{"buggy_code": ["# -*- coding: utf-8 -*-\n\"\"\"\nUnit tests for instructor.api methods.\n\"\"\"\nimport datetime\nimport ddt\nimport functools\nimport random\nimport pytz\nimport io\nimport json\nimport shutil\nimport tempfile\nfrom urllib import quote\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.core import mail\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import RequestFactory, TestCase\nfrom django.test.utils import override_settings\nfrom django.utils.timezone import utc\nfrom django.utils.translation import ugettext as _\n\nfrom mock import Mock, patch\nfrom nose.tools import raises\nfrom nose.plugins.attrib import attr\nfrom opaque_keys.edx.locations import SlashSeparatedCourseKey\nfrom opaque_keys.edx.locator import UsageKey\nfrom xmodule.modulestore import ModuleStoreEnum\n\nfrom bulk_email.models import BulkEmailFlag\nfrom course_modes.models import CourseMode\nfrom courseware.models import StudentModule\nfrom courseware.tests.factories import StaffFactory, InstructorFactory, BetaTesterFactory, UserProfileFactory\nfrom courseware.tests.helpers import LoginEnrollmentTestCase\nfrom django_comment_common.models import FORUM_ROLE_COMMUNITY_TA\nfrom django_comment_common.utils import seed_permissions_roles\nfrom microsite_configuration import microsite\nfrom shoppingcart.models import (\n    RegistrationCodeRedemption, Order, CouponRedemption,\n    PaidCourseRegistration, Coupon, Invoice, CourseRegistrationCode, CourseRegistrationCodeInvoiceItem,\n    InvoiceTransaction)\nfrom shoppingcart.pdf import PDFInvoice\nfrom student.models import (\n    CourseEnrollment, CourseEnrollmentAllowed, NonExistentCourseError,\n    ManualEnrollmentAudit, UNENROLLED_TO_ENROLLED, ENROLLED_TO_UNENROLLED,\n    ALLOWEDTOENROLL_TO_UNENROLLED, ENROLLED_TO_ENROLLED, UNENROLLED_TO_ALLOWEDTOENROLL,\n    UNENROLLED_TO_UNENROLLED, ALLOWEDTOENROLL_TO_ENROLLED\n)\nfrom student.tests.factories import UserFactory, CourseModeFactory, AdminFactory\nfrom student.roles import CourseBetaTesterRole, CourseSalesAdminRole, CourseFinanceAdminRole, CourseInstructorRole\nfrom xmodule.modulestore.tests.django_utils import SharedModuleStoreTestCase, ModuleStoreTestCase\nfrom xmodule.modulestore.tests.factories import CourseFactory, ItemFactory\nfrom xmodule.fields import Date\n\nfrom courseware.models import StudentFieldOverride\n\nimport instructor_task.api\nimport instructor.views.api\nfrom instructor.views.api import require_finance_admin\nfrom instructor.tests.utils import FakeContentTask, FakeEmail, FakeEmailInfo\nfrom instructor.views.api import _split_input_list, common_exceptions_400, generate_unique_password\nfrom instructor_task.api_helper import AlreadyRunningError\nfrom certificates.tests.factories import GeneratedCertificateFactory\nfrom certificates.models import CertificateStatuses\n\nfrom openedx.core.djangoapps.course_groups.cohorts import set_course_cohort_settings\nfrom openedx.core.lib.xblock_utils import grade_histogram\n\nfrom .test_tools import msk_from_problem_urlname\n\nDATE_FIELD = Date()\nEXPECTED_CSV_HEADER = (\n    '\"code\",\"redeem_code_url\",\"course_id\",\"company_name\",\"created_by\",\"redeemed_by\",\"invoice_id\",\"purchaser\",'\n    '\"customer_reference_number\",\"internal_reference\"'\n)\nEXPECTED_COUPON_CSV_HEADER = '\"Coupon Code\",\"Course Id\",\"% Discount\",\"Description\",\"Expiration Date\",' \\\n                             '\"Is Active\",\"Code Redeemed Count\",\"Total Discounted Seats\",\"Total Discounted Amount\"'\n\n# ddt data for test cases involving reports\nREPORTS_DATA = (\n    {\n        'report_type': 'grade',\n        'instructor_api_endpoint': 'calculate_grades_csv',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_grades_csv',\n        'extra_instructor_api_kwargs': {}\n    },\n    {\n        'report_type': 'enrolled learner profile',\n        'instructor_api_endpoint': 'get_students_features',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_students_features_csv',\n        'extra_instructor_api_kwargs': {'csv': '/csv'}\n    },\n    {\n        'report_type': 'detailed enrollment',\n        'instructor_api_endpoint': 'get_enrollment_report',\n        'task_api_endpoint': 'instructor_task.api.submit_detailed_enrollment_features_csv',\n        'extra_instructor_api_kwargs': {}\n    },\n    {\n        'report_type': 'enrollment',\n        'instructor_api_endpoint': 'get_students_who_may_enroll',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_may_enroll_csv',\n        'extra_instructor_api_kwargs': {},\n    },\n    {\n        'report_type': 'proctored exam results',\n        'instructor_api_endpoint': 'get_proctored_exam_results',\n        'task_api_endpoint': 'instructor_task.api.submit_proctored_exam_results_report',\n        'extra_instructor_api_kwargs': {},\n    },\n    {\n        'report_type': 'problem responses',\n        'instructor_api_endpoint': 'get_problem_responses',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_problem_responses_csv',\n        'extra_instructor_api_kwargs': {},\n    }\n)\n\n# ddt data for test cases involving executive summary report\nEXECUTIVE_SUMMARY_DATA = (\n    {\n        'report_type': 'executive summary',\n        'instructor_api_endpoint': 'get_exec_summary_report',\n        'task_api_endpoint': 'instructor_task.api.submit_executive_summary_report',\n        'extra_instructor_api_kwargs': {}\n    },\n)\n\n\n@common_exceptions_400\ndef view_success(request):  # pylint: disable=unused-argument\n    \"A dummy view for testing that returns a simple HTTP response\"\n    return HttpResponse('success')\n\n\n@common_exceptions_400\ndef view_user_doesnotexist(request):  # pylint: disable=unused-argument\n    \"A dummy view that raises a User.DoesNotExist exception\"\n    raise User.DoesNotExist()\n\n\n@common_exceptions_400\ndef view_alreadyrunningerror(request):  # pylint: disable=unused-argument\n    \"A dummy view that raises an AlreadyRunningError exception\"\n    raise AlreadyRunningError()\n\n\n@attr('shard_1')\nclass TestCommonExceptions400(TestCase):\n    \"\"\"\n    Testing the common_exceptions_400 decorator.\n    \"\"\"\n\n    def setUp(self):\n        super(TestCommonExceptions400, self).setUp()\n        self.request = Mock(spec=HttpRequest)\n        self.request.META = {}\n\n    def test_happy_path(self):\n        resp = view_success(self.request)\n        self.assertEqual(resp.status_code, 200)\n\n    def test_user_doesnotexist(self):\n        self.request.is_ajax.return_value = False\n        resp = view_user_doesnotexist(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        self.assertIn(\"User does not exist\", resp.content)\n\n    def test_user_doesnotexist_ajax(self):\n        self.request.is_ajax.return_value = True\n        resp = view_user_doesnotexist(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        result = json.loads(resp.content)\n        self.assertIn(\"User does not exist\", result[\"error\"])\n\n    def test_alreadyrunningerror(self):\n        self.request.is_ajax.return_value = False\n        resp = view_alreadyrunningerror(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        self.assertIn(\"Task is already running\", resp.content)\n\n    def test_alreadyrunningerror_ajax(self):\n        self.request.is_ajax.return_value = True\n        resp = view_alreadyrunningerror(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        result = json.loads(resp.content)\n        self.assertIn(\"Task is already running\", result[\"error\"])\n\n\n@attr('shard_1')\n@patch('bulk_email.models.html_to_text', Mock(return_value='Mocking CourseEmail.text_message', autospec=True))\nclass TestInstructorAPIDenyLevels(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Ensure that users cannot access endpoints they shouldn't be able to.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIDenyLevels, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.problem_location = msk_from_problem_urlname(\n            cls.course.id,\n            'robot-some-problem-urlname'\n        )\n        cls.problem_urlname = cls.problem_location.to_deprecated_string()\n        BulkEmailFlag.objects.create(enabled=True, require_course_email_auth=False)\n\n    @classmethod\n    def tearDownClass(cls):\n        super(TestInstructorAPIDenyLevels, cls).tearDownClass()\n        BulkEmailFlag.objects.all().delete()\n\n    def setUp(self):\n        super(TestInstructorAPIDenyLevels, self).setUp()\n        self.user = UserFactory.create()\n        CourseEnrollment.enroll(self.user, self.course.id)\n\n        _module = StudentModule.objects.create(\n            student=self.user,\n            course_id=self.course.id,\n            module_state_key=self.problem_location,\n            state=json.dumps({'attempts': 10}),\n        )\n\n        # Endpoints that only Staff or Instructors can access\n        self.staff_level_endpoints = [\n            ('students_update_enrollment',\n             {'identifiers': 'foo@example.org', 'action': 'enroll'}),\n            ('get_grading_config', {}),\n            ('get_students_features', {}),\n            ('get_student_progress_url', {'unique_student_identifier': self.user.username}),\n            ('reset_student_attempts',\n             {'problem_to_reset': self.problem_urlname, 'unique_student_identifier': self.user.email}),\n            ('update_forum_role_membership',\n             {'unique_student_identifier': self.user.email, 'rolename': 'Moderator', 'action': 'allow'}),\n            ('list_forum_members', {'rolename': FORUM_ROLE_COMMUNITY_TA}),\n            ('send_email', {'send_to': '[\"staff\"]', 'subject': 'test', 'message': 'asdf'}),\n            ('list_instructor_tasks', {}),\n            ('list_background_email_tasks', {}),\n            ('list_report_downloads', {}),\n            ('list_financial_report_downloads', {}),\n            ('calculate_grades_csv', {}),\n            ('get_students_features', {}),\n            ('get_enrollment_report', {}),\n            ('get_students_who_may_enroll', {}),\n            ('get_exec_summary_report', {}),\n            ('get_proctored_exam_results', {}),\n            ('get_problem_responses', {}),\n            ('export_ora2_data', {}),\n        ]\n        # Endpoints that only Instructors can access\n        self.instructor_level_endpoints = [\n            ('bulk_beta_modify_access', {'identifiers': 'foo@example.org', 'action': 'add'}),\n            ('modify_access', {'unique_student_identifier': self.user.email, 'rolename': 'beta', 'action': 'allow'}),\n            ('list_course_role_members', {'rolename': 'beta'}),\n            ('rescore_problem',\n             {'problem_to_reset': self.problem_urlname, 'unique_student_identifier': self.user.email}),\n        ]\n\n    def _access_endpoint(self, endpoint, args, status_code, msg):\n        \"\"\"\n        Asserts that accessing the given `endpoint` gets a response of `status_code`.\n\n        endpoint: string, endpoint for instructor dash API\n        args: dict, kwargs for `reverse` call\n        status_code: expected HTTP status code response\n        msg: message to display if assertion fails.\n        \"\"\"\n        url = reverse(endpoint, kwargs={'course_id': self.course.id.to_deprecated_string()})\n        if endpoint in ['send_email', 'students_update_enrollment', 'bulk_beta_modify_access']:\n            response = self.client.post(url, args)\n        else:\n            response = self.client.get(url, args)\n        self.assertEqual(\n            response.status_code,\n            status_code,\n            msg=msg\n        )\n\n    def test_student_level(self):\n        \"\"\"\n        Ensure that an enrolled student can't access staff or instructor endpoints.\n        \"\"\"\n        self.client.login(username=self.user.username, password='test')\n\n        for endpoint, args in self.staff_level_endpoints:\n            self._access_endpoint(\n                endpoint,\n                args,\n                403,\n                \"Student should not be allowed to access endpoint \" + endpoint\n            )\n\n        for endpoint, args in self.instructor_level_endpoints:\n            self._access_endpoint(\n                endpoint,\n                args,\n                403,\n                \"Student should not be allowed to access endpoint \" + endpoint\n            )\n\n    def _access_problem_responses_endpoint(self, msg):\n        \"\"\"\n        Access endpoint for problem responses report, ensuring that\n        UsageKey.from_string returns a problem key that the endpoint\n        can work with.\n\n        msg: message to display if assertion fails.\n        \"\"\"\n        mock_problem_key = Mock(return_value=u'')\n        mock_problem_key.course_key = self.course.id\n        with patch.object(UsageKey, 'from_string') as patched_method:\n            patched_method.return_value = mock_problem_key\n            self._access_endpoint('get_problem_responses', {}, 200, msg)\n\n    def test_staff_level(self):\n        \"\"\"\n        Ensure that a staff member can't access instructor endpoints.\n        \"\"\"\n        staff_member = StaffFactory(course_key=self.course.id)\n        CourseEnrollment.enroll(staff_member, self.course.id)\n        CourseFinanceAdminRole(self.course.id).add_users(staff_member)\n        self.client.login(username=staff_member.username, password='test')\n        # Try to promote to forums admin - not working\n        # update_forum_role(self.course.id, staff_member, FORUM_ROLE_ADMINISTRATOR, 'allow')\n\n        for endpoint, args in self.staff_level_endpoints:\n            expected_status = 200\n\n            # TODO: make these work\n            if endpoint in ['update_forum_role_membership', 'list_forum_members']:\n                continue\n            elif endpoint == 'get_problem_responses':\n                self._access_problem_responses_endpoint(\n                    \"Staff member should be allowed to access endpoint \" + endpoint\n                )\n                continue\n            self._access_endpoint(\n                endpoint,\n                args,\n                expected_status,\n                \"Staff member should be allowed to access endpoint \" + endpoint\n            )\n\n        for endpoint, args in self.instructor_level_endpoints:\n            self._access_endpoint(\n                endpoint,\n                args,\n                403,\n                \"Staff member should not be allowed to access endpoint \" + endpoint\n            )\n\n    def test_instructor_level(self):\n        \"\"\"\n        Ensure that an instructor member can access all endpoints.\n        \"\"\"\n        inst = InstructorFactory(course_key=self.course.id)\n        CourseEnrollment.enroll(inst, self.course.id)\n\n        CourseFinanceAdminRole(self.course.id).add_users(inst)\n        self.client.login(username=inst.username, password='test')\n\n        for endpoint, args in self.staff_level_endpoints:\n            expected_status = 200\n\n            # TODO: make these work\n            if endpoint in ['update_forum_role_membership']:\n                continue\n            elif endpoint == 'get_problem_responses':\n                self._access_problem_responses_endpoint(\n                    \"Instructor should be allowed to access endpoint \" + endpoint\n                )\n                continue\n            self._access_endpoint(\n                endpoint,\n                args,\n                expected_status,\n                \"Instructor should be allowed to access endpoint \" + endpoint\n            )\n\n        for endpoint, args in self.instructor_level_endpoints:\n            expected_status = 200\n\n            # TODO: make this work\n            if endpoint in ['rescore_problem']:\n                continue\n            self._access_endpoint(\n                endpoint,\n                args,\n                expected_status,\n                \"Instructor should be allowed to access endpoint \" + endpoint\n            )\n\n\n@attr('shard_1')\n@patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\nclass TestInstructorAPIBulkAccountCreationAndEnrollment(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test Bulk account creation and enrollment from csv file\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIBulkAccountCreationAndEnrollment, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n        # Create a course with mode 'audit'\n        cls.audit_course = CourseFactory.create()\n        CourseModeFactory.create(course_id=cls.audit_course.id, mode_slug=CourseMode.AUDIT)\n\n        cls.url = reverse(\n            'register_and_enroll_students', kwargs={'course_id': unicode(cls.course.id)}\n        )\n        cls.audit_course_url = reverse(\n            'register_and_enroll_students', kwargs={'course_id': unicode(cls.audit_course.id)}\n        )\n\n    def setUp(self):\n        super(TestInstructorAPIBulkAccountCreationAndEnrollment, self).setUp()\n\n        # Create a course with mode 'honor' and with price\n        self.white_label_course = CourseFactory.create()\n        self.white_label_course_mode = CourseModeFactory.create(\n            course_id=self.white_label_course.id,\n            mode_slug=CourseMode.HONOR,\n            min_price=10,\n            suggested_prices='10',\n        )\n\n        self.white_label_course_url = reverse(\n            'register_and_enroll_students', kwargs={'course_id': unicode(self.white_label_course.id)}\n        )\n\n        self.request = RequestFactory().request()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.audit_course_instructor = InstructorFactory(course_key=self.audit_course.id)\n        self.white_label_course_instructor = InstructorFactory(course_key=self.white_label_course.id)\n\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.not_enrolled_student = UserFactory(\n            username='NotEnrolledStudent',\n            email='nonenrolled@test.com',\n            first_name='NotEnrolled',\n            last_name='Student'\n        )\n\n    @patch('instructor.views.api.log.info')\n    def test_account_creation_and_enrollment_with_csv(self, info_log):\n        \"\"\"\n        Happy path test to create a single new user\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1,tester1,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # test the log for email that's send to new created user.\n        info_log.assert_called_with('email sent to new created user at %s', 'test_student@example.com')\n\n    @patch('instructor.views.api.log.info')\n    def test_account_creation_and_enrollment_with_csv_with_blank_lines(self, info_log):\n        \"\"\"\n        Happy path test to create a single new user\n        \"\"\"\n        csv_content = \"\\ntest_student@example.com,test_student_1,tester1,USA\\n\\n\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # test the log for email that's send to new created user.\n        info_log.assert_called_with('email sent to new created user at %s', 'test_student@example.com')\n\n    @patch('instructor.views.api.log.info')\n    def test_email_and_username_already_exist(self, info_log):\n        \"\"\"\n        If the email address and username already exists\n        and the user is enrolled in the course, do nothing (including no email gets sent out)\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student@example.com,test_student_1,tester2,US\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # test the log for email that's send to new created user.\n        info_log.assert_called_with(\n            u\"user already exists with username '%s' and email '%s'\",\n            'test_student_1',\n            'test_student@example.com'\n        )\n\n    def test_file_upload_type_not_csv(self):\n        \"\"\"\n        Try uploading some non-CSV file and verify that it is rejected\n        \"\"\"\n        uploaded_file = SimpleUploadedFile(\"temp.jpg\", io.BytesIO(b\"some initial binary data: \\x00\\x01\").read())\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['general_errors'][0]['response'], 'Make sure that the file you upload is in CSV format with no extraneous characters or rows.')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_bad_file_upload_type(self):\n        \"\"\"\n        Try uploading some non-CSV file and verify that it is rejected\n        \"\"\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", io.BytesIO(b\"some initial binary data: \\x00\\x01\").read())\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['general_errors'][0]['response'], 'Could not read uploaded file.')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_insufficient_data(self):\n        \"\"\"\n        Try uploading a CSV file which does not have the exact four columns of data\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1\\n\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 1)\n        self.assertEquals(data['general_errors'][0]['response'], 'Data in row #1 must have exactly four columns: email, username, full name, and country')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_invalid_email_in_csv(self):\n        \"\"\"\n        Test failure case of a poorly formatted email field\n        \"\"\"\n        csv_content = \"test_student.example.com,test_student_1,tester1,USA\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        data = json.loads(response.content)\n        self.assertEqual(response.status_code, 200)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'Invalid email {0}.'.format('test_student.example.com'))\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    @patch('instructor.views.api.log.info')\n    def test_csv_user_exist_and_not_enrolled(self, info_log):\n        \"\"\"\n        If the email address and username already exists\n        and the user is not enrolled in the course, enrolled him/her and iterate to next one.\n        \"\"\"\n        csv_content = \"nonenrolled@test.com,NotEnrolledStudent,tester1,USA\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        info_log.assert_called_with(\n            u'user %s enrolled in the course %s',\n            u'NotEnrolledStudent',\n            self.course.id\n        )\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertTrue(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n    def test_user_with_already_existing_email_in_csv(self):\n        \"\"\"\n        If the email address already exists, but the username is different,\n        assume it is the correct user and just register the user in the course.\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student@example.com,test_student_2,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        warning_message = 'An account with email {email} exists but the provided username {username} ' \\\n                          'is different. Enrolling anyway with {email}.'.format(email='test_student@example.com', username='test_student_2')\n        self.assertNotEquals(len(data['warnings']), 0)\n        self.assertEquals(data['warnings'][0]['response'], warning_message)\n        user = User.objects.get(email='test_student@example.com')\n        self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertTrue(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n    def test_user_with_already_existing_username_in_csv(self):\n        \"\"\"\n        If the username already exists (but not the email),\n        assume it is a different user and fail to create the new account.\n        \"\"\"\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student2@example.com,test_student_1,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'Username {user} already exists.'.format(user='test_student_1'))\n\n    def test_csv_file_not_attached(self):\n        \"\"\"\n        Test when the user does not attach a file\n        \"\"\"\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student2@example.com,test_student_1,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n\n        response = self.client.post(self.url, {'file_not_found': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['general_errors'][0]['response'], 'File is not attached.')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_raising_exception_in_auto_registration_and_enrollment_case(self):\n        \"\"\"\n        Test that exceptions are handled well\n        \"\"\"\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student2@example.com,test_student_1,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        with patch('instructor.views.api.create_manual_course_enrollment') as mock:\n            mock.side_effect = NonExistentCourseError()\n            response = self.client.post(self.url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'NonExistentCourseError')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_generate_unique_password(self):\n        \"\"\"\n        generate_unique_password should generate a unique password string that excludes certain characters.\n        \"\"\"\n        password = generate_unique_password([], 12)\n        self.assertEquals(len(password), 12)\n        for letter in password:\n            self.assertNotIn(letter, 'aAeEiIoOuU1l')\n\n    def test_users_created_and_enrolled_successfully_if_others_fail(self):\n\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student3@example.com,test_student_1,tester3,CA\\n\" \\\n                      \"test_student2@example.com,test_student_2,tester2,USA\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'Username {user} already exists.'.format(user='test_student_1'))\n        self.assertTrue(User.objects.filter(username='test_student_1', email='test_student1@example.com').exists())\n        self.assertTrue(User.objects.filter(username='test_student_2', email='test_student2@example.com').exists())\n        self.assertFalse(User.objects.filter(email='test_student3@example.com').exists())\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 2)\n\n    @patch.object(instructor.views.api, 'generate_random_string',\n                  Mock(side_effect=['first', 'first', 'second']))\n    def test_generate_unique_password_no_reuse(self):\n        \"\"\"\n        generate_unique_password should generate a unique password string that hasn't been generated before.\n        \"\"\"\n        generated_password = ['first']\n        password = generate_unique_password(generated_password, 12)\n        self.assertNotEquals(password, 'first')\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': False})\n    def test_allow_automated_signups_flag_not_set(self):\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEquals(response.status_code, 403)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\n    def test_audit_enrollment_mode(self):\n        \"\"\"\n        Test that enrollment mode for audit courses (paid courses) is 'audit'.\n        \"\"\"\n        # Login Audit Course instructor\n        self.client.login(username=self.audit_course_instructor.username, password='test')\n\n        csv_content = \"test_student_wl@example.com,test_student_wl,Test Student,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.audit_course_url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # Verify enrollment modes to be 'audit'\n        for enrollment in manual_enrollments:\n            self.assertEqual(enrollment.enrollment.mode, CourseMode.AUDIT)\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\n    def test_honor_enrollment_mode(self):\n        \"\"\"\n        Test that enrollment mode for unpaid honor courses is 'honor'.\n        \"\"\"\n        # Remove white label course price\n        self.white_label_course_mode.min_price = 0\n        self.white_label_course_mode.suggested_prices = ''\n        self.white_label_course_mode.save()  # pylint: disable=no-member\n\n        # Login Audit Course instructor\n        self.client.login(username=self.white_label_course_instructor.username, password='test')\n\n        csv_content = \"test_student_wl@example.com,test_student_wl,Test Student,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.white_label_course_url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # Verify enrollment modes to be 'honor'\n        for enrollment in manual_enrollments:\n            self.assertEqual(enrollment.enrollment.mode, CourseMode.HONOR)\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\n    def test_default_shopping_cart_enrollment_mode_for_white_label(self):\n        \"\"\"\n        Test that enrollment mode for white label courses (paid courses) is DEFAULT_SHOPPINGCART_MODE_SLUG.\n        \"\"\"\n        # Login white label course instructor\n        self.client.login(username=self.white_label_course_instructor.username, password='test')\n\n        csv_content = \"test_student_wl@example.com,test_student_wl,Test Student,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.white_label_course_url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # Verify enrollment modes to be CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG\n        for enrollment in manual_enrollments:\n            self.assertEqual(enrollment.enrollment.mode, CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG)\n\n\n@attr('shard_1')\n@ddt.ddt\nclass TestInstructorAPIEnrollment(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test enrollment modification endpoint.\n\n    This test does NOT exhaustively test state changes, that is the\n    job of test_enrollment. This tests the response and action switch.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIEnrollment, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n        # Email URL values\n        cls.site_name = microsite.get_value(\n            'SITE_NAME',\n            settings.SITE_NAME\n        )\n        cls.about_path = '/courses/{}/about'.format(cls.course.id)\n        cls.course_path = '/courses/{}/'.format(cls.course.id)\n\n    def setUp(self):\n        super(TestInstructorAPIEnrollment, self).setUp()\n\n        self.request = RequestFactory().request()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.enrolled_student = UserFactory(username='EnrolledStudent', first_name='Enrolled', last_name='Student')\n        CourseEnrollment.enroll(\n            self.enrolled_student,\n            self.course.id\n        )\n        self.notenrolled_student = UserFactory(username='NotEnrolledStudent', first_name='NotEnrolled',\n                                               last_name='Student')\n\n        # Create invited, but not registered, user\n        cea = CourseEnrollmentAllowed(email='robot-allowed@robot.org', course_id=self.course.id)\n        cea.save()\n        self.allowed_email = 'robot-allowed@robot.org'\n\n        self.notregistered_email = 'robot-not-an-email-yet@robot.org'\n        self.assertEqual(User.objects.filter(email=self.notregistered_email).count(), 0)\n\n        # uncomment to enable enable printing of large diffs\n        # from failed assertions in the event of a test failure.\n        # (comment because pylint C0103(invalid-name))\n        # self.maxDiff = None\n\n    def test_missing_params(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_bad_action(self):\n        \"\"\" Test with an invalid action. \"\"\"\n        action = 'robot-not-an-action'\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.enrolled_student.email, 'action': action})\n        self.assertEqual(response.status_code, 400)\n\n    def test_invalid_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': 'percivaloctavius@', 'action': 'enroll', 'email_students': False})\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            'auto_enroll': False,\n            \"results\": [\n                {\n                    \"identifier\": 'percivaloctavius@',\n                    \"invalidIdentifier\": True,\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_invalid_username(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': 'percivaloctavius', 'action': 'enroll', 'email_students': False})\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            'auto_enroll': False,\n            \"results\": [\n                {\n                    \"identifier\": 'percivaloctavius',\n                    \"invalidIdentifier\": True,\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_enroll_with_username(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.username, 'action': 'enroll',\n                                          'email_students': False})\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            'auto_enroll': False,\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.username,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_enroll_without_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'enroll',\n                                          'email_students': False})\n        print \"type(self.notenrolled_student.email): {}\".format(type(self.notenrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now enrolled\n        user = User.objects.get(email=self.notenrolled_student.email)\n        self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    @ddt.data('http', 'https')\n    def test_enroll_with_email(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notenrolled_student.email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n\n        print \"type(self.notenrolled_student.email): {}\".format(type(self.notenrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now enrolled\n        user = User.objects.get(email=self.notenrolled_student.email)\n        self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been enrolled in {}'.format(self.course.display_name)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear NotEnrolled Student\\n\\nYou have been enrolled in {} \"\n            \"at edx.org by a member of the course staff. \"\n            \"The course should now appear on your edx.org dashboard.\\n\\n\"\n            \"To start accessing course materials, please visit \"\n            \"{proto}://{site}{course_path}\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to NotEnrolled Student\".format(\n                self.course.display_name,\n                proto=protocol, site=self.site_name, course_path=self.course_path\n            )\n        )\n\n    @ddt.data('http', 'https')\n    def test_enroll_with_email_not_registered(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been invited to register for {}'.format(self.course.display_name)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {} at edx.org by a member of the course staff.\\n\\n\"\n            \"To finish your registration, please visit {proto}://{site}/register and fill out the \"\n            \"registration form making sure to use robot-not-an-email-yet@robot.org in the E-mail field.\\n\"\n            \"Once you have registered and activated your account, \"\n            \"visit {proto}://{site}{about_path} to join the course.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                self.course.display_name, proto=protocol, site=self.site_name, about_path=self.about_path\n            )\n        )\n\n    @ddt.data('http', 'https')\n    @patch.dict(settings.FEATURES, {'ENABLE_MKTG_SITE': True})\n    def test_enroll_email_not_registered_mktgsite(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name}\"\n            \" at edx.org by a member of the course staff.\\n\\n\"\n            \"To finish your registration, please visit {proto}://{site}/register and fill out the registration form \"\n            \"making sure to use robot-not-an-email-yet@robot.org in the E-mail field.\\n\"\n            \"You can then enroll in {display_name}.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                display_name=self.course.display_name, proto=protocol, site=self.site_name\n            )\n        )\n\n    @ddt.data('http', 'https')\n    def test_enroll_with_email_not_registered_autoenroll(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True,\n                  'auto_enroll': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        print \"type(self.notregistered_email): {}\".format(type(self.notregistered_email))\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been invited to register for {}'.format(self.course.display_name)\n        )\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name}\"\n            \" at edx.org by a member of the course staff.\\n\\n\"\n            \"To finish your registration, please visit {proto}://{site}/register and fill out the registration form \"\n            \"making sure to use robot-not-an-email-yet@robot.org in the E-mail field.\\n\"\n            \"Once you have registered and activated your account,\"\n            \" you will see {display_name} listed on your dashboard.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                proto=protocol, site=self.site_name, display_name=self.course.display_name\n            )\n        )\n\n    def test_unenroll_without_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.enrolled_student.email, 'action': 'unenroll',\n                                          'email_students': False})\n        print \"type(self.enrolled_student.email): {}\".format(type(self.enrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now unenrolled\n        user = User.objects.get(email=self.enrolled_student.email)\n        self.assertFalse(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.enrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ENROLLED_TO_UNENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_unenroll_with_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.enrolled_student.email, 'action': 'unenroll',\n                                          'email_students': True})\n        print \"type(self.enrolled_student.email): {}\".format(type(self.enrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now unenrolled\n        user = User.objects.get(email=self.enrolled_student.email)\n        self.assertFalse(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.enrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ENROLLED_TO_UNENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been un-enrolled from {display_name}'.format(display_name=self.course.display_name,)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear Enrolled Student\\n\\nYou have been un-enrolled in {display_name} \"\n            \"at edx.org by a member of the course staff. \"\n            \"The course will no longer appear on your edx.org dashboard.\\n\\n\"\n            \"Your other courses have not been affected.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to Enrolled Student\".format(\n                display_name=self.course.display_name,\n            )\n        )\n\n    def test_unenroll_with_email_allowed_student(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.allowed_email, 'action': 'unenroll', 'email_students': True})\n        print \"type(self.allowed_email): {}\".format(type(self.allowed_email))\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.allowed_email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": True,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ALLOWEDTOENROLL_TO_UNENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been un-enrolled from {display_name}'.format(display_name=self.course.display_name,)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear Student,\\n\\nYou have been un-enrolled from course {display_name} by a member of the course staff. \"\n            \"Please disregard the invitation previously sent.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-allowed@robot.org\".format(\n                display_name=self.course.display_name,\n            )\n        )\n\n    @ddt.data('http', 'https')\n    @patch('instructor.enrollment.uses_shib')\n    def test_enroll_with_email_not_registered_with_shib(self, protocol, mock_uses_shib):\n        mock_uses_shib.return_value = True\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to register for {display_name}'.format(display_name=self.course.display_name,)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name} at edx.org by a member of the course staff.\\n\\n\"\n            \"To access the course visit {proto}://{site}{about_path} and register for the course.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                proto=protocol, site=self.site_name, about_path=self.about_path,\n                display_name=self.course.display_name,\n            )\n        )\n\n    @patch('instructor.enrollment.uses_shib')\n    @patch.dict(settings.FEATURES, {'ENABLE_MKTG_SITE': True})\n    def test_enroll_email_not_registered_shib_mktgsite(self, mock_uses_shib):\n        # Try with marketing site enabled and shib on\n        mock_uses_shib.return_value = True\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        # Try with marketing site enabled\n        with patch.dict('django.conf.settings.FEATURES', {'ENABLE_MKTG_SITE': True}):\n            response = self.client.post(url, {'identifiers': self.notregistered_email, 'action': 'enroll',\n                                              'email_students': True})\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {} at edx.org by a member of the course staff.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                self.course.display_name,\n            )\n        )\n\n    @ddt.data('http', 'https')\n    @patch('instructor.enrollment.uses_shib')\n    def test_enroll_with_email_not_registered_with_shib_autoenroll(self, protocol, mock_uses_shib):\n        mock_uses_shib.return_value = True\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True,\n                  'auto_enroll': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        print \"type(self.notregistered_email): {}\".format(type(self.notregistered_email))\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to register for {display_name}'.format(display_name=self.course.display_name,)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name}\"\n            \" at edx.org by a member of the course staff.\\n\\n\"\n            \"To access the course visit {proto}://{site}{course_path} and login.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                display_name=self.course.display_name,\n                proto=protocol, site=self.site_name, course_path=self.course_path\n            )\n        )\n\n    def test_enroll_already_enrolled_student(self):\n        \"\"\"\n        Ensure that already enrolled \"verified\" students cannot be downgraded\n        to \"honor\"\n        \"\"\"\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        # make this enrollment \"verified\"\n        course_enrollment.mode = u'verified'\n        course_enrollment.save()\n        self.assertEqual(course_enrollment.mode, u'verified')\n\n        # now re-enroll the student through the instructor dash\n        self._change_student_enrollment(self.enrolled_student, self.course, 'enroll')\n\n        # affirm that the student is still in \"verified\" mode\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ENROLLED_TO_ENROLLED)\n        self.assertEqual(course_enrollment.mode, u\"verified\")\n\n    def create_paid_course(self):\n        \"\"\"\n        create paid course mode.\n        \"\"\"\n        paid_course = CourseFactory.create()\n        CourseModeFactory.create(course_id=paid_course.id, min_price=50, mode_slug=CourseMode.HONOR)\n        CourseInstructorRole(paid_course.id).add_users(self.instructor)\n        return paid_course\n\n    def test_reason_field_should_not_be_empty(self):\n        \"\"\"\n        test to check that reason field should not be empty when\n        manually enrolling the students for the paid courses.\n        \"\"\"\n        paid_course = self.create_paid_course()\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': False,\n                  'auto_enroll': False}\n        response = self.client.post(url, params)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"error\": True\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_unenrolled_allowed_to_enroll_user(self):\n        \"\"\"\n        test to unenroll allow to enroll user.\n        \"\"\"\n        paid_course = self.create_paid_course()\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': False,\n                  'auto_enroll': False, 'reason': 'testing..'}\n        response = self.client.post(url, params)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(response.status_code, 200)\n\n        # now registered the user\n        UserFactory(email=self.notregistered_email)\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': False,\n                  'auto_enroll': False, 'reason': 'testing'}\n        response = self.client.post(url, params)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 2)\n        self.assertEqual(manual_enrollments[1].state_transition, ALLOWEDTOENROLL_TO_ENROLLED)\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notregistered_email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": True,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": True,\n                    }\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_unenrolled_already_not_enrolled_user(self):\n        \"\"\"\n        test unenrolled user already not enrolled in a course.\n        \"\"\"\n        paid_course = self.create_paid_course()\n        course_enrollment = CourseEnrollment.objects.filter(\n            user__email=self.notregistered_email, course_id=paid_course.id\n        )\n        self.assertEqual(course_enrollment.count(), 0)\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'unenroll', 'email_students': False,\n                  'auto_enroll': False, 'reason': 'testing'}\n\n        response = self.client.post(url, params)\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notregistered_email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_UNENROLLED)\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_unenroll_and_enroll_verified(self):\n        \"\"\"\n        Test that unenrolling and enrolling a student from a verified track\n        results in that student being in the default track\n        \"\"\"\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        # upgrade enrollment\n        course_enrollment.mode = u'verified'\n        course_enrollment.save()\n        self.assertEqual(course_enrollment.mode, u'verified')\n\n        self._change_student_enrollment(self.enrolled_student, self.course, 'unenroll')\n\n        self._change_student_enrollment(self.enrolled_student, self.course, 'enroll')\n\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        self.assertEqual(course_enrollment.mode, CourseMode.DEFAULT_MODE_SLUG)\n\n    def _change_student_enrollment(self, user, course, action):\n        \"\"\"\n        Helper function that posts to 'students_update_enrollment' to change\n        a student's enrollment\n        \"\"\"\n        url = reverse(\n            'students_update_enrollment',\n            kwargs={'course_id': course.id.to_deprecated_string()},\n        )\n        params = {\n            'identifiers': user.email,\n            'action': action,\n            'email_students': True,\n            'reason': 'change user enrollment'\n        }\n        response = self.client.post(url, params)\n        self.assertEqual(response.status_code, 200)\n        return response\n\n\n@attr('shard_1')\n@ddt.ddt\nclass TestInstructorAPIBulkBetaEnrollment(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test bulk beta modify access endpoint.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIBulkBetaEnrollment, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        # Email URL values\n        cls.site_name = microsite.get_value(\n            'SITE_NAME',\n            settings.SITE_NAME\n        )\n        cls.about_path = '/courses/{}/about'.format(cls.course.id)\n        cls.course_path = '/courses/{}/'.format(cls.course.id)\n\n    def setUp(self):\n        super(TestInstructorAPIBulkBetaEnrollment, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.beta_tester = BetaTesterFactory(course_key=self.course.id)\n        CourseEnrollment.enroll(\n            self.beta_tester,\n            self.course.id\n        )\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))\n\n        self.notenrolled_student = UserFactory(username='NotEnrolledStudent')\n\n        self.notregistered_email = 'robot-not-an-email-yet@robot.org'\n        self.assertEqual(User.objects.filter(email=self.notregistered_email).count(), 0)\n\n        self.request = RequestFactory().request()\n\n        # uncomment to enable enable printing of large diffs\n        # from failed assertions in the event of a test failure.\n        # (comment because pylint C0103(invalid-name))\n        # self.maxDiff = None\n\n    def test_missing_params(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_bad_action(self):\n        \"\"\" Test with an invalid action. \"\"\"\n        action = 'robot-not-an-action'\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.beta_tester.email, 'action': action})\n        self.assertEqual(response.status_code, 400)\n\n    def add_notenrolled(self, response, identifier):\n        \"\"\"\n        Test Helper Method (not a test, called by other tests)\n\n        Takes a client response from a call to bulk_beta_modify_access with 'email_students': False,\n        and the student identifier (email or username) given as 'identifiers' in the request.\n\n        Asserts the reponse returns cleanly, that the student was added as a beta tester, and the\n        response properly contains their identifier, 'error': False, and 'userDoesNotExist': False.\n        Additionally asserts no email was sent.\n        \"\"\"\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.notenrolled_student))\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": identifier,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_add_notenrolled_email(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': False})\n        self.add_notenrolled(response, self.notenrolled_student.email)\n        self.assertFalse(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    def test_add_notenrolled_email_autoenroll(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': False, 'auto_enroll': True})\n        self.add_notenrolled(response, self.notenrolled_student.email)\n        self.assertTrue(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    def test_add_notenrolled_username(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.username, 'action': 'add', 'email_students': False})\n        self.add_notenrolled(response, self.notenrolled_student.username)\n        self.assertFalse(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    def test_add_notenrolled_username_autoenroll(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.username, 'action': 'add', 'email_students': False, 'auto_enroll': True})\n        self.add_notenrolled(response, self.notenrolled_student.username)\n        self.assertTrue(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    @ddt.data('http', 'https')\n    def test_add_notenrolled_with_email(self, protocol):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.notenrolled_student))\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to a beta test for {display_name}'.format(display_name=self.course.display_name,)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            u\"Dear {student_name}\\n\\nYou have been invited to be a beta tester \"\n            \"for {display_name} at edx.org by a member of the course staff.\\n\\n\"\n            \"Visit {proto}://{site}{about_path} to join \"\n            \"the course and begin the beta test.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {student_email}\".format(\n                display_name=self.course.display_name,\n                student_name=self.notenrolled_student.profile.name,\n                student_email=self.notenrolled_student.email,\n                proto=protocol,\n                site=self.site_name,\n                about_path=self.about_path\n            )\n        )\n\n    @ddt.data('http', 'https')\n    def test_add_notenrolled_with_email_autoenroll(self, protocol):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': True,\n                  'auto_enroll': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.notenrolled_student))\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to a beta test for {display_name}'.format(display_name=self.course.display_name)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            u\"Dear {student_name}\\n\\nYou have been invited to be a beta tester \"\n            \"for {display_name} at edx.org by a member of the course staff.\\n\\n\"\n            \"To start accessing course materials, please visit \"\n            \"{proto}://{site}{course_path}\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {student_email}\".format(\n                display_name=self.course.display_name,\n                student_name=self.notenrolled_student.profile.name,\n                student_email=self.notenrolled_student.email,\n                proto=protocol,\n                site=self.site_name,\n                course_path=self.course_path\n            )\n        )\n\n    @patch.dict(settings.FEATURES, {'ENABLE_MKTG_SITE': True})\n    def test_add_notenrolled_email_mktgsite(self):\n        # Try with marketing site enabled\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': True})\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\n            mail.outbox[0].body,\n            u\"Dear {}\\n\\nYou have been invited to be a beta tester \"\n            \"for {} at edx.org by a member of the course staff.\\n\\n\"\n            \"Visit edx.org to enroll in the course and begin the beta test.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {}\".format(\n                self.notenrolled_student.profile.name,\n                self.course.display_name,\n                self.notenrolled_student.email,\n            )\n        )\n\n    def test_enroll_with_email_not_registered(self):\n        # User doesn't exist\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.notregistered_email, 'action': 'add', 'email_students': True,\n                                     'reason': 'testing'})\n        self.assertEqual(response.status_code, 200)\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": self.notregistered_email,\n                    \"error\": True,\n                    \"userDoesNotExist\": True\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_remove_without_email(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.beta_tester.email, 'action': 'remove', 'email_students': False,\n                                     'reason': 'testing'})\n        self.assertEqual(response.status_code, 200)\n\n        # Works around a caching bug which supposedly can't happen in prod. The instance here is not ==\n        # the instance fetched from the email above which had its cache cleared\n        if hasattr(self.beta_tester, '_roles'):\n            del self.beta_tester._roles\n        self.assertFalse(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))\n\n        # test the response data\n        expected = {\n            \"action\": \"remove\",\n            \"results\": [\n                {\n                    \"identifier\": self.beta_tester.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_remove_with_email(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.beta_tester.email, 'action': 'remove', 'email_students': True,\n                                     'reason': 'testing'})\n        self.assertEqual(response.status_code, 200)\n\n        # Works around a caching bug which supposedly can't happen in prod. The instance here is not ==\n        # the instance fetched from the email above which had its cache cleared\n        if hasattr(self.beta_tester, '_roles'):\n            del self.beta_tester._roles\n        self.assertFalse(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))\n\n        # test the response data\n        expected = {\n            \"action\": \"remove\",\n            \"results\": [\n                {\n                    \"identifier\": self.beta_tester.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been removed from a beta test for {display_name}'.format(display_name=self.course.display_name,)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear {full_name}\\n\\nYou have been removed as a beta tester for \"\n            \"{display_name} at edx.org by a member of the course staff. \"\n            \"The course will remain on your dashboard, but you will no longer \"\n            \"be part of the beta testing group.\\n\\n\"\n            \"Your other courses have not been affected.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {email_address}\".format(\n                display_name=self.course.display_name,\n                full_name=self.beta_tester.profile.name,\n                email_address=self.beta_tester.email\n            )\n        )\n\n\n@attr('shard_1')\nclass TestInstructorAPILevelsAccess(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints whereby instructors can change permissions\n    of other users.\n\n    This test does NOT test whether the actions had an effect on the\n    database, that is the job of test_access.\n    This tests the response and action switch.\n    Actually, modify_access does not have a very meaningful\n    response yet, so only the status code is tested.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPILevelsAccess, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestInstructorAPILevelsAccess, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.other_instructor = InstructorFactory(course_key=self.course.id)\n        self.other_staff = StaffFactory(course_key=self.course.id)\n        self.other_user = UserFactory()\n\n    def test_modify_access_noparams(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_modify_access_bad_action(self):\n        \"\"\" Test with an invalid action parameter. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'staff',\n            'action': 'robot-not-an-action',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_modify_access_bad_role(self):\n        \"\"\" Test with an invalid action parameter. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'robot-not-a-roll',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_modify_access_allow(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_user.email,\n            'rolename': 'staff',\n            'action': 'allow',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_allow_with_uname(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_instructor.username,\n            'rolename': 'staff',\n            'action': 'allow',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_revoke(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'staff',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_revoke_with_username(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_staff.username,\n            'rolename': 'staff',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_with_fake_user(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': 'GandalfTheGrey',\n            'rolename': 'staff',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n        expected = {\n            'unique_student_identifier': 'GandalfTheGrey',\n            'userDoesNotExist': True,\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_modify_access_with_inactive_user(self):\n        self.other_user.is_active = False\n        self.other_user.save()  # pylint: disable=no-member\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_user.username,\n            'rolename': 'beta',\n            'action': 'allow',\n        })\n        self.assertEqual(response.status_code, 200)\n        expected = {\n            'unique_student_identifier': self.other_user.username,\n            'inactiveUser': True,\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_modify_access_revoke_not_allowed(self):\n        \"\"\" Test revoking access that a user does not have. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'instructor',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_revoke_self(self):\n        \"\"\"\n        Test that an instructor cannot remove instructor privelages from themself.\n        \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.instructor.email,\n            'rolename': 'instructor',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n        # check response content\n        expected = {\n            'unique_student_identifier': self.instructor.username,\n            'rolename': 'instructor',\n            'action': 'revoke',\n            'removingSelfAsInstructor': True,\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_list_course_role_members_noparams(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_list_course_role_members_bad_rolename(self):\n        \"\"\" Test with an invalid rolename parameter. \"\"\"\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'rolename': 'robot-not-a-rolename',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_list_course_role_members_staff(self):\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'rolename': 'staff',\n        })\n        self.assertEqual(response.status_code, 200)\n\n        # check response content\n        expected = {\n            'course_id': self.course.id.to_deprecated_string(),\n            'staff': [\n                {\n                    'username': self.other_staff.username,\n                    'email': self.other_staff.email,\n                    'first_name': self.other_staff.first_name,\n                    'last_name': self.other_staff.last_name,\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_list_course_role_members_beta(self):\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'rolename': 'beta',\n        })\n        self.assertEqual(response.status_code, 200)\n\n        # check response content\n        expected = {\n            'course_id': self.course.id.to_deprecated_string(),\n            'beta': []\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_update_forum_role_membership(self):\n        \"\"\"\n        Test update forum role membership with user's email and username.\n        \"\"\"\n\n        # Seed forum roles for course.\n        seed_permissions_roles(self.course.id)\n\n        for user in [self.instructor, self.other_user]:\n            for identifier_attr in [user.email, user.username]:\n                for rolename in [\"Administrator\", \"Moderator\", \"Community TA\"]:\n                    for action in [\"allow\", \"revoke\"]:\n                        self.assert_update_forum_role_membership(user, identifier_attr, rolename, action)\n\n    def assert_update_forum_role_membership(self, current_user, identifier, rolename, action):\n        \"\"\"\n        Test update forum role membership.\n        Get unique_student_identifier, rolename and action and update forum role.\n        \"\"\"\n        url = reverse('update_forum_role_membership', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(\n            url,\n            {\n                'unique_student_identifier': identifier,\n                'rolename': rolename,\n                'action': action,\n            }\n        )\n\n        # Status code should be 200.\n        self.assertEqual(response.status_code, 200)\n\n        user_roles = current_user.roles.filter(course_id=self.course.id).values_list(\"name\", flat=True)\n        if action == 'allow':\n            self.assertIn(rolename, user_roles)\n        elif action == 'revoke':\n            self.assertNotIn(rolename, user_roles)\n\n\n@attr('shard_1')\n@ddt.ddt\n@patch.dict('django.conf.settings.FEATURES', {'ENABLE_PAID_COURSE_REGISTRATION': True})\nclass TestInstructorAPILevelsDataDump(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints that show data without side effects.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPILevelsDataDump, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestInstructorAPILevelsDataDump, self).setUp()\n        self.course_mode = CourseMode(course_id=self.course.id,\n                                      mode_slug=\"honor\",\n                                      mode_display_name=\"honor cert\",\n                                      min_price=40)\n        self.course_mode.save()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n        self.cart = Order.get_cart_for_user(self.instructor)\n        self.coupon_code = 'abcde'\n        self.coupon = Coupon(code=self.coupon_code, description='testing code', course_id=self.course.id,\n                             percentage_discount=10, created_by=self.instructor, is_active=True)\n        self.coupon.save()\n\n        # Create testing invoice 1\n        self.sale_invoice_1 = Invoice.objects.create(\n            total_amount=1234.32, company_name='Test1', company_contact_name='TestName', company_contact_email='Test@company.com',\n            recipient_name='Testw', recipient_email='test1@test.com', customer_reference_number='2Fwe23S',\n            internal_reference=\"A\", course_id=self.course.id, is_valid=True\n        )\n        self.invoice_item = CourseRegistrationCodeInvoiceItem.objects.create(\n            invoice=self.sale_invoice_1,\n            qty=1,\n            unit_price=1234.32,\n            course_id=self.course.id\n        )\n\n        self.students = [UserFactory() for _ in xrange(6)]\n        for student in self.students:\n            CourseEnrollment.enroll(student, self.course.id)\n\n        self.students_who_may_enroll = self.students + [UserFactory() for _ in range(5)]\n        for student in self.students_who_may_enroll:\n            CourseEnrollmentAllowed.objects.create(\n                email=student.email, course_id=self.course.id\n            )\n\n    def register_with_redemption_code(self, user, code):\n        \"\"\"\n        enroll user using a registration code\n        \"\"\"\n        redeem_url = reverse('register_code_redemption', args=[code])\n        self.client.login(username=user.username, password='test')\n        response = self.client.get(redeem_url)\n        self.assertEquals(response.status_code, 200)\n        # check button text\n        self.assertTrue('Activate Course Enrollment' in response.content)\n\n        response = self.client.post(redeem_url)\n        self.assertEquals(response.status_code, 200)\n\n    def test_invalidate_sale_record(self):\n        \"\"\"\n        Testing the sale invalidating scenario.\n        \"\"\"\n        for i in range(2):\n            course_registration_code = CourseRegistrationCode(\n                code='sale_invoice{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        data = {'invoice_number': self.sale_invoice_1.id, 'event_type': \"invalidate\"}\n        url = reverse('sale_validation', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        self.assert_request_status_code(200, url, method=\"POST\", data=data)\n\n        #Now try to fetch data against not existing invoice number\n        test_data_1 = {'invoice_number': 100, 'event_type': \"invalidate\"}\n        self.assert_request_status_code(404, url, method=\"POST\", data=test_data_1)\n\n        # Now invalidate the same invoice number and expect an Bad request\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=data)\n        self.assertIn(\"The sale associated with this invoice has already been invalidated.\", response.content)\n\n        # now re_validate the invoice number\n        data['event_type'] = \"re_validate\"\n        self.assert_request_status_code(200, url, method=\"POST\", data=data)\n\n        # Now re_validate the same active invoice number and expect an Bad request\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=data)\n        self.assertIn(\"This invoice is already active.\", response.content)\n\n        test_data_2 = {'invoice_number': self.sale_invoice_1.id}\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=test_data_2)\n        self.assertIn(\"Missing required event_type parameter\", response.content)\n\n        test_data_3 = {'event_type': \"re_validate\"}\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=test_data_3)\n        self.assertIn(\"Missing required invoice_number parameter\", response.content)\n\n        # submitting invalid invoice number\n        data['invoice_number'] = 'testing'\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=data)\n        self.assertIn(\"invoice_number must be an integer, {value} provided\".format(value=data['invoice_number']), response.content)\n\n    def test_get_sale_order_records_features_csv(self):\n        \"\"\"\n        Test that the response from get_sale_order_records is in csv format.\n        \"\"\"\n        # add the coupon code for the course\n        coupon = Coupon(\n            code='test_code', description='test_description', course_id=self.course.id,\n            percentage_discount='10', created_by=self.instructor, is_active=True\n        )\n        coupon.save()\n        self.cart.order_type = 'business'\n        self.cart.save()\n        self.cart.add_billing_details(company_name='Test Company', company_contact_name='Test',\n                                      company_contact_email='test@123', recipient_name='R1',\n                                      recipient_email='', customer_reference_number='PO#23')\n\n        paid_course_reg_item = PaidCourseRegistration.add_to_order(\n            self.cart,\n            self.course.id,\n            mode_slug=CourseMode.HONOR\n        )\n        # update the quantity of the cart item paid_course_reg_item\n        resp = self.client.post(reverse('shoppingcart.views.update_user_cart'), {'ItemId': paid_course_reg_item.id, 'qty': '4'})\n        self.assertEqual(resp.status_code, 200)\n        # apply the coupon code to the item in the cart\n        resp = self.client.post(reverse('shoppingcart.views.use_code'), {'code': coupon.code})\n        self.assertEqual(resp.status_code, 200)\n        self.cart.purchase()\n        # get the updated item\n        item = self.cart.orderitem_set.all().select_subclasses()[0]\n        # get the redeemed coupon information\n        coupon_redemption = CouponRedemption.objects.select_related('coupon').filter(order=self.cart)\n\n        sale_order_url = reverse('get_sale_order_records', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(sale_order_url)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        self.assertIn('36', response.content.split('\\r\\n')[1])\n        self.assertIn(str(item.unit_cost), response.content.split('\\r\\n')[1],)\n        self.assertIn(str(item.list_price), response.content.split('\\r\\n')[1],)\n        self.assertIn(item.status, response.content.split('\\r\\n')[1],)\n        self.assertIn(coupon_redemption[0].coupon.code, response.content.split('\\r\\n')[1],)\n\n    def test_coupon_redeem_count_in_ecommerce_section(self):\n        \"\"\"\n        Test that checks the redeem count in the instructor_dashboard coupon section\n        \"\"\"\n        # add the coupon code for the course\n        coupon = Coupon(\n            code='test_code', description='test_description', course_id=self.course.id,\n            percentage_discount='10', created_by=self.instructor, is_active=True\n        )\n        coupon.save()\n\n        # Coupon Redeem Count only visible for Financial Admins.\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n\n        PaidCourseRegistration.add_to_order(self.cart, self.course.id)\n        # apply the coupon code to the item in the cart\n        resp = self.client.post(reverse('shoppingcart.views.use_code'), {'code': coupon.code})\n        self.assertEqual(resp.status_code, 200)\n\n        # URL for instructor dashboard\n        instructor_dashboard = reverse('instructor_dashboard', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        # visit the instructor dashboard page and\n        # check that the coupon redeem count should be 0\n        resp = self.client.get(instructor_dashboard)\n        self.assertEqual(resp.status_code, 200)\n        self.assertIn('Number Redeemed', resp.content)\n        self.assertIn('<td>0</td>', resp.content)\n\n        # now make the payment of your cart items\n        self.cart.purchase()\n        # visit the instructor dashboard page and\n        # check that the coupon redeem count should be 1\n        resp = self.client.get(instructor_dashboard)\n        self.assertEqual(resp.status_code, 200)\n\n        self.assertIn('Number Redeemed', resp.content)\n        self.assertIn('<td>1</td>', resp.content)\n\n    def test_get_sale_records_features_csv(self):\n        \"\"\"\n        Test that the response from get_sale_records is in csv format.\n        \"\"\"\n        for i in range(2):\n            course_registration_code = CourseRegistrationCode(\n                code='sale_invoice{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        url = reverse(\n            'get_sale_records',\n            kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n        response = self.client.get(url + '/csv', {})\n        self.assertEqual(response['Content-Type'], 'text/csv')\n\n    def test_get_sale_records_features_json(self):\n        \"\"\"\n        Test that the response from get_sale_records is in json format.\n        \"\"\"\n        for i in range(5):\n            course_registration_code = CourseRegistrationCode(\n                code='sale_invoice{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        url = reverse('get_sale_records', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('sale', res_json)\n\n        for res in res_json['sale']:\n            self.validate_sale_records_response(\n                res,\n                course_registration_code,\n                self.sale_invoice_1,\n                0,\n                invoice_item=self.invoice_item\n            )\n\n    def test_get_sale_records_features_with_multiple_invoices(self):\n        \"\"\"\n        Test that the response from get_sale_records is in json format for multiple invoices\n        \"\"\"\n        for i in range(5):\n            course_registration_code = CourseRegistrationCode(\n                code='qwerty{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        # Create test invoice 2\n        sale_invoice_2 = Invoice.objects.create(\n            total_amount=1234.32, company_name='Test1', company_contact_name='TestName', company_contact_email='Test@company.com',\n            recipient_name='Testw_2', recipient_email='test2@test.com', customer_reference_number='2Fwe23S',\n            internal_reference=\"B\", course_id=self.course.id\n        )\n\n        invoice_item_2 = CourseRegistrationCodeInvoiceItem.objects.create(\n            invoice=sale_invoice_2,\n            qty=1,\n            unit_price=1234.32,\n            course_id=self.course.id\n        )\n\n        for i in range(5):\n            course_registration_code = CourseRegistrationCode(\n                code='xyzmn{}'.format(i), course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor, invoice=sale_invoice_2, invoice_item=invoice_item_2, mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        url = reverse('get_sale_records', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('sale', res_json)\n\n        self.validate_sale_records_response(\n            res_json['sale'][0],\n            course_registration_code,\n            self.sale_invoice_1,\n            0,\n            invoice_item=self.invoice_item\n        )\n        self.validate_sale_records_response(\n            res_json['sale'][1],\n            course_registration_code,\n            sale_invoice_2,\n            0,\n            invoice_item=invoice_item_2\n        )\n\n    def validate_sale_records_response(self, res, course_registration_code, invoice, used_codes, invoice_item):\n        \"\"\"\n        validate sale records attribute values with the response object\n        \"\"\"\n        self.assertEqual(res['total_amount'], invoice.total_amount)\n        self.assertEqual(res['recipient_email'], invoice.recipient_email)\n        self.assertEqual(res['recipient_name'], invoice.recipient_name)\n        self.assertEqual(res['company_name'], invoice.company_name)\n        self.assertEqual(res['company_contact_name'], invoice.company_contact_name)\n        self.assertEqual(res['company_contact_email'], invoice.company_contact_email)\n        self.assertEqual(res['internal_reference'], invoice.internal_reference)\n        self.assertEqual(res['customer_reference_number'], invoice.customer_reference_number)\n        self.assertEqual(res['invoice_number'], invoice.id)\n        self.assertEqual(res['created_by'], course_registration_code.created_by.username)\n        self.assertEqual(res['course_id'], invoice_item.course_id.to_deprecated_string())\n        self.assertEqual(res['total_used_codes'], used_codes)\n        self.assertEqual(res['total_codes'], 5)\n\n    def test_get_problem_responses_invalid_location(self):\n        \"\"\"\n        Test whether get_problem_responses returns an appropriate status\n        message when users submit an invalid problem location.\n        \"\"\"\n        url = reverse(\n            'get_problem_responses',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        problem_location = ''\n\n        response = self.client.get(url, {'problem_location': problem_location})\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, 'Could not find problem with this location.')\n\n    def valid_problem_location(test):  # pylint: disable=no-self-argument\n        \"\"\"\n        Decorator for tests that target get_problem_responses endpoint and\n        need to pretend user submitted a valid problem location.\n        \"\"\"\n        @functools.wraps(test)\n        def wrapper(self, *args, **kwargs):\n            \"\"\"\n            Run `test` method, ensuring that UsageKey.from_string returns a\n            problem key that the get_problem_responses endpoint can\n            work with.\n            \"\"\"\n            mock_problem_key = Mock(return_value=u'')\n            mock_problem_key.course_key = self.course.id\n            with patch.object(UsageKey, 'from_string') as patched_method:\n                patched_method.return_value = mock_problem_key\n                test(self, *args, **kwargs)\n        return wrapper\n\n    @valid_problem_location\n    def test_get_problem_responses_successful(self):\n        \"\"\"\n        Test whether get_problem_responses returns an appropriate status\n        message if CSV generation was started successfully.\n        \"\"\"\n        url = reverse(\n            'get_problem_responses',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        problem_location = ''\n\n        response = self.client.get(url, {'problem_location': problem_location})\n        res_json = json.loads(response.content)\n        self.assertIn('status', res_json)\n        status = res_json['status']\n        self.assertIn('is being created', status)\n        self.assertNotIn('already in progress', status)\n\n    @valid_problem_location\n    def test_get_problem_responses_already_running(self):\n        \"\"\"\n        Test whether get_problem_responses returns an appropriate status\n        message if CSV generation is already in progress.\n        \"\"\"\n        url = reverse(\n            'get_problem_responses',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n\n        with patch('instructor_task.api.submit_calculate_problem_responses_csv') as submit_task_function:\n            error = AlreadyRunningError()\n            submit_task_function.side_effect = error\n            response = self.client.get(url, {})\n            res_json = json.loads(response.content)\n            self.assertIn('status', res_json)\n            self.assertIn('already in progress', res_json['status'])\n\n    def test_get_students_features(self):\n        \"\"\"\n        Test that some minimum of information is formatted\n        correctly in the response to get_students_features.\n        \"\"\"\n        for student in self.students:\n            student.profile.city = \"Mos Eisley {}\".format(student.id)\n            student.profile.save()\n        url = reverse('get_students_features', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('students', res_json)\n        for student in self.students:\n            student_json = [\n                x for x in res_json['students']\n                if x['username'] == student.username\n            ][0]\n            self.assertEqual(student_json['username'], student.username)\n            self.assertEqual(student_json['email'], student.email)\n            self.assertEqual(student_json['city'], student.profile.city)\n            self.assertEqual(student_json['country'], \"\")\n\n    @ddt.data(True, False)\n    def test_get_students_features_cohorted(self, is_cohorted):\n        \"\"\"\n        Test that get_students_features includes cohort info when the course is\n        cohorted, and does not when the course is not cohorted.\n        \"\"\"\n        url = reverse('get_students_features', kwargs={'course_id': unicode(self.course.id)})\n        set_course_cohort_settings(self.course.id, is_cohorted=is_cohorted)\n\n        response = self.client.get(url, {})\n        res_json = json.loads(response.content)\n\n        self.assertEqual('cohort' in res_json['feature_names'], is_cohorted)\n\n    @ddt.data(True, False)\n    def test_get_students_features_teams(self, has_teams):\n        \"\"\"\n        Test that get_students_features includes team info when the course is\n        has teams enabled, and does not when the course does not have teams enabled\n        \"\"\"\n        if has_teams:\n            self.course = CourseFactory.create(teams_configuration={\n                'max_size': 2, 'topics': [{'topic-id': 'topic', 'name': 'Topic', 'description': 'A Topic'}]\n            })\n            course_instructor = InstructorFactory(course_key=self.course.id)\n            self.client.login(username=course_instructor.username, password='test')\n\n        url = reverse('get_students_features', kwargs={'course_id': unicode(self.course.id)})\n\n        response = self.client.get(url, {})\n        res_json = json.loads(response.content)\n\n        self.assertEqual('team' in res_json['feature_names'], has_teams)\n\n    def test_get_students_who_may_enroll(self):\n        \"\"\"\n        Test whether get_students_who_may_enroll returns an appropriate\n        status message when users request a CSV file of students who\n        may enroll in a course.\n        \"\"\"\n        url = reverse(\n            'get_students_who_may_enroll',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        # Successful case:\n        response = self.client.get(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('status', res_json)\n        self.assertNotIn('currently being created', res_json['status'])\n        # CSV generation already in progress:\n        with patch('instructor_task.api.submit_calculate_may_enroll_csv') as submit_task_function:\n            error = AlreadyRunningError()\n            submit_task_function.side_effect = error\n            response = self.client.get(url, {})\n            res_json = json.loads(response.content)\n            self.assertIn('status', res_json)\n            self.assertIn('currently being created', res_json['status'])\n\n    def test_get_student_exam_results(self):\n        \"\"\"\n        Test whether get_proctored_exam_results returns an appropriate\n        status message when users request a CSV file.\n        \"\"\"\n        url = reverse(\n            'get_proctored_exam_results',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        # Successful case:\n        response = self.client.get(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('status', res_json)\n        self.assertNotIn('currently being created', res_json['status'])\n        # CSV generation already in progress:\n        with patch('instructor_task.api.submit_proctored_exam_results_report') as submit_task_function:\n            error = AlreadyRunningError()\n            submit_task_function.side_effect = error\n            response = self.client.get(url, {})\n            res_json = json.loads(response.content)\n            self.assertIn('status', res_json)\n            self.assertIn('currently being created', res_json['status'])\n\n    def test_access_course_finance_admin_with_invalid_course_key(self):\n        \"\"\"\n        Test assert require_course fiance_admin before generating\n        a detailed enrollment report\n        \"\"\"\n        func = Mock()\n        decorated_func = require_finance_admin(func)\n        request = self.mock_request()\n        response = decorated_func(request, 'invalid_course_key')\n        self.assertEqual(response.status_code, 404)\n        self.assertFalse(func.called)\n\n    def mock_request(self):\n        \"\"\"\n        mock request\n        \"\"\"\n        request = Mock()\n        request.user = self.instructor\n        return request\n\n    def test_access_course_finance_admin_with_valid_course_key(self):\n        \"\"\"\n        Test to check the course_finance_admin role with valid key\n        but doesn't have access to the function\n        \"\"\"\n        func = Mock()\n        decorated_func = require_finance_admin(func)\n        request = self.mock_request()\n        response = decorated_func(request, 'valid/course/key')\n        self.assertEqual(response.status_code, 403)\n        self.assertFalse(func.called)\n\n    def test_add_user_to_fiance_admin_role_with_valid_course(self):\n        \"\"\"\n        test to check that a function is called using a fiance_admin\n        rights.\n        \"\"\"\n        func = Mock()\n        decorated_func = require_finance_admin(func)\n        request = self.mock_request()\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        decorated_func(request, self.course.id.to_deprecated_string())\n        self.assertTrue(func.called)\n\n    def test_enrollment_report_features_csv(self):\n        \"\"\"\n        test to generate enrollment report.\n        enroll users, admin staff using registration codes.\n        \"\"\"\n        InvoiceTransaction.objects.create(\n            invoice=self.sale_invoice_1,\n            amount=self.sale_invoice_1.total_amount,\n            status='completed',\n            created_by=self.instructor,\n            last_modified_by=self.instructor\n        )\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            invoice=self.sale_invoice_1,\n            invoice_item=self.invoice_item,\n            mode_slug='honor'\n        )\n\n        admin_user = AdminFactory()\n        admin_cart = Order.get_cart_for_user(admin_user)\n        PaidCourseRegistration.add_to_order(admin_cart, self.course.id)\n        admin_cart.purchase()\n\n        # create a new user/student and enroll\n        # in the course using a registration code\n        # and then validates the generated detailed enrollment report\n        test_user = UserFactory()\n        self.register_with_redemption_code(test_user, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        UserProfileFactory.create(user=self.students[0], meta='{\"company\": \"asdasda\"}')\n\n        self.client.login(username=self.instructor.username, password='test')\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    def test_bulk_purchase_detailed_report(self):\n        \"\"\"\n        test to generate detailed enrollment report.\n        1 Purchase registration codes.\n        2 Enroll users via registration code.\n        3 Validate generated enrollment report.\n        \"\"\"\n        paid_course_reg_item = PaidCourseRegistration.add_to_order(self.cart, self.course.id)\n        # update the quantity of the cart item paid_course_reg_item\n        resp = self.client.post(reverse('shoppingcart.views.update_user_cart'),\n                                {'ItemId': paid_course_reg_item.id, 'qty': '4'})\n        self.assertEqual(resp.status_code, 200)\n        # apply the coupon code to the item in the cart\n        resp = self.client.post(reverse('shoppingcart.views.use_code'), {'code': self.coupon_code})\n        self.assertEqual(resp.status_code, 200)\n        self.cart.purchase()\n\n        course_reg_codes = CourseRegistrationCode.objects.filter(order=self.cart)\n        self.register_with_redemption_code(self.instructor, course_reg_codes[0].code)\n\n        test_user = UserFactory()\n        test_user_cart = Order.get_cart_for_user(test_user)\n        PaidCourseRegistration.add_to_order(test_user_cart, self.course.id)\n        test_user_cart.purchase()\n        InvoiceTransaction.objects.create(\n            invoice=self.sale_invoice_1,\n            amount=-self.sale_invoice_1.total_amount,\n            status='refunded',\n            created_by=self.instructor,\n            last_modified_by=self.instructor\n        )\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            invoice=self.sale_invoice_1,\n            invoice_item=self.invoice_item,\n            mode_slug='honor'\n        )\n\n        test_user1 = UserFactory()\n        self.register_with_redemption_code(test_user1, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    def test_create_registration_code_without_invoice_and_order(self):\n        \"\"\"\n        test generate detailed enrollment report,\n        used a registration codes which has been created via invoice or bulk\n        purchase scenario.\n        \"\"\"\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            mode_slug='honor'\n        )\n        test_user1 = UserFactory()\n        self.register_with_redemption_code(test_user1, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    def test_invoice_payment_is_still_pending_for_registration_codes(self):\n        \"\"\"\n        test generate enrollment report\n        enroll a user in a course using registration code\n        whose invoice has not been paid yet\n        \"\"\"\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            invoice=self.sale_invoice_1,\n            invoice_item=self.invoice_item,\n            mode_slug='honor'\n        )\n\n        test_user1 = UserFactory()\n        self.register_with_redemption_code(test_user1, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    @patch.object(instructor.views.api, 'anonymous_id_for_user', Mock(return_value='42'))\n    @patch.object(instructor.views.api, 'unique_id_for_user', Mock(return_value='41'))\n    def test_get_anon_ids(self):\n        \"\"\"\n        Test the CSV output for the anonymized user ids.\n        \"\"\"\n        url = reverse('get_anon_ids', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(\n            '\"User ID\",\"Anonymized User ID\",\"Course Specific Anonymized User ID\"'\n            '\\n\"{user_id}\",\"41\",\"42\"\\n'.format(user_id=self.students[0].id)\n        ))\n        self.assertTrue(\n            body.endswith('\"{user_id}\",\"41\",\"42\"\\n'.format(user_id=self.students[-1].id))\n        )\n\n    def test_list_report_downloads(self):\n        url = reverse('list_report_downloads', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        with patch('instructor_task.models.LocalFSReportStore.links_for') as mock_links_for:\n            mock_links_for.return_value = [\n                ('mock_file_name_1', 'https://1.mock.url'),\n                ('mock_file_name_2', 'https://2.mock.url'),\n            ]\n            response = self.client.get(url, {})\n\n        expected_response = {\n            \"downloads\": [\n                {\n                    \"url\": \"https://1.mock.url\",\n                    \"link\": \"<a href=\\\"https://1.mock.url\\\">mock_file_name_1</a>\",\n                    \"name\": \"mock_file_name_1\"\n                },\n                {\n                    \"url\": \"https://2.mock.url\",\n                    \"link\": \"<a href=\\\"https://2.mock.url\\\">mock_file_name_2</a>\",\n                    \"name\": \"mock_file_name_2\"\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected_response)\n\n    @ddt.data(*REPORTS_DATA)\n    @ddt.unpack\n    @valid_problem_location\n    def test_calculate_report_csv_success(self, report_type, instructor_api_endpoint, task_api_endpoint, extra_instructor_api_kwargs):\n        kwargs = {'course_id': unicode(self.course.id)}\n        kwargs.update(extra_instructor_api_kwargs)\n        url = reverse(instructor_api_endpoint, kwargs=kwargs)\n        success_status = \"The {report_type} report is being created.\".format(report_type=report_type)\n        if report_type == 'problem responses':\n            with patch(task_api_endpoint):\n                response = self.client.get(url, {'problem_location': ''})\n            self.assertIn(success_status, response.content)\n        else:\n            CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n            with patch(task_api_endpoint):\n                response = self.client.get(url, {})\n            self.assertIn(success_status, response.content)\n\n    @ddt.data(*EXECUTIVE_SUMMARY_DATA)\n    @ddt.unpack\n    def test_executive_summary_report_success(\n            self,\n            report_type,\n            instructor_api_endpoint,\n            task_api_endpoint,\n            extra_instructor_api_kwargs\n    ):\n        kwargs = {'course_id': unicode(self.course.id)}\n        kwargs.update(extra_instructor_api_kwargs)\n        url = reverse(instructor_api_endpoint, kwargs=kwargs)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        with patch(task_api_endpoint):\n            response = self.client.get(url, {})\n        success_status = \"The {report_type} report is being created.\" \\\n                         \" To view the status of the report, see Pending\" \\\n                         \" Tasks below\".format(report_type=report_type)\n        self.assertIn(success_status, response.content)\n\n    @ddt.data(*EXECUTIVE_SUMMARY_DATA)\n    @ddt.unpack\n    def test_executive_summary_report_already_running(\n            self,\n            report_type,\n            instructor_api_endpoint,\n            task_api_endpoint,\n            extra_instructor_api_kwargs\n    ):\n        kwargs = {'course_id': unicode(self.course.id)}\n        kwargs.update(extra_instructor_api_kwargs)\n        url = reverse(instructor_api_endpoint, kwargs=kwargs)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        with patch(task_api_endpoint) as mock:\n            mock.side_effect = AlreadyRunningError()\n            response = self.client.get(url, {})\n        already_running_status = \"The {report_type} report is currently being created.\" \\\n                                 \" To view the status of the report, see Pending Tasks below.\" \\\n                                 \" You will be able to download the report\" \\\n                                 \" when it is\" \\\n                                 \" complete.\".format(report_type=report_type)\n        self.assertIn(already_running_status, response.content)\n\n    def test_get_ora2_responses_success(self):\n        url = reverse('export_ora2_data', kwargs={'course_id': unicode(self.course.id)})\n\n        with patch('instructor_task.api.submit_export_ora2_data') as mock_submit_ora2_task:\n            mock_submit_ora2_task.return_value = True\n            response = self.client.get(url, {})\n        success_status = \"The ORA data report is being generated.\"\n        self.assertIn(success_status, response.content)\n\n    def test_get_ora2_responses_already_running(self):\n        url = reverse('export_ora2_data', kwargs={'course_id': unicode(self.course.id)})\n\n        with patch('instructor_task.api.submit_export_ora2_data') as mock_submit_ora2_task:\n            mock_submit_ora2_task.side_effect = AlreadyRunningError()\n            response = self.client.get(url, {})\n        already_running_status = \"An ORA data report generation task is already in progress.\"\n        self.assertIn(already_running_status, response.content)\n\n    def test_get_student_progress_url(self):\n        \"\"\" Test that progress_url is in the successful response. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        url += \"?unique_student_identifier={}\".format(\n            quote(self.students[0].email.encode(\"utf-8\"))\n        )\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        res_json = json.loads(response.content)\n        self.assertIn('progress_url', res_json)\n\n    def test_get_student_progress_url_from_uname(self):\n        \"\"\" Test that progress_url is in the successful response. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        url += \"?unique_student_identifier={}\".format(\n            quote(self.students[0].username.encode(\"utf-8\"))\n        )\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        res_json = json.loads(response.content)\n        self.assertIn('progress_url', res_json)\n\n    def test_get_student_progress_url_noparams(self):\n        \"\"\" Test that the endpoint 404's without the required query params. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_get_student_progress_url_nostudent(self):\n        \"\"\" Test that the endpoint 400's when requesting an unknown email. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 400)\n\n\n@attr('shard_1')\nclass TestInstructorAPIRegradeTask(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints whereby instructors can change student grades.\n    This includes resetting attempts and starting rescore tasks.\n\n    This test does NOT test whether the actions had an effect on the\n    database, that is the job of task tests and test_enrollment.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIRegradeTask, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.problem_location = msk_from_problem_urlname(\n            cls.course.id,\n            'robot-some-problem-urlname'\n        )\n        cls.problem_urlname = cls.problem_location.to_deprecated_string()\n\n    def setUp(self):\n        super(TestInstructorAPIRegradeTask, self).setUp()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.student = UserFactory()\n        CourseEnrollment.enroll(self.student, self.course.id)\n\n        self.module_to_reset = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.problem_location,\n            state=json.dumps({'attempts': 10}),\n        )\n\n    def test_reset_student_attempts_deletall(self):\n        \"\"\" Make sure no one can delete all students state on a problem. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'all_students': True,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_reset_student_attempts_single(self):\n        \"\"\" Test reset single student attempts. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure problem attempts have been reset.\n        changed_module = StudentModule.objects.get(pk=self.module_to_reset.pk)\n        self.assertEqual(\n            json.loads(changed_module.state)['attempts'],\n            0\n        )\n\n    # mock out the function which should be called to execute the action.\n    @patch.object(instructor_task.api, 'submit_reset_problem_attempts_for_all_students')\n    def test_reset_student_attempts_all(self, act):\n        \"\"\" Test reset all student attempts. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    def test_reset_student_attempts_missingmodule(self):\n        \"\"\" Test reset for non-existant problem. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': 'robot-not-a-real-module',\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_reset_student_attempts_delete(self):\n        \"\"\" Test delete single student state. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure the module has been deleted\n        self.assertEqual(\n            StudentModule.objects.filter(\n                student=self.module_to_reset.student,\n                course_id=self.module_to_reset.course_id,\n                # module_id=self.module_to_reset.module_id,\n            ).count(),\n            0\n        )\n\n    def test_reset_student_attempts_nonsense(self):\n        \"\"\" Test failure with both unique_student_identifier and all_students. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    @patch.object(instructor_task.api, 'submit_rescore_problem_for_student')\n    def test_rescore_problem_single(self, act):\n        \"\"\" Test rescoring of a single student. \"\"\"\n        url = reverse('rescore_problem', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    @patch.object(instructor_task.api, 'submit_rescore_problem_for_student')\n    def test_rescore_problem_single_from_uname(self, act):\n        \"\"\" Test rescoring of a single student. \"\"\"\n        url = reverse('rescore_problem', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.username,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    @patch.object(instructor_task.api, 'submit_rescore_problem_for_all_students')\n    def test_rescore_problem_all(self, act):\n        \"\"\" Test rescoring for all students. \"\"\"\n        url = reverse('rescore_problem', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'problem_to_reset': self.problem_urlname,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    @patch.dict(settings.FEATURES, {'ENTRANCE_EXAMS': True})\n    def test_course_has_entrance_exam_in_student_attempts_reset(self):\n        \"\"\" Test course has entrance exam id set while resetting attempts\"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'all_students': True,\n            'delete_module': False,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    @patch.dict(settings.FEATURES, {'ENTRANCE_EXAMS': True})\n    def test_rescore_entrance_exam_with_invalid_exam(self):\n        \"\"\" Test course has entrance exam id set while re-scoring. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n\n@attr('shard_1')\n@patch.dict(settings.FEATURES, {'ENTRANCE_EXAMS': True})\n@ddt.ddt\nclass TestEntranceExamInstructorAPIRegradeTask(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints whereby instructors can rescore student grades,\n    reset student attempts and delete state for entrance exam.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestEntranceExamInstructorAPIRegradeTask, cls).setUpClass()\n        cls.course = CourseFactory.create(\n            org='test_org',\n            course='test_course',\n            run='test_run',\n            entrance_exam_id='i4x://{}/{}/chapter/Entrance_exam'.format('test_org', 'test_course')\n        )\n        cls.course_with_invalid_ee = CourseFactory.create(entrance_exam_id='invalid_exam')\n\n        with cls.store.bulk_operations(cls.course.id, emit_signals=False):\n            cls.entrance_exam = ItemFactory.create(\n                parent=cls.course,\n                category='chapter',\n                display_name='Entrance exam'\n            )\n            subsection = ItemFactory.create(\n                parent=cls.entrance_exam,\n                category='sequential',\n                display_name='Subsection 1'\n            )\n            vertical = ItemFactory.create(\n                parent=subsection,\n                category='vertical',\n                display_name='Vertical 1'\n            )\n            cls.ee_problem_1 = ItemFactory.create(\n                parent=vertical,\n                category=\"problem\",\n                display_name=\"Exam Problem - Problem 1\"\n            )\n            cls.ee_problem_2 = ItemFactory.create(\n                parent=vertical,\n                category=\"problem\",\n                display_name=\"Exam Problem - Problem 2\"\n            )\n\n    def setUp(self):\n        super(TestEntranceExamInstructorAPIRegradeTask, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        # Add instructor to invalid ee course\n        CourseInstructorRole(self.course_with_invalid_ee.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.student = UserFactory()\n        CourseEnrollment.enroll(self.student, self.course.id)\n\n        ee_module_to_reset1 = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.ee_problem_1.location,\n            state=json.dumps({'attempts': 10, 'done': True}),\n        )\n        ee_module_to_reset2 = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.ee_problem_2.location,\n            state=json.dumps({'attempts': 10, 'done': True}),\n        )\n        self.ee_modules = [ee_module_to_reset1.module_state_key, ee_module_to_reset2.module_state_key]\n\n    @ddt.data(ModuleStoreEnum.Type.split, ModuleStoreEnum.Type.mongo)\n    def test_grade_histogram(self, store):\n        \"\"\"\n        Verify that a histogram has been created.\n        \"\"\"\n        course = CourseFactory.create(default_store=store)\n\n        usage_key = course.id.make_usage_key('problem', 'first_problem')\n        StudentModule.objects.create(\n            student_id=1,\n            grade=100,\n            module_state_key=usage_key\n        )\n        StudentModule.objects.create(\n            student_id=2,\n            grade=50,\n            module_state_key=usage_key\n        )\n\n        grades = grade_histogram(usage_key)\n        self.assertEqual(grades[0], (50.0, 1))\n        self.assertEqual(grades[1], (100.0, 1))\n\n    def test_reset_entrance_exam_student_attempts_deletall(self):\n        \"\"\" Make sure no one can delete all students state on entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'all_students': True,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_reset_entrance_exam_student_attempts_single(self):\n        \"\"\" Test reset single student attempts for entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure problem attempts have been reset.\n        changed_modules = StudentModule.objects.filter(module_state_key__in=self.ee_modules)\n        for changed_module in changed_modules:\n            self.assertEqual(\n                json.loads(changed_module.state)['attempts'],\n                0\n            )\n\n    # mock out the function which should be called to execute the action.\n    @patch.object(instructor_task.api, 'submit_reset_problem_attempts_in_entrance_exam')\n    def test_reset_entrance_exam_all_student_attempts(self, act):\n        \"\"\" Test reset all student attempts for entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    def test_reset_student_attempts_invalid_entrance_exam(self):\n        \"\"\" Test reset for invalid entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course_with_invalid_ee.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_entrance_exam_sttudent_delete_state(self):\n        \"\"\" Test delete single student entrance exam state. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure the module has been deleted\n        changed_modules = StudentModule.objects.filter(module_state_key__in=self.ee_modules)\n        self.assertEqual(changed_modules.count(), 0)\n\n    def test_entrance_exam_delete_state_with_staff(self):\n        \"\"\" Test entrance exam delete state failure with staff access. \"\"\"\n        self.client.logout()\n        staff_user = StaffFactory(course_key=self.course.id)\n        self.client.login(username=staff_user.username, password='test')\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 403)\n\n    def test_entrance_exam_reset_student_attempts_nonsense(self):\n        \"\"\" Test failure with both unique_student_identifier and all_students. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    @patch.object(instructor_task.api, 'submit_rescore_entrance_exam_for_student')\n    def test_rescore_entrance_exam_single_student(self, act):\n        \"\"\" Test re-scoring of entrance exam for single student. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    def test_rescore_entrance_exam_all_student(self):\n        \"\"\" Test rescoring for all students. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_rescore_entrance_exam_all_student_and_single(self):\n        \"\"\" Test re-scoring with both all students and single student parameters. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_rescore_entrance_exam_with_invalid_exam(self):\n        \"\"\" Test re-scoring of entrance exam with invalid exam. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course_with_invalid_ee.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_list_entrance_exam_instructor_tasks_student(self):\n        \"\"\" Test list task history for entrance exam AND student. \"\"\"\n        # create a re-score entrance exam task\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('list_entrance_exam_instructor_tasks', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        tasks = json.loads(response.content)['tasks']\n        self.assertEqual(len(tasks), 1)\n        self.assertEqual(tasks[0]['status'], _('Complete'))\n\n    def test_list_entrance_exam_instructor_tasks_all_student(self):\n        \"\"\" Test list task history for entrance exam AND all student. \"\"\"\n        url = reverse('list_entrance_exam_instructor_tasks', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        tasks = json.loads(response.content)['tasks']\n        self.assertEqual(len(tasks), 0)\n\n    def test_list_entrance_exam_instructor_with_invalid_exam_key(self):\n        \"\"\" Test list task history for entrance exam failure if course has invalid exam. \"\"\"\n        url = reverse('list_entrance_exam_instructor_tasks',\n                      kwargs={'course_id': unicode(self.course_with_invalid_ee.id)})\n        response = self.client.get(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_skip_entrance_exam_student(self):\n        \"\"\" Test skip entrance exam api for student. \"\"\"\n        # create a re-score entrance exam task\n        url = reverse('mark_student_can_skip_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        # check response\n        message = _('This student (%s) will skip the entrance exam.') % self.student.email\n        self.assertContains(response, message)\n\n        # post again with same student\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n\n        # This time response message should be different\n        message = _('This student (%s) is already allowed to skip the entrance exam.') % self.student.email\n        self.assertContains(response, message)\n\n\n@attr('shard_1')\n@patch('bulk_email.models.html_to_text', Mock(return_value='Mocking CourseEmail.text_message', autospec=True))\nclass TestInstructorSendEmail(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Checks that only instructors have access to email endpoints, and that\n    these endpoints are only accessible with courses that actually exist,\n    only with valid email messages.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorSendEmail, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        test_subject = u'\\u1234 test subject'\n        test_message = u'\\u6824 test message'\n        cls.full_test_message = {\n            'send_to': '[\"myself\", \"staff\"]',\n            'subject': test_subject,\n            'message': test_message,\n        }\n        BulkEmailFlag.objects.create(enabled=True, require_course_email_auth=False)\n\n    @classmethod\n    def tearDownClass(cls):\n        super(TestInstructorSendEmail, cls).tearDownClass()\n        BulkEmailFlag.objects.all().delete()\n\n    def setUp(self):\n        super(TestInstructorSendEmail, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def test_send_email_as_logged_in_instructor(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, self.full_test_message)\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_email_but_not_logged_in(self):\n        self.client.logout()\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, self.full_test_message)\n        self.assertEqual(response.status_code, 403)\n\n    def test_send_email_but_not_staff(self):\n        self.client.logout()\n        student = UserFactory()\n        self.client.login(username=student.username, password='test')\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, self.full_test_message)\n        self.assertEqual(response.status_code, 403)\n\n    def test_send_email_but_course_not_exist(self):\n        url = reverse('send_email', kwargs={'course_id': 'GarbageCourse/DNE/NoTerm'})\n        response = self.client.post(url, self.full_test_message)\n        self.assertNotEqual(response.status_code, 200)\n\n    def test_send_email_no_sendto(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'subject': 'test subject',\n            'message': 'test message',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_send_email_invalid_sendto(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'send_to': '[\"invalid_target\", \"staff\"]',\n            'subject': 'test subject',\n            'message': 'test message',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_send_email_no_subject(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'send_to': '[\"staff\"]',\n            'message': 'test message',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_send_email_no_message(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'send_to': '[\"staff\"]',\n            'subject': 'test subject',\n        })\n        self.assertEqual(response.status_code, 400)\n\n\nclass MockCompletionInfo(object):\n    \"\"\"Mock for get_task_completion_info\"\"\"\n    times_called = 0\n\n    def mock_get_task_completion_info(self, *args):  # pylint: disable=unused-argument\n        \"\"\"Mock for get_task_completion_info\"\"\"\n        self.times_called += 1\n        if self.times_called % 2 == 0:\n            return True, 'Task Completed'\n        return False, 'Task Errored In Some Way'\n\n\n@attr('shard_1')\nclass TestInstructorAPITaskLists(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test instructor task list endpoint.\n    \"\"\"\n\n    class FakeTask(object):\n        \"\"\" Fake task object \"\"\"\n        FEATURES = [\n            'task_type',\n            'task_input',\n            'task_id',\n            'requester',\n            'task_state',\n            'created',\n            'status',\n            'task_message',\n            'duration_sec'\n        ]\n\n        def __init__(self, completion):\n            for feature in self.FEATURES:\n                setattr(self, feature, 'expected')\n            # created needs to be a datetime\n            self.created = datetime.datetime(2013, 10, 25, 11, 42, 35)\n            # set 'status' and 'task_message' attrs\n            success, task_message = completion()\n            if success:\n                self.status = \"Complete\"\n            else:\n                self.status = \"Incomplete\"\n            self.task_message = task_message\n            # Set 'task_output' attr, which will be parsed to the 'duration_sec' attr.\n            self.task_output = '{\"duration_ms\": 1035000}'\n            self.duration_sec = 1035000 / 1000.0\n\n        def make_invalid_output(self):\n            \"\"\"Munge task_output to be invalid json\"\"\"\n            self.task_output = 'HI MY NAME IS INVALID JSON'\n            # This should be given the value of 'unknown' if the task output\n            # can't be properly parsed\n            self.duration_sec = 'unknown'\n\n        def to_dict(self):\n            \"\"\" Convert fake task to dictionary representation. \"\"\"\n            attr_dict = {key: getattr(self, key) for key in self.FEATURES}\n            attr_dict['created'] = attr_dict['created'].isoformat()\n            return attr_dict\n\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPITaskLists, cls).setUpClass()\n        cls.course = CourseFactory.create(\n            entrance_exam_id='i4x://{}/{}/chapter/Entrance_exam'.format('test_org', 'test_course')\n        )\n        cls.problem_location = msk_from_problem_urlname(\n            cls.course.id,\n            'robot-some-problem-urlname'\n        )\n        cls.problem_urlname = cls.problem_location.to_deprecated_string()\n\n    def setUp(self):\n        super(TestInstructorAPITaskLists, self).setUp()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.student = UserFactory()\n        CourseEnrollment.enroll(self.student, self.course.id)\n\n        self.module = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.problem_location,\n            state=json.dumps({'attempts': 10}),\n        )\n        mock_factory = MockCompletionInfo()\n        self.tasks = [self.FakeTask(mock_factory.mock_get_task_completion_info) for _ in xrange(7)]\n        self.tasks[-1].make_invalid_output()\n\n    @patch.object(instructor_task.api, 'get_running_instructor_tasks')\n    def test_list_instructor_tasks_running(self, act):\n        \"\"\" Test list of all running tasks. \"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_instructor_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.get(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n        self.assertEqual(actual_tasks, expected_tasks)\n\n    @patch.object(instructor_task.api, 'get_instructor_task_history')\n    def test_list_background_email_tasks(self, act):\n        \"\"\"Test list of background email tasks.\"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_background_email_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.get(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n        self.assertEqual(actual_tasks, expected_tasks)\n\n    @patch.object(instructor_task.api, 'get_instructor_task_history')\n    def test_list_instructor_tasks_problem(self, act):\n        \"\"\" Test list task history for problem. \"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_instructor_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.get(url, {\n                'problem_location_str': self.problem_urlname,\n            })\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n        self.assertEqual(actual_tasks, expected_tasks)\n\n    @patch.object(instructor_task.api, 'get_instructor_task_history')\n    def test_list_instructor_tasks_problem_student(self, act):\n        \"\"\" Test list task history for problem AND student. \"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_instructor_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.get(url, {\n                'problem_location_str': self.problem_urlname,\n                'unique_student_identifier': self.student.email,\n            })\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n\n        self.assertEqual(actual_tasks, expected_tasks)\n\n\n@attr('shard_1')\n@patch.object(instructor_task.api, 'get_instructor_task_history', autospec=True)\nclass TestInstructorEmailContentList(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test the instructor email content history endpoint.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorEmailContentList, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestInstructorEmailContentList, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n        self.tasks = {}\n        self.emails = {}\n        self.emails_info = {}\n\n    def setup_fake_email_info(self, num_emails, with_failures=False):\n        \"\"\" Initialize the specified number of fake emails \"\"\"\n        for email_id in range(num_emails):\n            num_sent = random.randint(1, 15401)\n            if with_failures:\n                failed = random.randint(1, 15401)\n            else:\n                failed = 0\n\n            self.tasks[email_id] = FakeContentTask(email_id, num_sent, failed, 'expected')\n            self.emails[email_id] = FakeEmail(email_id)\n            self.emails_info[email_id] = FakeEmailInfo(self.emails[email_id], num_sent, failed)\n\n    def get_matching_mock_email(self, **kwargs):\n        \"\"\" Returns the matching mock emails for the given id \"\"\"\n        email_id = kwargs.get('id', 0)\n        return self.emails[email_id]\n\n    def get_email_content_response(self, num_emails, task_history_request, with_failures=False):\n        \"\"\" Calls the list_email_content endpoint and returns the repsonse \"\"\"\n        self.setup_fake_email_info(num_emails, with_failures)\n        task_history_request.return_value = self.tasks.values()\n        url = reverse('list_email_content', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        with patch('instructor.views.api.CourseEmail.objects.get') as mock_email_info:\n            mock_email_info.side_effect = self.get_matching_mock_email\n            response = self.client.get(url, {})\n        self.assertEqual(response.status_code, 200)\n        return response\n\n    def check_emails_sent(self, num_emails, task_history_request, with_failures=False):\n        \"\"\" Tests sending emails with or without failures \"\"\"\n        response = self.get_email_content_response(num_emails, task_history_request, with_failures)\n        self.assertTrue(task_history_request.called)\n        expected_email_info = [email_info.to_dict() for email_info in self.emails_info.values()]\n        actual_email_info = json.loads(response.content)['emails']\n\n        self.assertEqual(len(actual_email_info), num_emails)\n        for exp_email, act_email in zip(expected_email_info, actual_email_info):\n            self.assertDictEqual(exp_email, act_email)\n\n        self.assertEqual(expected_email_info, actual_email_info)\n\n    def test_content_list_one_email(self, task_history_request):\n        \"\"\" Test listing of bulk emails when email list has one email \"\"\"\n        response = self.get_email_content_response(1, task_history_request)\n        self.assertTrue(task_history_request.called)\n        email_info = json.loads(response.content)['emails']\n\n        # Emails list should have one email\n        self.assertEqual(len(email_info), 1)\n\n        # Email content should be what's expected\n        expected_message = self.emails[0].html_message\n        returned_email_info = email_info[0]\n        received_message = returned_email_info[u'email'][u'html_message']\n        self.assertEqual(expected_message, received_message)\n\n    def test_content_list_no_emails(self, task_history_request):\n        \"\"\" Test listing of bulk emails when email list empty \"\"\"\n        response = self.get_email_content_response(0, task_history_request)\n        self.assertTrue(task_history_request.called)\n        email_info = json.loads(response.content)['emails']\n\n        # Emails list should be empty\n        self.assertEqual(len(email_info), 0)\n\n    def test_content_list_email_content_many(self, task_history_request):\n        \"\"\" Test listing of bulk emails sent large amount of emails \"\"\"\n        self.check_emails_sent(50, task_history_request)\n\n    def test_list_email_content_error(self, task_history_request):\n        \"\"\" Test handling of error retrieving email \"\"\"\n        invalid_task = FakeContentTask(0, 0, 0, 'test')\n        invalid_task.make_invalid_input()\n        task_history_request.return_value = [invalid_task]\n        url = reverse('list_email_content', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(task_history_request.called)\n        returned_email_info = json.loads(response.content)['emails']\n        self.assertEqual(len(returned_email_info), 1)\n        returned_info = returned_email_info[0]\n        for info in ['created', 'sent_to', 'email', 'number_sent', 'requester']:\n            self.assertEqual(returned_info[info], None)\n\n    def test_list_email_with_failure(self, task_history_request):\n        \"\"\" Test the handling of email task that had failures \"\"\"\n        self.check_emails_sent(1, task_history_request, True)\n\n    def test_list_many_emails_with_failures(self, task_history_request):\n        \"\"\" Test the handling of many emails with failures \"\"\"\n        self.check_emails_sent(50, task_history_request, True)\n\n    def test_list_email_with_no_successes(self, task_history_request):\n        task_info = FakeContentTask(0, 0, 10, 'expected')\n        email = FakeEmail(0)\n        email_info = FakeEmailInfo(email, 0, 10)\n        task_history_request.return_value = [task_info]\n        url = reverse('list_email_content', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        with patch('instructor.views.api.CourseEmail.objects.get') as mock_email_info:\n            mock_email_info.return_value = email\n            response = self.client.get(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(task_history_request.called)\n        returned_info_list = json.loads(response.content)['emails']\n\n        self.assertEqual(len(returned_info_list), 1)\n        returned_info = returned_info_list[0]\n        expected_info = email_info.to_dict()\n        self.assertDictEqual(expected_info, returned_info)\n\n\n@attr('shard_1')\nclass TestInstructorAPIHelpers(TestCase):\n    \"\"\" Test helpers for instructor.api \"\"\"\n\n    def test_split_input_list(self):\n        strings = []\n        lists = []\n        strings.append(\n            \"Lorem@ipsum.dolor, sit@amet.consectetur\\nadipiscing@elit.Aenean\\r convallis@at.lacus\\r, ut@lacinia.Sed\")\n        lists.append(['Lorem@ipsum.dolor', 'sit@amet.consectetur', 'adipiscing@elit.Aenean', 'convallis@at.lacus',\n                      'ut@lacinia.Sed'])\n\n        for (stng, lst) in zip(strings, lists):\n            self.assertEqual(_split_input_list(stng), lst)\n\n    def test_split_input_list_unicode(self):\n        self.assertEqual(_split_input_list('robot@robot.edu, robot2@robot.edu'),\n                         ['robot@robot.edu', 'robot2@robot.edu'])\n        self.assertEqual(_split_input_list(u'robot@robot.edu, robot2@robot.edu'),\n                         ['robot@robot.edu', 'robot2@robot.edu'])\n        self.assertEqual(_split_input_list(u'robot@robot.edu, robot2@robot.edu'),\n                         [u'robot@robot.edu', 'robot2@robot.edu'])\n        scary_unistuff = unichr(40960) + u'abcd' + unichr(1972)\n        self.assertEqual(_split_input_list(scary_unistuff), [scary_unistuff])\n\n    def test_msk_from_problem_urlname(self):\n        course_id = SlashSeparatedCourseKey('MITx', '6.002x', '2013_Spring')\n        name = 'L2Node1'\n        output = 'i4x://MITx/6.002x/problem/L2Node1'\n        self.assertEqual(msk_from_problem_urlname(course_id, name).to_deprecated_string(), output)\n\n    @raises(ValueError)\n    def test_msk_from_problem_urlname_error(self):\n        args = ('notagoodcourse', 'L2Node1')\n        msk_from_problem_urlname(*args)\n\n\ndef get_extended_due(course, unit, user):\n    \"\"\"\n    Gets the overridden due date for the given user on the given unit.  Returns\n    `None` if there is no override set.\n    \"\"\"\n    try:\n        override = StudentFieldOverride.objects.get(\n            course_id=course.id,\n            student=user,\n            location=unit.location,\n            field='due'\n        )\n        return DATE_FIELD.from_json(json.loads(override.value))\n    except StudentFieldOverride.DoesNotExist:\n        return None\n\n\n@attr('shard_1')\nclass TestDueDateExtensions(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test data dumps for reporting.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestDueDateExtensions, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.due = datetime.datetime(2010, 5, 12, 2, 42, tzinfo=utc)\n\n        with cls.store.bulk_operations(cls.course.id, emit_signals=False):\n            cls.week1 = ItemFactory.create(due=cls.due)\n            cls.week2 = ItemFactory.create(due=cls.due)\n            cls.week3 = ItemFactory.create()  # No due date\n            cls.course.children = [\n                cls.week1.location.to_deprecated_string(),\n                cls.week2.location.to_deprecated_string(),\n                cls.week3.location.to_deprecated_string()\n            ]\n            cls.homework = ItemFactory.create(\n                parent_location=cls.week1.location,\n                due=cls.due\n            )\n            cls.week1.children = [cls.homework.location.to_deprecated_string()]\n\n    def setUp(self):\n        \"\"\"\n        Fixtures.\n        \"\"\"\n        super(TestDueDateExtensions, self).setUp()\n\n        user1 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week2.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week3.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user2 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user3 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        self.user1 = user1\n        self.user2 = user2\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def test_change_due_date(self):\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n            'due_datetime': '12/30/2013 00:00'\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(datetime.datetime(2013, 12, 30, 0, 0, tzinfo=utc),\n                         get_extended_due(self.course, self.week1, self.user1))\n\n    def test_change_to_invalid_due_date(self):\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n            'due_datetime': '01/01/2009 00:00'\n        })\n        self.assertEqual(response.status_code, 400, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week1, self.user1)\n        )\n\n    def test_change_nonexistent_due_date(self):\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'student': self.user1.username,\n            'url': self.week3.location.to_deprecated_string(),\n            'due_datetime': '12/30/2013 00:00'\n        })\n        self.assertEqual(response.status_code, 400, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week3, self.user1)\n        )\n\n    def test_reset_date(self):\n        self.test_change_due_date()\n        url = reverse('reset_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week1, self.user1)\n        )\n\n    def test_reset_nonexistent_extension(self):\n        url = reverse('reset_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n        })\n        self.assertEqual(response.status_code, 400, response.content)\n\n    def test_show_unit_extensions(self):\n        self.test_change_due_date()\n        url = reverse('show_unit_extensions',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {'url': self.week1.location.to_deprecated_string()})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(json.loads(response.content), {\n            u'data': [{u'Extended Due Date': u'2013-12-30 00:00',\n                       u'Full Name': self.user1.profile.name,\n                       u'Username': self.user1.username}],\n            u'header': [u'Username', u'Full Name', u'Extended Due Date'],\n            u'title': u'Users with due date extensions for %s' %\n                      self.week1.display_name})\n\n    def test_show_student_extensions(self):\n        self.test_change_due_date()\n        url = reverse('show_student_extensions',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {'student': self.user1.username})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(json.loads(response.content), {\n            u'data': [{u'Extended Due Date': u'2013-12-30 00:00',\n                       u'Unit': self.week1.display_name}],\n            u'header': [u'Unit', u'Extended Due Date'],\n            u'title': u'Due date extensions for %s (%s)' % (\n                self.user1.profile.name, self.user1.username)})\n\n\n@attr('shard_1')\nclass TestDueDateExtensionsDeletedDate(ModuleStoreTestCase, LoginEnrollmentTestCase):\n    def setUp(self):\n        \"\"\"\n        Fixtures.\n        \"\"\"\n        super(TestDueDateExtensionsDeletedDate, self).setUp()\n\n        self.course = CourseFactory.create()\n        self.due = datetime.datetime(2010, 5, 12, 2, 42, tzinfo=utc)\n\n        with self.store.bulk_operations(self.course.id, emit_signals=False):\n            self.week1 = ItemFactory.create(due=self.due)\n            self.week2 = ItemFactory.create(due=self.due)\n            self.week3 = ItemFactory.create()  # No due date\n            self.course.children = [\n                self.week1.location.to_deprecated_string(),\n                self.week2.location.to_deprecated_string(),\n                self.week3.location.to_deprecated_string()\n            ]\n            self.homework = ItemFactory.create(\n                parent_location=self.week1.location,\n                due=self.due\n            )\n            self.week1.children = [self.homework.location.to_deprecated_string()]\n\n        user1 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week2.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week3.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user2 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user3 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        self.user1 = user1\n        self.user2 = user2\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def test_reset_extension_to_deleted_date(self):\n        \"\"\"\n        Test that we can delete a due date extension after deleting the normal\n        due date, without causing an error.\n        \"\"\"\n\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n            'due_datetime': '12/30/2013 00:00'\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(datetime.datetime(2013, 12, 30, 0, 0, tzinfo=utc),\n                         get_extended_due(self.course, self.week1, self.user1))\n\n        self.week1.due = None\n        self.week1 = self.store.update_item(self.week1, self.user1.id)\n        # Now, week1's normal due date is deleted but the extension still exists.\n        url = reverse('reset_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.get(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week1, self.user1)\n        )\n\n\n@attr('shard_1')\nclass TestCourseIssuedCertificatesData(SharedModuleStoreTestCase):\n    \"\"\"\n    Test data dumps for issued certificates.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestCourseIssuedCertificatesData, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestCourseIssuedCertificatesData, self).setUp()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def generate_certificate(self, course_id, mode, status):\n        \"\"\"\n        Generate test certificate\n        \"\"\"\n        test_user = UserFactory()\n        GeneratedCertificateFactory.create(\n            user=test_user,\n            course_id=course_id,\n            mode=mode,\n            status=status\n        )\n\n    def test_certificates_features_against_status(self):\n        \"\"\"\n        Test certificates with status 'downloadable' should be in the response.\n        \"\"\"\n        url = reverse('get_issued_certificates', kwargs={'course_id': unicode(self.course.id)})\n        # firstly generating downloadable certificates with 'honor' mode\n        certificate_count = 3\n        for __ in xrange(certificate_count):\n            self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.generating)\n\n        response = self.client.get(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n        self.assertEqual(len(res_json['certificates']), 0)\n\n        # Certificates with status 'downloadable' should be in response.\n        self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)\n        response = self.client.get(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n        self.assertEqual(len(res_json['certificates']), 1)\n\n    def test_certificates_features_group_by_mode(self):\n        \"\"\"\n        Test for certificate csv features against mode. Certificates should be group by 'mode' in reponse.\n        \"\"\"\n        url = reverse('get_issued_certificates', kwargs={'course_id': unicode(self.course.id)})\n        # firstly generating downloadable certificates with 'honor' mode\n        certificate_count = 3\n        for __ in xrange(certificate_count):\n            self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)\n\n        response = self.client.get(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n        self.assertEqual(len(res_json['certificates']), 1)\n\n        # retrieve the first certificate from the list, there should be 3 certificates for 'honor' mode.\n        certificate = res_json['certificates'][0]\n        self.assertEqual(certificate.get('total_issued_certificate'), 3)\n        self.assertEqual(certificate.get('mode'), 'honor')\n        self.assertEqual(certificate.get('course_id'), str(self.course.id))\n\n        # Now generating downloadable certificates with 'verified' mode\n        for __ in xrange(certificate_count):\n            self.generate_certificate(\n                course_id=self.course.id,\n                mode='verified',\n                status=CertificateStatuses.downloadable\n            )\n\n        response = self.client.get(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n\n        # total certificate count should be 2 for 'verified' mode.\n        self.assertEqual(len(res_json['certificates']), 2)\n\n        # retrieve the second certificate from the list\n        certificate = res_json['certificates'][1]\n        self.assertEqual(certificate.get('total_issued_certificate'), 3)\n        self.assertEqual(certificate.get('mode'), 'verified')\n\n    def test_certificates_features_csv(self):\n        \"\"\"\n        Test for certificate csv features.\n        \"\"\"\n        url = reverse('get_issued_certificates', kwargs={'course_id': unicode(self.course.id)})\n        url += '?csv=true'\n        # firstly generating downloadable certificates with 'honor' mode\n        certificate_count = 3\n        for __ in xrange(certificate_count):\n            self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)\n\n        current_date = datetime.date.today().strftime(\"%B %d, %Y\")\n        response = self.client.get(url)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        self.assertEqual(response['Content-Disposition'], 'attachment; filename={0}'.format('issued_certificates.csv'))\n        self.assertEqual(\n            response.content.strip(),\n            '\"CourseID\",\"Certificate Type\",\"Total Certificates Issued\",\"Date Report Run\"\\r\\n\"'\n            + str(self.course.id) + '\",\"honor\",\"3\",\"' + current_date + '\"'\n        )\n\n\n@attr('shard_1')\n@override_settings(REGISTRATION_CODE_LENGTH=8)\nclass TestCourseRegistrationCodes(SharedModuleStoreTestCase):\n    \"\"\"\n    Test data dumps for E-commerce Course Registration Codes.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestCourseRegistrationCodes, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.url = reverse(\n            'generate_registration_codes',\n            kwargs={'course_id': cls.course.id.to_deprecated_string()}\n        )\n\n    def setUp(self):\n        \"\"\"\n        Fixtures.\n        \"\"\"\n        super(TestCourseRegistrationCodes, self).setUp()\n\n        CourseModeFactory.create(course_id=self.course.id, min_price=50)\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n        CourseSalesAdminRole(self.course.id).add_users(self.instructor)\n\n        data = {\n            'total_registration_codes': 12, 'company_name': 'Test Group', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street',\n            'address_line_2': '', 'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(self.url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        for i in range(5):\n            order = Order(user=self.instructor, status='purchased')\n            order.save()\n\n        # Spent(used) Registration Codes\n        for i in range(5):\n            i += 1\n            registration_code_redemption = RegistrationCodeRedemption(\n                registration_code_id=i,\n                redeemed_by=self.instructor\n            )\n            registration_code_redemption.save()\n\n    @override_settings(FINANCE_EMAIL='finance@example.com')\n    def test_finance_email_in_recipient_list_when_generating_registration_codes(self):\n        \"\"\"\n        Test to verify that the invoice will also be sent to the FINANCE_EMAIL when\n        generating registration codes\n        \"\"\"\n        url_reg_code = reverse('generate_registration_codes',\n                               kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 5, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 121.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': 'True'\n        }\n\n        response = self.client.post(url_reg_code, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        # check for the last mail.outbox, The FINANCE_EMAIL has been appended at the\n        # very end, when generating registration codes\n        self.assertEqual(mail.outbox[-1].to[0], 'finance@example.com')\n\n    def test_user_invoice_copy_preference(self):\n        \"\"\"\n        Test to remember user invoice copy preference\n        \"\"\"\n        url_reg_code = reverse('generate_registration_codes',\n                               kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 5, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 121.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': 'True'\n        }\n\n        # user invoice copy preference will be saved in api user preference; model\n        response = self.client.post(url_reg_code, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n\n        # get user invoice copy preference.\n        url_user_invoice_preference = reverse('get_user_invoice_preference',\n                                              kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        response = self.client.post(url_user_invoice_preference, data)\n        result = json.loads(response.content)\n        self.assertEqual(result['invoice_copy'], True)\n\n        # updating the user invoice copy preference during code generation flow\n        data['invoice'] = ''\n        response = self.client.post(url_reg_code, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n\n        # get user invoice copy preference.\n        url_user_invoice_preference = reverse('get_user_invoice_preference',\n                                              kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        response = self.client.post(url_user_invoice_preference, data)\n        result = json.loads(response.content)\n        self.assertEqual(result['invoice_copy'], False)\n\n    def test_generate_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the generated course registration codes\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 15, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 17)\n\n    def test_generate_course_registration_with_redeem_url_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the generated course registration codes\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 15, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 17)\n        rows = body.split('\\n')\n        index = 1\n        while index < len(rows):\n            if rows[index]:\n                row_data = rows[index].split(',')\n                code = row_data[0].replace('\"', '')\n                self.assertTrue(row_data[1].startswith('\"http')\n                                and row_data[1].endswith('/shoppingcart/register/redeem/{0}/\"'.format(code)))\n            index += 1\n\n    @patch.object(instructor.views.api, 'random_code_generator',\n                  Mock(side_effect=['first', 'second', 'third', 'fourth']))\n    def test_generate_course_registration_codes_matching_existing_coupon_code(self):\n        \"\"\"\n        Test the generated course registration code is already in the Coupon Table\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        coupon = Coupon(code='first', course_id=self.course.id.to_deprecated_string(), created_by=self.instructor)\n        coupon.save()\n        data = {\n            'total_registration_codes': 3, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 5)  # 1 for headers, 1 for new line at the end and 3 for the actual data\n\n    @patch.object(instructor.views.api, 'random_code_generator',\n                  Mock(side_effect=['first', 'first', 'second', 'third']))\n    def test_generate_course_registration_codes_integrity_error(self):\n        \"\"\"\n       Test for the Integrity error against the generated code\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 2, 'company_name': 'Test Group', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 4)\n\n    def test_spent_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the spent course registration codes\n        \"\"\"\n        url = reverse('spent_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {'spent_company_name': ''}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n\n        self.assertEqual(len(body.split('\\n')), 7)\n\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'unit_price': 122.45, 'company_contact_email': 'Test@company.com', 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        for i in range(9):\n            order = Order(user=self.instructor, status='purchased')\n            order.save()\n\n        # Spent(used) Registration Codes\n        for i in range(9):\n            i += 13\n            registration_code_redemption = RegistrationCodeRedemption(\n                registration_code_id=i,\n                redeemed_by=self.instructor\n            )\n            registration_code_redemption.save()\n\n        data = {'spent_company_name': 'Group Alpha'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 11)\n\n    def test_active_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the active course registration codes\n        \"\"\"\n        url = reverse('active_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {'active_company_name': ''}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 9)\n\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        data = {'active_company_name': 'Group Alpha'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 11)\n\n    def test_get_all_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the course registration codes\n        \"\"\"\n        url = reverse(\n            'get_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {'download_company_name': ''}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 14)\n\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        data = {'download_company_name': 'Group Alpha'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 11)\n\n    def test_pdf_file_throws_exception(self):\n        \"\"\"\n        test to mock the pdf file generation throws an exception\n        when generating registration codes.\n        \"\"\"\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n        with patch.object(PDFInvoice, 'generate_pdf', side_effect=Exception):\n            response = self.client.post(generate_code_url, data)\n            self.assertEqual(response.status_code, 200, response.content)\n\n    def test_get_codes_with_sale_invoice(self):\n        \"\"\"\n        Test to generate a response of all the course registration codes\n        \"\"\"\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 5.5, 'company_name': 'Group Invoice', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': True\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        url = reverse('get_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n        data = {'download_company_name': 'Group Invoice'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n\n    def test_with_invalid_unit_price(self):\n        \"\"\"\n        Test to generate a response of all the course registration codes\n        \"\"\"\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 10, 'company_name': 'Group Invoice', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 'invalid', 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': True\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 400, response.content)\n        self.assertIn('Could not parse amount as', response.content)\n\n    def test_get_historical_coupon_codes(self):\n        \"\"\"\n        Test to download a response of all the active coupon codes\n        \"\"\"\n        get_coupon_code_url = reverse(\n            'get_coupon_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n        for i in range(10):\n            coupon = Coupon(\n                code='test_code{0}'.format(i), description='test_description', course_id=self.course.id,\n                percentage_discount='{0}'.format(i), created_by=self.instructor, is_active=True\n            )\n            coupon.save()\n\n        #now create coupons with the expiration dates\n        for i in range(5):\n            coupon = Coupon(\n                code='coupon{0}'.format(i), description='test_description', course_id=self.course.id,\n                percentage_discount='{0}'.format(i), created_by=self.instructor, is_active=True,\n                expiration_date=datetime.datetime.now(pytz.UTC) + datetime.timedelta(days=2)\n            )\n            coupon.save()\n\n        response = self.client.get(get_coupon_code_url)\n        self.assertEqual(response.status_code, 200, response.content)\n        # filter all the coupons\n        for coupon in Coupon.objects.all():\n            self.assertIn(\n                '\"{coupon_code}\",\"{course_id}\",\"{discount}\",\"{description}\",\"{expiration_date}\",\"{is_active}\",'\n                '\"{code_redeemed_count}\",\"{total_discounted_seats}\",\"{total_discounted_amount}\"'.format(\n                    coupon_code=coupon.code,\n                    course_id=coupon.course_id,\n                    discount=coupon.percentage_discount,\n                    description=coupon.description,\n                    expiration_date=coupon.display_expiry_date,\n                    is_active=coupon.is_active,\n                    code_redeemed_count=\"0\",\n                    total_discounted_seats=\"0\",\n                    total_discounted_amount=\"0\",\n                ), response.content\n            )\n\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_COUPON_CSV_HEADER))\n\n\n@attr('shard_1')\nclass TestBulkCohorting(SharedModuleStoreTestCase):\n    \"\"\"\n    Test adding users to cohorts in bulk via CSV upload.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestBulkCohorting, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestBulkCohorting, self).setUp()\n        self.staff_user = StaffFactory(course_key=self.course.id)\n        self.non_staff_user = UserFactory.create()\n        self.tempdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.tempdir)\n\n    def call_add_users_to_cohorts(self, csv_data, suffix='.csv', method='POST'):\n        \"\"\"\n        Call `add_users_to_cohorts` with a file generated from `csv_data`.\n        \"\"\"\n        # this temporary file will be removed in `self.tearDown()`\n        __, file_name = tempfile.mkstemp(suffix=suffix, dir=self.tempdir)\n        with open(file_name, 'w') as file_pointer:\n            file_pointer.write(csv_data.encode('utf-8'))\n        with open(file_name, 'r') as file_pointer:\n            url = reverse('add_users_to_cohorts', kwargs={'course_id': unicode(self.course.id)})\n            if method == 'POST':\n                return self.client.post(url, {'uploaded-file': file_pointer})\n            elif method == 'GET':\n                return self.client.get(url, {'uploaded-file': file_pointer})\n\n    def expect_error_on_file_content(self, file_content, error, file_suffix='.csv'):\n        \"\"\"\n        Verify that we get the error we expect for a given file input.\n        \"\"\"\n        self.client.login(username=self.staff_user.username, password='test')\n        response = self.call_add_users_to_cohorts(file_content, suffix=file_suffix)\n        self.assertEqual(response.status_code, 400)\n        result = json.loads(response.content)\n        self.assertEqual(result['error'], error)\n\n    def verify_success_on_file_content(self, file_content, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that `addd_users_to_cohorts` successfully validates the\n        file content, uploads the input file, and triggers the\n        background task.\n        \"\"\"\n        mock_store_upload.return_value = (None, 'fake_file_name.csv')\n        self.client.login(username=self.staff_user.username, password='test')\n        response = self.call_add_users_to_cohorts(file_content)\n        self.assertEqual(response.status_code, 204)\n        self.assertTrue(mock_store_upload.called)\n        self.assertTrue(mock_cohort_task.called)\n\n    def test_no_cohort_field(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        included a cohort field in the uploaded CSV.\n        \"\"\"\n        self.expect_error_on_file_content(\n            'username,email\\n', \"The file must contain a 'cohort' column containing cohort names.\"\n        )\n\n    def test_no_username_or_email_field(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        included a username or email field in the uploaded CSV.\n        \"\"\"\n        self.expect_error_on_file_content(\n            'cohort\\n', \"The file must contain a 'username' column, an 'email' column, or both.\"\n        )\n\n    def test_empty_csv(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        included any data in the uploaded CSV.\n        \"\"\"\n        self.expect_error_on_file_content(\n            '', \"The file must contain a 'cohort' column containing cohort names.\"\n        )\n\n    def test_wrong_extension(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        uploaded a file with a '.csv' extension.\n        \"\"\"\n        self.expect_error_on_file_content(\n            '', \"The file must end with the extension '.csv'.\", file_suffix='.notcsv'\n        )\n\n    def test_non_staff_no_access(self):\n        \"\"\"\n        Verify that we can't access the view when we aren't a staff user.\n        \"\"\"\n        self.client.login(username=self.non_staff_user.username, password='test')\n        response = self.call_add_users_to_cohorts('')\n        self.assertEqual(response.status_code, 403)\n\n    def test_post_only(self):\n        \"\"\"\n        Verify that we can't call the view when we aren't using POST.\n        \"\"\"\n        self.client.login(username=self.staff_user.username, password='test')\n        response = self.call_add_users_to_cohorts('', method='GET')\n        self.assertEqual(response.status_code, 405)\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_username(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call a background task when\n        the CSV has username and cohort columns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,cohort\\nfoo_username,bar_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_email(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when the CSV has email and cohort columns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'email,cohort\\nfoo_email,bar_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_username_and_email(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when the CSV has username, email and cohort columns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,email,cohort\\nfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_carriage_return(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when lines in the CSV are delimited by carriage returns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,email,cohort\\rfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_carriage_return_line_feed(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when lines in the CSV are delimited by carriage returns and line\n        feeds.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,email,cohort\\r\\nfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task\n        )\n", "\"\"\"\nInstructor Dashboard API views\n\nJSON views which the instructor dashboard requests.\n\nMany of these GETs may become PUTs in the future.\n\"\"\"\nimport StringIO\nimport json\nimport logging\nimport re\nimport time\nfrom django.conf import settings\nfrom django.views.decorators.csrf import ensure_csrf_cookie, csrf_exempt\nfrom django.views.decorators.http import require_POST, require_http_methods\nfrom django.views.decorators.cache import cache_control\nfrom django.core.exceptions import ValidationError, PermissionDenied\nfrom django.core.mail.message import EmailMessage\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.db import IntegrityError, transaction\nfrom django.core.urlresolvers import reverse\nfrom django.core.validators import validate_email\nfrom django.utils.translation import ugettext as _\nfrom django.http import HttpResponse, HttpResponseBadRequest, HttpResponseForbidden, HttpResponseNotFound\nfrom django.utils.html import strip_tags\nfrom django.shortcuts import redirect\nimport string\nimport random\nimport unicodecsv\nimport decimal\nfrom student import auth\nfrom student.roles import GlobalStaff, CourseSalesAdminRole, CourseFinanceAdminRole\nfrom util.file import (\n    store_uploaded_file, course_and_time_based_filename_generator,\n    FileValidationException, UniversalNewlineIterator\n)\nfrom util.json_request import JsonResponse, JsonResponseBadRequest\nfrom instructor.views.instructor_task_helpers import extract_email_features, extract_task_features\n\nfrom microsite_configuration import microsite\n\nfrom courseware.access import has_access\nfrom courseware.courses import get_course_with_access, get_course_by_id\nfrom django.contrib.auth.models import User\nfrom django_comment_client.utils import has_forum_access\nfrom django_comment_common.models import (\n    Role,\n    FORUM_ROLE_ADMINISTRATOR,\n    FORUM_ROLE_MODERATOR,\n    FORUM_ROLE_COMMUNITY_TA,\n)\nfrom edxmako.shortcuts import render_to_string\nfrom courseware.models import StudentModule\nfrom shoppingcart.models import (\n    Coupon,\n    CourseRegistrationCode,\n    RegistrationCodeRedemption,\n    Invoice,\n    CourseMode,\n    CourseRegistrationCodeInvoiceItem,\n)\nfrom student.models import (\n    CourseEnrollment, unique_id_for_user, anonymous_id_for_user,\n    UserProfile, Registration, EntranceExamConfiguration,\n    ManualEnrollmentAudit, UNENROLLED_TO_ALLOWEDTOENROLL, ALLOWEDTOENROLL_TO_ENROLLED,\n    ENROLLED_TO_ENROLLED, ENROLLED_TO_UNENROLLED, UNENROLLED_TO_ENROLLED,\n    UNENROLLED_TO_UNENROLLED, ALLOWEDTOENROLL_TO_UNENROLLED, DEFAULT_TRANSITION_STATE\n)\nimport instructor_task.api\nfrom instructor_task.api_helper import AlreadyRunningError\nfrom instructor_task.models import ReportStore\nimport instructor.enrollment as enrollment\nfrom instructor.enrollment import (\n    get_user_email_language,\n    enroll_email,\n    send_mail_to_student,\n    get_email_params,\n    send_beta_role_email,\n    unenroll_email,\n)\nfrom instructor.access import list_with_level, allow_access, revoke_access, ROLES, update_forum_role\nimport instructor_analytics.basic\nimport instructor_analytics.distributions\nimport instructor_analytics.csvs\nimport csv\nfrom openedx.core.djangoapps.user_api.preferences.api import get_user_preference, set_user_preference\nfrom openedx.core.djangolib.markup import HTML, Text\nfrom instructor.views import INVOICE_KEY\n\nfrom submissions import api as sub_api  # installed from the edx-submissions repository\n\nfrom certificates import api as certs_api\nfrom certificates.models import CertificateWhitelist, GeneratedCertificate, CertificateStatuses, CertificateInvalidation\n\nfrom bulk_email.models import CourseEmail, BulkEmailFlag\nfrom student.models import get_user_by_username_or_email\n\nfrom .tools import (\n    dump_student_extensions,\n    dump_module_extensions,\n    find_unit,\n    get_student_from_identifier,\n    require_student_from_identifier,\n    handle_dashboard_error,\n    parse_datetime,\n    set_due_date_extension,\n    strip_if_string,\n)\nfrom opaque_keys.edx.keys import CourseKey, UsageKey\nfrom opaque_keys.edx.locations import SlashSeparatedCourseKey\nfrom opaque_keys import InvalidKeyError\nfrom openedx.core.djangoapps.course_groups.cohorts import is_course_cohorted\nfrom openedx.core.djangoapps.theming import helpers as theming_helpers\n\nlog = logging.getLogger(__name__)\n\n\ndef common_exceptions_400(func):\n    \"\"\"\n    Catches common exceptions and renders matching 400 errors.\n    (decorator without arguments)\n    \"\"\"\n    def wrapped(request, *args, **kwargs):  # pylint: disable=missing-docstring\n        use_json = (request.is_ajax() or\n                    request.META.get(\"HTTP_ACCEPT\", \"\").startswith(\"application/json\"))\n        try:\n            return func(request, *args, **kwargs)\n        except User.DoesNotExist:\n            message = _(\"User does not exist.\")\n            if use_json:\n                return JsonResponse({\"error\": message}, 400)\n            else:\n                return HttpResponseBadRequest(message)\n        except AlreadyRunningError:\n            message = _(\"Task is already running.\")\n            if use_json:\n                return JsonResponse({\"error\": message}, 400)\n            else:\n                return HttpResponseBadRequest(message)\n    return wrapped\n\n\ndef require_query_params(*args, **kwargs):\n    \"\"\"\n    Checks for required paremters or renders a 400 error.\n    (decorator with arguments)\n\n    `args` is a *list of required GET parameter names.\n    `kwargs` is a **dict of required GET parameter names\n        to string explanations of the parameter\n    \"\"\"\n    required_params = []\n    required_params += [(arg, None) for arg in args]\n    required_params += [(key, kwargs[key]) for key in kwargs]\n    # required_params = e.g. [('action', 'enroll or unenroll'), ['emails', None]]\n\n    def decorator(func):  # pylint: disable=missing-docstring\n        def wrapped(*args, **kwargs):  # pylint: disable=missing-docstring\n            request = args[0]\n\n            error_response_data = {\n                'error': 'Missing required query parameter(s)',\n                'parameters': [],\n                'info': {},\n            }\n\n            for (param, extra) in required_params:\n                default = object()\n                if request.GET.get(param, default) == default:\n                    error_response_data['parameters'].append(param)\n                    error_response_data['info'][param] = extra\n\n            if len(error_response_data['parameters']) > 0:\n                return JsonResponse(error_response_data, status=400)\n            else:\n                return func(*args, **kwargs)\n        return wrapped\n    return decorator\n\n\ndef require_post_params(*args, **kwargs):\n    \"\"\"\n    Checks for required parameters or renders a 400 error.\n    (decorator with arguments)\n\n    Functions like 'require_query_params', but checks for\n    POST parameters rather than GET parameters.\n    \"\"\"\n    required_params = []\n    required_params += [(arg, None) for arg in args]\n    required_params += [(key, kwargs[key]) for key in kwargs]\n    # required_params = e.g. [('action', 'enroll or unenroll'), ['emails', None]]\n\n    def decorator(func):  # pylint: disable=missing-docstring\n        def wrapped(*args, **kwargs):  # pylint: disable=missing-docstring\n            request = args[0]\n\n            error_response_data = {\n                'error': 'Missing required query parameter(s)',\n                'parameters': [],\n                'info': {},\n            }\n\n            for (param, extra) in required_params:\n                default = object()\n                if request.POST.get(param, default) == default:\n                    error_response_data['parameters'].append(param)\n                    error_response_data['info'][param] = extra\n\n            if len(error_response_data['parameters']) > 0:\n                return JsonResponse(error_response_data, status=400)\n            else:\n                return func(*args, **kwargs)\n        return wrapped\n    return decorator\n\n\ndef require_level(level):\n    \"\"\"\n    Decorator with argument that requires an access level of the requesting\n    user. If the requirement is not satisfied, returns an\n    HttpResponseForbidden (403).\n\n    Assumes that request is in args[0].\n    Assumes that course_id is in kwargs['course_id'].\n\n    `level` is in ['instructor', 'staff']\n    if `level` is 'staff', instructors will also be allowed, even\n        if they are not in the staff group.\n    \"\"\"\n    if level not in ['instructor', 'staff']:\n        raise ValueError(\"unrecognized level '{}'\".format(level))\n\n    def decorator(func):  # pylint: disable=missing-docstring\n        def wrapped(*args, **kwargs):  # pylint: disable=missing-docstring\n            request = args[0]\n            course = get_course_by_id(CourseKey.from_string(kwargs['course_id']))\n\n            if has_access(request.user, level, course):\n                return func(*args, **kwargs)\n            else:\n                return HttpResponseForbidden()\n        return wrapped\n    return decorator\n\n\ndef require_global_staff(func):\n    \"\"\"View decorator that requires that the user have global staff permissions. \"\"\"\n    def wrapped(request, *args, **kwargs):  # pylint: disable=missing-docstring\n        if GlobalStaff().has_user(request.user):\n            return func(request, *args, **kwargs)\n        else:\n            return HttpResponseForbidden(\n                u\"Must be {platform_name} staff to perform this action.\".format(\n                    platform_name=settings.PLATFORM_NAME\n                )\n            )\n    return wrapped\n\n\ndef require_sales_admin(func):\n    \"\"\"\n    Decorator for checking sales administrator access before executing an HTTP endpoint. This decorator\n    is designed to be used for a request based action on a course. It assumes that there will be a\n    request object as well as a course_id attribute to leverage to check course level privileges.\n\n    If the user does not have privileges for this operation, this will return HttpResponseForbidden (403).\n    \"\"\"\n    def wrapped(request, course_id):  # pylint: disable=missing-docstring\n\n        try:\n            course_key = CourseKey.from_string(course_id)\n        except InvalidKeyError:\n            log.error(u\"Unable to find course with course key %s\", course_id)\n            return HttpResponseNotFound()\n\n        access = auth.user_has_role(request.user, CourseSalesAdminRole(course_key))\n\n        if access:\n            return func(request, course_id)\n        else:\n            return HttpResponseForbidden()\n    return wrapped\n\n\ndef require_finance_admin(func):\n    \"\"\"\n    Decorator for checking finance administrator access before executing an HTTP endpoint. This decorator\n    is designed to be used for a request based action on a course. It assumes that there will be a\n    request object as well as a course_id attribute to leverage to check course level privileges.\n\n    If the user does not have privileges for this operation, this will return HttpResponseForbidden (403).\n    \"\"\"\n    def wrapped(request, course_id):  # pylint: disable=missing-docstring\n\n        try:\n            course_key = CourseKey.from_string(course_id)\n        except InvalidKeyError:\n            log.error(u\"Unable to find course with course key %s\", course_id)\n            return HttpResponseNotFound()\n\n        access = auth.user_has_role(request.user, CourseFinanceAdminRole(course_key))\n\n        if access:\n            return func(request, course_id)\n        else:\n            return HttpResponseForbidden()\n    return wrapped\n\n\nEMAIL_INDEX = 0\nUSERNAME_INDEX = 1\nNAME_INDEX = 2\nCOUNTRY_INDEX = 3\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef register_and_enroll_students(request, course_id):  # pylint: disable=too-many-statements\n    \"\"\"\n    Create new account and Enroll students in this course.\n    Passing a csv file that contains a list of students.\n    Order in csv should be the following email = 0; username = 1; name = 2; country = 3.\n    Requires staff access.\n\n    -If the email address and username already exists and the user is enrolled in the course,\n    do nothing (including no email gets sent out)\n\n    -If the email address already exists, but the username is different,\n    match on the email address only and continue to enroll the user in the course using the email address\n    as the matching criteria. Note the change of username as a warning message (but not a failure). Send a standard enrollment email\n    which is the same as the existing manual enrollment\n\n    -If the username already exists (but not the email), assume it is a different user and fail to create the new account.\n     The failure will be messaged in a response in the browser.\n    \"\"\"\n\n    if not microsite.get_value('ALLOW_AUTOMATED_SIGNUPS', settings.FEATURES.get('ALLOW_AUTOMATED_SIGNUPS', False)):\n        return HttpResponseForbidden()\n\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    warnings = []\n    row_errors = []\n    general_errors = []\n\n    # for white labels we use 'shopping cart' which uses CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG as\n    # course mode for creating course enrollments.\n    if CourseMode.is_white_label(course_id):\n        course_mode = CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG\n    else:\n        course_mode = None\n\n    if 'students_list' in request.FILES:\n        students = []\n\n        try:\n            upload_file = request.FILES.get('students_list')\n            if upload_file.name.endswith('.csv'):\n                students = [row for row in csv.reader(upload_file.read().splitlines())]\n                course = get_course_by_id(course_id)\n            else:\n                general_errors.append({\n                    'username': '', 'email': '',\n                    'response': _('Make sure that the file you upload is in CSV format with no extraneous characters or rows.')\n                })\n\n        except Exception:  # pylint: disable=broad-except\n            general_errors.append({\n                'username': '', 'email': '', 'response': _('Could not read uploaded file.')\n            })\n        finally:\n            upload_file.close()\n\n        generated_passwords = []\n        row_num = 0\n        for student in students:\n            row_num = row_num + 1\n\n            # verify that we have exactly four columns in every row but allow for blank lines\n            if len(student) != 4:\n                if len(student) > 0:\n                    general_errors.append({\n                        'username': '',\n                        'email': '',\n                        'response': _('Data in row #{row_num} must have exactly four columns: email, username, full name, and country').format(row_num=row_num)\n                    })\n                continue\n\n            # Iterate each student in the uploaded csv file.\n            email = student[EMAIL_INDEX]\n            username = student[USERNAME_INDEX]\n            name = student[NAME_INDEX]\n            country = student[COUNTRY_INDEX][:2]\n\n            email_params = get_email_params(course, True, secure=request.is_secure())\n            try:\n                validate_email(email)  # Raises ValidationError if invalid\n            except ValidationError:\n                row_errors.append({\n                    'username': username, 'email': email, 'response': _('Invalid email {email_address}.').format(email_address=email)})\n            else:\n                if User.objects.filter(email=email).exists():\n                    # Email address already exists. assume it is the correct user\n                    # and just register the user in the course and send an enrollment email.\n                    user = User.objects.get(email=email)\n\n                    # see if it is an exact match with email and username\n                    # if it's not an exact match then just display a warning message, but continue onwards\n                    if not User.objects.filter(email=email, username=username).exists():\n                        warning_message = _(\n                            'An account with email {email} exists but the provided username {username} '\n                            'is different. Enrolling anyway with {email}.'\n                        ).format(email=email, username=username)\n\n                        warnings.append({\n                            'username': username, 'email': email, 'response': warning_message\n                        })\n                        log.warning(u'email %s already exist', email)\n                    else:\n                        log.info(\n                            u\"user already exists with username '%s' and email '%s'\",\n                            username,\n                            email\n                        )\n\n                    # enroll a user if it is not already enrolled.\n                    if not CourseEnrollment.is_enrolled(user, course_id):\n                        # Enroll user to the course and add manual enrollment audit trail\n                        create_manual_course_enrollment(\n                            user=user,\n                            course_id=course_id,\n                            mode=course_mode,\n                            enrolled_by=request.user,\n                            reason='Enrolling via csv upload',\n                            state_transition=UNENROLLED_TO_ENROLLED,\n                        )\n                        enroll_email(course_id=course_id, student_email=email, auto_enroll=True, email_students=True, email_params=email_params)\n                else:\n                    # This email does not yet exist, so we need to create a new account\n                    # If username already exists in the database, then create_and_enroll_user\n                    # will raise an IntegrityError exception.\n                    password = generate_unique_password(generated_passwords)\n                    errors = create_and_enroll_user(\n                        email, username, name, country, password, course_id, course_mode, request.user, email_params\n                    )\n                    row_errors.extend(errors)\n\n    else:\n        general_errors.append({\n            'username': '', 'email': '', 'response': _('File is not attached.')\n        })\n\n    results = {\n        'row_errors': row_errors,\n        'general_errors': general_errors,\n        'warnings': warnings\n    }\n    return JsonResponse(results)\n\n\ndef generate_random_string(length):\n    \"\"\"\n    Create a string of random characters of specified length\n    \"\"\"\n    chars = [\n        char for char in string.ascii_uppercase + string.digits + string.ascii_lowercase\n        if char not in 'aAeEiIoOuU1l'\n    ]\n\n    return string.join((random.choice(chars) for __ in range(length)), '')\n\n\ndef generate_unique_password(generated_passwords, password_length=12):\n    \"\"\"\n    generate a unique password for each student.\n    \"\"\"\n\n    password = generate_random_string(password_length)\n    while password in generated_passwords:\n        password = generate_random_string(password_length)\n\n    generated_passwords.append(password)\n\n    return password\n\n\ndef create_user_and_user_profile(email, username, name, country, password):\n    \"\"\"\n    Create a new user, add a new Registration instance for letting user verify its identity and create a user profile.\n\n    :param email: user's email address\n    :param username: user's username\n    :param name: user's name\n    :param country: user's country\n    :param password: user's password\n\n    :return: User instance of the new user.\n    \"\"\"\n    user = User.objects.create_user(username, email, password)\n    reg = Registration()\n    reg.register(user)\n\n    profile = UserProfile(user=user)\n    profile.name = name\n    profile.country = country\n    profile.save()\n\n    return user\n\n\ndef create_manual_course_enrollment(user, course_id, mode, enrolled_by, reason, state_transition):\n    \"\"\"\n    Create course enrollment for the given student and create manual enrollment audit trail.\n\n    :param user: User who is to enroll in course\n    :param course_id: course identifier of the course in which to enroll the user.\n    :param mode: mode for user enrollment, e.g. 'honor', 'audit' etc.\n    :param enrolled_by: User who made the manual enrollment entry (usually instructor or support)\n    :param reason: Reason behind manual enrollment\n    :param state_transition: state transition denoting whether student enrolled from un-enrolled,\n            un-enrolled from enrolled etc.\n    :return CourseEnrollment instance.\n    \"\"\"\n    enrollment_obj = CourseEnrollment.enroll(user, course_id, mode=mode)\n    ManualEnrollmentAudit.create_manual_enrollment_audit(\n        enrolled_by, user.email, state_transition, reason, enrollment_obj\n    )\n\n    log.info(u'user %s enrolled in the course %s', user.username, course_id)\n    return enrollment_obj\n\n\ndef create_and_enroll_user(email, username, name, country, password, course_id, course_mode, enrolled_by, email_params):\n    \"\"\"\n    Create a new user and enroll him/her to the given course, return list of errors in the following format\n        Error format:\n            each error is key-value pait dict with following key-value pairs.\n            1. username: username of the user to enroll\n            1. email: email of the user to enroll\n            1. response: readable error message\n\n    :param email: user's email address\n    :param username: user's username\n    :param name: user's name\n    :param country: user's country\n    :param password: user's password\n    :param course_id: course identifier of the course in which to enroll the user.\n    :param course_mode: mode for user enrollment, e.g. 'honor', 'audit' etc.\n    :param enrolled_by: User who made the manual enrollment entry (usually instructor or support)\n    :param email_params: information to send to the user via email\n\n    :return: list of errors\n    \"\"\"\n    errors = list()\n    try:\n        with transaction.atomic():\n            # Create a new user\n            user = create_user_and_user_profile(email, username, name, country, password)\n\n            # Enroll user to the course and add manual enrollment audit trail\n            create_manual_course_enrollment(\n                user=user,\n                course_id=course_id,\n                mode=course_mode,\n                enrolled_by=enrolled_by,\n                reason='Enrolling via csv upload',\n                state_transition=UNENROLLED_TO_ENROLLED,\n            )\n    except IntegrityError:\n        errors.append({\n            'username': username, 'email': email, 'response': _('Username {user} already exists.').format(user=username)\n        })\n    except Exception as ex:  # pylint: disable=broad-except\n        log.exception(type(ex).__name__)\n        errors.append({\n            'username': username, 'email': email, 'response': type(ex).__name__,\n        })\n    else:\n        try:\n            # It's a new user, an email will be sent to each newly created user.\n            email_params.update({\n                'message': 'account_creation_and_enrollment',\n                'email_address': email,\n                'password': password,\n                'platform_name': microsite.get_value('platform_name', settings.PLATFORM_NAME),\n            })\n            send_mail_to_student(email, email_params)\n        except Exception as ex:  # pylint: disable=broad-except\n            log.exception(\n                \"Exception '{exception}' raised while sending email to new user.\".format(exception=type(ex).__name__)\n            )\n            errors.append({\n                'username': username,\n                'email': email,\n                'response':\n                    _(\"Error '{error}' while sending email to new user (user email={email}). \"\n                      \"Without the email student would not be able to login. \"\n                      \"Please contact support for further information.\").format(error=type(ex).__name__, email=email),\n            })\n        else:\n            log.info(u'email sent to new created user at %s', email)\n\n    return errors\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params(action=\"enroll or unenroll\", identifiers=\"stringified list of emails and/or usernames\")\ndef students_update_enrollment(request, course_id):\n    \"\"\"\n    Enroll or unenroll students by email.\n    Requires staff access.\n\n    Query Parameters:\n    - action in ['enroll', 'unenroll']\n    - identifiers is string containing a list of emails and/or usernames separated by anything split_input_list can handle.\n    - auto_enroll is a boolean (defaults to false)\n        If auto_enroll is false, students will be allowed to enroll.\n        If auto_enroll is true, students will be enrolled as soon as they register.\n    - email_students is a boolean (defaults to false)\n        If email_students is true, students will be sent email notification\n        If email_students is false, students will not be sent email notification\n\n    Returns an analog to this JSON structure: {\n        \"action\": \"enroll\",\n        \"auto_enroll\": false,\n        \"results\": [\n            {\n                \"email\": \"testemail@test.org\",\n                \"before\": {\n                    \"enrollment\": false,\n                    \"auto_enroll\": false,\n                    \"user\": true,\n                    \"allowed\": false\n                },\n                \"after\": {\n                    \"enrollment\": true,\n                    \"auto_enroll\": false,\n                    \"user\": true,\n                    \"allowed\": false\n                }\n            }\n        ]\n    }\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    action = request.POST.get('action')\n    identifiers_raw = request.POST.get('identifiers')\n    identifiers = _split_input_list(identifiers_raw)\n    auto_enroll = request.POST.get('auto_enroll') in ['true', 'True', True]\n    email_students = request.POST.get('email_students') in ['true', 'True', True]\n    is_white_label = CourseMode.is_white_label(course_id)\n    reason = request.POST.get('reason')\n    if is_white_label:\n        if not reason:\n            return JsonResponse(\n                {\n                    'action': action,\n                    'results': [{'error': True}],\n                    'auto_enroll': auto_enroll,\n                }, status=400)\n    enrollment_obj = None\n    state_transition = DEFAULT_TRANSITION_STATE\n\n    email_params = {}\n    if email_students:\n        course = get_course_by_id(course_id)\n        email_params = get_email_params(course, auto_enroll, secure=request.is_secure())\n\n    results = []\n    for identifier in identifiers:\n        # First try to get a user object from the identifer\n        user = None\n        email = None\n        language = None\n        try:\n            user = get_student_from_identifier(identifier)\n        except User.DoesNotExist:\n            email = identifier\n        else:\n            email = user.email\n            language = get_user_email_language(user)\n\n        try:\n            # Use django.core.validators.validate_email to check email address\n            # validity (obviously, cannot check if email actually /exists/,\n            # simply that it is plausibly valid)\n            validate_email(email)  # Raises ValidationError if invalid\n            if action == 'enroll':\n                before, after, enrollment_obj = enroll_email(\n                    course_id, email, auto_enroll, email_students, email_params, language=language\n                )\n                before_enrollment = before.to_dict()['enrollment']\n                before_user_registered = before.to_dict()['user']\n                before_allowed = before.to_dict()['allowed']\n                after_enrollment = after.to_dict()['enrollment']\n                after_allowed = after.to_dict()['allowed']\n\n                if before_user_registered:\n                    if after_enrollment:\n                        if before_enrollment:\n                            state_transition = ENROLLED_TO_ENROLLED\n                        else:\n                            if before_allowed:\n                                state_transition = ALLOWEDTOENROLL_TO_ENROLLED\n                            else:\n                                state_transition = UNENROLLED_TO_ENROLLED\n                else:\n                    if after_allowed:\n                        state_transition = UNENROLLED_TO_ALLOWEDTOENROLL\n\n            elif action == 'unenroll':\n                before, after = unenroll_email(\n                    course_id, email, email_students, email_params, language=language\n                )\n                before_enrollment = before.to_dict()['enrollment']\n                before_allowed = before.to_dict()['allowed']\n                enrollment_obj = CourseEnrollment.get_enrollment(user, course_id)\n\n                if before_enrollment:\n                    state_transition = ENROLLED_TO_UNENROLLED\n                else:\n                    if before_allowed:\n                        state_transition = ALLOWEDTOENROLL_TO_UNENROLLED\n                    else:\n                        state_transition = UNENROLLED_TO_UNENROLLED\n\n            else:\n                return HttpResponseBadRequest(strip_tags(\n                    \"Unrecognized action '{}'\".format(action)\n                ))\n\n        except ValidationError:\n            # Flag this email as an error if invalid, but continue checking\n            # the remaining in the list\n            results.append({\n                'identifier': identifier,\n                'invalidIdentifier': True,\n            })\n\n        except Exception as exc:  # pylint: disable=broad-except\n            # catch and log any exceptions\n            # so that one error doesn't cause a 500.\n            log.exception(u\"Error while #{}ing student\")\n            log.exception(exc)\n            results.append({\n                'identifier': identifier,\n                'error': True,\n            })\n\n        else:\n            ManualEnrollmentAudit.create_manual_enrollment_audit(\n                request.user, email, state_transition, reason, enrollment_obj\n            )\n            results.append({\n                'identifier': identifier,\n                'before': before.to_dict(),\n                'after': after.to_dict(),\n            })\n\n    response_payload = {\n        'action': action,\n        'results': results,\n        'auto_enroll': auto_enroll,\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@common_exceptions_400\n@require_post_params(\n    identifiers=\"stringified list of emails and/or usernames\",\n    action=\"add or remove\",\n)\ndef bulk_beta_modify_access(request, course_id):\n    \"\"\"\n    Enroll or unenroll users in beta testing program.\n\n    Query parameters:\n    - identifiers is string containing a list of emails and/or usernames separated by\n      anything split_input_list can handle.\n    - action is one of ['add', 'remove']\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    action = request.POST.get('action')\n    identifiers_raw = request.POST.get('identifiers')\n    identifiers = _split_input_list(identifiers_raw)\n    email_students = request.POST.get('email_students') in ['true', 'True', True]\n    auto_enroll = request.POST.get('auto_enroll') in ['true', 'True', True]\n    results = []\n    rolename = 'beta'\n    course = get_course_by_id(course_id)\n\n    email_params = {}\n    if email_students:\n        secure = request.is_secure()\n        email_params = get_email_params(course, auto_enroll=auto_enroll, secure=secure)\n\n    for identifier in identifiers:\n        try:\n            error = False\n            user_does_not_exist = False\n            user = get_student_from_identifier(identifier)\n\n            if action == 'add':\n                allow_access(course, user, rolename)\n            elif action == 'remove':\n                revoke_access(course, user, rolename)\n            else:\n                return HttpResponseBadRequest(strip_tags(\n                    \"Unrecognized action '{}'\".format(action)\n                ))\n        except User.DoesNotExist:\n            error = True\n            user_does_not_exist = True\n        # catch and log any unexpected exceptions\n        # so that one error doesn't cause a 500.\n        except Exception as exc:  # pylint: disable=broad-except\n            log.exception(u\"Error while #{}ing student\")\n            log.exception(exc)\n            error = True\n        else:\n            # If no exception thrown, see if we should send an email\n            if email_students:\n                send_beta_role_email(action, user, email_params)\n            # See if we should autoenroll the student\n            if auto_enroll:\n                # Check if student is already enrolled\n                if not CourseEnrollment.is_enrolled(user, course_id):\n                    CourseEnrollment.enroll(user, course_id)\n\n        finally:\n            # Tabulate the action result of this email address\n            results.append({\n                'identifier': identifier,\n                'error': error,\n                'userDoesNotExist': user_does_not_exist\n            })\n\n    response_payload = {\n        'action': action,\n        'results': results,\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@common_exceptions_400\n@require_query_params(\n    unique_student_identifier=\"email or username of user to change access\",\n    rolename=\"'instructor', 'staff', 'beta', or 'ccx_coach'\",\n    action=\"'allow' or 'revoke'\"\n)\ndef modify_access(request, course_id):\n    \"\"\"\n    Modify staff/instructor access of other user.\n    Requires instructor access.\n\n    NOTE: instructors cannot remove their own instructor access.\n\n    Query parameters:\n    unique_student_identifer is the target user's username or email\n    rolename is one of ['instructor', 'staff', 'beta', 'ccx_coach']\n    action is one of ['allow', 'revoke']\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'instructor', course_id, depth=None\n    )\n    try:\n        user = get_student_from_identifier(request.GET.get('unique_student_identifier'))\n    except User.DoesNotExist:\n        response_payload = {\n            'unique_student_identifier': request.GET.get('unique_student_identifier'),\n            'userDoesNotExist': True,\n        }\n        return JsonResponse(response_payload)\n\n    # Check that user is active, because add_users\n    # in common/djangoapps/student/roles.py fails\n    # silently when we try to add an inactive user.\n    if not user.is_active:\n        response_payload = {\n            'unique_student_identifier': user.username,\n            'inactiveUser': True,\n        }\n        return JsonResponse(response_payload)\n\n    rolename = request.GET.get('rolename')\n    action = request.GET.get('action')\n\n    if rolename not in ROLES:\n        error = strip_tags(\"unknown rolename '{}'\".format(rolename))\n        log.error(error)\n        return HttpResponseBadRequest(error)\n\n    # disallow instructors from removing their own instructor access.\n    if rolename == 'instructor' and user == request.user and action != 'allow':\n        response_payload = {\n            'unique_student_identifier': user.username,\n            'rolename': rolename,\n            'action': action,\n            'removingSelfAsInstructor': True,\n        }\n        return JsonResponse(response_payload)\n\n    if action == 'allow':\n        allow_access(course, user, rolename)\n    elif action == 'revoke':\n        revoke_access(course, user, rolename)\n    else:\n        return HttpResponseBadRequest(strip_tags(\n            \"unrecognized action '{}'\".format(action)\n        ))\n\n    response_payload = {\n        'unique_student_identifier': user.username,\n        'rolename': rolename,\n        'action': action,\n        'success': 'yes',\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@require_query_params(rolename=\"'instructor', 'staff', or 'beta'\")\ndef list_course_role_members(request, course_id):\n    \"\"\"\n    List instructors and staff.\n    Requires instructor access.\n\n    rolename is one of ['instructor', 'staff', 'beta', 'ccx_coach']\n\n    Returns JSON of the form {\n        \"course_id\": \"some/course/id\",\n        \"staff\": [\n            {\n                \"username\": \"staff1\",\n                \"email\": \"staff1@example.org\",\n                \"first_name\": \"Joe\",\n                \"last_name\": \"Shmoe\",\n            }\n        ]\n    }\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'instructor', course_id, depth=None\n    )\n\n    rolename = request.GET.get('rolename')\n\n    if rolename not in ROLES:\n        return HttpResponseBadRequest()\n\n    def extract_user_info(user):\n        \"\"\" convert user into dicts for json view \"\"\"\n        return {\n            'username': user.username,\n            'email': user.email,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n        }\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        rolename: map(extract_user_info, list_with_level(\n            course, rolename\n        )),\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_problem_responses(request, course_id):\n    \"\"\"\n    Initiate generation of a CSV file containing all student answers\n    to a given problem.\n\n    Responds with JSON\n        {\"status\": \"... status message ...\"}\n\n    if initiation is successful (or generation task is already running).\n\n    Responds with BadRequest if problem location is faulty.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    problem_location = request.GET.get('problem_location', '')\n\n    try:\n        problem_key = UsageKey.from_string(problem_location)\n        # Are we dealing with an \"old-style\" problem location?\n        run = problem_key.run\n        if not run:\n            problem_key = course_key.make_usage_key_from_deprecated_string(problem_location)\n        if problem_key.course_key != course_key:\n            raise InvalidKeyError(type(problem_key), problem_key)\n    except InvalidKeyError:\n        return JsonResponseBadRequest(_(\"Could not find problem with this location.\"))\n\n    try:\n        instructor_task.api.submit_calculate_problem_responses_csv(request, course_key, problem_location)\n        success_status = _(\n            \"The problem responses report is being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n        )\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\n            \"A problem responses report generation task is already in progress. \"\n            \"Check the 'Pending Tasks' table for the status of the task. \"\n            \"When completed, the report will be available for download in the table below.\"\n        )\n        return JsonResponse({\"status\": already_running_status})\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_grading_config(request, course_id):\n    \"\"\"\n    Respond with json which contains a html formatted grade summary.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n    grading_config_summary = instructor_analytics.basic.dump_grading_context(course)\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'grading_config_summary': grading_config_summary,\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_sale_records(request, course_id, csv=False):  # pylint: disable=unused-argument, redefined-outer-name\n    \"\"\"\n    return the summary of all sales records for a particular course\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    query_features = [\n        'company_name', 'company_contact_name', 'company_contact_email', 'total_codes', 'total_used_codes',\n        'total_amount', 'created', 'customer_reference_number', 'recipient_name', 'recipient_email', 'created_by',\n        'internal_reference', 'invoice_number', 'codes', 'course_id'\n    ]\n\n    sale_data = instructor_analytics.basic.sale_record_features(course_id, query_features)\n\n    if not csv:\n        for item in sale_data:\n            item['created_by'] = item['created_by'].username\n\n        response_payload = {\n            'course_id': course_id.to_deprecated_string(),\n            'sale': sale_data,\n            'queried_features': query_features\n        }\n        return JsonResponse(response_payload)\n    else:\n        header, datarows = instructor_analytics.csvs.format_dictlist(sale_data, query_features)\n        return instructor_analytics.csvs.create_csv_response(\"e-commerce_sale_invoice_records.csv\", header, datarows)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_sale_order_records(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    return the summary of all sales records for a particular course\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    query_features = [\n        ('id', 'Order Id'),\n        ('company_name', 'Company Name'),\n        ('company_contact_name', 'Company Contact Name'),\n        ('company_contact_email', 'Company Contact Email'),\n        ('logged_in_username', 'Login Username'),\n        ('logged_in_email', 'Login User Email'),\n        ('purchase_time', 'Date of Sale'),\n        ('customer_reference_number', 'Customer Reference Number'),\n        ('recipient_name', 'Recipient Name'),\n        ('recipient_email', 'Recipient Email'),\n        ('bill_to_street1', 'Street 1'),\n        ('bill_to_street2', 'Street 2'),\n        ('bill_to_city', 'City'),\n        ('bill_to_state', 'State'),\n        ('bill_to_postalcode', 'Postal Code'),\n        ('bill_to_country', 'Country'),\n        ('order_type', 'Order Type'),\n        ('status', 'Order Item Status'),\n        ('coupon_code', 'Coupon Code'),\n        ('list_price', 'List Price'),\n        ('unit_cost', 'Unit Price'),\n        ('quantity', 'Quantity'),\n        ('total_discount', 'Total Discount'),\n        ('total_amount', 'Total Amount Paid'),\n    ]\n\n    db_columns = [x[0] for x in query_features]\n    csv_columns = [x[1] for x in query_features]\n    sale_data = instructor_analytics.basic.sale_order_record_features(course_id, db_columns)\n    __, datarows = instructor_analytics.csvs.format_dictlist(sale_data, db_columns)\n    return instructor_analytics.csvs.create_csv_response(\"e-commerce_sale_order_records.csv\", csv_columns, datarows)\n\n\n@require_level('staff')\n@require_POST\ndef sale_validation(request, course_id):\n    \"\"\"\n    This method either invalidate or re validate the sale against the invoice number depending upon the event type\n    \"\"\"\n    try:\n        invoice_number = request.POST[\"invoice_number\"]\n    except KeyError:\n        return HttpResponseBadRequest(\"Missing required invoice_number parameter\")\n    try:\n        invoice_number = int(invoice_number)\n    except ValueError:\n        return HttpResponseBadRequest(\n            \"invoice_number must be an integer, {value} provided\".format(\n                value=invoice_number\n            )\n        )\n    try:\n        event_type = request.POST[\"event_type\"]\n    except KeyError:\n        return HttpResponseBadRequest(\"Missing required event_type parameter\")\n\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        obj_invoice = CourseRegistrationCodeInvoiceItem.objects.select_related('invoice').get(\n            invoice_id=invoice_number,\n            course_id=course_id\n        )\n        obj_invoice = obj_invoice.invoice\n    except CourseRegistrationCodeInvoiceItem.DoesNotExist:  # Check for old type invoices\n        return HttpResponseNotFound(_(\"Invoice number '{num}' does not exist.\").format(num=invoice_number))\n\n    if event_type == \"invalidate\":\n        return invalidate_invoice(obj_invoice)\n    else:\n        return re_validate_invoice(obj_invoice)\n\n\ndef invalidate_invoice(obj_invoice):\n    \"\"\"\n    This method invalidate the sale against the invoice number\n    \"\"\"\n    if not obj_invoice.is_valid:\n        return HttpResponseBadRequest(_(\"The sale associated with this invoice has already been invalidated.\"))\n    obj_invoice.is_valid = False\n    obj_invoice.save()\n    message = _('Invoice number {0} has been invalidated.').format(obj_invoice.id)\n    return JsonResponse({'message': message})\n\n\ndef re_validate_invoice(obj_invoice):\n    \"\"\"\n    This method re-validate the sale against the invoice number\n    \"\"\"\n    if obj_invoice.is_valid:\n        return HttpResponseBadRequest(_(\"This invoice is already active.\"))\n\n    obj_invoice.is_valid = True\n    obj_invoice.save()\n    message = _('The registration codes for invoice {0} have been re-activated.').format(obj_invoice.id)\n    return JsonResponse({'message': message})\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_issued_certificates(request, course_id):\n    \"\"\"\n    Responds with JSON if CSV is not required. contains a list of issued certificates.\n    Arguments:\n        course_id\n    Returns:\n        {\"certificates\": [{course_id: xyz, mode: 'honor'}, ...]}\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    csv_required = request.GET.get('csv', 'false')\n\n    query_features = ['course_id', 'mode', 'total_issued_certificate', 'report_run_date']\n    query_features_names = [\n        ('course_id', _('CourseID')),\n        ('mode', _('Certificate Type')),\n        ('total_issued_certificate', _('Total Certificates Issued')),\n        ('report_run_date', _('Date Report Run'))\n    ]\n    certificates_data = instructor_analytics.basic.issued_certificates(course_key, query_features)\n    if csv_required.lower() == 'true':\n        __, data_rows = instructor_analytics.csvs.format_dictlist(certificates_data, query_features)\n        return instructor_analytics.csvs.create_csv_response(\n            'issued_certificates.csv',\n            [col_header for __, col_header in query_features_names],\n            data_rows\n        )\n    else:\n        response_payload = {\n            'certificates': certificates_data,\n            'queried_features': query_features,\n            'feature_names': dict(query_features_names)\n        }\n        return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_students_features(request, course_id, csv=False):  # pylint: disable=redefined-outer-name\n    \"\"\"\n    Respond with json which contains a summary of all enrolled students profile information.\n\n    Responds with JSON\n        {\"students\": [{-student-info-}, ...]}\n\n    TO DO accept requests for different attribute sets.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    course = get_course_by_id(course_key)\n\n    available_features = instructor_analytics.basic.AVAILABLE_FEATURES\n\n    # Allow for microsites to be able to define additional columns.\n    # Note that adding additional columns has the potential to break\n    # the student profile report due to a character limit on the\n    # asynchronous job input which in this case is a JSON string\n    # containing the list of columns to include in the report.\n    # TODO: Refactor the student profile report code to remove the list of columns\n    # that should be included in the report from the asynchronous job input.\n    # We need to clone the list because we modify it below\n    query_features = list(microsite.get_value('student_profile_download_fields', []))\n\n    if not query_features:\n        query_features = [\n            'id', 'username', 'name', 'email', 'language', 'location',\n            'year_of_birth', 'gender', 'level_of_education', 'mailing_address',\n            'goals',\n        ]\n\n    # Provide human-friendly and translatable names for these features. These names\n    # will be displayed in the table generated in data_download.coffee. It is not (yet)\n    # used as the header row in the CSV, but could be in the future.\n    query_features_names = {\n        'id': _('User ID'),\n        'username': _('Username'),\n        'name': _('Name'),\n        'email': _('Email'),\n        'language': _('Language'),\n        'location': _('Location'),\n        'year_of_birth': _('Birth Year'),\n        'gender': _('Gender'),\n        'level_of_education': _('Level of Education'),\n        'mailing_address': _('Mailing Address'),\n        'goals': _('Goals'),\n    }\n\n    if is_course_cohorted(course.id):\n        # Translators: 'Cohort' refers to a group of students within a course.\n        query_features.append('cohort')\n        query_features_names['cohort'] = _('Cohort')\n\n    if course.teams_enabled:\n        query_features.append('team')\n        query_features_names['team'] = _('Team')\n\n    # For compatibility reasons, city and country should always appear last.\n    query_features.append('city')\n    query_features_names['city'] = _('City')\n    query_features.append('country')\n    query_features_names['country'] = _('Country')\n\n    if not csv:\n        student_data = instructor_analytics.basic.enrolled_students_features(course_key, query_features)\n        response_payload = {\n            'course_id': unicode(course_key),\n            'students': student_data,\n            'students_count': len(student_data),\n            'queried_features': query_features,\n            'feature_names': query_features_names,\n            'available_features': available_features,\n        }\n        return JsonResponse(response_payload)\n    else:\n        try:\n            instructor_task.api.submit_calculate_students_features_csv(request, course_key, query_features)\n            success_status = _(\"The enrolled learner profile report is being created.\"\n                               \" To view the status of the report, see Pending Tasks below.\")\n            return JsonResponse({\"status\": success_status})\n        except AlreadyRunningError:\n            already_running_status = _(\n                \"This enrollment report is currently being created.\"\n                \" To view the status of the report, see Pending Tasks below.\"\n                \" You will be able to download the report when it is complete.\")\n            return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_students_who_may_enroll(request, course_id):\n    \"\"\"\n    Initiate generation of a CSV file containing information about\n    students who may enroll in a course.\n\n    Responds with JSON\n        {\"status\": \"... status message ...\"}\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    query_features = ['email']\n    try:\n        instructor_task.api.submit_calculate_may_enroll_csv(request, course_key, query_features)\n        success_status = _(\n            \"The enrollment report is being created. This report contains\"\n            \" information about learners who can enroll in the course.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n        )\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\n            \"This enrollment report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n        return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_POST\n@require_level('staff')\ndef add_users_to_cohorts(request, course_id):\n    \"\"\"\n    View method that accepts an uploaded file (using key \"uploaded-file\")\n    containing cohort assignments for users. This method spawns a celery task\n    to do the assignments, and a CSV file with results is provided via data downloads.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_string(course_id)\n\n    try:\n        def validator(file_storage, file_to_validate):\n            \"\"\"\n            Verifies that the expected columns are present.\n            \"\"\"\n            with file_storage.open(file_to_validate) as f:\n                reader = unicodecsv.reader(UniversalNewlineIterator(f), encoding='utf-8')\n                try:\n                    fieldnames = next(reader)\n                except StopIteration:\n                    fieldnames = []\n                msg = None\n                if \"cohort\" not in fieldnames:\n                    msg = _(\"The file must contain a 'cohort' column containing cohort names.\")\n                elif \"email\" not in fieldnames and \"username\" not in fieldnames:\n                    msg = _(\"The file must contain a 'username' column, an 'email' column, or both.\")\n                if msg:\n                    raise FileValidationException(msg)\n\n        __, filename = store_uploaded_file(\n            request, 'uploaded-file', ['.csv'],\n            course_and_time_based_filename_generator(course_key, \"cohorts\"),\n            max_file_size=2000000,  # limit to 2 MB\n            validator=validator\n        )\n        # The task will assume the default file storage.\n        instructor_task.api.submit_cohort_students(request, course_key, filename)\n    except (FileValidationException, PermissionDenied) as err:\n        return JsonResponse({\"error\": unicode(err)}, status=400)\n\n    return JsonResponse()\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_coupon_codes(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    Respond with csv which contains a summary of all Active Coupons.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    coupons = Coupon.objects.filter(course_id=course_id)\n\n    query_features = [\n        ('code', _('Coupon Code')),\n        ('course_id', _('Course Id')),\n        ('percentage_discount', _('% Discount')),\n        ('description', _('Description')),\n        ('expiration_date', _('Expiration Date')),\n        ('is_active', _('Is Active')),\n        ('code_redeemed_count', _('Code Redeemed Count')),\n        ('total_discounted_seats', _('Total Discounted Seats')),\n        ('total_discounted_amount', _('Total Discounted Amount')),\n    ]\n    db_columns = [x[0] for x in query_features]\n    csv_columns = [x[1] for x in query_features]\n\n    coupons_list = instructor_analytics.basic.coupon_codes_features(db_columns, coupons, course_id)\n    __, data_rows = instructor_analytics.csvs.format_dictlist(coupons_list, db_columns)\n    return instructor_analytics.csvs.create_csv_response('Coupons.csv', csv_columns, data_rows)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_finance_admin\ndef get_enrollment_report(request, course_id):\n    \"\"\"\n    get the enrollment report for the particular course.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_detailed_enrollment_features_csv(request, course_key)\n        success_status = _(\"The detailed enrollment report is being created.\"\n                           \" To view the status of the report, see Pending Tasks below.\")\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\"The detailed enrollment report is being created.\"\n                                   \" To view the status of the report, see Pending Tasks below.\"\n                                   \" You will be able to download the report when it is complete.\")\n        return JsonResponse({\n            \"status\": already_running_status\n        })\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_finance_admin\ndef get_exec_summary_report(request, course_id):\n    \"\"\"\n    get the executive summary report for the particular course.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_executive_summary_report(request, course_key)\n        status_response = _(\"The executive summary report is being created.\"\n                            \" To view the status of the report, see Pending Tasks below.\")\n    except AlreadyRunningError:\n        status_response = _(\n            \"The executive summary report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n    return JsonResponse({\n        \"status\": status_response\n    })\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_course_survey_results(request, course_id):\n    \"\"\"\n    get the survey results report for the particular course.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_course_survey_report(request, course_key)\n        status_response = _(\"The survey report is being created.\"\n                            \" To view the status of the report, see Pending Tasks below.\")\n    except AlreadyRunningError:\n        status_response = _(\n            \"The survey report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n    return JsonResponse({\n        \"status\": status_response\n    })\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_proctored_exam_results(request, course_id):\n    \"\"\"\n    get the proctored exam resultsreport for the particular course.\n    \"\"\"\n    query_features = [\n        'user_email',\n        'exam_name',\n        'attempt_code',\n        'allowed_time_limit_mins',\n        'is_sample_attempt',\n        'started_at',\n        'completed_at',\n        'status',\n    ]\n\n    course_key = CourseKey.from_string(course_id)\n    try:\n        instructor_task.api.submit_proctored_exam_results_report(request, course_key, query_features)\n        status_response = _(\"The proctored exam results report is being created.\"\n                            \" To view the status of the report, see Pending Tasks below.\")\n    except AlreadyRunningError:\n        status_response = _(\n            \"The proctored exam results report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n    return JsonResponse({\n        \"status\": status_response\n    })\n\n\ndef save_registration_code(user, course_id, mode_slug, invoice=None, order=None, invoice_item=None):\n    \"\"\"\n    recursive function that generate a new code every time and saves in the Course Registration Table\n    if validation check passes\n\n    Args:\n        user (User): The user creating the course registration codes.\n        course_id (str): The string representation of the course ID.\n        mode_slug (str): The Course Mode Slug associated with any enrollment made by these codes.\n        invoice (Invoice): (Optional) The associated invoice for this code.\n        order (Order): (Optional) The associated order for this code.\n        invoice_item (CourseRegistrationCodeInvoiceItem) : (Optional) The associated CourseRegistrationCodeInvoiceItem\n\n    Returns:\n        The newly created CourseRegistrationCode.\n\n    \"\"\"\n    code = random_code_generator()\n\n    # check if the generated code is in the Coupon Table\n    matching_coupons = Coupon.objects.filter(code=code, is_active=True)\n    if matching_coupons:\n        return save_registration_code(\n            user, course_id, mode_slug, invoice=invoice, order=order, invoice_item=invoice_item\n        )\n\n    course_registration = CourseRegistrationCode(\n        code=code,\n        course_id=unicode(course_id),\n        created_by=user,\n        invoice=invoice,\n        order=order,\n        mode_slug=mode_slug,\n        invoice_item=invoice_item\n    )\n    try:\n        with transaction.atomic():\n            course_registration.save()\n        return course_registration\n    except IntegrityError:\n        return save_registration_code(\n            user, course_id, mode_slug, invoice=invoice, order=order, invoice_item=invoice_item\n        )\n\n\ndef registration_codes_csv(file_name, codes_list, csv_type=None):\n    \"\"\"\n    Respond with the csv headers and data rows\n    given a dict of codes list\n    :param file_name:\n    :param codes_list:\n    :param csv_type:\n    \"\"\"\n    # csv headers\n    query_features = [\n        'code', 'redeem_code_url', 'course_id', 'company_name', 'created_by',\n        'redeemed_by', 'invoice_id', 'purchaser', 'customer_reference_number', 'internal_reference', 'is_valid'\n    ]\n\n    registration_codes = instructor_analytics.basic.course_registration_features(query_features, codes_list, csv_type)\n    header, data_rows = instructor_analytics.csvs.format_dictlist(registration_codes, query_features)\n    return instructor_analytics.csvs.create_csv_response(file_name, header, data_rows)\n\n\ndef random_code_generator():\n    \"\"\"\n    generate a random alphanumeric code of length defined in\n    REGISTRATION_CODE_LENGTH settings\n    \"\"\"\n    code_length = getattr(settings, 'REGISTRATION_CODE_LENGTH', 8)\n    return generate_random_string(code_length)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef get_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Registration Codes.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    #filter all the  course registration codes\n    registration_codes = CourseRegistrationCode.objects.filter(\n        course_id=course_id\n    ).order_by('invoice_item__invoice__company_name')\n\n    company_name = request.POST['download_company_name']\n    if company_name:\n        registration_codes = registration_codes.filter(invoice_item__invoice__company_name=company_name)\n\n    csv_type = 'download'\n    return registration_codes_csv(\"Registration_Codes.csv\", registration_codes, csv_type)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_sales_admin\n@require_POST\ndef generate_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Generated Codes.\n    \"\"\"\n    course_id = CourseKey.from_string(course_id)\n    invoice_copy = False\n\n    # covert the course registration code number into integer\n    try:\n        course_code_number = int(request.POST['total_registration_codes'])\n    except ValueError:\n        course_code_number = int(float(request.POST['total_registration_codes']))\n\n    company_name = request.POST['company_name']\n    company_contact_name = request.POST['company_contact_name']\n    company_contact_email = request.POST['company_contact_email']\n    unit_price = request.POST['unit_price']\n\n    try:\n        unit_price = (\n            decimal.Decimal(unit_price)\n        ).quantize(\n            decimal.Decimal('.01'),\n            rounding=decimal.ROUND_DOWN\n        )\n    except decimal.InvalidOperation:\n        return HttpResponse(\n            status=400,\n            content=_(u\"Could not parse amount as a decimal\")\n        )\n\n    recipient_name = request.POST['recipient_name']\n    recipient_email = request.POST['recipient_email']\n    address_line_1 = request.POST['address_line_1']\n    address_line_2 = request.POST['address_line_2']\n    address_line_3 = request.POST['address_line_3']\n    city = request.POST['city']\n    state = request.POST['state']\n    zip_code = request.POST['zip']\n    country = request.POST['country']\n    internal_reference = request.POST['internal_reference']\n    customer_reference_number = request.POST['customer_reference_number']\n    recipient_list = [recipient_email]\n    if request.POST.get('invoice', False):\n        recipient_list.append(request.user.email)\n        invoice_copy = True\n\n    sale_price = unit_price * course_code_number\n    set_user_preference(request.user, INVOICE_KEY, invoice_copy)\n    sale_invoice = Invoice.objects.create(\n        total_amount=sale_price,\n        company_name=company_name,\n        company_contact_email=company_contact_email,\n        company_contact_name=company_contact_name,\n        course_id=course_id,\n        recipient_name=recipient_name,\n        recipient_email=recipient_email,\n        address_line_1=address_line_1,\n        address_line_2=address_line_2,\n        address_line_3=address_line_3,\n        city=city,\n        state=state,\n        zip=zip_code,\n        country=country,\n        internal_reference=internal_reference,\n        customer_reference_number=customer_reference_number\n    )\n\n    invoice_item = CourseRegistrationCodeInvoiceItem.objects.create(\n        invoice=sale_invoice,\n        qty=course_code_number,\n        unit_price=unit_price,\n        course_id=course_id\n    )\n\n    course = get_course_by_id(course_id, depth=0)\n    paid_modes = CourseMode.paid_modes_for_course(course_id)\n\n    if len(paid_modes) != 1:\n        msg = (\n            u\"Generating Code Redeem Codes for Course '{course_id}', which must have a single paid course mode. \"\n            u\"This is a configuration issue. Current course modes with payment options: {paid_modes}\"\n        ).format(course_id=course_id, paid_modes=paid_modes)\n        log.error(msg)\n        return HttpResponse(\n            status=500,\n            content=_(u\"Unable to generate redeem codes because of course misconfiguration.\")\n        )\n\n    course_mode = paid_modes[0]\n    course_price = course_mode.min_price\n\n    registration_codes = []\n    for __ in range(course_code_number):\n        generated_registration_code = save_registration_code(\n            request.user, course_id, course_mode.slug, invoice=sale_invoice, order=None, invoice_item=invoice_item\n        )\n        registration_codes.append(generated_registration_code)\n\n    site_name = microsite.get_value('SITE_NAME', 'localhost')\n    quantity = course_code_number\n    discount = (float(quantity * course_price) - float(sale_price))\n    course_url = '{base_url}{course_about}'.format(\n        base_url=microsite.get_value('SITE_NAME', settings.SITE_NAME),\n        course_about=reverse('about_course', kwargs={'course_id': course_id.to_deprecated_string()})\n    )\n    dashboard_url = '{base_url}{dashboard}'.format(\n        base_url=microsite.get_value('SITE_NAME', settings.SITE_NAME),\n        dashboard=reverse('dashboard')\n    )\n\n    try:\n        pdf_file = sale_invoice.generate_pdf_invoice(course, course_price, int(quantity), float(sale_price))\n    except Exception:  # pylint: disable=broad-except\n        log.exception('Exception at creating pdf file.')\n        pdf_file = None\n\n    from_address = theming_helpers.get_value('email_from_address', settings.DEFAULT_FROM_EMAIL)\n    context = {\n        'invoice': sale_invoice,\n        'site_name': site_name,\n        'course': course,\n        'course_price': course_price,\n        'sub_total': course_price * quantity,\n        'discount': discount,\n        'sale_price': sale_price,\n        'quantity': quantity,\n        'registration_codes': registration_codes,\n        'currency_symbol': settings.PAID_COURSE_REGISTRATION_CURRENCY[1],\n        'course_url': course_url,\n        'platform_name': microsite.get_value('platform_name', settings.PLATFORM_NAME),\n        'dashboard_url': dashboard_url,\n        'contact_email': from_address,\n        'corp_address': microsite.get_value('invoice_corp_address', settings.INVOICE_CORP_ADDRESS),\n        'payment_instructions': microsite.get_value('invoice_payment_instructions', settings. INVOICE_PAYMENT_INSTRUCTIONS),\n        'date': time.strftime(\"%m/%d/%Y\")\n    }\n    # composes registration codes invoice email\n    subject = u'Confirmation and Invoice for {course_name}'.format(course_name=course.display_name)\n    message = render_to_string('emails/registration_codes_sale_email.txt', context)\n\n    invoice_attachment = render_to_string('emails/registration_codes_sale_invoice_attachment.txt', context)\n\n    #send_mail(subject, message, from_address, recipient_list, fail_silently=False)\n    csv_file = StringIO.StringIO()\n    csv_writer = csv.writer(csv_file)\n    for registration_code in registration_codes:\n        full_redeem_code_url = 'http://{base_url}{redeem_code_url}'.format(\n            base_url=microsite.get_value('SITE_NAME', settings.SITE_NAME),\n            redeem_code_url=reverse('register_code_redemption', kwargs={'registration_code': registration_code.code})\n        )\n        csv_writer.writerow([registration_code.code, full_redeem_code_url])\n    finance_email = microsite.get_value('finance_email', settings.FINANCE_EMAIL)\n    if finance_email:\n        # append the finance email into the recipient_list\n        recipient_list.append(finance_email)\n\n    # send a unique email for each recipient, don't put all email addresses in a single email\n    for recipient in recipient_list:\n        email = EmailMessage()\n        email.subject = subject\n        email.body = message\n        email.from_email = from_address\n        email.to = [recipient]\n        email.attach(u'RegistrationCodes.csv', csv_file.getvalue(), 'text/csv')\n        email.attach(u'Invoice.txt', invoice_attachment, 'text/plain')\n        if pdf_file is not None:\n            email.attach(u'Invoice.pdf', pdf_file.getvalue(), 'application/pdf')\n        else:\n            file_buffer = StringIO.StringIO(_('pdf download unavailable right now, please contact support.'))\n            email.attach(u'pdf_unavailable.txt', file_buffer.getvalue(), 'text/plain')\n        email.send()\n\n    return registration_codes_csv(\"Registration_Codes.csv\", registration_codes)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef active_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Active Registration Codes.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    # find all the registration codes in this course\n    registration_codes_list = CourseRegistrationCode.objects.filter(\n        course_id=course_id\n    ).order_by('invoice_item__invoice__company_name')\n\n    company_name = request.POST['active_company_name']\n    if company_name:\n        registration_codes_list = registration_codes_list.filter(invoice_item__invoice__company_name=company_name)\n    # find the redeemed registration codes if any exist in the db\n    code_redemption_set = RegistrationCodeRedemption.objects.select_related(\n        'registration_code', 'registration_code__invoice_item__invoice'\n    ).filter(registration_code__course_id=course_id)\n    if code_redemption_set.exists():\n        redeemed_registration_codes = [code.registration_code.code for code in code_redemption_set]\n        # exclude the redeemed registration codes from the registration codes list and you will get\n        # all the registration codes that are active\n        registration_codes_list = registration_codes_list.exclude(code__in=redeemed_registration_codes)\n\n    return registration_codes_csv(\"Active_Registration_Codes.csv\", registration_codes_list)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef spent_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Spent(used) Registration Codes.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    # find the redeemed registration codes if any exist in the db\n    code_redemption_set = RegistrationCodeRedemption.objects.select_related('registration_code').filter(\n        registration_code__course_id=course_id\n    )\n    spent_codes_list = []\n    if code_redemption_set.exists():\n        redeemed_registration_codes = [code.registration_code.code for code in code_redemption_set]\n        # filter the Registration Codes by course id and the redeemed codes and\n        # you will get a list of all the spent(Redeemed) Registration Codes\n        spent_codes_list = CourseRegistrationCode.objects.filter(\n            course_id=course_id, code__in=redeemed_registration_codes\n        ).order_by('invoice_item__invoice__company_name').select_related('invoice_item__invoice')\n\n        company_name = request.POST['spent_company_name']\n        if company_name:\n            spent_codes_list = spent_codes_list.filter(invoice_item__invoice__company_name=company_name)  # pylint: disable=maybe-no-member\n\n    csv_type = 'spent'\n    return registration_codes_csv(\"Spent_Registration_Codes.csv\", spent_codes_list, csv_type)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_anon_ids(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    Respond with 2-column CSV output of user-id, anonymized-user-id\n    \"\"\"\n    # TODO: the User.objects query and CSV generation here could be\n    # centralized into instructor_analytics. Currently instructor_analytics\n    # has similar functionality but not quite what's needed.\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    def csv_response(filename, header, rows):\n        \"\"\"Returns a CSV http response for the given header and rows (excel/utf-8).\"\"\"\n        response = HttpResponse(content_type='text/csv')\n        response['Content-Disposition'] = 'attachment; filename={0}'.format(unicode(filename).encode('utf-8'))\n        writer = csv.writer(response, dialect='excel', quotechar='\"', quoting=csv.QUOTE_ALL)\n        # In practice, there should not be non-ascii data in this query,\n        # but trying to do the right thing anyway.\n        encoded = [unicode(s).encode('utf-8') for s in header]\n        writer.writerow(encoded)\n        for row in rows:\n            encoded = [unicode(s).encode('utf-8') for s in row]\n            writer.writerow(encoded)\n        return response\n\n    students = User.objects.filter(\n        courseenrollment__course_id=course_id,\n    ).order_by('id')\n    header = ['User ID', 'Anonymized User ID', 'Course Specific Anonymized User ID']\n    rows = [[s.id, unique_id_for_user(s, save=False), anonymous_id_for_user(s, course_id, save=False)] for s in students]\n    return csv_response(course_id.to_deprecated_string().replace('/', '-') + '-anon-ids.csv', header, rows)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@common_exceptions_400\n@require_level('staff')\n@require_query_params(\n    unique_student_identifier=\"email or username of student for whom to get progress url\"\n)\ndef get_student_progress_url(request, course_id):\n    \"\"\"\n    Get the progress url of a student.\n    Limited to staff access.\n\n    Takes query paremeter unique_student_identifier and if the student exists\n    returns e.g. {\n        'progress_url': '/../...'\n    }\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    user = get_student_from_identifier(request.GET.get('unique_student_identifier'))\n\n    progress_url = reverse('student_progress', kwargs={'course_id': course_id.to_deprecated_string(), 'student_id': user.id})\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'progress_url': progress_url,\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_query_params(\n    problem_to_reset=\"problem urlname to reset\"\n)\n@common_exceptions_400\ndef reset_student_attempts(request, course_id):\n    \"\"\"\n\n    Resets a students attempts counter or starts a task to reset all students\n    attempts counters. Optionally deletes student state for a problem. Limited\n    to staff access. Some sub-methods limited to instructor access.\n\n    Takes some of the following query paremeters\n        - problem_to_reset is a urlname of a problem\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n            requires instructor access\n            mutually exclusive with delete_module\n            mutually exclusive with delete_module\n        - delete_module is a boolean\n            requires instructor access\n            mutually exclusive with all_students\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n\n    problem_to_reset = strip_if_string(request.GET.get('problem_to_reset'))\n    student_identifier = request.GET.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n    all_students = request.GET.get('all_students', False) in ['true', 'True', True]\n    delete_module = request.GET.get('delete_module', False) in ['true', 'True', True]\n\n    # parameter combinations\n    if all_students and student:\n        return HttpResponseBadRequest(\n            \"all_students and unique_student_identifier are mutually exclusive.\"\n        )\n    if all_students and delete_module:\n        return HttpResponseBadRequest(\n            \"all_students and delete_module are mutually exclusive.\"\n        )\n\n    # instructor authorization\n    if all_students or delete_module:\n        if not has_access(request.user, 'instructor', course):\n            return HttpResponseForbidden(\"Requires instructor access.\")\n\n    try:\n        module_state_key = course_id.make_usage_key_from_deprecated_string(problem_to_reset)\n    except InvalidKeyError:\n        return HttpResponseBadRequest()\n\n    response_payload = {}\n    response_payload['problem_to_reset'] = problem_to_reset\n\n    if student:\n        try:\n            enrollment.reset_student_attempts(\n                course_id,\n                student,\n                module_state_key,\n                requesting_user=request.user,\n                delete_module=delete_module\n            )\n        except StudentModule.DoesNotExist:\n            return HttpResponseBadRequest(_(\"Module does not exist.\"))\n        except sub_api.SubmissionError:\n            # Trust the submissions API to log the error\n            error_msg = _(\"An error occurred while deleting the score.\")\n            return HttpResponse(error_msg, status=500)\n        response_payload['student'] = student_identifier\n    elif all_students:\n        instructor_task.api.submit_reset_problem_attempts_for_all_students(request, module_state_key)\n        response_payload['task'] = 'created'\n        response_payload['student'] = 'All Students'\n    else:\n        return HttpResponseBadRequest()\n\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@common_exceptions_400\ndef reset_student_attempts_for_entrance_exam(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n\n    Resets a students attempts counter or starts a task to reset all students\n    attempts counters for entrance exam. Optionally deletes student state for\n    entrance exam. Limited to staff access. Some sub-methods limited to instructor access.\n\n    Following are possible query parameters\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n            requires instructor access\n            mutually exclusive with delete_module\n        - delete_module is a boolean\n            requires instructor access\n            mutually exclusive with all_students\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n\n    if not course.entrance_exam_id:\n        return HttpResponseBadRequest(\n            _(\"Course has no entrance exam section.\")\n        )\n\n    student_identifier = request.GET.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n    all_students = request.GET.get('all_students', False) in ['true', 'True', True]\n    delete_module = request.GET.get('delete_module', False) in ['true', 'True', True]\n\n    # parameter combinations\n    if all_students and student:\n        return HttpResponseBadRequest(\n            _(\"all_students and unique_student_identifier are mutually exclusive.\")\n        )\n    if all_students and delete_module:\n        return HttpResponseBadRequest(\n            _(\"all_students and delete_module are mutually exclusive.\")\n        )\n\n    # instructor authorization\n    if all_students or delete_module:\n        if not has_access(request.user, 'instructor', course):\n            return HttpResponseForbidden(_(\"Requires instructor access.\"))\n\n    try:\n        entrance_exam_key = course_id.make_usage_key_from_deprecated_string(course.entrance_exam_id)\n        if delete_module:\n            instructor_task.api.submit_delete_entrance_exam_state_for_student(request, entrance_exam_key, student)\n        else:\n            instructor_task.api.submit_reset_problem_attempts_in_entrance_exam(request, entrance_exam_key, student)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(_(\"Course has no valid entrance exam section.\"))\n\n    response_payload = {'student': student_identifier or _('All Students'), 'task': 'created'}\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@require_query_params(problem_to_reset=\"problem urlname to reset\")\n@common_exceptions_400\ndef rescore_problem(request, course_id):\n    \"\"\"\n    Starts a background process a students attempts counter. Optionally deletes student state for a problem.\n    Limited to instructor access.\n\n    Takes either of the following query paremeters\n        - problem_to_reset is a urlname of a problem\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n\n    all_students and unique_student_identifier cannot both be present.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    problem_to_reset = strip_if_string(request.GET.get('problem_to_reset'))\n    student_identifier = request.GET.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n\n    all_students = request.GET.get('all_students') in ['true', 'True', True]\n\n    if not (problem_to_reset and (all_students or student)):\n        return HttpResponseBadRequest(\"Missing query parameters.\")\n\n    if all_students and student:\n        return HttpResponseBadRequest(\n            \"Cannot rescore with all_students and unique_student_identifier.\"\n        )\n\n    try:\n        module_state_key = course_id.make_usage_key_from_deprecated_string(problem_to_reset)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(\"Unable to parse problem id\")\n\n    response_payload = {}\n    response_payload['problem_to_reset'] = problem_to_reset\n\n    if student:\n        response_payload['student'] = student_identifier\n        instructor_task.api.submit_rescore_problem_for_student(request, module_state_key, student)\n        response_payload['task'] = 'created'\n    elif all_students:\n        instructor_task.api.submit_rescore_problem_for_all_students(request, module_state_key)\n        response_payload['task'] = 'created'\n    else:\n        return HttpResponseBadRequest()\n\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@common_exceptions_400\ndef rescore_entrance_exam(request, course_id):\n    \"\"\"\n    Starts a background process a students attempts counter for entrance exam.\n    Optionally deletes student state for a problem. Limited to instructor access.\n\n    Takes either of the following query parameters\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n\n    all_students and unique_student_identifier cannot both be present.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n\n    student_identifier = request.GET.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n\n    all_students = request.GET.get('all_students') in ['true', 'True', True]\n\n    if not course.entrance_exam_id:\n        return HttpResponseBadRequest(\n            _(\"Course has no entrance exam section.\")\n        )\n\n    if all_students and student:\n        return HttpResponseBadRequest(\n            _(\"Cannot rescore with all_students and unique_student_identifier.\")\n        )\n\n    try:\n        entrance_exam_key = course_id.make_usage_key_from_deprecated_string(course.entrance_exam_id)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(_(\"Course has no valid entrance exam section.\"))\n\n    response_payload = {}\n    if student:\n        response_payload['student'] = student_identifier\n    else:\n        response_payload['student'] = _(\"All Students\")\n    instructor_task.api.submit_rescore_entrance_exam_for_student(request, entrance_exam_key, student)\n    response_payload['task'] = 'created'\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_background_email_tasks(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    List background email tasks.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    task_type = 'bulk_course_email'\n    # Specifying for the history of a single task type\n    tasks = instructor_task.api.get_instructor_task_history(course_id, task_type=task_type)\n\n    response_payload = {\n        'tasks': map(extract_task_features, tasks),\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_email_content(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    List the content of bulk emails sent\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    task_type = 'bulk_course_email'\n    # First get tasks list of bulk emails sent\n    emails = instructor_task.api.get_instructor_task_history(course_id, task_type=task_type)\n\n    response_payload = {\n        'emails': map(extract_email_features, emails),\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_instructor_tasks(request, course_id):\n    \"\"\"\n    List instructor tasks.\n\n    Takes optional query paremeters.\n        - With no arguments, lists running tasks.\n        - `problem_location_str` lists task history for problem\n        - `problem_location_str` and `unique_student_identifier` lists task\n            history for problem AND student (intersection)\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    problem_location_str = strip_if_string(request.GET.get('problem_location_str', False))\n    student = request.GET.get('unique_student_identifier', None)\n    if student is not None:\n        student = get_student_from_identifier(student)\n\n    if student and not problem_location_str:\n        return HttpResponseBadRequest(\n            \"unique_student_identifier must accompany problem_location_str\"\n        )\n\n    if problem_location_str:\n        try:\n            module_state_key = course_id.make_usage_key_from_deprecated_string(problem_location_str)\n        except InvalidKeyError:\n            return HttpResponseBadRequest()\n        if student:\n            # Specifying for a single student's history on this problem\n            tasks = instructor_task.api.get_instructor_task_history(course_id, module_state_key, student)\n        else:\n            # Specifying for single problem's history\n            tasks = instructor_task.api.get_instructor_task_history(course_id, module_state_key)\n    else:\n        # If no problem or student, just get currently running tasks\n        tasks = instructor_task.api.get_running_instructor_tasks(course_id)\n\n    response_payload = {\n        'tasks': map(extract_task_features, tasks),\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_entrance_exam_instructor_tasks(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n    List entrance exam related instructor tasks.\n\n    Takes either of the following query parameters\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_by_id(course_id)\n    student = request.GET.get('unique_student_identifier', None)\n    if student is not None:\n        student = get_student_from_identifier(student)\n\n    try:\n        entrance_exam_key = course_id.make_usage_key_from_deprecated_string(course.entrance_exam_id)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(_(\"Course has no valid entrance exam section.\"))\n    if student:\n        # Specifying for a single student's entrance exam history\n        tasks = instructor_task.api.get_entrance_exam_instructor_task_history(course_id, entrance_exam_key, student)\n    else:\n        # Specifying for all student's entrance exam history\n        tasks = instructor_task.api.get_entrance_exam_instructor_task_history(course_id, entrance_exam_key)\n\n    response_payload = {\n        'tasks': map(extract_task_features, tasks),\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_report_downloads(_request, course_id):\n    \"\"\"\n    List grade CSV files that are available for download for this course.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    report_store = ReportStore.from_config(config_name='GRADES_DOWNLOAD')\n\n    response_payload = {\n        'downloads': [\n            dict(name=name, url=url, link=HTML('<a href=\"{}\">{}</a>').format(HTML(url), Text(name)))\n            for name, url in report_store.links_for(course_id)\n        ]\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_finance_admin\ndef list_financial_report_downloads(_request, course_id):\n    \"\"\"\n    List grade CSV files that are available for download for this course.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    report_store = ReportStore.from_config(config_name='FINANCIAL_REPORTS')\n\n    response_payload = {\n        'downloads': [\n            dict(name=name, url=url, link=HTML('<a href=\"{}\">{}</a>').format(HTML(url), Text(name)))\n            for name, url in report_store.links_for(course_id)\n        ]\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef export_ora2_data(request, course_id):\n    \"\"\"\n    Pushes a Celery task which will aggregate ora2 responses for a course into a .csv\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_export_ora2_data(request, course_key)\n        success_status = _(\"The ORA data report is being generated.\")\n\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\n            \"An ORA data report generation task is already in \"\n            \"progress. Check the 'Pending Tasks' table \"\n            \"for the status of the task. When completed, the report \"\n            \"will be available for download in the table below.\"\n        )\n\n        return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef calculate_grades_csv(request, course_id):\n    \"\"\"\n    AlreadyRunningError is raised if the course's grades are already being updated.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_calculate_grades_csv(request, course_key)\n        success_status = _(\"The grade report is being created.\"\n                           \" To view the status of the report, see Pending Tasks below.\")\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\"The grade report is currently being created.\"\n                                   \" To view the status of the report, see Pending Tasks below.\"\n                                   \" You will be able to download the report when it is complete.\")\n        return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef problem_grade_report(request, course_id):\n    \"\"\"\n    Request a CSV showing students' grades for all problems in the\n    course.\n\n    AlreadyRunningError is raised if the course's grades are already being\n    updated.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_problem_grade_report(request, course_key)\n        success_status = _(\"The problem grade report is being created.\"\n                           \" To view the status of the report, see Pending Tasks below.\")\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\"A problem grade report is already being generated.\"\n                                   \" To view the status of the report, see Pending Tasks below.\"\n                                   \" You will be able to download the report when it is complete.\")\n        return JsonResponse({\n            \"status\": already_running_status\n        })\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_query_params('rolename')\ndef list_forum_members(request, course_id):\n    \"\"\"\n    Lists forum members of a certain rolename.\n    Limited to staff access.\n\n    The requesting user must be at least staff.\n    Staff forum admins can access all roles EXCEPT for FORUM_ROLE_ADMINISTRATOR\n        which is limited to instructors.\n\n    Takes query parameter `rolename`.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_by_id(course_id)\n    has_instructor_access = has_access(request.user, 'instructor', course)\n    has_forum_admin = has_forum_access(\n        request.user, course_id, FORUM_ROLE_ADMINISTRATOR\n    )\n\n    rolename = request.GET.get('rolename')\n\n    # default roles require either (staff & forum admin) or (instructor)\n    if not (has_forum_admin or has_instructor_access):\n        return HttpResponseBadRequest(\n            \"Operation requires staff & forum admin or instructor access\"\n        )\n\n    # EXCEPT FORUM_ROLE_ADMINISTRATOR requires (instructor)\n    if rolename == FORUM_ROLE_ADMINISTRATOR and not has_instructor_access:\n        return HttpResponseBadRequest(\"Operation requires instructor access.\")\n\n    # filter out unsupported for roles\n    if rolename not in [FORUM_ROLE_ADMINISTRATOR, FORUM_ROLE_MODERATOR, FORUM_ROLE_COMMUNITY_TA]:\n        return HttpResponseBadRequest(strip_tags(\n            \"Unrecognized rolename '{}'.\".format(rolename)\n        ))\n\n    try:\n        role = Role.objects.get(name=rolename, course_id=course_id)\n        users = role.users.all().order_by('username')\n    except Role.DoesNotExist:\n        users = []\n\n    def extract_user_info(user):\n        \"\"\" Convert user to dict for json rendering. \"\"\"\n        return {\n            'username': user.username,\n            'email': user.email,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n        }\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        rolename: map(extract_user_info, users),\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params(send_to=\"sending to whom\", subject=\"subject line\", message=\"message text\")\ndef send_email(request, course_id):\n    \"\"\"\n    Send an email to self, staff, or everyone involved in a course.\n    Query Parameters:\n    - 'send_to' specifies what group the email should be sent to\n       Options are defined by the CourseEmail model in\n       lms/djangoapps/bulk_email/models.py\n    - 'subject' specifies email's subject\n    - 'message' specifies email's content\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    if not BulkEmailFlag.feature_enabled(course_id):\n        return HttpResponseForbidden(\"Email is not enabled for this course.\")\n\n    targets = json.loads(request.POST.get(\"send_to\"))\n    subject = request.POST.get(\"subject\")\n    message = request.POST.get(\"message\")\n\n    # allow two branding points to come from Microsites: which CourseEmailTemplate should be used\n    # and what the 'from' field in the email should be\n    #\n    # If these are None (because we are not in a Microsite or they are undefined in Microsite config) than\n    # the system will use normal system defaults\n    template_name = microsite.get_value('course_email_template_name')\n    from_addr = microsite.get_value('course_email_from_addr')\n\n    # Create the CourseEmail object.  This is saved immediately, so that\n    # any transaction that has been pending up to this point will also be\n    # committed.\n    try:\n        email = CourseEmail.create(\n            course_id,\n            request.user,\n            targets,\n            subject, message,\n            template_name=template_name,\n            from_addr=from_addr\n        )\n    except ValueError as err:\n        return HttpResponseBadRequest(repr(err))\n\n    # Submit the task, so that the correct InstructorTask object gets created (for monitoring purposes)\n    instructor_task.api.submit_bulk_course_email(request, course_id, email.id)\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'success': True,\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_query_params(\n    unique_student_identifier=\"email or username of user to change access\",\n    rolename=\"the forum role\",\n    action=\"'allow' or 'revoke'\",\n)\n@common_exceptions_400\ndef update_forum_role_membership(request, course_id):\n    \"\"\"\n    Modify user's forum role.\n\n    The requesting user must be at least staff.\n    Staff forum admins can access all roles EXCEPT for FORUM_ROLE_ADMINISTRATOR\n        which is limited to instructors.\n    No one can revoke an instructors FORUM_ROLE_ADMINISTRATOR status.\n\n    Query parameters:\n    - `email` is the target users email\n    - `rolename` is one of [FORUM_ROLE_ADMINISTRATOR, FORUM_ROLE_MODERATOR, FORUM_ROLE_COMMUNITY_TA]\n    - `action` is one of ['allow', 'revoke']\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_by_id(course_id)\n    has_instructor_access = has_access(request.user, 'instructor', course)\n    has_forum_admin = has_forum_access(\n        request.user, course_id, FORUM_ROLE_ADMINISTRATOR\n    )\n\n    unique_student_identifier = request.GET.get('unique_student_identifier')\n    rolename = request.GET.get('rolename')\n    action = request.GET.get('action')\n\n    # default roles require either (staff & forum admin) or (instructor)\n    if not (has_forum_admin or has_instructor_access):\n        return HttpResponseBadRequest(\n            \"Operation requires staff & forum admin or instructor access\"\n        )\n\n    # EXCEPT FORUM_ROLE_ADMINISTRATOR requires (instructor)\n    if rolename == FORUM_ROLE_ADMINISTRATOR and not has_instructor_access:\n        return HttpResponseBadRequest(\"Operation requires instructor access.\")\n\n    if rolename not in [FORUM_ROLE_ADMINISTRATOR, FORUM_ROLE_MODERATOR, FORUM_ROLE_COMMUNITY_TA]:\n        return HttpResponseBadRequest(strip_tags(\n            \"Unrecognized rolename '{}'.\".format(rolename)\n        ))\n\n    user = get_student_from_identifier(unique_student_identifier)\n\n    try:\n        update_forum_role(course_id, user, rolename, action)\n    except Role.DoesNotExist:\n        return HttpResponseBadRequest(\"Role does not exist.\")\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'action': action,\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\ndef get_user_invoice_preference(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    Gets invoice copy user's preferences.\n    \"\"\"\n    invoice_copy_preference = True\n    invoice_preference_value = get_user_preference(request.user, INVOICE_KEY)\n    if invoice_preference_value is not None:\n        invoice_copy_preference = invoice_preference_value == 'True'\n\n    return JsonResponse({\n        'invoice_copy': invoice_copy_preference\n    })\n\n\ndef _display_unit(unit):\n    \"\"\"\n    Gets string for displaying unit to user.\n    \"\"\"\n    name = getattr(unit, 'display_name', None)\n    if name:\n        return u'{0} ({1})'.format(name, unit.location.to_deprecated_string())\n    else:\n        return unit.location.to_deprecated_string()\n\n\n@handle_dashboard_error\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_query_params('student', 'url', 'due_datetime')\ndef change_due_date(request, course_id):\n    \"\"\"\n    Grants a due date extension to a student for a particular unit.\n    \"\"\"\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    student = require_student_from_identifier(request.GET.get('student'))\n    unit = find_unit(course, request.GET.get('url'))\n    due_date = parse_datetime(request.GET.get('due_datetime'))\n    set_due_date_extension(course, unit, student, due_date)\n\n    return JsonResponse(_(\n        'Successfully changed due date for student {0} for {1} '\n        'to {2}').format(student.profile.name, _display_unit(unit),\n                         due_date.strftime('%Y-%m-%d %H:%M')))\n\n\n@handle_dashboard_error\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_query_params('student', 'url')\ndef reset_due_date(request, course_id):\n    \"\"\"\n    Rescinds a due date extension for a student on a particular unit.\n    \"\"\"\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    student = require_student_from_identifier(request.GET.get('student'))\n    unit = find_unit(course, request.GET.get('url'))\n    set_due_date_extension(course, unit, student, None)\n    if not getattr(unit, \"due\", None):\n        # It's possible the normal due date was deleted after an extension was granted:\n        return JsonResponse(\n            _(\"Successfully removed invalid due date extension (unit has no due date).\")\n        )\n\n    original_due_date_str = unit.due.strftime('%Y-%m-%d %H:%M')\n    return JsonResponse(_(\n        'Successfully reset due date for student {0} for {1} '\n        'to {2}').format(student.profile.name, _display_unit(unit),\n                         original_due_date_str))\n\n\n@handle_dashboard_error\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_query_params('url')\ndef show_unit_extensions(request, course_id):\n    \"\"\"\n    Shows all of the students which have due date extensions for the given unit.\n    \"\"\"\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    unit = find_unit(course, request.GET.get('url'))\n    return JsonResponse(dump_module_extensions(course, unit))\n\n\n@handle_dashboard_error\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_query_params('student')\ndef show_student_extensions(request, course_id):\n    \"\"\"\n    Shows all of the due date extensions granted to a particular student in a\n    particular course.\n    \"\"\"\n    student = require_student_from_identifier(request.GET.get('student'))\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    return JsonResponse(dump_student_extensions(course, student))\n\n\ndef _split_input_list(str_list):\n    \"\"\"\n    Separate out individual student email from the comma, or space separated string.\n\n    e.g.\n    in: \"Lorem@ipsum.dolor, sit@amet.consectetur\\nadipiscing@elit.Aenean\\r convallis@at.lacus\\r, ut@lacinia.Sed\"\n    out: ['Lorem@ipsum.dolor', 'sit@amet.consectetur', 'adipiscing@elit.Aenean', 'convallis@at.lacus', 'ut@lacinia.Sed']\n\n    `str_list` is a string coming from an input text area\n    returns a list of separated values\n    \"\"\"\n\n    new_list = re.split(r'[\\n\\r\\s,]', str_list)\n    new_list = [s.strip() for s in new_list]\n    new_list = [s for s in new_list if s != '']\n\n    return new_list\n\n\ndef _instructor_dash_url(course_key, section=None):\n    \"\"\"Return the URL for a section in the instructor dashboard.\n\n    Arguments:\n        course_key (CourseKey)\n\n    Keyword Arguments:\n        section (str): The name of the section to load.\n\n    Returns:\n        unicode: The URL of a section in the instructor dashboard.\n\n    \"\"\"\n    url = reverse('instructor_dashboard', kwargs={'course_id': unicode(course_key)})\n    if section is not None:\n        url += u'#view-{section}'.format(section=section)\n    return url\n\n\n@require_global_staff\n@require_POST\ndef generate_example_certificates(request, course_id=None):  # pylint: disable=unused-argument\n    \"\"\"Start generating a set of example certificates.\n\n    Example certificates are used to verify that certificates have\n    been configured correctly for the course.\n\n    Redirects back to the intructor dashboard once certificate\n    generation has begun.\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    certs_api.generate_example_certificates(course_key)\n    return redirect(_instructor_dash_url(course_key, section='certificates'))\n\n\n@require_global_staff\n@require_POST\ndef enable_certificate_generation(request, course_id=None):\n    \"\"\"Enable/disable self-generated certificates for a course.\n\n    Once self-generated certificates have been enabled, students\n    who have passed the course will be able to generate certificates.\n\n    Redirects back to the intructor dashboard once the\n    setting has been updated.\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    is_enabled = (request.POST.get('certificates-enabled', 'false') == 'true')\n    certs_api.set_cert_generation_enabled(course_key, is_enabled)\n    return redirect(_instructor_dash_url(course_key, section='certificates'))\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef mark_student_can_skip_entrance_exam(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n    Mark a student to skip entrance exam.\n    Takes `unique_student_identifier` as required POST parameter.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    student_identifier = request.POST.get('unique_student_identifier')\n    student = get_student_from_identifier(student_identifier)\n\n    __, created = EntranceExamConfiguration.objects.get_or_create(user=student, course_id=course_id)\n    if created:\n        message = _('This student (%s) will skip the entrance exam.') % student_identifier\n    else:\n        message = _('This student (%s) is already allowed to skip the entrance exam.') % student_identifier\n    response_payload = {\n        'message': message,\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef start_certificate_generation(request, course_id):\n    \"\"\"\n    Start generating certificates for all students enrolled in given course.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    task = instructor_task.api.generate_certificates_for_students(request, course_key)\n    message = _('Certificate generation task for all students of this course has been started. '\n                'You can view the status of the generation task in the \"Pending Tasks\" section.')\n    response_payload = {\n        'message': message,\n        'task_id': task.task_id\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef start_certificate_regeneration(request, course_id):\n    \"\"\"\n    Start regenerating certificates for students whose certificate statuses lie with in 'certificate_statuses'\n    entry in POST data.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    certificates_statuses = request.POST.getlist('certificate_statuses', [])\n    if not certificates_statuses:\n        return JsonResponse(\n            {'message': _('Please select one or more certificate statuses that require certificate regeneration.')},\n            status=400\n        )\n\n    # Check if the selected statuses are allowed\n    allowed_statuses = [CertificateStatuses.downloadable, CertificateStatuses.error, CertificateStatuses.notpassing]\n    if not set(certificates_statuses).issubset(allowed_statuses):\n        return JsonResponse(\n            {'message': _('Please select certificate statuses from the list only.')},\n            status=400\n        )\n    try:\n        instructor_task.api.regenerate_certificates(request, course_key, certificates_statuses)\n    except AlreadyRunningError as error:\n        return JsonResponse({'message': error.message}, status=400)\n\n    response_payload = {\n        'message': _('Certificate regeneration task has been started. '\n                     'You can view the status of the generation task in the \"Pending Tasks\" section.'),\n        'success': True\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_http_methods(['POST', 'DELETE'])\ndef certificate_exception_view(request, course_id):\n    \"\"\"\n    Add/Remove students to/from certificate white list.\n\n    :param request: HttpRequest object\n    :param course_id: course identifier of the course for whom to add/remove certificates exception.\n    :return: JsonResponse object with success/error message or certificate exception data.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    # Validate request data and return error response in case of invalid data\n    try:\n        certificate_exception, student = parse_request_data_and_get_user(request, course_key)\n    except ValueError as error:\n        return JsonResponse({'success': False, 'message': error.message}, status=400)\n\n    # Add new Certificate Exception for the student passed in request data\n    if request.method == 'POST':\n        try:\n            exception = add_certificate_exception(course_key, student, certificate_exception)\n        except ValueError as error:\n            return JsonResponse({'success': False, 'message': error.message}, status=400)\n        return JsonResponse(exception)\n\n    # Remove Certificate Exception for the student passed in request data\n    elif request.method == 'DELETE':\n        try:\n            remove_certificate_exception(course_key, student)\n        except ValueError as error:\n            return JsonResponse({'success': False, 'message': error.message}, status=400)\n\n        return JsonResponse({}, status=204)\n\n\ndef add_certificate_exception(course_key, student, certificate_exception):\n    \"\"\"\n    Add a certificate exception to CertificateWhitelist table.\n    Raises ValueError in case Student is already white listed.\n\n    :param course_key: identifier of the course whose certificate exception will be added.\n    :param student: User object whose certificate exception will be added.\n    :param certificate_exception: A dict object containing certificate exception info.\n    :return: CertificateWhitelist item in dict format containing certificate exception info.\n    \"\"\"\n    if len(CertificateWhitelist.get_certificate_white_list(course_key, student)) > 0:\n        raise ValueError(\n            _(\"Student (username/email={user}) already in certificate exception list.\").format(user=student.username)\n        )\n\n    certificate_white_list, __ = CertificateWhitelist.objects.get_or_create(\n        user=student,\n        course_id=course_key,\n        defaults={\n            'whitelist': True,\n            'notes': certificate_exception.get('notes', '')\n        }\n    )\n\n    generated_certificate = GeneratedCertificate.eligible_certificates.filter(\n        user=student,\n        course_id=course_key,\n        status=CertificateStatuses.downloadable,\n    ).first()\n\n    exception = dict({\n        'id': certificate_white_list.id,\n        'user_email': student.email,\n        'user_name': student.username,\n        'user_id': student.id,\n        'certificate_generated': generated_certificate and generated_certificate.created_date.strftime(\"%B %d, %Y\"),\n        'created': certificate_white_list.created.strftime(\"%A, %B %d, %Y\"),\n    })\n\n    return exception\n\n\ndef remove_certificate_exception(course_key, student):\n    \"\"\"\n    Remove certificate exception for given course and student from CertificateWhitelist table and\n    invalidate its GeneratedCertificate if present.\n    Raises ValueError in case no exception exists for the student in the given course.\n\n    :param course_key: identifier of the course whose certificate exception needs to be removed.\n    :param student: User object whose certificate exception needs to be removed.\n    :return:\n    \"\"\"\n    try:\n        certificate_exception = CertificateWhitelist.objects.get(user=student, course_id=course_key)\n    except ObjectDoesNotExist:\n        raise ValueError(\n            _('Certificate exception (user={user}) does not exist in certificate white list. '\n              'Please refresh the page and try again.').format(user=student.username)\n        )\n\n    try:\n        generated_certificate = GeneratedCertificate.objects.get(  # pylint: disable=no-member\n            user=student,\n            course_id=course_key\n        )\n        generated_certificate.invalidate()\n        log.info(\n            u'Certificate invalidated for %s in course %s when removed from certificate exception list',\n            student.username,\n            course_key\n        )\n    except ObjectDoesNotExist:\n        # Certificate has not been generated yet, so just remove the certificate exception from white list\n        pass\n    certificate_exception.delete()\n\n\ndef parse_request_data_and_get_user(request, course_key):\n    \"\"\"\n        Parse request data into Certificate Exception and User object.\n        Certificate Exception is the dict object containing information about certificate exception.\n\n    :param request:\n    :param course_key: Course Identifier of the course for whom to process certificate exception\n    :return: key-value pairs containing certificate exception data and User object\n    \"\"\"\n    certificate_exception = parse_request_data(request)\n\n    user = certificate_exception.get('user_name', '') or certificate_exception.get('user_email', '')\n    if not user:\n        raise ValueError(_('Student username/email field is required and can not be empty. '\n                           'Kindly fill in username/email and then press \"Add to Exception List\" button.'))\n    db_user = get_student(user, course_key)\n\n    return certificate_exception, db_user\n\n\ndef parse_request_data(request):\n    \"\"\"\n    Parse and return request data, raise ValueError in case of invalid JSON data.\n\n    :param request: HttpRequest request object.\n    :return: dict object containing parsed json data.\n    \"\"\"\n    try:\n        data = json.loads(request.body or '{}')\n    except ValueError:\n        raise ValueError(_('The record is not in the correct format. Please add a valid username or email address.'))\n\n    return data\n\n\ndef get_student(username_or_email, course_key):\n    \"\"\"\n    Retrieve and return User object from db, raise ValueError\n    if user is does not exists or is not enrolled in the given course.\n\n    :param username_or_email: String containing either user name or email of the student.\n    :param course_key: CourseKey object identifying the current course.\n    :return: User object\n    \"\"\"\n    try:\n        student = get_user_by_username_or_email(username_or_email)\n    except ObjectDoesNotExist:\n        raise ValueError(_(\"{user} does not exist in the LMS. Please check your spelling and retry.\").format(\n            user=username_or_email\n        ))\n\n    # Make Sure the given student is enrolled in the course\n    if not CourseEnrollment.is_enrolled(student, course_key):\n        raise ValueError(_(\"{user} is not enrolled in this course. Please check your spelling and retry.\")\n                         .format(user=username_or_email))\n    return student\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef generate_certificate_exceptions(request, course_id, generate_for=None):\n    \"\"\"\n    Generate Certificate for students in the Certificate White List.\n\n    :param request: HttpRequest object,\n    :param course_id: course identifier of the course for whom to generate certificates\n    :param generate_for: string to identify whether to generate certificates for 'all' or 'new'\n            additions to the certificate white-list\n    :return: JsonResponse object containing success/failure message and certificate exception data\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n\n    if generate_for == 'all':\n        # Generate Certificates for all white listed students\n        students = 'all_whitelisted'\n\n    elif generate_for == 'new':\n        students = 'whitelisted_not_generated'\n\n    else:\n        # Invalid data, generate_for must be present for all certificate exceptions\n        return JsonResponse(\n            {\n                'success': False,\n                'message': _('Invalid data, generate_for must be \"new\" or \"all\".'),\n            },\n            status=400\n        )\n\n    instructor_task.api.generate_certificates_for_students(request, course_key, student_set=students)\n\n    response_payload = {\n        'success': True,\n        'message': _('Certificate generation started for white listed students.'),\n    }\n\n    return JsonResponse(response_payload)\n\n\n@csrf_exempt\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef generate_bulk_certificate_exceptions(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n    Add Students to certificate white list from the uploaded csv file.\n    :return response in dict format.\n    {\n        general_errors: [errors related to csv file e.g. csv uploading, csv attachment, content reading etc. ],\n        row_errors: {\n            data_format_error:              [users/data in csv file that are not well formatted],\n            user_not_exist:                 [csv with none exiting users in LMS system],\n            user_already_white_listed:      [users that are already white listed],\n            user_not_enrolled:              [rows with not enrolled users in the given course]\n        },\n        success: [list of successfully added users to the certificate white list model]\n    }\n    \"\"\"\n    user_index = 0\n    notes_index = 1\n    row_errors_key = ['data_format_error', 'user_not_exist', 'user_already_white_listed', 'user_not_enrolled']\n    course_key = CourseKey.from_string(course_id)\n    students, general_errors, success = [], [], []\n    row_errors = {key: [] for key in row_errors_key}\n\n    def build_row_errors(key, _user, row_count):\n        \"\"\"\n        inner method to build dict of csv data as row errors.\n        \"\"\"\n        row_errors[key].append(_('user \"{user}\" in row# {row}').format(user=_user, row=row_count))\n\n    if 'students_list' in request.FILES:\n        try:\n            upload_file = request.FILES.get('students_list')\n            if upload_file.name.endswith('.csv'):\n                students = [row for row in csv.reader(upload_file.read().splitlines())]\n            else:\n                general_errors.append(_('Make sure that the file you upload is in CSV format with no '\n                                        'extraneous characters or rows.'))\n\n        except Exception:  # pylint: disable=broad-except\n            general_errors.append(_('Could not read uploaded file.'))\n        finally:\n            upload_file.close()\n\n        row_num = 0\n        for student in students:\n            row_num += 1\n            # verify that we have exactly two column in every row either email or username and notes but allow for\n            # blank lines\n            if len(student) != 2:\n                if len(student) > 0:\n                    build_row_errors('data_format_error', student[user_index], row_num)\n                    log.info(u'invalid data/format in csv row# %s', row_num)\n                continue\n\n            user = student[user_index]\n            try:\n                user = get_user_by_username_or_email(user)\n            except ObjectDoesNotExist:\n                build_row_errors('user_not_exist', user, row_num)\n                log.info(u'student %s does not exist', user)\n            else:\n                if len(CertificateWhitelist.get_certificate_white_list(course_key, user)) > 0:\n                    build_row_errors('user_already_white_listed', user, row_num)\n                    log.warning(u'student %s already exist.', user.username)\n\n                # make sure user is enrolled in course\n                elif not CourseEnrollment.is_enrolled(user, course_key):\n                    build_row_errors('user_not_enrolled', user, row_num)\n                    log.warning(u'student %s is not enrolled in course.', user.username)\n\n                else:\n                    CertificateWhitelist.objects.create(\n                        user=user,\n                        course_id=course_key,\n                        whitelist=True,\n                        notes=student[notes_index]\n                    )\n                    success.append(_('user \"{username}\" in row# {row}').format(username=user.username, row=row_num))\n\n    else:\n        general_errors.append(_('File is not attached.'))\n\n    results = {\n        'general_errors': general_errors,\n        'row_errors': row_errors,\n        'success': success\n    }\n\n    return JsonResponse(results)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_http_methods(['POST', 'DELETE'])\ndef certificate_invalidation_view(request, course_id):\n    \"\"\"\n    Invalidate/Re-Validate students to/from certificate.\n\n    :param request: HttpRequest object\n    :param course_id: course identifier of the course for whom to add/remove certificates exception.\n    :return: JsonResponse object with success/error message or certificate invalidation data.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    # Validate request data and return error response in case of invalid data\n    try:\n        certificate_invalidation_data = parse_request_data(request)\n        certificate = validate_request_data_and_get_certificate(certificate_invalidation_data, course_key)\n    except ValueError as error:\n        return JsonResponse({'message': error.message}, status=400)\n\n    # Invalidate certificate of the given student for the course course\n    if request.method == 'POST':\n        try:\n            certificate_invalidation = invalidate_certificate(request, certificate, certificate_invalidation_data)\n        except ValueError as error:\n            return JsonResponse({'message': error.message}, status=400)\n        return JsonResponse(certificate_invalidation)\n\n    # Re-Validate student certificate for the course course\n    elif request.method == 'DELETE':\n        try:\n            re_validate_certificate(request, course_key, certificate)\n        except ValueError as error:\n            return JsonResponse({'message': error.message}, status=400)\n\n        return JsonResponse({}, status=204)\n\n\ndef invalidate_certificate(request, generated_certificate, certificate_invalidation_data):\n    \"\"\"\n    Invalidate given GeneratedCertificate and add CertificateInvalidation record for future reference or re-validation.\n\n    :param request: HttpRequest object\n    :param generated_certificate: GeneratedCertificate object, the certificate we want to invalidate\n    :param certificate_invalidation_data: dict object containing data for CertificateInvalidation.\n    :return: dict object containing updated certificate invalidation data.\n    \"\"\"\n    if len(CertificateInvalidation.get_certificate_invalidations(\n            generated_certificate.course_id,\n            generated_certificate.user,\n    )) > 0:\n        raise ValueError(\n            _(\"Certificate of {user} has already been invalidated. Please check your spelling and retry.\").format(\n                user=generated_certificate.user.username,\n            )\n        )\n\n    # Verify that certificate user wants to invalidate is a valid one.\n    if not generated_certificate.is_valid():\n        raise ValueError(\n            _(\"Certificate for student {user} is already invalid, kindly verify that certificate was generated \"\n              \"for this student and then proceed.\").format(user=generated_certificate.user.username)\n        )\n\n    # Add CertificateInvalidation record for future reference or re-validation\n    certificate_invalidation, __ = CertificateInvalidation.objects.update_or_create(\n        generated_certificate=generated_certificate,\n        defaults={\n            'invalidated_by': request.user,\n            'notes': certificate_invalidation_data.get(\"notes\", \"\"),\n            'active': True,\n        }\n    )\n\n    # Invalidate GeneratedCertificate\n    generated_certificate.invalidate()\n    return {\n        'id': certificate_invalidation.id,\n        'user': certificate_invalidation.generated_certificate.user.username,\n        'invalidated_by': certificate_invalidation.invalidated_by.username,\n        'created': certificate_invalidation.created.strftime(\"%B %d, %Y\"),\n        'notes': certificate_invalidation.notes,\n    }\n\n\ndef re_validate_certificate(request, course_key, generated_certificate):\n    \"\"\"\n    Remove certificate invalidation from db and start certificate generation task for this student.\n    Raises ValueError if certificate invalidation is present.\n\n    :param request: HttpRequest object\n    :param course_key: CourseKey object identifying the current course.\n    :param generated_certificate: GeneratedCertificate object of the student for the given course\n    \"\"\"\n    try:\n        # Fetch CertificateInvalidation object\n        certificate_invalidation = CertificateInvalidation.objects.get(generated_certificate=generated_certificate)\n    except ObjectDoesNotExist:\n        raise ValueError(_(\"Certificate Invalidation does not exist, Please refresh the page and try again.\"))\n    else:\n        # Deactivate certificate invalidation if it was fetched successfully.\n        certificate_invalidation.deactivate()\n\n    # We need to generate certificate only for a single student here\n    student = certificate_invalidation.generated_certificate.user\n    instructor_task.api.generate_certificates_for_students(\n        request, course_key, student_set=\"specific_student\", specific_student_id=student.id\n    )\n\n\ndef validate_request_data_and_get_certificate(certificate_invalidation, course_key):\n    \"\"\"\n    Fetch and return GeneratedCertificate of the student passed in request data for the given course.\n\n    Raises ValueError in case of missing student username/email or\n    if student does not have certificate for the given course.\n\n    :param certificate_invalidation: dict containing certificate invalidation data\n    :param course_key: CourseKey object identifying the current course.\n    :return: GeneratedCertificate object of the student for the given course\n    \"\"\"\n    user = certificate_invalidation.get(\"user\")\n\n    if not user:\n        raise ValueError(\n            _('Student username/email field is required and can not be empty. '\n              'Kindly fill in username/email and then press \"Invalidate Certificate\" button.')\n        )\n\n    student = get_student(user, course_key)\n\n    certificate = GeneratedCertificate.certificate_for_student(student, course_key)\n    if not certificate:\n        raise ValueError(_(\n            \"The student {student} does not have certificate for the course {course}. Kindly verify student \"\n            \"username/email and the selected course are correct and try again.\"\n        ).format(student=student.username, course=course_key.course))\n    return certificate\n", "###\nData Download Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\n# Load utilities\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\nPendingInstructorTasks = -> window.InstructorDashboard.util.PendingInstructorTasks\nReportDownloads = -> window.InstructorDashboard.util.ReportDownloads\n\n# Data Download Certificate issued\nclass @DataDownload_Certificate\n  constructor: (@$container) ->\n    # gather elements\n    @$list_issued_certificate_table_btn = @$container.find(\"input[name='issued-certificates-list']\")\n    @$list_issued_certificate_csv_btn = @$container.find(\"input[name='issued-certificates-csv']\")\n    @$certificate_display_table       = @$container.find '.certificate-data-display-table'\n    @$certificates_request_response_error  = @$container.find '.issued-certificates-error.request-response-error'\n\n\n    @$list_issued_certificate_table_btn.click (e) =>\n      url = @$list_issued_certificate_table_btn.data 'endpoint'\n      # Dynamically generate slickgrid table for displaying issued certificate information.\n      @clear_ui()\n      @$certificate_display_table.text gettext('Loading data...')\n      # fetch user list\n      $.ajax\n        type: 'POST'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_ui()\n          @$certificates_request_response_error.text gettext(\"Error getting issued certificates list.\")\n          $(\".issued_certificates .issued-certificates-error.msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @clear_ui()\n          # display on a SlickGrid\n          options =\n            enableCellNavigation: true\n            enableColumnReorder: false\n            forceFitColumns: true\n            rowHeight: 35\n\n          columns = ({id: feature, field: feature, name: data.feature_names[feature]} for feature in data.queried_features)\n          grid_data = data.certificates\n\n          $table_placeholder = $ '<div/>', class: 'slickgrid'\n          @$certificate_display_table.append $table_placeholder\n          new Slick.Grid($table_placeholder, grid_data, columns, options)\n\n    @$list_issued_certificate_csv_btn.click (e) =>\n      @clear_ui()\n      url = @$list_issued_certificate_csv_btn.data 'endpoint'\n      location.href = url + '?csv=true'\n\n  clear_ui: ->\n    # Clear any generated tables, warning messages, etc of certificates.\n    @$certificate_display_table.empty()\n    @$certificates_request_response_error.empty()\n    $(\".issued-certificates-error.msg-error\").css({\"display\":\"none\"})\n\n# Data Download Section\nclass DataDownload\n  constructor: (@$section) ->\n    # attach self to html so that instructor_dashboard.coffee can find\n    #  this object to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # isolate # initialize DataDownload_Certificate subsection\n    new DataDownload_Certificate @$section.find '.issued_certificates'\n\n    # gather elements\n    @$list_studs_btn = @$section.find(\"input[name='list-profiles']\")\n    @$list_studs_csv_btn = @$section.find(\"input[name='list-profiles-csv']\")\n    @$list_proctored_exam_results_csv_btn = @$section.find(\"input[name='proctored-exam-results-report']\")\n    @$survey_results_csv_btn = @$section.find(\"input[name='survey-results-report']\")\n    @$list_may_enroll_csv_btn = @$section.find(\"input[name='list-may-enroll-csv']\")\n    @$list_problem_responses_csv_input = @$section.find(\"input[name='problem-location']\")\n    @$list_problem_responses_csv_btn = @$section.find(\"input[name='list-problem-responses-csv']\")\n    @$list_anon_btn = @$section.find(\"input[name='list-anon-ids']\")\n    @$grade_config_btn = @$section.find(\"input[name='dump-gradeconf']\")\n    @$calculate_grades_csv_btn = @$section.find(\"input[name='calculate-grades-csv']\")\n    @$problem_grade_report_csv_btn = @$section.find(\"input[name='problem-grade-report']\")\n    @$async_report_btn = @$section.find(\"input[class='async-report-btn']\")\n\n    # response areas\n    @$download                        = @$section.find '.data-download-container'\n    @$download_display_text           = @$download.find '.data-display-text'\n    @$download_request_response_error = @$download.find '.request-response-error'\n    @$reports                         = @$section.find '.reports-download-container'\n    @$download_display_table          = @$reports.find '.profile-data-display-table'\n    @$reports_request_response        = @$reports.find '.request-response'\n    @$reports_request_response_error  = @$reports.find '.request-response-error'\n\n    @report_downloads = new (ReportDownloads()) @$section\n    @instructor_tasks = new (PendingInstructorTasks()) @$section\n    @clear_display()\n\n    # attach click handlers\n    # The list-anon case is always CSV\n    @$list_anon_btn.click (e) =>\n      url = @$list_anon_btn.data 'endpoint'\n      location.href = url\n\n    # attach click handlers\n    # The list_proctored_exam_results case is always CSV\n    @$list_proctored_exam_results_csv_btn.click (e) =>\n      url = @$list_proctored_exam_results_csv_btn.data 'endpoint'\n      # display html from proctored exam results config endpoint\n      $.ajax\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$reports_request_response_error.text gettext(\n            \"Error generating proctored exam results. Please try again.\"\n          )\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @clear_display()\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    # attach click handlers\n    # The list_proctored_exam_results case is always CSV\n    @$survey_results_csv_btn.click (e) =>\n      url = @$survey_results_csv_btn.data 'endpoint'\n      # display html from survey results config endpoint\n      $.ajax\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$reports_request_response_error.text gettext(\n            \"Error generating survey results. Please try again.\"\n          )\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @clear_display()\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    # this handler binds to both the download\n    # and the csv button\n    @$list_studs_csv_btn.click (e) =>\n      @clear_display()\n\n      url = @$list_studs_csv_btn.data 'endpoint'\n      # handle csv special case\n      # redirect the document to the csv file.\n      url += '/csv'\n\n      $.ajax\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @$reports_request_response_error.text gettext(\"Error generating student profile information. Please try again.\")\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    @$list_studs_btn.click (e) =>\n      url = @$list_studs_btn.data 'endpoint'\n\n      # Dynamically generate slickgrid table for displaying student profile information\n      @clear_display()\n      @$download_display_table.text gettext('Loading')\n\n      # fetch user list\n      $.ajax\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$download_request_response_error.text gettext(\"Error getting student list.\")\n        success: (data) =>\n          @clear_display()\n\n          # display on a SlickGrid\n          options =\n            enableCellNavigation: true\n            enableColumnReorder: false\n            forceFitColumns: true\n            rowHeight: 35\n\n          columns = ({id: feature, field: feature, name: data.feature_names[feature]} for feature in data.queried_features)\n          grid_data = data.students\n\n          $table_placeholder = $ '<div/>', class: 'slickgrid'\n          @$download_display_table.append $table_placeholder\n          grid = new Slick.Grid($table_placeholder, grid_data, columns, options)\n          # grid.autosizeColumns()\n\n    @$list_problem_responses_csv_btn.click (e) =>\n      @clear_display()\n\n      url = @$list_problem_responses_csv_btn.data 'endpoint'\n      $.ajax\n        dataType: 'json'\n        url: url\n        data:\n          problem_location: @$list_problem_responses_csv_input.val()\n        error: (std_ajax_err) =>\n          @$reports_request_response_error.text JSON.parse(std_ajax_err['responseText'])\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    @$list_may_enroll_csv_btn.click (e) =>\n      @clear_display()\n\n      url = @$list_may_enroll_csv_btn.data 'endpoint'\n      $.ajax\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @$reports_request_response_error.text gettext(\"Error generating list of students who may enroll. Please try again.\")\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    @$grade_config_btn.click (e) =>\n      url = @$grade_config_btn.data 'endpoint'\n      # display html from grading config endpoint\n      $.ajax\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$download_request_response_error.text gettext(\"Error retrieving grading configuration.\")\n        success: (data) =>\n          @clear_display()\n          @$download_display_text.html data['grading_config_summary']\n\n    @$async_report_btn.click (e) =>\n        # Clear any CSS styling from the request-response areas\n        #$(\".msg-confirm\").css({\"display\":\"none\"})\n        #$(\".msg-error\").css({\"display\":\"none\"})\n        @clear_display()\n        url = $(e.target).data 'endpoint'\n        $.ajax\n          dataType: 'json'\n          url: url\n          error: std_ajax_err =>\n            if e.target.name == 'calculate-grades-csv'\n              @$grades_request_response_error.text gettext(\"Error generating grades. Please try again.\")\n            else if e.target.name == 'problem-grade-report'\n              @$grades_request_response_error.text gettext(\"Error generating problem grade report. Please try again.\")\n            else if e.target.name == 'export-ora2-data'\n              @$grades_request_response_error.text gettext(\"Error generating ORA data report. Please try again.\")\n            $(\".msg-error\").css({\"display\":\"block\"})\n          success: (data) =>\n            @$reports_request_response.text data['status']\n            $(\".msg-confirm\").css({\"display\":\"block\"})\n\n  # handler for when the section title is clicked.\n  onClickTitle: ->\n    # Clear display of anything that was here before\n    @clear_display()\n    @instructor_tasks.task_poller.start()\n    @report_downloads.downloads_poller.start()\n\n  # handler for when the section is closed\n  onExit: ->\n    @instructor_tasks.task_poller.stop()\n    @report_downloads.downloads_poller.stop()\n\n  clear_display: ->\n    # Clear any generated tables, warning messages, etc.\n    @$download_display_text.empty()\n    @$download_display_table.empty()\n    @$download_request_response_error.empty()\n    @$reports_request_response.empty()\n    @$reports_request_response_error.empty()\n    # Clear any CSS styling from the request-response areas\n    $(\".msg-confirm\").css({\"display\":\"none\"})\n    $(\".msg-error\").css({\"display\":\"none\"})\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n  DataDownload: DataDownload\n", "###\nExtensions Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\nplantTimeout = -> window.InstructorDashboard.util.plantTimeout.apply this, arguments\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\n\n# Extensions Section\nclass Extensions\n\n  constructor: (@$section) ->\n    # attach self to html\n    # so that instructor_dashboard.coffee can find this object\n    # to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # Gather buttons\n    @$change_due_date = @$section.find(\"input[name='change-due-date']\")\n    @$reset_due_date = @$section.find(\"input[name='reset-due-date']\")\n    @$show_unit_extensions = @$section.find(\"input[name='show-unit-extensions']\")\n    @$show_student_extensions = @$section.find(\"input[name='show-student-extensions']\")\n\n    # Gather notification areas\n    @$section.find(\".request-response\").hide()\n    @$section.find(\".request-response-error\").hide()\n\n    # Gather grid elements\n    $grid_display = @$section.find '.data-display'\n    @$grid_text = $grid_display.find '.data-display-text'\n    @$grid_table = $grid_display.find '.data-display-table'\n\n    # Click handlers\n    @$change_due_date.click =>\n      @clear_display()\n      @$student_input = @$section.find(\"#set-extension input[name='student']\")\n      @$url_input = @$section.find(\"#set-extension select[name='url']\")\n      @$due_datetime_input = @$section.find(\"#set-extension input[name='due_datetime']\")\n      send_data =\n        student: @$student_input.val()\n        url: @$url_input.val()\n        due_datetime: @$due_datetime_input.val()\n\n      $.ajax\n        dataType: 'json'\n        url: @$change_due_date.data 'endpoint'\n        data: send_data\n        success: (data) => @display_response \"set-extension\", data\n        error: (xhr) => @fail_with_error \"set-extension\", \"Error changing due date\", xhr\n\n    @$reset_due_date.click =>\n      @clear_display()\n      @$student_input = @$section.find(\"#reset-extension input[name='student']\")\n      @$url_input = @$section.find(\"#reset-extension select[name='url']\")\n      send_data =\n        student: @$student_input.val()\n        url: @$url_input.val()\n\n      $.ajax\n        dataType: 'json'\n        url: @$reset_due_date.data 'endpoint'\n        data: send_data\n        success: (data) => @display_response \"reset-extension\", data\n        error: (xhr) => @fail_with_error \"reset-extension\", \"Error reseting due date\", xhr\n\n    @$show_unit_extensions.click =>\n      @clear_display()\n      @$grid_table.text 'Loading'\n\n      @$url_input = @$section.find(\"#view-granted-extensions select[name='url']\")\n      url = @$show_unit_extensions.data 'endpoint'\n      send_data =\n        url: @$url_input.val()\n      $.ajax\n        dataType: 'json'\n        url: url\n        data: send_data\n        error: (xhr) => @fail_with_error \"view-granted-extensions\", \"Error getting due dates\", xhr\n        success: (data) => @display_grid data\n\n    @$show_student_extensions.click =>\n      @clear_display()\n      @$grid_table.text 'Loading'\n\n      url = @$show_student_extensions.data 'endpoint'\n      @$student_input = @$section.find(\"#view-granted-extensions input[name='student']\")\n      send_data =\n        student: @$student_input.val()\n      $.ajax\n        dataType: 'json'\n        url: url\n        data: send_data\n        error: (xhr) => @fail_with_error \"view-granted-extensions\", \"Error getting due dates\", xhr\n        success: (data) => @display_grid data\n      \n  # handler for when the section title is clicked.\n  onClickTitle: ->\n\n  fail_with_error: (id, msg, xhr) ->\n    $task_error = @$section.find(\"#\" + id + \" .request-response-error\")\n    $task_response = @$section.find(\"#\" + id + \" .request-response\")\n    @clear_display()\n    data = $.parseJSON xhr.responseText\n    msg += \": \" + data['error']\n    console.warn msg\n    $task_response.empty()\n    $task_error.empty()\n    $task_error.text msg\n    $task_error.show()\n\n  display_response: (id, data) ->\n    $task_error = @$section.find(\"#\" + id + \" .request-response-error\")\n    $task_response = @$section.find(\"#\" + id + \" .request-response\")\n    $task_error.empty().hide()\n    $task_response.empty().text data\n    $task_response.show()\n\n  display_grid: (data) ->\n    @clear_display()\n    @$grid_text.text data.title\n\n    # display on a SlickGrid\n    options =\n      enableCellNavigation: true\n      enableColumnReorder: false\n      forceFitColumns: true\n\n    columns = ({id: col, field: col, name: col} for col in data.header)\n    grid_data = data.data\n\n    $table_placeholder = $ '<div/>', class: 'slickgrid', style: 'min-height: 400px'\n    @$grid_table.append $table_placeholder\n    grid = new Slick.Grid($table_placeholder, grid_data, columns, options)\n\n  clear_display: ->\n    @$grid_text.empty()\n    @$grid_table.empty()\n    @$section.find(\".request-response-error\").empty().hide()\n    @$section.find(\".request-response\").empty().hide()\n\n# export for use\n# create parent namespaces if they do not already exist.\n# abort if underscore can not be found.\nif _?\n  _.defaults window, InstructorDashboard: {}\n  _.defaults window.InstructorDashboard, sections: {}\n  _.defaults window.InstructorDashboard.sections,\n    Extensions: Extensions\n", "###\nMembership Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\nplantTimeout = -> window.InstructorDashboard.util.plantTimeout.apply this, arguments\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\nemailStudents = false\n\n\nclass MemberListWidget\n  # create a MemberListWidget `$container` is a jquery object to embody.\n  # `params` holds template parameters. `params` should look like the defaults below.\n  constructor: (@$container, params={}) ->\n    params = _.defaults params,\n      title: \"Member List\"\n      info: \"\"\"\n        Use this list to manage members.\n      \"\"\"\n      labels: [\"field1\", \"field2\", \"field3\"]\n      add_placeholder: \"Enter name\"\n      add_btn_label: \"Add Member\"\n      add_handler: (input) ->\n\n    template_html = $(\"#member-list-widget-template\").html()\n    @$container.html Mustache.render template_html, params\n\n    # bind add button\n    @$('input[type=\"button\"].add').click =>\n      params.add_handler? @$('.add-field').val()\n\n  # clear the input text field\n  clear_input: -> @$('.add-field').val ''\n\n  # clear all table rows\n  clear_rows: -> @$('table tbody').empty()\n\n  # takes a table row as an array items are inserted as text, unless detected\n  # as a jquery objects in which case they are inserted directly. if an\n  # element is a jquery object\n  add_row: (row_array) ->\n    $tbody = @$('table tbody')\n    $tr = $ '<tr>'\n    for item in row_array\n      $td = $ '<td>'\n      if item instanceof jQuery\n        $td.append item\n      else\n        $td.text item\n      $tr.append $td\n    $tbody.append $tr\n\n  # local selector\n  $: (selector) ->\n    if @debug?\n      s = @$container.find selector\n      if s?.length != 1\n        console.warn \"local selector '#{selector}' found (#{s.length}) results\"\n      s\n    else\n      @$container.find selector\n\n\nclass AuthListWidget extends MemberListWidget\n  constructor: ($container, @rolename, @$error_section) ->\n    super $container,\n      title: $container.data 'display-name'\n      info: $container.data 'info-text'\n      labels: [gettext(\"Username\"), gettext(\"Email\"), gettext(\"Revoke access\")]\n      add_placeholder: gettext(\"Enter username or email\")\n      add_btn_label: $container.data 'add-button-label'\n      add_handler: (input) => @add_handler input\n\n    @debug = true\n    @list_endpoint = $container.data 'list-endpoint'\n    @modify_endpoint = $container.data 'modify-endpoint'\n    unless @rolename?\n      throw \"AuthListWidget missing @rolename\"\n\n    @reload_list()\n\n  # action to do when is reintroduced into user's view\n  re_view: ->\n    @clear_errors()\n    @clear_input()\n    @reload_list()\n\n  # handle clicks on the add button\n  add_handler: (input) ->\n    if input? and input isnt ''\n      @modify_member_access input, 'allow', (error) =>\n        # abort on error\n        return @show_errors error unless error is null\n        @clear_errors()\n        @clear_input()\n        @reload_list()\n    else\n      @show_errors gettext \"Please enter a username or email.\"\n\n  # reload the list of members\n  reload_list: ->\n    # @clear_rows()\n    @get_member_list (error, member_list) =>\n      # abort on error\n      return @show_errors error unless error is null\n\n      # only show the list of there are members\n      @clear_rows()\n\n      # use _.each instead of 'for' so that member\n      # is bound in the button callback.\n      _.each member_list, (member) =>\n        # if there are members, show the list\n\n        # create revoke button and insert it into the row\n        label_trans = gettext(\"Revoke access\")\n        $revoke_btn = $ _.template('<div class=\"revoke\"><span class=\"icon fa fa-times-circle\" aria-hidden=\"true\"></span> <%= label %></div>')({label: label_trans}),\n          class: 'revoke'\n        $revoke_btn.click =>\n            @modify_member_access member.email, 'revoke', (error) =>\n              # abort on error\n              return @show_errors error unless error is null\n              @clear_errors()\n              @reload_list()\n        @add_row [member.username, member.email, $revoke_btn]\n\n  # clear error display\n  clear_errors: -> @$error_section?.text ''\n\n  # set error display\n  show_errors: (msg) -> @$error_section?.text msg\n\n  # send ajax request to list members\n  # `cb` is called with cb(error, member_list)\n  get_member_list: (cb) ->\n    $.ajax\n      dataType: 'json'\n      url: @list_endpoint\n      data: rolename: @rolename\n      success: (data) => cb? null, data[@rolename]\n      error: std_ajax_err =>\n        `// Translators: A rolename appears this sentence. A rolename is something like \"staff\" or \"beta tester\".`\n        cb? gettext(\"Error fetching list for role\") + \" '#{@rolename}'\"\n\n  # send ajax request to modify access\n  # (add or remove them from the list)\n  # `action` can be 'allow' or 'revoke'\n  # `cb` is called with cb(error, data)\n  modify_member_access: (unique_student_identifier, action, cb) ->\n    $.ajax\n      dataType: 'json'\n      url: @modify_endpoint\n      data:\n        unique_student_identifier: unique_student_identifier\n        rolename: @rolename\n        action: action\n      success: (data) => @member_response data\n      error: std_ajax_err => cb? gettext \"Error changing user's permissions.\"\n\n  member_response: (data) ->\n    @clear_errors()\n    @clear_input()\n    if data.userDoesNotExist\n      msg = gettext(\"Could not find a user with username or email address '<%= identifier %>'.\")\n      @show_errors _.template(msg, {identifier: data.unique_student_identifier})\n    else if data.inactiveUser\n      msg = gettext(\"Error: User '<%= username %>' has not yet activated their account. Users must create and activate their accounts before they can be assigned a role.\")\n      @show_errors _.template(msg, {username: data.unique_student_identifier})\n    else if data.removingSelfAsInstructor\n      @show_errors gettext \"Error: You cannot remove yourself from the Instructor group!\"\n    else\n      @reload_list()\n\nclass @AutoEnrollmentViaCsv\n  constructor: (@$container) ->\n    # Wrapper for the AutoEnrollmentViaCsv subsection.\n    # This object handles buttons, success and failure reporting,\n    # and server communication.\n    @$student_enrollment_form = @$container.find(\"form#student-auto-enroll-form\")\n    @$enrollment_signup_button = @$container.find(\"[name='enrollment_signup_button']\")\n    @$students_list_file = @$container.find(\"input[name='students_list']\")\n    @$csrf_token = @$container.find(\"input[name='csrfmiddlewaretoken']\")\n    @$results = @$container.find(\"div.results\")\n    @$browse_button = @$container.find(\"#browseBtn\")\n    @$browse_file = @$container.find(\"#browseFile\")\n\n    @processing = false\n\n    @$browse_button.on \"change\", (event) =>\n      if event.currentTarget.files.length == 1\n        @$browse_file.val(event.currentTarget.value.substring(event.currentTarget.value.lastIndexOf(\"\\\\\") + 1))\n\n    # attach click handler for @$enrollment_signup_button\n    @$enrollment_signup_button.click =>\n      @$student_enrollment_form.submit (event) =>\n        if @processing\n          return false\n\n        @processing = true\n\n        event.preventDefault()\n        data = new FormData(event.currentTarget)\n        $.ajax\n            dataType: 'json'\n            type: 'POST'\n            url: event.currentTarget.action\n            data: data\n            processData: false\n            contentType: false\n            success: (data) =>\n              @processing = false\n              @display_response data\n\n        return false\n\n  display_response: (data_from_server) ->\n    @$results.empty()\n    errors = []\n    warnings = []\n    result_from_server_is_success = true\n\n    if data_from_server.general_errors.length\n      result_from_server_is_success = false\n      for general_error in data_from_server.general_errors\n        general_error['is_general_error'] = true\n        errors.push general_error\n\n    if data_from_server.row_errors.length\n      result_from_server_is_success = false\n      for error in data_from_server.row_errors\n        error['is_general_error'] = false\n        errors.push error\n\n    if data_from_server.warnings.length\n      result_from_server_is_success = false\n      for warning in data_from_server.warnings\n        warning['is_general_error'] = false\n        warnings.push warning\n\n    render_response = (title, message, type, student_results) =>\n      details = []\n      for student_result in student_results\n        if student_result.is_general_error\n          details.push student_result.response\n        else\n          response_message = student_result.username + '  ('+ student_result.email + '):  ' + '   (' + student_result.response + ')'\n          details.push response_message\n\n      @$results.append @render_notification_view type, title, message, details\n\n    if errors.length\n      render_response gettext('Errors'), gettext(\"The following errors were generated:\"), 'error', errors\n    if warnings.length\n      render_response gettext('Warnings'), gettext(\"The following warnings were generated:\"), 'warning', warnings\n    if result_from_server_is_success\n      render_response gettext('Success'), gettext(\"All accounts were created successfully.\"), 'confirmation', []\n\n  render_notification_view: (type, title, message, details) ->\n    notification_model = new NotificationModel()\n    notification_model.set({\n          'type': type,\n          'title': title,\n          'message': message,\n          'details': details,\n    });\n    view = new NotificationView(model:notification_model);\n    view.render()\n    return view.$el.html()\n\nclass BetaTesterBulkAddition\n  constructor: (@$container) ->\n    # gather elements\n    @$identifier_input       = @$container.find(\"textarea[name='student-ids-for-beta']\")\n    @$btn_beta_testers       = @$container.find(\"input[name='beta-testers']\")\n    @$checkbox_autoenroll    = @$container.find(\"input[name='auto-enroll']\")\n    @$checkbox_emailstudents = @$container.find(\"input[name='email-students-beta']\")\n    @$task_response          = @$container.find(\".request-response\")\n    @$request_response_error = @$container.find(\".request-response-error\")\n\n    # click handlers\n    @$btn_beta_testers.click (event) =>\n      emailStudents = @$checkbox_emailstudents.is(':checked')\n      autoEnroll = @$checkbox_autoenroll.is(':checked')\n      send_data =\n        action: $(event.target).data('action')  # 'add' or 'remove'\n        identifiers: @$identifier_input.val()\n        email_students: emailStudents\n        auto_enroll: autoEnroll\n\n      $.ajax\n        dataType: 'json'\n        type: 'POST'\n        url: @$btn_beta_testers.data 'endpoint'\n        data: send_data\n        success: (data) => @display_response data\n        error: std_ajax_err => @fail_with_error gettext \"Error adding/removing users as beta testers.\"\n\n  # clear the input text field\n  clear_input: ->\n    @$identifier_input.val ''\n    # default for the checkboxes should be checked\n    @$checkbox_emailstudents.attr('checked', true)\n    @$checkbox_autoenroll.attr('checked', true)\n\n  fail_with_error: (msg) ->\n    console.warn msg\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n    @$request_response_error.text msg\n\n  display_response: (data_from_server) ->\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n    errors = []\n    successes = []\n    no_users = []\n    for student_results in data_from_server.results\n      if student_results.userDoesNotExist\n        no_users.push student_results\n      else if student_results.error\n        errors.push student_results\n      else\n        successes.push student_results\n\n    render_list = (label, ids) =>\n      task_res_section = $ '<div/>', class: 'request-res-section'\n      task_res_section.append $ '<h3/>', text: label\n      ids_list = $ '<ul/>'\n      task_res_section.append ids_list\n\n      for identifier in ids\n        ids_list.append $ '<li/>', text: identifier\n\n      @$task_response.append task_res_section\n\n    if successes.length and data_from_server.action is 'add'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were successfully added as beta testers:\"), (sr.identifier for sr in successes)\n\n    if successes.length and data_from_server.action is 'remove'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were successfully removed as beta testers:\"), (sr.identifier for sr in successes)\n\n    if errors.length and data_from_server.action is 'add'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were not added as beta testers:\"), (sr.identifier for sr in errors)\n\n    if errors.length and data_from_server.action is 'remove'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were not removed as beta testers:\"), (sr.identifier for sr in errors)\n\n    if no_users.length\n      no_users.push $ gettext(\"Users must create and activate their account before they can be promoted to beta tester.\")\n      `// Translators: A list of identifiers (which are email addresses and/or usernames) appears after this sentence`\n      render_list gettext(\"Could not find users associated with the following identifiers:\"), (sr.identifier for sr in no_users)\n\n# Wrapper for the batch enrollment subsection.\n# This object handles buttons, success and failure reporting,\n# and server communication.\nclass BatchEnrollment\n  constructor: (@$container) ->\n    # gather elements\n    @$identifier_input       = @$container.find(\"textarea[name='student-ids']\")\n    @$enrollment_button      = @$container.find(\".enrollment-button\")\n    @$is_course_white_label  = @$container.find(\"#is_course_white_label\").val()\n    @$reason_field           = @$container.find(\"textarea[name='reason-field']\")\n    @$checkbox_autoenroll    = @$container.find(\"input[name='auto-enroll']\")\n    @$checkbox_emailstudents = @$container.find(\"input[name='email-students']\")\n    @$task_response          = @$container.find(\".request-response\")\n    @$request_response_error = @$container.find(\".request-response-error\")\n\n    # attach click handler for enrollment buttons\n    @$enrollment_button.click (event) =>\n      if @$is_course_white_label == 'True'\n        if not @$reason_field.val()\n          @fail_with_error gettext \"Reason field should not be left blank.\"\n          return false\n\n      emailStudents = @$checkbox_emailstudents.is(':checked')\n      send_data =\n        action: $(event.target).data('action') # 'enroll' or 'unenroll'\n        identifiers: @$identifier_input.val()\n        auto_enroll: @$checkbox_autoenroll.is(':checked')\n        email_students: emailStudents\n        reason: @$reason_field.val()\n\n      $.ajax\n        dataType: 'json'\n        type: 'POST'\n        url: $(event.target).data 'endpoint'\n        data: send_data\n        success: (data) => @display_response data\n        error: std_ajax_err => @fail_with_error gettext \"Error enrolling/unenrolling users.\"\n\n\n  # clear the input text field\n  clear_input: ->\n    @$identifier_input.val ''\n    @$reason_field.val ''\n    # default for the checkboxes should be checked\n    @$checkbox_emailstudents.attr('checked', true)\n    @$checkbox_autoenroll.attr('checked', true)\n\n  fail_with_error: (msg) ->\n    console.warn msg\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n    @$request_response_error.text msg\n\n  display_response: (data_from_server) ->\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n\n    # these results arrays contain student_results\n    # only populated arrays will be rendered\n    #\n    # invalid identifiers\n    invalid_identifier = []\n    # students for which there was an error during the action\n    errors = []\n    # students who are now enrolled in the course\n    enrolled = []\n    # students who are now allowed to enroll in the course\n    allowed = []\n    # students who will be autoenrolled on registration\n    autoenrolled = []\n    # students who are now not enrolled in the course\n    notenrolled = []\n    # students who were not enrolled or allowed prior to unenroll action\n    notunenrolled = []\n\n    # categorize student results into the above arrays.\n    for student_results in data_from_server.results\n      # for a successful action.\n      # student_results is of the form {\n      #   \"identifier\": \"jd405@edx.org\",\n      #   \"before\": {\n      #     \"enrollment\": true,\n      #     \"auto_enroll\": false,\n      #     \"user\": true,\n      #     \"allowed\": false\n      #   }\n      #   \"after\": {\n      #     \"enrollment\": true,\n      #     \"auto_enroll\": false,\n      #     \"user\": true,\n      #     \"allowed\": false\n      #   },\n      # }\n      #\n      # for an action error.\n      # student_results is of the form {\n      #   'identifier': identifier,\n      #   # then one of:\n      #   'error': True,\n      #   'invalidIdentifier': True  # if identifier can't find a valid User object and doesn't pass validate_email\n      # }\n\n      if student_results.invalidIdentifier\n        invalid_identifier.push student_results\n\n      else if student_results.error\n        errors.push student_results\n\n      else if student_results.after.enrollment\n        enrolled.push student_results\n\n      else if student_results.after.allowed\n        if student_results.after.auto_enroll\n          autoenrolled.push student_results\n        else\n          allowed.push student_results\n\n      # The instructor is trying to unenroll someone who is not enrolled or allowed to enroll; non-sensical action.\n      else if data_from_server.action is 'unenroll' and not (student_results.before.enrollment) and not (student_results.before.allowed)\n        notunenrolled.push student_results\n\n      else if not student_results.after.enrollment\n        notenrolled.push student_results\n\n      else\n        console.warn 'student results not reported to user'\n        console.warn student_results\n\n    # render populated result arrays\n    render_list = (label, ids) =>\n      task_res_section = $ '<div/>', class: 'request-res-section'\n      task_res_section.append $ '<h3/>', text: label\n      ids_list = $ '<ul/>'\n      task_res_section.append ids_list\n\n      for identifier in ids\n        ids_list.append $ '<li/>', text: identifier\n\n      @$task_response.append task_res_section\n\n    if invalid_identifier.length\n      render_list gettext(\"The following email addresses and/or usernames are invalid:\"), (sr.identifier for sr in invalid_identifier)\n\n    if errors.length\n      errors_label = do ->\n        if data_from_server.action is 'enroll'\n          \"There was an error enrolling:\"\n        else if data_from_server.action is 'unenroll'\n          \"There was an error unenrolling:\"\n        else\n          console.warn \"unknown action from server '#{data_from_server.action}'\"\n          \"There was an error processing:\"\n\n      for student_results in errors\n        render_list errors_label, (sr.identifier for sr in errors)\n\n    if enrolled.length and emailStudents\n      render_list gettext(\"Successfully enrolled and sent email to the following users:\"), (sr.identifier for sr in enrolled)\n\n    if enrolled.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Successfully enrolled the following users:\"), (sr.identifier for sr in enrolled)\n\n    # Student hasn't registered so we allow them to enroll\n    if allowed.length and emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Successfully sent enrollment emails to the following users. They will be allowed to enroll once they register:\"),\n        (sr.identifier for sr in allowed)\n\n    # Student hasn't registered so we allow them to enroll\n    if allowed.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users will be allowed to enroll once they register:\"),\n        (sr.identifier for sr in allowed)\n\n    # Student hasn't registered so we allow them to enroll with autoenroll\n    if autoenrolled.length and emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Successfully sent enrollment emails to the following users. They will be enrolled once they register:\"),\n        (sr.identifier for sr in autoenrolled)\n\n    # Student hasn't registered so we allow them to enroll with autoenroll\n    if autoenrolled.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users will be enrolled once they register:\"),\n        (sr.identifier for sr in autoenrolled)\n\n    if notenrolled.length and emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Emails successfully sent. The following users are no longer enrolled in the course:\"),\n        (sr.identifier for sr in notenrolled)\n\n    if notenrolled.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"The following users are no longer enrolled in the course:\"),\n        (sr.identifier for sr in notenrolled)\n\n    if notunenrolled.length\n      `// Translators: A list of users appears after this sentence. This situation arises when a staff member tries to unenroll a user who is not currently enrolled in this course.`\n      render_list gettext(\"These users were not affiliated with the course so could not be unenrolled:\"),\n        (sr.identifier for sr in notunenrolled)\n\n# Wrapper for auth list subsection.\n# manages a list of users who have special access.\n# these could be instructors, staff, beta users, or forum roles.\n# uses slickgrid to display list.\nclass AuthList\n  # rolename is one of ['instructor', 'staff'] for instructor_staff endpoints\n  # rolename is the name of Role for forums for the forum endpoints\n  constructor: (@$container, @rolename) ->\n    # gather elements\n    @$display_table          = @$container.find('.auth-list-table')\n    @$request_response_error = @$container.find('.request-response-error')\n    @$add_section            = @$container.find('.auth-list-add')\n    @$allow_field             = @$add_section.find(\"input[name='email']\")\n    @$allow_button            = @$add_section.find(\"input[name='allow']\")\n\n    # attach click handler\n    @$allow_button.click =>\n      @access_change @$allow_field.val(), 'allow', => @reload_auth_list()\n      @$allow_field.val ''\n\n    @reload_auth_list()\n\n  # fetch and display list of users who match criteria\n  reload_auth_list: ->\n    # helper function to display server data in the list\n    load_auth_list = (data) =>\n      # clear existing data\n      @$request_response_error.empty()\n      @$display_table.empty()\n\n      # setup slickgrid\n      options =\n        enableCellNavigation: true\n        enableColumnReorder: false\n        # autoHeight: true\n        forceFitColumns: true\n\n      # this is a hack to put a button/link in a slick grid cell\n      # if you change columns, then you must update\n      # WHICH_CELL_IS_REVOKE to have the index\n      # of the revoke column (left to right).\n      WHICH_CELL_IS_REVOKE = 3\n      columns = [\n        id: 'username'\n        field: 'username'\n        name: 'Username'\n      ,\n        id: 'email'\n        field: 'email'\n        name: 'Email'\n      ,\n        id: 'first_name'\n        field: 'first_name'\n        name: 'First Name'\n      ,\n      #   id: 'last_name'\n      #   field: 'last_name'\n      #   name: 'Last Name'\n      # ,\n        id: 'revoke'\n        field: 'revoke'\n        name: 'Revoke'\n        formatter: (row, cell, value, columnDef, dataContext) ->\n          \"<span class='revoke-link'>Revoke Access</span>\"\n      ]\n\n      table_data = data[@rolename]\n\n      $table_placeholder = $ '<div/>', class: 'slickgrid'\n      @$display_table.append $table_placeholder\n      grid = new Slick.Grid($table_placeholder, table_data, columns, options)\n\n      # click handler part of the revoke button/link hack.\n      grid.onClick.subscribe (e, args) =>\n        item = args.grid.getDataItem(args.row)\n        if args.cell is WHICH_CELL_IS_REVOKE\n          @access_change item.email, 'revoke', => @reload_auth_list()\n\n    # fetch data from the endpoint\n    # the endpoint comes from data-endpoint of the table\n    $.ajax\n      dataType: 'json'\n      url: @$display_table.data 'endpoint'\n      data: rolename: @rolename\n      success: load_auth_list\n      error: std_ajax_err => @$request_response_error.text \"Error fetching list for '#{@rolename}'\"\n\n\n  # slickgrid's layout collapses when rendered\n  # in an invisible div. use this method to reload\n  # the AuthList widget\n  refresh: ->\n    @$display_table.empty()\n    @reload_auth_list()\n\n  # update the access of a user.\n  # (add or remove them from the list)\n  # action should be one of ['allow', 'revoke']\n  access_change: (email, action, cb) ->\n    $.ajax\n      dataType: 'json'\n      url: @$add_section.data 'endpoint'\n      data:\n        email: email\n        rolename: @rolename\n        action: action\n      success: (data) -> cb?(data)\n      error: std_ajax_err => @$request_response_error.text gettext \"Error changing user's permissions.\"\n\n\n# Membership Section\nclass Membership\n  # enable subsections.\n  constructor: (@$section) ->\n    # attach self to html\n    # so that instructor_dashboard.coffee can find this object\n    # to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # isolate # initialize BatchEnrollment subsection\n    plantTimeout 0, => new BatchEnrollment @$section.find '.batch-enrollment'\n\n    # isolate # initialize AutoEnrollmentViaCsv subsection\n    plantTimeout 0, => new AutoEnrollmentViaCsv @$section.find '.auto_enroll_csv'\n\n    # initialize BetaTesterBulkAddition subsection\n    plantTimeout 0, => new BetaTesterBulkAddition @$section.find '.batch-beta-testers'\n\n    # gather elements\n    @$list_selector = @$section.find 'select#member-lists-selector'\n    @$auth_list_containers = @$section.find '.auth-list-container'\n    @$auth_list_errors = @$section.find '.member-lists-management .request-response-error'\n\n    # initialize & store AuthList subsections\n    # one for each .auth-list-container in the section.\n    @auth_lists = _.map (@$auth_list_containers), (auth_list_container) =>\n      rolename = $(auth_list_container).data 'rolename'\n      new AuthListWidget $(auth_list_container), rolename, @$auth_list_errors\n\n    # populate selector\n    @$list_selector.empty()\n    for auth_list in @auth_lists\n      @$list_selector.append $ '<option/>',\n        text: auth_list.$container.data 'display-name'\n        data:\n          auth_list: auth_list\n    if @auth_lists.length is 0\n      @$list_selector.hide()\n\n    @$list_selector.change =>\n      $opt = @$list_selector.children('option:selected')\n      return unless $opt.length > 0\n      for auth_list in @auth_lists\n        auth_list.$container.removeClass 'active'\n      auth_list = $opt.data('auth_list')\n      auth_list.$container.addClass 'active'\n      auth_list.re_view()\n\n    # one-time first selection of top list.\n    @$list_selector.change()\n\n  # handler for when the section title is clicked.\n  onClickTitle: ->\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n  Membership: Membership\n", "###\nEmail Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\n# Load utilities\nplantTimeout = -> window.InstructorDashboard.util.plantTimeout.apply this, arguments\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\nPendingInstructorTasks = -> window.InstructorDashboard.util.PendingInstructorTasks\ncreate_task_list_table = -> window.InstructorDashboard.util.create_task_list_table.apply this, arguments\ncreate_email_content_table = -> window.InstructorDashboard.util.create_email_content_table.apply this, arguments\ncreate_email_message_views = -> window.InstructorDashboard.util.create_email_message_views.apply this, arguments\nKeywordValidator = -> window.InstructorDashboard.util.KeywordValidator\n\nclass @SendEmail\n    constructor: (@$container) ->\n        # gather elements\n        @$emailEditor = XBlock.initializeBlock($('.xblock-studio_view'));\n        @$send_to = @$container.find(\"input[name='send_to']\")\n        @$subject = @$container.find(\"input[name='subject']\")\n        @$btn_send = @$container.find(\"input[name='send']\")\n        @$task_response = @$container.find(\".request-response\")\n        @$request_response_error = @$container.find(\".request-response-error\")\n        @$content_request_response_error = @$container.find(\".content-request-response-error\")\n        @$history_request_response_error = @$container.find(\".history-request-response-error\")\n        @$btn_task_history_email = @$container.find(\"input[name='task-history-email']\")\n        @$btn_task_history_email_content = @$container.find(\"input[name='task-history-email-content']\")\n        @$table_task_history_email = @$container.find(\".task-history-email-table\")\n        @$table_email_content_history = @$container.find(\".content-history-email-table\")\n        @$email_content_table_inner = @$container.find(\".content-history-table-inner\")\n        @$email_messages_wrapper = @$container.find(\".email-messages-wrapper\")\n\n        # attach click handlers\n\n        @$btn_send.click =>\n            subject = @$subject.val()\n            body = @$emailEditor.save()['data']\n            targets = []\n            @$send_to.filter(':checked').each ->\n                targets.push(this.value)\n\n            if subject == \"\"\n                alert gettext(\"Your message must have a subject.\")\n\n            else if body == \"\"\n                alert gettext(\"Your message cannot be blank.\")\n\n            else if targets.length == 0\n                alert gettext(\"Your message must have at least one target.\")\n\n            else\n                # Validation for keyword substitution\n                validation = KeywordValidator().validate_string body\n                if not validation.is_valid\n                    message = gettext(\"There are invalid keywords in your email. Check the following keywords and try again.\")\n                    message += \"\\n\" + validation.invalid_keywords.join('\\n')\n                    alert message\n                    return\n\n                target_map = {\n                    \"myself\": gettext(\"Yourself\"),\n                    \"staff\": gettext(\"Everyone who has staff privileges in this course\"),\n                    \"learners\": gettext(\"All learners who are enrolled in this course\"),\n                }\n                success_message = gettext(\"Your email message was successfully queued for sending. In courses with a large number of learners, email messages to learners might take up to an hour to be sent.\")\n                confirm_message = gettext(\"You are sending an email message with the subject {subject} to the following recipients.\")\n                for target in targets\n                    confirm_message += \"\\n-\" + target_map[target]\n                confirm_message += \"\\n\\n\" + gettext(\"Is this OK?\")\n                full_confirm_message = confirm_message.replace('{subject}', subject)\n\n                if confirm full_confirm_message\n\n                    send_data =\n                        action: 'send'\n                        send_to: JSON.stringify(targets)\n                        subject: subject\n                        message: body\n\n                    $.ajax\n                        type: 'POST'\n                        dataType: 'json'\n                        url: @$btn_send.data 'endpoint'\n                        data: send_data\n                        success: (data) =>\n                            @display_response success_message\n\n                        error: std_ajax_err =>\n                            @fail_with_error gettext('Error sending email.')\n\n                else\n                    @task_response.empty()\n                    @$request_response_error.empty()\n\n        # list task history for email\n        @$btn_task_history_email.click =>\n            url = @$btn_task_history_email.data 'endpoint'\n            $.ajax\n                dataType: 'json'\n                url: url\n                success: (data) =>\n                    if data.tasks.length\n                        create_task_list_table @$table_task_history_email, data.tasks\n                    else\n                        @$history_request_response_error.text gettext(\"There is no email history for this course.\")\n                        # Enable the msg-warning css display\n                        @$history_request_response_error.css({\"display\":\"block\"})\n                error: std_ajax_err =>\n                    @$history_request_response_error.text gettext(\"There was an error obtaining email task history for this course.\")\n\n        # List content history for emails sent\n        @$btn_task_history_email_content.click =>\n            url = @$btn_task_history_email_content.data 'endpoint'\n            $.ajax\n                dataType: 'json'\n                url : url\n                success: (data) =>\n                    if data.emails.length\n                        create_email_content_table @$table_email_content_history, @$email_content_table_inner, data.emails\n                        create_email_message_views @$email_messages_wrapper, data.emails\n                    else\n                        @$content_request_response_error.text gettext(\"There is no email history for this course.\")\n                        @$content_request_response_error.css({\"display\":\"block\"})\n                error: std_ajax_err =>\n                    @$content_request_response_error.text gettext(\"There was an error obtaining email content history for this course.\")\n\n    fail_with_error: (msg) ->\n        console.warn msg\n        @$task_response.empty()\n        @$request_response_error.empty()\n        @$request_response_error.text msg\n        $(\".msg-confirm\").css({\"display\":\"none\"})\n\n    display_response: (data_from_server) ->\n        @$task_response.empty()\n        @$request_response_error.empty()\n        @$task_response.text(data_from_server)\n        $(\".msg-confirm\").css({\"display\":\"block\"})\n\n\n# Email Section\nclass Email\n    # enable subsections.\n    constructor: (@$section) ->\n        # attach self to html so that instructor_dashboard.coffee can find\n        #  this object to call event handlers like 'onClickTitle'\n        @$section.data 'wrapper', @\n\n        # isolate # initialize SendEmail subsection\n        plantTimeout 0, => new SendEmail @$section.find '.send-email'\n\n        @instructor_tasks = new (PendingInstructorTasks()) @$section\n\n    # handler for when the section title is clicked.\n    onClickTitle: -> @instructor_tasks.task_poller.start()\n\n    # handler for when the section is closed\n    onExit: -> @instructor_tasks.task_poller.stop()\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n    Email: Email\n", "###\nStudent Admin Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\n# Load utilities\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\ncreate_task_list_table = -> window.InstructorDashboard.util.create_task_list_table.apply this, arguments\nPendingInstructorTasks = -> window.InstructorDashboard.util.PendingInstructorTasks\n\n\n# get jquery element and assert its existance\nfind_and_assert = ($root, selector) ->\n  item = $root.find selector\n  if item.length != 1\n    console.error \"element selection failed for '#{selector}' resulted in length #{item.length}\"\n    throw \"Failed Element Selection\"\n  else\n    item\n\n\nclass @StudentAdmin\n  constructor: (@$section) ->\n    # attach self to html so that instructor_dashboard.coffee can find\n    #  this object to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # gather buttons\n    # some buttons are optional because they can be flipped by the instructor task feature switch\n    # student-specific\n    @$field_student_select_progress = find_and_assert @$section, \"input[name='student-select-progress']\"\n    @$field_student_select_grade  = find_and_assert @$section, \"input[name='student-select-grade']\"\n    @$progress_link               = find_and_assert @$section, \"a.progress-link\"\n    @$field_problem_select_single = find_and_assert @$section, \"input[name='problem-select-single']\"\n    @$btn_reset_attempts_single   = find_and_assert @$section, \"input[name='reset-attempts-single']\"\n    @$btn_delete_state_single     = @$section.find \"input[name='delete-state-single']\"\n    @$btn_rescore_problem_single  = @$section.find \"input[name='rescore-problem-single']\"\n    @$btn_task_history_single     = @$section.find \"input[name='task-history-single']\"\n    @$table_task_history_single   = @$section.find \".task-history-single-table\"\n\n    # entrance-exam-specific\n    @$field_entrance_exam_student_select_grade  = @$section.find \"input[name='entrance-exam-student-select-grade']\"\n    @$btn_reset_entrance_exam_attempts   = @$section.find \"input[name='reset-entrance-exam-attempts']\"\n    @$btn_delete_entrance_exam_state     = @$section.find \"input[name='delete-entrance-exam-state']\"\n    @$btn_rescore_entrance_exam          = @$section.find \"input[name='rescore-entrance-exam']\"\n    @$btn_skip_entrance_exam             = @$section.find \"input[name='skip-entrance-exam']\"\n    @$btn_entrance_exam_task_history     = @$section.find \"input[name='entrance-exam-task-history']\"\n    @$table_entrance_exam_task_history   = @$section.find \".entrance-exam-task-history-table\"\n\n    # course-specific\n    @$field_problem_select_all    = @$section.find \"input[name='problem-select-all']\"\n    @$btn_reset_attempts_all      = @$section.find \"input[name='reset-attempts-all']\"\n    @$btn_rescore_problem_all     = @$section.find \"input[name='rescore-problem-all']\"\n    @$btn_task_history_all        = @$section.find \"input[name='task-history-all']\"\n    @$table_task_history_all      = @$section.find \".task-history-all-table\"\n    @instructor_tasks             = new (PendingInstructorTasks()) @$section\n\n    # response areas\n    @$request_response_error_progress = find_and_assert @$section, \".student-specific-container .request-response-error\"\n    @$request_response_error_grade = find_and_assert @$section, \".student-grade-container .request-response-error\"\n    @$request_response_error_ee       = @$section.find \".entrance-exam-grade-container .request-response-error\"\n    @$request_response_error_all    = @$section.find \".course-specific-container .request-response-error\"\n\n    # attach click handlers\n\n    # go to student progress page\n    @$progress_link.click (e) =>\n      e.preventDefault()\n      unique_student_identifier = @$field_student_select_progress.val()\n      if not unique_student_identifier\n        return @$request_response_error_progress.text gettext(\"Please enter a student email address or username.\")\n      error_message = gettext(\"Error getting student progress url for '<%= student_id %>'. Make sure that the student identifier is spelled correctly.\")\n      full_error_message = _.template(error_message)({student_id: unique_student_identifier})\n\n      $.ajax\n        dataType: 'json'\n        url: @$progress_link.data 'endpoint'\n        data: unique_student_identifier: unique_student_identifier\n        success: @clear_errors_then (data) ->\n          window.location = data.progress_url\n        error: std_ajax_err => @$request_response_error_progress.text full_error_message\n\n    # reset attempts for student on problem\n    @$btn_reset_attempts_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        problem_to_reset: problem_to_reset\n        delete_module: false\n      success_message = gettext(\"Success! Problem attempts reset for problem '<%= problem_id %>' and student '<%= student_id %>'.\")\n      error_message = gettext(\"Error resetting problem attempts for problem '<%= problem_id %>' and student '<%= student_id %>'. Make sure that the problem and student identifiers are complete and correct.\")\n      full_success_message = _.template(success_message)({problem_id: problem_to_reset, student_id: unique_student_identifier})\n      full_error_message = _.template(error_message)({problem_id: problem_to_reset, student_id: unique_student_identifier})\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_reset_attempts_single.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then -> alert full_success_message\n        error: std_ajax_err => @$request_response_error_grade.text full_error_message\n\n    # delete state for student on problem\n    @$btn_delete_state_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      confirm_message = gettext(\"Delete student '<%= student_id %>'s state on problem '<%= problem_id %>'?\")\n      full_confirm_message = _.template(confirm_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n      if window.confirm full_confirm_message\n        send_data =\n          unique_student_identifier: unique_student_identifier\n          problem_to_reset: problem_to_reset\n          delete_module: true\n        error_message = gettext(\"Error deleting student '<%= student_id %>'s state on problem '<%= problem_id %>'. Make sure that the problem and student identifiers are complete and correct.\")\n        full_error_message = _.template(error_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n        $.ajax\n          dataType: 'json'\n          url: @$btn_delete_state_single.data 'endpoint'\n          data: send_data\n          success: @clear_errors_then -> alert gettext('Module state successfully deleted.')\n          error: std_ajax_err => @$request_response_error_grade.text full_error_message\n      else\n        # Clear error messages if \"Cancel\" was chosen on confirmation alert\n        @clear_errors()\n\n    # start task to rescore problem for student\n    @$btn_rescore_problem_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        problem_to_reset: problem_to_reset\n      success_message = gettext(\"Started rescore problem task for problem '<%= problem_id %>' and student '<%= student_id %>'. Click the 'Show Background Task History for Student' button to see the status of the task.\")\n      full_success_message = _.template(success_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n      error_message = gettext(\"Error starting a task to rescore problem '<%= problem_id %>' for student '<%= student_id %>'. Make sure that the the problem and student identifiers are complete and correct.\")\n      full_error_message = _.template(error_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_rescore_problem_single.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then -> alert full_success_message\n        error: std_ajax_err => @$request_response_error_grade.text full_error_message\n\n    # list task history for student+problem\n    @$btn_task_history_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        problem_location_str: problem_to_reset\n      error_message = gettext(\"Error getting task history for problem '<%= problem_id %>' and student '<%= student_id %>'. Make sure that the problem and student identifiers are complete and correct.\")\n      full_error_message = _.template(error_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_task_history_single.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then (data) =>\n          create_task_list_table @$table_task_history_single, data.tasks\n        error: std_ajax_err => @$request_response_error_grade.text full_error_message\n\n   # reset entrance exam attempts for student\n    @$btn_reset_entrance_exam_attempts.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Please enter a student email address or username.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        delete_module: false\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_reset_entrance_exam_attempts.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then ->\n          success_message = gettext(\"Entrance exam attempts is being reset for student '{student_id}'.\")\n          full_success_message = interpolate_text(success_message, {student_id: unique_student_identifier})\n          alert full_success_message\n        error: std_ajax_err =>\n          error_message = gettext(\"Error resetting entrance exam attempts for student '{student_id}'. Make sure student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n   # start task to rescore entrance exam for student\n    @$btn_rescore_entrance_exam.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Please enter a student email address or username.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_rescore_entrance_exam.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then ->\n          success_message = gettext(\"Started entrance exam rescore task for student '{student_id}'. Click the 'Show Background Task History for Student' button to see the status of the task.\")\n          full_success_message = interpolate_text(success_message, {student_id: unique_student_identifier})\n          alert full_success_message\n        error: std_ajax_err =>\n          error_message = gettext(\"Error starting a task to rescore entrance exam for student '{student_id}'. Make sure that entrance exam has problems in it and student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n  # Mark a student to skip entrance exam\n    @$btn_skip_entrance_exam.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Enter a student's username or email address.\")\n      confirm_message = gettext(\"Do you want to allow this student ('{student_id}') to skip the entrance exam?\")\n      full_confirm_message = interpolate_text(confirm_message, {student_id: unique_student_identifier})\n      if window.confirm full_confirm_message\n        send_data =\n          unique_student_identifier: unique_student_identifier\n\n        $.ajax\n          dataType: 'json'\n          url: @$btn_skip_entrance_exam.data 'endpoint'\n          data: send_data\n          type: 'POST'\n          success: @clear_errors_then (data) ->\n            alert data.message\n          error: std_ajax_err =>\n            error_message = gettext(\"An error occurred. Make sure that the student's username or email address is correct and try again.\")\n            @$request_response_error_ee.text error_message\n\n   # delete student state for entrance exam\n    @$btn_delete_entrance_exam_state.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Please enter a student email address or username.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        delete_module: true\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_delete_entrance_exam_state.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then ->\n          success_message = gettext(\"Entrance exam state is being deleted for student '{student_id}'.\")\n          full_success_message = interpolate_text(success_message, {student_id: unique_student_identifier})\n          alert full_success_message\n        error: std_ajax_err =>\n          error_message = gettext(\"Error deleting entrance exam state for student '{student_id}'. Make sure student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n    # list entrance exam task history for student\n    @$btn_entrance_exam_task_history.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Enter a student's username or email address.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_entrance_exam_task_history.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then (data) =>\n          create_task_list_table @$table_entrance_exam_task_history, data.tasks\n        error: std_ajax_err =>\n          error_message = gettext(\"Error getting entrance exam task history for student '{student_id}'. Make sure student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n    # start task to reset attempts on problem for all students\n    @$btn_reset_attempts_all.click =>\n      problem_to_reset = @$field_problem_select_all.val()\n      if not problem_to_reset\n        return @$request_response_error_all.text gettext(\"Please enter a problem location.\")\n      confirm_message = gettext(\"Reset attempts for all students on problem '<%= problem_id %>'?\")\n      full_confirm_message = _.template(confirm_message)({problem_id: problem_to_reset})\n      if window.confirm full_confirm_message\n        send_data =\n          all_students: true\n          problem_to_reset: problem_to_reset\n        success_message = gettext(\"Successfully started task to reset attempts for problem '<%= problem_id %>'. Click the 'Show Background Task History for Problem' button to see the status of the task.\")\n        full_success_message = _.template(success_message)({problem_id: problem_to_reset})\n        error_message = gettext(\"Error starting a task to reset attempts for all students on problem '<%= problem_id %>'. Make sure that the problem identifier is complete and correct.\")\n        full_error_message = _.template(error_message)({problem_id: problem_to_reset})\n\n        $.ajax\n          dataType: 'json'\n          url: @$btn_reset_attempts_all.data 'endpoint'\n          data: send_data\n          success: @clear_errors_then -> alert full_success_message\n          error: std_ajax_err => @$request_response_error_all.text full_error_message\n      else\n        # Clear error messages if \"Cancel\" was chosen on confirmation alert\n        @clear_errors()\n\n    # start task to rescore problem for all students\n    @$btn_rescore_problem_all.click =>\n      problem_to_reset = @$field_problem_select_all.val()\n      if not problem_to_reset\n        return @$request_response_error_all.text gettext(\"Please enter a problem location.\")\n      confirm_message = gettext(\"Rescore problem '<%= problem_id %>' for all students?\")\n      full_confirm_message = _.template(confirm_message)({problem_id: problem_to_reset})\n      if window.confirm full_confirm_message\n        send_data =\n          all_students: true\n          problem_to_reset: problem_to_reset\n        success_message = gettext(\"Successfully started task to rescore problem '<%= problem_id %>' for all students. Click the 'Show Background Task History for Problem' button to see the status of the task.\")\n        full_success_message = _.template(success_message)({problem_id: problem_to_reset})\n        error_message = gettext(\"Error starting a task to rescore problem '<%= problem_id %>'. Make sure that the problem identifier is complete and correct.\")\n        full_error_message = _.template(error_message)({problem_id: problem_to_reset})\n\n        $.ajax\n          dataType: 'json'\n          url: @$btn_rescore_problem_all.data 'endpoint'\n          data: send_data\n          success: @clear_errors_then -> alert full_success_message\n          error: std_ajax_err => @$request_response_error_all.text full_error_message\n      else\n        # Clear error messages if \"Cancel\" was chosen on confirmation alert\n        @clear_errors()\n\n    # list task history for problem\n    @$btn_task_history_all.click =>\n      send_data =\n        problem_location_str: @$field_problem_select_all.val()\n\n      if not send_data.problem_location_str\n        return @$request_response_error_all.text gettext(\"Please enter a problem location.\")\n\n      $.ajax\n        dataType: 'json'\n        url: @$btn_task_history_all.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then (data) =>\n          create_task_list_table @$table_task_history_all, data.tasks\n        error: std_ajax_err => @$request_response_error_all.text gettext(\"Error listing task history for this student and problem.\")\n\n  # wraps a function, but first clear the error displays\n  clear_errors_then: (cb) ->\n    @$request_response_error_progress.empty()\n    @$request_response_error_grade.empty()\n    @$request_response_error_ee.empty()\n    @$request_response_error_all.empty()\n    ->\n      cb?.apply this, arguments\n\n\n  clear_errors: ->\n    @$request_response_error_progress.empty()\n    @$request_response_error_grade.empty()\n    @$request_response_error_ee.empty()\n    @$request_response_error_all.empty()\n\n  # handler for when the section title is clicked.\n  onClickTitle: -> @instructor_tasks.task_poller.start()\n\n  # handler for when the section is closed\n  onExit: -> @instructor_tasks.task_poller.stop()\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n  StudentAdmin: StudentAdmin\n", "# Common utilities for instructor dashboard components.\n\n# reverse arguments on common functions to enable\n# better coffeescript with callbacks at the end.\nplantTimeout = (ms, cb) -> setTimeout cb, ms\nplantInterval = (ms, cb) -> setInterval cb, ms\n\n\n# get jquery element and assert its existance\nfind_and_assert = ($root, selector) ->\n  item = $root.find selector\n  if item.length != 1\n    console.error \"element selection failed for '#{selector}' resulted in length #{item.length}\"\n    throw \"Failed Element Selection\"\n  else\n    item\n\n# standard ajax error wrapper\n#\n# wraps a `handler` function so that first\n# it prints basic error information to the console.\n@std_ajax_err = (handler) -> (jqXHR, textStatus, errorThrown) ->\n  console.warn \"\"\"ajax error\n                  textStatus: #{textStatus}\n                  errorThrown: #{errorThrown}\"\"\"\n  handler.apply this, arguments\n\n\n# render a task list table to the DOM\n# `$table_tasks` the $element in which to put the table\n# `tasks_data`\n@create_task_list_table = ($table_tasks, tasks_data) ->\n  $table_tasks.empty()\n\n  options =\n    enableCellNavigation: true\n    enableColumnReorder: false\n    autoHeight: true\n    rowHeight: 100\n    forceFitColumns: true\n\n  columns = [\n    id: 'task_type'\n    field: 'task_type'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task Type')\n    minWidth: 102\n  ,\n    id: 'task_input'\n    field: 'task_input'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task inputs')\n    minWidth: 150\n  ,\n    id: 'task_id'\n    field: 'task_id'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task ID')\n    minWidth: 150\n  ,\n    id: 'requester'\n    field: 'requester'\n    ###\n    Translators: a \"Requester\" is a username that requested a task such as sending email\n    ###\n    name: gettext('Requester')\n    minWidth: 80\n  ,\n    id: 'created'\n    field: 'created'\n    ###\n    Translators: A timestamp of when a task (eg, sending email) was submitted appears after this\n    ###\n    name: gettext('Submitted')\n    minWidth: 120\n  ,\n    id: 'duration_sec'\n    field: 'duration_sec'\n    ###\n    Translators: The length of a task (eg, sending email) in seconds appears this\n    ###\n    name: gettext('Duration (sec)')\n    minWidth: 80\n  ,\n    id: 'task_state'\n    field: 'task_state'\n    ###\n    Translators: The state (eg, \"In progress\") of a task (eg, sending email) appears after this.\n    ###\n    name: gettext('State')\n    minWidth: 80\n  ,\n    id: 'status'\n    field: 'status'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task Status')\n    minWidth: 80\n  ,\n    id: 'task_message'\n    field: 'task_message'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task Progress')\n    minWidth: 120\n  ]\n\n  table_data = tasks_data\n\n  $table_placeholder = $ '<div/>', class: 'slickgrid'\n  $table_tasks.append($table_placeholder)\n  grid = new Slick.Grid($table_placeholder, table_data, columns, options)\n\n# Formats the subject field for email content history table\nsubject_formatter = (row, cell, value, columnDef, dataContext) ->\n  if value is null then return gettext(\"An error occurred retrieving your email. Please try again later, and contact technical support if the problem persists.\")\n  subject_text = $('<span>').text(value['subject']).html()\n  return edx.HtmlUtils.joinHtml(\n    edx.HtmlUtils.HTML('<p><a href=\"#email_message_'),\n    value['id'],\n    edx.HtmlUtils.HTML('\" id=\"email_message_'),\n    value['id'],\n    edx.HtmlUtils.HTML('_trig\">'),\n    subject_text,\n    edx.HtmlUtils.HTML('</a></p>'),\n  )\n\np_wrapper = (value) ->\n  edx.HtmlUtils.joinHtml(\n    edx.HtmlUtils.HTML('<p>'),\n    value,\n    edx.HtmlUtils.HTML('</p>'),\n  )\n\nunknown_p = () ->\n  p_wrapper(gettext('Unknown'))\n\n# Since sent_to is a json array, it needs some extra attention\nsent_to_formatter = (row, cell, value, columnDef, dataContext) ->\n  if value is null\n    return unknown_p()\n  else\n    return p_wrapper(value.join(\", \"))\n\n# Formats the author, created, and number sent fields for the email content history table\nunknown_if_null_formatter = (row, cell, value, columnDef, dataContext) ->\n  if value is null\n    return unknown_p()\n  else\n    return p_wrapper(value)\n\n# Creates a table to display the content of bulk course emails\n# sent in the past\ncreate_email_content_table = ($table_emails, $table_emails_inner, email_data) ->\n    $table_emails_inner.empty()\n    $table_emails.show()\n\n    options =\n      enableCellNavigation: true\n      enableColumnReorder: false\n      autoHeight: true\n      rowHeight: 50\n      forceFitColumns: true\n\n    columns = [\n      id: 'email'\n      field: 'email'\n      name: gettext('Subject')\n      minWidth: 80\n      cssClass: \"email-content-cell\"\n      formatter: subject_formatter\n    ,\n      id: 'requester'\n      field: 'requester'\n      name: gettext('Sent By')\n      minWidth: 80\n      maxWidth: 100\n      cssClass: \"email-content-cell\"\n      formatter: unknown_if_null_formatter\n    ,\n      id: 'sent_to'\n      field: 'sent_to'\n      name: gettext('Sent To')\n      minWidth: 80\n      maxWidth: 100\n      cssClass: \"email-content-cell\"\n      formatter: sent_to_formatter\n    ,\n      id: 'created'\n      field: 'created'\n      name: gettext('Time Sent')\n      minWidth: 80\n      cssClass: \"email-content-cell\"\n      formatter: unknown_if_null_formatter\n    ,\n      id: 'number_sent'\n      field: 'number_sent'\n      name: gettext('Number Sent')\n      minwidth: 100\n      maxWidth: 150\n      cssClass: \"email-content-cell\"\n      formatter: unknown_if_null_formatter\n    ,\n    ]\n\n    table_data = email_data\n\n    $table_placeholder = $ '<div/>', class: 'slickgrid'\n    $table_emails_inner.append($table_placeholder)\n    grid = new Slick.Grid($table_placeholder, table_data, columns, options)\n    $table_emails.append($('<br/>'))\n\n# Creates the modal windows linked to each email in the email history\n# Displayed when instructor clicks an email's subject in the content history table\ncreate_email_message_views = ($messages_wrapper, emails) ->\n  $messages_wrapper.empty()\n  for email_info in emails\n\n    # If some error occured, bail out\n    if !email_info.email then return\n\n    # Create hidden section for modal window\n    email_id = email_info.email['id']\n    $message_content = $('<section>', \"aria-hidden\": \"true\", class: \"modal email-modal\", id: \"email_message_\" + email_id)\n    $email_wrapper = $ '<div>', class: 'inner-wrapper email-content-wrapper'\n    $email_header = $ '<div>', class: 'email-content-header'\n\n    # Add copy email body button\n    $email_header.append($('<input>', type: \"button\", name: \"copy-email-body-text\", value: gettext(\"Copy Email To Editor\"), id: \"copy_email_\" + email_id))\n\n    $close_button = $ '<a>', href: '#', class: \"close-modal\"\n    $close_button.append($('<i>', class: 'icon fa fa-times'))\n    $email_header.append($close_button)\n\n    # HTML escape things\n    interpolate_header = (title, value) ->\n      edx.HtmlUtils.setHtml(\n        $('<h2>', class: 'message-bold'),\n        edx.HtmlUtils.joinHtml(\n          edx.HtmlUtils.HTML('<em>'),\n          title\n          edx.HtmlUtils.HTML('</em>'),\n          value,\n        )\n      )\n    $subject = interpolate_header(gettext('Subject:'), email_info.email['subject'])\n    $requester = interpolate_header(gettext('Sent By:'), email_info.requester)\n    $created = interpolate_header(gettext('Time Sent:'), email_info.created)\n    $sent_to = interpolate_header(gettext('Sent To:'), email_info.sent_to.join(\", \"))\n    $email_header.append($subject)\n    $email_header.append($requester)\n    $email_header.append($created)\n    $email_header.append($sent_to)\n    $email_wrapper.append($email_header)\n\n    $email_wrapper.append($('<hr>'))\n\n    # Last, add email content section\n    $email_content = $ '<div>', class: 'email-content-message'\n    $email_content_header = edx.HtmlUtils.setHtml(\n      $('<h2>', class: \"message-bold\"),\n      edx.HtmlUtils.joinHtml(\n        edx.HtmlUtils.HTML('<em>'),\n        gettext(\"Message:\"),\n        edx.HtmlUtils.HTML('</em>'),\n      )\n    )\n    $email_content.append($email_content_header)\n    $message = edx.HtmlUtils.setHtml(\n      $('<div>'),\n      edx.HtmlUtils.HTML(email_info.email['html_message'])\n    )\n    $email_content.append($message)\n    $email_wrapper.append($email_content)\n\n    $message_content.append($email_wrapper)\n    $messages_wrapper.append($message_content)\n\n    # Setup buttons to open modal window and copy an email message\n    $('#email_message_' + email_info.email['id'] + '_trig').leanModal({closeButton: \".close-modal\", copyEmailButton: \"#copy_email_\" + email_id})\n    setup_copy_email_button(email_id, email_info.email['html_message'], email_info.email['subject'])\n\n# Helper method to set click handler for modal copy email button\nsetup_copy_email_button = (email_id, html_message, subject) ->\n    $(\"#copy_email_\" + email_id).click =>\n        editor = tinyMCE.get(\"mce_0\")\n        editor.setContent(html_message)\n        $('#id_subject').val(subject)\n\n\n# Helper class for managing the execution of interval tasks.\n# Handles pausing and restarting.\nclass IntervalManager\n  # Create a manager which will call `fn`\n  # after a call to .start every `ms` milliseconds.\n  constructor: (@ms, @fn) ->\n    @intervalID = null\n\n  # Start or restart firing every `ms` milliseconds.\n  start: ->\n    @fn()\n    if @intervalID is null\n      @intervalID = setInterval @fn, @ms\n\n  # Pause firing.\n  stop: ->\n    clearInterval @intervalID\n    @intervalID = null\n\n\nclass @PendingInstructorTasks\n  ### Pending Instructor Tasks Section ####\n  constructor: (@$section) ->\n    # Currently running tasks\n    @$running_tasks_section = find_and_assert @$section, \".running-tasks-section\"\n    @$table_running_tasks = find_and_assert @$section, \".running-tasks-table\"\n    @$no_tasks_message = find_and_assert @$section, \".no-pending-tasks-message\"\n\n    # start polling for task list\n    # if the list is in the DOM\n    if @$table_running_tasks.length\n      # reload every 20 seconds.\n      TASK_LIST_POLL_INTERVAL = 20000\n      @reload_running_tasks_list()\n      @task_poller = new IntervalManager(TASK_LIST_POLL_INTERVAL, => @reload_running_tasks_list())\n\n  # Populate the running tasks list\n  reload_running_tasks_list: =>\n    list_endpoint = @$table_running_tasks.data 'endpoint'\n    $.ajax\n      dataType: 'json'\n      url: list_endpoint\n      success: (data) =>\n        if data.tasks.length\n          create_task_list_table @$table_running_tasks, data.tasks\n          @$no_tasks_message.hide()\n          @$running_tasks_section.show()\n        else\n          console.log \"No pending tasks to display\"\n          @$running_tasks_section.hide()\n          @$no_tasks_message.empty()\n          @$no_tasks_message.append($('<p>').text(gettext(\"No tasks currently running.\")))\n          @$no_tasks_message.show()\n      error: std_ajax_err => console.error \"Error finding pending tasks to display\"\n    ### /Pending Instructor Tasks Section ####\n\nclass KeywordValidator\n\n    @keyword_regex = /%%+[^%]+%%/g\n    @keywords = ['%%USER_ID%%', '%%USER_FULLNAME%%', '%%COURSE_DISPLAY_NAME%%', '%%COURSE_END_DATE%%']\n\n    @validate_string: (string) =>\n      regex_match = string.match(@keyword_regex)\n      found_keywords = if regex_match == null then [] else regex_match\n      invalid_keywords = []\n      is_valid = true\n      keywords = @keywords\n\n      for found_keyword in found_keywords\n        do (found_keyword) ->\n          if found_keyword not in keywords\n            invalid_keywords.push found_keyword\n\n      if invalid_keywords.length != 0\n        is_valid = false\n\n      return {\n        is_valid: is_valid,\n        invalid_keywords: invalid_keywords\n      }\n\n\nclass ReportDownloads\n  ### Report Downloads -- links expire quickly, so we refresh every 5 mins ####\n  constructor: (@$section) ->\n\n    @$report_downloads_table = @$section.find \".report-downloads-table\"\n\n    POLL_INTERVAL = 20000 # 20 seconds, just like the \"pending instructor tasks\" table\n    @downloads_poller = new window.InstructorDashboard.util.IntervalManager(\n      POLL_INTERVAL, => @reload_report_downloads()\n    )\n\n  reload_report_downloads: ->\n    endpoint = @$report_downloads_table.data 'endpoint'\n    $.ajax\n      dataType: 'json'\n      url: endpoint\n      success: (data) =>\n        if data.downloads.length\n          @create_report_downloads_table data.downloads\n        else\n          console.log \"No reports ready for download\"\n      error: (std_ajax_err) => console.error \"Error finding report downloads\"\n\n  create_report_downloads_table: (report_downloads_data) ->\n    @$report_downloads_table.empty()\n\n    options =\n      enableCellNavigation: true\n      enableColumnReorder: false\n      rowHeight: 30\n      forceFitColumns: true\n\n    columns = [\n      id: 'link'\n      field: 'link'\n      name: gettext('File Name')\n      toolTip: gettext(\"Links are generated on demand and expire within 5 minutes due to the sensitive nature of student information.\")\n      sortable: false\n      minWidth: 150\n      cssClass: \"file-download-link\"\n      formatter: (row, cell, value, columnDef, dataContext) ->\n        edx.HtmlUtils.joinHtml(\n          edx.HtmlUtils.HTML('<a target=\"_blank\" href=\"'),\n          dataContext['url'],\n          edx.HtmlUtils.HTML('\">'),\n          dataContext['name'],\n          edx.HtmlUtils.HTML('</a>')\n        )\n    ]\n\n    $table_placeholder = $ '<div/>', class: 'slickgrid'\n    @$report_downloads_table.append($table_placeholder)\n    grid = new Slick.Grid($table_placeholder, report_downloads_data, columns, options)\n    grid.onClick.subscribe(\n        (event) =>\n            report_url = event.target.href\n            if report_url\n                # Record that the user requested to download a report\n                Logger.log('edx.instructor.report.downloaded', {\n                    report_url: report_url\n                })\n    )\n    grid.autosizeColumns()\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n# abort if underscore can not be found.\nif _?\n  _.defaults window, InstructorDashboard: {}\n  window.InstructorDashboard.util =\n    plantTimeout: plantTimeout\n    plantInterval: plantInterval\n    std_ajax_err: std_ajax_err\n    IntervalManager: IntervalManager\n    create_task_list_table: create_task_list_table\n    create_email_content_table: create_email_content_table\n    create_email_message_views: create_email_message_views\n    PendingInstructorTasks: PendingInstructorTasks\n    KeywordValidator: KeywordValidator\n    ReportDownloads: ReportDownloads\n", "var edx = edx || {};\n\n(function(Backbone, $, _, gettext) {\n    'use strict';\n\n    edx.instructor_dashboard = edx.instructor_dashboard || {};\n    edx.instructor_dashboard.ecommerce = {};\n\n    edx.instructor_dashboard.ecommerce.ExpiryCouponView = Backbone.View.extend({\n        el: 'li#add-coupon-modal-field-expiry',\n        events: {\n            'click input[type=\"checkbox\"]': 'clicked'\n        },\n        initialize: function() {\n            $('li#add-coupon-modal-field-expiry input[name=\"expiration_date\"]').hide();\n            _.bindAll(this, 'clicked');\n        },\n        clicked: function (event) {\n            if (event.currentTarget.checked) {\n                this.show(this.$('#coupon_expiration_date'));\n                this.$el.find('#coupon_expiration_date').focus();\n            }\n            else {\n                this.hide(this.$('#coupon_expiration_date'));\n            }\n        },\n        show: function ($el) {\n            $el.css('display', 'inline');\n        },\n        hide: function ($el) {\n            $el.css('display', 'none');\n        }\n    });\n\n    $(function() {\n        var $registration_code_status_form = $(\"form#set_regcode_status_form\"),\n            $lookup_button = $('#lookup_regcode', $registration_code_status_form),\n            $registration_code_status_form_error = $('#regcode_status_form_error', $registration_code_status_form),\n            $registration_code_status_form_success = $('#regcode_status_form_success', $registration_code_status_form);\n\n        $( \"#coupon_expiration_date\" ).datepicker({\n            minDate: 0\n        });\n        var view = new edx.instructor_dashboard.ecommerce.ExpiryCouponView();\n        $('input[name=\"user-enrollment-report\"]').click(function(){\n            var url = $(this).data('endpoint');\n            $.ajax({\n             dataType: \"json\",\n             url: url,\n             success: function (data) {\n                $('#enrollment-report-request-response').text(data['status']);\n                return $(\"#enrollment-report-request-response\").css({\n                  \"display\": \"block\"\n                });\n             },\n             error: function(std_ajax_err) {\n                $('#enrollment-report-request-response-error').text(gettext('There was a problem creating the report. Select \"Create Executive Summary\" to try again.'));\n                return $(\"#enrollment-report-request-response-error\").css({\n                  \"display\": \"block\"\n                });\n             }\n           });\n        });\n        $('input[name=\"exec-summary-report\"]').click(function(){\n            var url = $(this).data('endpoint');\n            $.ajax({\n             dataType: \"json\",\n             url: url,\n             success: function (data) {\n                $(\"#exec-summary-report-request-response\").text(data['status']);\n                return $(\"#exec-summary-report-request-response\").css({\n                  \"display\": \"block\"\n                });\n               },\n             error: function(std_ajax_err) {\n                $('#exec-summary-report-request-response-error').text(gettext('There was a problem creating the report. Select \"Create Executive Summary\" to try again.'));\n                return $(\"#exec-summary-report-request-response-error\").css({\n                  \"display\": \"block\"\n                });\n             }\n           });\n        });\n        $lookup_button.click(function () {\n            $registration_code_status_form_error.hide();\n            $lookup_button.attr('disabled', true);\n            var url = $(this).data('endpoint');\n            var lookup_registration_code = $('#set_regcode_status_form input[name=\"regcode_code\"]').val();\n            if (lookup_registration_code == '') {\n                $registration_code_status_form_error.show();\n                $registration_code_status_form_error.text(gettext('Enter the enrollment code.'));\n                $lookup_button.removeAttr('disabled');\n                return false;\n            }\n            $.ajax({\n                type: \"GET\",\n                data: {\n                    \"registration_code\"  : lookup_registration_code\n                },\n                url: url,\n                success: function (data) {\n                    var is_registration_code_valid = data.is_registration_code_valid,\n                    is_registration_code_redeemed = data.is_registration_code_redeemed,\n                    is_registration_code_exists = data.is_registration_code_exists;\n\n                    $lookup_button.removeAttr('disabled');\n                    if (is_registration_code_exists == 'false') {\n                        $registration_code_status_form_error.hide();\n                        $registration_code_status_form_error.show();\n                        $registration_code_status_form_error.text(gettext(data.message));\n                    }\n                    else {\n                        var actions_links = '';\n                        var actions = [];\n                        if (is_registration_code_valid == true) {\n                            actions.push(\n                                {\n                                    'action_url': data.registration_code_detail_url,\n                                    'action_name': gettext('Cancel enrollment code'),\n                                    'registration_code': lookup_registration_code,\n                                    'action_type': 'invalidate_registration_code'\n                                }\n                            );\n                        }\n                        else {\n                            actions.push(\n                                {\n                                    'action_url': data.registration_code_detail_url,\n                                    'action_name': gettext('Restore enrollment code'),\n                                    'registration_code': lookup_registration_code,\n                                    'action_type': 'validate_registration_code'\n                                }\n                            );\n                        }\n                        if (is_registration_code_redeemed == true) {\n                            actions.push(\n                                {\n                                    'action_url': data.registration_code_detail_url,\n                                    'action_name': gettext('Mark enrollment code as unused'),\n                                    'registration_code': lookup_registration_code,\n                                    'action_type': 'unredeem_registration_code'\n                                }\n                            );\n                        }\n                        is_registration_code_redeemed = is_registration_code_redeemed ? 'Yes' : 'No';\n                        is_registration_code_valid = is_registration_code_valid ? 'Yes' : 'No';\n                        // load the underscore template.\n                        var template_data = _.template($('#enrollment-code-lookup-links-tpl').text());\n                        var registration_code_lookup_actions = template_data(\n                            {\n                                lookup_registration_code: lookup_registration_code,\n                                is_registration_code_redeemed: is_registration_code_redeemed,\n                                is_registration_code_valid: is_registration_code_valid,\n                                actions: actions\n                            }\n                        );\n\n                        // before insertAfter do this.\n                        // remove the first element after the registration_code_status_form\n                        // so it doesn't duplicate the registration_code_lookup_actions in the UI.\n                        $registration_code_status_form.next().remove();\n                        $(registration_code_lookup_actions).insertAfter($registration_code_status_form);\n                    }\n                },\n                error: function(jqXHR, textStatus, errorThrown) {\n                    var data = $.parseJSON(jqXHR.responseText);\n                    $lookup_button.removeAttr('disabled');\n                    $registration_code_status_form_error.text(gettext(data.message));\n                    $registration_code_status_form_error.show();\n                }\n            });\n        });\n        $(\"section#invalidate_registration_code_modal\").on('click', 'a.registration_code_action_link', function(event) {\n            event.preventDefault();\n            $registration_code_status_form_error.attr('style', 'display: none');\n            $lookup_button.attr('disabled', true);\n            var url = $(this).data('endpoint');\n            var action_type = $(this).data('action-type');\n            var registration_code = $(this).data('registration-code');\n            $.ajax({\n                type: \"POST\",\n                data: {\n                    \"registration_code\": registration_code,\n                    \"action_type\": action_type\n                },\n                url: url,\n                success: function (data) {\n                    $('#set_regcode_status_form input[name=\"regcode_code\"]').val('');\n                    $registration_code_status_form.next().remove();\n                    $registration_code_status_form_error.hide();\n                    $lookup_button.removeAttr('disabled');\n                    $registration_code_status_form_success.text(gettext(data.message));\n                    $registration_code_status_form_success.show();\n                    $registration_code_status_form_success.fadeOut(3000);\n                },\n                error: function(jqXHR, textStatus, errorThrown) {\n                    var data = $.parseJSON(jqXHR.responseText);\n                    $registration_code_status_form_error.hide();\n                    $lookup_button.removeAttr('disabled');\n                    $registration_code_status_form_error.show();\n                    $registration_code_status_form_error.text(gettext(data.message));\n                }\n            });\n        });\n    });\n})(Backbone, $, _, gettext);\n", "define(['jquery', 'coffee/src/instructor_dashboard/student_admin', 'common/js/spec_helpers/ajax_helpers'],\n    function ($, StudentAdmin, AjaxHelpers) {\n        //'coffee/src/instructor_dashboard/student_admin'\n        'use strict';\n        describe(\"edx.instructor_dashboard.student_admin.StudentAdmin\", function() {\n            var studentadmin, dashboard_api_url, unique_student_identifier, alert_msg;\n\n            beforeEach(function() {\n                loadFixtures('js/fixtures/instructor_dashboard/student_admin.html');\n                window.InstructorDashboard = {};\n                window.InstructorDashboard.util = {\n                    std_ajax_err: std_ajax_err,\n                    PendingInstructorTasks: PendingInstructorTasks,\n                    create_task_list_table: create_task_list_table\n                };\n                studentadmin = new window.StudentAdmin($('#student_admin'));\n                dashboard_api_url = '/courses/PU/FSc/2014_T4/instructor/api';\n                unique_student_identifier = \"test@example.com\";\n                alert_msg = '';\n                spyOn(window, 'alert').and.callFake(function(message) {\n                    alert_msg = message;\n                });\n\n            });\n\n            it('initiates resetting of entrance exam when button is clicked', function() {\n                studentadmin.$btn_reset_entrance_exam_attempts.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Please enter a student email address or username.\"));\n\n                var success_message = gettext(\"Entrance exam attempts is being reset for student '{student_id}'.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_reset_entrance_exam_attempts.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: false\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when resetting of entrance exam fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_reset_entrance_exam_attempts.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: false\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error resetting entrance exam attempts for student '{student_id}'. Make sure student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n            it('initiates rescoring of the entrance exam when the button is clicked', function() {\n                studentadmin.$btn_rescore_entrance_exam.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Please enter a student email address or username.\"));\n\n                var success_message = gettext(\"Started entrance exam rescore task for student '{student_id}'.\" +\n                    \" Click the 'Show Background Task History for Student' button to see the status of the task.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_rescore_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/rescore_entrance_exam?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when entrance exam rescoring fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_rescore_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/rescore_entrance_exam?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error starting a task to rescore entrance exam for student '{student_id}'.\" +\n                    \" Make sure that entrance exam has problems in it and student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n            it('initiates skip entrance exam when button is clicked', function() {\n                studentadmin.$btn_skip_entrance_exam.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Enter a student's username or email address.\"));\n\n                var success_message = \"This student ('{student_id}') will skip the entrance exam.\";\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_skip_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var url = dashboard_api_url + '/mark_student_can_skip_entrance_exam';\n                AjaxHelpers.expectRequest(requests, 'POST', url, $.param({\n                    'unique_student_identifier': unique_student_identifier\n                }));\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when skip entrance exam fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_skip_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var url = dashboard_api_url + '/mark_student_can_skip_entrance_exam';\n                AjaxHelpers.expectRequest(requests, 'POST', url, $.param({\n                    'unique_student_identifier': unique_student_identifier\n                }));\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = \"An error occurred. Make sure that the student's username or email address is correct and try again.\";\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(error_message);\n            });\n\n            it('initiates delete student state for entrance exam when button is clicked', function() {\n                studentadmin.$btn_delete_entrance_exam_state.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Please enter a student email address or username.\"));\n\n                var success_message = gettext(\"Entrance exam state is being deleted for student '{student_id}'.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_delete_entrance_exam_state.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: true\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when delete student state for entrance exam fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_delete_entrance_exam_state.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: true\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error deleting entrance exam state for student '{student_id}'. \" +\n                    \"Make sure student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n            it('initiates listing of entrance exam task history when button is clicked', function() {\n                studentadmin.$btn_entrance_exam_task_history.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Enter a student's username or email address.\"));\n\n                var success_message = gettext(\"Entrance exam state is being deleted for student '{student_id}'.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_entrance_exam_task_history.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/list_entrance_exam_instructor_tasks?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    \"tasks\": [\n                        {\n                            \"status\": \"Incomplete\",\n                            \"task_type\": \"rescore_problem\",\n                            \"task_id\": \"9955d413-eac1-441f-978d-27c60dd1c946\",\n                            \"created\": \"2015-02-19T10:59:01+00:00\",\n                            \"task_input\": \"{\\\"entrance_exam_url\\\": \\\"i4x://PU/FSc/chapter/d2204197cce443c4a0d5c852d4e7f638\\\", \\\"student\\\": \\\"audit\\\"}\",\n                            \"duration_sec\": \"unknown\",\n                            \"task_message\": \"No status information available\",\n                            \"requester\": \"staff\",\n                            \"task_state\": \"QUEUING\"\n                        }\n                    ]\n                });\n                expect($('.entrance-exam-task-history-table')).toBeVisible();\n            });\n\n            it('shows an error when listing entrance exam task history fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_entrance_exam_task_history.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/list_entrance_exam_instructor_tasks?' + params;\n                AjaxHelpers.expectJsonRequest(requests, 'GET', url);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error getting entrance exam task history for student '{student_id}'. \" +\n                    \"Make sure student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n        });\n    });\n", "define([\n    'backbone', \n    'jquery', \n    'js/staff_debug_actions', \n    'common/js/spec_helpers/ajax_helpers'\n    ],\n    function (Backbone, $, tmp, AjaxHelpers) {\n        'use strict';\n        var StaffDebug = window.StaffDebug;\n\n        describe('StaffDebugActions', function () {\n            var location = 'i4x://edX/Open_DemoX/edx_demo_course/problem/test_loc';\n            var locationName = 'test_loc';\n            var fixture_id = 'sd_fu_' + locationName;\n            var fixture = $('<input>', { id: fixture_id, placeholder: \"userman\" });\n            var escapableLocationName = 'test\\.\\*\\+\\?\\^\\:\\$\\{\\}\\(\\)\\|\\]\\[loc';\n            var escapableFixture_id = 'sd_fu_' + escapableLocationName;\n            var escapableFixture = $('<input>', {id: escapableFixture_id, placeholder: \"userman\"});\n            var esclocationName = 'P2:problem_1';\n            var escapableId = 'result_' + esclocationName; \n            var escapableResultArea = $('<div>', {id: escapableId});\n\n            describe('get_url ', function () {\n                it('defines url to courseware ajax entry point', function () {\n                    spyOn(StaffDebug, \"get_current_url\")\n                      .and.returnValue(\"/courses/edX/Open_DemoX/edx_demo_course/courseware/stuff\");\n                    expect(StaffDebug.get_url('rescore_problem'))\n                      .toBe('/courses/edX/Open_DemoX/edx_demo_course/instructor/api/rescore_problem');\n                });\n            });\n\n            describe('sanitize_string', function () {\n                it('escapes escapable characters in a string', function () {\n                    expect(StaffDebug.sanitized_string('.*+?^:${}()|][')).toBe('\\\\.\\\\*\\\\+\\\\?\\\\^\\\\:\\\\$\\\\{\\\\}\\\\(\\\\)\\\\|\\\\]\\\\[');\n                });\n            });\n\n            describe('get_user', function () {\n\n                it('gets the placeholder username if input field is empty', function () {\n                    $('body').append(fixture);\n                    expect(StaffDebug.get_user(locationName)).toBe('userman');\n                    $('#' + fixture_id).remove();\n                });\n                it('gets a filled in name if there is one', function () {\n                    $('body').append(fixture);\n                    $('#' + fixture_id).val('notuserman');\n                    expect(StaffDebug.get_user(locationName)).toBe('notuserman');\n\n                    $('#' + fixture_id).val('');\n                    $('#' + fixture_id).remove();\n                });\n                it('gets the placeholder name if the id has escapable characters', function() {\n                    $('body').append(escapableFixture);\n                    expect(StaffDebug.get_user('test.*+?^:${}()|][loc')).toBe('userman');\n                    $(\"input[id^='sd_fu_']\").remove();\n                });\n            });\n            describe('do_idash_action success', function () {\n                it('adds a success message to the results element after using an action', function () {\n                    $('body').append(escapableResultArea);\n                    var requests = AjaxHelpers.requests(this);\n                    var action = {\n                        locationName: esclocationName,\n                        success_msg: 'Successfully reset the attempts for user userman',\n                    };\n                    StaffDebug.do_idash_action(action);\n                    AjaxHelpers.respondWithJson(requests, action);\n                    expect($('#idash_msg').text()).toBe('Successfully reset the attempts for user userman');\n                    $('#result_' + locationName).remove();\n                });\n            });\n            describe('do_idash_action error', function () {\n                it('adds a failure message to the results element after using an action', function () {\n                    $('body').append(escapableResultArea);\n                    var requests = AjaxHelpers.requests(this);\n                    var action = {\n                        locationName: esclocationName,\n                        error_msg: 'Failed to reset attempts.',\n                    };\n                    StaffDebug.do_idash_action(action);\n                    AjaxHelpers.respondWithError(requests);\n                    expect($('#idash_msg').text()).toBe('Failed to reset attempts. ');\n                    $('#result_' + locationName).remove();\n                });\n            });                    \n            describe('reset', function () {\n                it('makes an ajax call with the expected parameters', function () {\n                    $('body').append(fixture);\n\n                    spyOn($, 'ajax');\n                    StaffDebug.reset(locationName, location);\n\n                    expect($.ajax.calls.mostRecent().args[0].type).toEqual('GET');\n                    expect($.ajax.calls.mostRecent().args[0].data).toEqual({\n                        'problem_to_reset': location,\n                        'unique_student_identifier': 'userman',\n                        'delete_module': false\n                    });\n                    expect($.ajax.calls.mostRecent().args[0].url).toEqual(\n                        '/instructor/api/reset_student_attempts'\n                    );\n                    $('#' + fixture_id).remove();\n                });\n            });\n            describe('sdelete', function () {\n                it('makes an ajax call with the expected parameters', function () {\n                    $('body').append(fixture);\n\n                    spyOn($, 'ajax');\n                    StaffDebug.sdelete(locationName, location);\n\n                    expect($.ajax.calls.mostRecent().args[0].type).toEqual('GET');\n                    expect($.ajax.calls.mostRecent().args[0].data).toEqual({\n                        'problem_to_reset': location,\n                        'unique_student_identifier': 'userman',\n                        'delete_module': true\n                    });\n                    expect($.ajax.calls.mostRecent().args[0].url).toEqual(\n                        '/instructor/api/reset_student_attempts'\n                    );\n\n                    $('#' + fixture_id).remove();\n                });\n            });\n            describe('rescore', function () {\n                it('makes an ajax call with the expected parameters', function () {\n                    $('body').append(fixture);\n\n                    spyOn($, 'ajax');\n                    StaffDebug.rescore(locationName, location);\n\n                    expect($.ajax.calls.mostRecent().args[0].type).toEqual('GET');\n                    expect($.ajax.calls.mostRecent().args[0].data).toEqual({\n                        'problem_to_reset': location,\n                        'unique_student_identifier': 'userman',\n                        'delete_module': false\n                    });\n                    expect($.ajax.calls.mostRecent().args[0].url).toEqual(\n                        '/instructor/api/rescore_problem'\n                    );\n                    $('#' + fixture_id).remove();\n                });\n            });\n        });\n    });", "// Build StaffDebug object\nvar StaffDebug = (function (){\n\n  get_current_url = function() {\n    return window.location.pathname;\n  };\n\n  get_url = function(action){\n    var pathname = this.get_current_url();\n    var url = pathname.substr(0,pathname.indexOf('/courseware')) + '/instructor/api/' + action;\n    return url;\n  };\n\n  sanitized_string = function(string) {\n    return string.replace(/[.*+?^:${}()|[\\]\\\\]/g, \"\\\\$&\");\n  };\n\n  get_user = function(locname){\n    locname = sanitized_string(locname);\n    var uname = $('#sd_fu_' + locname).val();\n    if (uname===\"\"){\n        uname =  $('#sd_fu_' + locname).attr('placeholder');\n    }\n    return uname;\n  };\n\n  do_idash_action = function(action){\n    var pdata = {\n        'problem_to_reset': action.location,\n        'unique_student_identifier': get_user(action.locationName),\n        'delete_module': action.delete_module\n    };\n    $.ajax({\n        type: \"GET\",\n        url: get_url(action.method),\n        data: pdata,\n        success: function(data){\n            var text = _.template(action.success_msg, {interpolate: /\\{(.+?)\\}/g})(\n                {user: data.student}\n            );\n            var html = _.template('<p id=\"idash_msg\" class=\"success\">{text}</p>', {interpolate: /\\{(.+?)\\}/g})(\n                {text: text}\n            );\n            $(\"#result_\"+sanitized_string(action.locationName)).html(html);\n        },\n        error: function(request, status, error) {\n            var response_json;\n            try {\n                response_json = $.parseJSON(request.responseText);\n            } catch(e) {\n                response_json = { error: gettext('Unknown Error Occurred.') };\n            }\n            var text = _.template('{error_msg} {error}', {interpolate: /\\{(.+?)\\}/g})(\n                {\n                    error_msg: action.error_msg,\n                    error: response_json.error\n                }\n            );\n            var html = _.template('<p id=\"idash_msg\" class=\"error\">{text}</p>', {interpolate: /\\{(.+?)\\}/g})(\n                {text: text}\n            );\n            $(\"#result_\"+sanitized_string(action.locationName)).html(html);\n\n        },\n        dataType: 'json'\n    });\n  };\n\n  reset = function(locname, location){\n    this.do_idash_action({\n        locationName: locname,\n        location: location,\n        method: 'reset_student_attempts',\n        success_msg: gettext('Successfully reset the attempts for user {user}'),\n        error_msg: gettext('Failed to reset attempts.'),\n        delete_module: false\n    });\n  };\n\n  sdelete = function(locname, location){\n    this.do_idash_action({\n        locationName: locname,\n        location: location,\n        method: 'reset_student_attempts',\n        success_msg: gettext('Successfully deleted student state for user {user}'),\n        error_msg: gettext('Failed to delete student state.'),\n        delete_module: true\n    });\n  };\n\n  rescore = function(locname, location){\n    this.do_idash_action({\n        locationName: locname,\n        location: location,\n        method: 'rescore_problem',\n        success_msg: gettext('Successfully rescored problem for user {user}'),\n        error_msg: gettext('Failed to rescore problem.'),\n        delete_module: false\n    });\n  };\n\n  return {\n      reset: reset,\n      sdelete: sdelete,\n      rescore: rescore,\n      do_idash_action: do_idash_action,\n      get_current_url: get_current_url,\n      get_url: get_url,\n      get_user: get_user,\n      sanitized_string:sanitized_string\n  }; })();\n\n// Register click handlers\n$(document).ready(function() {\n\n    var $courseContent = $('.course-content');\n    $courseContent.on(\"click\", '.staff-debug-reset', function() {\n        StaffDebug.reset($(this).parent().data('location-name'), $(this).parent().data('location'));\n        return false;\n    });\n    $courseContent.on(\"click\", '.staff-debug-sdelete', function() {\n        StaffDebug.sdelete($(this).parent().data('location-name'), $(this).parent().data('location'));\n        return false;\n    });\n    $courseContent.on(\"click\", '.staff-debug-rescore', function() {\n        StaffDebug.rescore($(this).parent().data('location-name'), $(this).parent().data('location'));\n        return false;\n    });\n});\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\"\"\"\nUnit tests for instructor.api methods.\n\"\"\"\nimport datetime\nimport ddt\nimport functools\nimport random\nimport pytz\nimport io\nimport json\nimport shutil\nimport tempfile\nfrom urllib import quote\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.core import mail\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom django.core.urlresolvers import reverse as django_reverse\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import RequestFactory, TestCase\nfrom django.test.utils import override_settings\nfrom django.utils.timezone import utc\nfrom django.utils.translation import ugettext as _\n\nfrom mock import Mock, patch\nfrom nose.tools import raises\nfrom nose.plugins.attrib import attr\nfrom opaque_keys.edx.locations import SlashSeparatedCourseKey\nfrom opaque_keys.edx.locator import UsageKey\nfrom xmodule.modulestore import ModuleStoreEnum\n\nfrom bulk_email.models import BulkEmailFlag\nfrom course_modes.models import CourseMode\nfrom courseware.models import StudentModule\nfrom courseware.tests.factories import (\n    BetaTesterFactory, GlobalStaffFactory, InstructorFactory, StaffFactory, UserProfileFactory\n)\nfrom courseware.tests.helpers import LoginEnrollmentTestCase\nfrom django_comment_common.models import FORUM_ROLE_COMMUNITY_TA\nfrom django_comment_common.utils import seed_permissions_roles\nfrom microsite_configuration import microsite\nfrom shoppingcart.models import (\n    RegistrationCodeRedemption, Order, CouponRedemption,\n    PaidCourseRegistration, Coupon, Invoice, CourseRegistrationCode, CourseRegistrationCodeInvoiceItem,\n    InvoiceTransaction)\nfrom shoppingcart.pdf import PDFInvoice\nfrom student.models import (\n    CourseEnrollment, CourseEnrollmentAllowed, NonExistentCourseError,\n    ManualEnrollmentAudit, UNENROLLED_TO_ENROLLED, ENROLLED_TO_UNENROLLED,\n    ALLOWEDTOENROLL_TO_UNENROLLED, ENROLLED_TO_ENROLLED, UNENROLLED_TO_ALLOWEDTOENROLL,\n    UNENROLLED_TO_UNENROLLED, ALLOWEDTOENROLL_TO_ENROLLED\n)\nfrom student.tests.factories import UserFactory, CourseModeFactory, AdminFactory\nfrom student.roles import CourseBetaTesterRole, CourseSalesAdminRole, CourseFinanceAdminRole, CourseInstructorRole\nfrom xmodule.modulestore.tests.django_utils import SharedModuleStoreTestCase, ModuleStoreTestCase\nfrom xmodule.modulestore.tests.factories import CourseFactory, ItemFactory\nfrom xmodule.fields import Date\n\nfrom courseware.models import StudentFieldOverride\n\nimport instructor_task.api\nimport instructor.views.api\nfrom instructor.views.api import require_finance_admin\nfrom instructor.tests.utils import FakeContentTask, FakeEmail, FakeEmailInfo\nfrom instructor.views.api import _split_input_list, common_exceptions_400, generate_unique_password\nfrom instructor_task.api_helper import AlreadyRunningError\nfrom certificates.tests.factories import GeneratedCertificateFactory\nfrom certificates.models import CertificateStatuses\n\nfrom openedx.core.djangoapps.course_groups.cohorts import set_course_cohort_settings\nfrom openedx.core.lib.xblock_utils import grade_histogram\n\nfrom .test_tools import msk_from_problem_urlname\n\nDATE_FIELD = Date()\nEXPECTED_CSV_HEADER = (\n    '\"code\",\"redeem_code_url\",\"course_id\",\"company_name\",\"created_by\",\"redeemed_by\",\"invoice_id\",\"purchaser\",'\n    '\"customer_reference_number\",\"internal_reference\"'\n)\nEXPECTED_COUPON_CSV_HEADER = '\"Coupon Code\",\"Course Id\",\"% Discount\",\"Description\",\"Expiration Date\",' \\\n                             '\"Is Active\",\"Code Redeemed Count\",\"Total Discounted Seats\",\"Total Discounted Amount\"'\n\n# ddt data for test cases involving reports\nREPORTS_DATA = (\n    {\n        'report_type': 'grade',\n        'instructor_api_endpoint': 'calculate_grades_csv',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_grades_csv',\n        'extra_instructor_api_kwargs': {}\n    },\n    {\n        'report_type': 'enrolled learner profile',\n        'instructor_api_endpoint': 'get_students_features',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_students_features_csv',\n        'extra_instructor_api_kwargs': {'csv': '/csv'}\n    },\n    {\n        'report_type': 'detailed enrollment',\n        'instructor_api_endpoint': 'get_enrollment_report',\n        'task_api_endpoint': 'instructor_task.api.submit_detailed_enrollment_features_csv',\n        'extra_instructor_api_kwargs': {}\n    },\n    {\n        'report_type': 'enrollment',\n        'instructor_api_endpoint': 'get_students_who_may_enroll',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_may_enroll_csv',\n        'extra_instructor_api_kwargs': {},\n    },\n    {\n        'report_type': 'proctored exam results',\n        'instructor_api_endpoint': 'get_proctored_exam_results',\n        'task_api_endpoint': 'instructor_task.api.submit_proctored_exam_results_report',\n        'extra_instructor_api_kwargs': {},\n    },\n    {\n        'report_type': 'problem responses',\n        'instructor_api_endpoint': 'get_problem_responses',\n        'task_api_endpoint': 'instructor_task.api.submit_calculate_problem_responses_csv',\n        'extra_instructor_api_kwargs': {},\n    }\n)\n\n# ddt data for test cases involving executive summary report\nEXECUTIVE_SUMMARY_DATA = (\n    {\n        'report_type': 'executive summary',\n        'instructor_api_endpoint': 'get_exec_summary_report',\n        'task_api_endpoint': 'instructor_task.api.submit_executive_summary_report',\n        'extra_instructor_api_kwargs': {}\n    },\n)\n\n\nINSTRUCTOR_GET_ENDPOINTS = set([\n    'get_anon_ids',\n    'get_coupon_codes',\n    'get_issued_certificates',\n    'get_sale_order_records',\n    'get_sale_records',\n])\nINSTRUCTOR_POST_ENDPOINTS = set([\n    'active_registration_codes',\n    'add_users_to_cohorts',\n    'bulk_beta_modify_access',\n    'calculate_grades_csv',\n    'change_due_date',\n    'export_ora2_data',\n    'generate_registration_codes',\n    'get_enrollment_report',\n    'get_exec_summary_report',\n    'get_grading_config',\n    'get_problem_responses',\n    'get_proctored_exam_results',\n    'get_registration_codes',\n    'get_student_progress_url',\n    'get_students_features',\n    'get_students_who_may_enroll',\n    'get_user_invoice_preference',\n    'list_background_email_tasks',\n    'list_course_role_members',\n    'list_email_content',\n    'list_entrance_exam_instructor_tasks',\n    'list_financial_report_downloads',\n    'list_forum_members',\n    'list_instructor_tasks',\n    'list_report_downloads',\n    'mark_student_can_skip_entrance_exam',\n    'modify_access',\n    'register_and_enroll_students',\n    'rescore_entrance_exam',\n    'rescore_problem',\n    'reset_due_date',\n    'reset_student_attempts',\n    'reset_student_attempts_for_entrance_exam',\n    'sale_validation',\n    'show_student_extensions',\n    'show_unit_extensions',\n    'send_email',\n    'spent_registration_codes',\n    'students_update_enrollment',\n    'update_forum_role_membership',\n])\n\n\ndef reverse(endpoint, args=None, kwargs=None, is_dashboard_endpoint=True):\n    \"\"\"\n    Simple wrapper of Django's reverse that first ensures that we have declared\n    each endpoint under test.\n\n    Arguments:\n        args: The args to be passed through to reverse.\n        endpoint: The endpoint to be passed through to reverse.\n        kwargs: The kwargs to be passed through to reverse.\n        is_dashboard_endpoint: True if this is an instructor dashboard endpoint\n            that must be declared in the INSTRUCTOR_GET_ENDPOINTS or\n            INSTRUCTOR_GET_ENDPOINTS sets, or false otherwise.\n\n    Returns:\n        The return of Django's reverse function\n\n    \"\"\"\n    is_endpoint_declared = endpoint in INSTRUCTOR_GET_ENDPOINTS or endpoint in INSTRUCTOR_POST_ENDPOINTS\n    if is_dashboard_endpoint and is_endpoint_declared is False:\n        # Verify that all endpoints are declared so we can ensure they are\n        # properly validated elsewhere.\n        raise ValueError(\"The endpoint {} must be declared in ENDPOINTS before use.\".format(endpoint))\n    return django_reverse(endpoint, args=args, kwargs=kwargs)\n\n\n@common_exceptions_400\ndef view_success(request):  # pylint: disable=unused-argument\n    \"A dummy view for testing that returns a simple HTTP response\"\n    return HttpResponse('success')\n\n\n@common_exceptions_400\ndef view_user_doesnotexist(request):  # pylint: disable=unused-argument\n    \"A dummy view that raises a User.DoesNotExist exception\"\n    raise User.DoesNotExist()\n\n\n@common_exceptions_400\ndef view_alreadyrunningerror(request):  # pylint: disable=unused-argument\n    \"A dummy view that raises an AlreadyRunningError exception\"\n    raise AlreadyRunningError()\n\n\n@attr('shard_1')\nclass TestCommonExceptions400(TestCase):\n    \"\"\"\n    Testing the common_exceptions_400 decorator.\n    \"\"\"\n\n    def setUp(self):\n        super(TestCommonExceptions400, self).setUp()\n        self.request = Mock(spec=HttpRequest)\n        self.request.META = {}\n\n    def test_happy_path(self):\n        resp = view_success(self.request)\n        self.assertEqual(resp.status_code, 200)\n\n    def test_user_doesnotexist(self):\n        self.request.is_ajax.return_value = False\n        resp = view_user_doesnotexist(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        self.assertIn(\"User does not exist\", resp.content)\n\n    def test_user_doesnotexist_ajax(self):\n        self.request.is_ajax.return_value = True\n        resp = view_user_doesnotexist(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        result = json.loads(resp.content)\n        self.assertIn(\"User does not exist\", result[\"error\"])\n\n    def test_alreadyrunningerror(self):\n        self.request.is_ajax.return_value = False\n        resp = view_alreadyrunningerror(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        self.assertIn(\"Task is already running\", resp.content)\n\n    def test_alreadyrunningerror_ajax(self):\n        self.request.is_ajax.return_value = True\n        resp = view_alreadyrunningerror(self.request)  # pylint: disable=assignment-from-no-return\n        self.assertEqual(resp.status_code, 400)\n        result = json.loads(resp.content)\n        self.assertIn(\"Task is already running\", result[\"error\"])\n\n\n@attr('shard_1')\n@ddt.ddt\nclass TestEndpointHttpMethods(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Ensure that users can make GET requests against endpoints that allow GET,\n    and not against those that don't allow GET.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"\n        Set up test course.\n        \"\"\"\n        super(TestEndpointHttpMethods, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        \"\"\"\n        Set up global staff role so authorization will not fail.\n        \"\"\"\n        super(TestEndpointHttpMethods, self).setUp()\n        global_user = GlobalStaffFactory()\n        self.client.login(username=global_user.username, password='test')\n\n    @ddt.data(*INSTRUCTOR_POST_ENDPOINTS)\n    def test_endpoints_reject_get(self, data):\n        \"\"\"\n        Tests that POST endpoints are rejected with 405 when using GET.\n        \"\"\"\n        url = reverse(data, kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url)\n\n        self.assertEqual(\n            response.status_code, 405,\n            \"Endpoint {} returned status code {} instead of a 405. It should not allow GET.\".format(\n                data, response.status_code\n            )\n        )\n\n    @ddt.data(*INSTRUCTOR_GET_ENDPOINTS)\n    def test_endpoints_accept_get(self, data):\n        \"\"\"\n        Tests that GET endpoints are not rejected with 405 when using GET.\n        \"\"\"\n        url = reverse(data, kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.get(url)\n\n        self.assertNotEqual(\n            response.status_code, 405,\n            \"Endpoint {} returned status code 405 where it shouldn't, since it should allow GET.\".format(\n                data\n            )\n        )\n\n\n@attr('shard_1')\n@patch('bulk_email.models.html_to_text', Mock(return_value='Mocking CourseEmail.text_message', autospec=True))\nclass TestInstructorAPIDenyLevels(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Ensure that users cannot access endpoints they shouldn't be able to.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIDenyLevels, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.problem_location = msk_from_problem_urlname(\n            cls.course.id,\n            'robot-some-problem-urlname'\n        )\n        cls.problem_urlname = cls.problem_location.to_deprecated_string()\n        BulkEmailFlag.objects.create(enabled=True, require_course_email_auth=False)\n\n    @classmethod\n    def tearDownClass(cls):\n        super(TestInstructorAPIDenyLevels, cls).tearDownClass()\n        BulkEmailFlag.objects.all().delete()\n\n    def setUp(self):\n        super(TestInstructorAPIDenyLevels, self).setUp()\n        self.user = UserFactory.create()\n        CourseEnrollment.enroll(self.user, self.course.id)\n\n        _module = StudentModule.objects.create(\n            student=self.user,\n            course_id=self.course.id,\n            module_state_key=self.problem_location,\n            state=json.dumps({'attempts': 10}),\n        )\n\n        # Endpoints that only Staff or Instructors can access\n        self.staff_level_endpoints = [\n            ('students_update_enrollment',\n             {'identifiers': 'foo@example.org', 'action': 'enroll'}),\n            ('get_grading_config', {}),\n            ('get_students_features', {}),\n            ('get_student_progress_url', {'unique_student_identifier': self.user.username}),\n            ('reset_student_attempts',\n             {'problem_to_reset': self.problem_urlname, 'unique_student_identifier': self.user.email}),\n            ('update_forum_role_membership',\n             {'unique_student_identifier': self.user.email, 'rolename': 'Moderator', 'action': 'allow'}),\n            ('list_forum_members', {'rolename': FORUM_ROLE_COMMUNITY_TA}),\n            ('send_email', {'send_to': '[\"staff\"]', 'subject': 'test', 'message': 'asdf'}),\n            ('list_instructor_tasks', {}),\n            ('list_background_email_tasks', {}),\n            ('list_report_downloads', {}),\n            ('list_financial_report_downloads', {}),\n            ('calculate_grades_csv', {}),\n            ('get_students_features', {}),\n            ('get_enrollment_report', {}),\n            ('get_students_who_may_enroll', {}),\n            ('get_exec_summary_report', {}),\n            ('get_proctored_exam_results', {}),\n            ('get_problem_responses', {}),\n            ('export_ora2_data', {}),\n        ]\n        # Endpoints that only Instructors can access\n        self.instructor_level_endpoints = [\n            ('bulk_beta_modify_access', {'identifiers': 'foo@example.org', 'action': 'add'}),\n            ('modify_access', {'unique_student_identifier': self.user.email, 'rolename': 'beta', 'action': 'allow'}),\n            ('list_course_role_members', {'rolename': 'beta'}),\n            ('rescore_problem',\n             {'problem_to_reset': self.problem_urlname, 'unique_student_identifier': self.user.email}),\n        ]\n\n    def _access_endpoint(self, endpoint, args, status_code, msg):\n        \"\"\"\n        Asserts that accessing the given `endpoint` gets a response of `status_code`.\n\n        endpoint: string, endpoint for instructor dash API\n        args: dict, kwargs for `reverse` call\n        status_code: expected HTTP status code response\n        msg: message to display if assertion fails.\n        \"\"\"\n        url = reverse(endpoint, kwargs={'course_id': self.course.id.to_deprecated_string()})\n        if endpoint in INSTRUCTOR_GET_ENDPOINTS:\n            response = self.client.get(url, args)\n        else:\n            response = self.client.post(url, args)\n        self.assertEqual(\n            response.status_code,\n            status_code,\n            msg=msg\n        )\n\n    def test_student_level(self):\n        \"\"\"\n        Ensure that an enrolled student can't access staff or instructor endpoints.\n        \"\"\"\n        self.client.login(username=self.user.username, password='test')\n\n        for endpoint, args in self.staff_level_endpoints:\n            self._access_endpoint(\n                endpoint,\n                args,\n                403,\n                \"Student should not be allowed to access endpoint \" + endpoint\n            )\n\n        for endpoint, args in self.instructor_level_endpoints:\n            self._access_endpoint(\n                endpoint,\n                args,\n                403,\n                \"Student should not be allowed to access endpoint \" + endpoint\n            )\n\n    def _access_problem_responses_endpoint(self, msg):\n        \"\"\"\n        Access endpoint for problem responses report, ensuring that\n        UsageKey.from_string returns a problem key that the endpoint\n        can work with.\n\n        msg: message to display if assertion fails.\n        \"\"\"\n        mock_problem_key = Mock(return_value=u'')\n        mock_problem_key.course_key = self.course.id\n        with patch.object(UsageKey, 'from_string') as patched_method:\n            patched_method.return_value = mock_problem_key\n            self._access_endpoint('get_problem_responses', {}, 200, msg)\n\n    def test_staff_level(self):\n        \"\"\"\n        Ensure that a staff member can't access instructor endpoints.\n        \"\"\"\n        staff_member = StaffFactory(course_key=self.course.id)\n        CourseEnrollment.enroll(staff_member, self.course.id)\n        CourseFinanceAdminRole(self.course.id).add_users(staff_member)\n        self.client.login(username=staff_member.username, password='test')\n        # Try to promote to forums admin - not working\n        # update_forum_role(self.course.id, staff_member, FORUM_ROLE_ADMINISTRATOR, 'allow')\n\n        for endpoint, args in self.staff_level_endpoints:\n            expected_status = 200\n\n            # TODO: make these work\n            if endpoint in ['update_forum_role_membership', 'list_forum_members']:\n                continue\n            elif endpoint == 'get_problem_responses':\n                self._access_problem_responses_endpoint(\n                    \"Staff member should be allowed to access endpoint \" + endpoint\n                )\n                continue\n            self._access_endpoint(\n                endpoint,\n                args,\n                expected_status,\n                \"Staff member should be allowed to access endpoint \" + endpoint\n            )\n\n        for endpoint, args in self.instructor_level_endpoints:\n            self._access_endpoint(\n                endpoint,\n                args,\n                403,\n                \"Staff member should not be allowed to access endpoint \" + endpoint\n            )\n\n    def test_instructor_level(self):\n        \"\"\"\n        Ensure that an instructor member can access all endpoints.\n        \"\"\"\n        inst = InstructorFactory(course_key=self.course.id)\n        CourseEnrollment.enroll(inst, self.course.id)\n\n        CourseFinanceAdminRole(self.course.id).add_users(inst)\n        self.client.login(username=inst.username, password='test')\n\n        for endpoint, args in self.staff_level_endpoints:\n            expected_status = 200\n\n            # TODO: make these work\n            if endpoint in ['update_forum_role_membership']:\n                continue\n            elif endpoint == 'get_problem_responses':\n                self._access_problem_responses_endpoint(\n                    \"Instructor should be allowed to access endpoint \" + endpoint\n                )\n                continue\n            self._access_endpoint(\n                endpoint,\n                args,\n                expected_status,\n                \"Instructor should be allowed to access endpoint \" + endpoint\n            )\n\n        for endpoint, args in self.instructor_level_endpoints:\n            expected_status = 200\n\n            # TODO: make this work\n            if endpoint in ['rescore_problem']:\n                continue\n            self._access_endpoint(\n                endpoint,\n                args,\n                expected_status,\n                \"Instructor should be allowed to access endpoint \" + endpoint\n            )\n\n\n@attr('shard_1')\n@patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\nclass TestInstructorAPIBulkAccountCreationAndEnrollment(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test Bulk account creation and enrollment from csv file\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIBulkAccountCreationAndEnrollment, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n        # Create a course with mode 'audit'\n        cls.audit_course = CourseFactory.create()\n        CourseModeFactory.create(course_id=cls.audit_course.id, mode_slug=CourseMode.AUDIT)\n\n        cls.url = reverse(\n            'register_and_enroll_students', kwargs={'course_id': unicode(cls.course.id)}\n        )\n        cls.audit_course_url = reverse(\n            'register_and_enroll_students', kwargs={'course_id': unicode(cls.audit_course.id)}\n        )\n\n    def setUp(self):\n        super(TestInstructorAPIBulkAccountCreationAndEnrollment, self).setUp()\n\n        # Create a course with mode 'honor' and with price\n        self.white_label_course = CourseFactory.create()\n        self.white_label_course_mode = CourseModeFactory.create(\n            course_id=self.white_label_course.id,\n            mode_slug=CourseMode.HONOR,\n            min_price=10,\n            suggested_prices='10',\n        )\n\n        self.white_label_course_url = reverse(\n            'register_and_enroll_students', kwargs={'course_id': unicode(self.white_label_course.id)}\n        )\n\n        self.request = RequestFactory().request()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.audit_course_instructor = InstructorFactory(course_key=self.audit_course.id)\n        self.white_label_course_instructor = InstructorFactory(course_key=self.white_label_course.id)\n\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.not_enrolled_student = UserFactory(\n            username='NotEnrolledStudent',\n            email='nonenrolled@test.com',\n            first_name='NotEnrolled',\n            last_name='Student'\n        )\n\n    @patch('instructor.views.api.log.info')\n    def test_account_creation_and_enrollment_with_csv(self, info_log):\n        \"\"\"\n        Happy path test to create a single new user\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1,tester1,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # test the log for email that's send to new created user.\n        info_log.assert_called_with('email sent to new created user at %s', 'test_student@example.com')\n\n    @patch('instructor.views.api.log.info')\n    def test_account_creation_and_enrollment_with_csv_with_blank_lines(self, info_log):\n        \"\"\"\n        Happy path test to create a single new user\n        \"\"\"\n        csv_content = \"\\ntest_student@example.com,test_student_1,tester1,USA\\n\\n\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # test the log for email that's send to new created user.\n        info_log.assert_called_with('email sent to new created user at %s', 'test_student@example.com')\n\n    @patch('instructor.views.api.log.info')\n    def test_email_and_username_already_exist(self, info_log):\n        \"\"\"\n        If the email address and username already exists\n        and the user is enrolled in the course, do nothing (including no email gets sent out)\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student@example.com,test_student_1,tester2,US\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # test the log for email that's send to new created user.\n        info_log.assert_called_with(\n            u\"user already exists with username '%s' and email '%s'\",\n            'test_student_1',\n            'test_student@example.com'\n        )\n\n    def test_file_upload_type_not_csv(self):\n        \"\"\"\n        Try uploading some non-CSV file and verify that it is rejected\n        \"\"\"\n        uploaded_file = SimpleUploadedFile(\"temp.jpg\", io.BytesIO(b\"some initial binary data: \\x00\\x01\").read())\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['general_errors'][0]['response'], 'Make sure that the file you upload is in CSV format with no extraneous characters or rows.')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_bad_file_upload_type(self):\n        \"\"\"\n        Try uploading some non-CSV file and verify that it is rejected\n        \"\"\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", io.BytesIO(b\"some initial binary data: \\x00\\x01\").read())\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['general_errors'][0]['response'], 'Could not read uploaded file.')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_insufficient_data(self):\n        \"\"\"\n        Try uploading a CSV file which does not have the exact four columns of data\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1\\n\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 1)\n        self.assertEquals(data['general_errors'][0]['response'], 'Data in row #1 must have exactly four columns: email, username, full name, and country')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_invalid_email_in_csv(self):\n        \"\"\"\n        Test failure case of a poorly formatted email field\n        \"\"\"\n        csv_content = \"test_student.example.com,test_student_1,tester1,USA\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        data = json.loads(response.content)\n        self.assertEqual(response.status_code, 200)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'Invalid email {0}.'.format('test_student.example.com'))\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    @patch('instructor.views.api.log.info')\n    def test_csv_user_exist_and_not_enrolled(self, info_log):\n        \"\"\"\n        If the email address and username already exists\n        and the user is not enrolled in the course, enrolled him/her and iterate to next one.\n        \"\"\"\n        csv_content = \"nonenrolled@test.com,NotEnrolledStudent,tester1,USA\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        info_log.assert_called_with(\n            u'user %s enrolled in the course %s',\n            u'NotEnrolledStudent',\n            self.course.id\n        )\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertTrue(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n    def test_user_with_already_existing_email_in_csv(self):\n        \"\"\"\n        If the email address already exists, but the username is different,\n        assume it is the correct user and just register the user in the course.\n        \"\"\"\n        csv_content = \"test_student@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student@example.com,test_student_2,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        warning_message = 'An account with email {email} exists but the provided username {username} ' \\\n                          'is different. Enrolling anyway with {email}.'.format(email='test_student@example.com', username='test_student_2')\n        self.assertNotEquals(len(data['warnings']), 0)\n        self.assertEquals(data['warnings'][0]['response'], warning_message)\n        user = User.objects.get(email='test_student@example.com')\n        self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertTrue(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n    def test_user_with_already_existing_username_in_csv(self):\n        \"\"\"\n        If the username already exists (but not the email),\n        assume it is a different user and fail to create the new account.\n        \"\"\"\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student2@example.com,test_student_1,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'Username {user} already exists.'.format(user='test_student_1'))\n\n    def test_csv_file_not_attached(self):\n        \"\"\"\n        Test when the user does not attach a file\n        \"\"\"\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student2@example.com,test_student_1,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n\n        response = self.client.post(self.url, {'file_not_found': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['general_errors']), 0)\n        self.assertEquals(data['general_errors'][0]['response'], 'File is not attached.')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_raising_exception_in_auto_registration_and_enrollment_case(self):\n        \"\"\"\n        Test that exceptions are handled well\n        \"\"\"\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student2@example.com,test_student_1,tester2,US\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        with patch('instructor.views.api.create_manual_course_enrollment') as mock:\n            mock.side_effect = NonExistentCourseError()\n            response = self.client.post(self.url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'NonExistentCourseError')\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    def test_generate_unique_password(self):\n        \"\"\"\n        generate_unique_password should generate a unique password string that excludes certain characters.\n        \"\"\"\n        password = generate_unique_password([], 12)\n        self.assertEquals(len(password), 12)\n        for letter in password:\n            self.assertNotIn(letter, 'aAeEiIoOuU1l')\n\n    def test_users_created_and_enrolled_successfully_if_others_fail(self):\n\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\\n\" \\\n                      \"test_student3@example.com,test_student_1,tester3,CA\\n\" \\\n                      \"test_student2@example.com,test_student_2,tester2,USA\"\n\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertNotEquals(len(data['row_errors']), 0)\n        self.assertEquals(data['row_errors'][0]['response'], 'Username {user} already exists.'.format(user='test_student_1'))\n        self.assertTrue(User.objects.filter(username='test_student_1', email='test_student1@example.com').exists())\n        self.assertTrue(User.objects.filter(username='test_student_2', email='test_student2@example.com').exists())\n        self.assertFalse(User.objects.filter(email='test_student3@example.com').exists())\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 2)\n\n    @patch.object(instructor.views.api, 'generate_random_string',\n                  Mock(side_effect=['first', 'first', 'second']))\n    def test_generate_unique_password_no_reuse(self):\n        \"\"\"\n        generate_unique_password should generate a unique password string that hasn't been generated before.\n        \"\"\"\n        generated_password = ['first']\n        password = generate_unique_password(generated_password, 12)\n        self.assertNotEquals(password, 'first')\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': False})\n    def test_allow_automated_signups_flag_not_set(self):\n        csv_content = \"test_student1@example.com,test_student_1,tester1,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.url, {'students_list': uploaded_file})\n        self.assertEquals(response.status_code, 403)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\n    def test_audit_enrollment_mode(self):\n        \"\"\"\n        Test that enrollment mode for audit courses (paid courses) is 'audit'.\n        \"\"\"\n        # Login Audit Course instructor\n        self.client.login(username=self.audit_course_instructor.username, password='test')\n\n        csv_content = \"test_student_wl@example.com,test_student_wl,Test Student,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.audit_course_url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # Verify enrollment modes to be 'audit'\n        for enrollment in manual_enrollments:\n            self.assertEqual(enrollment.enrollment.mode, CourseMode.AUDIT)\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\n    def test_honor_enrollment_mode(self):\n        \"\"\"\n        Test that enrollment mode for unpaid honor courses is 'honor'.\n        \"\"\"\n        # Remove white label course price\n        self.white_label_course_mode.min_price = 0\n        self.white_label_course_mode.suggested_prices = ''\n        self.white_label_course_mode.save()  # pylint: disable=no-member\n\n        # Login Audit Course instructor\n        self.client.login(username=self.white_label_course_instructor.username, password='test')\n\n        csv_content = \"test_student_wl@example.com,test_student_wl,Test Student,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.white_label_course_url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # Verify enrollment modes to be 'honor'\n        for enrollment in manual_enrollments:\n            self.assertEqual(enrollment.enrollment.mode, CourseMode.HONOR)\n\n    @patch.dict(settings.FEATURES, {'ALLOW_AUTOMATED_SIGNUPS': True})\n    def test_default_shopping_cart_enrollment_mode_for_white_label(self):\n        \"\"\"\n        Test that enrollment mode for white label courses (paid courses) is DEFAULT_SHOPPINGCART_MODE_SLUG.\n        \"\"\"\n        # Login white label course instructor\n        self.client.login(username=self.white_label_course_instructor.username, password='test')\n\n        csv_content = \"test_student_wl@example.com,test_student_wl,Test Student,USA\"\n        uploaded_file = SimpleUploadedFile(\"temp.csv\", csv_content)\n        response = self.client.post(self.white_label_course_url, {'students_list': uploaded_file})\n\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        self.assertEquals(len(data['row_errors']), 0)\n        self.assertEquals(len(data['warnings']), 0)\n        self.assertEquals(len(data['general_errors']), 0)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n\n        # Verify enrollment modes to be CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG\n        for enrollment in manual_enrollments:\n            self.assertEqual(enrollment.enrollment.mode, CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG)\n\n\n@attr('shard_1')\n@ddt.ddt\nclass TestInstructorAPIEnrollment(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test enrollment modification endpoint.\n\n    This test does NOT exhaustively test state changes, that is the\n    job of test_enrollment. This tests the response and action switch.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIEnrollment, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n        # Email URL values\n        cls.site_name = microsite.get_value(\n            'SITE_NAME',\n            settings.SITE_NAME\n        )\n        cls.about_path = '/courses/{}/about'.format(cls.course.id)\n        cls.course_path = '/courses/{}/'.format(cls.course.id)\n\n    def setUp(self):\n        super(TestInstructorAPIEnrollment, self).setUp()\n\n        self.request = RequestFactory().request()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.enrolled_student = UserFactory(username='EnrolledStudent', first_name='Enrolled', last_name='Student')\n        CourseEnrollment.enroll(\n            self.enrolled_student,\n            self.course.id\n        )\n        self.notenrolled_student = UserFactory(username='NotEnrolledStudent', first_name='NotEnrolled',\n                                               last_name='Student')\n\n        # Create invited, but not registered, user\n        cea = CourseEnrollmentAllowed(email='robot-allowed@robot.org', course_id=self.course.id)\n        cea.save()\n        self.allowed_email = 'robot-allowed@robot.org'\n\n        self.notregistered_email = 'robot-not-an-email-yet@robot.org'\n        self.assertEqual(User.objects.filter(email=self.notregistered_email).count(), 0)\n\n        # uncomment to enable enable printing of large diffs\n        # from failed assertions in the event of a test failure.\n        # (comment because pylint C0103(invalid-name))\n        # self.maxDiff = None\n\n    def test_missing_params(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_bad_action(self):\n        \"\"\" Test with an invalid action. \"\"\"\n        action = 'robot-not-an-action'\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.enrolled_student.email, 'action': action})\n        self.assertEqual(response.status_code, 400)\n\n    def test_invalid_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': 'percivaloctavius@', 'action': 'enroll', 'email_students': False})\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            'auto_enroll': False,\n            \"results\": [\n                {\n                    \"identifier\": 'percivaloctavius@',\n                    \"invalidIdentifier\": True,\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_invalid_username(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': 'percivaloctavius', 'action': 'enroll', 'email_students': False})\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            'auto_enroll': False,\n            \"results\": [\n                {\n                    \"identifier\": 'percivaloctavius',\n                    \"invalidIdentifier\": True,\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_enroll_with_username(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.username, 'action': 'enroll',\n                                          'email_students': False})\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            'auto_enroll': False,\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.username,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_enroll_without_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'enroll',\n                                          'email_students': False})\n        print \"type(self.notenrolled_student.email): {}\".format(type(self.notenrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now enrolled\n        user = User.objects.get(email=self.notenrolled_student.email)\n        self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    @ddt.data('http', 'https')\n    def test_enroll_with_email(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notenrolled_student.email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n\n        print \"type(self.notenrolled_student.email): {}\".format(type(self.notenrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now enrolled\n        user = User.objects.get(email=self.notenrolled_student.email)\n        self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been enrolled in {}'.format(self.course.display_name)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear NotEnrolled Student\\n\\nYou have been enrolled in {} \"\n            \"at edx.org by a member of the course staff. \"\n            \"The course should now appear on your edx.org dashboard.\\n\\n\"\n            \"To start accessing course materials, please visit \"\n            \"{proto}://{site}{course_path}\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to NotEnrolled Student\".format(\n                self.course.display_name,\n                proto=protocol, site=self.site_name, course_path=self.course_path\n            )\n        )\n\n    @ddt.data('http', 'https')\n    def test_enroll_with_email_not_registered(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been invited to register for {}'.format(self.course.display_name)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {} at edx.org by a member of the course staff.\\n\\n\"\n            \"To finish your registration, please visit {proto}://{site}/register and fill out the \"\n            \"registration form making sure to use robot-not-an-email-yet@robot.org in the E-mail field.\\n\"\n            \"Once you have registered and activated your account, \"\n            \"visit {proto}://{site}{about_path} to join the course.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                self.course.display_name, proto=protocol, site=self.site_name, about_path=self.about_path\n            )\n        )\n\n    @ddt.data('http', 'https')\n    @patch.dict(settings.FEATURES, {'ENABLE_MKTG_SITE': True})\n    def test_enroll_email_not_registered_mktgsite(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name}\"\n            \" at edx.org by a member of the course staff.\\n\\n\"\n            \"To finish your registration, please visit {proto}://{site}/register and fill out the registration form \"\n            \"making sure to use robot-not-an-email-yet@robot.org in the E-mail field.\\n\"\n            \"You can then enroll in {display_name}.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                display_name=self.course.display_name, proto=protocol, site=self.site_name\n            )\n        )\n\n    @ddt.data('http', 'https')\n    def test_enroll_with_email_not_registered_autoenroll(self, protocol):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True,\n                  'auto_enroll': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        print \"type(self.notregistered_email): {}\".format(type(self.notregistered_email))\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been invited to register for {}'.format(self.course.display_name)\n        )\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name}\"\n            \" at edx.org by a member of the course staff.\\n\\n\"\n            \"To finish your registration, please visit {proto}://{site}/register and fill out the registration form \"\n            \"making sure to use robot-not-an-email-yet@robot.org in the E-mail field.\\n\"\n            \"Once you have registered and activated your account,\"\n            \" you will see {display_name} listed on your dashboard.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                proto=protocol, site=self.site_name, display_name=self.course.display_name\n            )\n        )\n\n    def test_unenroll_without_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.enrolled_student.email, 'action': 'unenroll',\n                                          'email_students': False})\n        print \"type(self.enrolled_student.email): {}\".format(type(self.enrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now unenrolled\n        user = User.objects.get(email=self.enrolled_student.email)\n        self.assertFalse(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.enrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ENROLLED_TO_UNENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_unenroll_with_email(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.enrolled_student.email, 'action': 'unenroll',\n                                          'email_students': True})\n        print \"type(self.enrolled_student.email): {}\".format(type(self.enrolled_student.email))\n        self.assertEqual(response.status_code, 200)\n\n        # test that the user is now unenrolled\n        user = User.objects.get(email=self.enrolled_student.email)\n        self.assertFalse(CourseEnrollment.is_enrolled(user, self.course.id))\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.enrolled_student.email,\n                    \"before\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ENROLLED_TO_UNENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been un-enrolled from {display_name}'.format(display_name=self.course.display_name,)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear Enrolled Student\\n\\nYou have been un-enrolled in {display_name} \"\n            \"at edx.org by a member of the course staff. \"\n            \"The course will no longer appear on your edx.org dashboard.\\n\\n\"\n            \"Your other courses have not been affected.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to Enrolled Student\".format(\n                display_name=self.course.display_name,\n            )\n        )\n\n    def test_unenroll_with_email_allowed_student(self):\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.allowed_email, 'action': 'unenroll', 'email_students': True})\n        print \"type(self.allowed_email): {}\".format(type(self.allowed_email))\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.allowed_email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": True,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ALLOWEDTOENROLL_TO_UNENROLLED)\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been un-enrolled from {display_name}'.format(display_name=self.course.display_name,)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear Student,\\n\\nYou have been un-enrolled from course {display_name} by a member of the course staff. \"\n            \"Please disregard the invitation previously sent.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-allowed@robot.org\".format(\n                display_name=self.course.display_name,\n            )\n        )\n\n    @ddt.data('http', 'https')\n    @patch('instructor.enrollment.uses_shib')\n    def test_enroll_with_email_not_registered_with_shib(self, protocol, mock_uses_shib):\n        mock_uses_shib.return_value = True\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to register for {display_name}'.format(display_name=self.course.display_name,)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name} at edx.org by a member of the course staff.\\n\\n\"\n            \"To access the course visit {proto}://{site}{about_path} and register for the course.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                proto=protocol, site=self.site_name, about_path=self.about_path,\n                display_name=self.course.display_name,\n            )\n        )\n\n    @patch('instructor.enrollment.uses_shib')\n    @patch.dict(settings.FEATURES, {'ENABLE_MKTG_SITE': True})\n    def test_enroll_email_not_registered_shib_mktgsite(self, mock_uses_shib):\n        # Try with marketing site enabled and shib on\n        mock_uses_shib.return_value = True\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        # Try with marketing site enabled\n        with patch.dict('django.conf.settings.FEATURES', {'ENABLE_MKTG_SITE': True}):\n            response = self.client.post(url, {'identifiers': self.notregistered_email, 'action': 'enroll',\n                                              'email_students': True})\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {} at edx.org by a member of the course staff.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                self.course.display_name,\n            )\n        )\n\n    @ddt.data('http', 'https')\n    @patch('instructor.enrollment.uses_shib')\n    def test_enroll_with_email_not_registered_with_shib_autoenroll(self, protocol, mock_uses_shib):\n        mock_uses_shib.return_value = True\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': True,\n                  'auto_enroll': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        print \"type(self.notregistered_email): {}\".format(type(self.notregistered_email))\n        self.assertEqual(response.status_code, 200)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to register for {display_name}'.format(display_name=self.course.display_name,)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear student,\\n\\nYou have been invited to join {display_name}\"\n            \" at edx.org by a member of the course staff.\\n\\n\"\n            \"To access the course visit {proto}://{site}{course_path} and login.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to robot-not-an-email-yet@robot.org\".format(\n                display_name=self.course.display_name,\n                proto=protocol, site=self.site_name, course_path=self.course_path\n            )\n        )\n\n    def test_enroll_already_enrolled_student(self):\n        \"\"\"\n        Ensure that already enrolled \"verified\" students cannot be downgraded\n        to \"honor\"\n        \"\"\"\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        # make this enrollment \"verified\"\n        course_enrollment.mode = u'verified'\n        course_enrollment.save()\n        self.assertEqual(course_enrollment.mode, u'verified')\n\n        # now re-enroll the student through the instructor dash\n        self._change_student_enrollment(self.enrolled_student, self.course, 'enroll')\n\n        # affirm that the student is still in \"verified\" mode\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, ENROLLED_TO_ENROLLED)\n        self.assertEqual(course_enrollment.mode, u\"verified\")\n\n    def create_paid_course(self):\n        \"\"\"\n        create paid course mode.\n        \"\"\"\n        paid_course = CourseFactory.create()\n        CourseModeFactory.create(course_id=paid_course.id, min_price=50, mode_slug=CourseMode.HONOR)\n        CourseInstructorRole(paid_course.id).add_users(self.instructor)\n        return paid_course\n\n    def test_reason_field_should_not_be_empty(self):\n        \"\"\"\n        test to check that reason field should not be empty when\n        manually enrolling the students for the paid courses.\n        \"\"\"\n        paid_course = self.create_paid_course()\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': False,\n                  'auto_enroll': False}\n        response = self.client.post(url, params)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 0)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"error\": True\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_unenrolled_allowed_to_enroll_user(self):\n        \"\"\"\n        test to unenroll allow to enroll user.\n        \"\"\"\n        paid_course = self.create_paid_course()\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': False,\n                  'auto_enroll': False, 'reason': 'testing..'}\n        response = self.client.post(url, params)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_ALLOWEDTOENROLL)\n        self.assertEqual(response.status_code, 200)\n\n        # now registered the user\n        UserFactory(email=self.notregistered_email)\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'enroll', 'email_students': False,\n                  'auto_enroll': False, 'reason': 'testing'}\n        response = self.client.post(url, params)\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 2)\n        self.assertEqual(manual_enrollments[1].state_transition, ALLOWEDTOENROLL_TO_ENROLLED)\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"enroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notregistered_email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": True,\n                    },\n                    \"after\": {\n                        \"enrollment\": True,\n                        \"auto_enroll\": False,\n                        \"user\": True,\n                        \"allowed\": True,\n                    }\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_unenrolled_already_not_enrolled_user(self):\n        \"\"\"\n        test unenrolled user already not enrolled in a course.\n        \"\"\"\n        paid_course = self.create_paid_course()\n        course_enrollment = CourseEnrollment.objects.filter(\n            user__email=self.notregistered_email, course_id=paid_course.id\n        )\n        self.assertEqual(course_enrollment.count(), 0)\n\n        url = reverse('students_update_enrollment', kwargs={'course_id': paid_course.id.to_deprecated_string()})\n        params = {'identifiers': self.notregistered_email, 'action': 'unenroll', 'email_students': False,\n                  'auto_enroll': False, 'reason': 'testing'}\n\n        response = self.client.post(url, params)\n        self.assertEqual(response.status_code, 200)\n\n        # test the response data\n        expected = {\n            \"action\": \"unenroll\",\n            \"auto_enroll\": False,\n            \"results\": [\n                {\n                    \"identifier\": self.notregistered_email,\n                    \"before\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": False,\n                    },\n                    \"after\": {\n                        \"enrollment\": False,\n                        \"auto_enroll\": False,\n                        \"user\": False,\n                        \"allowed\": False,\n                    }\n                }\n            ]\n        }\n\n        manual_enrollments = ManualEnrollmentAudit.objects.all()\n        self.assertEqual(manual_enrollments.count(), 1)\n        self.assertEqual(manual_enrollments[0].state_transition, UNENROLLED_TO_UNENROLLED)\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_unenroll_and_enroll_verified(self):\n        \"\"\"\n        Test that unenrolling and enrolling a student from a verified track\n        results in that student being in the default track\n        \"\"\"\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        # upgrade enrollment\n        course_enrollment.mode = u'verified'\n        course_enrollment.save()\n        self.assertEqual(course_enrollment.mode, u'verified')\n\n        self._change_student_enrollment(self.enrolled_student, self.course, 'unenroll')\n\n        self._change_student_enrollment(self.enrolled_student, self.course, 'enroll')\n\n        course_enrollment = CourseEnrollment.objects.get(\n            user=self.enrolled_student, course_id=self.course.id\n        )\n        self.assertEqual(course_enrollment.mode, CourseMode.DEFAULT_MODE_SLUG)\n\n    def _change_student_enrollment(self, user, course, action):\n        \"\"\"\n        Helper function that posts to 'students_update_enrollment' to change\n        a student's enrollment\n        \"\"\"\n        url = reverse(\n            'students_update_enrollment',\n            kwargs={'course_id': course.id.to_deprecated_string()},\n        )\n        params = {\n            'identifiers': user.email,\n            'action': action,\n            'email_students': True,\n            'reason': 'change user enrollment'\n        }\n        response = self.client.post(url, params)\n        self.assertEqual(response.status_code, 200)\n        return response\n\n\n@attr('shard_1')\n@ddt.ddt\nclass TestInstructorAPIBulkBetaEnrollment(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test bulk beta modify access endpoint.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIBulkBetaEnrollment, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        # Email URL values\n        cls.site_name = microsite.get_value(\n            'SITE_NAME',\n            settings.SITE_NAME\n        )\n        cls.about_path = '/courses/{}/about'.format(cls.course.id)\n        cls.course_path = '/courses/{}/'.format(cls.course.id)\n\n    def setUp(self):\n        super(TestInstructorAPIBulkBetaEnrollment, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.beta_tester = BetaTesterFactory(course_key=self.course.id)\n        CourseEnrollment.enroll(\n            self.beta_tester,\n            self.course.id\n        )\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))\n\n        self.notenrolled_student = UserFactory(username='NotEnrolledStudent')\n\n        self.notregistered_email = 'robot-not-an-email-yet@robot.org'\n        self.assertEqual(User.objects.filter(email=self.notregistered_email).count(), 0)\n\n        self.request = RequestFactory().request()\n\n        # uncomment to enable enable printing of large diffs\n        # from failed assertions in the event of a test failure.\n        # (comment because pylint C0103(invalid-name))\n        # self.maxDiff = None\n\n    def test_missing_params(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_bad_action(self):\n        \"\"\" Test with an invalid action. \"\"\"\n        action = 'robot-not-an-action'\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.beta_tester.email, 'action': action})\n        self.assertEqual(response.status_code, 400)\n\n    def add_notenrolled(self, response, identifier):\n        \"\"\"\n        Test Helper Method (not a test, called by other tests)\n\n        Takes a client response from a call to bulk_beta_modify_access with 'email_students': False,\n        and the student identifier (email or username) given as 'identifiers' in the request.\n\n        Asserts the reponse returns cleanly, that the student was added as a beta tester, and the\n        response properly contains their identifier, 'error': False, and 'userDoesNotExist': False.\n        Additionally asserts no email was sent.\n        \"\"\"\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.notenrolled_student))\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": identifier,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_add_notenrolled_email(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': False})\n        self.add_notenrolled(response, self.notenrolled_student.email)\n        self.assertFalse(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    def test_add_notenrolled_email_autoenroll(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': False, 'auto_enroll': True})\n        self.add_notenrolled(response, self.notenrolled_student.email)\n        self.assertTrue(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    def test_add_notenrolled_username(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.username, 'action': 'add', 'email_students': False})\n        self.add_notenrolled(response, self.notenrolled_student.username)\n        self.assertFalse(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    def test_add_notenrolled_username_autoenroll(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.username, 'action': 'add', 'email_students': False, 'auto_enroll': True})\n        self.add_notenrolled(response, self.notenrolled_student.username)\n        self.assertTrue(CourseEnrollment.is_enrolled(self.notenrolled_student, self.course.id))\n\n    @ddt.data('http', 'https')\n    def test_add_notenrolled_with_email(self, protocol):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.notenrolled_student))\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to a beta test for {display_name}'.format(display_name=self.course.display_name,)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            u\"Dear {student_name}\\n\\nYou have been invited to be a beta tester \"\n            \"for {display_name} at edx.org by a member of the course staff.\\n\\n\"\n            \"Visit {proto}://{site}{about_path} to join \"\n            \"the course and begin the beta test.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {student_email}\".format(\n                display_name=self.course.display_name,\n                student_name=self.notenrolled_student.profile.name,\n                student_email=self.notenrolled_student.email,\n                proto=protocol,\n                site=self.site_name,\n                about_path=self.about_path\n            )\n        )\n\n    @ddt.data('http', 'https')\n    def test_add_notenrolled_with_email_autoenroll(self, protocol):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        params = {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': True,\n                  'auto_enroll': True}\n        environ = {'wsgi.url_scheme': protocol}\n        response = self.client.post(url, params, **environ)\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(self.notenrolled_student))\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": self.notenrolled_student.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            'You have been invited to a beta test for {display_name}'.format(display_name=self.course.display_name)\n        )\n\n        self.assertEqual(\n            mail.outbox[0].body,\n            u\"Dear {student_name}\\n\\nYou have been invited to be a beta tester \"\n            \"for {display_name} at edx.org by a member of the course staff.\\n\\n\"\n            \"To start accessing course materials, please visit \"\n            \"{proto}://{site}{course_path}\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {student_email}\".format(\n                display_name=self.course.display_name,\n                student_name=self.notenrolled_student.profile.name,\n                student_email=self.notenrolled_student.email,\n                proto=protocol,\n                site=self.site_name,\n                course_path=self.course_path\n            )\n        )\n\n    @patch.dict(settings.FEATURES, {'ENABLE_MKTG_SITE': True})\n    def test_add_notenrolled_email_mktgsite(self):\n        # Try with marketing site enabled\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'identifiers': self.notenrolled_student.email, 'action': 'add', 'email_students': True})\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\n            mail.outbox[0].body,\n            u\"Dear {}\\n\\nYou have been invited to be a beta tester \"\n            \"for {} at edx.org by a member of the course staff.\\n\\n\"\n            \"Visit edx.org to enroll in the course and begin the beta test.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {}\".format(\n                self.notenrolled_student.profile.name,\n                self.course.display_name,\n                self.notenrolled_student.email,\n            )\n        )\n\n    def test_enroll_with_email_not_registered(self):\n        # User doesn't exist\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.notregistered_email, 'action': 'add', 'email_students': True,\n                                     'reason': 'testing'})\n        self.assertEqual(response.status_code, 200)\n        # test the response data\n        expected = {\n            \"action\": \"add\",\n            \"results\": [\n                {\n                    \"identifier\": self.notregistered_email,\n                    \"error\": True,\n                    \"userDoesNotExist\": True\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_remove_without_email(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.beta_tester.email, 'action': 'remove', 'email_students': False,\n                                     'reason': 'testing'})\n        self.assertEqual(response.status_code, 200)\n\n        # Works around a caching bug which supposedly can't happen in prod. The instance here is not ==\n        # the instance fetched from the email above which had its cache cleared\n        if hasattr(self.beta_tester, '_roles'):\n            del self.beta_tester._roles\n        self.assertFalse(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))\n\n        # test the response data\n        expected = {\n            \"action\": \"remove\",\n            \"results\": [\n                {\n                    \"identifier\": self.beta_tester.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_remove_with_email(self):\n        url = reverse('bulk_beta_modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url,\n                                    {'identifiers': self.beta_tester.email, 'action': 'remove', 'email_students': True,\n                                     'reason': 'testing'})\n        self.assertEqual(response.status_code, 200)\n\n        # Works around a caching bug which supposedly can't happen in prod. The instance here is not ==\n        # the instance fetched from the email above which had its cache cleared\n        if hasattr(self.beta_tester, '_roles'):\n            del self.beta_tester._roles\n        self.assertFalse(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))\n\n        # test the response data\n        expected = {\n            \"action\": \"remove\",\n            \"results\": [\n                {\n                    \"identifier\": self.beta_tester.email,\n                    \"error\": False,\n                    \"userDoesNotExist\": False\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n        # Check the outbox\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\n            mail.outbox[0].subject,\n            u'You have been removed from a beta test for {display_name}'.format(display_name=self.course.display_name,)\n        )\n        self.assertEqual(\n            mail.outbox[0].body,\n            \"Dear {full_name}\\n\\nYou have been removed as a beta tester for \"\n            \"{display_name} at edx.org by a member of the course staff. \"\n            \"The course will remain on your dashboard, but you will no longer \"\n            \"be part of the beta testing group.\\n\\n\"\n            \"Your other courses have not been affected.\\n\\n----\\n\"\n            \"This email was automatically sent from edx.org to {email_address}\".format(\n                display_name=self.course.display_name,\n                full_name=self.beta_tester.profile.name,\n                email_address=self.beta_tester.email\n            )\n        )\n\n\n@attr('shard_1')\nclass TestInstructorAPILevelsAccess(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints whereby instructors can change permissions\n    of other users.\n\n    This test does NOT test whether the actions had an effect on the\n    database, that is the job of test_access.\n    This tests the response and action switch.\n    Actually, modify_access does not have a very meaningful\n    response yet, so only the status code is tested.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPILevelsAccess, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestInstructorAPILevelsAccess, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.other_instructor = InstructorFactory(course_key=self.course.id)\n        self.other_staff = StaffFactory(course_key=self.course.id)\n        self.other_user = UserFactory()\n\n    def test_modify_access_noparams(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_modify_access_bad_action(self):\n        \"\"\" Test with an invalid action parameter. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'staff',\n            'action': 'robot-not-an-action',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_modify_access_bad_role(self):\n        \"\"\" Test with an invalid action parameter. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'robot-not-a-roll',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_modify_access_allow(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_user.email,\n            'rolename': 'staff',\n            'action': 'allow',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_allow_with_uname(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_instructor.username,\n            'rolename': 'staff',\n            'action': 'allow',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_revoke(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'staff',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_revoke_with_username(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_staff.username,\n            'rolename': 'staff',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_with_fake_user(self):\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': 'GandalfTheGrey',\n            'rolename': 'staff',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n        expected = {\n            'unique_student_identifier': 'GandalfTheGrey',\n            'userDoesNotExist': True,\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_modify_access_with_inactive_user(self):\n        self.other_user.is_active = False\n        self.other_user.save()  # pylint: disable=no-member\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_user.username,\n            'rolename': 'beta',\n            'action': 'allow',\n        })\n        self.assertEqual(response.status_code, 200)\n        expected = {\n            'unique_student_identifier': self.other_user.username,\n            'inactiveUser': True,\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_modify_access_revoke_not_allowed(self):\n        \"\"\" Test revoking access that a user does not have. \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.other_staff.email,\n            'rolename': 'instructor',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_modify_access_revoke_self(self):\n        \"\"\"\n        Test that an instructor cannot remove instructor privelages from themself.\n        \"\"\"\n        url = reverse('modify_access', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.instructor.email,\n            'rolename': 'instructor',\n            'action': 'revoke',\n        })\n        self.assertEqual(response.status_code, 200)\n        # check response content\n        expected = {\n            'unique_student_identifier': self.instructor.username,\n            'rolename': 'instructor',\n            'action': 'revoke',\n            'removingSelfAsInstructor': True,\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_list_course_role_members_noparams(self):\n        \"\"\" Test missing all query parameters. \"\"\"\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_list_course_role_members_bad_rolename(self):\n        \"\"\" Test with an invalid rolename parameter. \"\"\"\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'rolename': 'robot-not-a-rolename',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_list_course_role_members_staff(self):\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'rolename': 'staff',\n        })\n        self.assertEqual(response.status_code, 200)\n\n        # check response content\n        expected = {\n            'course_id': self.course.id.to_deprecated_string(),\n            'staff': [\n                {\n                    'username': self.other_staff.username,\n                    'email': self.other_staff.email,\n                    'first_name': self.other_staff.first_name,\n                    'last_name': self.other_staff.last_name,\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_list_course_role_members_beta(self):\n        url = reverse('list_course_role_members', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'rolename': 'beta',\n        })\n        self.assertEqual(response.status_code, 200)\n\n        # check response content\n        expected = {\n            'course_id': self.course.id.to_deprecated_string(),\n            'beta': []\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected)\n\n    def test_update_forum_role_membership(self):\n        \"\"\"\n        Test update forum role membership with user's email and username.\n        \"\"\"\n\n        # Seed forum roles for course.\n        seed_permissions_roles(self.course.id)\n\n        for user in [self.instructor, self.other_user]:\n            for identifier_attr in [user.email, user.username]:\n                for rolename in [\"Administrator\", \"Moderator\", \"Community TA\"]:\n                    for action in [\"allow\", \"revoke\"]:\n                        self.assert_update_forum_role_membership(user, identifier_attr, rolename, action)\n\n    def assert_update_forum_role_membership(self, current_user, identifier, rolename, action):\n        \"\"\"\n        Test update forum role membership.\n        Get unique_student_identifier, rolename and action and update forum role.\n        \"\"\"\n        url = reverse('update_forum_role_membership', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(\n            url,\n            {\n                'unique_student_identifier': identifier,\n                'rolename': rolename,\n                'action': action,\n            }\n        )\n\n        # Status code should be 200.\n        self.assertEqual(response.status_code, 200)\n\n        user_roles = current_user.roles.filter(course_id=self.course.id).values_list(\"name\", flat=True)\n        if action == 'allow':\n            self.assertIn(rolename, user_roles)\n        elif action == 'revoke':\n            self.assertNotIn(rolename, user_roles)\n\n\n@attr('shard_1')\n@ddt.ddt\n@patch.dict('django.conf.settings.FEATURES', {'ENABLE_PAID_COURSE_REGISTRATION': True})\nclass TestInstructorAPILevelsDataDump(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints that show data without side effects.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPILevelsDataDump, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestInstructorAPILevelsDataDump, self).setUp()\n        self.course_mode = CourseMode(course_id=self.course.id,\n                                      mode_slug=\"honor\",\n                                      mode_display_name=\"honor cert\",\n                                      min_price=40)\n        self.course_mode.save()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n        self.cart = Order.get_cart_for_user(self.instructor)\n        self.coupon_code = 'abcde'\n        self.coupon = Coupon(code=self.coupon_code, description='testing code', course_id=self.course.id,\n                             percentage_discount=10, created_by=self.instructor, is_active=True)\n        self.coupon.save()\n\n        # Create testing invoice 1\n        self.sale_invoice_1 = Invoice.objects.create(\n            total_amount=1234.32, company_name='Test1', company_contact_name='TestName', company_contact_email='Test@company.com',\n            recipient_name='Testw', recipient_email='test1@test.com', customer_reference_number='2Fwe23S',\n            internal_reference=\"A\", course_id=self.course.id, is_valid=True\n        )\n        self.invoice_item = CourseRegistrationCodeInvoiceItem.objects.create(\n            invoice=self.sale_invoice_1,\n            qty=1,\n            unit_price=1234.32,\n            course_id=self.course.id\n        )\n\n        self.students = [UserFactory() for _ in xrange(6)]\n        for student in self.students:\n            CourseEnrollment.enroll(student, self.course.id)\n\n        self.students_who_may_enroll = self.students + [UserFactory() for _ in range(5)]\n        for student in self.students_who_may_enroll:\n            CourseEnrollmentAllowed.objects.create(\n                email=student.email, course_id=self.course.id\n            )\n\n    def register_with_redemption_code(self, user, code):\n        \"\"\"\n        enroll user using a registration code\n        \"\"\"\n        redeem_url = reverse('shoppingcart.views.register_code_redemption', args=[code], is_dashboard_endpoint=False)\n        self.client.login(username=user.username, password='test')\n        response = self.client.get(redeem_url)\n        self.assertEquals(response.status_code, 200)\n        # check button text\n        self.assertTrue('Activate Course Enrollment' in response.content)\n\n        response = self.client.post(redeem_url)\n        self.assertEquals(response.status_code, 200)\n\n    def test_invalidate_sale_record(self):\n        \"\"\"\n        Testing the sale invalidating scenario.\n        \"\"\"\n        for i in range(2):\n            course_registration_code = CourseRegistrationCode(\n                code='sale_invoice{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        data = {'invoice_number': self.sale_invoice_1.id, 'event_type': \"invalidate\"}\n        url = reverse('sale_validation', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        self.assert_request_status_code(200, url, method=\"POST\", data=data)\n\n        #Now try to fetch data against not existing invoice number\n        test_data_1 = {'invoice_number': 100, 'event_type': \"invalidate\"}\n        self.assert_request_status_code(404, url, method=\"POST\", data=test_data_1)\n\n        # Now invalidate the same invoice number and expect an Bad request\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=data)\n        self.assertIn(\"The sale associated with this invoice has already been invalidated.\", response.content)\n\n        # now re_validate the invoice number\n        data['event_type'] = \"re_validate\"\n        self.assert_request_status_code(200, url, method=\"POST\", data=data)\n\n        # Now re_validate the same active invoice number and expect an Bad request\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=data)\n        self.assertIn(\"This invoice is already active.\", response.content)\n\n        test_data_2 = {'invoice_number': self.sale_invoice_1.id}\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=test_data_2)\n        self.assertIn(\"Missing required event_type parameter\", response.content)\n\n        test_data_3 = {'event_type': \"re_validate\"}\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=test_data_3)\n        self.assertIn(\"Missing required invoice_number parameter\", response.content)\n\n        # submitting invalid invoice number\n        data['invoice_number'] = 'testing'\n        response = self.assert_request_status_code(400, url, method=\"POST\", data=data)\n        self.assertIn(\"invoice_number must be an integer, {value} provided\".format(value=data['invoice_number']), response.content)\n\n    def test_get_sale_order_records_features_csv(self):\n        \"\"\"\n        Test that the response from get_sale_order_records is in csv format.\n        \"\"\"\n        # add the coupon code for the course\n        coupon = Coupon(\n            code='test_code', description='test_description', course_id=self.course.id,\n            percentage_discount='10', created_by=self.instructor, is_active=True\n        )\n        coupon.save()\n        self.cart.order_type = 'business'\n        self.cart.save()\n        self.cart.add_billing_details(company_name='Test Company', company_contact_name='Test',\n                                      company_contact_email='test@123', recipient_name='R1',\n                                      recipient_email='', customer_reference_number='PO#23')\n\n        paid_course_reg_item = PaidCourseRegistration.add_to_order(\n            self.cart,\n            self.course.id,\n            mode_slug=CourseMode.HONOR\n        )\n        # update the quantity of the cart item paid_course_reg_item\n        resp = self.client.post(\n            reverse('shoppingcart.views.update_user_cart', is_dashboard_endpoint=False),\n            {'ItemId': paid_course_reg_item.id, 'qty': '4'}\n        )\n        self.assertEqual(resp.status_code, 200)\n        # apply the coupon code to the item in the cart\n        resp = self.client.post(\n            reverse('shoppingcart.views.use_code', is_dashboard_endpoint=False),\n            {'code': coupon.code}\n        )\n        self.assertEqual(resp.status_code, 200)\n        self.cart.purchase()\n        # get the updated item\n        item = self.cart.orderitem_set.all().select_subclasses()[0]\n        # get the redeemed coupon information\n        coupon_redemption = CouponRedemption.objects.select_related('coupon').filter(order=self.cart)\n\n        sale_order_url = reverse('get_sale_order_records', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(sale_order_url)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        self.assertIn('36', response.content.split('\\r\\n')[1])\n        self.assertIn(str(item.unit_cost), response.content.split('\\r\\n')[1],)\n        self.assertIn(str(item.list_price), response.content.split('\\r\\n')[1],)\n        self.assertIn(item.status, response.content.split('\\r\\n')[1],)\n        self.assertIn(coupon_redemption[0].coupon.code, response.content.split('\\r\\n')[1],)\n\n    def test_coupon_redeem_count_in_ecommerce_section(self):\n        \"\"\"\n        Test that checks the redeem count in the instructor_dashboard coupon section\n        \"\"\"\n        # add the coupon code for the course\n        coupon = Coupon(\n            code='test_code', description='test_description', course_id=self.course.id,\n            percentage_discount='10', created_by=self.instructor, is_active=True\n        )\n        coupon.save()\n\n        # Coupon Redeem Count only visible for Financial Admins.\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n\n        PaidCourseRegistration.add_to_order(self.cart, self.course.id)\n        # apply the coupon code to the item in the cart\n        resp = self.client.post(\n            reverse('shoppingcart.views.use_code', is_dashboard_endpoint=False),\n            {'code': coupon.code}\n        )\n        self.assertEqual(resp.status_code, 200)\n\n        # URL for instructor dashboard\n        instructor_dashboard = reverse(\n            'instructor_dashboard',\n            kwargs={'course_id': self.course.id.to_deprecated_string()},\n            is_dashboard_endpoint=False\n        )\n        # visit the instructor dashboard page and\n        # check that the coupon redeem count should be 0\n        resp = self.client.get(instructor_dashboard)\n        self.assertEqual(resp.status_code, 200)\n        self.assertIn('Number Redeemed', resp.content)\n        self.assertIn('<td>0</td>', resp.content)\n\n        # now make the payment of your cart items\n        self.cart.purchase()\n        # visit the instructor dashboard page and\n        # check that the coupon redeem count should be 1\n        resp = self.client.get(instructor_dashboard)\n        self.assertEqual(resp.status_code, 200)\n\n        self.assertIn('Number Redeemed', resp.content)\n        self.assertIn('<td>1</td>', resp.content)\n\n    def test_get_sale_records_features_csv(self):\n        \"\"\"\n        Test that the response from get_sale_records is in csv format.\n        \"\"\"\n        for i in range(2):\n            course_registration_code = CourseRegistrationCode(\n                code='sale_invoice{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        url = reverse(\n            'get_sale_records',\n            kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n        response = self.client.post(url + '/csv', {})\n        self.assertEqual(response['Content-Type'], 'text/csv')\n\n    def test_get_sale_records_features_json(self):\n        \"\"\"\n        Test that the response from get_sale_records is in json format.\n        \"\"\"\n        for i in range(5):\n            course_registration_code = CourseRegistrationCode(\n                code='sale_invoice{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        url = reverse('get_sale_records', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('sale', res_json)\n\n        for res in res_json['sale']:\n            self.validate_sale_records_response(\n                res,\n                course_registration_code,\n                self.sale_invoice_1,\n                0,\n                invoice_item=self.invoice_item\n            )\n\n    def test_get_sale_records_features_with_multiple_invoices(self):\n        \"\"\"\n        Test that the response from get_sale_records is in json format for multiple invoices\n        \"\"\"\n        for i in range(5):\n            course_registration_code = CourseRegistrationCode(\n                code='qwerty{}'.format(i),\n                course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor,\n                invoice=self.sale_invoice_1,\n                invoice_item=self.invoice_item,\n                mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        # Create test invoice 2\n        sale_invoice_2 = Invoice.objects.create(\n            total_amount=1234.32, company_name='Test1', company_contact_name='TestName', company_contact_email='Test@company.com',\n            recipient_name='Testw_2', recipient_email='test2@test.com', customer_reference_number='2Fwe23S',\n            internal_reference=\"B\", course_id=self.course.id\n        )\n\n        invoice_item_2 = CourseRegistrationCodeInvoiceItem.objects.create(\n            invoice=sale_invoice_2,\n            qty=1,\n            unit_price=1234.32,\n            course_id=self.course.id\n        )\n\n        for i in range(5):\n            course_registration_code = CourseRegistrationCode(\n                code='xyzmn{}'.format(i), course_id=self.course.id.to_deprecated_string(),\n                created_by=self.instructor, invoice=sale_invoice_2, invoice_item=invoice_item_2, mode_slug='honor'\n            )\n            course_registration_code.save()\n\n        url = reverse('get_sale_records', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('sale', res_json)\n\n        self.validate_sale_records_response(\n            res_json['sale'][0],\n            course_registration_code,\n            self.sale_invoice_1,\n            0,\n            invoice_item=self.invoice_item\n        )\n        self.validate_sale_records_response(\n            res_json['sale'][1],\n            course_registration_code,\n            sale_invoice_2,\n            0,\n            invoice_item=invoice_item_2\n        )\n\n    def validate_sale_records_response(self, res, course_registration_code, invoice, used_codes, invoice_item):\n        \"\"\"\n        validate sale records attribute values with the response object\n        \"\"\"\n        self.assertEqual(res['total_amount'], invoice.total_amount)\n        self.assertEqual(res['recipient_email'], invoice.recipient_email)\n        self.assertEqual(res['recipient_name'], invoice.recipient_name)\n        self.assertEqual(res['company_name'], invoice.company_name)\n        self.assertEqual(res['company_contact_name'], invoice.company_contact_name)\n        self.assertEqual(res['company_contact_email'], invoice.company_contact_email)\n        self.assertEqual(res['internal_reference'], invoice.internal_reference)\n        self.assertEqual(res['customer_reference_number'], invoice.customer_reference_number)\n        self.assertEqual(res['invoice_number'], invoice.id)\n        self.assertEqual(res['created_by'], course_registration_code.created_by.username)\n        self.assertEqual(res['course_id'], invoice_item.course_id.to_deprecated_string())\n        self.assertEqual(res['total_used_codes'], used_codes)\n        self.assertEqual(res['total_codes'], 5)\n\n    def test_get_problem_responses_invalid_location(self):\n        \"\"\"\n        Test whether get_problem_responses returns an appropriate status\n        message when users submit an invalid problem location.\n        \"\"\"\n        url = reverse(\n            'get_problem_responses',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        problem_location = ''\n\n        response = self.client.post(url, {'problem_location': problem_location})\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, 'Could not find problem with this location.')\n\n    def valid_problem_location(test):  # pylint: disable=no-self-argument\n        \"\"\"\n        Decorator for tests that target get_problem_responses endpoint and\n        need to pretend user submitted a valid problem location.\n        \"\"\"\n        @functools.wraps(test)\n        def wrapper(self, *args, **kwargs):\n            \"\"\"\n            Run `test` method, ensuring that UsageKey.from_string returns a\n            problem key that the get_problem_responses endpoint can\n            work with.\n            \"\"\"\n            mock_problem_key = Mock(return_value=u'')\n            mock_problem_key.course_key = self.course.id\n            with patch.object(UsageKey, 'from_string') as patched_method:\n                patched_method.return_value = mock_problem_key\n                test(self, *args, **kwargs)\n        return wrapper\n\n    @valid_problem_location\n    def test_get_problem_responses_successful(self):\n        \"\"\"\n        Test whether get_problem_responses returns an appropriate status\n        message if CSV generation was started successfully.\n        \"\"\"\n        url = reverse(\n            'get_problem_responses',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        problem_location = ''\n\n        response = self.client.post(url, {'problem_location': problem_location})\n        res_json = json.loads(response.content)\n        self.assertIn('status', res_json)\n        status = res_json['status']\n        self.assertIn('is being created', status)\n        self.assertNotIn('already in progress', status)\n\n    @valid_problem_location\n    def test_get_problem_responses_already_running(self):\n        \"\"\"\n        Test whether get_problem_responses returns an appropriate status\n        message if CSV generation is already in progress.\n        \"\"\"\n        url = reverse(\n            'get_problem_responses',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n\n        with patch('instructor_task.api.submit_calculate_problem_responses_csv') as submit_task_function:\n            error = AlreadyRunningError()\n            submit_task_function.side_effect = error\n            response = self.client.post(url, {})\n            res_json = json.loads(response.content)\n            self.assertIn('status', res_json)\n            self.assertIn('already in progress', res_json['status'])\n\n    def test_get_students_features(self):\n        \"\"\"\n        Test that some minimum of information is formatted\n        correctly in the response to get_students_features.\n        \"\"\"\n        for student in self.students:\n            student.profile.city = \"Mos Eisley {}\".format(student.id)\n            student.profile.save()\n        url = reverse('get_students_features', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('students', res_json)\n        for student in self.students:\n            student_json = [\n                x for x in res_json['students']\n                if x['username'] == student.username\n            ][0]\n            self.assertEqual(student_json['username'], student.username)\n            self.assertEqual(student_json['email'], student.email)\n            self.assertEqual(student_json['city'], student.profile.city)\n            self.assertEqual(student_json['country'], \"\")\n\n    @ddt.data(True, False)\n    def test_get_students_features_cohorted(self, is_cohorted):\n        \"\"\"\n        Test that get_students_features includes cohort info when the course is\n        cohorted, and does not when the course is not cohorted.\n        \"\"\"\n        url = reverse('get_students_features', kwargs={'course_id': unicode(self.course.id)})\n        set_course_cohort_settings(self.course.id, is_cohorted=is_cohorted)\n\n        response = self.client.post(url, {})\n        res_json = json.loads(response.content)\n\n        self.assertEqual('cohort' in res_json['feature_names'], is_cohorted)\n\n    @ddt.data(True, False)\n    def test_get_students_features_teams(self, has_teams):\n        \"\"\"\n        Test that get_students_features includes team info when the course is\n        has teams enabled, and does not when the course does not have teams enabled\n        \"\"\"\n        if has_teams:\n            self.course = CourseFactory.create(teams_configuration={\n                'max_size': 2, 'topics': [{'topic-id': 'topic', 'name': 'Topic', 'description': 'A Topic'}]\n            })\n            course_instructor = InstructorFactory(course_key=self.course.id)\n            self.client.login(username=course_instructor.username, password='test')\n\n        url = reverse('get_students_features', kwargs={'course_id': unicode(self.course.id)})\n\n        response = self.client.post(url, {})\n        res_json = json.loads(response.content)\n\n        self.assertEqual('team' in res_json['feature_names'], has_teams)\n\n    def test_get_students_who_may_enroll(self):\n        \"\"\"\n        Test whether get_students_who_may_enroll returns an appropriate\n        status message when users request a CSV file of students who\n        may enroll in a course.\n        \"\"\"\n        url = reverse(\n            'get_students_who_may_enroll',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        # Successful case:\n        response = self.client.post(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('status', res_json)\n        self.assertNotIn('currently being created', res_json['status'])\n        # CSV generation already in progress:\n        with patch('instructor_task.api.submit_calculate_may_enroll_csv') as submit_task_function:\n            error = AlreadyRunningError()\n            submit_task_function.side_effect = error\n            response = self.client.post(url, {})\n            res_json = json.loads(response.content)\n            self.assertIn('status', res_json)\n            self.assertIn('currently being created', res_json['status'])\n\n    def test_get_student_exam_results(self):\n        \"\"\"\n        Test whether get_proctored_exam_results returns an appropriate\n        status message when users request a CSV file.\n        \"\"\"\n        url = reverse(\n            'get_proctored_exam_results',\n            kwargs={'course_id': unicode(self.course.id)}\n        )\n        # Successful case:\n        response = self.client.post(url, {})\n        res_json = json.loads(response.content)\n        self.assertIn('status', res_json)\n        self.assertNotIn('currently being created', res_json['status'])\n        # CSV generation already in progress:\n        with patch('instructor_task.api.submit_proctored_exam_results_report') as submit_task_function:\n            error = AlreadyRunningError()\n            submit_task_function.side_effect = error\n            response = self.client.post(url, {})\n            res_json = json.loads(response.content)\n            self.assertIn('status', res_json)\n            self.assertIn('currently being created', res_json['status'])\n\n    def test_access_course_finance_admin_with_invalid_course_key(self):\n        \"\"\"\n        Test assert require_course fiance_admin before generating\n        a detailed enrollment report\n        \"\"\"\n        func = Mock()\n        decorated_func = require_finance_admin(func)\n        request = self.mock_request()\n        response = decorated_func(request, 'invalid_course_key')\n        self.assertEqual(response.status_code, 404)\n        self.assertFalse(func.called)\n\n    def mock_request(self):\n        \"\"\"\n        mock request\n        \"\"\"\n        request = Mock()\n        request.user = self.instructor\n        return request\n\n    def test_access_course_finance_admin_with_valid_course_key(self):\n        \"\"\"\n        Test to check the course_finance_admin role with valid key\n        but doesn't have access to the function\n        \"\"\"\n        func = Mock()\n        decorated_func = require_finance_admin(func)\n        request = self.mock_request()\n        response = decorated_func(request, 'valid/course/key')\n        self.assertEqual(response.status_code, 403)\n        self.assertFalse(func.called)\n\n    def test_add_user_to_fiance_admin_role_with_valid_course(self):\n        \"\"\"\n        test to check that a function is called using a fiance_admin\n        rights.\n        \"\"\"\n        func = Mock()\n        decorated_func = require_finance_admin(func)\n        request = self.mock_request()\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        decorated_func(request, self.course.id.to_deprecated_string())\n        self.assertTrue(func.called)\n\n    def test_enrollment_report_features_csv(self):\n        \"\"\"\n        test to generate enrollment report.\n        enroll users, admin staff using registration codes.\n        \"\"\"\n        InvoiceTransaction.objects.create(\n            invoice=self.sale_invoice_1,\n            amount=self.sale_invoice_1.total_amount,\n            status='completed',\n            created_by=self.instructor,\n            last_modified_by=self.instructor\n        )\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            invoice=self.sale_invoice_1,\n            invoice_item=self.invoice_item,\n            mode_slug='honor'\n        )\n\n        admin_user = AdminFactory()\n        admin_cart = Order.get_cart_for_user(admin_user)\n        PaidCourseRegistration.add_to_order(admin_cart, self.course.id)\n        admin_cart.purchase()\n\n        # create a new user/student and enroll\n        # in the course using a registration code\n        # and then validates the generated detailed enrollment report\n        test_user = UserFactory()\n        self.register_with_redemption_code(test_user, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        UserProfileFactory.create(user=self.students[0], meta='{\"company\": \"asdasda\"}')\n\n        self.client.login(username=self.instructor.username, password='test')\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    def test_bulk_purchase_detailed_report(self):\n        \"\"\"\n        test to generate detailed enrollment report.\n        1 Purchase registration codes.\n        2 Enroll users via registration code.\n        3 Validate generated enrollment report.\n        \"\"\"\n        paid_course_reg_item = PaidCourseRegistration.add_to_order(self.cart, self.course.id)\n        # update the quantity of the cart item paid_course_reg_item\n        resp = self.client.post(\n            reverse('shoppingcart.views.update_user_cart', is_dashboard_endpoint=False),\n            {'ItemId': paid_course_reg_item.id, 'qty': '4'}\n        )\n        self.assertEqual(resp.status_code, 200)\n        # apply the coupon code to the item in the cart\n        resp = self.client.post(\n            reverse('shoppingcart.views.use_code', is_dashboard_endpoint=False),\n            {'code': self.coupon_code}\n        )\n        self.assertEqual(resp.status_code, 200)\n        self.cart.purchase()\n\n        course_reg_codes = CourseRegistrationCode.objects.filter(order=self.cart)\n        self.register_with_redemption_code(self.instructor, course_reg_codes[0].code)\n\n        test_user = UserFactory()\n        test_user_cart = Order.get_cart_for_user(test_user)\n        PaidCourseRegistration.add_to_order(test_user_cart, self.course.id)\n        test_user_cart.purchase()\n        InvoiceTransaction.objects.create(\n            invoice=self.sale_invoice_1,\n            amount=-self.sale_invoice_1.total_amount,\n            status='refunded',\n            created_by=self.instructor,\n            last_modified_by=self.instructor\n        )\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            invoice=self.sale_invoice_1,\n            invoice_item=self.invoice_item,\n            mode_slug='honor'\n        )\n\n        test_user1 = UserFactory()\n        self.register_with_redemption_code(test_user1, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    def test_create_registration_code_without_invoice_and_order(self):\n        \"\"\"\n        test generate detailed enrollment report,\n        used a registration codes which has been created via invoice or bulk\n        purchase scenario.\n        \"\"\"\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            mode_slug='honor'\n        )\n        test_user1 = UserFactory()\n        self.register_with_redemption_code(test_user1, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    def test_invoice_payment_is_still_pending_for_registration_codes(self):\n        \"\"\"\n        test generate enrollment report\n        enroll a user in a course using registration code\n        whose invoice has not been paid yet\n        \"\"\"\n        course_registration_code = CourseRegistrationCode.objects.create(\n            code='abcde',\n            course_id=self.course.id.to_deprecated_string(),\n            created_by=self.instructor,\n            invoice=self.sale_invoice_1,\n            invoice_item=self.invoice_item,\n            mode_slug='honor'\n        )\n\n        test_user1 = UserFactory()\n        self.register_with_redemption_code(test_user1, course_registration_code.code)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        url = reverse('get_enrollment_report', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        self.assertIn('The detailed enrollment report is being created.', response.content)\n\n    @patch.object(instructor.views.api, 'anonymous_id_for_user', Mock(return_value='42'))\n    @patch.object(instructor.views.api, 'unique_id_for_user', Mock(return_value='41'))\n    def test_get_anon_ids(self):\n        \"\"\"\n        Test the CSV output for the anonymized user ids.\n        \"\"\"\n        url = reverse('get_anon_ids', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(\n            '\"User ID\",\"Anonymized User ID\",\"Course Specific Anonymized User ID\"'\n            '\\n\"{user_id}\",\"41\",\"42\"\\n'.format(user_id=self.students[0].id)\n        ))\n        self.assertTrue(\n            body.endswith('\"{user_id}\",\"41\",\"42\"\\n'.format(user_id=self.students[-1].id))\n        )\n\n    def test_list_report_downloads(self):\n        url = reverse('list_report_downloads', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        with patch('instructor_task.models.LocalFSReportStore.links_for') as mock_links_for:\n            mock_links_for.return_value = [\n                ('mock_file_name_1', 'https://1.mock.url'),\n                ('mock_file_name_2', 'https://2.mock.url'),\n            ]\n            response = self.client.post(url, {})\n\n        expected_response = {\n            \"downloads\": [\n                {\n                    \"url\": \"https://1.mock.url\",\n                    \"link\": \"<a href=\\\"https://1.mock.url\\\">mock_file_name_1</a>\",\n                    \"name\": \"mock_file_name_1\"\n                },\n                {\n                    \"url\": \"https://2.mock.url\",\n                    \"link\": \"<a href=\\\"https://2.mock.url\\\">mock_file_name_2</a>\",\n                    \"name\": \"mock_file_name_2\"\n                }\n            ]\n        }\n        res_json = json.loads(response.content)\n        self.assertEqual(res_json, expected_response)\n\n    @ddt.data(*REPORTS_DATA)\n    @ddt.unpack\n    @valid_problem_location\n    def test_calculate_report_csv_success(self, report_type, instructor_api_endpoint, task_api_endpoint, extra_instructor_api_kwargs):\n        kwargs = {'course_id': unicode(self.course.id)}\n        kwargs.update(extra_instructor_api_kwargs)\n        url = reverse(instructor_api_endpoint, kwargs=kwargs)\n        success_status = \"The {report_type} report is being created.\".format(report_type=report_type)\n        if report_type == 'problem responses':\n            with patch(task_api_endpoint):\n                response = self.client.post(url, {'problem_location': ''})\n            self.assertIn(success_status, response.content)\n        else:\n            CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n            with patch(task_api_endpoint):\n                response = self.client.post(url, {})\n            self.assertIn(success_status, response.content)\n\n    @ddt.data(*EXECUTIVE_SUMMARY_DATA)\n    @ddt.unpack\n    def test_executive_summary_report_success(\n            self,\n            report_type,\n            instructor_api_endpoint,\n            task_api_endpoint,\n            extra_instructor_api_kwargs\n    ):\n        kwargs = {'course_id': unicode(self.course.id)}\n        kwargs.update(extra_instructor_api_kwargs)\n        url = reverse(instructor_api_endpoint, kwargs=kwargs)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        with patch(task_api_endpoint):\n            response = self.client.post(url, {})\n        success_status = \"The {report_type} report is being created.\" \\\n                         \" To view the status of the report, see Pending\" \\\n                         \" Tasks below\".format(report_type=report_type)\n        self.assertIn(success_status, response.content)\n\n    @ddt.data(*EXECUTIVE_SUMMARY_DATA)\n    @ddt.unpack\n    def test_executive_summary_report_already_running(\n            self,\n            report_type,\n            instructor_api_endpoint,\n            task_api_endpoint,\n            extra_instructor_api_kwargs\n    ):\n        kwargs = {'course_id': unicode(self.course.id)}\n        kwargs.update(extra_instructor_api_kwargs)\n        url = reverse(instructor_api_endpoint, kwargs=kwargs)\n\n        CourseFinanceAdminRole(self.course.id).add_users(self.instructor)\n        with patch(task_api_endpoint) as mock:\n            mock.side_effect = AlreadyRunningError()\n            response = self.client.post(url, {})\n        already_running_status = \"The {report_type} report is currently being created.\" \\\n                                 \" To view the status of the report, see Pending Tasks below.\" \\\n                                 \" You will be able to download the report\" \\\n                                 \" when it is\" \\\n                                 \" complete.\".format(report_type=report_type)\n        self.assertIn(already_running_status, response.content)\n\n    def test_get_ora2_responses_success(self):\n        url = reverse('export_ora2_data', kwargs={'course_id': unicode(self.course.id)})\n\n        with patch('instructor_task.api.submit_export_ora2_data') as mock_submit_ora2_task:\n            mock_submit_ora2_task.return_value = True\n            response = self.client.post(url, {})\n        success_status = \"The ORA data report is being generated.\"\n        self.assertIn(success_status, response.content)\n\n    def test_get_ora2_responses_already_running(self):\n        url = reverse('export_ora2_data', kwargs={'course_id': unicode(self.course.id)})\n\n        with patch('instructor_task.api.submit_export_ora2_data') as mock_submit_ora2_task:\n            mock_submit_ora2_task.side_effect = AlreadyRunningError()\n            response = self.client.post(url, {})\n        already_running_status = \"An ORA data report generation task is already in progress.\"\n        self.assertIn(already_running_status, response.content)\n\n    def test_get_student_progress_url(self):\n        \"\"\" Test that progress_url is in the successful response. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        data = {'unique_student_identifier': self.students[0].email.encode(\"utf-8\")}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200)\n        res_json = json.loads(response.content)\n        self.assertIn('progress_url', res_json)\n\n    def test_get_student_progress_url_from_uname(self):\n        \"\"\" Test that progress_url is in the successful response. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        data = {'unique_student_identifier': self.students[0].username.encode(\"utf-8\")}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200)\n        res_json = json.loads(response.content)\n        self.assertIn('progress_url', res_json)\n\n    def test_get_student_progress_url_noparams(self):\n        \"\"\" Test that the endpoint 404's without the required query params. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n    def test_get_student_progress_url_nostudent(self):\n        \"\"\" Test that the endpoint 400's when requesting an unknown email. \"\"\"\n        url = reverse('get_student_progress_url', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url)\n        self.assertEqual(response.status_code, 400)\n\n\n@attr('shard_1')\nclass TestInstructorAPIRegradeTask(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints whereby instructors can change student grades.\n    This includes resetting attempts and starting rescore tasks.\n\n    This test does NOT test whether the actions had an effect on the\n    database, that is the job of task tests and test_enrollment.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPIRegradeTask, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.problem_location = msk_from_problem_urlname(\n            cls.course.id,\n            'robot-some-problem-urlname'\n        )\n        cls.problem_urlname = cls.problem_location.to_deprecated_string()\n\n    def setUp(self):\n        super(TestInstructorAPIRegradeTask, self).setUp()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.student = UserFactory()\n        CourseEnrollment.enroll(self.student, self.course.id)\n\n        self.module_to_reset = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.problem_location,\n            state=json.dumps({'attempts': 10}),\n        )\n\n    def test_reset_student_attempts_deletall(self):\n        \"\"\" Make sure no one can delete all students state on a problem. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'all_students': True,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_reset_student_attempts_single(self):\n        \"\"\" Test reset single student attempts. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure problem attempts have been reset.\n        changed_module = StudentModule.objects.get(pk=self.module_to_reset.pk)\n        self.assertEqual(\n            json.loads(changed_module.state)['attempts'],\n            0\n        )\n\n    # mock out the function which should be called to execute the action.\n    @patch.object(instructor_task.api, 'submit_reset_problem_attempts_for_all_students')\n    def test_reset_student_attempts_all(self, act):\n        \"\"\" Test reset all student attempts. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    def test_reset_student_attempts_missingmodule(self):\n        \"\"\" Test reset for non-existant problem. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': 'robot-not-a-real-module',\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_reset_student_attempts_delete(self):\n        \"\"\" Test delete single student state. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure the module has been deleted\n        self.assertEqual(\n            StudentModule.objects.filter(\n                student=self.module_to_reset.student,\n                course_id=self.module_to_reset.course_id,\n                # module_id=self.module_to_reset.module_id,\n            ).count(),\n            0\n        )\n\n    def test_reset_student_attempts_nonsense(self):\n        \"\"\" Test failure with both unique_student_identifier and all_students. \"\"\"\n        url = reverse('reset_student_attempts', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    @patch.object(instructor_task.api, 'submit_rescore_problem_for_student')\n    def test_rescore_problem_single(self, act):\n        \"\"\" Test rescoring of a single student. \"\"\"\n        url = reverse('rescore_problem', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    @patch.object(instructor_task.api, 'submit_rescore_problem_for_student')\n    def test_rescore_problem_single_from_uname(self, act):\n        \"\"\" Test rescoring of a single student. \"\"\"\n        url = reverse('rescore_problem', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'unique_student_identifier': self.student.username,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    @patch.object(instructor_task.api, 'submit_rescore_problem_for_all_students')\n    def test_rescore_problem_all(self, act):\n        \"\"\" Test rescoring for all students. \"\"\"\n        url = reverse('rescore_problem', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'problem_to_reset': self.problem_urlname,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    @patch.dict(settings.FEATURES, {'ENTRANCE_EXAMS': True})\n    def test_course_has_entrance_exam_in_student_attempts_reset(self):\n        \"\"\" Test course has entrance exam id set while resetting attempts\"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'all_students': True,\n            'delete_module': False,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    @patch.dict(settings.FEATURES, {'ENTRANCE_EXAMS': True})\n    def test_rescore_entrance_exam_with_invalid_exam(self):\n        \"\"\" Test course has entrance exam id set while re-scoring. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n\n@attr('shard_1')\n@patch.dict(settings.FEATURES, {'ENTRANCE_EXAMS': True})\n@ddt.ddt\nclass TestEntranceExamInstructorAPIRegradeTask(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test endpoints whereby instructors can rescore student grades,\n    reset student attempts and delete state for entrance exam.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestEntranceExamInstructorAPIRegradeTask, cls).setUpClass()\n        cls.course = CourseFactory.create(\n            org='test_org',\n            course='test_course',\n            run='test_run',\n            entrance_exam_id='i4x://{}/{}/chapter/Entrance_exam'.format('test_org', 'test_course')\n        )\n        cls.course_with_invalid_ee = CourseFactory.create(entrance_exam_id='invalid_exam')\n\n        with cls.store.bulk_operations(cls.course.id, emit_signals=False):\n            cls.entrance_exam = ItemFactory.create(\n                parent=cls.course,\n                category='chapter',\n                display_name='Entrance exam'\n            )\n            subsection = ItemFactory.create(\n                parent=cls.entrance_exam,\n                category='sequential',\n                display_name='Subsection 1'\n            )\n            vertical = ItemFactory.create(\n                parent=subsection,\n                category='vertical',\n                display_name='Vertical 1'\n            )\n            cls.ee_problem_1 = ItemFactory.create(\n                parent=vertical,\n                category=\"problem\",\n                display_name=\"Exam Problem - Problem 1\"\n            )\n            cls.ee_problem_2 = ItemFactory.create(\n                parent=vertical,\n                category=\"problem\",\n                display_name=\"Exam Problem - Problem 2\"\n            )\n\n    def setUp(self):\n        super(TestEntranceExamInstructorAPIRegradeTask, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        # Add instructor to invalid ee course\n        CourseInstructorRole(self.course_with_invalid_ee.id).add_users(self.instructor)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.student = UserFactory()\n        CourseEnrollment.enroll(self.student, self.course.id)\n\n        ee_module_to_reset1 = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.ee_problem_1.location,\n            state=json.dumps({'attempts': 10, 'done': True}),\n        )\n        ee_module_to_reset2 = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.ee_problem_2.location,\n            state=json.dumps({'attempts': 10, 'done': True}),\n        )\n        self.ee_modules = [ee_module_to_reset1.module_state_key, ee_module_to_reset2.module_state_key]\n\n    @ddt.data(ModuleStoreEnum.Type.split, ModuleStoreEnum.Type.mongo)\n    def test_grade_histogram(self, store):\n        \"\"\"\n        Verify that a histogram has been created.\n        \"\"\"\n        course = CourseFactory.create(default_store=store)\n\n        usage_key = course.id.make_usage_key('problem', 'first_problem')\n        StudentModule.objects.create(\n            student_id=1,\n            grade=100,\n            module_state_key=usage_key\n        )\n        StudentModule.objects.create(\n            student_id=2,\n            grade=50,\n            module_state_key=usage_key\n        )\n\n        grades = grade_histogram(usage_key)\n        self.assertEqual(grades[0], (50.0, 1))\n        self.assertEqual(grades[1], (100.0, 1))\n\n    def test_reset_entrance_exam_student_attempts_deletall(self):\n        \"\"\" Make sure no one can delete all students state on entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'all_students': True,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_reset_entrance_exam_student_attempts_single(self):\n        \"\"\" Test reset single student attempts for entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure problem attempts have been reset.\n        changed_modules = StudentModule.objects.filter(module_state_key__in=self.ee_modules)\n        for changed_module in changed_modules:\n            self.assertEqual(\n                json.loads(changed_module.state)['attempts'],\n                0\n            )\n\n    # mock out the function which should be called to execute the action.\n    @patch.object(instructor_task.api, 'submit_reset_problem_attempts_in_entrance_exam')\n    def test_reset_entrance_exam_all_student_attempts(self, act):\n        \"\"\" Test reset all student attempts for entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    def test_reset_student_attempts_invalid_entrance_exam(self):\n        \"\"\" Test reset for invalid entrance exam. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course_with_invalid_ee.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_entrance_exam_sttudent_delete_state(self):\n        \"\"\" Test delete single student entrance exam state. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 200)\n        # make sure the module has been deleted\n        changed_modules = StudentModule.objects.filter(module_state_key__in=self.ee_modules)\n        self.assertEqual(changed_modules.count(), 0)\n\n    def test_entrance_exam_delete_state_with_staff(self):\n        \"\"\" Test entrance exam delete state failure with staff access. \"\"\"\n        self.client.logout()\n        staff_user = StaffFactory(course_key=self.course.id)\n        self.client.login(username=staff_user.username, password='test')\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n            'delete_module': True,\n        })\n        self.assertEqual(response.status_code, 403)\n\n    def test_entrance_exam_reset_student_attempts_nonsense(self):\n        \"\"\" Test failure with both unique_student_identifier and all_students. \"\"\"\n        url = reverse('reset_student_attempts_for_entrance_exam',\n                      kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    @patch.object(instructor_task.api, 'submit_rescore_entrance_exam_for_student')\n    def test_rescore_entrance_exam_single_student(self, act):\n        \"\"\" Test re-scoring of entrance exam for single student. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue(act.called)\n\n    def test_rescore_entrance_exam_all_student(self):\n        \"\"\" Test rescoring for all students. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 200)\n\n    def test_rescore_entrance_exam_all_student_and_single(self):\n        \"\"\" Test re-scoring with both all students and single student parameters. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n            'all_students': True,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_rescore_entrance_exam_with_invalid_exam(self):\n        \"\"\" Test re-scoring of entrance exam with invalid exam. \"\"\"\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course_with_invalid_ee.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_list_entrance_exam_instructor_tasks_student(self):\n        \"\"\" Test list task history for entrance exam AND student. \"\"\"\n        # create a re-score entrance exam task\n        url = reverse('rescore_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('list_entrance_exam_instructor_tasks', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        tasks = json.loads(response.content)['tasks']\n        self.assertEqual(len(tasks), 1)\n        self.assertEqual(tasks[0]['status'], _('Complete'))\n\n    def test_list_entrance_exam_instructor_tasks_all_student(self):\n        \"\"\" Test list task history for entrance exam AND all student. \"\"\"\n        url = reverse('list_entrance_exam_instructor_tasks', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        tasks = json.loads(response.content)['tasks']\n        self.assertEqual(len(tasks), 0)\n\n    def test_list_entrance_exam_instructor_with_invalid_exam_key(self):\n        \"\"\" Test list task history for entrance exam failure if course has invalid exam. \"\"\"\n        url = reverse('list_entrance_exam_instructor_tasks',\n                      kwargs={'course_id': unicode(self.course_with_invalid_ee.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_skip_entrance_exam_student(self):\n        \"\"\" Test skip entrance exam api for student. \"\"\"\n        # create a re-score entrance exam task\n        url = reverse('mark_student_can_skip_entrance_exam', kwargs={'course_id': unicode(self.course.id)})\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n        self.assertEqual(response.status_code, 200)\n        # check response\n        message = _('This student (%s) will skip the entrance exam.') % self.student.email\n        self.assertContains(response, message)\n\n        # post again with same student\n        response = self.client.post(url, {\n            'unique_student_identifier': self.student.email,\n        })\n\n        # This time response message should be different\n        message = _('This student (%s) is already allowed to skip the entrance exam.') % self.student.email\n        self.assertContains(response, message)\n\n\n@attr('shard_1')\n@patch('bulk_email.models.html_to_text', Mock(return_value='Mocking CourseEmail.text_message', autospec=True))\nclass TestInstructorSendEmail(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Checks that only instructors have access to email endpoints, and that\n    these endpoints are only accessible with courses that actually exist,\n    only with valid email messages.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorSendEmail, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        test_subject = u'\\u1234 test subject'\n        test_message = u'\\u6824 test message'\n        cls.full_test_message = {\n            'send_to': '[\"myself\", \"staff\"]',\n            'subject': test_subject,\n            'message': test_message,\n        }\n        BulkEmailFlag.objects.create(enabled=True, require_course_email_auth=False)\n\n    @classmethod\n    def tearDownClass(cls):\n        super(TestInstructorSendEmail, cls).tearDownClass()\n        BulkEmailFlag.objects.all().delete()\n\n    def setUp(self):\n        super(TestInstructorSendEmail, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def test_send_email_as_logged_in_instructor(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, self.full_test_message)\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_email_but_not_logged_in(self):\n        self.client.logout()\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, self.full_test_message)\n        self.assertEqual(response.status_code, 403)\n\n    def test_send_email_but_not_staff(self):\n        self.client.logout()\n        student = UserFactory()\n        self.client.login(username=student.username, password='test')\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, self.full_test_message)\n        self.assertEqual(response.status_code, 403)\n\n    def test_send_email_but_course_not_exist(self):\n        url = reverse('send_email', kwargs={'course_id': 'GarbageCourse/DNE/NoTerm'})\n        response = self.client.post(url, self.full_test_message)\n        self.assertNotEqual(response.status_code, 200)\n\n    def test_send_email_no_sendto(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'subject': 'test subject',\n            'message': 'test message',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_send_email_invalid_sendto(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'send_to': '[\"invalid_target\", \"staff\"]',\n            'subject': 'test subject',\n            'message': 'test message',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_send_email_no_subject(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'send_to': '[\"staff\"]',\n            'message': 'test message',\n        })\n        self.assertEqual(response.status_code, 400)\n\n    def test_send_email_no_message(self):\n        url = reverse('send_email', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'send_to': '[\"staff\"]',\n            'subject': 'test subject',\n        })\n        self.assertEqual(response.status_code, 400)\n\n\nclass MockCompletionInfo(object):\n    \"\"\"Mock for get_task_completion_info\"\"\"\n    times_called = 0\n\n    def mock_get_task_completion_info(self, *args):  # pylint: disable=unused-argument\n        \"\"\"Mock for get_task_completion_info\"\"\"\n        self.times_called += 1\n        if self.times_called % 2 == 0:\n            return True, 'Task Completed'\n        return False, 'Task Errored In Some Way'\n\n\n@attr('shard_1')\nclass TestInstructorAPITaskLists(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test instructor task list endpoint.\n    \"\"\"\n\n    class FakeTask(object):\n        \"\"\" Fake task object \"\"\"\n        FEATURES = [\n            'task_type',\n            'task_input',\n            'task_id',\n            'requester',\n            'task_state',\n            'created',\n            'status',\n            'task_message',\n            'duration_sec'\n        ]\n\n        def __init__(self, completion):\n            for feature in self.FEATURES:\n                setattr(self, feature, 'expected')\n            # created needs to be a datetime\n            self.created = datetime.datetime(2013, 10, 25, 11, 42, 35)\n            # set 'status' and 'task_message' attrs\n            success, task_message = completion()\n            if success:\n                self.status = \"Complete\"\n            else:\n                self.status = \"Incomplete\"\n            self.task_message = task_message\n            # Set 'task_output' attr, which will be parsed to the 'duration_sec' attr.\n            self.task_output = '{\"duration_ms\": 1035000}'\n            self.duration_sec = 1035000 / 1000.0\n\n        def make_invalid_output(self):\n            \"\"\"Munge task_output to be invalid json\"\"\"\n            self.task_output = 'HI MY NAME IS INVALID JSON'\n            # This should be given the value of 'unknown' if the task output\n            # can't be properly parsed\n            self.duration_sec = 'unknown'\n\n        def to_dict(self):\n            \"\"\" Convert fake task to dictionary representation. \"\"\"\n            attr_dict = {key: getattr(self, key) for key in self.FEATURES}\n            attr_dict['created'] = attr_dict['created'].isoformat()\n            return attr_dict\n\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorAPITaskLists, cls).setUpClass()\n        cls.course = CourseFactory.create(\n            entrance_exam_id='i4x://{}/{}/chapter/Entrance_exam'.format('test_org', 'test_course')\n        )\n        cls.problem_location = msk_from_problem_urlname(\n            cls.course.id,\n            'robot-some-problem-urlname'\n        )\n        cls.problem_urlname = cls.problem_location.to_deprecated_string()\n\n    def setUp(self):\n        super(TestInstructorAPITaskLists, self).setUp()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n        self.student = UserFactory()\n        CourseEnrollment.enroll(self.student, self.course.id)\n\n        self.module = StudentModule.objects.create(\n            student=self.student,\n            course_id=self.course.id,\n            module_state_key=self.problem_location,\n            state=json.dumps({'attempts': 10}),\n        )\n        mock_factory = MockCompletionInfo()\n        self.tasks = [self.FakeTask(mock_factory.mock_get_task_completion_info) for _ in xrange(7)]\n        self.tasks[-1].make_invalid_output()\n\n    @patch.object(instructor_task.api, 'get_running_instructor_tasks')\n    def test_list_instructor_tasks_running(self, act):\n        \"\"\" Test list of all running tasks. \"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_instructor_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.post(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n        self.assertEqual(actual_tasks, expected_tasks)\n\n    @patch.object(instructor_task.api, 'get_instructor_task_history')\n    def test_list_background_email_tasks(self, act):\n        \"\"\"Test list of background email tasks.\"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_background_email_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.post(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n        self.assertEqual(actual_tasks, expected_tasks)\n\n    @patch.object(instructor_task.api, 'get_instructor_task_history')\n    def test_list_instructor_tasks_problem(self, act):\n        \"\"\" Test list task history for problem. \"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_instructor_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.post(url, {\n                'problem_location_str': self.problem_urlname,\n            })\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n        self.assertEqual(actual_tasks, expected_tasks)\n\n    @patch.object(instructor_task.api, 'get_instructor_task_history')\n    def test_list_instructor_tasks_problem_student(self, act):\n        \"\"\" Test list task history for problem AND student. \"\"\"\n        act.return_value = self.tasks\n        url = reverse('list_instructor_tasks', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        mock_factory = MockCompletionInfo()\n        with patch('instructor.views.instructor_task_helpers.get_task_completion_info') as mock_completion_info:\n            mock_completion_info.side_effect = mock_factory.mock_get_task_completion_info\n            response = self.client.post(url, {\n                'problem_location_str': self.problem_urlname,\n                'unique_student_identifier': self.student.email,\n            })\n        self.assertEqual(response.status_code, 200)\n\n        # check response\n        self.assertTrue(act.called)\n        expected_tasks = [ftask.to_dict() for ftask in self.tasks]\n        actual_tasks = json.loads(response.content)['tasks']\n        for exp_task, act_task in zip(expected_tasks, actual_tasks):\n            self.assertDictEqual(exp_task, act_task)\n\n        self.assertEqual(actual_tasks, expected_tasks)\n\n\n@attr('shard_1')\n@patch.object(instructor_task.api, 'get_instructor_task_history', autospec=True)\nclass TestInstructorEmailContentList(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test the instructor email content history endpoint.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestInstructorEmailContentList, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestInstructorEmailContentList, self).setUp()\n\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n        self.tasks = {}\n        self.emails = {}\n        self.emails_info = {}\n\n    def setup_fake_email_info(self, num_emails, with_failures=False):\n        \"\"\" Initialize the specified number of fake emails \"\"\"\n        for email_id in range(num_emails):\n            num_sent = random.randint(1, 15401)\n            if with_failures:\n                failed = random.randint(1, 15401)\n            else:\n                failed = 0\n\n            self.tasks[email_id] = FakeContentTask(email_id, num_sent, failed, 'expected')\n            self.emails[email_id] = FakeEmail(email_id)\n            self.emails_info[email_id] = FakeEmailInfo(self.emails[email_id], num_sent, failed)\n\n    def get_matching_mock_email(self, **kwargs):\n        \"\"\" Returns the matching mock emails for the given id \"\"\"\n        email_id = kwargs.get('id', 0)\n        return self.emails[email_id]\n\n    def get_email_content_response(self, num_emails, task_history_request, with_failures=False):\n        \"\"\" Calls the list_email_content endpoint and returns the repsonse \"\"\"\n        self.setup_fake_email_info(num_emails, with_failures)\n        task_history_request.return_value = self.tasks.values()\n        url = reverse('list_email_content', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        with patch('instructor.views.api.CourseEmail.objects.get') as mock_email_info:\n            mock_email_info.side_effect = self.get_matching_mock_email\n            response = self.client.post(url, {})\n        self.assertEqual(response.status_code, 200)\n        return response\n\n    def check_emails_sent(self, num_emails, task_history_request, with_failures=False):\n        \"\"\" Tests sending emails with or without failures \"\"\"\n        response = self.get_email_content_response(num_emails, task_history_request, with_failures)\n        self.assertTrue(task_history_request.called)\n        expected_email_info = [email_info.to_dict() for email_info in self.emails_info.values()]\n        actual_email_info = json.loads(response.content)['emails']\n\n        self.assertEqual(len(actual_email_info), num_emails)\n        for exp_email, act_email in zip(expected_email_info, actual_email_info):\n            self.assertDictEqual(exp_email, act_email)\n\n        self.assertEqual(expected_email_info, actual_email_info)\n\n    def test_content_list_one_email(self, task_history_request):\n        \"\"\" Test listing of bulk emails when email list has one email \"\"\"\n        response = self.get_email_content_response(1, task_history_request)\n        self.assertTrue(task_history_request.called)\n        email_info = json.loads(response.content)['emails']\n\n        # Emails list should have one email\n        self.assertEqual(len(email_info), 1)\n\n        # Email content should be what's expected\n        expected_message = self.emails[0].html_message\n        returned_email_info = email_info[0]\n        received_message = returned_email_info[u'email'][u'html_message']\n        self.assertEqual(expected_message, received_message)\n\n    def test_content_list_no_emails(self, task_history_request):\n        \"\"\" Test listing of bulk emails when email list empty \"\"\"\n        response = self.get_email_content_response(0, task_history_request)\n        self.assertTrue(task_history_request.called)\n        email_info = json.loads(response.content)['emails']\n\n        # Emails list should be empty\n        self.assertEqual(len(email_info), 0)\n\n    def test_content_list_email_content_many(self, task_history_request):\n        \"\"\" Test listing of bulk emails sent large amount of emails \"\"\"\n        self.check_emails_sent(50, task_history_request)\n\n    def test_list_email_content_error(self, task_history_request):\n        \"\"\" Test handling of error retrieving email \"\"\"\n        invalid_task = FakeContentTask(0, 0, 0, 'test')\n        invalid_task.make_invalid_input()\n        task_history_request.return_value = [invalid_task]\n        url = reverse('list_email_content', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(task_history_request.called)\n        returned_email_info = json.loads(response.content)['emails']\n        self.assertEqual(len(returned_email_info), 1)\n        returned_info = returned_email_info[0]\n        for info in ['created', 'sent_to', 'email', 'number_sent', 'requester']:\n            self.assertEqual(returned_info[info], None)\n\n    def test_list_email_with_failure(self, task_history_request):\n        \"\"\" Test the handling of email task that had failures \"\"\"\n        self.check_emails_sent(1, task_history_request, True)\n\n    def test_list_many_emails_with_failures(self, task_history_request):\n        \"\"\" Test the handling of many emails with failures \"\"\"\n        self.check_emails_sent(50, task_history_request, True)\n\n    def test_list_email_with_no_successes(self, task_history_request):\n        task_info = FakeContentTask(0, 0, 10, 'expected')\n        email = FakeEmail(0)\n        email_info = FakeEmailInfo(email, 0, 10)\n        task_history_request.return_value = [task_info]\n        url = reverse('list_email_content', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        with patch('instructor.views.api.CourseEmail.objects.get') as mock_email_info:\n            mock_email_info.return_value = email\n            response = self.client.post(url, {})\n        self.assertEqual(response.status_code, 200)\n\n        self.assertTrue(task_history_request.called)\n        returned_info_list = json.loads(response.content)['emails']\n\n        self.assertEqual(len(returned_info_list), 1)\n        returned_info = returned_info_list[0]\n        expected_info = email_info.to_dict()\n        self.assertDictEqual(expected_info, returned_info)\n\n\n@attr('shard_1')\nclass TestInstructorAPIHelpers(TestCase):\n    \"\"\" Test helpers for instructor.api \"\"\"\n\n    def test_split_input_list(self):\n        strings = []\n        lists = []\n        strings.append(\n            \"Lorem@ipsum.dolor, sit@amet.consectetur\\nadipiscing@elit.Aenean\\r convallis@at.lacus\\r, ut@lacinia.Sed\")\n        lists.append(['Lorem@ipsum.dolor', 'sit@amet.consectetur', 'adipiscing@elit.Aenean', 'convallis@at.lacus',\n                      'ut@lacinia.Sed'])\n\n        for (stng, lst) in zip(strings, lists):\n            self.assertEqual(_split_input_list(stng), lst)\n\n    def test_split_input_list_unicode(self):\n        self.assertEqual(_split_input_list('robot@robot.edu, robot2@robot.edu'),\n                         ['robot@robot.edu', 'robot2@robot.edu'])\n        self.assertEqual(_split_input_list(u'robot@robot.edu, robot2@robot.edu'),\n                         ['robot@robot.edu', 'robot2@robot.edu'])\n        self.assertEqual(_split_input_list(u'robot@robot.edu, robot2@robot.edu'),\n                         [u'robot@robot.edu', 'robot2@robot.edu'])\n        scary_unistuff = unichr(40960) + u'abcd' + unichr(1972)\n        self.assertEqual(_split_input_list(scary_unistuff), [scary_unistuff])\n\n    def test_msk_from_problem_urlname(self):\n        course_id = SlashSeparatedCourseKey('MITx', '6.002x', '2013_Spring')\n        name = 'L2Node1'\n        output = 'i4x://MITx/6.002x/problem/L2Node1'\n        self.assertEqual(msk_from_problem_urlname(course_id, name).to_deprecated_string(), output)\n\n    @raises(ValueError)\n    def test_msk_from_problem_urlname_error(self):\n        args = ('notagoodcourse', 'L2Node1')\n        msk_from_problem_urlname(*args)\n\n\ndef get_extended_due(course, unit, user):\n    \"\"\"\n    Gets the overridden due date for the given user on the given unit.  Returns\n    `None` if there is no override set.\n    \"\"\"\n    try:\n        override = StudentFieldOverride.objects.get(\n            course_id=course.id,\n            student=user,\n            location=unit.location,\n            field='due'\n        )\n        return DATE_FIELD.from_json(json.loads(override.value))\n    except StudentFieldOverride.DoesNotExist:\n        return None\n\n\n@attr('shard_1')\nclass TestDueDateExtensions(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test data dumps for reporting.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestDueDateExtensions, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.due = datetime.datetime(2010, 5, 12, 2, 42, tzinfo=utc)\n\n        with cls.store.bulk_operations(cls.course.id, emit_signals=False):\n            cls.week1 = ItemFactory.create(due=cls.due)\n            cls.week2 = ItemFactory.create(due=cls.due)\n            cls.week3 = ItemFactory.create()  # No due date\n            cls.course.children = [\n                cls.week1.location.to_deprecated_string(),\n                cls.week2.location.to_deprecated_string(),\n                cls.week3.location.to_deprecated_string()\n            ]\n            cls.homework = ItemFactory.create(\n                parent_location=cls.week1.location,\n                due=cls.due\n            )\n            cls.week1.children = [cls.homework.location.to_deprecated_string()]\n\n    def setUp(self):\n        \"\"\"\n        Fixtures.\n        \"\"\"\n        super(TestDueDateExtensions, self).setUp()\n\n        user1 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week2.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week3.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user2 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user3 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        self.user1 = user1\n        self.user2 = user2\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def test_change_due_date(self):\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n            'due_datetime': '12/30/2013 00:00'\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(datetime.datetime(2013, 12, 30, 0, 0, tzinfo=utc),\n                         get_extended_due(self.course, self.week1, self.user1))\n\n    def test_change_to_invalid_due_date(self):\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n            'due_datetime': '01/01/2009 00:00'\n        })\n        self.assertEqual(response.status_code, 400, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week1, self.user1)\n        )\n\n    def test_change_nonexistent_due_date(self):\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'student': self.user1.username,\n            'url': self.week3.location.to_deprecated_string(),\n            'due_datetime': '12/30/2013 00:00'\n        })\n        self.assertEqual(response.status_code, 400, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week3, self.user1)\n        )\n\n    def test_reset_date(self):\n        self.test_change_due_date()\n        url = reverse('reset_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week1, self.user1)\n        )\n\n    def test_reset_nonexistent_extension(self):\n        url = reverse('reset_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n        })\n        self.assertEqual(response.status_code, 400, response.content)\n\n    def test_show_unit_extensions(self):\n        self.test_change_due_date()\n        url = reverse('show_unit_extensions',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'url': self.week1.location.to_deprecated_string()})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(json.loads(response.content), {\n            u'data': [{u'Extended Due Date': u'2013-12-30 00:00',\n                       u'Full Name': self.user1.profile.name,\n                       u'Username': self.user1.username}],\n            u'header': [u'Username', u'Full Name', u'Extended Due Date'],\n            u'title': u'Users with due date extensions for %s' %\n                      self.week1.display_name})\n\n    def test_show_student_extensions(self):\n        self.test_change_due_date()\n        url = reverse('show_student_extensions',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {'student': self.user1.username})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(json.loads(response.content), {\n            u'data': [{u'Extended Due Date': u'2013-12-30 00:00',\n                       u'Unit': self.week1.display_name}],\n            u'header': [u'Unit', u'Extended Due Date'],\n            u'title': u'Due date extensions for %s (%s)' % (\n                self.user1.profile.name, self.user1.username)})\n\n\n@attr('shard_1')\nclass TestDueDateExtensionsDeletedDate(ModuleStoreTestCase, LoginEnrollmentTestCase):\n    def setUp(self):\n        \"\"\"\n        Fixtures.\n        \"\"\"\n        super(TestDueDateExtensionsDeletedDate, self).setUp()\n\n        self.course = CourseFactory.create()\n        self.due = datetime.datetime(2010, 5, 12, 2, 42, tzinfo=utc)\n\n        with self.store.bulk_operations(self.course.id, emit_signals=False):\n            self.week1 = ItemFactory.create(due=self.due)\n            self.week2 = ItemFactory.create(due=self.due)\n            self.week3 = ItemFactory.create()  # No due date\n            self.course.children = [\n                self.week1.location.to_deprecated_string(),\n                self.week2.location.to_deprecated_string(),\n                self.week3.location.to_deprecated_string()\n            ]\n            self.homework = ItemFactory.create(\n                parent_location=self.week1.location,\n                due=self.due\n            )\n            self.week1.children = [self.homework.location.to_deprecated_string()]\n\n        user1 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week2.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.week3.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user1.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user2 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user2.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        user3 = UserFactory.create()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.week1.location).save()\n        StudentModule(\n            state='{}',\n            student_id=user3.id,\n            course_id=self.course.id,\n            module_state_key=self.homework.location).save()\n\n        self.user1 = user1\n        self.user2 = user2\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def test_reset_extension_to_deleted_date(self):\n        \"\"\"\n        Test that we can delete a due date extension after deleting the normal\n        due date, without causing an error.\n        \"\"\"\n\n        url = reverse('change_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n            'due_datetime': '12/30/2013 00:00'\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(datetime.datetime(2013, 12, 30, 0, 0, tzinfo=utc),\n                         get_extended_due(self.course, self.week1, self.user1))\n\n        self.week1.due = None\n        self.week1 = self.store.update_item(self.week1, self.user1.id)\n        # Now, week1's normal due date is deleted but the extension still exists.\n        url = reverse('reset_due_date', kwargs={'course_id': self.course.id.to_deprecated_string()})\n        response = self.client.post(url, {\n            'student': self.user1.username,\n            'url': self.week1.location.to_deprecated_string(),\n        })\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(\n            None,\n            get_extended_due(self.course, self.week1, self.user1)\n        )\n\n\n@attr('shard_1')\nclass TestCourseIssuedCertificatesData(SharedModuleStoreTestCase):\n    \"\"\"\n    Test data dumps for issued certificates.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestCourseIssuedCertificatesData, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestCourseIssuedCertificatesData, self).setUp()\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n\n    def generate_certificate(self, course_id, mode, status):\n        \"\"\"\n        Generate test certificate\n        \"\"\"\n        test_user = UserFactory()\n        GeneratedCertificateFactory.create(\n            user=test_user,\n            course_id=course_id,\n            mode=mode,\n            status=status\n        )\n\n    def test_certificates_features_against_status(self):\n        \"\"\"\n        Test certificates with status 'downloadable' should be in the response.\n        \"\"\"\n        url = reverse('get_issued_certificates', kwargs={'course_id': unicode(self.course.id)})\n        # firstly generating downloadable certificates with 'honor' mode\n        certificate_count = 3\n        for __ in xrange(certificate_count):\n            self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.generating)\n\n        response = self.client.post(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n        self.assertEqual(len(res_json['certificates']), 0)\n\n        # Certificates with status 'downloadable' should be in response.\n        self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)\n        response = self.client.post(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n        self.assertEqual(len(res_json['certificates']), 1)\n\n    def test_certificates_features_group_by_mode(self):\n        \"\"\"\n        Test for certificate csv features against mode. Certificates should be group by 'mode' in reponse.\n        \"\"\"\n        url = reverse('get_issued_certificates', kwargs={'course_id': unicode(self.course.id)})\n        # firstly generating downloadable certificates with 'honor' mode\n        certificate_count = 3\n        for __ in xrange(certificate_count):\n            self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)\n\n        response = self.client.post(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n        self.assertEqual(len(res_json['certificates']), 1)\n\n        # retrieve the first certificate from the list, there should be 3 certificates for 'honor' mode.\n        certificate = res_json['certificates'][0]\n        self.assertEqual(certificate.get('total_issued_certificate'), 3)\n        self.assertEqual(certificate.get('mode'), 'honor')\n        self.assertEqual(certificate.get('course_id'), str(self.course.id))\n\n        # Now generating downloadable certificates with 'verified' mode\n        for __ in xrange(certificate_count):\n            self.generate_certificate(\n                course_id=self.course.id,\n                mode='verified',\n                status=CertificateStatuses.downloadable\n            )\n\n        response = self.client.post(url)\n        res_json = json.loads(response.content)\n        self.assertIn('certificates', res_json)\n\n        # total certificate count should be 2 for 'verified' mode.\n        self.assertEqual(len(res_json['certificates']), 2)\n\n        # retrieve the second certificate from the list\n        certificate = res_json['certificates'][1]\n        self.assertEqual(certificate.get('total_issued_certificate'), 3)\n        self.assertEqual(certificate.get('mode'), 'verified')\n\n    def test_certificates_features_csv(self):\n        \"\"\"\n        Test for certificate csv features.\n        \"\"\"\n        url = reverse('get_issued_certificates', kwargs={'course_id': unicode(self.course.id)})\n        # firstly generating downloadable certificates with 'honor' mode\n        certificate_count = 3\n        for __ in xrange(certificate_count):\n            self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)\n\n        current_date = datetime.date.today().strftime(\"%B %d, %Y\")\n        response = self.client.get(url, {'csv': 'true'})\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        self.assertEqual(response['Content-Disposition'], 'attachment; filename={0}'.format('issued_certificates.csv'))\n        self.assertEqual(\n            response.content.strip(),\n            '\"CourseID\",\"Certificate Type\",\"Total Certificates Issued\",\"Date Report Run\"\\r\\n\"'\n            + str(self.course.id) + '\",\"honor\",\"3\",\"' + current_date + '\"'\n        )\n\n\n@attr('shard_1')\n@override_settings(REGISTRATION_CODE_LENGTH=8)\nclass TestCourseRegistrationCodes(SharedModuleStoreTestCase):\n    \"\"\"\n    Test data dumps for E-commerce Course Registration Codes.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestCourseRegistrationCodes, cls).setUpClass()\n        cls.course = CourseFactory.create()\n        cls.url = reverse(\n            'generate_registration_codes',\n            kwargs={'course_id': cls.course.id.to_deprecated_string()}\n        )\n\n    def setUp(self):\n        \"\"\"\n        Fixtures.\n        \"\"\"\n        super(TestCourseRegistrationCodes, self).setUp()\n\n        CourseModeFactory.create(course_id=self.course.id, min_price=50)\n        self.instructor = InstructorFactory(course_key=self.course.id)\n        self.client.login(username=self.instructor.username, password='test')\n        CourseSalesAdminRole(self.course.id).add_users(self.instructor)\n\n        data = {\n            'total_registration_codes': 12, 'company_name': 'Test Group', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street',\n            'address_line_2': '', 'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(self.url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        for i in range(5):\n            order = Order(user=self.instructor, status='purchased')\n            order.save()\n\n        # Spent(used) Registration Codes\n        for i in range(5):\n            i += 1\n            registration_code_redemption = RegistrationCodeRedemption(\n                registration_code_id=i,\n                redeemed_by=self.instructor\n            )\n            registration_code_redemption.save()\n\n    @override_settings(FINANCE_EMAIL='finance@example.com')\n    def test_finance_email_in_recipient_list_when_generating_registration_codes(self):\n        \"\"\"\n        Test to verify that the invoice will also be sent to the FINANCE_EMAIL when\n        generating registration codes\n        \"\"\"\n        url_reg_code = reverse('generate_registration_codes',\n                               kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 5, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 121.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': 'True'\n        }\n\n        response = self.client.post(url_reg_code, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        # check for the last mail.outbox, The FINANCE_EMAIL has been appended at the\n        # very end, when generating registration codes\n        self.assertEqual(mail.outbox[-1].to[0], 'finance@example.com')\n\n    def test_user_invoice_copy_preference(self):\n        \"\"\"\n        Test to remember user invoice copy preference\n        \"\"\"\n        url_reg_code = reverse('generate_registration_codes',\n                               kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 5, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 121.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': 'True'\n        }\n\n        # user invoice copy preference will be saved in api user preference; model\n        response = self.client.post(url_reg_code, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n\n        # get user invoice copy preference.\n        url_user_invoice_preference = reverse('get_user_invoice_preference',\n                                              kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        response = self.client.post(url_user_invoice_preference, data)\n        result = json.loads(response.content)\n        self.assertEqual(result['invoice_copy'], True)\n\n        # updating the user invoice copy preference during code generation flow\n        data['invoice'] = ''\n        response = self.client.post(url_reg_code, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n\n        # get user invoice copy preference.\n        url_user_invoice_preference = reverse('get_user_invoice_preference',\n                                              kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        response = self.client.post(url_user_invoice_preference, data)\n        result = json.loads(response.content)\n        self.assertEqual(result['invoice_copy'], False)\n\n    def test_generate_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the generated course registration codes\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 15, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 17)\n\n    def test_generate_course_registration_with_redeem_url_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the generated course registration codes\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 15, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 17)\n        rows = body.split('\\n')\n        index = 1\n        while index < len(rows):\n            if rows[index]:\n                row_data = rows[index].split(',')\n                code = row_data[0].replace('\"', '')\n                self.assertTrue(row_data[1].startswith('\"http')\n                                and row_data[1].endswith('/shoppingcart/register/redeem/{0}/\"'.format(code)))\n            index += 1\n\n    @patch.object(instructor.views.api, 'random_code_generator',\n                  Mock(side_effect=['first', 'second', 'third', 'fourth']))\n    def test_generate_course_registration_codes_matching_existing_coupon_code(self):\n        \"\"\"\n        Test the generated course registration code is already in the Coupon Table\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        coupon = Coupon(code='first', course_id=self.course.id.to_deprecated_string(), created_by=self.instructor)\n        coupon.save()\n        data = {\n            'total_registration_codes': 3, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 5)  # 1 for headers, 1 for new line at the end and 3 for the actual data\n\n    @patch.object(instructor.views.api, 'random_code_generator',\n                  Mock(side_effect=['first', 'first', 'second', 'third']))\n    def test_generate_course_registration_codes_integrity_error(self):\n        \"\"\"\n       Test for the Integrity error against the generated code\n        \"\"\"\n        url = reverse('generate_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {\n            'total_registration_codes': 2, 'company_name': 'Test Group', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 4)\n\n    def test_spent_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the spent course registration codes\n        \"\"\"\n        url = reverse('spent_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {'spent_company_name': ''}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n\n        self.assertEqual(len(body.split('\\n')), 7)\n\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'unit_price': 122.45, 'company_contact_email': 'Test@company.com', 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        for i in range(9):\n            order = Order(user=self.instructor, status='purchased')\n            order.save()\n\n        # Spent(used) Registration Codes\n        for i in range(9):\n            i += 13\n            registration_code_redemption = RegistrationCodeRedemption(\n                registration_code_id=i,\n                redeemed_by=self.instructor\n            )\n            registration_code_redemption.save()\n\n        data = {'spent_company_name': 'Group Alpha'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 11)\n\n    def test_active_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the active course registration codes\n        \"\"\"\n        url = reverse('active_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n\n        data = {'active_company_name': ''}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 9)\n\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        data = {'active_company_name': 'Group Alpha'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 11)\n\n    def test_get_all_course_registration_codes_csv(self):\n        \"\"\"\n        Test to generate a response of all the course registration codes\n        \"\"\"\n        url = reverse(\n            'get_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {'download_company_name': ''}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 14)\n\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        data = {'download_company_name': 'Group Alpha'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n        self.assertEqual(len(body.split('\\n')), 11)\n\n    def test_pdf_file_throws_exception(self):\n        \"\"\"\n        test to mock the pdf file generation throws an exception\n        when generating registration codes.\n        \"\"\"\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n        data = {\n            'total_registration_codes': 9, 'company_name': 'Group Alpha', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': ''\n        }\n        with patch.object(PDFInvoice, 'generate_pdf', side_effect=Exception):\n            response = self.client.post(generate_code_url, data)\n            self.assertEqual(response.status_code, 200, response.content)\n\n    def test_get_codes_with_sale_invoice(self):\n        \"\"\"\n        Test to generate a response of all the course registration codes\n        \"\"\"\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 5.5, 'company_name': 'Group Invoice', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 122.45, 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': True\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 200, response.content)\n\n        url = reverse('get_registration_codes',\n                      kwargs={'course_id': self.course.id.to_deprecated_string()})\n        data = {'download_company_name': 'Group Invoice'}\n        response = self.client.post(url, data)\n        self.assertEqual(response.status_code, 200, response.content)\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_CSV_HEADER))\n\n    def test_with_invalid_unit_price(self):\n        \"\"\"\n        Test to generate a response of all the course registration codes\n        \"\"\"\n        generate_code_url = reverse(\n            'generate_registration_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n\n        data = {\n            'total_registration_codes': 10, 'company_name': 'Group Invoice', 'company_contact_name': 'Test@company.com',\n            'company_contact_email': 'Test@company.com', 'unit_price': 'invalid', 'recipient_name': 'Test123',\n            'recipient_email': 'test@123.com', 'address_line_1': 'Portland Street', 'address_line_2': '',\n            'address_line_3': '', 'city': '', 'state': '', 'zip': '', 'country': '',\n            'customer_reference_number': '123A23F', 'internal_reference': '', 'invoice': True\n        }\n\n        response = self.client.post(generate_code_url, data, **{'HTTP_HOST': 'localhost'})\n        self.assertEqual(response.status_code, 400, response.content)\n        self.assertIn('Could not parse amount as', response.content)\n\n    def test_get_historical_coupon_codes(self):\n        \"\"\"\n        Test to download a response of all the active coupon codes\n        \"\"\"\n        get_coupon_code_url = reverse(\n            'get_coupon_codes', kwargs={'course_id': self.course.id.to_deprecated_string()}\n        )\n        for i in range(10):\n            coupon = Coupon(\n                code='test_code{0}'.format(i), description='test_description', course_id=self.course.id,\n                percentage_discount='{0}'.format(i), created_by=self.instructor, is_active=True\n            )\n            coupon.save()\n\n        #now create coupons with the expiration dates\n        for i in range(5):\n            coupon = Coupon(\n                code='coupon{0}'.format(i), description='test_description', course_id=self.course.id,\n                percentage_discount='{0}'.format(i), created_by=self.instructor, is_active=True,\n                expiration_date=datetime.datetime.now(pytz.UTC) + datetime.timedelta(days=2)\n            )\n            coupon.save()\n\n        response = self.client.post(get_coupon_code_url)\n        self.assertEqual(response.status_code, 200, response.content)\n        # filter all the coupons\n        for coupon in Coupon.objects.all():\n            self.assertIn(\n                '\"{coupon_code}\",\"{course_id}\",\"{discount}\",\"{description}\",\"{expiration_date}\",\"{is_active}\",'\n                '\"{code_redeemed_count}\",\"{total_discounted_seats}\",\"{total_discounted_amount}\"'.format(\n                    coupon_code=coupon.code,\n                    course_id=coupon.course_id,\n                    discount=coupon.percentage_discount,\n                    description=coupon.description,\n                    expiration_date=coupon.display_expiry_date,\n                    is_active=coupon.is_active,\n                    code_redeemed_count=\"0\",\n                    total_discounted_seats=\"0\",\n                    total_discounted_amount=\"0\",\n                ), response.content\n            )\n\n        self.assertEqual(response['Content-Type'], 'text/csv')\n        body = response.content.replace('\\r', '')\n        self.assertTrue(body.startswith(EXPECTED_COUPON_CSV_HEADER))\n\n\n@attr('shard_1')\nclass TestBulkCohorting(SharedModuleStoreTestCase):\n    \"\"\"\n    Test adding users to cohorts in bulk via CSV upload.\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super(TestBulkCohorting, cls).setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super(TestBulkCohorting, self).setUp()\n        self.staff_user = StaffFactory(course_key=self.course.id)\n        self.non_staff_user = UserFactory.create()\n        self.tempdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.tempdir)\n\n    def call_add_users_to_cohorts(self, csv_data, suffix='.csv'):\n        \"\"\"\n        Call `add_users_to_cohorts` with a file generated from `csv_data`.\n        \"\"\"\n        # this temporary file will be removed in `self.tearDown()`\n        __, file_name = tempfile.mkstemp(suffix=suffix, dir=self.tempdir)\n        with open(file_name, 'w') as file_pointer:\n            file_pointer.write(csv_data.encode('utf-8'))\n        with open(file_name, 'r') as file_pointer:\n            url = reverse('add_users_to_cohorts', kwargs={'course_id': unicode(self.course.id)})\n            return self.client.post(url, {'uploaded-file': file_pointer})\n\n    def expect_error_on_file_content(self, file_content, error, file_suffix='.csv'):\n        \"\"\"\n        Verify that we get the error we expect for a given file input.\n        \"\"\"\n        self.client.login(username=self.staff_user.username, password='test')\n        response = self.call_add_users_to_cohorts(file_content, suffix=file_suffix)\n        self.assertEqual(response.status_code, 400)\n        result = json.loads(response.content)\n        self.assertEqual(result['error'], error)\n\n    def verify_success_on_file_content(self, file_content, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that `addd_users_to_cohorts` successfully validates the\n        file content, uploads the input file, and triggers the\n        background task.\n        \"\"\"\n        mock_store_upload.return_value = (None, 'fake_file_name.csv')\n        self.client.login(username=self.staff_user.username, password='test')\n        response = self.call_add_users_to_cohorts(file_content)\n        self.assertEqual(response.status_code, 204)\n        self.assertTrue(mock_store_upload.called)\n        self.assertTrue(mock_cohort_task.called)\n\n    def test_no_cohort_field(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        included a cohort field in the uploaded CSV.\n        \"\"\"\n        self.expect_error_on_file_content(\n            'username,email\\n', \"The file must contain a 'cohort' column containing cohort names.\"\n        )\n\n    def test_no_username_or_email_field(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        included a username or email field in the uploaded CSV.\n        \"\"\"\n        self.expect_error_on_file_content(\n            'cohort\\n', \"The file must contain a 'username' column, an 'email' column, or both.\"\n        )\n\n    def test_empty_csv(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        included any data in the uploaded CSV.\n        \"\"\"\n        self.expect_error_on_file_content(\n            '', \"The file must contain a 'cohort' column containing cohort names.\"\n        )\n\n    def test_wrong_extension(self):\n        \"\"\"\n        Verify that we get a descriptive verification error when we haven't\n        uploaded a file with a '.csv' extension.\n        \"\"\"\n        self.expect_error_on_file_content(\n            '', \"The file must end with the extension '.csv'.\", file_suffix='.notcsv'\n        )\n\n    def test_non_staff_no_access(self):\n        \"\"\"\n        Verify that we can't access the view when we aren't a staff user.\n        \"\"\"\n        self.client.login(username=self.non_staff_user.username, password='test')\n        response = self.call_add_users_to_cohorts('')\n        self.assertEqual(response.status_code, 403)\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_username(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call a background task when\n        the CSV has username and cohort columns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,cohort\\nfoo_username,bar_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_email(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when the CSV has email and cohort columns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'email,cohort\\nfoo_email,bar_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_username_and_email(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when the CSV has username, email and cohort columns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,email,cohort\\nfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_carriage_return(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when lines in the CSV are delimited by carriage returns.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,email,cohort\\rfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task\n        )\n\n    @patch('instructor.views.api.instructor_task.api.submit_cohort_students')\n    @patch('instructor.views.api.store_uploaded_file')\n    def test_success_carriage_return_line_feed(self, mock_store_upload, mock_cohort_task):\n        \"\"\"\n        Verify that we store the input CSV and call the cohorting background\n        task when lines in the CSV are delimited by carriage returns and line\n        feeds.\n        \"\"\"\n        self.verify_success_on_file_content(\n            'username,email,cohort\\r\\nfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task\n        )\n", "\"\"\"\nInstructor Dashboard API views\n\nJSON views which the instructor dashboard requests.\n\nMany of these GETs may become PUTs in the future.\n\"\"\"\nimport StringIO\nimport json\nimport logging\nimport re\nimport time\nfrom django.conf import settings\nfrom django.views.decorators.csrf import ensure_csrf_cookie, csrf_exempt\nfrom django.views.decorators.http import require_POST, require_http_methods\nfrom django.views.decorators.cache import cache_control\nfrom django.core.exceptions import ValidationError, PermissionDenied\nfrom django.core.mail.message import EmailMessage\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.db import IntegrityError, transaction\nfrom django.core.urlresolvers import reverse\nfrom django.core.validators import validate_email\nfrom django.utils.translation import ugettext as _\nfrom django.http import HttpResponse, HttpResponseBadRequest, HttpResponseForbidden, HttpResponseNotFound\nfrom django.utils.html import strip_tags\nfrom django.shortcuts import redirect\nimport string\nimport random\nimport unicodecsv\nimport decimal\nfrom student import auth\nfrom student.roles import GlobalStaff, CourseSalesAdminRole, CourseFinanceAdminRole\nfrom util.file import (\n    store_uploaded_file, course_and_time_based_filename_generator,\n    FileValidationException, UniversalNewlineIterator\n)\nfrom util.json_request import JsonResponse, JsonResponseBadRequest\nfrom instructor.views.instructor_task_helpers import extract_email_features, extract_task_features\n\nfrom microsite_configuration import microsite\n\nfrom courseware.access import has_access\nfrom courseware.courses import get_course_with_access, get_course_by_id\nfrom django.contrib.auth.models import User\nfrom django_comment_client.utils import has_forum_access\nfrom django_comment_common.models import (\n    Role,\n    FORUM_ROLE_ADMINISTRATOR,\n    FORUM_ROLE_MODERATOR,\n    FORUM_ROLE_COMMUNITY_TA,\n)\nfrom edxmako.shortcuts import render_to_string\nfrom courseware.models import StudentModule\nfrom shoppingcart.models import (\n    Coupon,\n    CourseRegistrationCode,\n    RegistrationCodeRedemption,\n    Invoice,\n    CourseMode,\n    CourseRegistrationCodeInvoiceItem,\n)\nfrom student.models import (\n    CourseEnrollment, unique_id_for_user, anonymous_id_for_user,\n    UserProfile, Registration, EntranceExamConfiguration,\n    ManualEnrollmentAudit, UNENROLLED_TO_ALLOWEDTOENROLL, ALLOWEDTOENROLL_TO_ENROLLED,\n    ENROLLED_TO_ENROLLED, ENROLLED_TO_UNENROLLED, UNENROLLED_TO_ENROLLED,\n    UNENROLLED_TO_UNENROLLED, ALLOWEDTOENROLL_TO_UNENROLLED, DEFAULT_TRANSITION_STATE\n)\nimport instructor_task.api\nfrom instructor_task.api_helper import AlreadyRunningError\nfrom instructor_task.models import ReportStore\nimport instructor.enrollment as enrollment\nfrom instructor.enrollment import (\n    get_user_email_language,\n    enroll_email,\n    send_mail_to_student,\n    get_email_params,\n    send_beta_role_email,\n    unenroll_email,\n)\nfrom instructor.access import list_with_level, allow_access, revoke_access, ROLES, update_forum_role\nimport instructor_analytics.basic\nimport instructor_analytics.distributions\nimport instructor_analytics.csvs\nimport csv\nfrom openedx.core.djangoapps.user_api.preferences.api import get_user_preference, set_user_preference\nfrom openedx.core.djangolib.markup import HTML, Text\nfrom instructor.views import INVOICE_KEY\n\nfrom submissions import api as sub_api  # installed from the edx-submissions repository\n\nfrom certificates import api as certs_api\nfrom certificates.models import CertificateWhitelist, GeneratedCertificate, CertificateStatuses, CertificateInvalidation\n\nfrom bulk_email.models import CourseEmail, BulkEmailFlag\nfrom student.models import get_user_by_username_or_email\n\nfrom .tools import (\n    dump_student_extensions,\n    dump_module_extensions,\n    find_unit,\n    get_student_from_identifier,\n    require_student_from_identifier,\n    handle_dashboard_error,\n    parse_datetime,\n    set_due_date_extension,\n    strip_if_string,\n)\nfrom opaque_keys.edx.keys import CourseKey, UsageKey\nfrom opaque_keys.edx.locations import SlashSeparatedCourseKey\nfrom opaque_keys import InvalidKeyError\nfrom openedx.core.djangoapps.course_groups.cohorts import is_course_cohorted\nfrom openedx.core.djangoapps.theming import helpers as theming_helpers\n\nlog = logging.getLogger(__name__)\n\n\ndef common_exceptions_400(func):\n    \"\"\"\n    Catches common exceptions and renders matching 400 errors.\n    (decorator without arguments)\n    \"\"\"\n    def wrapped(request, *args, **kwargs):  # pylint: disable=missing-docstring\n        use_json = (request.is_ajax() or\n                    request.META.get(\"HTTP_ACCEPT\", \"\").startswith(\"application/json\"))\n        try:\n            return func(request, *args, **kwargs)\n        except User.DoesNotExist:\n            message = _(\"User does not exist.\")\n            if use_json:\n                return JsonResponse({\"error\": message}, 400)\n            else:\n                return HttpResponseBadRequest(message)\n        except AlreadyRunningError:\n            message = _(\"Task is already running.\")\n            if use_json:\n                return JsonResponse({\"error\": message}, 400)\n            else:\n                return HttpResponseBadRequest(message)\n    return wrapped\n\n\ndef require_post_params(*args, **kwargs):\n    \"\"\"\n    Checks for required parameters or renders a 400 error.\n    (decorator with arguments)\n\n    `args` is a *list of required POST parameter names.\n    `kwargs` is a **dict of required POST parameter names\n        to string explanations of the parameter\n    \"\"\"\n    required_params = []\n    required_params += [(arg, None) for arg in args]\n    required_params += [(key, kwargs[key]) for key in kwargs]\n    # required_params = e.g. [('action', 'enroll or unenroll'), ['emails', None]]\n\n    def decorator(func):  # pylint: disable=missing-docstring\n        def wrapped(*args, **kwargs):  # pylint: disable=missing-docstring\n            request = args[0]\n\n            error_response_data = {\n                'error': 'Missing required query parameter(s)',\n                'parameters': [],\n                'info': {},\n            }\n\n            for (param, extra) in required_params:\n                default = object()\n                if request.POST.get(param, default) == default:\n                    error_response_data['parameters'].append(param)\n                    error_response_data['info'][param] = extra\n\n            if len(error_response_data['parameters']) > 0:\n                return JsonResponse(error_response_data, status=400)\n            else:\n                return func(*args, **kwargs)\n        return wrapped\n    return decorator\n\n\ndef require_level(level):\n    \"\"\"\n    Decorator with argument that requires an access level of the requesting\n    user. If the requirement is not satisfied, returns an\n    HttpResponseForbidden (403).\n\n    Assumes that request is in args[0].\n    Assumes that course_id is in kwargs['course_id'].\n\n    `level` is in ['instructor', 'staff']\n    if `level` is 'staff', instructors will also be allowed, even\n        if they are not in the staff group.\n    \"\"\"\n    if level not in ['instructor', 'staff']:\n        raise ValueError(\"unrecognized level '{}'\".format(level))\n\n    def decorator(func):  # pylint: disable=missing-docstring\n        def wrapped(*args, **kwargs):  # pylint: disable=missing-docstring\n            request = args[0]\n            course = get_course_by_id(CourseKey.from_string(kwargs['course_id']))\n\n            if has_access(request.user, level, course):\n                return func(*args, **kwargs)\n            else:\n                return HttpResponseForbidden()\n        return wrapped\n    return decorator\n\n\ndef require_global_staff(func):\n    \"\"\"View decorator that requires that the user have global staff permissions. \"\"\"\n    def wrapped(request, *args, **kwargs):  # pylint: disable=missing-docstring\n        if GlobalStaff().has_user(request.user):\n            return func(request, *args, **kwargs)\n        else:\n            return HttpResponseForbidden(\n                u\"Must be {platform_name} staff to perform this action.\".format(\n                    platform_name=settings.PLATFORM_NAME\n                )\n            )\n    return wrapped\n\n\ndef require_sales_admin(func):\n    \"\"\"\n    Decorator for checking sales administrator access before executing an HTTP endpoint. This decorator\n    is designed to be used for a request based action on a course. It assumes that there will be a\n    request object as well as a course_id attribute to leverage to check course level privileges.\n\n    If the user does not have privileges for this operation, this will return HttpResponseForbidden (403).\n    \"\"\"\n    def wrapped(request, course_id):  # pylint: disable=missing-docstring\n\n        try:\n            course_key = CourseKey.from_string(course_id)\n        except InvalidKeyError:\n            log.error(u\"Unable to find course with course key %s\", course_id)\n            return HttpResponseNotFound()\n\n        access = auth.user_has_role(request.user, CourseSalesAdminRole(course_key))\n\n        if access:\n            return func(request, course_id)\n        else:\n            return HttpResponseForbidden()\n    return wrapped\n\n\ndef require_finance_admin(func):\n    \"\"\"\n    Decorator for checking finance administrator access before executing an HTTP endpoint. This decorator\n    is designed to be used for a request based action on a course. It assumes that there will be a\n    request object as well as a course_id attribute to leverage to check course level privileges.\n\n    If the user does not have privileges for this operation, this will return HttpResponseForbidden (403).\n    \"\"\"\n    def wrapped(request, course_id):  # pylint: disable=missing-docstring\n\n        try:\n            course_key = CourseKey.from_string(course_id)\n        except InvalidKeyError:\n            log.error(u\"Unable to find course with course key %s\", course_id)\n            return HttpResponseNotFound()\n\n        access = auth.user_has_role(request.user, CourseFinanceAdminRole(course_key))\n\n        if access:\n            return func(request, course_id)\n        else:\n            return HttpResponseForbidden()\n    return wrapped\n\n\nEMAIL_INDEX = 0\nUSERNAME_INDEX = 1\nNAME_INDEX = 2\nCOUNTRY_INDEX = 3\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef register_and_enroll_students(request, course_id):  # pylint: disable=too-many-statements\n    \"\"\"\n    Create new account and Enroll students in this course.\n    Passing a csv file that contains a list of students.\n    Order in csv should be the following email = 0; username = 1; name = 2; country = 3.\n    Requires staff access.\n\n    -If the email address and username already exists and the user is enrolled in the course,\n    do nothing (including no email gets sent out)\n\n    -If the email address already exists, but the username is different,\n    match on the email address only and continue to enroll the user in the course using the email address\n    as the matching criteria. Note the change of username as a warning message (but not a failure). Send a standard enrollment email\n    which is the same as the existing manual enrollment\n\n    -If the username already exists (but not the email), assume it is a different user and fail to create the new account.\n     The failure will be messaged in a response in the browser.\n    \"\"\"\n\n    if not microsite.get_value('ALLOW_AUTOMATED_SIGNUPS', settings.FEATURES.get('ALLOW_AUTOMATED_SIGNUPS', False)):\n        return HttpResponseForbidden()\n\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    warnings = []\n    row_errors = []\n    general_errors = []\n\n    # for white labels we use 'shopping cart' which uses CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG as\n    # course mode for creating course enrollments.\n    if CourseMode.is_white_label(course_id):\n        course_mode = CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG\n    else:\n        course_mode = None\n\n    if 'students_list' in request.FILES:\n        students = []\n\n        try:\n            upload_file = request.FILES.get('students_list')\n            if upload_file.name.endswith('.csv'):\n                students = [row for row in csv.reader(upload_file.read().splitlines())]\n                course = get_course_by_id(course_id)\n            else:\n                general_errors.append({\n                    'username': '', 'email': '',\n                    'response': _('Make sure that the file you upload is in CSV format with no extraneous characters or rows.')\n                })\n\n        except Exception:  # pylint: disable=broad-except\n            general_errors.append({\n                'username': '', 'email': '', 'response': _('Could not read uploaded file.')\n            })\n        finally:\n            upload_file.close()\n\n        generated_passwords = []\n        row_num = 0\n        for student in students:\n            row_num = row_num + 1\n\n            # verify that we have exactly four columns in every row but allow for blank lines\n            if len(student) != 4:\n                if len(student) > 0:\n                    general_errors.append({\n                        'username': '',\n                        'email': '',\n                        'response': _('Data in row #{row_num} must have exactly four columns: email, username, full name, and country').format(row_num=row_num)\n                    })\n                continue\n\n            # Iterate each student in the uploaded csv file.\n            email = student[EMAIL_INDEX]\n            username = student[USERNAME_INDEX]\n            name = student[NAME_INDEX]\n            country = student[COUNTRY_INDEX][:2]\n\n            email_params = get_email_params(course, True, secure=request.is_secure())\n            try:\n                validate_email(email)  # Raises ValidationError if invalid\n            except ValidationError:\n                row_errors.append({\n                    'username': username, 'email': email, 'response': _('Invalid email {email_address}.').format(email_address=email)})\n            else:\n                if User.objects.filter(email=email).exists():\n                    # Email address already exists. assume it is the correct user\n                    # and just register the user in the course and send an enrollment email.\n                    user = User.objects.get(email=email)\n\n                    # see if it is an exact match with email and username\n                    # if it's not an exact match then just display a warning message, but continue onwards\n                    if not User.objects.filter(email=email, username=username).exists():\n                        warning_message = _(\n                            'An account with email {email} exists but the provided username {username} '\n                            'is different. Enrolling anyway with {email}.'\n                        ).format(email=email, username=username)\n\n                        warnings.append({\n                            'username': username, 'email': email, 'response': warning_message\n                        })\n                        log.warning(u'email %s already exist', email)\n                    else:\n                        log.info(\n                            u\"user already exists with username '%s' and email '%s'\",\n                            username,\n                            email\n                        )\n\n                    # enroll a user if it is not already enrolled.\n                    if not CourseEnrollment.is_enrolled(user, course_id):\n                        # Enroll user to the course and add manual enrollment audit trail\n                        create_manual_course_enrollment(\n                            user=user,\n                            course_id=course_id,\n                            mode=course_mode,\n                            enrolled_by=request.user,\n                            reason='Enrolling via csv upload',\n                            state_transition=UNENROLLED_TO_ENROLLED,\n                        )\n                        enroll_email(course_id=course_id, student_email=email, auto_enroll=True, email_students=True, email_params=email_params)\n                else:\n                    # This email does not yet exist, so we need to create a new account\n                    # If username already exists in the database, then create_and_enroll_user\n                    # will raise an IntegrityError exception.\n                    password = generate_unique_password(generated_passwords)\n                    errors = create_and_enroll_user(\n                        email, username, name, country, password, course_id, course_mode, request.user, email_params\n                    )\n                    row_errors.extend(errors)\n\n    else:\n        general_errors.append({\n            'username': '', 'email': '', 'response': _('File is not attached.')\n        })\n\n    results = {\n        'row_errors': row_errors,\n        'general_errors': general_errors,\n        'warnings': warnings\n    }\n    return JsonResponse(results)\n\n\ndef generate_random_string(length):\n    \"\"\"\n    Create a string of random characters of specified length\n    \"\"\"\n    chars = [\n        char for char in string.ascii_uppercase + string.digits + string.ascii_lowercase\n        if char not in 'aAeEiIoOuU1l'\n    ]\n\n    return string.join((random.choice(chars) for __ in range(length)), '')\n\n\ndef generate_unique_password(generated_passwords, password_length=12):\n    \"\"\"\n    generate a unique password for each student.\n    \"\"\"\n\n    password = generate_random_string(password_length)\n    while password in generated_passwords:\n        password = generate_random_string(password_length)\n\n    generated_passwords.append(password)\n\n    return password\n\n\ndef create_user_and_user_profile(email, username, name, country, password):\n    \"\"\"\n    Create a new user, add a new Registration instance for letting user verify its identity and create a user profile.\n\n    :param email: user's email address\n    :param username: user's username\n    :param name: user's name\n    :param country: user's country\n    :param password: user's password\n\n    :return: User instance of the new user.\n    \"\"\"\n    user = User.objects.create_user(username, email, password)\n    reg = Registration()\n    reg.register(user)\n\n    profile = UserProfile(user=user)\n    profile.name = name\n    profile.country = country\n    profile.save()\n\n    return user\n\n\ndef create_manual_course_enrollment(user, course_id, mode, enrolled_by, reason, state_transition):\n    \"\"\"\n    Create course enrollment for the given student and create manual enrollment audit trail.\n\n    :param user: User who is to enroll in course\n    :param course_id: course identifier of the course in which to enroll the user.\n    :param mode: mode for user enrollment, e.g. 'honor', 'audit' etc.\n    :param enrolled_by: User who made the manual enrollment entry (usually instructor or support)\n    :param reason: Reason behind manual enrollment\n    :param state_transition: state transition denoting whether student enrolled from un-enrolled,\n            un-enrolled from enrolled etc.\n    :return CourseEnrollment instance.\n    \"\"\"\n    enrollment_obj = CourseEnrollment.enroll(user, course_id, mode=mode)\n    ManualEnrollmentAudit.create_manual_enrollment_audit(\n        enrolled_by, user.email, state_transition, reason, enrollment_obj\n    )\n\n    log.info(u'user %s enrolled in the course %s', user.username, course_id)\n    return enrollment_obj\n\n\ndef create_and_enroll_user(email, username, name, country, password, course_id, course_mode, enrolled_by, email_params):\n    \"\"\"\n    Create a new user and enroll him/her to the given course, return list of errors in the following format\n        Error format:\n            each error is key-value pait dict with following key-value pairs.\n            1. username: username of the user to enroll\n            1. email: email of the user to enroll\n            1. response: readable error message\n\n    :param email: user's email address\n    :param username: user's username\n    :param name: user's name\n    :param country: user's country\n    :param password: user's password\n    :param course_id: course identifier of the course in which to enroll the user.\n    :param course_mode: mode for user enrollment, e.g. 'honor', 'audit' etc.\n    :param enrolled_by: User who made the manual enrollment entry (usually instructor or support)\n    :param email_params: information to send to the user via email\n\n    :return: list of errors\n    \"\"\"\n    errors = list()\n    try:\n        with transaction.atomic():\n            # Create a new user\n            user = create_user_and_user_profile(email, username, name, country, password)\n\n            # Enroll user to the course and add manual enrollment audit trail\n            create_manual_course_enrollment(\n                user=user,\n                course_id=course_id,\n                mode=course_mode,\n                enrolled_by=enrolled_by,\n                reason='Enrolling via csv upload',\n                state_transition=UNENROLLED_TO_ENROLLED,\n            )\n    except IntegrityError:\n        errors.append({\n            'username': username, 'email': email, 'response': _('Username {user} already exists.').format(user=username)\n        })\n    except Exception as ex:  # pylint: disable=broad-except\n        log.exception(type(ex).__name__)\n        errors.append({\n            'username': username, 'email': email, 'response': type(ex).__name__,\n        })\n    else:\n        try:\n            # It's a new user, an email will be sent to each newly created user.\n            email_params.update({\n                'message': 'account_creation_and_enrollment',\n                'email_address': email,\n                'password': password,\n                'platform_name': microsite.get_value('platform_name', settings.PLATFORM_NAME),\n            })\n            send_mail_to_student(email, email_params)\n        except Exception as ex:  # pylint: disable=broad-except\n            log.exception(\n                \"Exception '{exception}' raised while sending email to new user.\".format(exception=type(ex).__name__)\n            )\n            errors.append({\n                'username': username,\n                'email': email,\n                'response':\n                    _(\"Error '{error}' while sending email to new user (user email={email}). \"\n                      \"Without the email student would not be able to login. \"\n                      \"Please contact support for further information.\").format(error=type(ex).__name__, email=email),\n            })\n        else:\n            log.info(u'email sent to new created user at %s', email)\n\n    return errors\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params(action=\"enroll or unenroll\", identifiers=\"stringified list of emails and/or usernames\")\ndef students_update_enrollment(request, course_id):\n    \"\"\"\n    Enroll or unenroll students by email.\n    Requires staff access.\n\n    Query Parameters:\n    - action in ['enroll', 'unenroll']\n    - identifiers is string containing a list of emails and/or usernames separated by anything split_input_list can handle.\n    - auto_enroll is a boolean (defaults to false)\n        If auto_enroll is false, students will be allowed to enroll.\n        If auto_enroll is true, students will be enrolled as soon as they register.\n    - email_students is a boolean (defaults to false)\n        If email_students is true, students will be sent email notification\n        If email_students is false, students will not be sent email notification\n\n    Returns an analog to this JSON structure: {\n        \"action\": \"enroll\",\n        \"auto_enroll\": false,\n        \"results\": [\n            {\n                \"email\": \"testemail@test.org\",\n                \"before\": {\n                    \"enrollment\": false,\n                    \"auto_enroll\": false,\n                    \"user\": true,\n                    \"allowed\": false\n                },\n                \"after\": {\n                    \"enrollment\": true,\n                    \"auto_enroll\": false,\n                    \"user\": true,\n                    \"allowed\": false\n                }\n            }\n        ]\n    }\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    action = request.POST.get('action')\n    identifiers_raw = request.POST.get('identifiers')\n    identifiers = _split_input_list(identifiers_raw)\n    auto_enroll = request.POST.get('auto_enroll') in ['true', 'True', True]\n    email_students = request.POST.get('email_students') in ['true', 'True', True]\n    is_white_label = CourseMode.is_white_label(course_id)\n    reason = request.POST.get('reason')\n    if is_white_label:\n        if not reason:\n            return JsonResponse(\n                {\n                    'action': action,\n                    'results': [{'error': True}],\n                    'auto_enroll': auto_enroll,\n                }, status=400)\n    enrollment_obj = None\n    state_transition = DEFAULT_TRANSITION_STATE\n\n    email_params = {}\n    if email_students:\n        course = get_course_by_id(course_id)\n        email_params = get_email_params(course, auto_enroll, secure=request.is_secure())\n\n    results = []\n    for identifier in identifiers:\n        # First try to get a user object from the identifer\n        user = None\n        email = None\n        language = None\n        try:\n            user = get_student_from_identifier(identifier)\n        except User.DoesNotExist:\n            email = identifier\n        else:\n            email = user.email\n            language = get_user_email_language(user)\n\n        try:\n            # Use django.core.validators.validate_email to check email address\n            # validity (obviously, cannot check if email actually /exists/,\n            # simply that it is plausibly valid)\n            validate_email(email)  # Raises ValidationError if invalid\n            if action == 'enroll':\n                before, after, enrollment_obj = enroll_email(\n                    course_id, email, auto_enroll, email_students, email_params, language=language\n                )\n                before_enrollment = before.to_dict()['enrollment']\n                before_user_registered = before.to_dict()['user']\n                before_allowed = before.to_dict()['allowed']\n                after_enrollment = after.to_dict()['enrollment']\n                after_allowed = after.to_dict()['allowed']\n\n                if before_user_registered:\n                    if after_enrollment:\n                        if before_enrollment:\n                            state_transition = ENROLLED_TO_ENROLLED\n                        else:\n                            if before_allowed:\n                                state_transition = ALLOWEDTOENROLL_TO_ENROLLED\n                            else:\n                                state_transition = UNENROLLED_TO_ENROLLED\n                else:\n                    if after_allowed:\n                        state_transition = UNENROLLED_TO_ALLOWEDTOENROLL\n\n            elif action == 'unenroll':\n                before, after = unenroll_email(\n                    course_id, email, email_students, email_params, language=language\n                )\n                before_enrollment = before.to_dict()['enrollment']\n                before_allowed = before.to_dict()['allowed']\n                enrollment_obj = CourseEnrollment.get_enrollment(user, course_id)\n\n                if before_enrollment:\n                    state_transition = ENROLLED_TO_UNENROLLED\n                else:\n                    if before_allowed:\n                        state_transition = ALLOWEDTOENROLL_TO_UNENROLLED\n                    else:\n                        state_transition = UNENROLLED_TO_UNENROLLED\n\n            else:\n                return HttpResponseBadRequest(strip_tags(\n                    \"Unrecognized action '{}'\".format(action)\n                ))\n\n        except ValidationError:\n            # Flag this email as an error if invalid, but continue checking\n            # the remaining in the list\n            results.append({\n                'identifier': identifier,\n                'invalidIdentifier': True,\n            })\n\n        except Exception as exc:  # pylint: disable=broad-except\n            # catch and log any exceptions\n            # so that one error doesn't cause a 500.\n            log.exception(u\"Error while #{}ing student\")\n            log.exception(exc)\n            results.append({\n                'identifier': identifier,\n                'error': True,\n            })\n\n        else:\n            ManualEnrollmentAudit.create_manual_enrollment_audit(\n                request.user, email, state_transition, reason, enrollment_obj\n            )\n            results.append({\n                'identifier': identifier,\n                'before': before.to_dict(),\n                'after': after.to_dict(),\n            })\n\n    response_payload = {\n        'action': action,\n        'results': results,\n        'auto_enroll': auto_enroll,\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@common_exceptions_400\n@require_post_params(\n    identifiers=\"stringified list of emails and/or usernames\",\n    action=\"add or remove\",\n)\ndef bulk_beta_modify_access(request, course_id):\n    \"\"\"\n    Enroll or unenroll users in beta testing program.\n\n    Query parameters:\n    - identifiers is string containing a list of emails and/or usernames separated by\n      anything split_input_list can handle.\n    - action is one of ['add', 'remove']\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    action = request.POST.get('action')\n    identifiers_raw = request.POST.get('identifiers')\n    identifiers = _split_input_list(identifiers_raw)\n    email_students = request.POST.get('email_students') in ['true', 'True', True]\n    auto_enroll = request.POST.get('auto_enroll') in ['true', 'True', True]\n    results = []\n    rolename = 'beta'\n    course = get_course_by_id(course_id)\n\n    email_params = {}\n    if email_students:\n        secure = request.is_secure()\n        email_params = get_email_params(course, auto_enroll=auto_enroll, secure=secure)\n\n    for identifier in identifiers:\n        try:\n            error = False\n            user_does_not_exist = False\n            user = get_student_from_identifier(identifier)\n\n            if action == 'add':\n                allow_access(course, user, rolename)\n            elif action == 'remove':\n                revoke_access(course, user, rolename)\n            else:\n                return HttpResponseBadRequest(strip_tags(\n                    \"Unrecognized action '{}'\".format(action)\n                ))\n        except User.DoesNotExist:\n            error = True\n            user_does_not_exist = True\n        # catch and log any unexpected exceptions\n        # so that one error doesn't cause a 500.\n        except Exception as exc:  # pylint: disable=broad-except\n            log.exception(u\"Error while #{}ing student\")\n            log.exception(exc)\n            error = True\n        else:\n            # If no exception thrown, see if we should send an email\n            if email_students:\n                send_beta_role_email(action, user, email_params)\n            # See if we should autoenroll the student\n            if auto_enroll:\n                # Check if student is already enrolled\n                if not CourseEnrollment.is_enrolled(user, course_id):\n                    CourseEnrollment.enroll(user, course_id)\n\n        finally:\n            # Tabulate the action result of this email address\n            results.append({\n                'identifier': identifier,\n                'error': error,\n                'userDoesNotExist': user_does_not_exist\n            })\n\n    response_payload = {\n        'action': action,\n        'results': results,\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@common_exceptions_400\n@require_post_params(\n    unique_student_identifier=\"email or username of user to change access\",\n    rolename=\"'instructor', 'staff', 'beta', or 'ccx_coach'\",\n    action=\"'allow' or 'revoke'\"\n)\ndef modify_access(request, course_id):\n    \"\"\"\n    Modify staff/instructor access of other user.\n    Requires instructor access.\n\n    NOTE: instructors cannot remove their own instructor access.\n\n    Query parameters:\n    unique_student_identifer is the target user's username or email\n    rolename is one of ['instructor', 'staff', 'beta', 'ccx_coach']\n    action is one of ['allow', 'revoke']\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'instructor', course_id, depth=None\n    )\n    try:\n        user = get_student_from_identifier(request.POST.get('unique_student_identifier'))\n    except User.DoesNotExist:\n        response_payload = {\n            'unique_student_identifier': request.POST.get('unique_student_identifier'),\n            'userDoesNotExist': True,\n        }\n        return JsonResponse(response_payload)\n\n    # Check that user is active, because add_users\n    # in common/djangoapps/student/roles.py fails\n    # silently when we try to add an inactive user.\n    if not user.is_active:\n        response_payload = {\n            'unique_student_identifier': user.username,\n            'inactiveUser': True,\n        }\n        return JsonResponse(response_payload)\n\n    rolename = request.POST.get('rolename')\n    action = request.POST.get('action')\n\n    if rolename not in ROLES:\n        error = strip_tags(\"unknown rolename '{}'\".format(rolename))\n        log.error(error)\n        return HttpResponseBadRequest(error)\n\n    # disallow instructors from removing their own instructor access.\n    if rolename == 'instructor' and user == request.user and action != 'allow':\n        response_payload = {\n            'unique_student_identifier': user.username,\n            'rolename': rolename,\n            'action': action,\n            'removingSelfAsInstructor': True,\n        }\n        return JsonResponse(response_payload)\n\n    if action == 'allow':\n        allow_access(course, user, rolename)\n    elif action == 'revoke':\n        revoke_access(course, user, rolename)\n    else:\n        return HttpResponseBadRequest(strip_tags(\n            \"unrecognized action '{}'\".format(action)\n        ))\n\n    response_payload = {\n        'unique_student_identifier': user.username,\n        'rolename': rolename,\n        'action': action,\n        'success': 'yes',\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@require_post_params(rolename=\"'instructor', 'staff', or 'beta'\")\ndef list_course_role_members(request, course_id):\n    \"\"\"\n    List instructors and staff.\n    Requires instructor access.\n\n    rolename is one of ['instructor', 'staff', 'beta', 'ccx_coach']\n\n    Returns JSON of the form {\n        \"course_id\": \"some/course/id\",\n        \"staff\": [\n            {\n                \"username\": \"staff1\",\n                \"email\": \"staff1@example.org\",\n                \"first_name\": \"Joe\",\n                \"last_name\": \"Shmoe\",\n            }\n        ]\n    }\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'instructor', course_id, depth=None\n    )\n\n    rolename = request.POST.get('rolename')\n\n    if rolename not in ROLES:\n        return HttpResponseBadRequest()\n\n    def extract_user_info(user):\n        \"\"\" convert user into dicts for json view \"\"\"\n        return {\n            'username': user.username,\n            'email': user.email,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n        }\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        rolename: map(extract_user_info, list_with_level(\n            course, rolename\n        )),\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_problem_responses(request, course_id):\n    \"\"\"\n    Initiate generation of a CSV file containing all student answers\n    to a given problem.\n\n    Responds with JSON\n        {\"status\": \"... status message ...\"}\n\n    if initiation is successful (or generation task is already running).\n\n    Responds with BadRequest if problem location is faulty.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    problem_location = request.POST.get('problem_location', '')\n\n    try:\n        problem_key = UsageKey.from_string(problem_location)\n        # Are we dealing with an \"old-style\" problem location?\n        run = problem_key.run\n        if not run:\n            problem_key = course_key.make_usage_key_from_deprecated_string(problem_location)\n        if problem_key.course_key != course_key:\n            raise InvalidKeyError(type(problem_key), problem_key)\n    except InvalidKeyError:\n        return JsonResponseBadRequest(_(\"Could not find problem with this location.\"))\n\n    try:\n        instructor_task.api.submit_calculate_problem_responses_csv(request, course_key, problem_location)\n        success_status = _(\n            \"The problem responses report is being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n        )\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\n            \"A problem responses report generation task is already in progress. \"\n            \"Check the 'Pending Tasks' table for the status of the task. \"\n            \"When completed, the report will be available for download in the table below.\"\n        )\n        return JsonResponse({\"status\": already_running_status})\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_grading_config(request, course_id):\n    \"\"\"\n    Respond with json which contains a html formatted grade summary.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n    grading_config_summary = instructor_analytics.basic.dump_grading_context(course)\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'grading_config_summary': grading_config_summary,\n    }\n    return JsonResponse(response_payload)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_sale_records(request, course_id, csv=False):  # pylint: disable=unused-argument, redefined-outer-name\n    \"\"\"\n    return the summary of all sales records for a particular course\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    query_features = [\n        'company_name', 'company_contact_name', 'company_contact_email', 'total_codes', 'total_used_codes',\n        'total_amount', 'created', 'customer_reference_number', 'recipient_name', 'recipient_email', 'created_by',\n        'internal_reference', 'invoice_number', 'codes', 'course_id'\n    ]\n\n    sale_data = instructor_analytics.basic.sale_record_features(course_id, query_features)\n\n    if not csv:\n        for item in sale_data:\n            item['created_by'] = item['created_by'].username\n\n        response_payload = {\n            'course_id': course_id.to_deprecated_string(),\n            'sale': sale_data,\n            'queried_features': query_features\n        }\n        return JsonResponse(response_payload)\n    else:\n        header, datarows = instructor_analytics.csvs.format_dictlist(sale_data, query_features)\n        return instructor_analytics.csvs.create_csv_response(\"e-commerce_sale_invoice_records.csv\", header, datarows)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_sale_order_records(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    return the summary of all sales records for a particular course\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    query_features = [\n        ('id', 'Order Id'),\n        ('company_name', 'Company Name'),\n        ('company_contact_name', 'Company Contact Name'),\n        ('company_contact_email', 'Company Contact Email'),\n        ('logged_in_username', 'Login Username'),\n        ('logged_in_email', 'Login User Email'),\n        ('purchase_time', 'Date of Sale'),\n        ('customer_reference_number', 'Customer Reference Number'),\n        ('recipient_name', 'Recipient Name'),\n        ('recipient_email', 'Recipient Email'),\n        ('bill_to_street1', 'Street 1'),\n        ('bill_to_street2', 'Street 2'),\n        ('bill_to_city', 'City'),\n        ('bill_to_state', 'State'),\n        ('bill_to_postalcode', 'Postal Code'),\n        ('bill_to_country', 'Country'),\n        ('order_type', 'Order Type'),\n        ('status', 'Order Item Status'),\n        ('coupon_code', 'Coupon Code'),\n        ('list_price', 'List Price'),\n        ('unit_cost', 'Unit Price'),\n        ('quantity', 'Quantity'),\n        ('total_discount', 'Total Discount'),\n        ('total_amount', 'Total Amount Paid'),\n    ]\n\n    db_columns = [x[0] for x in query_features]\n    csv_columns = [x[1] for x in query_features]\n    sale_data = instructor_analytics.basic.sale_order_record_features(course_id, db_columns)\n    __, datarows = instructor_analytics.csvs.format_dictlist(sale_data, db_columns)\n    return instructor_analytics.csvs.create_csv_response(\"e-commerce_sale_order_records.csv\", csv_columns, datarows)\n\n\n@require_level('staff')\n@require_POST\ndef sale_validation(request, course_id):\n    \"\"\"\n    This method either invalidate or re validate the sale against the invoice number depending upon the event type\n    \"\"\"\n    try:\n        invoice_number = request.POST[\"invoice_number\"]\n    except KeyError:\n        return HttpResponseBadRequest(\"Missing required invoice_number parameter\")\n    try:\n        invoice_number = int(invoice_number)\n    except ValueError:\n        return HttpResponseBadRequest(\n            \"invoice_number must be an integer, {value} provided\".format(\n                value=invoice_number\n            )\n        )\n    try:\n        event_type = request.POST[\"event_type\"]\n    except KeyError:\n        return HttpResponseBadRequest(\"Missing required event_type parameter\")\n\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        obj_invoice = CourseRegistrationCodeInvoiceItem.objects.select_related('invoice').get(\n            invoice_id=invoice_number,\n            course_id=course_id\n        )\n        obj_invoice = obj_invoice.invoice\n    except CourseRegistrationCodeInvoiceItem.DoesNotExist:  # Check for old type invoices\n        return HttpResponseNotFound(_(\"Invoice number '{num}' does not exist.\").format(num=invoice_number))\n\n    if event_type == \"invalidate\":\n        return invalidate_invoice(obj_invoice)\n    else:\n        return re_validate_invoice(obj_invoice)\n\n\ndef invalidate_invoice(obj_invoice):\n    \"\"\"\n    This method invalidate the sale against the invoice number\n    \"\"\"\n    if not obj_invoice.is_valid:\n        return HttpResponseBadRequest(_(\"The sale associated with this invoice has already been invalidated.\"))\n    obj_invoice.is_valid = False\n    obj_invoice.save()\n    message = _('Invoice number {0} has been invalidated.').format(obj_invoice.id)\n    return JsonResponse({'message': message})\n\n\ndef re_validate_invoice(obj_invoice):\n    \"\"\"\n    This method re-validate the sale against the invoice number\n    \"\"\"\n    if obj_invoice.is_valid:\n        return HttpResponseBadRequest(_(\"This invoice is already active.\"))\n\n    obj_invoice.is_valid = True\n    obj_invoice.save()\n    message = _('The registration codes for invoice {0} have been re-activated.').format(obj_invoice.id)\n    return JsonResponse({'message': message})\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_issued_certificates(request, course_id):\n    \"\"\"\n    Responds with JSON if CSV is not required. contains a list of issued certificates.\n    Arguments:\n        course_id\n    Returns:\n        {\"certificates\": [{course_id: xyz, mode: 'honor'}, ...]}\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    csv_required = request.GET.get('csv', 'false')\n\n    query_features = ['course_id', 'mode', 'total_issued_certificate', 'report_run_date']\n    query_features_names = [\n        ('course_id', _('CourseID')),\n        ('mode', _('Certificate Type')),\n        ('total_issued_certificate', _('Total Certificates Issued')),\n        ('report_run_date', _('Date Report Run'))\n    ]\n    certificates_data = instructor_analytics.basic.issued_certificates(course_key, query_features)\n    if csv_required.lower() == 'true':\n        __, data_rows = instructor_analytics.csvs.format_dictlist(certificates_data, query_features)\n        return instructor_analytics.csvs.create_csv_response(\n            'issued_certificates.csv',\n            [col_header for __, col_header in query_features_names],\n            data_rows\n        )\n    else:\n        response_payload = {\n            'certificates': certificates_data,\n            'queried_features': query_features,\n            'feature_names': dict(query_features_names)\n        }\n        return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_students_features(request, course_id, csv=False):  # pylint: disable=redefined-outer-name\n    \"\"\"\n    Respond with json which contains a summary of all enrolled students profile information.\n\n    Responds with JSON\n        {\"students\": [{-student-info-}, ...]}\n\n    TO DO accept requests for different attribute sets.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    course = get_course_by_id(course_key)\n\n    available_features = instructor_analytics.basic.AVAILABLE_FEATURES\n\n    # Allow for microsites to be able to define additional columns.\n    # Note that adding additional columns has the potential to break\n    # the student profile report due to a character limit on the\n    # asynchronous job input which in this case is a JSON string\n    # containing the list of columns to include in the report.\n    # TODO: Refactor the student profile report code to remove the list of columns\n    # that should be included in the report from the asynchronous job input.\n    # We need to clone the list because we modify it below\n    query_features = list(microsite.get_value('student_profile_download_fields', []))\n\n    if not query_features:\n        query_features = [\n            'id', 'username', 'name', 'email', 'language', 'location',\n            'year_of_birth', 'gender', 'level_of_education', 'mailing_address',\n            'goals',\n        ]\n\n    # Provide human-friendly and translatable names for these features. These names\n    # will be displayed in the table generated in data_download.coffee. It is not (yet)\n    # used as the header row in the CSV, but could be in the future.\n    query_features_names = {\n        'id': _('User ID'),\n        'username': _('Username'),\n        'name': _('Name'),\n        'email': _('Email'),\n        'language': _('Language'),\n        'location': _('Location'),\n        'year_of_birth': _('Birth Year'),\n        'gender': _('Gender'),\n        'level_of_education': _('Level of Education'),\n        'mailing_address': _('Mailing Address'),\n        'goals': _('Goals'),\n    }\n\n    if is_course_cohorted(course.id):\n        # Translators: 'Cohort' refers to a group of students within a course.\n        query_features.append('cohort')\n        query_features_names['cohort'] = _('Cohort')\n\n    if course.teams_enabled:\n        query_features.append('team')\n        query_features_names['team'] = _('Team')\n\n    # For compatibility reasons, city and country should always appear last.\n    query_features.append('city')\n    query_features_names['city'] = _('City')\n    query_features.append('country')\n    query_features_names['country'] = _('Country')\n\n    if not csv:\n        student_data = instructor_analytics.basic.enrolled_students_features(course_key, query_features)\n        response_payload = {\n            'course_id': unicode(course_key),\n            'students': student_data,\n            'students_count': len(student_data),\n            'queried_features': query_features,\n            'feature_names': query_features_names,\n            'available_features': available_features,\n        }\n        return JsonResponse(response_payload)\n    else:\n        try:\n            instructor_task.api.submit_calculate_students_features_csv(request, course_key, query_features)\n            success_status = _(\"The enrolled learner profile report is being created.\"\n                               \" To view the status of the report, see Pending Tasks below.\")\n            return JsonResponse({\"status\": success_status})\n        except AlreadyRunningError:\n            already_running_status = _(\n                \"This enrollment report is currently being created.\"\n                \" To view the status of the report, see Pending Tasks below.\"\n                \" You will be able to download the report when it is complete.\")\n            return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_students_who_may_enroll(request, course_id):\n    \"\"\"\n    Initiate generation of a CSV file containing information about\n    students who may enroll in a course.\n\n    Responds with JSON\n        {\"status\": \"... status message ...\"}\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    query_features = ['email']\n    try:\n        instructor_task.api.submit_calculate_may_enroll_csv(request, course_key, query_features)\n        success_status = _(\n            \"The enrollment report is being created. This report contains\"\n            \" information about learners who can enroll in the course.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n        )\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\n            \"This enrollment report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n        return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_POST\n@require_level('staff')\ndef add_users_to_cohorts(request, course_id):\n    \"\"\"\n    View method that accepts an uploaded file (using key \"uploaded-file\")\n    containing cohort assignments for users. This method spawns a celery task\n    to do the assignments, and a CSV file with results is provided via data downloads.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_string(course_id)\n\n    try:\n        def validator(file_storage, file_to_validate):\n            \"\"\"\n            Verifies that the expected columns are present.\n            \"\"\"\n            with file_storage.open(file_to_validate) as f:\n                reader = unicodecsv.reader(UniversalNewlineIterator(f), encoding='utf-8')\n                try:\n                    fieldnames = next(reader)\n                except StopIteration:\n                    fieldnames = []\n                msg = None\n                if \"cohort\" not in fieldnames:\n                    msg = _(\"The file must contain a 'cohort' column containing cohort names.\")\n                elif \"email\" not in fieldnames and \"username\" not in fieldnames:\n                    msg = _(\"The file must contain a 'username' column, an 'email' column, or both.\")\n                if msg:\n                    raise FileValidationException(msg)\n\n        __, filename = store_uploaded_file(\n            request, 'uploaded-file', ['.csv'],\n            course_and_time_based_filename_generator(course_key, \"cohorts\"),\n            max_file_size=2000000,  # limit to 2 MB\n            validator=validator\n        )\n        # The task will assume the default file storage.\n        instructor_task.api.submit_cohort_students(request, course_key, filename)\n    except (FileValidationException, PermissionDenied) as err:\n        return JsonResponse({\"error\": unicode(err)}, status=400)\n\n    return JsonResponse()\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_coupon_codes(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    Respond with csv which contains a summary of all Active Coupons.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    coupons = Coupon.objects.filter(course_id=course_id)\n\n    query_features = [\n        ('code', _('Coupon Code')),\n        ('course_id', _('Course Id')),\n        ('percentage_discount', _('% Discount')),\n        ('description', _('Description')),\n        ('expiration_date', _('Expiration Date')),\n        ('is_active', _('Is Active')),\n        ('code_redeemed_count', _('Code Redeemed Count')),\n        ('total_discounted_seats', _('Total Discounted Seats')),\n        ('total_discounted_amount', _('Total Discounted Amount')),\n    ]\n    db_columns = [x[0] for x in query_features]\n    csv_columns = [x[1] for x in query_features]\n\n    coupons_list = instructor_analytics.basic.coupon_codes_features(db_columns, coupons, course_id)\n    __, data_rows = instructor_analytics.csvs.format_dictlist(coupons_list, db_columns)\n    return instructor_analytics.csvs.create_csv_response('Coupons.csv', csv_columns, data_rows)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_finance_admin\ndef get_enrollment_report(request, course_id):\n    \"\"\"\n    get the enrollment report for the particular course.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_detailed_enrollment_features_csv(request, course_key)\n        success_status = _(\"The detailed enrollment report is being created.\"\n                           \" To view the status of the report, see Pending Tasks below.\")\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\"The detailed enrollment report is being created.\"\n                                   \" To view the status of the report, see Pending Tasks below.\"\n                                   \" You will be able to download the report when it is complete.\")\n        return JsonResponse({\n            \"status\": already_running_status\n        })\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_finance_admin\ndef get_exec_summary_report(request, course_id):\n    \"\"\"\n    get the executive summary report for the particular course.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_executive_summary_report(request, course_key)\n        status_response = _(\"The executive summary report is being created.\"\n                            \" To view the status of the report, see Pending Tasks below.\")\n    except AlreadyRunningError:\n        status_response = _(\n            \"The executive summary report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n    return JsonResponse({\n        \"status\": status_response\n    })\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_course_survey_results(request, course_id):\n    \"\"\"\n    get the survey results report for the particular course.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_course_survey_report(request, course_key)\n        status_response = _(\"The survey report is being created.\"\n                            \" To view the status of the report, see Pending Tasks below.\")\n    except AlreadyRunningError:\n        status_response = _(\n            \"The survey report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n    return JsonResponse({\n        \"status\": status_response\n    })\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_proctored_exam_results(request, course_id):\n    \"\"\"\n    get the proctored exam resultsreport for the particular course.\n    \"\"\"\n    query_features = [\n        'user_email',\n        'exam_name',\n        'attempt_code',\n        'allowed_time_limit_mins',\n        'is_sample_attempt',\n        'started_at',\n        'completed_at',\n        'status',\n    ]\n\n    course_key = CourseKey.from_string(course_id)\n    try:\n        instructor_task.api.submit_proctored_exam_results_report(request, course_key, query_features)\n        status_response = _(\"The proctored exam results report is being created.\"\n                            \" To view the status of the report, see Pending Tasks below.\")\n    except AlreadyRunningError:\n        status_response = _(\n            \"The proctored exam results report is currently being created.\"\n            \" To view the status of the report, see Pending Tasks below.\"\n            \" You will be able to download the report when it is complete.\"\n        )\n    return JsonResponse({\n        \"status\": status_response\n    })\n\n\ndef save_registration_code(user, course_id, mode_slug, invoice=None, order=None, invoice_item=None):\n    \"\"\"\n    recursive function that generate a new code every time and saves in the Course Registration Table\n    if validation check passes\n\n    Args:\n        user (User): The user creating the course registration codes.\n        course_id (str): The string representation of the course ID.\n        mode_slug (str): The Course Mode Slug associated with any enrollment made by these codes.\n        invoice (Invoice): (Optional) The associated invoice for this code.\n        order (Order): (Optional) The associated order for this code.\n        invoice_item (CourseRegistrationCodeInvoiceItem) : (Optional) The associated CourseRegistrationCodeInvoiceItem\n\n    Returns:\n        The newly created CourseRegistrationCode.\n\n    \"\"\"\n    code = random_code_generator()\n\n    # check if the generated code is in the Coupon Table\n    matching_coupons = Coupon.objects.filter(code=code, is_active=True)\n    if matching_coupons:\n        return save_registration_code(\n            user, course_id, mode_slug, invoice=invoice, order=order, invoice_item=invoice_item\n        )\n\n    course_registration = CourseRegistrationCode(\n        code=code,\n        course_id=unicode(course_id),\n        created_by=user,\n        invoice=invoice,\n        order=order,\n        mode_slug=mode_slug,\n        invoice_item=invoice_item\n    )\n    try:\n        with transaction.atomic():\n            course_registration.save()\n        return course_registration\n    except IntegrityError:\n        return save_registration_code(\n            user, course_id, mode_slug, invoice=invoice, order=order, invoice_item=invoice_item\n        )\n\n\ndef registration_codes_csv(file_name, codes_list, csv_type=None):\n    \"\"\"\n    Respond with the csv headers and data rows\n    given a dict of codes list\n    :param file_name:\n    :param codes_list:\n    :param csv_type:\n    \"\"\"\n    # csv headers\n    query_features = [\n        'code', 'redeem_code_url', 'course_id', 'company_name', 'created_by',\n        'redeemed_by', 'invoice_id', 'purchaser', 'customer_reference_number', 'internal_reference', 'is_valid'\n    ]\n\n    registration_codes = instructor_analytics.basic.course_registration_features(query_features, codes_list, csv_type)\n    header, data_rows = instructor_analytics.csvs.format_dictlist(registration_codes, query_features)\n    return instructor_analytics.csvs.create_csv_response(file_name, header, data_rows)\n\n\ndef random_code_generator():\n    \"\"\"\n    generate a random alphanumeric code of length defined in\n    REGISTRATION_CODE_LENGTH settings\n    \"\"\"\n    code_length = getattr(settings, 'REGISTRATION_CODE_LENGTH', 8)\n    return generate_random_string(code_length)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef get_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Registration Codes.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    #filter all the  course registration codes\n    registration_codes = CourseRegistrationCode.objects.filter(\n        course_id=course_id\n    ).order_by('invoice_item__invoice__company_name')\n\n    company_name = request.POST['download_company_name']\n    if company_name:\n        registration_codes = registration_codes.filter(invoice_item__invoice__company_name=company_name)\n\n    csv_type = 'download'\n    return registration_codes_csv(\"Registration_Codes.csv\", registration_codes, csv_type)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_sales_admin\n@require_POST\ndef generate_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Generated Codes.\n    \"\"\"\n    course_id = CourseKey.from_string(course_id)\n    invoice_copy = False\n\n    # covert the course registration code number into integer\n    try:\n        course_code_number = int(request.POST['total_registration_codes'])\n    except ValueError:\n        course_code_number = int(float(request.POST['total_registration_codes']))\n\n    company_name = request.POST['company_name']\n    company_contact_name = request.POST['company_contact_name']\n    company_contact_email = request.POST['company_contact_email']\n    unit_price = request.POST['unit_price']\n\n    try:\n        unit_price = (\n            decimal.Decimal(unit_price)\n        ).quantize(\n            decimal.Decimal('.01'),\n            rounding=decimal.ROUND_DOWN\n        )\n    except decimal.InvalidOperation:\n        return HttpResponse(\n            status=400,\n            content=_(u\"Could not parse amount as a decimal\")\n        )\n\n    recipient_name = request.POST['recipient_name']\n    recipient_email = request.POST['recipient_email']\n    address_line_1 = request.POST['address_line_1']\n    address_line_2 = request.POST['address_line_2']\n    address_line_3 = request.POST['address_line_3']\n    city = request.POST['city']\n    state = request.POST['state']\n    zip_code = request.POST['zip']\n    country = request.POST['country']\n    internal_reference = request.POST['internal_reference']\n    customer_reference_number = request.POST['customer_reference_number']\n    recipient_list = [recipient_email]\n    if request.POST.get('invoice', False):\n        recipient_list.append(request.user.email)\n        invoice_copy = True\n\n    sale_price = unit_price * course_code_number\n    set_user_preference(request.user, INVOICE_KEY, invoice_copy)\n    sale_invoice = Invoice.objects.create(\n        total_amount=sale_price,\n        company_name=company_name,\n        company_contact_email=company_contact_email,\n        company_contact_name=company_contact_name,\n        course_id=course_id,\n        recipient_name=recipient_name,\n        recipient_email=recipient_email,\n        address_line_1=address_line_1,\n        address_line_2=address_line_2,\n        address_line_3=address_line_3,\n        city=city,\n        state=state,\n        zip=zip_code,\n        country=country,\n        internal_reference=internal_reference,\n        customer_reference_number=customer_reference_number\n    )\n\n    invoice_item = CourseRegistrationCodeInvoiceItem.objects.create(\n        invoice=sale_invoice,\n        qty=course_code_number,\n        unit_price=unit_price,\n        course_id=course_id\n    )\n\n    course = get_course_by_id(course_id, depth=0)\n    paid_modes = CourseMode.paid_modes_for_course(course_id)\n\n    if len(paid_modes) != 1:\n        msg = (\n            u\"Generating Code Redeem Codes for Course '{course_id}', which must have a single paid course mode. \"\n            u\"This is a configuration issue. Current course modes with payment options: {paid_modes}\"\n        ).format(course_id=course_id, paid_modes=paid_modes)\n        log.error(msg)\n        return HttpResponse(\n            status=500,\n            content=_(u\"Unable to generate redeem codes because of course misconfiguration.\")\n        )\n\n    course_mode = paid_modes[0]\n    course_price = course_mode.min_price\n\n    registration_codes = []\n    for __ in range(course_code_number):\n        generated_registration_code = save_registration_code(\n            request.user, course_id, course_mode.slug, invoice=sale_invoice, order=None, invoice_item=invoice_item\n        )\n        registration_codes.append(generated_registration_code)\n\n    site_name = microsite.get_value('SITE_NAME', 'localhost')\n    quantity = course_code_number\n    discount = (float(quantity * course_price) - float(sale_price))\n    course_url = '{base_url}{course_about}'.format(\n        base_url=microsite.get_value('SITE_NAME', settings.SITE_NAME),\n        course_about=reverse('about_course', kwargs={'course_id': course_id.to_deprecated_string()})\n    )\n    dashboard_url = '{base_url}{dashboard}'.format(\n        base_url=microsite.get_value('SITE_NAME', settings.SITE_NAME),\n        dashboard=reverse('dashboard')\n    )\n\n    try:\n        pdf_file = sale_invoice.generate_pdf_invoice(course, course_price, int(quantity), float(sale_price))\n    except Exception:  # pylint: disable=broad-except\n        log.exception('Exception at creating pdf file.')\n        pdf_file = None\n\n    from_address = theming_helpers.get_value('email_from_address', settings.DEFAULT_FROM_EMAIL)\n    context = {\n        'invoice': sale_invoice,\n        'site_name': site_name,\n        'course': course,\n        'course_price': course_price,\n        'sub_total': course_price * quantity,\n        'discount': discount,\n        'sale_price': sale_price,\n        'quantity': quantity,\n        'registration_codes': registration_codes,\n        'currency_symbol': settings.PAID_COURSE_REGISTRATION_CURRENCY[1],\n        'course_url': course_url,\n        'platform_name': microsite.get_value('platform_name', settings.PLATFORM_NAME),\n        'dashboard_url': dashboard_url,\n        'contact_email': from_address,\n        'corp_address': microsite.get_value('invoice_corp_address', settings.INVOICE_CORP_ADDRESS),\n        'payment_instructions': microsite.get_value('invoice_payment_instructions', settings. INVOICE_PAYMENT_INSTRUCTIONS),\n        'date': time.strftime(\"%m/%d/%Y\")\n    }\n    # composes registration codes invoice email\n    subject = u'Confirmation and Invoice for {course_name}'.format(course_name=course.display_name)\n    message = render_to_string('emails/registration_codes_sale_email.txt', context)\n\n    invoice_attachment = render_to_string('emails/registration_codes_sale_invoice_attachment.txt', context)\n\n    #send_mail(subject, message, from_address, recipient_list, fail_silently=False)\n    csv_file = StringIO.StringIO()\n    csv_writer = csv.writer(csv_file)\n    for registration_code in registration_codes:\n        full_redeem_code_url = 'http://{base_url}{redeem_code_url}'.format(\n            base_url=microsite.get_value('SITE_NAME', settings.SITE_NAME),\n            redeem_code_url=reverse('register_code_redemption', kwargs={'registration_code': registration_code.code})\n        )\n        csv_writer.writerow([registration_code.code, full_redeem_code_url])\n    finance_email = microsite.get_value('finance_email', settings.FINANCE_EMAIL)\n    if finance_email:\n        # append the finance email into the recipient_list\n        recipient_list.append(finance_email)\n\n    # send a unique email for each recipient, don't put all email addresses in a single email\n    for recipient in recipient_list:\n        email = EmailMessage()\n        email.subject = subject\n        email.body = message\n        email.from_email = from_address\n        email.to = [recipient]\n        email.attach(u'RegistrationCodes.csv', csv_file.getvalue(), 'text/csv')\n        email.attach(u'Invoice.txt', invoice_attachment, 'text/plain')\n        if pdf_file is not None:\n            email.attach(u'Invoice.pdf', pdf_file.getvalue(), 'application/pdf')\n        else:\n            file_buffer = StringIO.StringIO(_('pdf download unavailable right now, please contact support.'))\n            email.attach(u'pdf_unavailable.txt', file_buffer.getvalue(), 'text/plain')\n        email.send()\n\n    return registration_codes_csv(\"Registration_Codes.csv\", registration_codes)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef active_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Active Registration Codes.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    # find all the registration codes in this course\n    registration_codes_list = CourseRegistrationCode.objects.filter(\n        course_id=course_id\n    ).order_by('invoice_item__invoice__company_name')\n\n    company_name = request.POST['active_company_name']\n    if company_name:\n        registration_codes_list = registration_codes_list.filter(invoice_item__invoice__company_name=company_name)\n    # find the redeemed registration codes if any exist in the db\n    code_redemption_set = RegistrationCodeRedemption.objects.select_related(\n        'registration_code', 'registration_code__invoice_item__invoice'\n    ).filter(registration_code__course_id=course_id)\n    if code_redemption_set.exists():\n        redeemed_registration_codes = [code.registration_code.code for code in code_redemption_set]\n        # exclude the redeemed registration codes from the registration codes list and you will get\n        # all the registration codes that are active\n        registration_codes_list = registration_codes_list.exclude(code__in=redeemed_registration_codes)\n\n    return registration_codes_csv(\"Active_Registration_Codes.csv\", registration_codes_list)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef spent_registration_codes(request, course_id):\n    \"\"\"\n    Respond with csv which contains a summary of all Spent(used) Registration Codes.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    # find the redeemed registration codes if any exist in the db\n    code_redemption_set = RegistrationCodeRedemption.objects.select_related('registration_code').filter(\n        registration_code__course_id=course_id\n    )\n    spent_codes_list = []\n    if code_redemption_set.exists():\n        redeemed_registration_codes = [code.registration_code.code for code in code_redemption_set]\n        # filter the Registration Codes by course id and the redeemed codes and\n        # you will get a list of all the spent(Redeemed) Registration Codes\n        spent_codes_list = CourseRegistrationCode.objects.filter(\n            course_id=course_id, code__in=redeemed_registration_codes\n        ).order_by('invoice_item__invoice__company_name').select_related('invoice_item__invoice')\n\n        company_name = request.POST['spent_company_name']\n        if company_name:\n            spent_codes_list = spent_codes_list.filter(invoice_item__invoice__company_name=company_name)  # pylint: disable=maybe-no-member\n\n    csv_type = 'spent'\n    return registration_codes_csv(\"Spent_Registration_Codes.csv\", spent_codes_list, csv_type)\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef get_anon_ids(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    Respond with 2-column CSV output of user-id, anonymized-user-id\n    \"\"\"\n    # TODO: the User.objects query and CSV generation here could be\n    # centralized into instructor_analytics. Currently instructor_analytics\n    # has similar functionality but not quite what's needed.\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    def csv_response(filename, header, rows):\n        \"\"\"Returns a CSV http response for the given header and rows (excel/utf-8).\"\"\"\n        response = HttpResponse(content_type='text/csv')\n        response['Content-Disposition'] = 'attachment; filename={0}'.format(unicode(filename).encode('utf-8'))\n        writer = csv.writer(response, dialect='excel', quotechar='\"', quoting=csv.QUOTE_ALL)\n        # In practice, there should not be non-ascii data in this query,\n        # but trying to do the right thing anyway.\n        encoded = [unicode(s).encode('utf-8') for s in header]\n        writer.writerow(encoded)\n        for row in rows:\n            encoded = [unicode(s).encode('utf-8') for s in row]\n            writer.writerow(encoded)\n        return response\n\n    students = User.objects.filter(\n        courseenrollment__course_id=course_id,\n    ).order_by('id')\n    header = ['User ID', 'Anonymized User ID', 'Course Specific Anonymized User ID']\n    rows = [[s.id, unique_id_for_user(s, save=False), anonymous_id_for_user(s, course_id, save=False)] for s in students]\n    return csv_response(course_id.to_deprecated_string().replace('/', '-') + '-anon-ids.csv', header, rows)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@common_exceptions_400\n@require_level('staff')\n@require_post_params(\n    unique_student_identifier=\"email or username of student for whom to get progress url\"\n)\ndef get_student_progress_url(request, course_id):\n    \"\"\"\n    Get the progress url of a student.\n    Limited to staff access.\n\n    Takes query parameter unique_student_identifier and if the student exists\n    returns e.g. {\n        'progress_url': '/../...'\n    }\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    user = get_student_from_identifier(request.POST.get('unique_student_identifier'))\n\n    progress_url = reverse('student_progress', kwargs={'course_id': course_id.to_deprecated_string(), 'student_id': user.id})\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'progress_url': progress_url,\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params(\n    problem_to_reset=\"problem urlname to reset\"\n)\n@common_exceptions_400\ndef reset_student_attempts(request, course_id):\n    \"\"\"\n\n    Resets a students attempts counter or starts a task to reset all students\n    attempts counters. Optionally deletes student state for a problem. Limited\n    to staff access. Some sub-methods limited to instructor access.\n\n    Takes some of the following query paremeters\n        - problem_to_reset is a urlname of a problem\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n            requires instructor access\n            mutually exclusive with delete_module\n            mutually exclusive with delete_module\n        - delete_module is a boolean\n            requires instructor access\n            mutually exclusive with all_students\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n\n    problem_to_reset = strip_if_string(request.POST.get('problem_to_reset'))\n    student_identifier = request.POST.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n    all_students = request.POST.get('all_students', False) in ['true', 'True', True]\n    delete_module = request.POST.get('delete_module', False) in ['true', 'True', True]\n\n    # parameter combinations\n    if all_students and student:\n        return HttpResponseBadRequest(\n            \"all_students and unique_student_identifier are mutually exclusive.\"\n        )\n    if all_students and delete_module:\n        return HttpResponseBadRequest(\n            \"all_students and delete_module are mutually exclusive.\"\n        )\n\n    # instructor authorization\n    if all_students or delete_module:\n        if not has_access(request.user, 'instructor', course):\n            return HttpResponseForbidden(\"Requires instructor access.\")\n\n    try:\n        module_state_key = course_id.make_usage_key_from_deprecated_string(problem_to_reset)\n    except InvalidKeyError:\n        return HttpResponseBadRequest()\n\n    response_payload = {}\n    response_payload['problem_to_reset'] = problem_to_reset\n\n    if student:\n        try:\n            enrollment.reset_student_attempts(\n                course_id,\n                student,\n                module_state_key,\n                requesting_user=request.user,\n                delete_module=delete_module\n            )\n        except StudentModule.DoesNotExist:\n            return HttpResponseBadRequest(_(\"Module does not exist.\"))\n        except sub_api.SubmissionError:\n            # Trust the submissions API to log the error\n            error_msg = _(\"An error occurred while deleting the score.\")\n            return HttpResponse(error_msg, status=500)\n        response_payload['student'] = student_identifier\n    elif all_students:\n        instructor_task.api.submit_reset_problem_attempts_for_all_students(request, module_state_key)\n        response_payload['task'] = 'created'\n        response_payload['student'] = 'All Students'\n    else:\n        return HttpResponseBadRequest()\n\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@common_exceptions_400\ndef reset_student_attempts_for_entrance_exam(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n\n    Resets a students attempts counter or starts a task to reset all students\n    attempts counters for entrance exam. Optionally deletes student state for\n    entrance exam. Limited to staff access. Some sub-methods limited to instructor access.\n\n    Following are possible query parameters\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n            requires instructor access\n            mutually exclusive with delete_module\n        - delete_module is a boolean\n            requires instructor access\n            mutually exclusive with all_students\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n\n    if not course.entrance_exam_id:\n        return HttpResponseBadRequest(\n            _(\"Course has no entrance exam section.\")\n        )\n\n    student_identifier = request.POST.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n    all_students = request.POST.get('all_students', False) in ['true', 'True', True]\n    delete_module = request.POST.get('delete_module', False) in ['true', 'True', True]\n\n    # parameter combinations\n    if all_students and student:\n        return HttpResponseBadRequest(\n            _(\"all_students and unique_student_identifier are mutually exclusive.\")\n        )\n    if all_students and delete_module:\n        return HttpResponseBadRequest(\n            _(\"all_students and delete_module are mutually exclusive.\")\n        )\n\n    # instructor authorization\n    if all_students or delete_module:\n        if not has_access(request.user, 'instructor', course):\n            return HttpResponseForbidden(_(\"Requires instructor access.\"))\n\n    try:\n        entrance_exam_key = course_id.make_usage_key_from_deprecated_string(course.entrance_exam_id)\n        if delete_module:\n            instructor_task.api.submit_delete_entrance_exam_state_for_student(request, entrance_exam_key, student)\n        else:\n            instructor_task.api.submit_reset_problem_attempts_in_entrance_exam(request, entrance_exam_key, student)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(_(\"Course has no valid entrance exam section.\"))\n\n    response_payload = {'student': student_identifier or _('All Students'), 'task': 'created'}\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@require_post_params(problem_to_reset=\"problem urlname to reset\")\n@common_exceptions_400\ndef rescore_problem(request, course_id):\n    \"\"\"\n    Starts a background process a students attempts counter. Optionally deletes student state for a problem.\n    Limited to instructor access.\n\n    Takes either of the following query paremeters\n        - problem_to_reset is a urlname of a problem\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n\n    all_students and unique_student_identifier cannot both be present.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    problem_to_reset = strip_if_string(request.POST.get('problem_to_reset'))\n    student_identifier = request.POST.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n\n    all_students = request.POST.get('all_students') in ['true', 'True', True]\n\n    if not (problem_to_reset and (all_students or student)):\n        return HttpResponseBadRequest(\"Missing query parameters.\")\n\n    if all_students and student:\n        return HttpResponseBadRequest(\n            \"Cannot rescore with all_students and unique_student_identifier.\"\n        )\n\n    try:\n        module_state_key = course_id.make_usage_key_from_deprecated_string(problem_to_reset)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(\"Unable to parse problem id\")\n\n    response_payload = {}\n    response_payload['problem_to_reset'] = problem_to_reset\n\n    if student:\n        response_payload['student'] = student_identifier\n        instructor_task.api.submit_rescore_problem_for_student(request, module_state_key, student)\n        response_payload['task'] = 'created'\n    elif all_students:\n        instructor_task.api.submit_rescore_problem_for_all_students(request, module_state_key)\n        response_payload['task'] = 'created'\n    else:\n        return HttpResponseBadRequest()\n\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('instructor')\n@common_exceptions_400\ndef rescore_entrance_exam(request, course_id):\n    \"\"\"\n    Starts a background process a students attempts counter for entrance exam.\n    Optionally deletes student state for a problem. Limited to instructor access.\n\n    Takes either of the following query parameters\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n\n    all_students and unique_student_identifier cannot both be present.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_with_access(\n        request.user, 'staff', course_id, depth=None\n    )\n\n    student_identifier = request.POST.get('unique_student_identifier', None)\n    student = None\n    if student_identifier is not None:\n        student = get_student_from_identifier(student_identifier)\n\n    all_students = request.POST.get('all_students') in ['true', 'True', True]\n\n    if not course.entrance_exam_id:\n        return HttpResponseBadRequest(\n            _(\"Course has no entrance exam section.\")\n        )\n\n    if all_students and student:\n        return HttpResponseBadRequest(\n            _(\"Cannot rescore with all_students and unique_student_identifier.\")\n        )\n\n    try:\n        entrance_exam_key = course_id.make_usage_key_from_deprecated_string(course.entrance_exam_id)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(_(\"Course has no valid entrance exam section.\"))\n\n    response_payload = {}\n    if student:\n        response_payload['student'] = student_identifier\n    else:\n        response_payload['student'] = _(\"All Students\")\n    instructor_task.api.submit_rescore_entrance_exam_for_student(request, entrance_exam_key, student)\n    response_payload['task'] = 'created'\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_background_email_tasks(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    List background email tasks.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    task_type = 'bulk_course_email'\n    # Specifying for the history of a single task type\n    tasks = instructor_task.api.get_instructor_task_history(course_id, task_type=task_type)\n\n    response_payload = {\n        'tasks': map(extract_task_features, tasks),\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_email_content(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    List the content of bulk emails sent\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    task_type = 'bulk_course_email'\n    # First get tasks list of bulk emails sent\n    emails = instructor_task.api.get_instructor_task_history(course_id, task_type=task_type)\n\n    response_payload = {\n        'emails': map(extract_email_features, emails),\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_instructor_tasks(request, course_id):\n    \"\"\"\n    List instructor tasks.\n\n    Takes optional query paremeters.\n        - With no arguments, lists running tasks.\n        - `problem_location_str` lists task history for problem\n        - `problem_location_str` and `unique_student_identifier` lists task\n            history for problem AND student (intersection)\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    problem_location_str = strip_if_string(request.POST.get('problem_location_str', False))\n    student = request.POST.get('unique_student_identifier', None)\n    if student is not None:\n        student = get_student_from_identifier(student)\n\n    if student and not problem_location_str:\n        return HttpResponseBadRequest(\n            \"unique_student_identifier must accompany problem_location_str\"\n        )\n\n    if problem_location_str:\n        try:\n            module_state_key = course_id.make_usage_key_from_deprecated_string(problem_location_str)\n        except InvalidKeyError:\n            return HttpResponseBadRequest()\n        if student:\n            # Specifying for a single student's history on this problem\n            tasks = instructor_task.api.get_instructor_task_history(course_id, module_state_key, student)\n        else:\n            # Specifying for single problem's history\n            tasks = instructor_task.api.get_instructor_task_history(course_id, module_state_key)\n    else:\n        # If no problem or student, just get currently running tasks\n        tasks = instructor_task.api.get_running_instructor_tasks(course_id)\n\n    response_payload = {\n        'tasks': map(extract_task_features, tasks),\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_entrance_exam_instructor_tasks(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n    List entrance exam related instructor tasks.\n\n    Takes either of the following query parameters\n        - unique_student_identifier is an email or username\n        - all_students is a boolean\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_by_id(course_id)\n    student = request.POST.get('unique_student_identifier', None)\n    if student is not None:\n        student = get_student_from_identifier(student)\n\n    try:\n        entrance_exam_key = course_id.make_usage_key_from_deprecated_string(course.entrance_exam_id)\n    except InvalidKeyError:\n        return HttpResponseBadRequest(_(\"Course has no valid entrance exam section.\"))\n    if student:\n        # Specifying for a single student's entrance exam history\n        tasks = instructor_task.api.get_entrance_exam_instructor_task_history(course_id, entrance_exam_key, student)\n    else:\n        # Specifying for all student's entrance exam history\n        tasks = instructor_task.api.get_entrance_exam_instructor_task_history(course_id, entrance_exam_key)\n\n    response_payload = {\n        'tasks': map(extract_task_features, tasks),\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef list_report_downloads(_request, course_id):\n    \"\"\"\n    List grade CSV files that are available for download for this course.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    report_store = ReportStore.from_config(config_name='GRADES_DOWNLOAD')\n\n    response_payload = {\n        'downloads': [\n            dict(name=name, url=url, link=HTML('<a href=\"{}\">{}</a>').format(HTML(url), Text(name)))\n            for name, url in report_store.links_for(course_id)\n        ]\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_finance_admin\ndef list_financial_report_downloads(_request, course_id):\n    \"\"\"\n    List grade CSV files that are available for download for this course.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    report_store = ReportStore.from_config(config_name='FINANCIAL_REPORTS')\n\n    response_payload = {\n        'downloads': [\n            dict(name=name, url=url, link=HTML('<a href=\"{}\">{}</a>').format(HTML(url), Text(name)))\n            for name, url in report_store.links_for(course_id)\n        ]\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef export_ora2_data(request, course_id):\n    \"\"\"\n    Pushes a Celery task which will aggregate ora2 responses for a course into a .csv\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_export_ora2_data(request, course_key)\n        success_status = _(\"The ORA data report is being generated.\")\n\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\n            \"An ORA data report generation task is already in \"\n            \"progress. Check the 'Pending Tasks' table \"\n            \"for the status of the task. When completed, the report \"\n            \"will be available for download in the table below.\"\n        )\n\n        return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef calculate_grades_csv(request, course_id):\n    \"\"\"\n    AlreadyRunningError is raised if the course's grades are already being updated.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_calculate_grades_csv(request, course_key)\n        success_status = _(\"The grade report is being created.\"\n                           \" To view the status of the report, see Pending Tasks below.\")\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\"The grade report is currently being created.\"\n                                   \" To view the status of the report, see Pending Tasks below.\"\n                                   \" You will be able to download the report when it is complete.\")\n        return JsonResponse({\"status\": already_running_status})\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\ndef problem_grade_report(request, course_id):\n    \"\"\"\n    Request a CSV showing students' grades for all problems in the\n    course.\n\n    AlreadyRunningError is raised if the course's grades are already being\n    updated.\n    \"\"\"\n    course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    try:\n        instructor_task.api.submit_problem_grade_report(request, course_key)\n        success_status = _(\"The problem grade report is being created.\"\n                           \" To view the status of the report, see Pending Tasks below.\")\n        return JsonResponse({\"status\": success_status})\n    except AlreadyRunningError:\n        already_running_status = _(\"A problem grade report is already being generated.\"\n                                   \" To view the status of the report, see Pending Tasks below.\"\n                                   \" You will be able to download the report when it is complete.\")\n        return JsonResponse({\n            \"status\": already_running_status\n        })\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params('rolename')\ndef list_forum_members(request, course_id):\n    \"\"\"\n    Lists forum members of a certain rolename.\n    Limited to staff access.\n\n    The requesting user must be at least staff.\n    Staff forum admins can access all roles EXCEPT for FORUM_ROLE_ADMINISTRATOR\n        which is limited to instructors.\n\n    Takes query parameter `rolename`.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_by_id(course_id)\n    has_instructor_access = has_access(request.user, 'instructor', course)\n    has_forum_admin = has_forum_access(\n        request.user, course_id, FORUM_ROLE_ADMINISTRATOR\n    )\n\n    rolename = request.POST.get('rolename')\n\n    # default roles require either (staff & forum admin) or (instructor)\n    if not (has_forum_admin or has_instructor_access):\n        return HttpResponseBadRequest(\n            \"Operation requires staff & forum admin or instructor access\"\n        )\n\n    # EXCEPT FORUM_ROLE_ADMINISTRATOR requires (instructor)\n    if rolename == FORUM_ROLE_ADMINISTRATOR and not has_instructor_access:\n        return HttpResponseBadRequest(\"Operation requires instructor access.\")\n\n    # filter out unsupported for roles\n    if rolename not in [FORUM_ROLE_ADMINISTRATOR, FORUM_ROLE_MODERATOR, FORUM_ROLE_COMMUNITY_TA]:\n        return HttpResponseBadRequest(strip_tags(\n            \"Unrecognized rolename '{}'.\".format(rolename)\n        ))\n\n    try:\n        role = Role.objects.get(name=rolename, course_id=course_id)\n        users = role.users.all().order_by('username')\n    except Role.DoesNotExist:\n        users = []\n\n    def extract_user_info(user):\n        \"\"\" Convert user to dict for json rendering. \"\"\"\n        return {\n            'username': user.username,\n            'email': user.email,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n        }\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        rolename: map(extract_user_info, users),\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params(send_to=\"sending to whom\", subject=\"subject line\", message=\"message text\")\ndef send_email(request, course_id):\n    \"\"\"\n    Send an email to self, staff, or everyone involved in a course.\n    Query Parameters:\n    - 'send_to' specifies what group the email should be sent to\n       Options are defined by the CourseEmail model in\n       lms/djangoapps/bulk_email/models.py\n    - 'subject' specifies email's subject\n    - 'message' specifies email's content\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n\n    if not BulkEmailFlag.feature_enabled(course_id):\n        return HttpResponseForbidden(\"Email is not enabled for this course.\")\n\n    targets = json.loads(request.POST.get(\"send_to\"))\n    subject = request.POST.get(\"subject\")\n    message = request.POST.get(\"message\")\n\n    # allow two branding points to come from Microsites: which CourseEmailTemplate should be used\n    # and what the 'from' field in the email should be\n    #\n    # If these are None (because we are not in a Microsite or they are undefined in Microsite config) than\n    # the system will use normal system defaults\n    template_name = microsite.get_value('course_email_template_name')\n    from_addr = microsite.get_value('course_email_from_addr')\n\n    # Create the CourseEmail object.  This is saved immediately, so that\n    # any transaction that has been pending up to this point will also be\n    # committed.\n    try:\n        email = CourseEmail.create(\n            course_id,\n            request.user,\n            targets,\n            subject, message,\n            template_name=template_name,\n            from_addr=from_addr\n        )\n    except ValueError as err:\n        return HttpResponseBadRequest(repr(err))\n\n    # Submit the task, so that the correct InstructorTask object gets created (for monitoring purposes)\n    instructor_task.api.submit_bulk_course_email(request, course_id, email.id)\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'success': True,\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params(\n    unique_student_identifier=\"email or username of user to change access\",\n    rolename=\"the forum role\",\n    action=\"'allow' or 'revoke'\",\n)\n@common_exceptions_400\ndef update_forum_role_membership(request, course_id):\n    \"\"\"\n    Modify user's forum role.\n\n    The requesting user must be at least staff.\n    Staff forum admins can access all roles EXCEPT for FORUM_ROLE_ADMINISTRATOR\n        which is limited to instructors.\n    No one can revoke an instructors FORUM_ROLE_ADMINISTRATOR status.\n\n    Query parameters:\n    - `email` is the target users email\n    - `rolename` is one of [FORUM_ROLE_ADMINISTRATOR, FORUM_ROLE_MODERATOR, FORUM_ROLE_COMMUNITY_TA]\n    - `action` is one of ['allow', 'revoke']\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    course = get_course_by_id(course_id)\n    has_instructor_access = has_access(request.user, 'instructor', course)\n    has_forum_admin = has_forum_access(\n        request.user, course_id, FORUM_ROLE_ADMINISTRATOR\n    )\n\n    unique_student_identifier = request.POST.get('unique_student_identifier')\n    rolename = request.POST.get('rolename')\n    action = request.POST.get('action')\n\n    # default roles require either (staff & forum admin) or (instructor)\n    if not (has_forum_admin or has_instructor_access):\n        return HttpResponseBadRequest(\n            \"Operation requires staff & forum admin or instructor access\"\n        )\n\n    # EXCEPT FORUM_ROLE_ADMINISTRATOR requires (instructor)\n    if rolename == FORUM_ROLE_ADMINISTRATOR and not has_instructor_access:\n        return HttpResponseBadRequest(\"Operation requires instructor access.\")\n\n    if rolename not in [FORUM_ROLE_ADMINISTRATOR, FORUM_ROLE_MODERATOR, FORUM_ROLE_COMMUNITY_TA]:\n        return HttpResponseBadRequest(strip_tags(\n            \"Unrecognized rolename '{}'.\".format(rolename)\n        ))\n\n    user = get_student_from_identifier(unique_student_identifier)\n\n    try:\n        update_forum_role(course_id, user, rolename, action)\n    except Role.DoesNotExist:\n        return HttpResponseBadRequest(\"Role does not exist.\")\n\n    response_payload = {\n        'course_id': course_id.to_deprecated_string(),\n        'action': action,\n    }\n    return JsonResponse(response_payload)\n\n\n@require_POST\ndef get_user_invoice_preference(request, course_id):  # pylint: disable=unused-argument\n    \"\"\"\n    Gets invoice copy user's preferences.\n    \"\"\"\n    invoice_copy_preference = True\n    invoice_preference_value = get_user_preference(request.user, INVOICE_KEY)\n    if invoice_preference_value is not None:\n        invoice_copy_preference = invoice_preference_value == 'True'\n\n    return JsonResponse({\n        'invoice_copy': invoice_copy_preference\n    })\n\n\ndef _display_unit(unit):\n    \"\"\"\n    Gets string for displaying unit to user.\n    \"\"\"\n    name = getattr(unit, 'display_name', None)\n    if name:\n        return u'{0} ({1})'.format(name, unit.location.to_deprecated_string())\n    else:\n        return unit.location.to_deprecated_string()\n\n\n@handle_dashboard_error\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params('student', 'url', 'due_datetime')\ndef change_due_date(request, course_id):\n    \"\"\"\n    Grants a due date extension to a student for a particular unit.\n    \"\"\"\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    student = require_student_from_identifier(request.POST.get('student'))\n    unit = find_unit(course, request.POST.get('url'))\n    due_date = parse_datetime(request.POST.get('due_datetime'))\n    set_due_date_extension(course, unit, student, due_date)\n\n    return JsonResponse(_(\n        'Successfully changed due date for student {0} for {1} '\n        'to {2}').format(student.profile.name, _display_unit(unit),\n                         due_date.strftime('%Y-%m-%d %H:%M')))\n\n\n@handle_dashboard_error\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params('student', 'url')\ndef reset_due_date(request, course_id):\n    \"\"\"\n    Rescinds a due date extension for a student on a particular unit.\n    \"\"\"\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    student = require_student_from_identifier(request.POST.get('student'))\n    unit = find_unit(course, request.POST.get('url'))\n    set_due_date_extension(course, unit, student, None)\n    if not getattr(unit, \"due\", None):\n        # It's possible the normal due date was deleted after an extension was granted:\n        return JsonResponse(\n            _(\"Successfully removed invalid due date extension (unit has no due date).\")\n        )\n\n    original_due_date_str = unit.due.strftime('%Y-%m-%d %H:%M')\n    return JsonResponse(_(\n        'Successfully reset due date for student {0} for {1} '\n        'to {2}').format(student.profile.name, _display_unit(unit),\n                         original_due_date_str))\n\n\n@handle_dashboard_error\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params('url')\ndef show_unit_extensions(request, course_id):\n    \"\"\"\n    Shows all of the students which have due date extensions for the given unit.\n    \"\"\"\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    unit = find_unit(course, request.POST.get('url'))\n    return JsonResponse(dump_module_extensions(course, unit))\n\n\n@handle_dashboard_error\n@require_POST\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_post_params('student')\ndef show_student_extensions(request, course_id):\n    \"\"\"\n    Shows all of the due date extensions granted to a particular student in a\n    particular course.\n    \"\"\"\n    student = require_student_from_identifier(request.POST.get('student'))\n    course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id))\n    return JsonResponse(dump_student_extensions(course, student))\n\n\ndef _split_input_list(str_list):\n    \"\"\"\n    Separate out individual student email from the comma, or space separated string.\n\n    e.g.\n    in: \"Lorem@ipsum.dolor, sit@amet.consectetur\\nadipiscing@elit.Aenean\\r convallis@at.lacus\\r, ut@lacinia.Sed\"\n    out: ['Lorem@ipsum.dolor', 'sit@amet.consectetur', 'adipiscing@elit.Aenean', 'convallis@at.lacus', 'ut@lacinia.Sed']\n\n    `str_list` is a string coming from an input text area\n    returns a list of separated values\n    \"\"\"\n\n    new_list = re.split(r'[\\n\\r\\s,]', str_list)\n    new_list = [s.strip() for s in new_list]\n    new_list = [s for s in new_list if s != '']\n\n    return new_list\n\n\ndef _instructor_dash_url(course_key, section=None):\n    \"\"\"Return the URL for a section in the instructor dashboard.\n\n    Arguments:\n        course_key (CourseKey)\n\n    Keyword Arguments:\n        section (str): The name of the section to load.\n\n    Returns:\n        unicode: The URL of a section in the instructor dashboard.\n\n    \"\"\"\n    url = reverse('instructor_dashboard', kwargs={'course_id': unicode(course_key)})\n    if section is not None:\n        url += u'#view-{section}'.format(section=section)\n    return url\n\n\n@require_global_staff\n@require_POST\ndef generate_example_certificates(request, course_id=None):  # pylint: disable=unused-argument\n    \"\"\"Start generating a set of example certificates.\n\n    Example certificates are used to verify that certificates have\n    been configured correctly for the course.\n\n    Redirects back to the intructor dashboard once certificate\n    generation has begun.\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    certs_api.generate_example_certificates(course_key)\n    return redirect(_instructor_dash_url(course_key, section='certificates'))\n\n\n@require_global_staff\n@require_POST\ndef enable_certificate_generation(request, course_id=None):\n    \"\"\"Enable/disable self-generated certificates for a course.\n\n    Once self-generated certificates have been enabled, students\n    who have passed the course will be able to generate certificates.\n\n    Redirects back to the intructor dashboard once the\n    setting has been updated.\n\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    is_enabled = (request.POST.get('certificates-enabled', 'false') == 'true')\n    certs_api.set_cert_generation_enabled(course_key, is_enabled)\n    return redirect(_instructor_dash_url(course_key, section='certificates'))\n\n\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_level('staff')\n@require_POST\ndef mark_student_can_skip_entrance_exam(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n    Mark a student to skip entrance exam.\n    Takes `unique_student_identifier` as required POST parameter.\n    \"\"\"\n    course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id)\n    student_identifier = request.POST.get('unique_student_identifier')\n    student = get_student_from_identifier(student_identifier)\n\n    __, created = EntranceExamConfiguration.objects.get_or_create(user=student, course_id=course_id)\n    if created:\n        message = _('This student (%s) will skip the entrance exam.') % student_identifier\n    else:\n        message = _('This student (%s) is already allowed to skip the entrance exam.') % student_identifier\n    response_payload = {\n        'message': message,\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef start_certificate_generation(request, course_id):\n    \"\"\"\n    Start generating certificates for all students enrolled in given course.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    task = instructor_task.api.generate_certificates_for_students(request, course_key)\n    message = _('Certificate generation task for all students of this course has been started. '\n                'You can view the status of the generation task in the \"Pending Tasks\" section.')\n    response_payload = {\n        'message': message,\n        'task_id': task.task_id\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef start_certificate_regeneration(request, course_id):\n    \"\"\"\n    Start regenerating certificates for students whose certificate statuses lie with in 'certificate_statuses'\n    entry in POST data.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    certificates_statuses = request.POST.getlist('certificate_statuses', [])\n    if not certificates_statuses:\n        return JsonResponse(\n            {'message': _('Please select one or more certificate statuses that require certificate regeneration.')},\n            status=400\n        )\n\n    # Check if the selected statuses are allowed\n    allowed_statuses = [CertificateStatuses.downloadable, CertificateStatuses.error, CertificateStatuses.notpassing]\n    if not set(certificates_statuses).issubset(allowed_statuses):\n        return JsonResponse(\n            {'message': _('Please select certificate statuses from the list only.')},\n            status=400\n        )\n    try:\n        instructor_task.api.regenerate_certificates(request, course_key, certificates_statuses)\n    except AlreadyRunningError as error:\n        return JsonResponse({'message': error.message}, status=400)\n\n    response_payload = {\n        'message': _('Certificate regeneration task has been started. '\n                     'You can view the status of the generation task in the \"Pending Tasks\" section.'),\n        'success': True\n    }\n    return JsonResponse(response_payload)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_http_methods(['POST', 'DELETE'])\ndef certificate_exception_view(request, course_id):\n    \"\"\"\n    Add/Remove students to/from certificate white list.\n\n    :param request: HttpRequest object\n    :param course_id: course identifier of the course for whom to add/remove certificates exception.\n    :return: JsonResponse object with success/error message or certificate exception data.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    # Validate request data and return error response in case of invalid data\n    try:\n        certificate_exception, student = parse_request_data_and_get_user(request, course_key)\n    except ValueError as error:\n        return JsonResponse({'success': False, 'message': error.message}, status=400)\n\n    # Add new Certificate Exception for the student passed in request data\n    if request.method == 'POST':\n        try:\n            exception = add_certificate_exception(course_key, student, certificate_exception)\n        except ValueError as error:\n            return JsonResponse({'success': False, 'message': error.message}, status=400)\n        return JsonResponse(exception)\n\n    # Remove Certificate Exception for the student passed in request data\n    elif request.method == 'DELETE':\n        try:\n            remove_certificate_exception(course_key, student)\n        except ValueError as error:\n            return JsonResponse({'success': False, 'message': error.message}, status=400)\n\n        return JsonResponse({}, status=204)\n\n\ndef add_certificate_exception(course_key, student, certificate_exception):\n    \"\"\"\n    Add a certificate exception to CertificateWhitelist table.\n    Raises ValueError in case Student is already white listed.\n\n    :param course_key: identifier of the course whose certificate exception will be added.\n    :param student: User object whose certificate exception will be added.\n    :param certificate_exception: A dict object containing certificate exception info.\n    :return: CertificateWhitelist item in dict format containing certificate exception info.\n    \"\"\"\n    if len(CertificateWhitelist.get_certificate_white_list(course_key, student)) > 0:\n        raise ValueError(\n            _(\"Student (username/email={user}) already in certificate exception list.\").format(user=student.username)\n        )\n\n    certificate_white_list, __ = CertificateWhitelist.objects.get_or_create(\n        user=student,\n        course_id=course_key,\n        defaults={\n            'whitelist': True,\n            'notes': certificate_exception.get('notes', '')\n        }\n    )\n\n    generated_certificate = GeneratedCertificate.eligible_certificates.filter(\n        user=student,\n        course_id=course_key,\n        status=CertificateStatuses.downloadable,\n    ).first()\n\n    exception = dict({\n        'id': certificate_white_list.id,\n        'user_email': student.email,\n        'user_name': student.username,\n        'user_id': student.id,\n        'certificate_generated': generated_certificate and generated_certificate.created_date.strftime(\"%B %d, %Y\"),\n        'created': certificate_white_list.created.strftime(\"%A, %B %d, %Y\"),\n    })\n\n    return exception\n\n\ndef remove_certificate_exception(course_key, student):\n    \"\"\"\n    Remove certificate exception for given course and student from CertificateWhitelist table and\n    invalidate its GeneratedCertificate if present.\n    Raises ValueError in case no exception exists for the student in the given course.\n\n    :param course_key: identifier of the course whose certificate exception needs to be removed.\n    :param student: User object whose certificate exception needs to be removed.\n    :return:\n    \"\"\"\n    try:\n        certificate_exception = CertificateWhitelist.objects.get(user=student, course_id=course_key)\n    except ObjectDoesNotExist:\n        raise ValueError(\n            _('Certificate exception (user={user}) does not exist in certificate white list. '\n              'Please refresh the page and try again.').format(user=student.username)\n        )\n\n    try:\n        generated_certificate = GeneratedCertificate.objects.get(  # pylint: disable=no-member\n            user=student,\n            course_id=course_key\n        )\n        generated_certificate.invalidate()\n        log.info(\n            u'Certificate invalidated for %s in course %s when removed from certificate exception list',\n            student.username,\n            course_key\n        )\n    except ObjectDoesNotExist:\n        # Certificate has not been generated yet, so just remove the certificate exception from white list\n        pass\n    certificate_exception.delete()\n\n\ndef parse_request_data_and_get_user(request, course_key):\n    \"\"\"\n        Parse request data into Certificate Exception and User object.\n        Certificate Exception is the dict object containing information about certificate exception.\n\n    :param request:\n    :param course_key: Course Identifier of the course for whom to process certificate exception\n    :return: key-value pairs containing certificate exception data and User object\n    \"\"\"\n    certificate_exception = parse_request_data(request)\n\n    user = certificate_exception.get('user_name', '') or certificate_exception.get('user_email', '')\n    if not user:\n        raise ValueError(_('Student username/email field is required and can not be empty. '\n                           'Kindly fill in username/email and then press \"Add to Exception List\" button.'))\n    db_user = get_student(user, course_key)\n\n    return certificate_exception, db_user\n\n\ndef parse_request_data(request):\n    \"\"\"\n    Parse and return request data, raise ValueError in case of invalid JSON data.\n\n    :param request: HttpRequest request object.\n    :return: dict object containing parsed json data.\n    \"\"\"\n    try:\n        data = json.loads(request.body or '{}')\n    except ValueError:\n        raise ValueError(_('The record is not in the correct format. Please add a valid username or email address.'))\n\n    return data\n\n\ndef get_student(username_or_email, course_key):\n    \"\"\"\n    Retrieve and return User object from db, raise ValueError\n    if user is does not exists or is not enrolled in the given course.\n\n    :param username_or_email: String containing either user name or email of the student.\n    :param course_key: CourseKey object identifying the current course.\n    :return: User object\n    \"\"\"\n    try:\n        student = get_user_by_username_or_email(username_or_email)\n    except ObjectDoesNotExist:\n        raise ValueError(_(\"{user} does not exist in the LMS. Please check your spelling and retry.\").format(\n            user=username_or_email\n        ))\n\n    # Make Sure the given student is enrolled in the course\n    if not CourseEnrollment.is_enrolled(student, course_key):\n        raise ValueError(_(\"{user} is not enrolled in this course. Please check your spelling and retry.\")\n                         .format(user=username_or_email))\n    return student\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef generate_certificate_exceptions(request, course_id, generate_for=None):\n    \"\"\"\n    Generate Certificate for students in the Certificate White List.\n\n    :param request: HttpRequest object,\n    :param course_id: course identifier of the course for whom to generate certificates\n    :param generate_for: string to identify whether to generate certificates for 'all' or 'new'\n            additions to the certificate white-list\n    :return: JsonResponse object containing success/failure message and certificate exception data\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n\n    if generate_for == 'all':\n        # Generate Certificates for all white listed students\n        students = 'all_whitelisted'\n\n    elif generate_for == 'new':\n        students = 'whitelisted_not_generated'\n\n    else:\n        # Invalid data, generate_for must be present for all certificate exceptions\n        return JsonResponse(\n            {\n                'success': False,\n                'message': _('Invalid data, generate_for must be \"new\" or \"all\".'),\n            },\n            status=400\n        )\n\n    instructor_task.api.generate_certificates_for_students(request, course_key, student_set=students)\n\n    response_payload = {\n        'success': True,\n        'message': _('Certificate generation started for white listed students.'),\n    }\n\n    return JsonResponse(response_payload)\n\n\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_POST\ndef generate_bulk_certificate_exceptions(request, course_id):  # pylint: disable=invalid-name\n    \"\"\"\n    Add Students to certificate white list from the uploaded csv file.\n    :return response in dict format.\n    {\n        general_errors: [errors related to csv file e.g. csv uploading, csv attachment, content reading etc. ],\n        row_errors: {\n            data_format_error:              [users/data in csv file that are not well formatted],\n            user_not_exist:                 [csv with none exiting users in LMS system],\n            user_already_white_listed:      [users that are already white listed],\n            user_not_enrolled:              [rows with not enrolled users in the given course]\n        },\n        success: [list of successfully added users to the certificate white list model]\n    }\n    \"\"\"\n    user_index = 0\n    notes_index = 1\n    row_errors_key = ['data_format_error', 'user_not_exist', 'user_already_white_listed', 'user_not_enrolled']\n    course_key = CourseKey.from_string(course_id)\n    students, general_errors, success = [], [], []\n    row_errors = {key: [] for key in row_errors_key}\n\n    def build_row_errors(key, _user, row_count):\n        \"\"\"\n        inner method to build dict of csv data as row errors.\n        \"\"\"\n        row_errors[key].append(_('user \"{user}\" in row# {row}').format(user=_user, row=row_count))\n\n    if 'students_list' in request.FILES:\n        try:\n            upload_file = request.FILES.get('students_list')\n            if upload_file.name.endswith('.csv'):\n                students = [row for row in csv.reader(upload_file.read().splitlines())]\n            else:\n                general_errors.append(_('Make sure that the file you upload is in CSV format with no '\n                                        'extraneous characters or rows.'))\n\n        except Exception:  # pylint: disable=broad-except\n            general_errors.append(_('Could not read uploaded file.'))\n        finally:\n            upload_file.close()\n\n        row_num = 0\n        for student in students:\n            row_num += 1\n            # verify that we have exactly two column in every row either email or username and notes but allow for\n            # blank lines\n            if len(student) != 2:\n                if len(student) > 0:\n                    build_row_errors('data_format_error', student[user_index], row_num)\n                    log.info(u'invalid data/format in csv row# %s', row_num)\n                continue\n\n            user = student[user_index]\n            try:\n                user = get_user_by_username_or_email(user)\n            except ObjectDoesNotExist:\n                build_row_errors('user_not_exist', user, row_num)\n                log.info(u'student %s does not exist', user)\n            else:\n                if len(CertificateWhitelist.get_certificate_white_list(course_key, user)) > 0:\n                    build_row_errors('user_already_white_listed', user, row_num)\n                    log.warning(u'student %s already exist.', user.username)\n\n                # make sure user is enrolled in course\n                elif not CourseEnrollment.is_enrolled(user, course_key):\n                    build_row_errors('user_not_enrolled', user, row_num)\n                    log.warning(u'student %s is not enrolled in course.', user.username)\n\n                else:\n                    CertificateWhitelist.objects.create(\n                        user=user,\n                        course_id=course_key,\n                        whitelist=True,\n                        notes=student[notes_index]\n                    )\n                    success.append(_('user \"{username}\" in row# {row}').format(username=user.username, row=row_num))\n\n    else:\n        general_errors.append(_('File is not attached.'))\n\n    results = {\n        'general_errors': general_errors,\n        'row_errors': row_errors,\n        'success': success\n    }\n\n    return JsonResponse(results)\n\n\n@transaction.non_atomic_requests\n@ensure_csrf_cookie\n@cache_control(no_cache=True, no_store=True, must_revalidate=True)\n@require_global_staff\n@require_http_methods(['POST', 'DELETE'])\ndef certificate_invalidation_view(request, course_id):\n    \"\"\"\n    Invalidate/Re-Validate students to/from certificate.\n\n    :param request: HttpRequest object\n    :param course_id: course identifier of the course for whom to add/remove certificates exception.\n    :return: JsonResponse object with success/error message or certificate invalidation data.\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    # Validate request data and return error response in case of invalid data\n    try:\n        certificate_invalidation_data = parse_request_data(request)\n        certificate = validate_request_data_and_get_certificate(certificate_invalidation_data, course_key)\n    except ValueError as error:\n        return JsonResponse({'message': error.message}, status=400)\n\n    # Invalidate certificate of the given student for the course course\n    if request.method == 'POST':\n        try:\n            certificate_invalidation = invalidate_certificate(request, certificate, certificate_invalidation_data)\n        except ValueError as error:\n            return JsonResponse({'message': error.message}, status=400)\n        return JsonResponse(certificate_invalidation)\n\n    # Re-Validate student certificate for the course course\n    elif request.method == 'DELETE':\n        try:\n            re_validate_certificate(request, course_key, certificate)\n        except ValueError as error:\n            return JsonResponse({'message': error.message}, status=400)\n\n        return JsonResponse({}, status=204)\n\n\ndef invalidate_certificate(request, generated_certificate, certificate_invalidation_data):\n    \"\"\"\n    Invalidate given GeneratedCertificate and add CertificateInvalidation record for future reference or re-validation.\n\n    :param request: HttpRequest object\n    :param generated_certificate: GeneratedCertificate object, the certificate we want to invalidate\n    :param certificate_invalidation_data: dict object containing data for CertificateInvalidation.\n    :return: dict object containing updated certificate invalidation data.\n    \"\"\"\n    if len(CertificateInvalidation.get_certificate_invalidations(\n            generated_certificate.course_id,\n            generated_certificate.user,\n    )) > 0:\n        raise ValueError(\n            _(\"Certificate of {user} has already been invalidated. Please check your spelling and retry.\").format(\n                user=generated_certificate.user.username,\n            )\n        )\n\n    # Verify that certificate user wants to invalidate is a valid one.\n    if not generated_certificate.is_valid():\n        raise ValueError(\n            _(\"Certificate for student {user} is already invalid, kindly verify that certificate was generated \"\n              \"for this student and then proceed.\").format(user=generated_certificate.user.username)\n        )\n\n    # Add CertificateInvalidation record for future reference or re-validation\n    certificate_invalidation, __ = CertificateInvalidation.objects.update_or_create(\n        generated_certificate=generated_certificate,\n        defaults={\n            'invalidated_by': request.user,\n            'notes': certificate_invalidation_data.get(\"notes\", \"\"),\n            'active': True,\n        }\n    )\n\n    # Invalidate GeneratedCertificate\n    generated_certificate.invalidate()\n    return {\n        'id': certificate_invalidation.id,\n        'user': certificate_invalidation.generated_certificate.user.username,\n        'invalidated_by': certificate_invalidation.invalidated_by.username,\n        'created': certificate_invalidation.created.strftime(\"%B %d, %Y\"),\n        'notes': certificate_invalidation.notes,\n    }\n\n\ndef re_validate_certificate(request, course_key, generated_certificate):\n    \"\"\"\n    Remove certificate invalidation from db and start certificate generation task for this student.\n    Raises ValueError if certificate invalidation is present.\n\n    :param request: HttpRequest object\n    :param course_key: CourseKey object identifying the current course.\n    :param generated_certificate: GeneratedCertificate object of the student for the given course\n    \"\"\"\n    try:\n        # Fetch CertificateInvalidation object\n        certificate_invalidation = CertificateInvalidation.objects.get(generated_certificate=generated_certificate)\n    except ObjectDoesNotExist:\n        raise ValueError(_(\"Certificate Invalidation does not exist, Please refresh the page and try again.\"))\n    else:\n        # Deactivate certificate invalidation if it was fetched successfully.\n        certificate_invalidation.deactivate()\n\n    # We need to generate certificate only for a single student here\n    student = certificate_invalidation.generated_certificate.user\n    instructor_task.api.generate_certificates_for_students(\n        request, course_key, student_set=\"specific_student\", specific_student_id=student.id\n    )\n\n\ndef validate_request_data_and_get_certificate(certificate_invalidation, course_key):\n    \"\"\"\n    Fetch and return GeneratedCertificate of the student passed in request data for the given course.\n\n    Raises ValueError in case of missing student username/email or\n    if student does not have certificate for the given course.\n\n    :param certificate_invalidation: dict containing certificate invalidation data\n    :param course_key: CourseKey object identifying the current course.\n    :return: GeneratedCertificate object of the student for the given course\n    \"\"\"\n    user = certificate_invalidation.get(\"user\")\n\n    if not user:\n        raise ValueError(\n            _('Student username/email field is required and can not be empty. '\n              'Kindly fill in username/email and then press \"Invalidate Certificate\" button.')\n        )\n\n    student = get_student(user, course_key)\n\n    certificate = GeneratedCertificate.certificate_for_student(student, course_key)\n    if not certificate:\n        raise ValueError(_(\n            \"The student {student} does not have certificate for the course {course}. Kindly verify student \"\n            \"username/email and the selected course are correct and try again.\"\n        ).format(student=student.username, course=course_key.course))\n    return certificate\n", "###\nData Download Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\n# Load utilities\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\nPendingInstructorTasks = -> window.InstructorDashboard.util.PendingInstructorTasks\nReportDownloads = -> window.InstructorDashboard.util.ReportDownloads\n\n# Data Download Certificate issued\nclass @DataDownload_Certificate\n  constructor: (@$container) ->\n    # gather elements\n    @$list_issued_certificate_table_btn = @$container.find(\"input[name='issued-certificates-list']\")\n    @$list_issued_certificate_csv_btn = @$container.find(\"input[name='issued-certificates-csv']\")\n    @$certificate_display_table       = @$container.find '.certificate-data-display-table'\n    @$certificates_request_response_error  = @$container.find '.issued-certificates-error.request-response-error'\n\n\n    @$list_issued_certificate_table_btn.click (e) =>\n      url = @$list_issued_certificate_table_btn.data 'endpoint'\n      # Dynamically generate slickgrid table for displaying issued certificate information.\n      @clear_ui()\n      @$certificate_display_table.text gettext('Loading data...')\n      # fetch user list\n      $.ajax\n        type: 'POST'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_ui()\n          @$certificates_request_response_error.text gettext(\"Error getting issued certificates list.\")\n          $(\".issued_certificates .issued-certificates-error.msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @clear_ui()\n          # display on a SlickGrid\n          options =\n            enableCellNavigation: true\n            enableColumnReorder: false\n            forceFitColumns: true\n            rowHeight: 35\n\n          columns = ({id: feature, field: feature, name: data.feature_names[feature]} for feature in data.queried_features)\n          grid_data = data.certificates\n\n          $table_placeholder = $ '<div/>', class: 'slickgrid'\n          @$certificate_display_table.append $table_placeholder\n          new Slick.Grid($table_placeholder, grid_data, columns, options)\n\n    @$list_issued_certificate_csv_btn.click (e) =>\n      @clear_ui()\n      url = @$list_issued_certificate_csv_btn.data 'endpoint'\n      location.href = url + '?csv=true'\n\n  clear_ui: ->\n    # Clear any generated tables, warning messages, etc of certificates.\n    @$certificate_display_table.empty()\n    @$certificates_request_response_error.empty()\n    $(\".issued-certificates-error.msg-error\").css({\"display\":\"none\"})\n\n# Data Download Section\nclass DataDownload\n  constructor: (@$section) ->\n    # attach self to html so that instructor_dashboard.coffee can find\n    #  this object to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # isolate # initialize DataDownload_Certificate subsection\n    new DataDownload_Certificate @$section.find '.issued_certificates'\n\n    # gather elements\n    @$list_studs_btn = @$section.find(\"input[name='list-profiles']\")\n    @$list_studs_csv_btn = @$section.find(\"input[name='list-profiles-csv']\")\n    @$list_proctored_exam_results_csv_btn = @$section.find(\"input[name='proctored-exam-results-report']\")\n    @$survey_results_csv_btn = @$section.find(\"input[name='survey-results-report']\")\n    @$list_may_enroll_csv_btn = @$section.find(\"input[name='list-may-enroll-csv']\")\n    @$list_problem_responses_csv_input = @$section.find(\"input[name='problem-location']\")\n    @$list_problem_responses_csv_btn = @$section.find(\"input[name='list-problem-responses-csv']\")\n    @$list_anon_btn = @$section.find(\"input[name='list-anon-ids']\")\n    @$grade_config_btn = @$section.find(\"input[name='dump-gradeconf']\")\n    @$calculate_grades_csv_btn = @$section.find(\"input[name='calculate-grades-csv']\")\n    @$problem_grade_report_csv_btn = @$section.find(\"input[name='problem-grade-report']\")\n    @$async_report_btn = @$section.find(\"input[class='async-report-btn']\")\n\n    # response areas\n    @$download                        = @$section.find '.data-download-container'\n    @$download_display_text           = @$download.find '.data-display-text'\n    @$download_request_response_error = @$download.find '.request-response-error'\n    @$reports                         = @$section.find '.reports-download-container'\n    @$download_display_table          = @$reports.find '.profile-data-display-table'\n    @$reports_request_response        = @$reports.find '.request-response'\n    @$reports_request_response_error  = @$reports.find '.request-response-error'\n\n    @report_downloads = new (ReportDownloads()) @$section\n    @instructor_tasks = new (PendingInstructorTasks()) @$section\n    @clear_display()\n\n    # attach click handlers\n    # The list-anon case is always CSV\n    @$list_anon_btn.click (e) =>\n      url = @$list_anon_btn.data 'endpoint'\n      location.href = url\n\n    # attach click handlers\n    # The list_proctored_exam_results case is always CSV\n    @$list_proctored_exam_results_csv_btn.click (e) =>\n      url = @$list_proctored_exam_results_csv_btn.data 'endpoint'\n      # display html from proctored exam results config endpoint\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$reports_request_response_error.text gettext(\n            \"Error generating proctored exam results. Please try again.\"\n          )\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @clear_display()\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    # attach click handlers\n    # The list_proctored_exam_results case is always CSV\n    @$survey_results_csv_btn.click (e) =>\n      url = @$survey_results_csv_btn.data 'endpoint'\n      # display html from survey results config endpoint\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$reports_request_response_error.text gettext(\n            \"Error generating survey results. Please try again.\"\n          )\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @clear_display()\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    # this handler binds to both the download\n    # and the csv button\n    @$list_studs_csv_btn.click (e) =>\n      @clear_display()\n\n      url = @$list_studs_csv_btn.data 'endpoint'\n      # handle csv special case\n      # redirect the document to the csv file.\n      url += '/csv'\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @$reports_request_response_error.text gettext(\"Error generating student profile information. Please try again.\")\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    @$list_studs_btn.click (e) =>\n      url = @$list_studs_btn.data 'endpoint'\n\n      # Dynamically generate slickgrid table for displaying student profile information\n      @clear_display()\n      @$download_display_table.text gettext('Loading')\n\n      # fetch user list\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$download_request_response_error.text gettext(\"Error getting student list.\")\n        success: (data) =>\n          @clear_display()\n\n          # display on a SlickGrid\n          options =\n            enableCellNavigation: true\n            enableColumnReorder: false\n            forceFitColumns: true\n            rowHeight: 35\n\n          columns = ({id: feature, field: feature, name: data.feature_names[feature]} for feature in data.queried_features)\n          grid_data = data.students\n\n          $table_placeholder = $ '<div/>', class: 'slickgrid'\n          @$download_display_table.append $table_placeholder\n          grid = new Slick.Grid($table_placeholder, grid_data, columns, options)\n          # grid.autosizeColumns()\n\n    @$list_problem_responses_csv_btn.click (e) =>\n      @clear_display()\n\n      url = @$list_problem_responses_csv_btn.data 'endpoint'\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        data:\n          problem_location: @$list_problem_responses_csv_input.val()\n        error: (std_ajax_err) =>\n          @$reports_request_response_error.text JSON.parse(std_ajax_err['responseText'])\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    @$list_may_enroll_csv_btn.click (e) =>\n      @clear_display()\n\n      url = @$list_may_enroll_csv_btn.data 'endpoint'\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @$reports_request_response_error.text gettext(\"Error generating list of students who may enroll. Please try again.\")\n          $(\".msg-error\").css({\"display\":\"block\"})\n        success: (data) =>\n          @$reports_request_response.text data['status']\n          $(\".msg-confirm\").css({\"display\":\"block\"})\n\n    @$grade_config_btn.click (e) =>\n      url = @$grade_config_btn.data 'endpoint'\n      # display html from grading config endpoint\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        error: (std_ajax_err) =>\n          @clear_display()\n          @$download_request_response_error.text gettext(\"Error retrieving grading configuration.\")\n        success: (data) =>\n          @clear_display()\n          @$download_display_text.html data['grading_config_summary']\n\n    @$async_report_btn.click (e) =>\n        # Clear any CSS styling from the request-response areas\n        #$(\".msg-confirm\").css({\"display\":\"none\"})\n        #$(\".msg-error\").css({\"display\":\"none\"})\n        @clear_display()\n        url = $(e.target).data 'endpoint'\n        $.ajax\n          type: 'POST'\n          dataType: 'json'\n          url: url\n          error: std_ajax_err =>\n            if e.target.name == 'calculate-grades-csv'\n              @$grades_request_response_error.text gettext(\"Error generating grades. Please try again.\")\n            else if e.target.name == 'problem-grade-report'\n              @$grades_request_response_error.text gettext(\"Error generating problem grade report. Please try again.\")\n            else if e.target.name == 'export-ora2-data'\n              @$grades_request_response_error.text gettext(\"Error generating ORA data report. Please try again.\")\n            $(\".msg-error\").css({\"display\":\"block\"})\n          success: (data) =>\n            @$reports_request_response.text data['status']\n            $(\".msg-confirm\").css({\"display\":\"block\"})\n\n  # handler for when the section title is clicked.\n  onClickTitle: ->\n    # Clear display of anything that was here before\n    @clear_display()\n    @instructor_tasks.task_poller.start()\n    @report_downloads.downloads_poller.start()\n\n  # handler for when the section is closed\n  onExit: ->\n    @instructor_tasks.task_poller.stop()\n    @report_downloads.downloads_poller.stop()\n\n  clear_display: ->\n    # Clear any generated tables, warning messages, etc.\n    @$download_display_text.empty()\n    @$download_display_table.empty()\n    @$download_request_response_error.empty()\n    @$reports_request_response.empty()\n    @$reports_request_response_error.empty()\n    # Clear any CSS styling from the request-response areas\n    $(\".msg-confirm\").css({\"display\":\"none\"})\n    $(\".msg-error\").css({\"display\":\"none\"})\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n  DataDownload: DataDownload\n", "###\nExtensions Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\nplantTimeout = -> window.InstructorDashboard.util.plantTimeout.apply this, arguments\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\n\n# Extensions Section\nclass Extensions\n\n  constructor: (@$section) ->\n    # attach self to html\n    # so that instructor_dashboard.coffee can find this object\n    # to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # Gather buttons\n    @$change_due_date = @$section.find(\"input[name='change-due-date']\")\n    @$reset_due_date = @$section.find(\"input[name='reset-due-date']\")\n    @$show_unit_extensions = @$section.find(\"input[name='show-unit-extensions']\")\n    @$show_student_extensions = @$section.find(\"input[name='show-student-extensions']\")\n\n    # Gather notification areas\n    @$section.find(\".request-response\").hide()\n    @$section.find(\".request-response-error\").hide()\n\n    # Gather grid elements\n    $grid_display = @$section.find '.data-display'\n    @$grid_text = $grid_display.find '.data-display-text'\n    @$grid_table = $grid_display.find '.data-display-table'\n\n    # Click handlers\n    @$change_due_date.click =>\n      @clear_display()\n      @$student_input = @$section.find(\"#set-extension input[name='student']\")\n      @$url_input = @$section.find(\"#set-extension select[name='url']\")\n      @$due_datetime_input = @$section.find(\"#set-extension input[name='due_datetime']\")\n      send_data =\n        student: @$student_input.val()\n        url: @$url_input.val()\n        due_datetime: @$due_datetime_input.val()\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$change_due_date.data 'endpoint'\n        data: send_data\n        success: (data) => @display_response \"set-extension\", data\n        error: (xhr) => @fail_with_error \"set-extension\", \"Error changing due date\", xhr\n\n    @$reset_due_date.click =>\n      @clear_display()\n      @$student_input = @$section.find(\"#reset-extension input[name='student']\")\n      @$url_input = @$section.find(\"#reset-extension select[name='url']\")\n      send_data =\n        student: @$student_input.val()\n        url: @$url_input.val()\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$reset_due_date.data 'endpoint'\n        data: send_data\n        success: (data) => @display_response \"reset-extension\", data\n        error: (xhr) => @fail_with_error \"reset-extension\", \"Error reseting due date\", xhr\n\n    @$show_unit_extensions.click =>\n      @clear_display()\n      @$grid_table.text 'Loading'\n\n      @$url_input = @$section.find(\"#view-granted-extensions select[name='url']\")\n      url = @$show_unit_extensions.data 'endpoint'\n      send_data =\n        url: @$url_input.val()\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        data: send_data\n        error: (xhr) => @fail_with_error \"view-granted-extensions\", \"Error getting due dates\", xhr\n        success: (data) => @display_grid data\n\n    @$show_student_extensions.click =>\n      @clear_display()\n      @$grid_table.text 'Loading'\n\n      url = @$show_student_extensions.data 'endpoint'\n      @$student_input = @$section.find(\"#view-granted-extensions input[name='student']\")\n      send_data =\n        student: @$student_input.val()\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: url\n        data: send_data\n        error: (xhr) => @fail_with_error \"view-granted-extensions\", \"Error getting due dates\", xhr\n        success: (data) => @display_grid data\n      \n  # handler for when the section title is clicked.\n  onClickTitle: ->\n\n  fail_with_error: (id, msg, xhr) ->\n    $task_error = @$section.find(\"#\" + id + \" .request-response-error\")\n    $task_response = @$section.find(\"#\" + id + \" .request-response\")\n    @clear_display()\n    data = $.parseJSON xhr.responseText\n    msg += \": \" + data['error']\n    console.warn msg\n    $task_response.empty()\n    $task_error.empty()\n    $task_error.text msg\n    $task_error.show()\n\n  display_response: (id, data) ->\n    $task_error = @$section.find(\"#\" + id + \" .request-response-error\")\n    $task_response = @$section.find(\"#\" + id + \" .request-response\")\n    $task_error.empty().hide()\n    $task_response.empty().text data\n    $task_response.show()\n\n  display_grid: (data) ->\n    @clear_display()\n    @$grid_text.text data.title\n\n    # display on a SlickGrid\n    options =\n      enableCellNavigation: true\n      enableColumnReorder: false\n      forceFitColumns: true\n\n    columns = ({id: col, field: col, name: col} for col in data.header)\n    grid_data = data.data\n\n    $table_placeholder = $ '<div/>', class: 'slickgrid', style: 'min-height: 400px'\n    @$grid_table.append $table_placeholder\n    grid = new Slick.Grid($table_placeholder, grid_data, columns, options)\n\n  clear_display: ->\n    @$grid_text.empty()\n    @$grid_table.empty()\n    @$section.find(\".request-response-error\").empty().hide()\n    @$section.find(\".request-response\").empty().hide()\n\n# export for use\n# create parent namespaces if they do not already exist.\n# abort if underscore can not be found.\nif _?\n  _.defaults window, InstructorDashboard: {}\n  _.defaults window.InstructorDashboard, sections: {}\n  _.defaults window.InstructorDashboard.sections,\n    Extensions: Extensions\n", "###\nMembership Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\nplantTimeout = -> window.InstructorDashboard.util.plantTimeout.apply this, arguments\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\nemailStudents = false\n\n\nclass MemberListWidget\n  # create a MemberListWidget `$container` is a jquery object to embody.\n  # `params` holds template parameters. `params` should look like the defaults below.\n  constructor: (@$container, params={}) ->\n    params = _.defaults params,\n      title: \"Member List\"\n      info: \"\"\"\n        Use this list to manage members.\n      \"\"\"\n      labels: [\"field1\", \"field2\", \"field3\"]\n      add_placeholder: \"Enter name\"\n      add_btn_label: \"Add Member\"\n      add_handler: (input) ->\n\n    template_html = $(\"#member-list-widget-template\").html()\n    @$container.html Mustache.render template_html, params\n\n    # bind add button\n    @$('input[type=\"button\"].add').click =>\n      params.add_handler? @$('.add-field').val()\n\n  # clear the input text field\n  clear_input: -> @$('.add-field').val ''\n\n  # clear all table rows\n  clear_rows: -> @$('table tbody').empty()\n\n  # takes a table row as an array items are inserted as text, unless detected\n  # as a jquery objects in which case they are inserted directly. if an\n  # element is a jquery object\n  add_row: (row_array) ->\n    $tbody = @$('table tbody')\n    $tr = $ '<tr>'\n    for item in row_array\n      $td = $ '<td>'\n      if item instanceof jQuery\n        $td.append item\n      else\n        $td.text item\n      $tr.append $td\n    $tbody.append $tr\n\n  # local selector\n  $: (selector) ->\n    if @debug?\n      s = @$container.find selector\n      if s?.length != 1\n        console.warn \"local selector '#{selector}' found (#{s.length}) results\"\n      s\n    else\n      @$container.find selector\n\n\nclass AuthListWidget extends MemberListWidget\n  constructor: ($container, @rolename, @$error_section) ->\n    super $container,\n      title: $container.data 'display-name'\n      info: $container.data 'info-text'\n      labels: [gettext(\"Username\"), gettext(\"Email\"), gettext(\"Revoke access\")]\n      add_placeholder: gettext(\"Enter username or email\")\n      add_btn_label: $container.data 'add-button-label'\n      add_handler: (input) => @add_handler input\n\n    @debug = true\n    @list_endpoint = $container.data 'list-endpoint'\n    @modify_endpoint = $container.data 'modify-endpoint'\n    unless @rolename?\n      throw \"AuthListWidget missing @rolename\"\n\n    @reload_list()\n\n  # action to do when is reintroduced into user's view\n  re_view: ->\n    @clear_errors()\n    @clear_input()\n    @reload_list()\n\n  # handle clicks on the add button\n  add_handler: (input) ->\n    if input? and input isnt ''\n      @modify_member_access input, 'allow', (error) =>\n        # abort on error\n        return @show_errors error unless error is null\n        @clear_errors()\n        @clear_input()\n        @reload_list()\n    else\n      @show_errors gettext \"Please enter a username or email.\"\n\n  # reload the list of members\n  reload_list: ->\n    # @clear_rows()\n    @get_member_list (error, member_list) =>\n      # abort on error\n      return @show_errors error unless error is null\n\n      # only show the list of there are members\n      @clear_rows()\n\n      # use _.each instead of 'for' so that member\n      # is bound in the button callback.\n      _.each member_list, (member) =>\n        # if there are members, show the list\n\n        # create revoke button and insert it into the row\n        label_trans = gettext(\"Revoke access\")\n        $revoke_btn = $ _.template('<div class=\"revoke\"><span class=\"icon fa fa-times-circle\" aria-hidden=\"true\"></span> <%= label %></div>')({label: label_trans}),\n          class: 'revoke'\n        $revoke_btn.click =>\n            @modify_member_access member.email, 'revoke', (error) =>\n              # abort on error\n              return @show_errors error unless error is null\n              @clear_errors()\n              @reload_list()\n        @add_row [member.username, member.email, $revoke_btn]\n\n  # clear error display\n  clear_errors: -> @$error_section?.text ''\n\n  # set error display\n  show_errors: (msg) -> @$error_section?.text msg\n\n  # send ajax request to list members\n  # `cb` is called with cb(error, member_list)\n  get_member_list: (cb) ->\n    $.ajax\n      type: 'POST'\n      dataType: 'json'\n      url: @list_endpoint\n      data: rolename: @rolename\n      success: (data) => cb? null, data[@rolename]\n      error: std_ajax_err =>\n        `// Translators: A rolename appears this sentence. A rolename is something like \"staff\" or \"beta tester\".`\n        cb? gettext(\"Error fetching list for role\") + \" '#{@rolename}'\"\n\n  # send ajax request to modify access\n  # (add or remove them from the list)\n  # `action` can be 'allow' or 'revoke'\n  # `cb` is called with cb(error, data)\n  modify_member_access: (unique_student_identifier, action, cb) ->\n    $.ajax\n      type: 'POST'\n      dataType: 'json'\n      url: @modify_endpoint\n      data:\n        unique_student_identifier: unique_student_identifier\n        rolename: @rolename\n        action: action\n      success: (data) => @member_response data\n      error: std_ajax_err => cb? gettext \"Error changing user's permissions.\"\n\n  member_response: (data) ->\n    @clear_errors()\n    @clear_input()\n    if data.userDoesNotExist\n      msg = gettext(\"Could not find a user with username or email address '<%= identifier %>'.\")\n      @show_errors _.template(msg, {identifier: data.unique_student_identifier})\n    else if data.inactiveUser\n      msg = gettext(\"Error: User '<%= username %>' has not yet activated their account. Users must create and activate their accounts before they can be assigned a role.\")\n      @show_errors _.template(msg, {username: data.unique_student_identifier})\n    else if data.removingSelfAsInstructor\n      @show_errors gettext \"Error: You cannot remove yourself from the Instructor group!\"\n    else\n      @reload_list()\n\nclass @AutoEnrollmentViaCsv\n  constructor: (@$container) ->\n    # Wrapper for the AutoEnrollmentViaCsv subsection.\n    # This object handles buttons, success and failure reporting,\n    # and server communication.\n    @$student_enrollment_form = @$container.find(\"form#student-auto-enroll-form\")\n    @$enrollment_signup_button = @$container.find(\"[name='enrollment_signup_button']\")\n    @$students_list_file = @$container.find(\"input[name='students_list']\")\n    @$csrf_token = @$container.find(\"input[name='csrfmiddlewaretoken']\")\n    @$results = @$container.find(\"div.results\")\n    @$browse_button = @$container.find(\"#browseBtn\")\n    @$browse_file = @$container.find(\"#browseFile\")\n\n    @processing = false\n\n    @$browse_button.on \"change\", (event) =>\n      if event.currentTarget.files.length == 1\n        @$browse_file.val(event.currentTarget.value.substring(event.currentTarget.value.lastIndexOf(\"\\\\\") + 1))\n\n    # attach click handler for @$enrollment_signup_button\n    @$enrollment_signup_button.click =>\n      @$student_enrollment_form.submit (event) =>\n        if @processing\n          return false\n\n        @processing = true\n\n        event.preventDefault()\n        data = new FormData(event.currentTarget)\n        $.ajax\n            dataType: 'json'\n            type: 'POST'\n            url: event.currentTarget.action\n            data: data\n            processData: false\n            contentType: false\n            success: (data) =>\n              @processing = false\n              @display_response data\n\n        return false\n\n  display_response: (data_from_server) ->\n    @$results.empty()\n    errors = []\n    warnings = []\n    result_from_server_is_success = true\n\n    if data_from_server.general_errors.length\n      result_from_server_is_success = false\n      for general_error in data_from_server.general_errors\n        general_error['is_general_error'] = true\n        errors.push general_error\n\n    if data_from_server.row_errors.length\n      result_from_server_is_success = false\n      for error in data_from_server.row_errors\n        error['is_general_error'] = false\n        errors.push error\n\n    if data_from_server.warnings.length\n      result_from_server_is_success = false\n      for warning in data_from_server.warnings\n        warning['is_general_error'] = false\n        warnings.push warning\n\n    render_response = (title, message, type, student_results) =>\n      details = []\n      for student_result in student_results\n        if student_result.is_general_error\n          details.push student_result.response\n        else\n          response_message = student_result.username + '  ('+ student_result.email + '):  ' + '   (' + student_result.response + ')'\n          details.push response_message\n\n      @$results.append @render_notification_view type, title, message, details\n\n    if errors.length\n      render_response gettext('Errors'), gettext(\"The following errors were generated:\"), 'error', errors\n    if warnings.length\n      render_response gettext('Warnings'), gettext(\"The following warnings were generated:\"), 'warning', warnings\n    if result_from_server_is_success\n      render_response gettext('Success'), gettext(\"All accounts were created successfully.\"), 'confirmation', []\n\n  render_notification_view: (type, title, message, details) ->\n    notification_model = new NotificationModel()\n    notification_model.set({\n          'type': type,\n          'title': title,\n          'message': message,\n          'details': details,\n    });\n    view = new NotificationView(model:notification_model);\n    view.render()\n    return view.$el.html()\n\nclass BetaTesterBulkAddition\n  constructor: (@$container) ->\n    # gather elements\n    @$identifier_input       = @$container.find(\"textarea[name='student-ids-for-beta']\")\n    @$btn_beta_testers       = @$container.find(\"input[name='beta-testers']\")\n    @$checkbox_autoenroll    = @$container.find(\"input[name='auto-enroll']\")\n    @$checkbox_emailstudents = @$container.find(\"input[name='email-students-beta']\")\n    @$task_response          = @$container.find(\".request-response\")\n    @$request_response_error = @$container.find(\".request-response-error\")\n\n    # click handlers\n    @$btn_beta_testers.click (event) =>\n      emailStudents = @$checkbox_emailstudents.is(':checked')\n      autoEnroll = @$checkbox_autoenroll.is(':checked')\n      send_data =\n        action: $(event.target).data('action')  # 'add' or 'remove'\n        identifiers: @$identifier_input.val()\n        email_students: emailStudents\n        auto_enroll: autoEnroll\n\n      $.ajax\n        dataType: 'json'\n        type: 'POST'\n        url: @$btn_beta_testers.data 'endpoint'\n        data: send_data\n        success: (data) => @display_response data\n        error: std_ajax_err => @fail_with_error gettext \"Error adding/removing users as beta testers.\"\n\n  # clear the input text field\n  clear_input: ->\n    @$identifier_input.val ''\n    # default for the checkboxes should be checked\n    @$checkbox_emailstudents.attr('checked', true)\n    @$checkbox_autoenroll.attr('checked', true)\n\n  fail_with_error: (msg) ->\n    console.warn msg\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n    @$request_response_error.text msg\n\n  display_response: (data_from_server) ->\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n    errors = []\n    successes = []\n    no_users = []\n    for student_results in data_from_server.results\n      if student_results.userDoesNotExist\n        no_users.push student_results\n      else if student_results.error\n        errors.push student_results\n      else\n        successes.push student_results\n\n    render_list = (label, ids) =>\n      task_res_section = $ '<div/>', class: 'request-res-section'\n      task_res_section.append $ '<h3/>', text: label\n      ids_list = $ '<ul/>'\n      task_res_section.append ids_list\n\n      for identifier in ids\n        ids_list.append $ '<li/>', text: identifier\n\n      @$task_response.append task_res_section\n\n    if successes.length and data_from_server.action is 'add'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were successfully added as beta testers:\"), (sr.identifier for sr in successes)\n\n    if successes.length and data_from_server.action is 'remove'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were successfully removed as beta testers:\"), (sr.identifier for sr in successes)\n\n    if errors.length and data_from_server.action is 'add'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were not added as beta testers:\"), (sr.identifier for sr in errors)\n\n    if errors.length and data_from_server.action is 'remove'\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users were not removed as beta testers:\"), (sr.identifier for sr in errors)\n\n    if no_users.length\n      no_users.push $ gettext(\"Users must create and activate their account before they can be promoted to beta tester.\")\n      `// Translators: A list of identifiers (which are email addresses and/or usernames) appears after this sentence`\n      render_list gettext(\"Could not find users associated with the following identifiers:\"), (sr.identifier for sr in no_users)\n\n# Wrapper for the batch enrollment subsection.\n# This object handles buttons, success and failure reporting,\n# and server communication.\nclass BatchEnrollment\n  constructor: (@$container) ->\n    # gather elements\n    @$identifier_input       = @$container.find(\"textarea[name='student-ids']\")\n    @$enrollment_button      = @$container.find(\".enrollment-button\")\n    @$is_course_white_label  = @$container.find(\"#is_course_white_label\").val()\n    @$reason_field           = @$container.find(\"textarea[name='reason-field']\")\n    @$checkbox_autoenroll    = @$container.find(\"input[name='auto-enroll']\")\n    @$checkbox_emailstudents = @$container.find(\"input[name='email-students']\")\n    @$task_response          = @$container.find(\".request-response\")\n    @$request_response_error = @$container.find(\".request-response-error\")\n\n    # attach click handler for enrollment buttons\n    @$enrollment_button.click (event) =>\n      if @$is_course_white_label == 'True'\n        if not @$reason_field.val()\n          @fail_with_error gettext \"Reason field should not be left blank.\"\n          return false\n\n      emailStudents = @$checkbox_emailstudents.is(':checked')\n      send_data =\n        action: $(event.target).data('action') # 'enroll' or 'unenroll'\n        identifiers: @$identifier_input.val()\n        auto_enroll: @$checkbox_autoenroll.is(':checked')\n        email_students: emailStudents\n        reason: @$reason_field.val()\n\n      $.ajax\n        dataType: 'json'\n        type: 'POST'\n        url: $(event.target).data 'endpoint'\n        data: send_data\n        success: (data) => @display_response data\n        error: std_ajax_err => @fail_with_error gettext \"Error enrolling/unenrolling users.\"\n\n\n  # clear the input text field\n  clear_input: ->\n    @$identifier_input.val ''\n    @$reason_field.val ''\n    # default for the checkboxes should be checked\n    @$checkbox_emailstudents.attr('checked', true)\n    @$checkbox_autoenroll.attr('checked', true)\n\n  fail_with_error: (msg) ->\n    console.warn msg\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n    @$request_response_error.text msg\n\n  display_response: (data_from_server) ->\n    @clear_input()\n    @$task_response.empty()\n    @$request_response_error.empty()\n\n    # these results arrays contain student_results\n    # only populated arrays will be rendered\n    #\n    # invalid identifiers\n    invalid_identifier = []\n    # students for which there was an error during the action\n    errors = []\n    # students who are now enrolled in the course\n    enrolled = []\n    # students who are now allowed to enroll in the course\n    allowed = []\n    # students who will be autoenrolled on registration\n    autoenrolled = []\n    # students who are now not enrolled in the course\n    notenrolled = []\n    # students who were not enrolled or allowed prior to unenroll action\n    notunenrolled = []\n\n    # categorize student results into the above arrays.\n    for student_results in data_from_server.results\n      # for a successful action.\n      # student_results is of the form {\n      #   \"identifier\": \"jd405@edx.org\",\n      #   \"before\": {\n      #     \"enrollment\": true,\n      #     \"auto_enroll\": false,\n      #     \"user\": true,\n      #     \"allowed\": false\n      #   }\n      #   \"after\": {\n      #     \"enrollment\": true,\n      #     \"auto_enroll\": false,\n      #     \"user\": true,\n      #     \"allowed\": false\n      #   },\n      # }\n      #\n      # for an action error.\n      # student_results is of the form {\n      #   'identifier': identifier,\n      #   # then one of:\n      #   'error': True,\n      #   'invalidIdentifier': True  # if identifier can't find a valid User object and doesn't pass validate_email\n      # }\n\n      if student_results.invalidIdentifier\n        invalid_identifier.push student_results\n\n      else if student_results.error\n        errors.push student_results\n\n      else if student_results.after.enrollment\n        enrolled.push student_results\n\n      else if student_results.after.allowed\n        if student_results.after.auto_enroll\n          autoenrolled.push student_results\n        else\n          allowed.push student_results\n\n      # The instructor is trying to unenroll someone who is not enrolled or allowed to enroll; non-sensical action.\n      else if data_from_server.action is 'unenroll' and not (student_results.before.enrollment) and not (student_results.before.allowed)\n        notunenrolled.push student_results\n\n      else if not student_results.after.enrollment\n        notenrolled.push student_results\n\n      else\n        console.warn 'student results not reported to user'\n        console.warn student_results\n\n    # render populated result arrays\n    render_list = (label, ids) =>\n      task_res_section = $ '<div/>', class: 'request-res-section'\n      task_res_section.append $ '<h3/>', text: label\n      ids_list = $ '<ul/>'\n      task_res_section.append ids_list\n\n      for identifier in ids\n        ids_list.append $ '<li/>', text: identifier\n\n      @$task_response.append task_res_section\n\n    if invalid_identifier.length\n      render_list gettext(\"The following email addresses and/or usernames are invalid:\"), (sr.identifier for sr in invalid_identifier)\n\n    if errors.length\n      errors_label = do ->\n        if data_from_server.action is 'enroll'\n          \"There was an error enrolling:\"\n        else if data_from_server.action is 'unenroll'\n          \"There was an error unenrolling:\"\n        else\n          console.warn \"unknown action from server '#{data_from_server.action}'\"\n          \"There was an error processing:\"\n\n      for student_results in errors\n        render_list errors_label, (sr.identifier for sr in errors)\n\n    if enrolled.length and emailStudents\n      render_list gettext(\"Successfully enrolled and sent email to the following users:\"), (sr.identifier for sr in enrolled)\n\n    if enrolled.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Successfully enrolled the following users:\"), (sr.identifier for sr in enrolled)\n\n    # Student hasn't registered so we allow them to enroll\n    if allowed.length and emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Successfully sent enrollment emails to the following users. They will be allowed to enroll once they register:\"),\n        (sr.identifier for sr in allowed)\n\n    # Student hasn't registered so we allow them to enroll\n    if allowed.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users will be allowed to enroll once they register:\"),\n        (sr.identifier for sr in allowed)\n\n    # Student hasn't registered so we allow them to enroll with autoenroll\n    if autoenrolled.length and emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Successfully sent enrollment emails to the following users. They will be enrolled once they register:\"),\n        (sr.identifier for sr in autoenrolled)\n\n    # Student hasn't registered so we allow them to enroll with autoenroll\n    if autoenrolled.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"These users will be enrolled once they register:\"),\n        (sr.identifier for sr in autoenrolled)\n\n    if notenrolled.length and emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"Emails successfully sent. The following users are no longer enrolled in the course:\"),\n        (sr.identifier for sr in notenrolled)\n\n    if notenrolled.length and not emailStudents\n      `// Translators: A list of users appears after this sentence`\n      render_list gettext(\"The following users are no longer enrolled in the course:\"),\n        (sr.identifier for sr in notenrolled)\n\n    if notunenrolled.length\n      `// Translators: A list of users appears after this sentence. This situation arises when a staff member tries to unenroll a user who is not currently enrolled in this course.`\n      render_list gettext(\"These users were not affiliated with the course so could not be unenrolled:\"),\n        (sr.identifier for sr in notunenrolled)\n\n# Wrapper for auth list subsection.\n# manages a list of users who have special access.\n# these could be instructors, staff, beta users, or forum roles.\n# uses slickgrid to display list.\nclass AuthList\n  # rolename is one of ['instructor', 'staff'] for instructor_staff endpoints\n  # rolename is the name of Role for forums for the forum endpoints\n  constructor: (@$container, @rolename) ->\n    # gather elements\n    @$display_table          = @$container.find('.auth-list-table')\n    @$request_response_error = @$container.find('.request-response-error')\n    @$add_section            = @$container.find('.auth-list-add')\n    @$allow_field             = @$add_section.find(\"input[name='email']\")\n    @$allow_button            = @$add_section.find(\"input[name='allow']\")\n\n    # attach click handler\n    @$allow_button.click =>\n      @access_change @$allow_field.val(), 'allow', => @reload_auth_list()\n      @$allow_field.val ''\n\n    @reload_auth_list()\n\n  # fetch and display list of users who match criteria\n  reload_auth_list: ->\n    # helper function to display server data in the list\n    load_auth_list = (data) =>\n      # clear existing data\n      @$request_response_error.empty()\n      @$display_table.empty()\n\n      # setup slickgrid\n      options =\n        enableCellNavigation: true\n        enableColumnReorder: false\n        # autoHeight: true\n        forceFitColumns: true\n\n      # this is a hack to put a button/link in a slick grid cell\n      # if you change columns, then you must update\n      # WHICH_CELL_IS_REVOKE to have the index\n      # of the revoke column (left to right).\n      WHICH_CELL_IS_REVOKE = 3\n      columns = [\n        id: 'username'\n        field: 'username'\n        name: 'Username'\n      ,\n        id: 'email'\n        field: 'email'\n        name: 'Email'\n      ,\n        id: 'first_name'\n        field: 'first_name'\n        name: 'First Name'\n      ,\n      #   id: 'last_name'\n      #   field: 'last_name'\n      #   name: 'Last Name'\n      # ,\n        id: 'revoke'\n        field: 'revoke'\n        name: 'Revoke'\n        formatter: (row, cell, value, columnDef, dataContext) ->\n          \"<span class='revoke-link'>Revoke Access</span>\"\n      ]\n\n      table_data = data[@rolename]\n\n      $table_placeholder = $ '<div/>', class: 'slickgrid'\n      @$display_table.append $table_placeholder\n      grid = new Slick.Grid($table_placeholder, table_data, columns, options)\n\n      # click handler part of the revoke button/link hack.\n      grid.onClick.subscribe (e, args) =>\n        item = args.grid.getDataItem(args.row)\n        if args.cell is WHICH_CELL_IS_REVOKE\n          @access_change item.email, 'revoke', => @reload_auth_list()\n\n    # fetch data from the endpoint\n    # the endpoint comes from data-endpoint of the table\n    $.ajax\n      dataType: 'json'\n      type: 'POST'\n      url: @$display_table.data 'endpoint'\n      data: rolename: @rolename\n      success: load_auth_list\n      error: std_ajax_err => @$request_response_error.text \"Error fetching list for '#{@rolename}'\"\n\n\n  # slickgrid's layout collapses when rendered\n  # in an invisible div. use this method to reload\n  # the AuthList widget\n  refresh: ->\n    @$display_table.empty()\n    @reload_auth_list()\n\n  # update the access of a user.\n  # (add or remove them from the list)\n  # action should be one of ['allow', 'revoke']\n  access_change: (email, action, cb) ->\n    $.ajax\n      dataType: 'json'\n      type: 'POST'\n      url: @$add_section.data 'endpoint'\n      data:\n        email: email\n        rolename: @rolename\n        action: action\n      success: (data) -> cb?(data)\n      error: std_ajax_err => @$request_response_error.text gettext \"Error changing user's permissions.\"\n\n\n# Membership Section\nclass Membership\n  # enable subsections.\n  constructor: (@$section) ->\n    # attach self to html\n    # so that instructor_dashboard.coffee can find this object\n    # to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # isolate # initialize BatchEnrollment subsection\n    plantTimeout 0, => new BatchEnrollment @$section.find '.batch-enrollment'\n\n    # isolate # initialize AutoEnrollmentViaCsv subsection\n    plantTimeout 0, => new AutoEnrollmentViaCsv @$section.find '.auto_enroll_csv'\n\n    # initialize BetaTesterBulkAddition subsection\n    plantTimeout 0, => new BetaTesterBulkAddition @$section.find '.batch-beta-testers'\n\n    # gather elements\n    @$list_selector = @$section.find 'select#member-lists-selector'\n    @$auth_list_containers = @$section.find '.auth-list-container'\n    @$auth_list_errors = @$section.find '.member-lists-management .request-response-error'\n\n    # initialize & store AuthList subsections\n    # one for each .auth-list-container in the section.\n    @auth_lists = _.map (@$auth_list_containers), (auth_list_container) =>\n      rolename = $(auth_list_container).data 'rolename'\n      new AuthListWidget $(auth_list_container), rolename, @$auth_list_errors\n\n    # populate selector\n    @$list_selector.empty()\n    for auth_list in @auth_lists\n      @$list_selector.append $ '<option/>',\n        text: auth_list.$container.data 'display-name'\n        data:\n          auth_list: auth_list\n    if @auth_lists.length is 0\n      @$list_selector.hide()\n\n    @$list_selector.change =>\n      $opt = @$list_selector.children('option:selected')\n      return unless $opt.length > 0\n      for auth_list in @auth_lists\n        auth_list.$container.removeClass 'active'\n      auth_list = $opt.data('auth_list')\n      auth_list.$container.addClass 'active'\n      auth_list.re_view()\n\n    # one-time first selection of top list.\n    @$list_selector.change()\n\n  # handler for when the section title is clicked.\n  onClickTitle: ->\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n  Membership: Membership\n", "###\nEmail Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\n# Load utilities\nplantTimeout = -> window.InstructorDashboard.util.plantTimeout.apply this, arguments\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\nPendingInstructorTasks = -> window.InstructorDashboard.util.PendingInstructorTasks\ncreate_task_list_table = -> window.InstructorDashboard.util.create_task_list_table.apply this, arguments\ncreate_email_content_table = -> window.InstructorDashboard.util.create_email_content_table.apply this, arguments\ncreate_email_message_views = -> window.InstructorDashboard.util.create_email_message_views.apply this, arguments\nKeywordValidator = -> window.InstructorDashboard.util.KeywordValidator\n\nclass @SendEmail\n    constructor: (@$container) ->\n        # gather elements\n        @$emailEditor = XBlock.initializeBlock($('.xblock-studio_view'));\n        @$send_to = @$container.find(\"input[name='send_to']\")\n        @$subject = @$container.find(\"input[name='subject']\")\n        @$btn_send = @$container.find(\"input[name='send']\")\n        @$task_response = @$container.find(\".request-response\")\n        @$request_response_error = @$container.find(\".request-response-error\")\n        @$content_request_response_error = @$container.find(\".content-request-response-error\")\n        @$history_request_response_error = @$container.find(\".history-request-response-error\")\n        @$btn_task_history_email = @$container.find(\"input[name='task-history-email']\")\n        @$btn_task_history_email_content = @$container.find(\"input[name='task-history-email-content']\")\n        @$table_task_history_email = @$container.find(\".task-history-email-table\")\n        @$table_email_content_history = @$container.find(\".content-history-email-table\")\n        @$email_content_table_inner = @$container.find(\".content-history-table-inner\")\n        @$email_messages_wrapper = @$container.find(\".email-messages-wrapper\")\n\n        # attach click handlers\n\n        @$btn_send.click =>\n            subject = @$subject.val()\n            body = @$emailEditor.save()['data']\n            targets = []\n            @$send_to.filter(':checked').each ->\n                targets.push(this.value)\n\n            if subject == \"\"\n                alert gettext(\"Your message must have a subject.\")\n\n            else if body == \"\"\n                alert gettext(\"Your message cannot be blank.\")\n\n            else if targets.length == 0\n                alert gettext(\"Your message must have at least one target.\")\n\n            else\n                # Validation for keyword substitution\n                validation = KeywordValidator().validate_string body\n                if not validation.is_valid\n                    message = gettext(\"There are invalid keywords in your email. Check the following keywords and try again.\")\n                    message += \"\\n\" + validation.invalid_keywords.join('\\n')\n                    alert message\n                    return\n\n                target_map = {\n                    \"myself\": gettext(\"Yourself\"),\n                    \"staff\": gettext(\"Everyone who has staff privileges in this course\"),\n                    \"learners\": gettext(\"All learners who are enrolled in this course\"),\n                }\n                success_message = gettext(\"Your email message was successfully queued for sending. In courses with a large number of learners, email messages to learners might take up to an hour to be sent.\")\n                confirm_message = gettext(\"You are sending an email message with the subject {subject} to the following recipients.\")\n                for target in targets\n                    confirm_message += \"\\n-\" + target_map[target]\n                confirm_message += \"\\n\\n\" + gettext(\"Is this OK?\")\n                full_confirm_message = confirm_message.replace('{subject}', subject)\n\n                if confirm full_confirm_message\n\n                    send_data =\n                        action: 'send'\n                        send_to: JSON.stringify(targets)\n                        subject: subject\n                        message: body\n\n                    $.ajax\n                        type: 'POST'\n                        dataType: 'json'\n                        url: @$btn_send.data 'endpoint'\n                        data: send_data\n                        success: (data) =>\n                            @display_response success_message\n\n                        error: std_ajax_err =>\n                            @fail_with_error gettext('Error sending email.')\n\n                else\n                    @task_response.empty()\n                    @$request_response_error.empty()\n\n        # list task history for email\n        @$btn_task_history_email.click =>\n            url = @$btn_task_history_email.data 'endpoint'\n            $.ajax\n                type: 'POST'\n                dataType: 'json'\n                url: url\n                success: (data) =>\n                    if data.tasks.length\n                        create_task_list_table @$table_task_history_email, data.tasks\n                    else\n                        @$history_request_response_error.text gettext(\"There is no email history for this course.\")\n                        # Enable the msg-warning css display\n                        @$history_request_response_error.css({\"display\":\"block\"})\n                error: std_ajax_err =>\n                    @$history_request_response_error.text gettext(\"There was an error obtaining email task history for this course.\")\n\n        # List content history for emails sent\n        @$btn_task_history_email_content.click =>\n            url = @$btn_task_history_email_content.data 'endpoint'\n            $.ajax\n                type: 'POST'\n                dataType: 'json'\n                url : url\n                success: (data) =>\n                    if data.emails.length\n                        create_email_content_table @$table_email_content_history, @$email_content_table_inner, data.emails\n                        create_email_message_views @$email_messages_wrapper, data.emails\n                    else\n                        @$content_request_response_error.text gettext(\"There is no email history for this course.\")\n                        @$content_request_response_error.css({\"display\":\"block\"})\n                error: std_ajax_err =>\n                    @$content_request_response_error.text gettext(\"There was an error obtaining email content history for this course.\")\n\n    fail_with_error: (msg) ->\n        console.warn msg\n        @$task_response.empty()\n        @$request_response_error.empty()\n        @$request_response_error.text msg\n        $(\".msg-confirm\").css({\"display\":\"none\"})\n\n    display_response: (data_from_server) ->\n        @$task_response.empty()\n        @$request_response_error.empty()\n        @$task_response.text(data_from_server)\n        $(\".msg-confirm\").css({\"display\":\"block\"})\n\n\n# Email Section\nclass Email\n    # enable subsections.\n    constructor: (@$section) ->\n        # attach self to html so that instructor_dashboard.coffee can find\n        #  this object to call event handlers like 'onClickTitle'\n        @$section.data 'wrapper', @\n\n        # isolate # initialize SendEmail subsection\n        plantTimeout 0, => new SendEmail @$section.find '.send-email'\n\n        @instructor_tasks = new (PendingInstructorTasks()) @$section\n\n    # handler for when the section title is clicked.\n    onClickTitle: -> @instructor_tasks.task_poller.start()\n\n    # handler for when the section is closed\n    onExit: -> @instructor_tasks.task_poller.stop()\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n    Email: Email\n", "###\nStudent Admin Section\n\nimports from other modules.\nwrap in (-> ... apply) to defer evaluation\nsuch that the value can be defined later than this assignment (file load order).\n###\n\n# Load utilities\nstd_ajax_err = -> window.InstructorDashboard.util.std_ajax_err.apply this, arguments\ncreate_task_list_table = -> window.InstructorDashboard.util.create_task_list_table.apply this, arguments\nPendingInstructorTasks = -> window.InstructorDashboard.util.PendingInstructorTasks\n\n\n# get jquery element and assert its existance\nfind_and_assert = ($root, selector) ->\n  item = $root.find selector\n  if item.length != 1\n    console.error \"element selection failed for '#{selector}' resulted in length #{item.length}\"\n    throw \"Failed Element Selection\"\n  else\n    item\n\n\nclass @StudentAdmin\n  constructor: (@$section) ->\n    # attach self to html so that instructor_dashboard.coffee can find\n    #  this object to call event handlers like 'onClickTitle'\n    @$section.data 'wrapper', @\n\n    # gather buttons\n    # some buttons are optional because they can be flipped by the instructor task feature switch\n    # student-specific\n    @$field_student_select_progress = find_and_assert @$section, \"input[name='student-select-progress']\"\n    @$field_student_select_grade  = find_and_assert @$section, \"input[name='student-select-grade']\"\n    @$progress_link               = find_and_assert @$section, \"a.progress-link\"\n    @$field_problem_select_single = find_and_assert @$section, \"input[name='problem-select-single']\"\n    @$btn_reset_attempts_single   = find_and_assert @$section, \"input[name='reset-attempts-single']\"\n    @$btn_delete_state_single     = @$section.find \"input[name='delete-state-single']\"\n    @$btn_rescore_problem_single  = @$section.find \"input[name='rescore-problem-single']\"\n    @$btn_task_history_single     = @$section.find \"input[name='task-history-single']\"\n    @$table_task_history_single   = @$section.find \".task-history-single-table\"\n\n    # entrance-exam-specific\n    @$field_entrance_exam_student_select_grade  = @$section.find \"input[name='entrance-exam-student-select-grade']\"\n    @$btn_reset_entrance_exam_attempts   = @$section.find \"input[name='reset-entrance-exam-attempts']\"\n    @$btn_delete_entrance_exam_state     = @$section.find \"input[name='delete-entrance-exam-state']\"\n    @$btn_rescore_entrance_exam          = @$section.find \"input[name='rescore-entrance-exam']\"\n    @$btn_skip_entrance_exam             = @$section.find \"input[name='skip-entrance-exam']\"\n    @$btn_entrance_exam_task_history     = @$section.find \"input[name='entrance-exam-task-history']\"\n    @$table_entrance_exam_task_history   = @$section.find \".entrance-exam-task-history-table\"\n\n    # course-specific\n    @$field_problem_select_all    = @$section.find \"input[name='problem-select-all']\"\n    @$btn_reset_attempts_all      = @$section.find \"input[name='reset-attempts-all']\"\n    @$btn_rescore_problem_all     = @$section.find \"input[name='rescore-problem-all']\"\n    @$btn_task_history_all        = @$section.find \"input[name='task-history-all']\"\n    @$table_task_history_all      = @$section.find \".task-history-all-table\"\n    @instructor_tasks             = new (PendingInstructorTasks()) @$section\n\n    # response areas\n    @$request_response_error_progress = find_and_assert @$section, \".student-specific-container .request-response-error\"\n    @$request_response_error_grade = find_and_assert @$section, \".student-grade-container .request-response-error\"\n    @$request_response_error_ee       = @$section.find \".entrance-exam-grade-container .request-response-error\"\n    @$request_response_error_all    = @$section.find \".course-specific-container .request-response-error\"\n\n    # attach click handlers\n\n    # go to student progress page\n    @$progress_link.click (e) =>\n      e.preventDefault()\n      unique_student_identifier = @$field_student_select_progress.val()\n      if not unique_student_identifier\n        return @$request_response_error_progress.text gettext(\"Please enter a student email address or username.\")\n      error_message = gettext(\"Error getting student progress url for '<%= student_id %>'. Make sure that the student identifier is spelled correctly.\")\n      full_error_message = _.template(error_message)({student_id: unique_student_identifier})\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$progress_link.data 'endpoint'\n        data: unique_student_identifier: unique_student_identifier\n        success: @clear_errors_then (data) ->\n          window.location = data.progress_url\n        error: std_ajax_err => @$request_response_error_progress.text full_error_message\n\n    # reset attempts for student on problem\n    @$btn_reset_attempts_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        problem_to_reset: problem_to_reset\n        delete_module: false\n      success_message = gettext(\"Success! Problem attempts reset for problem '<%= problem_id %>' and student '<%= student_id %>'.\")\n      error_message = gettext(\"Error resetting problem attempts for problem '<%= problem_id %>' and student '<%= student_id %>'. Make sure that the problem and student identifiers are complete and correct.\")\n      full_success_message = _.template(success_message)({problem_id: problem_to_reset, student_id: unique_student_identifier})\n      full_error_message = _.template(error_message)({problem_id: problem_to_reset, student_id: unique_student_identifier})\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_reset_attempts_single.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then -> alert full_success_message\n        error: std_ajax_err => @$request_response_error_grade.text full_error_message\n\n    # delete state for student on problem\n    @$btn_delete_state_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      confirm_message = gettext(\"Delete student '<%= student_id %>'s state on problem '<%= problem_id %>'?\")\n      full_confirm_message = _.template(confirm_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n      if window.confirm full_confirm_message\n        send_data =\n          unique_student_identifier: unique_student_identifier\n          problem_to_reset: problem_to_reset\n          delete_module: true\n        error_message = gettext(\"Error deleting student '<%= student_id %>'s state on problem '<%= problem_id %>'. Make sure that the problem and student identifiers are complete and correct.\")\n        full_error_message = _.template(error_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n        $.ajax\n          type: 'POST'\n          dataType: 'json'\n          url: @$btn_delete_state_single.data 'endpoint'\n          data: send_data\n          success: @clear_errors_then -> alert gettext('Module state successfully deleted.')\n          error: std_ajax_err => @$request_response_error_grade.text full_error_message\n      else\n        # Clear error messages if \"Cancel\" was chosen on confirmation alert\n        @clear_errors()\n\n    # start task to rescore problem for student\n    @$btn_rescore_problem_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        problem_to_reset: problem_to_reset\n      success_message = gettext(\"Started rescore problem task for problem '<%= problem_id %>' and student '<%= student_id %>'. Click the 'Show Background Task History for Student' button to see the status of the task.\")\n      full_success_message = _.template(success_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n      error_message = gettext(\"Error starting a task to rescore problem '<%= problem_id %>' for student '<%= student_id %>'. Make sure that the the problem and student identifiers are complete and correct.\")\n      full_error_message = _.template(error_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_rescore_problem_single.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then -> alert full_success_message\n        error: std_ajax_err => @$request_response_error_grade.text full_error_message\n\n    # list task history for student+problem\n    @$btn_task_history_single.click =>\n      unique_student_identifier = @$field_student_select_grade.val()\n      problem_to_reset = @$field_problem_select_single.val()\n      if not unique_student_identifier\n        return @$request_response_error_grade.text gettext(\"Please enter a student email address or username.\")\n      if not problem_to_reset\n        return @$request_response_error_grade.text gettext(\"Please enter a problem location.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        problem_location_str: problem_to_reset\n      error_message = gettext(\"Error getting task history for problem '<%= problem_id %>' and student '<%= student_id %>'. Make sure that the problem and student identifiers are complete and correct.\")\n      full_error_message = _.template(error_message)({student_id: unique_student_identifier, problem_id: problem_to_reset})\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_task_history_single.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then (data) =>\n          create_task_list_table @$table_task_history_single, data.tasks\n        error: std_ajax_err => @$request_response_error_grade.text full_error_message\n\n   # reset entrance exam attempts for student\n    @$btn_reset_entrance_exam_attempts.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Please enter a student email address or username.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        delete_module: false\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_reset_entrance_exam_attempts.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then ->\n          success_message = gettext(\"Entrance exam attempts is being reset for student '{student_id}'.\")\n          full_success_message = interpolate_text(success_message, {student_id: unique_student_identifier})\n          alert full_success_message\n        error: std_ajax_err =>\n          error_message = gettext(\"Error resetting entrance exam attempts for student '{student_id}'. Make sure student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n   # start task to rescore entrance exam for student\n    @$btn_rescore_entrance_exam.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Please enter a student email address or username.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_rescore_entrance_exam.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then ->\n          success_message = gettext(\"Started entrance exam rescore task for student '{student_id}'. Click the 'Show Background Task History for Student' button to see the status of the task.\")\n          full_success_message = interpolate_text(success_message, {student_id: unique_student_identifier})\n          alert full_success_message\n        error: std_ajax_err =>\n          error_message = gettext(\"Error starting a task to rescore entrance exam for student '{student_id}'. Make sure that entrance exam has problems in it and student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n  # Mark a student to skip entrance exam\n    @$btn_skip_entrance_exam.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Enter a student's username or email address.\")\n      confirm_message = gettext(\"Do you want to allow this student ('{student_id}') to skip the entrance exam?\")\n      full_confirm_message = interpolate_text(confirm_message, {student_id: unique_student_identifier})\n      if window.confirm full_confirm_message\n        send_data =\n          unique_student_identifier: unique_student_identifier\n\n        $.ajax\n          dataType: 'json'\n          url: @$btn_skip_entrance_exam.data 'endpoint'\n          data: send_data\n          type: 'POST'\n          success: @clear_errors_then (data) ->\n            alert data.message\n          error: std_ajax_err =>\n            error_message = gettext(\"An error occurred. Make sure that the student's username or email address is correct and try again.\")\n            @$request_response_error_ee.text error_message\n\n   # delete student state for entrance exam\n    @$btn_delete_entrance_exam_state.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Please enter a student email address or username.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n        delete_module: true\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_delete_entrance_exam_state.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then ->\n          success_message = gettext(\"Entrance exam state is being deleted for student '{student_id}'.\")\n          full_success_message = interpolate_text(success_message, {student_id: unique_student_identifier})\n          alert full_success_message\n        error: std_ajax_err =>\n          error_message = gettext(\"Error deleting entrance exam state for student '{student_id}'. Make sure student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n    # list entrance exam task history for student\n    @$btn_entrance_exam_task_history.click =>\n      unique_student_identifier = @$field_entrance_exam_student_select_grade.val()\n      if not unique_student_identifier\n        return @$request_response_error_ee.text gettext(\"Enter a student's username or email address.\")\n      send_data =\n        unique_student_identifier: unique_student_identifier\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_entrance_exam_task_history.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then (data) =>\n          create_task_list_table @$table_entrance_exam_task_history, data.tasks\n        error: std_ajax_err =>\n          error_message = gettext(\"Error getting entrance exam task history for student '{student_id}'. Make sure student identifier is correct.\")\n          full_error_message = interpolate_text(error_message, {student_id: unique_student_identifier})\n          @$request_response_error_ee.text full_error_message\n\n    # start task to reset attempts on problem for all students\n    @$btn_reset_attempts_all.click =>\n      problem_to_reset = @$field_problem_select_all.val()\n      if not problem_to_reset\n        return @$request_response_error_all.text gettext(\"Please enter a problem location.\")\n      confirm_message = gettext(\"Reset attempts for all students on problem '<%= problem_id %>'?\")\n      full_confirm_message = _.template(confirm_message)({problem_id: problem_to_reset})\n      if window.confirm full_confirm_message\n        send_data =\n          all_students: true\n          problem_to_reset: problem_to_reset\n        success_message = gettext(\"Successfully started task to reset attempts for problem '<%= problem_id %>'. Click the 'Show Background Task History for Problem' button to see the status of the task.\")\n        full_success_message = _.template(success_message)({problem_id: problem_to_reset})\n        error_message = gettext(\"Error starting a task to reset attempts for all students on problem '<%= problem_id %>'. Make sure that the problem identifier is complete and correct.\")\n        full_error_message = _.template(error_message)({problem_id: problem_to_reset})\n\n        $.ajax\n          type: 'POST'\n          dataType: 'json'\n          url: @$btn_reset_attempts_all.data 'endpoint'\n          data: send_data\n          success: @clear_errors_then -> alert full_success_message\n          error: std_ajax_err => @$request_response_error_all.text full_error_message\n      else\n        # Clear error messages if \"Cancel\" was chosen on confirmation alert\n        @clear_errors()\n\n    # start task to rescore problem for all students\n    @$btn_rescore_problem_all.click =>\n      problem_to_reset = @$field_problem_select_all.val()\n      if not problem_to_reset\n        return @$request_response_error_all.text gettext(\"Please enter a problem location.\")\n      confirm_message = gettext(\"Rescore problem '<%= problem_id %>' for all students?\")\n      full_confirm_message = _.template(confirm_message)({problem_id: problem_to_reset})\n      if window.confirm full_confirm_message\n        send_data =\n          all_students: true\n          problem_to_reset: problem_to_reset\n        success_message = gettext(\"Successfully started task to rescore problem '<%= problem_id %>' for all students. Click the 'Show Background Task History for Problem' button to see the status of the task.\")\n        full_success_message = _.template(success_message)({problem_id: problem_to_reset})\n        error_message = gettext(\"Error starting a task to rescore problem '<%= problem_id %>'. Make sure that the problem identifier is complete and correct.\")\n        full_error_message = _.template(error_message)({problem_id: problem_to_reset})\n\n        $.ajax\n          type: 'POST'\n          dataType: 'json'\n          url: @$btn_rescore_problem_all.data 'endpoint'\n          data: send_data\n          success: @clear_errors_then -> alert full_success_message\n          error: std_ajax_err => @$request_response_error_all.text full_error_message\n      else\n        # Clear error messages if \"Cancel\" was chosen on confirmation alert\n        @clear_errors()\n\n    # list task history for problem\n    @$btn_task_history_all.click =>\n      send_data =\n        problem_location_str: @$field_problem_select_all.val()\n\n      if not send_data.problem_location_str\n        return @$request_response_error_all.text gettext(\"Please enter a problem location.\")\n\n      $.ajax\n        type: 'POST'\n        dataType: 'json'\n        url: @$btn_task_history_all.data 'endpoint'\n        data: send_data\n        success: @clear_errors_then (data) =>\n          create_task_list_table @$table_task_history_all, data.tasks\n        error: std_ajax_err => @$request_response_error_all.text gettext(\"Error listing task history for this student and problem.\")\n\n  # wraps a function, but first clear the error displays\n  clear_errors_then: (cb) ->\n    @$request_response_error_progress.empty()\n    @$request_response_error_grade.empty()\n    @$request_response_error_ee.empty()\n    @$request_response_error_all.empty()\n    ->\n      cb?.apply this, arguments\n\n\n  clear_errors: ->\n    @$request_response_error_progress.empty()\n    @$request_response_error_grade.empty()\n    @$request_response_error_ee.empty()\n    @$request_response_error_all.empty()\n\n  # handler for when the section title is clicked.\n  onClickTitle: -> @instructor_tasks.task_poller.start()\n\n  # handler for when the section is closed\n  onExit: -> @instructor_tasks.task_poller.stop()\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n_.defaults window, InstructorDashboard: {}\n_.defaults window.InstructorDashboard, sections: {}\n_.defaults window.InstructorDashboard.sections,\n  StudentAdmin: StudentAdmin\n", "# Common utilities for instructor dashboard components.\n\n# reverse arguments on common functions to enable\n# better coffeescript with callbacks at the end.\nplantTimeout = (ms, cb) -> setTimeout cb, ms\nplantInterval = (ms, cb) -> setInterval cb, ms\n\n\n# get jquery element and assert its existance\nfind_and_assert = ($root, selector) ->\n  item = $root.find selector\n  if item.length != 1\n    console.error \"element selection failed for '#{selector}' resulted in length #{item.length}\"\n    throw \"Failed Element Selection\"\n  else\n    item\n\n# standard ajax error wrapper\n#\n# wraps a `handler` function so that first\n# it prints basic error information to the console.\n@std_ajax_err = (handler) -> (jqXHR, textStatus, errorThrown) ->\n  console.warn \"\"\"ajax error\n                  textStatus: #{textStatus}\n                  errorThrown: #{errorThrown}\"\"\"\n  handler.apply this, arguments\n\n\n# render a task list table to the DOM\n# `$table_tasks` the $element in which to put the table\n# `tasks_data`\n@create_task_list_table = ($table_tasks, tasks_data) ->\n  $table_tasks.empty()\n\n  options =\n    enableCellNavigation: true\n    enableColumnReorder: false\n    autoHeight: true\n    rowHeight: 100\n    forceFitColumns: true\n\n  columns = [\n    id: 'task_type'\n    field: 'task_type'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task Type')\n    minWidth: 102\n  ,\n    id: 'task_input'\n    field: 'task_input'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task inputs')\n    minWidth: 150\n  ,\n    id: 'task_id'\n    field: 'task_id'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task ID')\n    minWidth: 150\n  ,\n    id: 'requester'\n    field: 'requester'\n    ###\n    Translators: a \"Requester\" is a username that requested a task such as sending email\n    ###\n    name: gettext('Requester')\n    minWidth: 80\n  ,\n    id: 'created'\n    field: 'created'\n    ###\n    Translators: A timestamp of when a task (eg, sending email) was submitted appears after this\n    ###\n    name: gettext('Submitted')\n    minWidth: 120\n  ,\n    id: 'duration_sec'\n    field: 'duration_sec'\n    ###\n    Translators: The length of a task (eg, sending email) in seconds appears this\n    ###\n    name: gettext('Duration (sec)')\n    minWidth: 80\n  ,\n    id: 'task_state'\n    field: 'task_state'\n    ###\n    Translators: The state (eg, \"In progress\") of a task (eg, sending email) appears after this.\n    ###\n    name: gettext('State')\n    minWidth: 80\n  ,\n    id: 'status'\n    field: 'status'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task Status')\n    minWidth: 80\n  ,\n    id: 'task_message'\n    field: 'task_message'\n    ###\n    Translators: a \"Task\" is a background process such as grading students or sending email\n    ###\n    name: gettext('Task Progress')\n    minWidth: 120\n  ]\n\n  table_data = tasks_data\n\n  $table_placeholder = $ '<div/>', class: 'slickgrid'\n  $table_tasks.append($table_placeholder)\n  grid = new Slick.Grid($table_placeholder, table_data, columns, options)\n\n# Formats the subject field for email content history table\nsubject_formatter = (row, cell, value, columnDef, dataContext) ->\n  if value is null then return gettext(\"An error occurred retrieving your email. Please try again later, and contact technical support if the problem persists.\")\n  subject_text = $('<span>').text(value['subject']).html()\n  return edx.HtmlUtils.joinHtml(\n    edx.HtmlUtils.HTML('<p><a href=\"#email_message_'),\n    value['id'],\n    edx.HtmlUtils.HTML('\" id=\"email_message_'),\n    value['id'],\n    edx.HtmlUtils.HTML('_trig\">'),\n    subject_text,\n    edx.HtmlUtils.HTML('</a></p>'),\n  )\n\np_wrapper = (value) ->\n  edx.HtmlUtils.joinHtml(\n    edx.HtmlUtils.HTML('<p>'),\n    value,\n    edx.HtmlUtils.HTML('</p>'),\n  )\n\nunknown_p = () ->\n  p_wrapper(gettext('Unknown'))\n\n# Since sent_to is a json array, it needs some extra attention\nsent_to_formatter = (row, cell, value, columnDef, dataContext) ->\n  if value is null\n    return unknown_p()\n  else\n    return p_wrapper(value.join(\", \"))\n\n# Formats the author, created, and number sent fields for the email content history table\nunknown_if_null_formatter = (row, cell, value, columnDef, dataContext) ->\n  if value is null\n    return unknown_p()\n  else\n    return p_wrapper(value)\n\n# Creates a table to display the content of bulk course emails\n# sent in the past\ncreate_email_content_table = ($table_emails, $table_emails_inner, email_data) ->\n    $table_emails_inner.empty()\n    $table_emails.show()\n\n    options =\n      enableCellNavigation: true\n      enableColumnReorder: false\n      autoHeight: true\n      rowHeight: 50\n      forceFitColumns: true\n\n    columns = [\n      id: 'email'\n      field: 'email'\n      name: gettext('Subject')\n      minWidth: 80\n      cssClass: \"email-content-cell\"\n      formatter: subject_formatter\n    ,\n      id: 'requester'\n      field: 'requester'\n      name: gettext('Sent By')\n      minWidth: 80\n      maxWidth: 100\n      cssClass: \"email-content-cell\"\n      formatter: unknown_if_null_formatter\n    ,\n      id: 'sent_to'\n      field: 'sent_to'\n      name: gettext('Sent To')\n      minWidth: 80\n      maxWidth: 100\n      cssClass: \"email-content-cell\"\n      formatter: sent_to_formatter\n    ,\n      id: 'created'\n      field: 'created'\n      name: gettext('Time Sent')\n      minWidth: 80\n      cssClass: \"email-content-cell\"\n      formatter: unknown_if_null_formatter\n    ,\n      id: 'number_sent'\n      field: 'number_sent'\n      name: gettext('Number Sent')\n      minwidth: 100\n      maxWidth: 150\n      cssClass: \"email-content-cell\"\n      formatter: unknown_if_null_formatter\n    ,\n    ]\n\n    table_data = email_data\n\n    $table_placeholder = $ '<div/>', class: 'slickgrid'\n    $table_emails_inner.append($table_placeholder)\n    grid = new Slick.Grid($table_placeholder, table_data, columns, options)\n    $table_emails.append($('<br/>'))\n\n# Creates the modal windows linked to each email in the email history\n# Displayed when instructor clicks an email's subject in the content history table\ncreate_email_message_views = ($messages_wrapper, emails) ->\n  $messages_wrapper.empty()\n  for email_info in emails\n\n    # If some error occured, bail out\n    if !email_info.email then return\n\n    # Create hidden section for modal window\n    email_id = email_info.email['id']\n    $message_content = $('<section>', \"aria-hidden\": \"true\", class: \"modal email-modal\", id: \"email_message_\" + email_id)\n    $email_wrapper = $ '<div>', class: 'inner-wrapper email-content-wrapper'\n    $email_header = $ '<div>', class: 'email-content-header'\n\n    # Add copy email body button\n    $email_header.append($('<input>', type: \"button\", name: \"copy-email-body-text\", value: gettext(\"Copy Email To Editor\"), id: \"copy_email_\" + email_id))\n\n    $close_button = $ '<a>', href: '#', class: \"close-modal\"\n    $close_button.append($('<i>', class: 'icon fa fa-times'))\n    $email_header.append($close_button)\n\n    # HTML escape things\n    interpolate_header = (title, value) ->\n      edx.HtmlUtils.setHtml(\n        $('<h2>', class: 'message-bold'),\n        edx.HtmlUtils.joinHtml(\n          edx.HtmlUtils.HTML('<em>'),\n          title\n          edx.HtmlUtils.HTML('</em>'),\n          value,\n        )\n      )\n    $subject = interpolate_header(gettext('Subject:'), email_info.email['subject'])\n    $requester = interpolate_header(gettext('Sent By:'), email_info.requester)\n    $created = interpolate_header(gettext('Time Sent:'), email_info.created)\n    $sent_to = interpolate_header(gettext('Sent To:'), email_info.sent_to.join(\", \"))\n    $email_header.append($subject)\n    $email_header.append($requester)\n    $email_header.append($created)\n    $email_header.append($sent_to)\n    $email_wrapper.append($email_header)\n\n    $email_wrapper.append($('<hr>'))\n\n    # Last, add email content section\n    $email_content = $ '<div>', class: 'email-content-message'\n    $email_content_header = edx.HtmlUtils.setHtml(\n      $('<h2>', class: \"message-bold\"),\n      edx.HtmlUtils.joinHtml(\n        edx.HtmlUtils.HTML('<em>'),\n        gettext(\"Message:\"),\n        edx.HtmlUtils.HTML('</em>'),\n      )\n    )\n    $email_content.append($email_content_header)\n    $message = edx.HtmlUtils.setHtml(\n      $('<div>'),\n      edx.HtmlUtils.HTML(email_info.email['html_message'])\n    )\n    $email_content.append($message)\n    $email_wrapper.append($email_content)\n\n    $message_content.append($email_wrapper)\n    $messages_wrapper.append($message_content)\n\n    # Setup buttons to open modal window and copy an email message\n    $('#email_message_' + email_info.email['id'] + '_trig').leanModal({closeButton: \".close-modal\", copyEmailButton: \"#copy_email_\" + email_id})\n    setup_copy_email_button(email_id, email_info.email['html_message'], email_info.email['subject'])\n\n# Helper method to set click handler for modal copy email button\nsetup_copy_email_button = (email_id, html_message, subject) ->\n    $(\"#copy_email_\" + email_id).click =>\n        editor = tinyMCE.get(\"mce_0\")\n        editor.setContent(html_message)\n        $('#id_subject').val(subject)\n\n\n# Helper class for managing the execution of interval tasks.\n# Handles pausing and restarting.\nclass IntervalManager\n  # Create a manager which will call `fn`\n  # after a call to .start every `ms` milliseconds.\n  constructor: (@ms, @fn) ->\n    @intervalID = null\n\n  # Start or restart firing every `ms` milliseconds.\n  start: ->\n    @fn()\n    if @intervalID is null\n      @intervalID = setInterval @fn, @ms\n\n  # Pause firing.\n  stop: ->\n    clearInterval @intervalID\n    @intervalID = null\n\n\nclass @PendingInstructorTasks\n  ### Pending Instructor Tasks Section ####\n  constructor: (@$section) ->\n    # Currently running tasks\n    @$running_tasks_section = find_and_assert @$section, \".running-tasks-section\"\n    @$table_running_tasks = find_and_assert @$section, \".running-tasks-table\"\n    @$no_tasks_message = find_and_assert @$section, \".no-pending-tasks-message\"\n\n    # start polling for task list\n    # if the list is in the DOM\n    if @$table_running_tasks.length\n      # reload every 20 seconds.\n      TASK_LIST_POLL_INTERVAL = 20000\n      @reload_running_tasks_list()\n      @task_poller = new IntervalManager(TASK_LIST_POLL_INTERVAL, => @reload_running_tasks_list())\n\n  # Populate the running tasks list\n  reload_running_tasks_list: =>\n    list_endpoint = @$table_running_tasks.data 'endpoint'\n    $.ajax\n      type: 'POST'\n      dataType: 'json'\n      url: list_endpoint\n      success: (data) =>\n        if data.tasks.length\n          create_task_list_table @$table_running_tasks, data.tasks\n          @$no_tasks_message.hide()\n          @$running_tasks_section.show()\n        else\n          console.log \"No pending tasks to display\"\n          @$running_tasks_section.hide()\n          @$no_tasks_message.empty()\n          @$no_tasks_message.append($('<p>').text(gettext(\"No tasks currently running.\")))\n          @$no_tasks_message.show()\n      error: std_ajax_err => console.error \"Error finding pending tasks to display\"\n    ### /Pending Instructor Tasks Section ####\n\nclass KeywordValidator\n\n    @keyword_regex = /%%+[^%]+%%/g\n    @keywords = ['%%USER_ID%%', '%%USER_FULLNAME%%', '%%COURSE_DISPLAY_NAME%%', '%%COURSE_END_DATE%%']\n\n    @validate_string: (string) =>\n      regex_match = string.match(@keyword_regex)\n      found_keywords = if regex_match == null then [] else regex_match\n      invalid_keywords = []\n      is_valid = true\n      keywords = @keywords\n\n      for found_keyword in found_keywords\n        do (found_keyword) ->\n          if found_keyword not in keywords\n            invalid_keywords.push found_keyword\n\n      if invalid_keywords.length != 0\n        is_valid = false\n\n      return {\n        is_valid: is_valid,\n        invalid_keywords: invalid_keywords\n      }\n\n\nclass ReportDownloads\n  ### Report Downloads -- links expire quickly, so we refresh every 5 mins ####\n  constructor: (@$section) ->\n\n    @$report_downloads_table = @$section.find \".report-downloads-table\"\n\n    POLL_INTERVAL = 20000 # 20 seconds, just like the \"pending instructor tasks\" table\n    @downloads_poller = new window.InstructorDashboard.util.IntervalManager(\n      POLL_INTERVAL, => @reload_report_downloads()\n    )\n\n  reload_report_downloads: ->\n    endpoint = @$report_downloads_table.data 'endpoint'\n    $.ajax\n      type: 'POST'\n      dataType: 'json'\n      url: endpoint\n      success: (data) =>\n        if data.downloads.length\n          @create_report_downloads_table data.downloads\n        else\n          console.log \"No reports ready for download\"\n      error: (std_ajax_err) => console.error \"Error finding report downloads\"\n\n  create_report_downloads_table: (report_downloads_data) ->\n    @$report_downloads_table.empty()\n\n    options =\n      enableCellNavigation: true\n      enableColumnReorder: false\n      rowHeight: 30\n      forceFitColumns: true\n\n    columns = [\n      id: 'link'\n      field: 'link'\n      name: gettext('File Name')\n      toolTip: gettext(\"Links are generated on demand and expire within 5 minutes due to the sensitive nature of student information.\")\n      sortable: false\n      minWidth: 150\n      cssClass: \"file-download-link\"\n      formatter: (row, cell, value, columnDef, dataContext) ->\n        edx.HtmlUtils.joinHtml(\n          edx.HtmlUtils.HTML('<a target=\"_blank\" href=\"'),\n          dataContext['url'],\n          edx.HtmlUtils.HTML('\">'),\n          dataContext['name'],\n          edx.HtmlUtils.HTML('</a>')\n        )\n    ]\n\n    $table_placeholder = $ '<div/>', class: 'slickgrid'\n    @$report_downloads_table.append($table_placeholder)\n    grid = new Slick.Grid($table_placeholder, report_downloads_data, columns, options)\n    grid.onClick.subscribe(\n        (event) =>\n            report_url = event.target.href\n            if report_url\n                # Record that the user requested to download a report\n                Logger.log('edx.instructor.report.downloaded', {\n                    report_url: report_url\n                })\n    )\n    grid.autosizeColumns()\n\n\n# export for use\n# create parent namespaces if they do not already exist.\n# abort if underscore can not be found.\nif _?\n  _.defaults window, InstructorDashboard: {}\n  window.InstructorDashboard.util =\n    plantTimeout: plantTimeout\n    plantInterval: plantInterval\n    std_ajax_err: std_ajax_err\n    IntervalManager: IntervalManager\n    create_task_list_table: create_task_list_table\n    create_email_content_table: create_email_content_table\n    create_email_message_views: create_email_message_views\n    PendingInstructorTasks: PendingInstructorTasks\n    KeywordValidator: KeywordValidator\n    ReportDownloads: ReportDownloads\n", "var edx = edx || {};\n\n(function(Backbone, $, _, gettext) {\n    'use strict';\n\n    edx.instructor_dashboard = edx.instructor_dashboard || {};\n    edx.instructor_dashboard.ecommerce = {};\n\n    edx.instructor_dashboard.ecommerce.ExpiryCouponView = Backbone.View.extend({\n        el: 'li#add-coupon-modal-field-expiry',\n        events: {\n            'click input[type=\"checkbox\"]': 'clicked'\n        },\n        initialize: function() {\n            $('li#add-coupon-modal-field-expiry input[name=\"expiration_date\"]').hide();\n            _.bindAll(this, 'clicked');\n        },\n        clicked: function (event) {\n            if (event.currentTarget.checked) {\n                this.show(this.$('#coupon_expiration_date'));\n                this.$el.find('#coupon_expiration_date').focus();\n            }\n            else {\n                this.hide(this.$('#coupon_expiration_date'));\n            }\n        },\n        show: function ($el) {\n            $el.css('display', 'inline');\n        },\n        hide: function ($el) {\n            $el.css('display', 'none');\n        }\n    });\n\n    $(function() {\n        var $registration_code_status_form = $(\"form#set_regcode_status_form\"),\n            $lookup_button = $('#lookup_regcode', $registration_code_status_form),\n            $registration_code_status_form_error = $('#regcode_status_form_error', $registration_code_status_form),\n            $registration_code_status_form_success = $('#regcode_status_form_success', $registration_code_status_form);\n\n        $( \"#coupon_expiration_date\" ).datepicker({\n            minDate: 0\n        });\n        var view = new edx.instructor_dashboard.ecommerce.ExpiryCouponView();\n        $('input[name=\"user-enrollment-report\"]').click(function(){\n            var url = $(this).data('endpoint');\n            $.ajax({\n             type: 'POST',\n             dataType: \"json\",\n             url: url,\n             success: function (data) {\n                $('#enrollment-report-request-response').text(data['status']);\n                return $(\"#enrollment-report-request-response\").css({\n                  \"display\": \"block\"\n                });\n             },\n             error: function(std_ajax_err) {\n                $('#enrollment-report-request-response-error').text(gettext('There was a problem creating the report. Select \"Create Executive Summary\" to try again.'));\n                return $(\"#enrollment-report-request-response-error\").css({\n                  \"display\": \"block\"\n                });\n             }\n           });\n        });\n        $('input[name=\"exec-summary-report\"]').click(function(){\n            var url = $(this).data('endpoint');\n            $.ajax({\n             type: 'POST',\n             dataType: \"json\",\n             url: url,\n             success: function (data) {\n                $(\"#exec-summary-report-request-response\").text(data['status']);\n                return $(\"#exec-summary-report-request-response\").css({\n                  \"display\": \"block\"\n                });\n               },\n             error: function(std_ajax_err) {\n                $('#exec-summary-report-request-response-error').text(gettext('There was a problem creating the report. Select \"Create Executive Summary\" to try again.'));\n                return $(\"#exec-summary-report-request-response-error\").css({\n                  \"display\": \"block\"\n                });\n             }\n           });\n        });\n        $lookup_button.click(function () {\n            $registration_code_status_form_error.hide();\n            $lookup_button.attr('disabled', true);\n            var url = $(this).data('endpoint');\n            var lookup_registration_code = $('#set_regcode_status_form input[name=\"regcode_code\"]').val();\n            if (lookup_registration_code == '') {\n                $registration_code_status_form_error.show();\n                $registration_code_status_form_error.text(gettext('Enter the enrollment code.'));\n                $lookup_button.removeAttr('disabled');\n                return false;\n            }\n            $.ajax({\n                type: \"GET\",\n                data: {\n                    \"registration_code\"  : lookup_registration_code\n                },\n                url: url,\n                success: function (data) {\n                    var is_registration_code_valid = data.is_registration_code_valid,\n                    is_registration_code_redeemed = data.is_registration_code_redeemed,\n                    is_registration_code_exists = data.is_registration_code_exists;\n\n                    $lookup_button.removeAttr('disabled');\n                    if (is_registration_code_exists == 'false') {\n                        $registration_code_status_form_error.hide();\n                        $registration_code_status_form_error.show();\n                        $registration_code_status_form_error.text(gettext(data.message));\n                    }\n                    else {\n                        var actions_links = '';\n                        var actions = [];\n                        if (is_registration_code_valid == true) {\n                            actions.push(\n                                {\n                                    'action_url': data.registration_code_detail_url,\n                                    'action_name': gettext('Cancel enrollment code'),\n                                    'registration_code': lookup_registration_code,\n                                    'action_type': 'invalidate_registration_code'\n                                }\n                            );\n                        }\n                        else {\n                            actions.push(\n                                {\n                                    'action_url': data.registration_code_detail_url,\n                                    'action_name': gettext('Restore enrollment code'),\n                                    'registration_code': lookup_registration_code,\n                                    'action_type': 'validate_registration_code'\n                                }\n                            );\n                        }\n                        if (is_registration_code_redeemed == true) {\n                            actions.push(\n                                {\n                                    'action_url': data.registration_code_detail_url,\n                                    'action_name': gettext('Mark enrollment code as unused'),\n                                    'registration_code': lookup_registration_code,\n                                    'action_type': 'unredeem_registration_code'\n                                }\n                            );\n                        }\n                        is_registration_code_redeemed = is_registration_code_redeemed ? 'Yes' : 'No';\n                        is_registration_code_valid = is_registration_code_valid ? 'Yes' : 'No';\n                        // load the underscore template.\n                        var template_data = _.template($('#enrollment-code-lookup-links-tpl').text());\n                        var registration_code_lookup_actions = template_data(\n                            {\n                                lookup_registration_code: lookup_registration_code,\n                                is_registration_code_redeemed: is_registration_code_redeemed,\n                                is_registration_code_valid: is_registration_code_valid,\n                                actions: actions\n                            }\n                        );\n\n                        // before insertAfter do this.\n                        // remove the first element after the registration_code_status_form\n                        // so it doesn't duplicate the registration_code_lookup_actions in the UI.\n                        $registration_code_status_form.next().remove();\n                        $(registration_code_lookup_actions).insertAfter($registration_code_status_form);\n                    }\n                },\n                error: function(jqXHR, textStatus, errorThrown) {\n                    var data = $.parseJSON(jqXHR.responseText);\n                    $lookup_button.removeAttr('disabled');\n                    $registration_code_status_form_error.text(gettext(data.message));\n                    $registration_code_status_form_error.show();\n                }\n            });\n        });\n        $(\"section#invalidate_registration_code_modal\").on('click', 'a.registration_code_action_link', function(event) {\n            event.preventDefault();\n            $registration_code_status_form_error.attr('style', 'display: none');\n            $lookup_button.attr('disabled', true);\n            var url = $(this).data('endpoint');\n            var action_type = $(this).data('action-type');\n            var registration_code = $(this).data('registration-code');\n            $.ajax({\n                type: \"POST\",\n                data: {\n                    \"registration_code\": registration_code,\n                    \"action_type\": action_type\n                },\n                url: url,\n                success: function (data) {\n                    $('#set_regcode_status_form input[name=\"regcode_code\"]').val('');\n                    $registration_code_status_form.next().remove();\n                    $registration_code_status_form_error.hide();\n                    $lookup_button.removeAttr('disabled');\n                    $registration_code_status_form_success.text(gettext(data.message));\n                    $registration_code_status_form_success.show();\n                    $registration_code_status_form_success.fadeOut(3000);\n                },\n                error: function(jqXHR, textStatus, errorThrown) {\n                    var data = $.parseJSON(jqXHR.responseText);\n                    $registration_code_status_form_error.hide();\n                    $lookup_button.removeAttr('disabled');\n                    $registration_code_status_form_error.show();\n                    $registration_code_status_form_error.text(gettext(data.message));\n                }\n            });\n        });\n    });\n})(Backbone, $, _, gettext);\n", "define(['jquery', 'coffee/src/instructor_dashboard/student_admin', 'common/js/spec_helpers/ajax_helpers'],\n    function ($, StudentAdmin, AjaxHelpers) {\n        //'coffee/src/instructor_dashboard/student_admin'\n        'use strict';\n        describe(\"edx.instructor_dashboard.student_admin.StudentAdmin\", function() {\n            var studentadmin, dashboard_api_url, unique_student_identifier, alert_msg;\n\n            beforeEach(function() {\n                loadFixtures('js/fixtures/instructor_dashboard/student_admin.html');\n                window.InstructorDashboard = {};\n                window.InstructorDashboard.util = {\n                    std_ajax_err: std_ajax_err,\n                    PendingInstructorTasks: PendingInstructorTasks,\n                    create_task_list_table: create_task_list_table\n                };\n                studentadmin = new window.StudentAdmin($('#student_admin'));\n                dashboard_api_url = '/courses/PU/FSc/2014_T4/instructor/api';\n                unique_student_identifier = \"test@example.com\";\n                alert_msg = '';\n                spyOn(window, 'alert').and.callFake(function(message) {\n                    alert_msg = message;\n                });\n\n            });\n\n            it('initiates resetting of entrance exam when button is clicked', function() {\n                studentadmin.$btn_reset_entrance_exam_attempts.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Please enter a student email address or username.\"));\n\n                var success_message = gettext(\"Entrance exam attempts is being reset for student '{student_id}'.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier);\n                studentadmin.$btn_reset_entrance_exam_attempts.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: false\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when resetting of entrance exam fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_reset_entrance_exam_attempts.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: false\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error resetting entrance exam attempts for student '{student_id}'. Make sure student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n            it('initiates rescoring of the entrance exam when the button is clicked', function() {\n                studentadmin.$btn_rescore_entrance_exam.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Please enter a student email address or username.\"));\n\n                var success_message = gettext(\"Started entrance exam rescore task for student '{student_id}'.\" +\n                    \" Click the 'Show Background Task History for Student' button to see the status of the task.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_rescore_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/rescore_entrance_exam';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when entrance exam rescoring fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_rescore_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/rescore_entrance_exam';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error starting a task to rescore entrance exam for student '{student_id}'.\" +\n                    \" Make sure that entrance exam has problems in it and student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n            it('initiates skip entrance exam when button is clicked', function() {\n                studentadmin.$btn_skip_entrance_exam.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Enter a student's username or email address.\"));\n\n                var success_message = \"This student ('{student_id}') will skip the entrance exam.\";\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_skip_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var url = dashboard_api_url + '/mark_student_can_skip_entrance_exam';\n                AjaxHelpers.expectRequest(requests, 'POST', url, $.param({\n                    'unique_student_identifier': unique_student_identifier\n                }));\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when skip entrance exam fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_skip_entrance_exam.click();\n                // Verify that the client contacts the server to start instructor task\n                var url = dashboard_api_url + '/mark_student_can_skip_entrance_exam';\n                AjaxHelpers.expectRequest(requests, 'POST', url, $.param({\n                    'unique_student_identifier': unique_student_identifier\n                }));\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = \"An error occurred. Make sure that the student's username or email address is correct and try again.\";\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(error_message);\n            });\n\n            it('initiates delete student state for entrance exam when button is clicked', function() {\n                studentadmin.$btn_delete_entrance_exam_state.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Please enter a student email address or username.\"));\n\n                var success_message = gettext(\"Entrance exam state is being deleted for student '{student_id}'.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_delete_entrance_exam_state.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: true\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    message: full_success_message\n                });\n                expect(alert_msg).toEqual(full_success_message);\n            });\n\n            it('shows an error when delete student state for entrance exam fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_delete_entrance_exam_state.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier,\n                    delete_module: true\n                });\n                var url = dashboard_api_url + '/reset_student_attempts_for_entrance_exam';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error deleting entrance exam state for student '{student_id}'. \" +\n                    \"Make sure student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n            it('initiates listing of entrance exam task history when button is clicked', function() {\n                studentadmin.$btn_entrance_exam_task_history.click();\n                // expect error to be shown since student identifier is not set\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(gettext(\"Enter a student's username or email address.\"));\n\n                var success_message = gettext(\"Entrance exam state is being deleted for student '{student_id}'.\");\n                var full_success_message = interpolate_text(success_message, {\n                  student_id: unique_student_identifier\n                });\n\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_entrance_exam_task_history.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/list_entrance_exam_instructor_tasks';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate a success response from the server\n                AjaxHelpers.respondWithJson(requests, {\n                    \"tasks\": [\n                        {\n                            \"status\": \"Incomplete\",\n                            \"task_type\": \"rescore_problem\",\n                            \"task_id\": \"9955d413-eac1-441f-978d-27c60dd1c946\",\n                            \"created\": \"2015-02-19T10:59:01+00:00\",\n                            \"task_input\": \"{\\\"entrance_exam_url\\\": \\\"i4x://PU/FSc/chapter/d2204197cce443c4a0d5c852d4e7f638\\\", \\\"student\\\": \\\"audit\\\"}\",\n                            \"duration_sec\": \"unknown\",\n                            \"task_message\": \"No status information available\",\n                            \"requester\": \"staff\",\n                            \"task_state\": \"QUEUING\"\n                        }\n                    ]\n                });\n                expect($('.entrance-exam-task-history-table')).toBeVisible();\n            });\n\n            it('shows an error when listing entrance exam task history fails', function() {\n                // Spy on AJAX requests\n                var requests = AjaxHelpers.requests(this);\n                studentadmin.$field_entrance_exam_student_select_grade.val(unique_student_identifier)\n                studentadmin.$btn_entrance_exam_task_history.click();\n                // Verify that the client contacts the server to start instructor task\n                var params = $.param({\n                    unique_student_identifier: unique_student_identifier\n                });\n                var url = dashboard_api_url + '/list_entrance_exam_instructor_tasks';\n                AjaxHelpers.expectPostRequest(requests, url, params);\n\n                // Simulate an error response from the server\n                AjaxHelpers.respondWithError(requests, 400,{});\n\n                var error_message = gettext(\"Error getting entrance exam task history for student '{student_id}'. \" +\n                    \"Make sure student identifier is correct.\");\n                var full_error_message = interpolate_text(error_message, {\n                  student_id: unique_student_identifier\n                });\n                expect(studentadmin.$request_response_error_ee.text()).toEqual(full_error_message);\n            });\n\n        });\n    });\n", "define([\n    'backbone', \n    'jquery', \n    'js/staff_debug_actions', \n    'common/js/spec_helpers/ajax_helpers'\n    ],\n    function (Backbone, $, tmp, AjaxHelpers) {\n        'use strict';\n        var StaffDebug = window.StaffDebug;\n\n        describe('StaffDebugActions', function () {\n            var location = 'i4x://edX/Open_DemoX/edx_demo_course/problem/test_loc';\n            var locationName = 'test_loc';\n            var fixture_id = 'sd_fu_' + locationName;\n            var fixture = $('<input>', { id: fixture_id, placeholder: \"userman\" });\n            var escapableLocationName = 'test\\.\\*\\+\\?\\^\\:\\$\\{\\}\\(\\)\\|\\]\\[loc';\n            var escapableFixture_id = 'sd_fu_' + escapableLocationName;\n            var escapableFixture = $('<input>', {id: escapableFixture_id, placeholder: \"userman\"});\n            var esclocationName = 'P2:problem_1';\n            var escapableId = 'result_' + esclocationName; \n            var escapableResultArea = $('<div>', {id: escapableId});\n\n            describe('get_url ', function () {\n                it('defines url to courseware ajax entry point', function () {\n                    spyOn(StaffDebug, \"get_current_url\")\n                      .and.returnValue(\"/courses/edX/Open_DemoX/edx_demo_course/courseware/stuff\");\n                    expect(StaffDebug.get_url('rescore_problem'))\n                      .toBe('/courses/edX/Open_DemoX/edx_demo_course/instructor/api/rescore_problem');\n                });\n            });\n\n            describe('sanitize_string', function () {\n                it('escapes escapable characters in a string', function () {\n                    expect(StaffDebug.sanitized_string('.*+?^:${}()|][')).toBe('\\\\.\\\\*\\\\+\\\\?\\\\^\\\\:\\\\$\\\\{\\\\}\\\\(\\\\)\\\\|\\\\]\\\\[');\n                });\n            });\n\n            describe('get_user', function () {\n\n                it('gets the placeholder username if input field is empty', function () {\n                    $('body').append(fixture);\n                    expect(StaffDebug.get_user(locationName)).toBe('userman');\n                    $('#' + fixture_id).remove();\n                });\n                it('gets a filled in name if there is one', function () {\n                    $('body').append(fixture);\n                    $('#' + fixture_id).val('notuserman');\n                    expect(StaffDebug.get_user(locationName)).toBe('notuserman');\n\n                    $('#' + fixture_id).val('');\n                    $('#' + fixture_id).remove();\n                });\n                it('gets the placeholder name if the id has escapable characters', function() {\n                    $('body').append(escapableFixture);\n                    expect(StaffDebug.get_user('test.*+?^:${}()|][loc')).toBe('userman');\n                    $(\"input[id^='sd_fu_']\").remove();\n                });\n            });\n            describe('do_idash_action success', function () {\n                it('adds a success message to the results element after using an action', function () {\n                    $('body').append(escapableResultArea);\n                    var requests = AjaxHelpers.requests(this);\n                    var action = {\n                        locationName: esclocationName,\n                        success_msg: 'Successfully reset the attempts for user userman',\n                    };\n                    StaffDebug.do_idash_action(action);\n                    AjaxHelpers.respondWithJson(requests, action);\n                    expect($('#idash_msg').text()).toBe('Successfully reset the attempts for user userman');\n                    $('#result_' + locationName).remove();\n                });\n            });\n            describe('do_idash_action error', function () {\n                it('adds a failure message to the results element after using an action', function () {\n                    $('body').append(escapableResultArea);\n                    var requests = AjaxHelpers.requests(this);\n                    var action = {\n                        locationName: esclocationName,\n                        error_msg: 'Failed to reset attempts.',\n                    };\n                    StaffDebug.do_idash_action(action);\n                    AjaxHelpers.respondWithError(requests);\n                    expect($('#idash_msg').text()).toBe('Failed to reset attempts. ');\n                    $('#result_' + locationName).remove();\n                });\n            });                    \n            describe('reset', function () {\n                it('makes an ajax call with the expected parameters', function () {\n                    $('body').append(fixture);\n\n                    spyOn($, 'ajax');\n                    StaffDebug.reset(locationName, location);\n\n                    expect($.ajax.calls.mostRecent().args[0].type).toEqual('POST');\n                    expect($.ajax.calls.mostRecent().args[0].data).toEqual({\n                        'problem_to_reset': location,\n                        'unique_student_identifier': 'userman',\n                        'delete_module': false\n                    });\n                    expect($.ajax.calls.mostRecent().args[0].url).toEqual(\n                        '/instructor/api/reset_student_attempts'\n                    );\n                    $('#' + fixture_id).remove();\n                });\n            });\n            describe('sdelete', function () {\n                it('makes an ajax call with the expected parameters', function () {\n                    $('body').append(fixture);\n\n                    spyOn($, 'ajax');\n                    StaffDebug.sdelete(locationName, location);\n\n                    expect($.ajax.calls.mostRecent().args[0].type).toEqual('POST');\n                    expect($.ajax.calls.mostRecent().args[0].data).toEqual({\n                        'problem_to_reset': location,\n                        'unique_student_identifier': 'userman',\n                        'delete_module': true\n                    });\n                    expect($.ajax.calls.mostRecent().args[0].url).toEqual(\n                        '/instructor/api/reset_student_attempts'\n                    );\n\n                    $('#' + fixture_id).remove();\n                });\n            });\n            describe('rescore', function () {\n                it('makes an ajax call with the expected parameters', function () {\n                    $('body').append(fixture);\n\n                    spyOn($, 'ajax');\n                    StaffDebug.rescore(locationName, location);\n\n                    expect($.ajax.calls.mostRecent().args[0].type).toEqual('POST');\n                    expect($.ajax.calls.mostRecent().args[0].data).toEqual({\n                        'problem_to_reset': location,\n                        'unique_student_identifier': 'userman',\n                        'delete_module': false\n                    });\n                    expect($.ajax.calls.mostRecent().args[0].url).toEqual(\n                        '/instructor/api/rescore_problem'\n                    );\n                    $('#' + fixture_id).remove();\n                });\n            });\n        });\n    });", "// Build StaffDebug object\nvar StaffDebug = (function (){\n\n  get_current_url = function() {\n    return window.location.pathname;\n  };\n\n  get_url = function(action){\n    var pathname = this.get_current_url();\n    var url = pathname.substr(0,pathname.indexOf('/courseware')) + '/instructor/api/' + action;\n    return url;\n  };\n\n  sanitized_string = function(string) {\n    return string.replace(/[.*+?^:${}()|[\\]\\\\]/g, \"\\\\$&\");\n  };\n\n  get_user = function(locname){\n    locname = sanitized_string(locname);\n    var uname = $('#sd_fu_' + locname).val();\n    if (uname===\"\"){\n        uname =  $('#sd_fu_' + locname).attr('placeholder');\n    }\n    return uname;\n  };\n\n  do_idash_action = function(action){\n    var pdata = {\n        'problem_to_reset': action.location,\n        'unique_student_identifier': get_user(action.locationName),\n        'delete_module': action.delete_module\n    };\n    $.ajax({\n        type: \"POST\",\n        url: get_url(action.method),\n        data: pdata,\n        success: function(data){\n            var text = _.template(action.success_msg, {interpolate: /\\{(.+?)\\}/g})(\n                {user: data.student}\n            );\n            var html = _.template('<p id=\"idash_msg\" class=\"success\">{text}</p>', {interpolate: /\\{(.+?)\\}/g})(\n                {text: text}\n            );\n            $(\"#result_\"+sanitized_string(action.locationName)).html(html);\n        },\n        error: function(request, status, error) {\n            var response_json;\n            try {\n                response_json = $.parseJSON(request.responseText);\n            } catch(e) {\n                response_json = { error: gettext('Unknown Error Occurred.') };\n            }\n            var text = _.template('{error_msg} {error}', {interpolate: /\\{(.+?)\\}/g})(\n                {\n                    error_msg: action.error_msg,\n                    error: response_json.error\n                }\n            );\n            var html = _.template('<p id=\"idash_msg\" class=\"error\">{text}</p>', {interpolate: /\\{(.+?)\\}/g})(\n                {text: text}\n            );\n            $(\"#result_\"+sanitized_string(action.locationName)).html(html);\n\n        },\n        dataType: 'json'\n    });\n  };\n\n  reset = function(locname, location){\n    this.do_idash_action({\n        locationName: locname,\n        location: location,\n        method: 'reset_student_attempts',\n        success_msg: gettext('Successfully reset the attempts for user {user}'),\n        error_msg: gettext('Failed to reset attempts.'),\n        delete_module: false\n    });\n  };\n\n  sdelete = function(locname, location){\n    this.do_idash_action({\n        locationName: locname,\n        location: location,\n        method: 'reset_student_attempts',\n        success_msg: gettext('Successfully deleted student state for user {user}'),\n        error_msg: gettext('Failed to delete student state.'),\n        delete_module: true\n    });\n  };\n\n  rescore = function(locname, location){\n    this.do_idash_action({\n        locationName: locname,\n        location: location,\n        method: 'rescore_problem',\n        success_msg: gettext('Successfully rescored problem for user {user}'),\n        error_msg: gettext('Failed to rescore problem.'),\n        delete_module: false\n    });\n  };\n\n  return {\n      reset: reset,\n      sdelete: sdelete,\n      rescore: rescore,\n      do_idash_action: do_idash_action,\n      get_current_url: get_current_url,\n      get_url: get_url,\n      get_user: get_user,\n      sanitized_string:sanitized_string\n  }; })();\n\n// Register click handlers\n$(document).ready(function() {\n\n    var $courseContent = $('.course-content');\n    $courseContent.on(\"click\", '.staff-debug-reset', function() {\n        StaffDebug.reset($(this).parent().data('location-name'), $(this).parent().data('location'));\n        return false;\n    });\n    $courseContent.on(\"click\", '.staff-debug-sdelete', function() {\n        StaffDebug.sdelete($(this).parent().data('location-name'), $(this).parent().data('location'));\n        return false;\n    });\n    $courseContent.on(\"click\", '.staff-debug-rescore', function() {\n        StaffDebug.rescore($(this).parent().data('location-name'), $(this).parent().data('location'));\n        return false;\n    });\n});\n"], "buggy_code_start_loc": [20, 143, 112, 47, 139, 101, 78, 338, 47, 39, 94, 34], "buggy_code_end_loc": [4814, 3080, 246, 92, 666, 117, 350, 394, 66, 284, 134, 35], "fixing_code_start_loc": [20, 142, 113, 48, 140, 102, 79, 339, 48, 39, 94, 34], "fixing_code_end_loc": [4948, 3075, 255, 97, 671, 120, 363, 397, 69, 284, 134, 35], "type": "CWE-352", "message": "edx-platform before 2016-06-06 allows CSRF.", "other": {"cve": {"id": "CVE-2016-10766", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-29T17:15:11.183", "lastModified": "2020-01-07T19:55:13.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "edx-platform before 2016-06-06 allows CSRF."}, {"lang": "es", "value": "La plataforma edx antes del 06-06-2016, permite un ataque de tipo CSRF."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:edx:edx-platform:*:*:*:*:*:*:*:*", "versionEndExcluding": "2016-06-06", "matchCriteriaId": "69AFC65D-0F1D-4D9B-AD37-DC2C4618ABB6"}]}]}], "references": [{"url": "https://github.com/edx/edx-platform/commit/d54f79f5bf3e1af17063937df1abc0026843412d.patch", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://open.edx.org/announcements/cross-site-request-forgery-bug-edx-lms/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/edx/edx-platform/commit/d54f79f5bf3e1af17063937df1abc0026843412d.patch"}}