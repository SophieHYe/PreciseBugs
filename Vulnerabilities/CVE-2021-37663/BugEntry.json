{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/math_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/type_traits.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/cwise_ops.h\"\n#include \"tensorflow/core/kernels/meta_support.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n\nnamespace {\nenum {\n  QUANTIZE_MODE_MIN_COMBINED,\n  QUANTIZE_MODE_MIN_FIRST,\n  QUANTIZE_MODE_SCALED,\n};\nenum {\n  // Round half away from zero: if the fraction of y is exactly 0.5, then\n  // round(y) = y + 0.5 if y > 0\n  // round(y) = y - 0.5 if y < 0\n  // E.g., -5.5 gets rounded to -6, -5.4 goes to -5,\n  // 5.4 goes to 5, and 5.5 goes to 6.\n  ROUND_HALF_AWAY_FROM_ZERO,\n  // Round half to even: if the fraction of y is exactly 0.5, then round(y) is\n  // the nearest even integer to y.\n  // E.g., 23.5 gets rounded to 24, 24.5 gets rounded to 24, while -23.5 becomes\n  // -24, and -24.5 gets rounded to 24.\n  ROUND_HALF_TO_EVEN,\n};\n}  // namespace\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\n// Quantize a tensor from float to T, with user-specified min_range and\n// max_range.\n// TODO(xbing): Add a new QuantizeOp just taking scale,\n//              rather than min_range and max_range.\ntemplate <typename Device, typename T>\nclass QuantizeV2Op : public OpKernel {\n public:\n  explicit QuantizeV2Op(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    half_range_ =\n        !std::is_signed<T>::value\n            ? 0.0f\n            : (static_cast<double>(std::numeric_limits<T>::max()) -\n               static_cast<double>(std::numeric_limits<T>::min()) + 1) /\n                  2.0f;\n    string mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"mode\", &mode_string));\n    OP_REQUIRES(ctx,\n                (mode_string == \"MIN_COMBINED\" || mode_string == \"MIN_FIRST\" ||\n                 mode_string == \"SCALED\"),\n                errors::InvalidArgument(\"Mode string must be 'MIN_COMBINED',\"\n                                        \" 'MIN_FIRST', or 'SCALED', is '\" +\n                                        mode_string + \"'\"));\n    if (mode_string == \"MIN_COMBINED\") {\n      mode_ = QUANTIZE_MODE_MIN_COMBINED;\n    } else if (mode_string == \"MIN_FIRST\") {\n      mode_ = QUANTIZE_MODE_MIN_FIRST;\n    } else if (mode_string == \"SCALED\") {\n      mode_ = QUANTIZE_MODE_SCALED;\n    }\n\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(ctx,\n                (round_mode_string == \"HALF_AWAY_FROM_ZERO\" ||\n                 round_mode_string == \"HALF_TO_EVEN\"),\n                errors::InvalidArgument(\"Round mode string must be \"\n                                        \"'HALF_AWAY_FROM_ZERO' or \"\n                                        \"'HALF_TO_EVEN', is '\" +\n                                        round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_AWAY_FROM_ZERO\") {\n      round_mode_ = ROUND_HALF_AWAY_FROM_ZERO;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      OP_REQUIRES(ctx, mode_string == \"SCALED\",\n                  errors::InvalidArgument(\"Round mode 'HALF_TO_EVEN' \"\n                                          \"only supported for mode 'SCALED', \"\n                                          \"b  ut mode is '\" +\n                                          mode_string + \"'.\"));\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(\n        ctx, ctx->GetAttr(\"ensure_minimum_range\", &ensure_minimum_range_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_range = ctx->input(1);\n    const Tensor& input_max_range = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n\n    const TensorShape& minmax_shape = ctx->input(1).shape();\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    Tensor* output_min_tensor = nullptr;\n    Tensor* output_max_tensor = nullptr;\n\n    if (num_slices == 1) {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));\n      const float min_range = input_min_range.template flat<float>()(0);\n      const float max_range = input_max_range.template flat<float>()(0);\n      QuantizeTensor(ctx, input, min_range, max_range, output,\n                     output_min_tensor, output_max_tensor);\n      return;\n    }\n\n    OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                      \"Quantize with axis != -1.\"));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, minmax_shape, &output_min_tensor));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, minmax_shape, &output_max_tensor));\n\n    auto input_tensor =\n        input.template flat_inner_outer_dims<float, 3>(axis_ - 1);\n    int64_t pre_dim = 1, post_dim = 1;\n    for (int i = 0; i < axis_; ++i) {\n      pre_dim *= output->dim_size(i);\n    }\n    for (int i = axis_ + 1; i < output->dims(); ++i) {\n      post_dim *= output->dim_size(i);\n    }\n    auto output_tensor = output->template bit_casted_shaped<T, 3>(\n        {pre_dim, num_slices, post_dim});\n    auto min_ranges = input_min_range.template vec<float>();\n    auto max_ranges = input_max_range.template vec<float>();\n    for (int i = 0; i < num_slices; ++i) {\n      QuantizeSlice(ctx->eigen_device<Device>(), ctx,\n                    input_tensor.template chip<1>(i), min_ranges(i),\n                    max_ranges(i), output_tensor.template chip<1>(i),\n                    &output_min_tensor->flat<float>()(i),\n                    &output_max_tensor->flat<float>()(i));\n    }\n  }\n\n  void QuantizeTensor(OpKernelContext* ctx, const Tensor& input,\n                      const float input_min_range, const float input_max_range,\n                      Tensor* output, Tensor* output_min_tensor,\n                      Tensor* output_max_tensor) {\n    OP_REQUIRES(ctx, !(input_max_range < input_min_range),\n                errors::InvalidArgument(\n                    \"input_max_range must be larger than input_min_range.\"));\n\n    // When the minimum and maximum ranges are too close together, nudge them\n    // apart by a small value so that they are slightly different. This helps\n    // us avoid creating ill-formed buffers where all quantized values map to\n    // the same float number. These kinds of buffers cause problems for\n    // downstream ops when they need to do calculations on them.\n    // We pick the value by making sure that zero is not more than 100x the\n    // overall range from the maximum, so that the value can be easily\n    // represented when we promote the quantized value to a higher\n    // intermediate bit depth, since that's a common requirement.\n    float min_range = std::min(0.0f, input_min_range);\n    const float epsilon = std::max(1.0f, std::max(fabsf(input_min_range),\n                                                  fabsf(input_max_range))) *\n                          ensure_minimum_range_;\n    float max_range =\n        std::max(0.0f, std::max(input_max_range, min_range + epsilon));\n\n    if (mode_ == QUANTIZE_MODE_MIN_FIRST) {\n      if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n        TTypes<const float>::Vec input_array = input.flat<float>();\n\n        meta::Quantize(ctx, input_array.data(), input_array.size(), min_range,\n                       max_range, output->flat<quint8>().data());\n      } else {\n        FloatTensorToQuantizedInPlaceUsingEigen<T>(\n            ctx->template eigen_device<Device>(), input, min_range, max_range,\n            output);\n      }\n      output_min_tensor->flat<float>()(0) = min_range;\n      output_max_tensor->flat<float>()(0) = max_range;\n    } else {\n      QuantizeSlice(ctx->eigen_device<Device>(), ctx, input.flat<float>(),\n                    input_min_range, input_max_range,\n                    output->template flat<T>(),\n                    &output_min_tensor->flat<float>()(0),\n                    &output_max_tensor->flat<float>()(0));\n    }\n  }\n\n  template <typename ConstVec, typename Vec>\n  void QuantizeSlice(const Device& d, OpKernelContext* ctx,\n                     const ConstVec& input, float input_min_range,\n                     float input_max_range, Vec output, float* output_min_range,\n                     float* output_max_range) {\n    OP_REQUIRES(ctx, !(input_max_range < input_min_range),\n                errors::InvalidArgument(\n                    \"input_max_range must be larger than input_min_range.\"));\n    float min_range = std::min(0.0f, input_min_range);\n    const float epsilon = std::max(1.0f, std::max(fabsf(input_min_range),\n                                                  fabsf(input_max_range))) *\n                          ensure_minimum_range_;\n    float max_range =\n        std::max(0.0f, std::max(input_max_range, min_range + epsilon));\n\n    if (mode_ == QUANTIZE_MODE_MIN_COMBINED) {\n      const float scale_factor =\n          (static_cast<double>(std::numeric_limits<T>::max()) -\n           static_cast<double>(std::numeric_limits<T>::min())) /\n          (max_range - min_range);\n\n      // Quantize:\n      // Make input in range of [min_range, max_range], then\n      // subtract min_range to be in range of [0, max_range - min_range]\n      // Divide by (max_range - min_range) to get to [0, 1.0]\n      // Multiply by range of T, after that shift left 1/2 range of T if\n      // T is signed.\n      // Note that the number is rounded before the cast. Rounding follows the\n      // semantic of std::round, which implements \"round-half-away-zero\",\n      // e.g., -5.5 gets rounded to -6, -5.4 goes to -5, 5.4 goes to 5,\n      // and 5.5 goes to 6.\n      bool is_signed = std::is_signed<T>::value;\n      if (is_signed) {\n        // The slow path.\n        // TODO(xbing,yonghui): Speedup this path as well.\n        output.device(d) =\n            ((input.cwiseMin(max_range).cwiseMax(min_range) - min_range) *\n                 scale_factor -\n             half_range_)\n                .round()\n                .template cast<T>();\n      } else {\n        // The fast path that avoids unaryExpr\n        // According to the micro-benchmark, adding device here doesn't help.\n        output.device(d) =\n            ((input.cwiseMin(max_range).cwiseMax(min_range) - min_range) *\n                 scale_factor +\n             0.5f)\n                .template cast<T>();\n      }\n    } else if (mode_ == QUANTIZE_MODE_SCALED) {\n      const int min_output_value =\n          std::numeric_limits<T>::min() + (narrow_range_ ? 1 : 0);\n      const int max_output_value = std::numeric_limits<T>::max();\n      const float scale_factor_from_min_side =\n          (min_output_value * min_range > 0)\n              ? min_output_value / min_range\n              : std::numeric_limits<float>::max();\n      const float scale_factor_from_max_side =\n          (max_output_value * max_range > 0)\n              ? max_output_value / max_range\n              : std::numeric_limits<float>::max();\n      const float scale_factor =\n          std::min(scale_factor_from_min_side, scale_factor_from_max_side);\n      min_range = min_output_value / scale_factor;\n      max_range = max_output_value / scale_factor;\n      if (round_mode_ == ROUND_HALF_TO_EVEN) {\n        output.device(d) =\n            (input.cwiseMin(max_range).cwiseMax(min_range) * scale_factor)\n                .unaryExpr(\n                    Eigen::internal::scalar_round_half_to_even_op<float>())\n                .template cast<T>();\n      } else if (round_mode_ == ROUND_HALF_AWAY_FROM_ZERO) {\n        output.device(d) =\n            (input.cwiseMin(max_range).cwiseMax(min_range) * scale_factor)\n                .round()\n                .template cast<T>();\n      }\n    }\n\n    *output_min_range = min_range;\n    *output_max_range = max_range;\n  }\n\n private:\n  float half_range_;\n  float ensure_minimum_range_;\n  int mode_;\n  int round_mode_;\n  int axis_;\n  bool narrow_range_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<quint8>(\"T\"),\n    QuantizeV2Op<CPUDevice, quint8>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<qint8>(\"T\"),\n    QuantizeV2Op<CPUDevice, qint8>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<quint16>(\"T\"),\n    QuantizeV2Op<CPUDevice, quint16>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<qint16>(\"T\"),\n    QuantizeV2Op<CPUDevice, qint16>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<qint32>(\"T\"),\n    QuantizeV2Op<CPUDevice, qint32>);\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/math_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/type_traits.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/cwise_ops.h\"\n#include \"tensorflow/core/kernels/meta_support.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n\nnamespace {\nenum {\n  QUANTIZE_MODE_MIN_COMBINED,\n  QUANTIZE_MODE_MIN_FIRST,\n  QUANTIZE_MODE_SCALED,\n};\nenum {\n  // Round half away from zero: if the fraction of y is exactly 0.5, then\n  // round(y) = y + 0.5 if y > 0\n  // round(y) = y - 0.5 if y < 0\n  // E.g., -5.5 gets rounded to -6, -5.4 goes to -5,\n  // 5.4 goes to 5, and 5.5 goes to 6.\n  ROUND_HALF_AWAY_FROM_ZERO,\n  // Round half to even: if the fraction of y is exactly 0.5, then round(y) is\n  // the nearest even integer to y.\n  // E.g., 23.5 gets rounded to 24, 24.5 gets rounded to 24, while -23.5 becomes\n  // -24, and -24.5 gets rounded to 24.\n  ROUND_HALF_TO_EVEN,\n};\n}  // namespace\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\n// Quantize a tensor from float to T, with user-specified min_range and\n// max_range.\n// TODO(xbing): Add a new QuantizeOp just taking scale,\n//              rather than min_range and max_range.\ntemplate <typename Device, typename T>\nclass QuantizeV2Op : public OpKernel {\n public:\n  explicit QuantizeV2Op(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    half_range_ =\n        !std::is_signed<T>::value\n            ? 0.0f\n            : (static_cast<double>(std::numeric_limits<T>::max()) -\n               static_cast<double>(std::numeric_limits<T>::min()) + 1) /\n                  2.0f;\n    string mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"mode\", &mode_string));\n    OP_REQUIRES(ctx,\n                (mode_string == \"MIN_COMBINED\" || mode_string == \"MIN_FIRST\" ||\n                 mode_string == \"SCALED\"),\n                errors::InvalidArgument(\"Mode string must be 'MIN_COMBINED',\"\n                                        \" 'MIN_FIRST', or 'SCALED', is '\" +\n                                        mode_string + \"'\"));\n    if (mode_string == \"MIN_COMBINED\") {\n      mode_ = QUANTIZE_MODE_MIN_COMBINED;\n    } else if (mode_string == \"MIN_FIRST\") {\n      mode_ = QUANTIZE_MODE_MIN_FIRST;\n    } else if (mode_string == \"SCALED\") {\n      mode_ = QUANTIZE_MODE_SCALED;\n    }\n\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(ctx,\n                (round_mode_string == \"HALF_AWAY_FROM_ZERO\" ||\n                 round_mode_string == \"HALF_TO_EVEN\"),\n                errors::InvalidArgument(\"Round mode string must be \"\n                                        \"'HALF_AWAY_FROM_ZERO' or \"\n                                        \"'HALF_TO_EVEN', is '\" +\n                                        round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_AWAY_FROM_ZERO\") {\n      round_mode_ = ROUND_HALF_AWAY_FROM_ZERO;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      OP_REQUIRES(ctx, mode_string == \"SCALED\",\n                  errors::InvalidArgument(\"Round mode 'HALF_TO_EVEN' \"\n                                          \"only supported for mode 'SCALED', \"\n                                          \"b  ut mode is '\" +\n                                          mode_string + \"'.\"));\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(\n        ctx, ctx->GetAttr(\"ensure_minimum_range\", &ensure_minimum_range_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_range = ctx->input(1);\n    const Tensor& input_max_range = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      OP_REQUIRES(\n          ctx, input.dims() > axis_,\n          errors::InvalidArgument(\n              \"Axis is on a zero-based index, so its value must always be less \"\n              \"than number of input's dims, but given axis value was \",\n              axis_, \" and input's dims was \", input.dims()));\n      num_slices = input.dim_size(axis_);\n      OP_REQUIRES(ctx, input_min_range.dims() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is specified, min_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but min_range dims are \",\n                      input_min_range.dims()));\n      OP_REQUIRES(ctx, input_min_range.dim_size(0) == num_slices,\n                  errors::InvalidArgument(\n                      \"If axis is specified, min_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but min_range is a 1-D tensor of size \",\n                      input_min_range.dim_size(0),\n                      \" and input's axis dimension is of size \", num_slices));\n      OP_REQUIRES(ctx, input_max_range.dims() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is specified, max_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but max_range dims are \",\n                      input_max_range.dims()));\n      OP_REQUIRES(ctx, input_max_range.dim_size(0) == num_slices,\n                  errors::InvalidArgument(\n                      \"If axis is specified, max_range must be a 1-D tensor \"\n                      \"whose size matches the axis dimension of the input and \"\n                      \"output tensors, but max_range is a 1-D tensor of size \",\n                      input_max_range.dim_size(0),\n                      \" and input's axis dimension is of size \", num_slices));\n    } else {\n      OP_REQUIRES(ctx, input_min_range.NumElements() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is not specified, min_range must contain a \"\n                      \"single float element, but it contains \",\n                      input_min_range.NumElements(), \" elements\"));\n      OP_REQUIRES(ctx, input_max_range.NumElements() == 1,\n                  errors::InvalidArgument(\n                      \"If axis is not specified, max_range must contain a \"\n                      \"single float element, but it contains \",\n                      input_max_range.NumElements(), \" elements\"));\n    }\n\n    const TensorShape& minmax_shape = ctx->input(1).shape();\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    Tensor* output_min_tensor = nullptr;\n    Tensor* output_max_tensor = nullptr;\n\n    if (num_slices == 1) {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));\n      const float min_range = input_min_range.template flat<float>()(0);\n      const float max_range = input_max_range.template flat<float>()(0);\n      QuantizeTensor(ctx, input, min_range, max_range, output,\n                     output_min_tensor, output_max_tensor);\n      return;\n    }\n\n    OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                      \"Quantize with axis != -1.\"));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, minmax_shape, &output_min_tensor));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, minmax_shape, &output_max_tensor));\n\n    auto input_tensor =\n        input.template flat_inner_outer_dims<float, 3>(axis_ - 1);\n    int64_t pre_dim = 1, post_dim = 1;\n    for (int i = 0; i < axis_; ++i) {\n      pre_dim *= output->dim_size(i);\n    }\n    for (int i = axis_ + 1; i < output->dims(); ++i) {\n      post_dim *= output->dim_size(i);\n    }\n    auto output_tensor = output->template bit_casted_shaped<T, 3>(\n        {pre_dim, num_slices, post_dim});\n    auto min_ranges = input_min_range.template vec<float>();\n    auto max_ranges = input_max_range.template vec<float>();\n    for (int i = 0; i < num_slices; ++i) {\n      QuantizeSlice(ctx->eigen_device<Device>(), ctx,\n                    input_tensor.template chip<1>(i), min_ranges(i),\n                    max_ranges(i), output_tensor.template chip<1>(i),\n                    &output_min_tensor->flat<float>()(i),\n                    &output_max_tensor->flat<float>()(i));\n    }\n  }\n\n  void QuantizeTensor(OpKernelContext* ctx, const Tensor& input,\n                      const float input_min_range, const float input_max_range,\n                      Tensor* output, Tensor* output_min_tensor,\n                      Tensor* output_max_tensor) {\n    OP_REQUIRES(ctx, !(input_max_range < input_min_range),\n                errors::InvalidArgument(\n                    \"input_max_range must be larger than input_min_range.\"));\n\n    // When the minimum and maximum ranges are too close together, nudge them\n    // apart by a small value so that they are slightly different. This helps\n    // us avoid creating ill-formed buffers where all quantized values map to\n    // the same float number. These kinds of buffers cause problems for\n    // downstream ops when they need to do calculations on them.\n    // We pick the value by making sure that zero is not more than 100x the\n    // overall range from the maximum, so that the value can be easily\n    // represented when we promote the quantized value to a higher\n    // intermediate bit depth, since that's a common requirement.\n    float min_range = std::min(0.0f, input_min_range);\n    const float epsilon = std::max(1.0f, std::max(fabsf(input_min_range),\n                                                  fabsf(input_max_range))) *\n                          ensure_minimum_range_;\n    float max_range =\n        std::max(0.0f, std::max(input_max_range, min_range + epsilon));\n\n    if (mode_ == QUANTIZE_MODE_MIN_FIRST) {\n      if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n        TTypes<const float>::Vec input_array = input.flat<float>();\n\n        meta::Quantize(ctx, input_array.data(), input_array.size(), min_range,\n                       max_range, output->flat<quint8>().data());\n      } else {\n        FloatTensorToQuantizedInPlaceUsingEigen<T>(\n            ctx->template eigen_device<Device>(), input, min_range, max_range,\n            output);\n      }\n      output_min_tensor->flat<float>()(0) = min_range;\n      output_max_tensor->flat<float>()(0) = max_range;\n    } else {\n      QuantizeSlice(ctx->eigen_device<Device>(), ctx, input.flat<float>(),\n                    input_min_range, input_max_range,\n                    output->template flat<T>(),\n                    &output_min_tensor->flat<float>()(0),\n                    &output_max_tensor->flat<float>()(0));\n    }\n  }\n\n  template <typename ConstVec, typename Vec>\n  void QuantizeSlice(const Device& d, OpKernelContext* ctx,\n                     const ConstVec& input, float input_min_range,\n                     float input_max_range, Vec output, float* output_min_range,\n                     float* output_max_range) {\n    OP_REQUIRES(ctx, !(input_max_range < input_min_range),\n                errors::InvalidArgument(\n                    \"input_max_range must be larger than input_min_range.\"));\n    float min_range = std::min(0.0f, input_min_range);\n    const float epsilon = std::max(1.0f, std::max(fabsf(input_min_range),\n                                                  fabsf(input_max_range))) *\n                          ensure_minimum_range_;\n    float max_range =\n        std::max(0.0f, std::max(input_max_range, min_range + epsilon));\n\n    if (mode_ == QUANTIZE_MODE_MIN_COMBINED) {\n      const float scale_factor =\n          (static_cast<double>(std::numeric_limits<T>::max()) -\n           static_cast<double>(std::numeric_limits<T>::min())) /\n          (max_range - min_range);\n\n      // Quantize:\n      // Make input in range of [min_range, max_range], then\n      // subtract min_range to be in range of [0, max_range - min_range]\n      // Divide by (max_range - min_range) to get to [0, 1.0]\n      // Multiply by range of T, after that shift left 1/2 range of T if\n      // T is signed.\n      // Note that the number is rounded before the cast. Rounding follows the\n      // semantic of std::round, which implements \"round-half-away-zero\",\n      // e.g., -5.5 gets rounded to -6, -5.4 goes to -5, 5.4 goes to 5,\n      // and 5.5 goes to 6.\n      bool is_signed = std::is_signed<T>::value;\n      if (is_signed) {\n        // The slow path.\n        // TODO(xbing,yonghui): Speedup this path as well.\n        output.device(d) =\n            ((input.cwiseMin(max_range).cwiseMax(min_range) - min_range) *\n                 scale_factor -\n             half_range_)\n                .round()\n                .template cast<T>();\n      } else {\n        // The fast path that avoids unaryExpr\n        // According to the micro-benchmark, adding device here doesn't help.\n        output.device(d) =\n            ((input.cwiseMin(max_range).cwiseMax(min_range) - min_range) *\n                 scale_factor +\n             0.5f)\n                .template cast<T>();\n      }\n    } else if (mode_ == QUANTIZE_MODE_SCALED) {\n      const int min_output_value =\n          std::numeric_limits<T>::min() + (narrow_range_ ? 1 : 0);\n      const int max_output_value = std::numeric_limits<T>::max();\n      const float scale_factor_from_min_side =\n          (min_output_value * min_range > 0)\n              ? min_output_value / min_range\n              : std::numeric_limits<float>::max();\n      const float scale_factor_from_max_side =\n          (max_output_value * max_range > 0)\n              ? max_output_value / max_range\n              : std::numeric_limits<float>::max();\n      const float scale_factor =\n          std::min(scale_factor_from_min_side, scale_factor_from_max_side);\n      min_range = min_output_value / scale_factor;\n      max_range = max_output_value / scale_factor;\n      if (round_mode_ == ROUND_HALF_TO_EVEN) {\n        output.device(d) =\n            (input.cwiseMin(max_range).cwiseMax(min_range) * scale_factor)\n                .unaryExpr(\n                    Eigen::internal::scalar_round_half_to_even_op<float>())\n                .template cast<T>();\n      } else if (round_mode_ == ROUND_HALF_AWAY_FROM_ZERO) {\n        output.device(d) =\n            (input.cwiseMin(max_range).cwiseMax(min_range) * scale_factor)\n                .round()\n                .template cast<T>();\n      }\n    }\n\n    *output_min_range = min_range;\n    *output_max_range = max_range;\n  }\n\n private:\n  float half_range_;\n  float ensure_minimum_range_;\n  int mode_;\n  int round_mode_;\n  int axis_;\n  bool narrow_range_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<quint8>(\"T\"),\n    QuantizeV2Op<CPUDevice, quint8>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<qint8>(\"T\"),\n    QuantizeV2Op<CPUDevice, qint8>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<quint16>(\"T\"),\n    QuantizeV2Op<CPUDevice, quint16>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<qint16>(\"T\"),\n    QuantizeV2Op<CPUDevice, qint16>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"QuantizeV2\").Device(DEVICE_CPU).TypeConstraint<qint32>(\"T\"),\n    QuantizeV2Op<CPUDevice, qint32>);\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/quantize_op.cc"], "buggy_code_start_loc": [115], "buggy_code_end_loc": [116], "fixing_code_start_loc": [116], "fixing_code_end_loc": [160], "type": "CWE-20", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37663", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T23:15:07.233", "lastModified": "2021-08-19T14:41:25.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;En las versiones afectadas debido a una comprobaci\u00f3n incompleta en \"tf.raw_ops.QuantizeV2\", un atacante puede desencadenar un comportamiento indefinido vinculando una referencia a un puntero null o puede acceder a datos fuera de l\u00edmites de las matrices asignadas a la pila.&#xa0;La [implementaci\u00f3n] (https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) presenta alguna comprobaci\u00f3n, pero no comprueba que \"min_range\" y\" max_range\" tengan el mismo n\u00famero de elementos distinto de cero.&#xa0;Si se proporciona \"axis\" (es decir, no\" -1\"), entonces la comprobaci\u00f3n debe verificar que sea un valor en el rango para el rango del tensor de \"input\" y luego las longitudes de las entradas de\" min_range\" y \"max_range\" coincidan con las Dimensi\u00f3n \"axis\" del tensor\" input\".&#xa0;Hemos solucionado el problema en GitHub commit 6da6620efad397c85493b8f8667b821403516708.&#xa0;La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3 y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan se encuentran en el rango admitido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/6da6620efad397c85493b8f8667b821403516708", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-g25h-jr74-qp5j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/6da6620efad397c85493b8f8667b821403516708"}}