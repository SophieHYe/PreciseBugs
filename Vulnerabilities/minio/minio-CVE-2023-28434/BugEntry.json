{"buggy_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"compress/gzip\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/klauspost/compress/gzhttp\"\n\t\"github.com/minio/console/restapi\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/mux\"\n\t\"github.com/minio/pkg/wildcard\"\n\t\"github.com/rs/cors\"\n)\n\nfunc newHTTPServerFn() *xhttp.Server {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalHTTPServer\n}\n\nfunc setHTTPServer(h *xhttp.Server) {\n\tglobalObjLayerMutex.Lock()\n\tglobalHTTPServer = h\n\tglobalObjLayerMutex.Unlock()\n}\n\nfunc newConsoleServerFn() *restapi.Server {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalConsoleSrv\n}\n\nfunc setConsoleSrv(srv *restapi.Server) {\n\tglobalObjLayerMutex.Lock()\n\tglobalConsoleSrv = srv\n\tglobalObjLayerMutex.Unlock()\n}\n\nfunc newObjectLayerFn() ObjectLayer {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalObjectAPI\n}\n\nfunc newCachedObjectLayerFn() CacheObjectLayer {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalCacheObjectAPI\n}\n\nfunc setCacheObjectLayer(c CacheObjectLayer) {\n\tglobalObjLayerMutex.Lock()\n\tglobalCacheObjectAPI = c\n\tglobalObjLayerMutex.Unlock()\n}\n\nfunc setObjectLayer(o ObjectLayer) {\n\tglobalObjLayerMutex.Lock()\n\tglobalObjectAPI = o\n\tglobalObjLayerMutex.Unlock()\n}\n\n// objectAPIHandler implements and provides http handlers for S3 API.\ntype objectAPIHandlers struct {\n\tObjectAPI func() ObjectLayer\n\tCacheAPI  func() CacheObjectLayer\n}\n\n// getHost tries its best to return the request host.\n// According to section 14.23 of RFC 2616 the Host header\n// can include the port number if the default value of 80 is not used.\nfunc getHost(r *http.Request) string {\n\tif r.URL.IsAbs() {\n\t\treturn r.URL.Host\n\t}\n\treturn r.Host\n}\n\nfunc notImplementedHandler(w http.ResponseWriter, r *http.Request) {\n\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrNotImplemented), r.URL)\n}\n\ntype rejectedAPI struct {\n\tapi     string\n\tmethods []string\n\tqueries []string\n\tpath    string\n}\n\nvar rejectedObjAPIs = []rejectedAPI{\n\t{\n\t\tapi:     \"torrent\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete, http.MethodGet},\n\t\tqueries: []string{\"torrent\", \"\"},\n\t\tpath:    \"/{object:.+}\",\n\t},\n\t{\n\t\tapi:     \"acl\",\n\t\tmethods: []string{http.MethodDelete},\n\t\tqueries: []string{\"acl\", \"\"},\n\t\tpath:    \"/{object:.+}\",\n\t},\n}\n\nvar rejectedBucketAPIs = []rejectedAPI{\n\t{\n\t\tapi:     \"inventory\",\n\t\tmethods: []string{http.MethodGet, http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"inventory\", \"\"},\n\t},\n\t{\n\t\tapi:     \"cors\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"cors\", \"\"},\n\t},\n\t{\n\t\tapi:     \"metrics\",\n\t\tmethods: []string{http.MethodGet, http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"metrics\", \"\"},\n\t},\n\t{\n\t\tapi:     \"website\",\n\t\tmethods: []string{http.MethodPut},\n\t\tqueries: []string{\"website\", \"\"},\n\t},\n\t{\n\t\tapi:     \"logging\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"logging\", \"\"},\n\t},\n\t{\n\t\tapi:     \"accelerate\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"accelerate\", \"\"},\n\t},\n\t{\n\t\tapi:     \"requestPayment\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"requestPayment\", \"\"},\n\t},\n\t{\n\t\tapi:     \"acl\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodHead},\n\t\tqueries: []string{\"acl\", \"\"},\n\t},\n\t{\n\t\tapi:     \"publicAccessBlock\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"publicAccessBlock\", \"\"},\n\t},\n\t{\n\t\tapi:     \"ownershipControls\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"ownershipControls\", \"\"},\n\t},\n\t{\n\t\tapi:     \"intelligent-tiering\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"intelligent-tiering\", \"\"},\n\t},\n\t{\n\t\tapi:     \"analytics\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"analytics\", \"\"},\n\t},\n}\n\n// registerAPIRouter - registers S3 compatible APIs.\nfunc registerAPIRouter(router *mux.Router) {\n\t// Initialize API.\n\tapi := objectAPIHandlers{\n\t\tObjectAPI: newObjectLayerFn,\n\t\tCacheAPI:  newCachedObjectLayerFn,\n\t}\n\n\t// API Router\n\tapiRouter := router.PathPrefix(SlashSeparator).Subrouter()\n\n\tvar routers []*mux.Router\n\tfor _, domainName := range globalDomainNames {\n\t\tif IsKubernetes() {\n\t\t\trouters = append(routers, apiRouter.MatcherFunc(func(r *http.Request, match *mux.RouteMatch) bool {\n\t\t\t\thost, _, err := net.SplitHostPort(getHost(r))\n\t\t\t\tif err != nil {\n\t\t\t\t\thost = r.Host\n\t\t\t\t}\n\t\t\t\t// Make sure to skip matching minio.<domain>` this is\n\t\t\t\t// specifically meant for operator/k8s deployment\n\t\t\t\t// The reason we need to skip this is for a special\n\t\t\t\t// usecase where we need to make sure that\n\t\t\t\t// minio.<namespace>.svc.<cluster_domain> is ignored\n\t\t\t\t// by the bucketDNS style to ensure that path style\n\t\t\t\t// is available and honored at this domain.\n\t\t\t\t//\n\t\t\t\t// All other `<bucket>.<namespace>.svc.<cluster_domain>`\n\t\t\t\t// makes sure that buckets are routed through this matcher\n\t\t\t\t// to match for `<bucket>`\n\t\t\t\treturn host != minioReservedBucket+\".\"+domainName\n\t\t\t}).Host(\"{bucket:.+}.\"+domainName).Subrouter())\n\t\t} else {\n\t\t\trouters = append(routers, apiRouter.Host(\"{bucket:.+}.\"+domainName).Subrouter())\n\t\t}\n\t}\n\trouters = append(routers, apiRouter.PathPrefix(\"/{bucket}\").Subrouter())\n\n\tgz, err := gzhttp.NewWrapper(gzhttp.MinSize(1000), gzhttp.CompressionLevel(gzip.BestSpeed))\n\tif err != nil {\n\t\t// Static params, so this is very unlikely.\n\t\tlogger.Fatal(err, \"Unable to initialize server\")\n\t}\n\n\tfor _, router := range routers {\n\t\t// Register all rejected object APIs\n\t\tfor _, r := range rejectedObjAPIs {\n\t\t\tt := router.Methods(r.methods...).\n\t\t\t\tHandlerFunc(collectAPIStats(r.api, httpTraceAll(notImplementedHandler))).\n\t\t\t\tQueries(r.queries...)\n\t\t\tt.Path(r.path)\n\t\t}\n\n\t\t// Object operations\n\t\t// HeadObject\n\t\trouter.Methods(http.MethodHead).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"headobject\", maxClients(gz(httpTraceAll(api.HeadObjectHandler)))))\n\t\t// CopyObjectPart\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").\n\t\t\tHeadersRegexp(xhttp.AmzCopySource, \".*?(\\\\/|%2F).*?\").\n\t\t\tHandlerFunc(collectAPIStats(\"copyobjectpart\", maxClients(gz(httpTraceAll(api.CopyObjectPartHandler))))).\n\t\t\tQueries(\"partNumber\", \"{partNumber:[0-9]+}\", \"uploadId\", \"{uploadId:.*}\")\n\t\t// PutObjectPart\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectpart\", maxClients(gz(httpTraceHdrs(api.PutObjectPartHandler))))).Queries(\"partNumber\", \"{partNumber:[0-9]+}\", \"uploadId\", \"{uploadId:.*}\")\n\t\t// ListObjectParts\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectparts\", maxClients(gz(httpTraceAll(api.ListObjectPartsHandler))))).Queries(\"uploadId\", \"{uploadId:.*}\")\n\t\t// CompleteMultipartUpload\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"completemultipartupload\", maxClients(gz(httpTraceAll(api.CompleteMultipartUploadHandler))))).Queries(\"uploadId\", \"{uploadId:.*}\")\n\t\t// NewMultipartUpload\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"newmultipartupload\", maxClients(gz(httpTraceAll(api.NewMultipartUploadHandler))))).Queries(\"uploads\", \"\")\n\t\t// AbortMultipartUpload\n\t\trouter.Methods(http.MethodDelete).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"abortmultipartupload\", maxClients(gz(httpTraceAll(api.AbortMultipartUploadHandler))))).Queries(\"uploadId\", \"{uploadId:.*}\")\n\t\t// GetObjectACL - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjectacl\", maxClients(gz(httpTraceHdrs(api.GetObjectACLHandler))))).Queries(\"acl\", \"\")\n\t\t// PutObjectACL - this is a dummy call.\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectacl\", maxClients(gz(httpTraceHdrs(api.PutObjectACLHandler))))).Queries(\"acl\", \"\")\n\t\t// GetObjectTagging\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjecttagging\", maxClients(gz(httpTraceHdrs(api.GetObjectTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// PutObjectTagging\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjecttagging\", maxClients(gz(httpTraceHdrs(api.PutObjectTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// DeleteObjectTagging\n\t\trouter.Methods(http.MethodDelete).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"deleteobjecttagging\", maxClients(gz(httpTraceHdrs(api.DeleteObjectTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// SelectObjectContent\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"selectobjectcontent\", maxClients(gz(httpTraceHdrs(api.SelectObjectContentHandler))))).Queries(\"select\", \"\").Queries(\"select-type\", \"2\")\n\t\t// GetObjectRetention\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjectretention\", maxClients(gz(httpTraceAll(api.GetObjectRetentionHandler))))).Queries(\"retention\", \"\")\n\t\t// GetObjectLegalHold\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjectlegalhold\", maxClients(gz(httpTraceAll(api.GetObjectLegalHoldHandler))))).Queries(\"legal-hold\", \"\")\n\t\t// GetObject with lambda ARNs\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobject\", maxClients(gz(httpTraceHdrs(api.GetObjectLambdaHandler))))).Queries(\"lambdaArn\", \"{lambdaArn:.*}\")\n\t\t// GetObject\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobject\", maxClients(gz(httpTraceHdrs(api.GetObjectHandler)))))\n\t\t// CopyObject\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HeadersRegexp(xhttp.AmzCopySource, \".*?(\\\\/|%2F).*?\").HandlerFunc(\n\t\t\tcollectAPIStats(\"copyobject\", maxClients(gz(httpTraceAll(api.CopyObjectHandler)))))\n\t\t// PutObjectRetention\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectretention\", maxClients(gz(httpTraceAll(api.PutObjectRetentionHandler))))).Queries(\"retention\", \"\")\n\t\t// PutObjectLegalHold\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectlegalhold\", maxClients(gz(httpTraceAll(api.PutObjectLegalHoldHandler))))).Queries(\"legal-hold\", \"\")\n\n\t\t// PutObject with auto-extract support for zip\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HeadersRegexp(xhttp.AmzSnowballExtract, \"true\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobject\", maxClients(gz(httpTraceHdrs(api.PutObjectExtractHandler)))))\n\n\t\t// PutObject\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobject\", maxClients(gz(httpTraceHdrs(api.PutObjectHandler)))))\n\n\t\t// DeleteObject\n\t\trouter.Methods(http.MethodDelete).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"deleteobject\", maxClients(gz(httpTraceAll(api.DeleteObjectHandler)))))\n\n\t\t// PostRestoreObject\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"restoreobject\", maxClients(gz(httpTraceAll(api.PostRestoreObjectHandler))))).Queries(\"restore\", \"\")\n\n\t\t// Bucket operations\n\n\t\t// GetBucketLocation\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketlocation\", maxClients(gz(httpTraceAll(api.GetBucketLocationHandler))))).Queries(\"location\", \"\")\n\t\t// GetBucketPolicy\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketpolicy\", maxClients(gz(httpTraceAll(api.GetBucketPolicyHandler))))).Queries(\"policy\", \"\")\n\t\t// GetBucketLifecycle\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketlifecycle\", maxClients(gz(httpTraceAll(api.GetBucketLifecycleHandler))))).Queries(\"lifecycle\", \"\")\n\t\t// GetBucketEncryption\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketencryption\", maxClients(gz(httpTraceAll(api.GetBucketEncryptionHandler))))).Queries(\"encryption\", \"\")\n\t\t// GetBucketObjectLockConfig\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketobjectlockconfiguration\", maxClients(gz(httpTraceAll(api.GetBucketObjectLockConfigHandler))))).Queries(\"object-lock\", \"\")\n\t\t// GetBucketReplicationConfig\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketreplicationconfiguration\", maxClients(gz(httpTraceAll(api.GetBucketReplicationConfigHandler))))).Queries(\"replication\", \"\")\n\t\t// GetBucketVersioning\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketversioning\", maxClients(gz(httpTraceAll(api.GetBucketVersioningHandler))))).Queries(\"versioning\", \"\")\n\t\t// GetBucketNotification\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketnotification\", maxClients(gz(httpTraceAll(api.GetBucketNotificationHandler))))).Queries(\"notification\", \"\")\n\t\t// ListenNotification\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listennotification\", gz(httpTraceAll(api.ListenNotificationHandler)))).Queries(\"events\", \"{events:.*}\")\n\t\t// ResetBucketReplicationStatus - MinIO extension API\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"resetbucketreplicationstatus\", maxClients(gz(httpTraceAll(api.ResetBucketReplicationStatusHandler))))).Queries(\"replication-reset-status\", \"\")\n\n\t\t// Dummy Bucket Calls\n\t\t// GetBucketACL -- this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketacl\", maxClients(gz(httpTraceAll(api.GetBucketACLHandler))))).Queries(\"acl\", \"\")\n\t\t// PutBucketACL -- this is a dummy call.\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketacl\", maxClients(gz(httpTraceAll(api.PutBucketACLHandler))))).Queries(\"acl\", \"\")\n\t\t// GetBucketCors - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketcors\", maxClients(gz(httpTraceAll(api.GetBucketCorsHandler))))).Queries(\"cors\", \"\")\n\t\t// GetBucketWebsiteHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketwebsite\", maxClients(gz(httpTraceAll(api.GetBucketWebsiteHandler))))).Queries(\"website\", \"\")\n\t\t// GetBucketAccelerateHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketaccelerate\", maxClients(gz(httpTraceAll(api.GetBucketAccelerateHandler))))).Queries(\"accelerate\", \"\")\n\t\t// GetBucketRequestPaymentHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketrequestpayment\", maxClients(gz(httpTraceAll(api.GetBucketRequestPaymentHandler))))).Queries(\"requestPayment\", \"\")\n\t\t// GetBucketLoggingHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketlogging\", maxClients(gz(httpTraceAll(api.GetBucketLoggingHandler))))).Queries(\"logging\", \"\")\n\t\t// GetBucketTaggingHandler\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbuckettagging\", maxClients(gz(httpTraceAll(api.GetBucketTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// DeleteBucketWebsiteHandler\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketwebsite\", maxClients(gz(httpTraceAll(api.DeleteBucketWebsiteHandler))))).Queries(\"website\", \"\")\n\t\t// DeleteBucketTaggingHandler\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebuckettagging\", maxClients(gz(httpTraceAll(api.DeleteBucketTaggingHandler))))).Queries(\"tagging\", \"\")\n\n\t\t// ListMultipartUploads\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listmultipartuploads\", maxClients(gz(httpTraceAll(api.ListMultipartUploadsHandler))))).Queries(\"uploads\", \"\")\n\t\t// ListObjectsV2M\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectsv2M\", maxClients(gz(httpTraceAll(api.ListObjectsV2MHandler))))).Queries(\"list-type\", \"2\", \"metadata\", \"true\")\n\t\t// ListObjectsV2\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectsv2\", maxClients(gz(httpTraceAll(api.ListObjectsV2Handler))))).Queries(\"list-type\", \"2\")\n\t\t// ListObjectVersions\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectversions\", maxClients(gz(httpTraceAll(api.ListObjectVersionsHandler))))).Queries(\"versions\", \"\")\n\t\t// GetBucketPolicyStatus\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getpolicystatus\", maxClients(gz(httpTraceAll(api.GetBucketPolicyStatusHandler))))).Queries(\"policyStatus\", \"\")\n\t\t// PutBucketLifecycle\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketlifecycle\", maxClients(gz(httpTraceAll(api.PutBucketLifecycleHandler))))).Queries(\"lifecycle\", \"\")\n\t\t// PutBucketReplicationConfig\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketreplicationconfiguration\", maxClients(gz(httpTraceAll(api.PutBucketReplicationConfigHandler))))).Queries(\"replication\", \"\")\n\t\t// PutBucketEncryption\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketencryption\", maxClients(gz(httpTraceAll(api.PutBucketEncryptionHandler))))).Queries(\"encryption\", \"\")\n\n\t\t// PutBucketPolicy\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketpolicy\", maxClients(gz(httpTraceAll(api.PutBucketPolicyHandler))))).Queries(\"policy\", \"\")\n\n\t\t// PutBucketObjectLockConfig\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketobjectlockconfig\", maxClients(gz(httpTraceAll(api.PutBucketObjectLockConfigHandler))))).Queries(\"object-lock\", \"\")\n\t\t// PutBucketTaggingHandler\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbuckettagging\", maxClients(gz(httpTraceAll(api.PutBucketTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// PutBucketVersioning\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketversioning\", maxClients(gz(httpTraceAll(api.PutBucketVersioningHandler))))).Queries(\"versioning\", \"\")\n\t\t// PutBucketNotification\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketnotification\", maxClients(gz(httpTraceAll(api.PutBucketNotificationHandler))))).Queries(\"notification\", \"\")\n\t\t// ResetBucketReplicationStart - MinIO extension API\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"resetbucketreplicationstart\", maxClients(gz(httpTraceAll(api.ResetBucketReplicationStartHandler))))).Queries(\"replication-reset\", \"\")\n\n\t\t// PutBucket\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucket\", maxClients(gz(httpTraceAll(api.PutBucketHandler)))))\n\t\t// HeadBucket\n\t\trouter.Methods(http.MethodHead).HandlerFunc(\n\t\t\tcollectAPIStats(\"headbucket\", maxClients(gz(httpTraceAll(api.HeadBucketHandler)))))\n\t\t// PostPolicy\n\t\trouter.Methods(http.MethodPost).HeadersRegexp(xhttp.ContentType, \"multipart/form-data*\").HandlerFunc(\n\t\t\tcollectAPIStats(\"postpolicybucket\", maxClients(gz(httpTraceHdrs(api.PostPolicyBucketHandler)))))\n\t\t// DeleteMultipleObjects\n\t\trouter.Methods(http.MethodPost).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletemultipleobjects\", maxClients(gz(httpTraceAll(api.DeleteMultipleObjectsHandler))))).Queries(\"delete\", \"\")\n\t\t// DeleteBucketPolicy\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketpolicy\", maxClients(gz(httpTraceAll(api.DeleteBucketPolicyHandler))))).Queries(\"policy\", \"\")\n\t\t// DeleteBucketReplication\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketreplicationconfiguration\", maxClients(gz(httpTraceAll(api.DeleteBucketReplicationConfigHandler))))).Queries(\"replication\", \"\")\n\t\t// DeleteBucketLifecycle\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketlifecycle\", maxClients(gz(httpTraceAll(api.DeleteBucketLifecycleHandler))))).Queries(\"lifecycle\", \"\")\n\t\t// DeleteBucketEncryption\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketencryption\", maxClients(gz(httpTraceAll(api.DeleteBucketEncryptionHandler))))).Queries(\"encryption\", \"\")\n\t\t// DeleteBucket\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucket\", maxClients(gz(httpTraceAll(api.DeleteBucketHandler)))))\n\n\t\t// MinIO extension API for replication.\n\t\t//\n\t\t// GetBucketReplicationMetrics\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketreplicationmetrics\", maxClients(gz(httpTraceAll(api.GetBucketReplicationMetricsHandler))))).Queries(\"replication-metrics\", \"\")\n\n\t\t// Register rejected bucket APIs\n\t\tfor _, r := range rejectedBucketAPIs {\n\t\t\trouter.Methods(r.methods...).\n\t\t\t\tHandlerFunc(collectAPIStats(r.api, httpTraceAll(notImplementedHandler))).\n\t\t\t\tQueries(r.queries...)\n\t\t}\n\n\t\t// S3 ListObjectsV1 (Legacy)\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectsv1\", maxClients(gz(httpTraceAll(api.ListObjectsV1Handler)))))\n\t}\n\n\t// Root operation\n\n\t// ListenNotification\n\tapiRouter.Methods(http.MethodGet).Path(SlashSeparator).HandlerFunc(\n\t\tcollectAPIStats(\"listennotification\", gz(httpTraceAll(api.ListenNotificationHandler)))).Queries(\"events\", \"{events:.*}\")\n\n\t// ListBuckets\n\tapiRouter.Methods(http.MethodGet).Path(SlashSeparator).HandlerFunc(\n\t\tcollectAPIStats(\"listbuckets\", maxClients(gz(httpTraceAll(api.ListBucketsHandler)))))\n\n\t// S3 browser with signature v4 adds '//' for ListBuckets request, so rather\n\t// than failing with UnknownAPIRequest we simply handle it for now.\n\tapiRouter.Methods(http.MethodGet).Path(SlashSeparator + SlashSeparator).HandlerFunc(\n\t\tcollectAPIStats(\"listbuckets\", maxClients(gz(httpTraceAll(api.ListBucketsHandler)))))\n\n\t// If none of the routes match add default error handler routes\n\tapiRouter.NotFoundHandler = collectAPIStats(\"notfound\", httpTraceAll(errorResponseHandler))\n\tapiRouter.MethodNotAllowedHandler = collectAPIStats(\"methodnotallowed\", httpTraceAll(methodNotAllowedHandler(\"S3\")))\n}\n\n// corsHandler handler for CORS (Cross Origin Resource Sharing)\nfunc corsHandler(handler http.Handler) http.Handler {\n\tcommonS3Headers := []string{\n\t\txhttp.Date,\n\t\txhttp.ETag,\n\t\txhttp.ServerInfo,\n\t\txhttp.Connection,\n\t\txhttp.AcceptRanges,\n\t\txhttp.ContentRange,\n\t\txhttp.ContentEncoding,\n\t\txhttp.ContentLength,\n\t\txhttp.ContentType,\n\t\txhttp.ContentDisposition,\n\t\txhttp.LastModified,\n\t\txhttp.ContentLanguage,\n\t\txhttp.CacheControl,\n\t\txhttp.RetryAfter,\n\t\txhttp.AmzBucketRegion,\n\t\txhttp.Expires,\n\t\t\"X-Amz*\",\n\t\t\"x-amz*\",\n\t\t\"*\",\n\t}\n\n\treturn cors.New(cors.Options{\n\t\tAllowOriginFunc: func(origin string) bool {\n\t\t\tallowedOrigins := globalAPIConfig.getCorsAllowOrigins()\n\t\t\tif len(allowedOrigins) == 0 {\n\t\t\t\tallowedOrigins = []string{\"*\"}\n\t\t\t}\n\t\t\tfor _, allowedOrigin := range allowedOrigins {\n\t\t\t\tif wildcard.MatchSimple(allowedOrigin, origin) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t},\n\t\tAllowedMethods: []string{\n\t\t\thttp.MethodGet,\n\t\t\thttp.MethodPut,\n\t\t\thttp.MethodHead,\n\t\t\thttp.MethodPost,\n\t\t\thttp.MethodDelete,\n\t\t\thttp.MethodOptions,\n\t\t\thttp.MethodPatch,\n\t\t},\n\t\tAllowedHeaders:   commonS3Headers,\n\t\tExposedHeaders:   commonS3Headers,\n\t\tAllowCredentials: true,\n\t}).Handler(handler)\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\tobjectlock \"github.com/minio/minio/internal/bucket/object/lock\"\n\t\"github.com/minio/minio/internal/etag\"\n\t\"github.com/minio/minio/internal/hash\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\txjwt \"github.com/minio/minio/internal/jwt\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/minio/internal/mcontext\"\n\t\"github.com/minio/pkg/bucket/policy\"\n\tiampolicy \"github.com/minio/pkg/iam/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(xhttp.Authorization), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzCredential]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzAccessKeyID]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\treturn strings.Contains(r.Header.Get(xhttp.ContentType), \"multipart/form-data\") &&\n\t\tr.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Authorization type.\n//\n//go:generate stringer -type=authType -trimprefix=authType $GOFILE\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n\tauthTypeSTS\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) authType {\n\tif r.URL != nil {\n\t\tvar err error\n\t\tr.Form, err = url.ParseQuery(r.URL.RawQuery)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(r.Context(), err)\n\t\t\treturn authTypeUnknown\n\t\t}\n\t}\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.Form[xhttp.Action]; ok {\n\t\treturn authTypeSTS\n\t} else if _, ok := r.Header[xhttp.Authorization]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\nfunc validateAdminSignature(ctx context.Context, r *http.Request, region string) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\ts3Err := ErrAccessDenied\n\tif _, ok := r.Header[xhttp.AmzContentSha256]; ok &&\n\t\tgetRequestAuthType(r) == authTypeSigned {\n\t\t// We only support admin credentials to access admin APIs.\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t\tif s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\n\t\t// we only support V4 (no presign) with auth body\n\t\ts3Err = isReqAuthenticated(ctx, r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\treturn cred, owner, ErrNone\n}\n\n// checkAdminRequestAuth checks for authentication and authorization for the incoming\n// request. It only accepts V2 and V4 requests. Presigned, JWT and anonymous requests\n// are automatically rejected.\nfunc checkAdminRequestAuth(ctx context.Context, r *http.Request, action iampolicy.AdminAction, region string) (auth.Credentials, APIErrorCode) {\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, region)\n\tif s3Err != ErrNone {\n\t\treturn cred, s3Err\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.Action(action),\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred, ErrNone\n\t}\n\n\treturn cred, ErrAccessDenied\n}\n\n// Fetch the security token set by the client.\nfunc getSessionToken(r *http.Request) (token string) {\n\ttoken = r.Header.Get(xhttp.AmzSecurityToken)\n\tif token != \"\" {\n\t\treturn token\n\t}\n\treturn r.Form.Get(xhttp.AmzSecurityToken)\n}\n\n// Fetch claims in the security token returned by the client, doesn't return\n// errors - upon errors the returned claims map will be empty.\nfunc mustGetClaimsFromToken(r *http.Request) map[string]interface{} {\n\tclaims, _ := getClaimsFromToken(getSessionToken(r))\n\treturn claims\n}\n\nfunc getClaimsFromTokenWithSecret(token, secret string) (map[string]interface{}, error) {\n\t// JWT token for x-amz-security-token is signed with admin\n\t// secret key, temporary credentials become invalid if\n\t// server admin credentials change. This is done to ensure\n\t// that clients cannot decode the token using the temp\n\t// secret keys and generate an entirely new claim by essentially\n\t// hijacking the policies. We need to make sure that this is\n\t// based on admin credential such that token cannot be decoded\n\t// on the client side and is treated like an opaque value.\n\tclaims, err := auth.ExtractClaims(token, secret)\n\tif err != nil {\n\t\tif subtle.ConstantTimeCompare([]byte(secret), []byte(globalActiveCred.SecretKey)) == 1 {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims, err = auth.ExtractClaims(token, globalActiveCred.SecretKey)\n\t\tif err != nil {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t}\n\n\t// If AuthZPlugin is set, return without any further checks.\n\tif newGlobalAuthZPluginFn() != nil {\n\t\treturn claims.Map(), nil\n\t}\n\n\t// Check if a session policy is set. If so, decode it here.\n\tsp, spok := claims.Lookup(iampolicy.SessionPolicyName)\n\tif spok {\n\t\t// Looks like subpolicy is set and is a string, if set then its\n\t\t// base64 encoded, decode it. Decoding fails reject such\n\t\t// requests.\n\t\tspBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\t// Base64 decoding fails, we should log to indicate\n\t\t\t// something is malforming the request sent by client.\n\t\t\tlogger.LogIf(GlobalContext, err, logger.Application)\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims.MapClaims[sessionPolicyNameExtracted] = string(spBytes)\n\t}\n\n\treturn claims.Map(), nil\n}\n\n// Fetch claims in the security token returned by the client.\nfunc getClaimsFromToken(token string) (map[string]interface{}, error) {\n\treturn getClaimsFromTokenWithSecret(token, globalActiveCred.SecretKey)\n}\n\n// Fetch claims in the security token returned by the client and validate the token.\nfunc checkClaimsFromToken(r *http.Request, cred auth.Credentials) (map[string]interface{}, APIErrorCode) {\n\ttoken := getSessionToken(r)\n\tif token != \"\" && cred.AccessKey == \"\" {\n\t\t// x-amz-security-token is not allowed for anonymous access.\n\t\treturn nil, ErrNoAccessKey\n\t}\n\n\tif token == \"\" && cred.IsTemp() && !cred.IsServiceAccount() {\n\t\t// Temporary credentials should always have x-amz-security-token\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif token != \"\" && !cred.IsTemp() {\n\t\t// x-amz-security-token should not present for static credentials.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif !cred.IsServiceAccount() && cred.IsTemp() && subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n\t\t// validate token for temporary credentials only.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tsecret := globalActiveCred.SecretKey\n\tif cred.IsServiceAccount() {\n\t\ttoken = cred.SessionToken\n\t\tsecret = cred.SecretKey\n\t}\n\n\tif token != \"\" {\n\t\tclaims, err := getClaimsFromTokenWithSecret(token, secret)\n\t\tif err != nil {\n\t\t\treturn nil, toAPIErrorCode(r.Context(), err)\n\t\t}\n\t\treturn claims, ErrNone\n\t}\n\n\tclaims := xjwt.NewMapClaims()\n\treturn claims.Map(), ErrNone\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\n// checkRequestAuthTypeWithVID is similar to checkRequestAuthType\n// passes versionID additionally.\nfunc checkRequestAuthTypeWithVID(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName, versionID string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\tlogger.GetReqInfo(ctx).VersionID = versionID\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\nfunc authenticateRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\tif logger.GetReqInfo(ctx) == nil {\n\t\tlogger.LogIf(ctx, errors.New(\"unexpected context.Context does not have a logger.ReqInfo\"), logger.Minio)\n\t\treturn ErrAccessDenied\n\t}\n\n\tvar cred auth.Credentials\n\tvar owner bool\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalSite.Region\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\t\tif s3Err = isReqAuthenticated(ctx, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\t// region is valid only for CreateBucketAction.\n\tvar region string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := io.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err, logger.Application)\n\t\t\treturn ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t\tregion, s3Err = parseLocationConstraint(r)\n\t\tif s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tlogger.GetReqInfo(ctx).Region = region\n\n\treturn s3Err\n}\n\nfunc authorizeRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn ErrAccessDenied\n\t}\n\n\tcred := reqInfo.Cred\n\towner := reqInfo.Owner\n\tregion := reqInfo.Region\n\tbucket := reqInfo.BucketName\n\tobject := reqInfo.ObjectName\n\tversionID := reqInfo.VersionID\n\n\tif action != policy.ListAllMyBucketsAction && cred.AccessKey == \"\" {\n\t\t// Anonymous checks are not meant for ListAllBuckets action\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      object,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\n\t\tif action == policy.ListBucketVersionsAction {\n\t\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t\t// verify as a fallback.\n\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\tGroups:          cred.Groups,\n\t\t\t\tAction:          policy.ListBucketAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\t// Request is allowed return the appropriate access key.\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t}\n\n\t\treturn ErrAccessDenied\n\t}\n\tif action == policy.DeleteObjectAction && versionID != \"\" {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.Action(policy.DeleteObjectVersionAction),\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t\tDenyOnly:        true,\n\t\t}) { // Request is not allowed if Deny action on DeleteObjectVersionAction\n\t\t\treturn ErrAccessDenied\n\t\t}\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.Action(action),\n\t\tBucketName:      bucket,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      object,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn ErrNone\n\t}\n\n\tif action == policy.ListBucketVersionsAction {\n\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t// verify as a fallback.\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\t}\n\n\treturn ErrAccessDenied\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\n// Additionally returns the accessKey used in the request, and if this request is by an admin.\nfunc checkRequestAuthTypeCredential(ctx context.Context, r *http.Request, action policy.Action) (cred auth.Credentials, owner bool, s3Err APIErrorCode) {\n\ts3Err = authenticateRequest(ctx, r, action)\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn cred, owner, ErrAccessDenied\n\t}\n\n\tcred = reqInfo.Cred\n\towner = reqInfo.Owner\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, authorizeRequest(ctx, r, action)\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r, stype)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region, stype)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region, stype)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(ctx context.Context, r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tif errCode := reqSignatureV4Verify(r, region, stype); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tclientETag, err := etag.FromContentMD5(r.Header)\n\tif err != nil {\n\t\treturn ErrInvalidDigest\n\t}\n\n\t// Extract either 'X-Amz-Content-Sha256' header or 'X-Amz-Content-Sha256' query parameter (if V4 presigned)\n\t// Do not verify 'X-Amz-Content-Sha256' if skipSHA256.\n\tvar contentSHA256 []byte\n\tif skipSHA256 := skipContentSha256Cksum(r); !skipSHA256 && isRequestPresignedSignatureV4(r) {\n\t\tif sha256Sum, ok := r.Form[xhttp.AmzContentSha256]; ok && len(sha256Sum) > 0 {\n\t\t\tcontentSHA256, err = hex.DecodeString(sha256Sum[0])\n\t\t\tif err != nil {\n\t\t\t\treturn ErrContentSHA256Mismatch\n\t\t\t}\n\t\t}\n\t} else if _, ok := r.Header[xhttp.AmzContentSha256]; !skipSHA256 && ok {\n\t\tcontentSHA256, err = hex.DecodeString(r.Header.Get(xhttp.AmzContentSha256))\n\t\tif err != nil || len(contentSHA256) == 0 {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\n\t// Verify 'Content-Md5' and/or 'X-Amz-Content-Sha256' if present.\n\t// The verification happens implicit during reading.\n\treader, err := hash.NewReader(r.Body, -1, clientETag.String(), hex.EncodeToString(contentSHA256), -1)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\tr.Body = reader\n\treturn ErrNone\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:       {},\n\tauthTypePresigned:       {},\n\tauthTypePresignedV2:     {},\n\tauthTypeSigned:          {},\n\tauthTypeSignedV2:        {},\n\tauthTypePostPolicy:      {},\n\tauthTypeStreamingSigned: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// setAuthHandler to validate authorization header for the incoming request.\nfunc setAuthHandler(h http.Handler) http.Handler {\n\t// handler for validating incoming authorization headers.\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\taType := getRequestAuthType(r)\n\t\tif aType == authTypeSigned || aType == authTypeSignedV2 || aType == authTypeStreamingSigned {\n\t\t\t// Verify if date headers are set, if not reject the request\n\t\t\tamzDate, errCode := parseAmzDateHeader(r)\n\t\t\tif errCode != ErrNone {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\t// All our internal APIs are sensitive towards Date\n\t\t\t\t// header, for all requests where Date header is not\n\t\t\t\t// present we will reject such clients.\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(errCode), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Verify if the request date header is shifted by less than globalMaxSkewTime parameter in the past\n\t\t\t// or in the future, reject request otherwise.\n\t\t\tcurTime := UTCNow()\n\t\t\tif curTime.Sub(amzDate) > globalMaxSkewTime || amzDate.Sub(curTime) > globalMaxSkewTime {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrRequestTimeTooSkewed), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif isSupportedS3AuthType(aType) || aType == authTypeJWT || aType == authTypeSTS {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif ok {\n\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t}\n\n\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrSignatureVersionNotSupported), r.URL)\n\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsAuth, 1)\n\t})\n}\n\nfunc validateSignature(atype authType, r *http.Request) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tvar s3Err APIErrorCode\n\tswitch atype {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn cred, owner, ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypePresigned, authTypeSigned:\n\t\tregion := globalSite.Region\n\t\tif s3Err = isReqAuthenticated(GlobalContext, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, ErrNone\n}\n\nfunc isPutRetentionAllowed(bucketName, objectName string, retDays int, retDate time.Time, retMode objectlock.RetMode, byPassSet bool, r *http.Request, cred auth.Credentials, owner bool) (s3Err APIErrorCode) {\n\tvar retSet bool\n\tif cred.AccessKey == \"\" {\n\t\treturn ErrAccessDenied\n\t}\n\n\tconditions := getConditionValues(r, \"\", cred)\n\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.UTC().Format(time.RFC3339)}\n\tif retDays > 0 {\n\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t}\n\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\tbyPassSet = globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.BypassGovernanceRetentionAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tObjectName:      objectName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t})\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.PutObjectRetentionAction,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: conditions,\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\tretSet = true\n\t}\n\tif byPassSet || retSet {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n\n// isPutActionAllowed - check if PUT operation is allowed on the resource, this\n// call verifies bucket policies and IAM policies, supports multi user\n// checks etc.\nfunc isPutActionAllowed(ctx context.Context, atype authType, bucketName, objectName string, r *http.Request, action iampolicy.Action) (s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tregion := globalSite.Region\n\tswitch atype {\n\tcase authTypeUnknown:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeStreamingSigned, authTypePresigned, authTypeSigned:\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = region\n\n\t// Do not check for PutObjectRetentionAction permission,\n\t// if mode and retain until date are not set.\n\t// Can happen when bucket has default lock config set\n\tif action == iampolicy.PutObjectRetentionAction &&\n\t\tr.Header.Get(xhttp.AmzObjectLockMode) == \"\" &&\n\t\tr.Header.Get(xhttp.AmzObjectLockRetainUntilDate) == \"\" {\n\t\treturn ErrNone\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.Action(action),\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n"], "fixing_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"compress/gzip\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/klauspost/compress/gzhttp\"\n\t\"github.com/minio/console/restapi\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/mux\"\n\t\"github.com/minio/pkg/wildcard\"\n\t\"github.com/rs/cors\"\n)\n\nfunc newHTTPServerFn() *xhttp.Server {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalHTTPServer\n}\n\nfunc setHTTPServer(h *xhttp.Server) {\n\tglobalObjLayerMutex.Lock()\n\tglobalHTTPServer = h\n\tglobalObjLayerMutex.Unlock()\n}\n\nfunc newConsoleServerFn() *restapi.Server {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalConsoleSrv\n}\n\nfunc setConsoleSrv(srv *restapi.Server) {\n\tglobalObjLayerMutex.Lock()\n\tglobalConsoleSrv = srv\n\tglobalObjLayerMutex.Unlock()\n}\n\nfunc newObjectLayerFn() ObjectLayer {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalObjectAPI\n}\n\nfunc newCachedObjectLayerFn() CacheObjectLayer {\n\tglobalObjLayerMutex.RLock()\n\tdefer globalObjLayerMutex.RUnlock()\n\treturn globalCacheObjectAPI\n}\n\nfunc setCacheObjectLayer(c CacheObjectLayer) {\n\tglobalObjLayerMutex.Lock()\n\tglobalCacheObjectAPI = c\n\tglobalObjLayerMutex.Unlock()\n}\n\nfunc setObjectLayer(o ObjectLayer) {\n\tglobalObjLayerMutex.Lock()\n\tglobalObjectAPI = o\n\tglobalObjLayerMutex.Unlock()\n}\n\n// objectAPIHandler implements and provides http handlers for S3 API.\ntype objectAPIHandlers struct {\n\tObjectAPI func() ObjectLayer\n\tCacheAPI  func() CacheObjectLayer\n}\n\n// getHost tries its best to return the request host.\n// According to section 14.23 of RFC 2616 the Host header\n// can include the port number if the default value of 80 is not used.\nfunc getHost(r *http.Request) string {\n\tif r.URL.IsAbs() {\n\t\treturn r.URL.Host\n\t}\n\treturn r.Host\n}\n\nfunc notImplementedHandler(w http.ResponseWriter, r *http.Request) {\n\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrNotImplemented), r.URL)\n}\n\ntype rejectedAPI struct {\n\tapi     string\n\tmethods []string\n\tqueries []string\n\tpath    string\n}\n\nvar rejectedObjAPIs = []rejectedAPI{\n\t{\n\t\tapi:     \"torrent\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete, http.MethodGet},\n\t\tqueries: []string{\"torrent\", \"\"},\n\t\tpath:    \"/{object:.+}\",\n\t},\n\t{\n\t\tapi:     \"acl\",\n\t\tmethods: []string{http.MethodDelete},\n\t\tqueries: []string{\"acl\", \"\"},\n\t\tpath:    \"/{object:.+}\",\n\t},\n}\n\nvar rejectedBucketAPIs = []rejectedAPI{\n\t{\n\t\tapi:     \"inventory\",\n\t\tmethods: []string{http.MethodGet, http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"inventory\", \"\"},\n\t},\n\t{\n\t\tapi:     \"cors\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"cors\", \"\"},\n\t},\n\t{\n\t\tapi:     \"metrics\",\n\t\tmethods: []string{http.MethodGet, http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"metrics\", \"\"},\n\t},\n\t{\n\t\tapi:     \"website\",\n\t\tmethods: []string{http.MethodPut},\n\t\tqueries: []string{\"website\", \"\"},\n\t},\n\t{\n\t\tapi:     \"logging\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"logging\", \"\"},\n\t},\n\t{\n\t\tapi:     \"accelerate\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"accelerate\", \"\"},\n\t},\n\t{\n\t\tapi:     \"requestPayment\",\n\t\tmethods: []string{http.MethodPut, http.MethodDelete},\n\t\tqueries: []string{\"requestPayment\", \"\"},\n\t},\n\t{\n\t\tapi:     \"acl\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodHead},\n\t\tqueries: []string{\"acl\", \"\"},\n\t},\n\t{\n\t\tapi:     \"publicAccessBlock\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"publicAccessBlock\", \"\"},\n\t},\n\t{\n\t\tapi:     \"ownershipControls\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"ownershipControls\", \"\"},\n\t},\n\t{\n\t\tapi:     \"intelligent-tiering\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"intelligent-tiering\", \"\"},\n\t},\n\t{\n\t\tapi:     \"analytics\",\n\t\tmethods: []string{http.MethodDelete, http.MethodPut, http.MethodGet},\n\t\tqueries: []string{\"analytics\", \"\"},\n\t},\n}\n\n// registerAPIRouter - registers S3 compatible APIs.\nfunc registerAPIRouter(router *mux.Router) {\n\t// Initialize API.\n\tapi := objectAPIHandlers{\n\t\tObjectAPI: newObjectLayerFn,\n\t\tCacheAPI:  newCachedObjectLayerFn,\n\t}\n\n\t// API Router\n\tapiRouter := router.PathPrefix(SlashSeparator).Subrouter()\n\n\tvar routers []*mux.Router\n\tfor _, domainName := range globalDomainNames {\n\t\tif IsKubernetes() {\n\t\t\trouters = append(routers, apiRouter.MatcherFunc(func(r *http.Request, match *mux.RouteMatch) bool {\n\t\t\t\thost, _, err := net.SplitHostPort(getHost(r))\n\t\t\t\tif err != nil {\n\t\t\t\t\thost = r.Host\n\t\t\t\t}\n\t\t\t\t// Make sure to skip matching minio.<domain>` this is\n\t\t\t\t// specifically meant for operator/k8s deployment\n\t\t\t\t// The reason we need to skip this is for a special\n\t\t\t\t// usecase where we need to make sure that\n\t\t\t\t// minio.<namespace>.svc.<cluster_domain> is ignored\n\t\t\t\t// by the bucketDNS style to ensure that path style\n\t\t\t\t// is available and honored at this domain.\n\t\t\t\t//\n\t\t\t\t// All other `<bucket>.<namespace>.svc.<cluster_domain>`\n\t\t\t\t// makes sure that buckets are routed through this matcher\n\t\t\t\t// to match for `<bucket>`\n\t\t\t\treturn host != minioReservedBucket+\".\"+domainName\n\t\t\t}).Host(\"{bucket:.+}.\"+domainName).Subrouter())\n\t\t} else {\n\t\t\trouters = append(routers, apiRouter.Host(\"{bucket:.+}.\"+domainName).Subrouter())\n\t\t}\n\t}\n\trouters = append(routers, apiRouter.PathPrefix(\"/{bucket}\").Subrouter())\n\n\tgz, err := gzhttp.NewWrapper(gzhttp.MinSize(1000), gzhttp.CompressionLevel(gzip.BestSpeed))\n\tif err != nil {\n\t\t// Static params, so this is very unlikely.\n\t\tlogger.Fatal(err, \"Unable to initialize server\")\n\t}\n\n\tfor _, router := range routers {\n\t\t// Register all rejected object APIs\n\t\tfor _, r := range rejectedObjAPIs {\n\t\t\tt := router.Methods(r.methods...).\n\t\t\t\tHandlerFunc(collectAPIStats(r.api, httpTraceAll(notImplementedHandler))).\n\t\t\t\tQueries(r.queries...)\n\t\t\tt.Path(r.path)\n\t\t}\n\n\t\t// Object operations\n\t\t// HeadObject\n\t\trouter.Methods(http.MethodHead).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"headobject\", maxClients(gz(httpTraceAll(api.HeadObjectHandler)))))\n\t\t// CopyObjectPart\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").\n\t\t\tHeadersRegexp(xhttp.AmzCopySource, \".*?(\\\\/|%2F).*?\").\n\t\t\tHandlerFunc(collectAPIStats(\"copyobjectpart\", maxClients(gz(httpTraceAll(api.CopyObjectPartHandler))))).\n\t\t\tQueries(\"partNumber\", \"{partNumber:[0-9]+}\", \"uploadId\", \"{uploadId:.*}\")\n\t\t// PutObjectPart\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectpart\", maxClients(gz(httpTraceHdrs(api.PutObjectPartHandler))))).Queries(\"partNumber\", \"{partNumber:[0-9]+}\", \"uploadId\", \"{uploadId:.*}\")\n\t\t// ListObjectParts\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectparts\", maxClients(gz(httpTraceAll(api.ListObjectPartsHandler))))).Queries(\"uploadId\", \"{uploadId:.*}\")\n\t\t// CompleteMultipartUpload\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"completemultipartupload\", maxClients(gz(httpTraceAll(api.CompleteMultipartUploadHandler))))).Queries(\"uploadId\", \"{uploadId:.*}\")\n\t\t// NewMultipartUpload\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"newmultipartupload\", maxClients(gz(httpTraceAll(api.NewMultipartUploadHandler))))).Queries(\"uploads\", \"\")\n\t\t// AbortMultipartUpload\n\t\trouter.Methods(http.MethodDelete).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"abortmultipartupload\", maxClients(gz(httpTraceAll(api.AbortMultipartUploadHandler))))).Queries(\"uploadId\", \"{uploadId:.*}\")\n\t\t// GetObjectACL - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjectacl\", maxClients(gz(httpTraceHdrs(api.GetObjectACLHandler))))).Queries(\"acl\", \"\")\n\t\t// PutObjectACL - this is a dummy call.\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectacl\", maxClients(gz(httpTraceHdrs(api.PutObjectACLHandler))))).Queries(\"acl\", \"\")\n\t\t// GetObjectTagging\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjecttagging\", maxClients(gz(httpTraceHdrs(api.GetObjectTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// PutObjectTagging\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjecttagging\", maxClients(gz(httpTraceHdrs(api.PutObjectTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// DeleteObjectTagging\n\t\trouter.Methods(http.MethodDelete).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"deleteobjecttagging\", maxClients(gz(httpTraceHdrs(api.DeleteObjectTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// SelectObjectContent\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"selectobjectcontent\", maxClients(gz(httpTraceHdrs(api.SelectObjectContentHandler))))).Queries(\"select\", \"\").Queries(\"select-type\", \"2\")\n\t\t// GetObjectRetention\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjectretention\", maxClients(gz(httpTraceAll(api.GetObjectRetentionHandler))))).Queries(\"retention\", \"\")\n\t\t// GetObjectLegalHold\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobjectlegalhold\", maxClients(gz(httpTraceAll(api.GetObjectLegalHoldHandler))))).Queries(\"legal-hold\", \"\")\n\t\t// GetObject with lambda ARNs\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobject\", maxClients(gz(httpTraceHdrs(api.GetObjectLambdaHandler))))).Queries(\"lambdaArn\", \"{lambdaArn:.*}\")\n\t\t// GetObject\n\t\trouter.Methods(http.MethodGet).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"getobject\", maxClients(gz(httpTraceHdrs(api.GetObjectHandler)))))\n\t\t// CopyObject\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HeadersRegexp(xhttp.AmzCopySource, \".*?(\\\\/|%2F).*?\").HandlerFunc(\n\t\t\tcollectAPIStats(\"copyobject\", maxClients(gz(httpTraceAll(api.CopyObjectHandler)))))\n\t\t// PutObjectRetention\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectretention\", maxClients(gz(httpTraceAll(api.PutObjectRetentionHandler))))).Queries(\"retention\", \"\")\n\t\t// PutObjectLegalHold\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobjectlegalhold\", maxClients(gz(httpTraceAll(api.PutObjectLegalHoldHandler))))).Queries(\"legal-hold\", \"\")\n\n\t\t// PutObject with auto-extract support for zip\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HeadersRegexp(xhttp.AmzSnowballExtract, \"true\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobject\", maxClients(gz(httpTraceHdrs(api.PutObjectExtractHandler)))))\n\n\t\t// PutObject\n\t\trouter.Methods(http.MethodPut).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"putobject\", maxClients(gz(httpTraceHdrs(api.PutObjectHandler)))))\n\n\t\t// DeleteObject\n\t\trouter.Methods(http.MethodDelete).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"deleteobject\", maxClients(gz(httpTraceAll(api.DeleteObjectHandler)))))\n\n\t\t// PostRestoreObject\n\t\trouter.Methods(http.MethodPost).Path(\"/{object:.+}\").HandlerFunc(\n\t\t\tcollectAPIStats(\"restoreobject\", maxClients(gz(httpTraceAll(api.PostRestoreObjectHandler))))).Queries(\"restore\", \"\")\n\n\t\t// Bucket operations\n\n\t\t// GetBucketLocation\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketlocation\", maxClients(gz(httpTraceAll(api.GetBucketLocationHandler))))).Queries(\"location\", \"\")\n\t\t// GetBucketPolicy\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketpolicy\", maxClients(gz(httpTraceAll(api.GetBucketPolicyHandler))))).Queries(\"policy\", \"\")\n\t\t// GetBucketLifecycle\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketlifecycle\", maxClients(gz(httpTraceAll(api.GetBucketLifecycleHandler))))).Queries(\"lifecycle\", \"\")\n\t\t// GetBucketEncryption\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketencryption\", maxClients(gz(httpTraceAll(api.GetBucketEncryptionHandler))))).Queries(\"encryption\", \"\")\n\t\t// GetBucketObjectLockConfig\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketobjectlockconfiguration\", maxClients(gz(httpTraceAll(api.GetBucketObjectLockConfigHandler))))).Queries(\"object-lock\", \"\")\n\t\t// GetBucketReplicationConfig\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketreplicationconfiguration\", maxClients(gz(httpTraceAll(api.GetBucketReplicationConfigHandler))))).Queries(\"replication\", \"\")\n\t\t// GetBucketVersioning\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketversioning\", maxClients(gz(httpTraceAll(api.GetBucketVersioningHandler))))).Queries(\"versioning\", \"\")\n\t\t// GetBucketNotification\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketnotification\", maxClients(gz(httpTraceAll(api.GetBucketNotificationHandler))))).Queries(\"notification\", \"\")\n\t\t// ListenNotification\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listennotification\", gz(httpTraceAll(api.ListenNotificationHandler)))).Queries(\"events\", \"{events:.*}\")\n\t\t// ResetBucketReplicationStatus - MinIO extension API\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"resetbucketreplicationstatus\", maxClients(gz(httpTraceAll(api.ResetBucketReplicationStatusHandler))))).Queries(\"replication-reset-status\", \"\")\n\n\t\t// Dummy Bucket Calls\n\t\t// GetBucketACL -- this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketacl\", maxClients(gz(httpTraceAll(api.GetBucketACLHandler))))).Queries(\"acl\", \"\")\n\t\t// PutBucketACL -- this is a dummy call.\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketacl\", maxClients(gz(httpTraceAll(api.PutBucketACLHandler))))).Queries(\"acl\", \"\")\n\t\t// GetBucketCors - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketcors\", maxClients(gz(httpTraceAll(api.GetBucketCorsHandler))))).Queries(\"cors\", \"\")\n\t\t// GetBucketWebsiteHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketwebsite\", maxClients(gz(httpTraceAll(api.GetBucketWebsiteHandler))))).Queries(\"website\", \"\")\n\t\t// GetBucketAccelerateHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketaccelerate\", maxClients(gz(httpTraceAll(api.GetBucketAccelerateHandler))))).Queries(\"accelerate\", \"\")\n\t\t// GetBucketRequestPaymentHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketrequestpayment\", maxClients(gz(httpTraceAll(api.GetBucketRequestPaymentHandler))))).Queries(\"requestPayment\", \"\")\n\t\t// GetBucketLoggingHandler - this is a dummy call.\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketlogging\", maxClients(gz(httpTraceAll(api.GetBucketLoggingHandler))))).Queries(\"logging\", \"\")\n\t\t// GetBucketTaggingHandler\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbuckettagging\", maxClients(gz(httpTraceAll(api.GetBucketTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// DeleteBucketWebsiteHandler\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketwebsite\", maxClients(gz(httpTraceAll(api.DeleteBucketWebsiteHandler))))).Queries(\"website\", \"\")\n\t\t// DeleteBucketTaggingHandler\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebuckettagging\", maxClients(gz(httpTraceAll(api.DeleteBucketTaggingHandler))))).Queries(\"tagging\", \"\")\n\n\t\t// ListMultipartUploads\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listmultipartuploads\", maxClients(gz(httpTraceAll(api.ListMultipartUploadsHandler))))).Queries(\"uploads\", \"\")\n\t\t// ListObjectsV2M\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectsv2M\", maxClients(gz(httpTraceAll(api.ListObjectsV2MHandler))))).Queries(\"list-type\", \"2\", \"metadata\", \"true\")\n\t\t// ListObjectsV2\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectsv2\", maxClients(gz(httpTraceAll(api.ListObjectsV2Handler))))).Queries(\"list-type\", \"2\")\n\t\t// ListObjectVersions\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectversions\", maxClients(gz(httpTraceAll(api.ListObjectVersionsHandler))))).Queries(\"versions\", \"\")\n\t\t// GetBucketPolicyStatus\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getpolicystatus\", maxClients(gz(httpTraceAll(api.GetBucketPolicyStatusHandler))))).Queries(\"policyStatus\", \"\")\n\t\t// PutBucketLifecycle\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketlifecycle\", maxClients(gz(httpTraceAll(api.PutBucketLifecycleHandler))))).Queries(\"lifecycle\", \"\")\n\t\t// PutBucketReplicationConfig\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketreplicationconfiguration\", maxClients(gz(httpTraceAll(api.PutBucketReplicationConfigHandler))))).Queries(\"replication\", \"\")\n\t\t// PutBucketEncryption\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketencryption\", maxClients(gz(httpTraceAll(api.PutBucketEncryptionHandler))))).Queries(\"encryption\", \"\")\n\n\t\t// PutBucketPolicy\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketpolicy\", maxClients(gz(httpTraceAll(api.PutBucketPolicyHandler))))).Queries(\"policy\", \"\")\n\n\t\t// PutBucketObjectLockConfig\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketobjectlockconfig\", maxClients(gz(httpTraceAll(api.PutBucketObjectLockConfigHandler))))).Queries(\"object-lock\", \"\")\n\t\t// PutBucketTaggingHandler\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbuckettagging\", maxClients(gz(httpTraceAll(api.PutBucketTaggingHandler))))).Queries(\"tagging\", \"\")\n\t\t// PutBucketVersioning\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketversioning\", maxClients(gz(httpTraceAll(api.PutBucketVersioningHandler))))).Queries(\"versioning\", \"\")\n\t\t// PutBucketNotification\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucketnotification\", maxClients(gz(httpTraceAll(api.PutBucketNotificationHandler))))).Queries(\"notification\", \"\")\n\t\t// ResetBucketReplicationStart - MinIO extension API\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"resetbucketreplicationstart\", maxClients(gz(httpTraceAll(api.ResetBucketReplicationStartHandler))))).Queries(\"replication-reset\", \"\")\n\n\t\t// PutBucket\n\t\trouter.Methods(http.MethodPut).HandlerFunc(\n\t\t\tcollectAPIStats(\"putbucket\", maxClients(gz(httpTraceAll(api.PutBucketHandler)))))\n\t\t// HeadBucket\n\t\trouter.Methods(http.MethodHead).HandlerFunc(\n\t\t\tcollectAPIStats(\"headbucket\", maxClients(gz(httpTraceAll(api.HeadBucketHandler)))))\n\t\t// PostPolicy\n\t\trouter.Methods(http.MethodPost).MatcherFunc(func(r *http.Request, _ *mux.RouteMatch) bool {\n\t\t\treturn isRequestPostPolicySignatureV4(r)\n\t\t}).HandlerFunc(collectAPIStats(\"postpolicybucket\", maxClients(gz(httpTraceHdrs(api.PostPolicyBucketHandler)))))\n\t\t// DeleteMultipleObjects\n\t\trouter.Methods(http.MethodPost).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletemultipleobjects\", maxClients(gz(httpTraceAll(api.DeleteMultipleObjectsHandler))))).Queries(\"delete\", \"\")\n\t\t// DeleteBucketPolicy\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketpolicy\", maxClients(gz(httpTraceAll(api.DeleteBucketPolicyHandler))))).Queries(\"policy\", \"\")\n\t\t// DeleteBucketReplication\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketreplicationconfiguration\", maxClients(gz(httpTraceAll(api.DeleteBucketReplicationConfigHandler))))).Queries(\"replication\", \"\")\n\t\t// DeleteBucketLifecycle\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketlifecycle\", maxClients(gz(httpTraceAll(api.DeleteBucketLifecycleHandler))))).Queries(\"lifecycle\", \"\")\n\t\t// DeleteBucketEncryption\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucketencryption\", maxClients(gz(httpTraceAll(api.DeleteBucketEncryptionHandler))))).Queries(\"encryption\", \"\")\n\t\t// DeleteBucket\n\t\trouter.Methods(http.MethodDelete).HandlerFunc(\n\t\t\tcollectAPIStats(\"deletebucket\", maxClients(gz(httpTraceAll(api.DeleteBucketHandler)))))\n\n\t\t// MinIO extension API for replication.\n\t\t//\n\t\t// GetBucketReplicationMetrics\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"getbucketreplicationmetrics\", maxClients(gz(httpTraceAll(api.GetBucketReplicationMetricsHandler))))).Queries(\"replication-metrics\", \"\")\n\n\t\t// Register rejected bucket APIs\n\t\tfor _, r := range rejectedBucketAPIs {\n\t\t\trouter.Methods(r.methods...).\n\t\t\t\tHandlerFunc(collectAPIStats(r.api, httpTraceAll(notImplementedHandler))).\n\t\t\t\tQueries(r.queries...)\n\t\t}\n\n\t\t// S3 ListObjectsV1 (Legacy)\n\t\trouter.Methods(http.MethodGet).HandlerFunc(\n\t\t\tcollectAPIStats(\"listobjectsv1\", maxClients(gz(httpTraceAll(api.ListObjectsV1Handler)))))\n\t}\n\n\t// Root operation\n\n\t// ListenNotification\n\tapiRouter.Methods(http.MethodGet).Path(SlashSeparator).HandlerFunc(\n\t\tcollectAPIStats(\"listennotification\", gz(httpTraceAll(api.ListenNotificationHandler)))).Queries(\"events\", \"{events:.*}\")\n\n\t// ListBuckets\n\tapiRouter.Methods(http.MethodGet).Path(SlashSeparator).HandlerFunc(\n\t\tcollectAPIStats(\"listbuckets\", maxClients(gz(httpTraceAll(api.ListBucketsHandler)))))\n\n\t// S3 browser with signature v4 adds '//' for ListBuckets request, so rather\n\t// than failing with UnknownAPIRequest we simply handle it for now.\n\tapiRouter.Methods(http.MethodGet).Path(SlashSeparator + SlashSeparator).HandlerFunc(\n\t\tcollectAPIStats(\"listbuckets\", maxClients(gz(httpTraceAll(api.ListBucketsHandler)))))\n\n\t// If none of the routes match add default error handler routes\n\tapiRouter.NotFoundHandler = collectAPIStats(\"notfound\", httpTraceAll(errorResponseHandler))\n\tapiRouter.MethodNotAllowedHandler = collectAPIStats(\"methodnotallowed\", httpTraceAll(methodNotAllowedHandler(\"S3\")))\n}\n\n// corsHandler handler for CORS (Cross Origin Resource Sharing)\nfunc corsHandler(handler http.Handler) http.Handler {\n\tcommonS3Headers := []string{\n\t\txhttp.Date,\n\t\txhttp.ETag,\n\t\txhttp.ServerInfo,\n\t\txhttp.Connection,\n\t\txhttp.AcceptRanges,\n\t\txhttp.ContentRange,\n\t\txhttp.ContentEncoding,\n\t\txhttp.ContentLength,\n\t\txhttp.ContentType,\n\t\txhttp.ContentDisposition,\n\t\txhttp.LastModified,\n\t\txhttp.ContentLanguage,\n\t\txhttp.CacheControl,\n\t\txhttp.RetryAfter,\n\t\txhttp.AmzBucketRegion,\n\t\txhttp.Expires,\n\t\t\"X-Amz*\",\n\t\t\"x-amz*\",\n\t\t\"*\",\n\t}\n\n\treturn cors.New(cors.Options{\n\t\tAllowOriginFunc: func(origin string) bool {\n\t\t\tallowedOrigins := globalAPIConfig.getCorsAllowOrigins()\n\t\t\tif len(allowedOrigins) == 0 {\n\t\t\t\tallowedOrigins = []string{\"*\"}\n\t\t\t}\n\t\t\tfor _, allowedOrigin := range allowedOrigins {\n\t\t\t\tif wildcard.MatchSimple(allowedOrigin, origin) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t},\n\t\tAllowedMethods: []string{\n\t\t\thttp.MethodGet,\n\t\t\thttp.MethodPut,\n\t\t\thttp.MethodHead,\n\t\t\thttp.MethodPost,\n\t\t\thttp.MethodDelete,\n\t\t\thttp.MethodOptions,\n\t\t\thttp.MethodPatch,\n\t\t},\n\t\tAllowedHeaders:   commonS3Headers,\n\t\tExposedHeaders:   commonS3Headers,\n\t\tAllowCredentials: true,\n\t}).Handler(handler)\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\tobjectlock \"github.com/minio/minio/internal/bucket/object/lock\"\n\t\"github.com/minio/minio/internal/etag\"\n\t\"github.com/minio/minio/internal/hash\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\txjwt \"github.com/minio/minio/internal/jwt\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/minio/internal/mcontext\"\n\t\"github.com/minio/pkg/bucket/policy\"\n\tiampolicy \"github.com/minio/pkg/iam/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(xhttp.Authorization), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzCredential]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzAccessKeyID]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\tmediaType, _, err := mime.ParseMediaType(r.Header.Get(xhttp.ContentType))\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn mediaType == \"multipart/form-data\" && r.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Authorization type.\n//\n//go:generate stringer -type=authType -trimprefix=authType $GOFILE\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n\tauthTypeSTS\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) authType {\n\tif r.URL != nil {\n\t\tvar err error\n\t\tr.Form, err = url.ParseQuery(r.URL.RawQuery)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(r.Context(), err)\n\t\t\treturn authTypeUnknown\n\t\t}\n\t}\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.Form[xhttp.Action]; ok {\n\t\treturn authTypeSTS\n\t} else if _, ok := r.Header[xhttp.Authorization]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\nfunc validateAdminSignature(ctx context.Context, r *http.Request, region string) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\ts3Err := ErrAccessDenied\n\tif _, ok := r.Header[xhttp.AmzContentSha256]; ok &&\n\t\tgetRequestAuthType(r) == authTypeSigned {\n\t\t// We only support admin credentials to access admin APIs.\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t\tif s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\n\t\t// we only support V4 (no presign) with auth body\n\t\ts3Err = isReqAuthenticated(ctx, r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\treturn cred, owner, ErrNone\n}\n\n// checkAdminRequestAuth checks for authentication and authorization for the incoming\n// request. It only accepts V2 and V4 requests. Presigned, JWT and anonymous requests\n// are automatically rejected.\nfunc checkAdminRequestAuth(ctx context.Context, r *http.Request, action iampolicy.AdminAction, region string) (auth.Credentials, APIErrorCode) {\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, region)\n\tif s3Err != ErrNone {\n\t\treturn cred, s3Err\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.Action(action),\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred, ErrNone\n\t}\n\n\treturn cred, ErrAccessDenied\n}\n\n// Fetch the security token set by the client.\nfunc getSessionToken(r *http.Request) (token string) {\n\ttoken = r.Header.Get(xhttp.AmzSecurityToken)\n\tif token != \"\" {\n\t\treturn token\n\t}\n\treturn r.Form.Get(xhttp.AmzSecurityToken)\n}\n\n// Fetch claims in the security token returned by the client, doesn't return\n// errors - upon errors the returned claims map will be empty.\nfunc mustGetClaimsFromToken(r *http.Request) map[string]interface{} {\n\tclaims, _ := getClaimsFromToken(getSessionToken(r))\n\treturn claims\n}\n\nfunc getClaimsFromTokenWithSecret(token, secret string) (map[string]interface{}, error) {\n\t// JWT token for x-amz-security-token is signed with admin\n\t// secret key, temporary credentials become invalid if\n\t// server admin credentials change. This is done to ensure\n\t// that clients cannot decode the token using the temp\n\t// secret keys and generate an entirely new claim by essentially\n\t// hijacking the policies. We need to make sure that this is\n\t// based on admin credential such that token cannot be decoded\n\t// on the client side and is treated like an opaque value.\n\tclaims, err := auth.ExtractClaims(token, secret)\n\tif err != nil {\n\t\tif subtle.ConstantTimeCompare([]byte(secret), []byte(globalActiveCred.SecretKey)) == 1 {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims, err = auth.ExtractClaims(token, globalActiveCred.SecretKey)\n\t\tif err != nil {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t}\n\n\t// If AuthZPlugin is set, return without any further checks.\n\tif newGlobalAuthZPluginFn() != nil {\n\t\treturn claims.Map(), nil\n\t}\n\n\t// Check if a session policy is set. If so, decode it here.\n\tsp, spok := claims.Lookup(iampolicy.SessionPolicyName)\n\tif spok {\n\t\t// Looks like subpolicy is set and is a string, if set then its\n\t\t// base64 encoded, decode it. Decoding fails reject such\n\t\t// requests.\n\t\tspBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\t// Base64 decoding fails, we should log to indicate\n\t\t\t// something is malforming the request sent by client.\n\t\t\tlogger.LogIf(GlobalContext, err, logger.Application)\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims.MapClaims[sessionPolicyNameExtracted] = string(spBytes)\n\t}\n\n\treturn claims.Map(), nil\n}\n\n// Fetch claims in the security token returned by the client.\nfunc getClaimsFromToken(token string) (map[string]interface{}, error) {\n\treturn getClaimsFromTokenWithSecret(token, globalActiveCred.SecretKey)\n}\n\n// Fetch claims in the security token returned by the client and validate the token.\nfunc checkClaimsFromToken(r *http.Request, cred auth.Credentials) (map[string]interface{}, APIErrorCode) {\n\ttoken := getSessionToken(r)\n\tif token != \"\" && cred.AccessKey == \"\" {\n\t\t// x-amz-security-token is not allowed for anonymous access.\n\t\treturn nil, ErrNoAccessKey\n\t}\n\n\tif token == \"\" && cred.IsTemp() && !cred.IsServiceAccount() {\n\t\t// Temporary credentials should always have x-amz-security-token\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif token != \"\" && !cred.IsTemp() {\n\t\t// x-amz-security-token should not present for static credentials.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif !cred.IsServiceAccount() && cred.IsTemp() && subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n\t\t// validate token for temporary credentials only.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tsecret := globalActiveCred.SecretKey\n\tif cred.IsServiceAccount() {\n\t\ttoken = cred.SessionToken\n\t\tsecret = cred.SecretKey\n\t}\n\n\tif token != \"\" {\n\t\tclaims, err := getClaimsFromTokenWithSecret(token, secret)\n\t\tif err != nil {\n\t\t\treturn nil, toAPIErrorCode(r.Context(), err)\n\t\t}\n\t\treturn claims, ErrNone\n\t}\n\n\tclaims := xjwt.NewMapClaims()\n\treturn claims.Map(), ErrNone\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\n// checkRequestAuthTypeWithVID is similar to checkRequestAuthType\n// passes versionID additionally.\nfunc checkRequestAuthTypeWithVID(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName, versionID string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\tlogger.GetReqInfo(ctx).VersionID = versionID\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\nfunc authenticateRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\tif logger.GetReqInfo(ctx) == nil {\n\t\tlogger.LogIf(ctx, errors.New(\"unexpected context.Context does not have a logger.ReqInfo\"), logger.Minio)\n\t\treturn ErrAccessDenied\n\t}\n\n\tvar cred auth.Credentials\n\tvar owner bool\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalSite.Region\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\t\tif s3Err = isReqAuthenticated(ctx, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\t// region is valid only for CreateBucketAction.\n\tvar region string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := io.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err, logger.Application)\n\t\t\treturn ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t\tregion, s3Err = parseLocationConstraint(r)\n\t\tif s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tlogger.GetReqInfo(ctx).Region = region\n\n\treturn s3Err\n}\n\nfunc authorizeRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn ErrAccessDenied\n\t}\n\n\tcred := reqInfo.Cred\n\towner := reqInfo.Owner\n\tregion := reqInfo.Region\n\tbucket := reqInfo.BucketName\n\tobject := reqInfo.ObjectName\n\tversionID := reqInfo.VersionID\n\n\tif action != policy.ListAllMyBucketsAction && cred.AccessKey == \"\" {\n\t\t// Anonymous checks are not meant for ListAllBuckets action\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      object,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\n\t\tif action == policy.ListBucketVersionsAction {\n\t\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t\t// verify as a fallback.\n\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\tGroups:          cred.Groups,\n\t\t\t\tAction:          policy.ListBucketAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\t// Request is allowed return the appropriate access key.\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t}\n\n\t\treturn ErrAccessDenied\n\t}\n\tif action == policy.DeleteObjectAction && versionID != \"\" {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.Action(policy.DeleteObjectVersionAction),\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t\tDenyOnly:        true,\n\t\t}) { // Request is not allowed if Deny action on DeleteObjectVersionAction\n\t\t\treturn ErrAccessDenied\n\t\t}\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.Action(action),\n\t\tBucketName:      bucket,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      object,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn ErrNone\n\t}\n\n\tif action == policy.ListBucketVersionsAction {\n\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t// verify as a fallback.\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\t}\n\n\treturn ErrAccessDenied\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\n// Additionally returns the accessKey used in the request, and if this request is by an admin.\nfunc checkRequestAuthTypeCredential(ctx context.Context, r *http.Request, action policy.Action) (cred auth.Credentials, owner bool, s3Err APIErrorCode) {\n\ts3Err = authenticateRequest(ctx, r, action)\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn cred, owner, ErrAccessDenied\n\t}\n\n\tcred = reqInfo.Cred\n\towner = reqInfo.Owner\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, authorizeRequest(ctx, r, action)\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r, stype)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region, stype)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region, stype)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(ctx context.Context, r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tif errCode := reqSignatureV4Verify(r, region, stype); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tclientETag, err := etag.FromContentMD5(r.Header)\n\tif err != nil {\n\t\treturn ErrInvalidDigest\n\t}\n\n\t// Extract either 'X-Amz-Content-Sha256' header or 'X-Amz-Content-Sha256' query parameter (if V4 presigned)\n\t// Do not verify 'X-Amz-Content-Sha256' if skipSHA256.\n\tvar contentSHA256 []byte\n\tif skipSHA256 := skipContentSha256Cksum(r); !skipSHA256 && isRequestPresignedSignatureV4(r) {\n\t\tif sha256Sum, ok := r.Form[xhttp.AmzContentSha256]; ok && len(sha256Sum) > 0 {\n\t\t\tcontentSHA256, err = hex.DecodeString(sha256Sum[0])\n\t\t\tif err != nil {\n\t\t\t\treturn ErrContentSHA256Mismatch\n\t\t\t}\n\t\t}\n\t} else if _, ok := r.Header[xhttp.AmzContentSha256]; !skipSHA256 && ok {\n\t\tcontentSHA256, err = hex.DecodeString(r.Header.Get(xhttp.AmzContentSha256))\n\t\tif err != nil || len(contentSHA256) == 0 {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\n\t// Verify 'Content-Md5' and/or 'X-Amz-Content-Sha256' if present.\n\t// The verification happens implicit during reading.\n\treader, err := hash.NewReader(r.Body, -1, clientETag.String(), hex.EncodeToString(contentSHA256), -1)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\tr.Body = reader\n\treturn ErrNone\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:       {},\n\tauthTypePresigned:       {},\n\tauthTypePresignedV2:     {},\n\tauthTypeSigned:          {},\n\tauthTypeSignedV2:        {},\n\tauthTypePostPolicy:      {},\n\tauthTypeStreamingSigned: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// setAuthHandler to validate authorization header for the incoming request.\nfunc setAuthHandler(h http.Handler) http.Handler {\n\t// handler for validating incoming authorization headers.\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\taType := getRequestAuthType(r)\n\t\tif aType == authTypeSigned || aType == authTypeSignedV2 || aType == authTypeStreamingSigned {\n\t\t\t// Verify if date headers are set, if not reject the request\n\t\t\tamzDate, errCode := parseAmzDateHeader(r)\n\t\t\tif errCode != ErrNone {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\t// All our internal APIs are sensitive towards Date\n\t\t\t\t// header, for all requests where Date header is not\n\t\t\t\t// present we will reject such clients.\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(errCode), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Verify if the request date header is shifted by less than globalMaxSkewTime parameter in the past\n\t\t\t// or in the future, reject request otherwise.\n\t\t\tcurTime := UTCNow()\n\t\t\tif curTime.Sub(amzDate) > globalMaxSkewTime || amzDate.Sub(curTime) > globalMaxSkewTime {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrRequestTimeTooSkewed), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif isSupportedS3AuthType(aType) || aType == authTypeJWT || aType == authTypeSTS {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif ok {\n\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t}\n\n\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrSignatureVersionNotSupported), r.URL)\n\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsAuth, 1)\n\t})\n}\n\nfunc validateSignature(atype authType, r *http.Request) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tvar s3Err APIErrorCode\n\tswitch atype {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn cred, owner, ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypePresigned, authTypeSigned:\n\t\tregion := globalSite.Region\n\t\tif s3Err = isReqAuthenticated(GlobalContext, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, ErrNone\n}\n\nfunc isPutRetentionAllowed(bucketName, objectName string, retDays int, retDate time.Time, retMode objectlock.RetMode, byPassSet bool, r *http.Request, cred auth.Credentials, owner bool) (s3Err APIErrorCode) {\n\tvar retSet bool\n\tif cred.AccessKey == \"\" {\n\t\treturn ErrAccessDenied\n\t}\n\n\tconditions := getConditionValues(r, \"\", cred)\n\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.UTC().Format(time.RFC3339)}\n\tif retDays > 0 {\n\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t}\n\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\tbyPassSet = globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.BypassGovernanceRetentionAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tObjectName:      objectName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t})\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.PutObjectRetentionAction,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: conditions,\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\tretSet = true\n\t}\n\tif byPassSet || retSet {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n\n// isPutActionAllowed - check if PUT operation is allowed on the resource, this\n// call verifies bucket policies and IAM policies, supports multi user\n// checks etc.\nfunc isPutActionAllowed(ctx context.Context, atype authType, bucketName, objectName string, r *http.Request, action iampolicy.Action) (s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tregion := globalSite.Region\n\tswitch atype {\n\tcase authTypeUnknown:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeStreamingSigned, authTypePresigned, authTypeSigned:\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = region\n\n\t// Do not check for PutObjectRetentionAction permission,\n\t// if mode and retain until date are not set.\n\t// Can happen when bucket has default lock config set\n\tif action == iampolicy.PutObjectRetentionAction &&\n\t\tr.Header.Get(xhttp.AmzObjectLockMode) == \"\" &&\n\t\tr.Header.Get(xhttp.AmzObjectLockRetainUntilDate) == \"\" {\n\t\treturn ErrNone\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.Action(action),\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n"], "buggy_code_start_loc": [437, 27], "buggy_code_end_loc": [439, 79], "fixing_code_start_loc": [437, 28], "fixing_code_end_loc": [440, 83], "type": "NVD-CWE-noinfo", "message": "Minio is a Multi-Cloud Object Storage framework. Prior to RELEASE.2023-03-20T20-16-18Z, an attacker can use crafted requests to bypass metadata bucket name checking and put an object into any bucket while processing `PostPolicyBucket`. To carry out this attack, the attacker requires credentials with `arn:aws:s3:::*` permission, as well as enabled Console API access. This issue has been patched in RELEASE.2023-03-20T20-16-18Z. As a workaround, enable browser API access and turn off `MINIO_BROWSER=off`.", "other": {"cve": {"id": "CVE-2023-28434", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-22T21:15:18.427", "lastModified": "2023-03-28T16:24:55.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Minio is a Multi-Cloud Object Storage framework. Prior to RELEASE.2023-03-20T20-16-18Z, an attacker can use crafted requests to bypass metadata bucket name checking and put an object into any bucket while processing `PostPolicyBucket`. To carry out this attack, the attacker requires credentials with `arn:aws:s3:::*` permission, as well as enabled Console API access. This issue has been patched in RELEASE.2023-03-20T20-16-18Z. As a workaround, enable browser API access and turn off `MINIO_BROWSER=off`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-03-20t20-16-18z", "matchCriteriaId": "63CBB19F-80FF-4D6B-ADF3-7BD9768861D0"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/67f4ba154a27a1b06e48bfabda38355a010dfca5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/minio/minio/pull/16849", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-2pxw-r47w-4p8c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/67f4ba154a27a1b06e48bfabda38355a010dfca5"}}