{"buggy_code": ["# html-parse-stringify\n\nThis is an _experimental lightweight approach_ to enable quickly parsing HTML into an AST and stringify'ing it back to the original string.\n\nAs it turns out, if you can make a the simplifying assumptions about HTML that all tags must be closed or self-closing. Which is OK for _this_ particular application. You can write a super light/fast parser in JS with regex.\n\n\"Why on earth would you do this?! Haven't you read: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags ?!?!\"\n\nWhy yes, yes I have :)\n\nBut the truth is. If you _could_ do this in a whopping grand total of ~600 bytes (min+gzip) as this repo shows. It potentially enables DOM diffing based on a HTML strings to be super light and fast in a browser. What is that you say? DOM-diffing?\n\nYes.\n\nReact.js essentially pioneered the approach. With React you render to a \"virtual DOM\" whenever you want to, and the virtual DOM can then diff against the real DOM (or the last virtual DOM) and then turn that diff into whatever transformations are necessary to get the _real_ DOM to match what you rendered as efficiently as possible.\n\nAs a result, when you're building a single page app, you don't have to worry so much about bindings. Instead, you simple re-render to the virtual DOM whenever you know something's changed. All of a sudden being able to have `change` events for individual properties becomes less important, instead you can just reference those values in your template whenever you think something changed.\n\nCool idea, right?!\n\n## So why this?\n\nWell, there are other things React expects me to do if I use it that I don't like. Such as the custom templating and syntax you have to use.\n\nIf, hypothetically, you could instead diff an HTML string (generated by _whatever_ templating language of your choice) against the DOM, then you'd get the same benefit, sans React's impositions.\n\nThis may all turn out to be a bad idea altogether, but initial results seem promising when paired with [virtual-dom](https://github.com/Matt-Esch/virtual-dom).\n\nBut you can't just diff HTML strings, as simple strings, very easily, in order to diff two HTML node trees you have to first turn that string into a tree structure of some sort. Typically, the thing you generate from parsing something like this is called an AST (abstract syntax tree).\n\nThis lib does exactly that.\n\nIt has two methods:\n\n1. parse\n2. stringify\n\n## `.parse(htmlString, options)`\n\nTakes a string of HTML and turns it into an AST, the only option you can currently pass is an object of registered `components` whose children will be ignored when generating the AST.\n\n## `.stringify(AST)`\n\nTakes an AST and turns it back into a string of HTML.\n\n## What does the AST look like?\n\nSee comments in the following example:\n\n```js\nvar HTML = require('html-parse-stringify')\n\n// this html:\nvar html = '<div class=\"oh\"><p>hi</p></div>'\n\n// becomes this AST:\nvar ast = HTML.parse(html)\n\nconsole.log(ast)\n/*\n{\n    // can be `tag`, `text` or `component`\n    type: 'tag',\n\n    // name of tag if relevant\n    name: 'div',\n    \n    // parsed attribute object\n    attrs: {\n        class: 'oh'\n    },\n\n    // whether this is a self-closing tag\n    // such as <img/>\n    voidElement: false,\n\n    // an array of child nodes\n    // we see the same structure\n    // repeated in each of these\n    children: [\n        {\n            type: 'tag',\n            name: 'p',\n            attrs: {},\n            voidElement: false,\n            children: [\n                // this is a text node\n                // it also has a `type`\n                // but nothing other than\n                // a `content` containing\n                // its text.\n                {\n                    type: 'text',\n                    content: 'hi'\n                }\n            ]\n        }\n    ]\n}\n*/\n```\n\n## the AST node types\n\n### 1. tag\n\nproperties:\n\n- `type` - will always be `tag` for this type of node\n- `name` - tag name, such as 'div'\n- `attrs` - an object of key/value pairs. If an attribute has multiple space-separated items such as classes, they'll still be in a single string, for example: `class: \"class1 class2\"`\n- `voidElement` - `true` or `false`. Whether this tag is a known void element as defined by [spec](http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements).\n- `children` - array of child nodes. Note that any continuous string of text is a text node child, see below.\n\n### 2. text\n\nproperties:\n\n- `type` - will always be `text` for this type of node\n- `content` - text content of the node\n\n### 3. component\n\nIf you pass an object of `components` as part of the `options` object passed as the second argument to `.parse()` then the AST won't keep parsing that branch of the DOM tree when it one of those registered components.\n\nThis is so that it's possible to ignore sections of the tree that you may want to handle by another \"subview\" in your application that handles it's own DOM diffing.\n\nproperties:\n\n- `type` - will always be `component` for this type of node\n- `name` - tag name, such as 'div'\n- `attrs` - an object of key/value pairs. If an attribute has multiple space-separated items such as classes, they'll still be in a single string, for example: `class: \"class1 class2\"`\n- `voidElement` - `true` or `false`. Whether this tag is a known void element as defined by [spec](http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements).\n- `children` - it will still have a `children` array, but it will always be empty.\n\n## changelog\n\n- `2.0.0` updated to more modern dependencies/build system. Switched to prettier, etc. No big feature differences, just new build system/project structure. Added support for top level text nodes thanks to @jperl. Added support for comments thanks to @pconerly.\n- `1.0.0 - 1.0.3` no big changes, bug fixes and speed improvements.\n\n## credits\n\nIf this sounds interesting you should probably follow [@HenrikJoreteg](https://twitter.com/henrikjoreteg) and [@Philip_Roberts](https://twitter.com/philip_roberts) on twitter to see how this all turns out.\n\n## license\n\nMIT\n", "const tagRE = /<[a-zA-Z\\-\\!\\/](?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])*>/g\nimport parseTag from './parse-tag'\n\n// re-used obj for quick lookups of components\nconst empty = Object.create(null)\n\nexport default function parse(html, options) {\n  options || (options = {})\n  options.components || (options.components = empty)\n  const result = []\n  const arr = []\n  let current\n  let level = -1\n  let inComponent = false\n\n  // handle text at top level\n  if (html.indexOf('<') !== 0) {\n    var end = html.indexOf('<')\n    result.push({\n      type: 'text',\n      content: end === -1 ? html : html.substring(0, end),\n    })\n  }\n\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return\n      } else {\n        inComponent = false\n      }\n    }\n    const isOpen = tag.charAt(1) !== '/'\n    const isComment = tag.startsWith('<!--')\n    const start = index + tag.length\n    const nextChar = html.charAt(start)\n    let parent\n\n    if (isComment) {\n      const comment = parseTag(tag)\n\n      // if we're at root, push new base node\n      if (level < 0) {\n        result.push(comment)\n        return result\n      }\n      parent = arr[level]\n      parent.children.push(comment)\n      return result\n    }\n\n    if (isOpen) {\n      level++\n\n      current = parseTag(tag)\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component'\n        inComponent = true\n      }\n\n      if (\n        !current.voidElement &&\n        !inComponent &&\n        nextChar &&\n        nextChar !== '<'\n      ) {\n        current.children.push({\n          type: 'text',\n          content: html.slice(start, html.indexOf('<', start)),\n        })\n      }\n\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current)\n      }\n\n      parent = arr[level - 1]\n\n      if (parent) {\n        parent.children.push(current)\n      }\n\n      arr[level] = current\n    }\n\n    if (!isOpen || current.voidElement) {\n      if (\n        level > -1 &&\n        (current.voidElement || current.name === tag.slice(2, -1))\n      ) {\n        level--\n      }\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children\n\n        // calculate correct end of the content slice in case there's\n        // no tag after the text node.\n        const end = html.indexOf('<', start)\n        const content = html.slice(start, end === -1 ? undefined : end)\n        // if a node is nothing but whitespace, no need to add it.\n        if (!/^\\s*$/.test(content)) {\n          parent.push({\n            type: 'text',\n            content: content,\n          })\n        }\n      }\n    }\n  })\n\n  return result\n}\n", "/* global console */\nimport test from 'tape'\nimport HTML from '../src/index'\n\ntest('parse', function (t) {\n  let html = '<div class=\"oh\"><p></p></div>'\n  let parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'oh',\n      },\n      voidElement: false,\n      children: [\n        {\n          type: 'tag',\n          name: 'p',\n          attrs: {},\n          children: [],\n          voidElement: false,\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div class=\"oh\"><p>hi</p></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'oh',\n      },\n      voidElement: false,\n      children: [\n        {\n          type: 'tag',\n          name: 'p',\n          attrs: {},\n          voidElement: false,\n          children: [\n            {\n              type: 'text',\n              content: 'hi',\n            },\n          ],\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<!-- just a comment node -->'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'comment',\n      comment: ' just a comment node ',\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html =\n    '<div><h2>Comment below this header</h2><!-- just a comment node --></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      name: 'div',\n      type: 'tag',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          attrs: {},\n          name: 'h2',\n          type: 'tag',\n          voidElement: false,\n          children: [\n            {\n              content: 'Comment below this header',\n              type: 'text',\n            },\n          ],\n        },\n        {\n          type: 'comment',\n          comment: ' just a comment node ',\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html =\n    '<div><h2>Comment below this header</h2><!-- just a comment node --><!-- subsequent comment node --></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      name: 'div',\n      type: 'tag',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          attrs: {},\n          name: 'h2',\n          type: 'tag',\n          voidElement: false,\n          children: [\n            {\n              content: 'Comment below this header',\n              type: 'text',\n            },\n          ],\n        },\n        {\n          type: 'comment',\n          comment: ' just a comment node ',\n        },\n        {\n          type: 'comment',\n          comment: ' subsequent comment node ',\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div><h2><!-- comment inside h2 tag --></h2></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      name: 'div',\n      type: 'tag',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          attrs: {},\n          name: 'h2',\n          type: 'tag',\n          voidElement: false,\n          children: [\n            {\n              type: 'comment',\n              comment: ' comment inside h2 tag ',\n            },\n          ],\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<!---->'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'comment',\n      comment: '',\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html =\n    '<!---this comment starts with a hyphen b/c web developers love curveballs -->'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'comment',\n      comment:\n        '-this comment starts with a hyphen b/c web developers love curveballs ',\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div>oh <strong>hello</strong> there! How are <span>you</span>?</div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          type: 'text',\n          content: 'oh ',\n        },\n        {\n          type: 'tag',\n          name: 'strong',\n          attrs: {},\n          voidElement: false,\n          children: [\n            {\n              type: 'text',\n              content: 'hello',\n            },\n          ],\n        },\n        {\n          type: 'text',\n          content: ' there! How are ',\n        },\n        {\n          type: 'tag',\n          name: 'span',\n          attrs: {},\n          voidElement: false,\n          children: [\n            {\n              type: 'text',\n              content: 'you',\n            },\n          ],\n        },\n        {\n          type: 'text',\n          content: '?',\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div class=\"handles multiple classes\" and=\"attributes\"></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'handles multiple classes',\n        and: 'attributes',\n      },\n      voidElement: false,\n      children: [],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div class=\\'handles\\' other=47 and=\"attributes\"></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'handles',\n        other: '47',\n        and: 'attributes',\n      },\n      voidElement: false,\n      children: [],\n    },\n  ])\n  t.equal(\n    HTML.stringify(parsed),\n    '<div class=\"handles\" other=\"47\" and=\"attributes\"></div>'\n  )\n\n  html =\n    '<div-custom class=\"oh\"><my-component some=\"thing\"><p>should be ignored</p></my-component></div-custom>'\n  parsed = HTML.parse(html, {\n    components: {\n      'my-component': 'something',\n    },\n  })\n\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div-custom',\n        attrs: {\n          class: 'oh',\n        },\n        voidElement: false,\n        children: [\n          {\n            type: 'component',\n            name: 'my-component',\n            attrs: {\n              some: 'thing',\n            },\n            voidElement: false,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should not include children of registered components in AST'\n  )\n\n  html =\n    '<div><my-component thing=\"one\">ok</my-component><my-component thing=\"two\">ok</my-component></div>'\n  parsed = HTML.parse(html, {\n    components: {\n      'my-component': 'something',\n    },\n  })\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          type: 'component',\n          name: 'my-component',\n          attrs: {\n            thing: 'one',\n          },\n          voidElement: false,\n          children: [],\n        },\n        {\n          type: 'component',\n          name: 'my-component',\n          attrs: {\n            thing: 'two',\n          },\n          voidElement: false,\n          children: [],\n        },\n      ],\n    },\n  ])\n\n  html = '<div><img></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            type: 'tag',\n            name: 'img',\n            attrs: {},\n            voidElement: true,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should handle unclosed void elements'\n  )\n  t.equal(HTML.stringify(parsed), '<div><img/></div>')\n\n  html = '<div></div><img>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [],\n      },\n      {\n        type: 'tag',\n        name: 'img',\n        attrs: {},\n        voidElement: true,\n        children: [],\n      },\n    ],\n    'should handle multiple root nodes'\n  )\n  t.equal(HTML.stringify(parsed), '<div></div><img/>')\n\n  html = '<div><void-web-component/></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            type: 'tag',\n            name: 'void-web-component',\n            attrs: {},\n            voidElement: true,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should handle custom void tags if self-closing'\n  )\n\n  html = '<div><void-registered-component/></div>'\n  parsed = HTML.parse(html, {\n    components: { 'void-registered-component': true },\n  })\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            type: 'component',\n            name: 'void-registered-component',\n            attrs: {},\n            voidElement: true,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should handle registered void tags if self-closing'\n  )\n\n  html = '<div> 9 <input type=\"text\"/> 10 </div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          { type: 'text', content: ' 9 ' },\n          {\n            type: 'tag',\n            name: 'input',\n            attrs: {\n              type: 'text',\n            },\n            children: [],\n            voidElement: true,\n          },\n          { type: 'text', content: ' 10 ' },\n        ],\n      },\n    ],\n    'should not give voidElements children'\n  )\n\n  html = '<div></div>\\n'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [],\n      },\n    ],\n    'should not explode on trailing whitespace'\n  )\n\n  html = '<div>Hi</div> There '\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi' }],\n      },\n      {\n        type: 'text',\n        content: ' There ',\n      },\n    ],\n    'should handle trailing text nodes at the top-level'\n  )\n\n  html = 'Hi <div>There</div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'text',\n        content: 'Hi ',\n      },\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'There' }],\n      },\n    ],\n    'should handle leading text nodes at the top-level'\n  )\n\n  html = 'Hi There'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'text',\n        content: 'Hi There',\n      },\n    ],\n    'should handle plain strings of text with no tags'\n  )\n\n  html = '<div>Hi</div> There <span>something</span> <a></a>else '\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi' }],\n      },\n      {\n        type: 'text',\n        content: ' There ',\n      },\n      {\n        type: 'tag',\n        name: 'span',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'something' }],\n      },\n      {\n        type: 'tag',\n        name: 'a',\n        attrs: {},\n        voidElement: false,\n        children: [],\n      },\n      {\n        type: 'text',\n        content: 'else ',\n      },\n    ],\n    'should handle text nodes in the middle of tags at the top-level'\n  )\n\n  html = '<div>Hi</div>\\n\\n <span>There</span> \\t '\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi' }],\n      },\n      {\n        type: 'tag',\n        name: 'span',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'There' }],\n      },\n    ],\n    'should remove text nodes that are nothing but whitespace'\n  )\n\n  html = `<script>\n      !function() {\n        var cookies = document.cookie ? document.cookie.split(';') : [];\n        //                |   this less than is triggering probems\n        for (var i = 0; i < cookies.length; i++) {\n          var splitted = cookies[i].split('=');\n          var name = splitted[0];\n        }\n      }();\n      </script>`\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'script',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            content:\n              \"\\n      !function() {\\n        var cookies = document.cookie ? document.cookie.split(';') : [];\\n        //                |   this less than is triggering probems\\n        for (var i = 0; i \",\n            type: 'text',\n          },\n        ],\n      },\n    ],\n    'should parse a script tag'\n  )\n\n  html = `<div onclick=\"alert('hi!')\">Click me!</div>`\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {\n          onclick: \"alert('hi!')\",\n        },\n        voidElement: false,\n        children: [{ content: 'Click me!', type: 'text' }],\n      },\n    ],\n    'should parse attr values with quotes'\n  )\n\n  html = `<div onclick='alert(\"hi!\")'>Click me!</div>`\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {\n          onclick: 'alert(\"hi!\")',\n        },\n        voidElement: false,\n        children: [{ content: 'Click me!', type: 'text' }],\n      },\n    ],\n    'should parse attr values with quotes, opposite'\n  )\n\n  html = '<div>Hi</span>There</div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          { type: 'text', content: 'Hi' },\n          { type: 'text', content: 'There' },\n        ],\n      },\n    ],\n    \"should skip over closing tags that don't match the current tag name\"\n  )\n\n  html = '<p>Hi There</p></span>root text</p><p>Try again</p>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'p',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi There' }],\n      },\n      {\n        type: 'text',\n        content: 'root text',\n      },\n      {\n        type: 'tag',\n        name: 'p',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Try again' }],\n      },\n    ],\n    'should not go lower than the root level (-1)'\n  )\n\n  t.end()\n})\n\ntest('simple speed sanity check', function (t) {\n  var i = 100000\n  var groupSize = 1000\n  var waitLoopSize = 10000000\n  var groups = i / groupSize\n  var html =\n    '<html><head><title>Some page</title></head><body class=\"hey there\"><img src=\"someURL\"><h3>Hey, we need content</h3><br></body></html>'\n\n  var parse = HTML.parse\n  var times = []\n  var count\n  var waitCount\n  var total = 0\n  var start, stepAverage\n\n  console.log('running ' + i + ' iterations...')\n\n  while (i--) {\n    count = groupSize\n    // grab groups\n    if (i % count === 0) {\n      start = Date.now()\n      while (count--) {\n        parse(html)\n      }\n      var diff = Date.now() - start\n      stepAverage = diff / groupSize\n      console.log('group ' + (groups - i / groupSize) + ': ' + stepAverage)\n      times.push(stepAverage)\n      total += stepAverage\n      waitCount = waitLoopSize\n      // forcing a bit of a pause between tests\n      while (waitCount--) {}\n    }\n  }\n\n  // trim off first\n  // it's always a slower outlier\n  // with higher variability that\n  // makes it harder to find differences\n  times.shift()\n\n  var max = Math.max.apply(null, times)\n  var min = Math.min.apply(null, times)\n  var average = total / times.length\n\n  console.log('max', max)\n  console.log('min', min)\n  console.log('avg', average)\n\n  t.end()\n})\n"], "fixing_code": ["# html-parse-stringify\n\nThis is an _experimental lightweight approach_ to enable quickly parsing HTML into an AST and stringify'ing it back to the original string.\n\nAs it turns out, if you can make a the simplifying assumptions about HTML that all tags must be closed or self-closing. Which is OK for _this_ particular application. You can write a super light/fast parser in JS with regex.\n\n\"Why on earth would you do this?! Haven't you read: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags ?!?!\"\n\nWhy yes, yes I have :)\n\nBut the truth is. If you _could_ do this in a whopping grand total of ~600 bytes (min+gzip) as this repo shows. It potentially enables DOM diffing based on a HTML strings to be super light and fast in a browser. What is that you say? DOM-diffing?\n\nYes.\n\nReact.js essentially pioneered the approach. With React you render to a \"virtual DOM\" whenever you want to, and the virtual DOM can then diff against the real DOM (or the last virtual DOM) and then turn that diff into whatever transformations are necessary to get the _real_ DOM to match what you rendered as efficiently as possible.\n\nAs a result, when you're building a single page app, you don't have to worry so much about bindings. Instead, you simple re-render to the virtual DOM whenever you know something's changed. All of a sudden being able to have `change` events for individual properties becomes less important, instead you can just reference those values in your template whenever you think something changed.\n\nCool idea, right?!\n\n## So why this?\n\nWell, there are other things React expects me to do if I use it that I don't like. Such as the custom templating and syntax you have to use.\n\nIf, hypothetically, you could instead diff an HTML string (generated by _whatever_ templating language of your choice) against the DOM, then you'd get the same benefit, sans React's impositions.\n\nThis may all turn out to be a bad idea altogether, but initial results seem promising when paired with [virtual-dom](https://github.com/Matt-Esch/virtual-dom).\n\nBut you can't just diff HTML strings, as simple strings, very easily, in order to diff two HTML node trees you have to first turn that string into a tree structure of some sort. Typically, the thing you generate from parsing something like this is called an AST (abstract syntax tree).\n\nThis lib does exactly that.\n\nIt has two methods:\n\n1. parse\n2. stringify\n\n## `.parse(htmlString, options)`\n\nTakes a string of HTML and turns it into an AST, the only option you can currently pass is an object of registered `components` whose children will be ignored when generating the AST.\n\n## `.stringify(AST)`\n\nTakes an AST and turns it back into a string of HTML.\n\n## What does the AST look like?\n\nSee comments in the following example:\n\n```js\nvar HTML = require('html-parse-stringify')\n\n// this html:\nvar html = '<div class=\"oh\"><p>hi</p></div>'\n\n// becomes this AST:\nvar ast = HTML.parse(html)\n\nconsole.log(ast)\n/*\n{\n    // can be `tag`, `text` or `component`\n    type: 'tag',\n\n    // name of tag if relevant\n    name: 'div',\n    \n    // parsed attribute object\n    attrs: {\n        class: 'oh'\n    },\n\n    // whether this is a self-closing tag\n    // such as <img/>\n    voidElement: false,\n\n    // an array of child nodes\n    // we see the same structure\n    // repeated in each of these\n    children: [\n        {\n            type: 'tag',\n            name: 'p',\n            attrs: {},\n            voidElement: false,\n            children: [\n                // this is a text node\n                // it also has a `type`\n                // but nothing other than\n                // a `content` containing\n                // its text.\n                {\n                    type: 'text',\n                    content: 'hi'\n                }\n            ]\n        }\n    ]\n}\n*/\n```\n\n## the AST node types\n\n### 1. tag\n\nproperties:\n\n- `type` - will always be `tag` for this type of node\n- `name` - tag name, such as 'div'\n- `attrs` - an object of key/value pairs. If an attribute has multiple space-separated items such as classes, they'll still be in a single string, for example: `class: \"class1 class2\"`\n- `voidElement` - `true` or `false`. Whether this tag is a known void element as defined by [spec](http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements).\n- `children` - array of child nodes. Note that any continuous string of text is a text node child, see below.\n\n### 2. text\n\nproperties:\n\n- `type` - will always be `text` for this type of node\n- `content` - text content of the node\n\n### 3. component\n\nIf you pass an object of `components` as part of the `options` object passed as the second argument to `.parse()` then the AST won't keep parsing that branch of the DOM tree when it one of those registered components.\n\nThis is so that it's possible to ignore sections of the tree that you may want to handle by another \"subview\" in your application that handles it's own DOM diffing.\n\nproperties:\n\n- `type` - will always be `component` for this type of node\n- `name` - tag name, such as 'div'\n- `attrs` - an object of key/value pairs. If an attribute has multiple space-separated items such as classes, they'll still be in a single string, for example: `class: \"class1 class2\"`\n- `voidElement` - `true` or `false`. Whether this tag is a known void element as defined by [spec](http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements).\n- `children` - it will still have a `children` array, but it will always be empty.\n\n## changelog\n\n- `2.0.1` Addressing a reported regular expression denial of service issue reported by [Sam Sanoop](https://twitter.com/snoopysecurity) of [Snyk](https://snyk.io/) THANK YOU!. The issue was that sending certain input would cause one of the regular expressions we used to lock up and not finish, freezing the process. See the test that was added for details. To be clear, this lib wasn't meant for parsing non-well formed HTML. But, better safe than sorry! So we're fixing it.\n- `2.0.0` updated to more modern dependencies/build system. Switched to prettier, etc. No big feature differences, just new build system/project structure. Added support for top level text nodes thanks to @jperl. Added support for comments thanks to @pconerly.\n- `1.0.0 - 1.0.3` no big changes, bug fixes and speed improvements.\n\n## credits\n\nIf this sounds interesting you should probably follow [@HenrikJoreteg](https://twitter.com/henrikjoreteg) and [@Philip_Roberts](https://twitter.com/philip_roberts) on twitter to see how this all turns out.\n\n## license\n\nMIT\n", "const tagRE = /<[a-zA-Z\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g\nimport parseTag from './parse-tag'\n\n// re-used obj for quick lookups of components\nconst empty = Object.create(null)\n\nexport default function parse(html, options) {\n  options || (options = {})\n  options.components || (options.components = empty)\n  const result = []\n  const arr = []\n  let current\n  let level = -1\n  let inComponent = false\n\n  // handle text at top level\n  if (html.indexOf('<') !== 0) {\n    var end = html.indexOf('<')\n    result.push({\n      type: 'text',\n      content: end === -1 ? html : html.substring(0, end),\n    })\n  }\n\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return\n      } else {\n        inComponent = false\n      }\n    }\n    const isOpen = tag.charAt(1) !== '/'\n    const isComment = tag.startsWith('<!--')\n    const start = index + tag.length\n    const nextChar = html.charAt(start)\n    let parent\n\n    if (isComment) {\n      const comment = parseTag(tag)\n\n      // if we're at root, push new base node\n      if (level < 0) {\n        result.push(comment)\n        return result\n      }\n      parent = arr[level]\n      parent.children.push(comment)\n      return result\n    }\n\n    if (isOpen) {\n      level++\n\n      current = parseTag(tag)\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component'\n        inComponent = true\n      }\n\n      if (\n        !current.voidElement &&\n        !inComponent &&\n        nextChar &&\n        nextChar !== '<'\n      ) {\n        current.children.push({\n          type: 'text',\n          content: html.slice(start, html.indexOf('<', start)),\n        })\n      }\n\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current)\n      }\n\n      parent = arr[level - 1]\n\n      if (parent) {\n        parent.children.push(current)\n      }\n\n      arr[level] = current\n    }\n\n    if (!isOpen || current.voidElement) {\n      if (\n        level > -1 &&\n        (current.voidElement || current.name === tag.slice(2, -1))\n      ) {\n        level--\n      }\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children\n\n        // calculate correct end of the content slice in case there's\n        // no tag after the text node.\n        const end = html.indexOf('<', start)\n        const content = html.slice(start, end === -1 ? undefined : end)\n        // if a node is nothing but whitespace, no need to add it.\n        if (!/^\\s*$/.test(content)) {\n          parent.push({\n            type: 'text',\n            content: content,\n          })\n        }\n      }\n    }\n  })\n\n  return result\n}\n", "/* global console */\nimport test from 'tape'\nimport HTML from '../src/index'\n\ntest('parse', function (t) {\n  let html = '<div class=\"oh\"><p></p></div>'\n  let parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'oh',\n      },\n      voidElement: false,\n      children: [\n        {\n          type: 'tag',\n          name: 'p',\n          attrs: {},\n          children: [],\n          voidElement: false,\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div class=\"oh\"><p>hi</p></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'oh',\n      },\n      voidElement: false,\n      children: [\n        {\n          type: 'tag',\n          name: 'p',\n          attrs: {},\n          voidElement: false,\n          children: [\n            {\n              type: 'text',\n              content: 'hi',\n            },\n          ],\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<!-- just a comment node -->'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'comment',\n      comment: ' just a comment node ',\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html =\n    '<div><h2>Comment below this header</h2><!-- just a comment node --></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      name: 'div',\n      type: 'tag',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          attrs: {},\n          name: 'h2',\n          type: 'tag',\n          voidElement: false,\n          children: [\n            {\n              content: 'Comment below this header',\n              type: 'text',\n            },\n          ],\n        },\n        {\n          type: 'comment',\n          comment: ' just a comment node ',\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html =\n    '<div><h2>Comment below this header</h2><!-- just a comment node --><!-- subsequent comment node --></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      name: 'div',\n      type: 'tag',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          attrs: {},\n          name: 'h2',\n          type: 'tag',\n          voidElement: false,\n          children: [\n            {\n              content: 'Comment below this header',\n              type: 'text',\n            },\n          ],\n        },\n        {\n          type: 'comment',\n          comment: ' just a comment node ',\n        },\n        {\n          type: 'comment',\n          comment: ' subsequent comment node ',\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div><h2><!-- comment inside h2 tag --></h2></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      name: 'div',\n      type: 'tag',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          attrs: {},\n          name: 'h2',\n          type: 'tag',\n          voidElement: false,\n          children: [\n            {\n              type: 'comment',\n              comment: ' comment inside h2 tag ',\n            },\n          ],\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<!---->'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'comment',\n      comment: '',\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html =\n    '<!---this comment starts with a hyphen b/c web developers love curveballs -->'\n  parsed = HTML.parse(html)\n  t.deepEqual(parsed, [\n    {\n      type: 'comment',\n      comment:\n        '-this comment starts with a hyphen b/c web developers love curveballs ',\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div>oh <strong>hello</strong> there! How are <span>you</span>?</div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          type: 'text',\n          content: 'oh ',\n        },\n        {\n          type: 'tag',\n          name: 'strong',\n          attrs: {},\n          voidElement: false,\n          children: [\n            {\n              type: 'text',\n              content: 'hello',\n            },\n          ],\n        },\n        {\n          type: 'text',\n          content: ' there! How are ',\n        },\n        {\n          type: 'tag',\n          name: 'span',\n          attrs: {},\n          voidElement: false,\n          children: [\n            {\n              type: 'text',\n              content: 'you',\n            },\n          ],\n        },\n        {\n          type: 'text',\n          content: '?',\n        },\n      ],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div class=\"handles multiple classes\" and=\"attributes\"></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'handles multiple classes',\n        and: 'attributes',\n      },\n      voidElement: false,\n      children: [],\n    },\n  ])\n  t.equal(html, HTML.stringify(parsed))\n\n  html = '<div class=\\'handles\\' other=47 and=\"attributes\"></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {\n        class: 'handles',\n        other: '47',\n        and: 'attributes',\n      },\n      voidElement: false,\n      children: [],\n    },\n  ])\n  t.equal(\n    HTML.stringify(parsed),\n    '<div class=\"handles\" other=\"47\" and=\"attributes\"></div>'\n  )\n\n  html =\n    '<div-custom class=\"oh\"><my-component some=\"thing\"><p>should be ignored</p></my-component></div-custom>'\n  parsed = HTML.parse(html, {\n    components: {\n      'my-component': 'something',\n    },\n  })\n\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div-custom',\n        attrs: {\n          class: 'oh',\n        },\n        voidElement: false,\n        children: [\n          {\n            type: 'component',\n            name: 'my-component',\n            attrs: {\n              some: 'thing',\n            },\n            voidElement: false,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should not include children of registered components in AST'\n  )\n\n  html =\n    '<div><my-component thing=\"one\">ok</my-component><my-component thing=\"two\">ok</my-component></div>'\n  parsed = HTML.parse(html, {\n    components: {\n      'my-component': 'something',\n    },\n  })\n\n  t.deepEqual(parsed, [\n    {\n      type: 'tag',\n      name: 'div',\n      attrs: {},\n      voidElement: false,\n      children: [\n        {\n          type: 'component',\n          name: 'my-component',\n          attrs: {\n            thing: 'one',\n          },\n          voidElement: false,\n          children: [],\n        },\n        {\n          type: 'component',\n          name: 'my-component',\n          attrs: {\n            thing: 'two',\n          },\n          voidElement: false,\n          children: [],\n        },\n      ],\n    },\n  ])\n\n  html = '<div><img></div>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            type: 'tag',\n            name: 'img',\n            attrs: {},\n            voidElement: true,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should handle unclosed void elements'\n  )\n  t.equal(HTML.stringify(parsed), '<div><img/></div>')\n\n  html = '<div></div><img>'\n  parsed = HTML.parse(html)\n\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [],\n      },\n      {\n        type: 'tag',\n        name: 'img',\n        attrs: {},\n        voidElement: true,\n        children: [],\n      },\n    ],\n    'should handle multiple root nodes'\n  )\n  t.equal(HTML.stringify(parsed), '<div></div><img/>')\n\n  html = '<div><void-web-component/></div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            type: 'tag',\n            name: 'void-web-component',\n            attrs: {},\n            voidElement: true,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should handle custom void tags if self-closing'\n  )\n\n  html = '<div><void-registered-component/></div>'\n  parsed = HTML.parse(html, {\n    components: { 'void-registered-component': true },\n  })\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            type: 'component',\n            name: 'void-registered-component',\n            attrs: {},\n            voidElement: true,\n            children: [],\n          },\n        ],\n      },\n    ],\n    'should handle registered void tags if self-closing'\n  )\n\n  html = '<div> 9 <input type=\"text\"/> 10 </div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          { type: 'text', content: ' 9 ' },\n          {\n            type: 'tag',\n            name: 'input',\n            attrs: {\n              type: 'text',\n            },\n            children: [],\n            voidElement: true,\n          },\n          { type: 'text', content: ' 10 ' },\n        ],\n      },\n    ],\n    'should not give voidElements children'\n  )\n\n  html = '<div></div>\\n'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [],\n      },\n    ],\n    'should not explode on trailing whitespace'\n  )\n\n  html = '<div>Hi</div> There '\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi' }],\n      },\n      {\n        type: 'text',\n        content: ' There ',\n      },\n    ],\n    'should handle trailing text nodes at the top-level'\n  )\n\n  html = 'Hi <div>There</div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'text',\n        content: 'Hi ',\n      },\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'There' }],\n      },\n    ],\n    'should handle leading text nodes at the top-level'\n  )\n\n  html = 'Hi There'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'text',\n        content: 'Hi There',\n      },\n    ],\n    'should handle plain strings of text with no tags'\n  )\n\n  html = '<div>Hi</div> There <span>something</span> <a></a>else '\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi' }],\n      },\n      {\n        type: 'text',\n        content: ' There ',\n      },\n      {\n        type: 'tag',\n        name: 'span',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'something' }],\n      },\n      {\n        type: 'tag',\n        name: 'a',\n        attrs: {},\n        voidElement: false,\n        children: [],\n      },\n      {\n        type: 'text',\n        content: 'else ',\n      },\n    ],\n    'should handle text nodes in the middle of tags at the top-level'\n  )\n\n  html = '<div>Hi</div>\\n\\n <span>There</span> \\t '\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi' }],\n      },\n      {\n        type: 'tag',\n        name: 'span',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'There' }],\n      },\n    ],\n    'should remove text nodes that are nothing but whitespace'\n  )\n\n  html = `<script>\n      !function() {\n        var cookies = document.cookie ? document.cookie.split(';') : [];\n        //                |   this less than is triggering probems\n        for (var i = 0; i < cookies.length; i++) {\n          var splitted = cookies[i].split('=');\n          var name = splitted[0];\n        }\n      }();\n      </script>`\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'script',\n        attrs: {},\n        voidElement: false,\n        children: [\n          {\n            content:\n              \"\\n      !function() {\\n        var cookies = document.cookie ? document.cookie.split(';') : [];\\n        //                |   this less than is triggering probems\\n        for (var i = 0; i \",\n            type: 'text',\n          },\n        ],\n      },\n    ],\n    'should parse a script tag'\n  )\n\n  html = `<div onclick=\"alert('hi!')\">Click me!</div>`\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {\n          onclick: \"alert('hi!')\",\n        },\n        voidElement: false,\n        children: [{ content: 'Click me!', type: 'text' }],\n      },\n    ],\n    'should parse attr values with quotes'\n  )\n\n  html = `<div onclick='alert(\"hi!\")'>Click me!</div>`\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {\n          onclick: 'alert(\"hi!\")',\n        },\n        voidElement: false,\n        children: [{ content: 'Click me!', type: 'text' }],\n      },\n    ],\n    'should parse attr values with quotes, opposite'\n  )\n\n  html = '<div>Hi</span>There</div>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'div',\n        attrs: {},\n        voidElement: false,\n        children: [\n          { type: 'text', content: 'Hi' },\n          { type: 'text', content: 'There' },\n        ],\n      },\n    ],\n    \"should skip over closing tags that don't match the current tag name\"\n  )\n\n  html = '<p>Hi There</p></span>root text</p><p>Try again</p>'\n  parsed = HTML.parse(html)\n  t.deepEqual(\n    parsed,\n    [\n      {\n        type: 'tag',\n        name: 'p',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Hi There' }],\n      },\n      {\n        type: 'text',\n        content: 'root text',\n      },\n      {\n        type: 'tag',\n        name: 'p',\n        attrs: {},\n        voidElement: false,\n        children: [{ type: 'text', content: 'Try again' }],\n      },\n    ],\n    'should not go lower than the root level (-1)'\n  )\n\n  t.end()\n})\n\ntest('simple speed sanity check', function (t) {\n  var i = 100000\n  var groupSize = 1000\n  var waitLoopSize = 10000000\n  var groups = i / groupSize\n  var html =\n    '<html><head><title>Some page</title></head><body class=\"hey there\"><img src=\"someURL\"><h3>Hey, we need content</h3><br></body></html>'\n\n  var parse = HTML.parse\n  var times = []\n  var count\n  var waitCount\n  var total = 0\n  var start, stepAverage\n\n  console.log('running ' + i + ' iterations...')\n\n  while (i--) {\n    count = groupSize\n    // grab groups\n    if (i % count === 0) {\n      start = Date.now()\n      while (count--) {\n        parse(html)\n      }\n      var diff = Date.now() - start\n      stepAverage = diff / groupSize\n      console.log('group ' + (groups - i / groupSize) + ': ' + stepAverage)\n      times.push(stepAverage)\n      total += stepAverage\n      waitCount = waitLoopSize\n      // forcing a bit of a pause between tests\n      while (waitCount--) {}\n    }\n  }\n\n  // trim off first\n  // it's always a slower outlier\n  // with higher variability that\n  // makes it harder to find differences\n  times.shift()\n\n  var max = Math.max.apply(null, times)\n  var min = Math.min.apply(null, times)\n  var average = total / times.length\n\n  console.log('max', max)\n  console.log('min', min)\n  console.log('avg', average)\n\n  t.end()\n})\n\ntest('ReDoS vulnerability reported by Sam Sanoop of Snyk', function (t) {\n  const start = Date.now()\n  // reported problematic string\n  HTML.parse(\n    \"<!''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''!\"\n  )\n  // other variant\n  HTML.parse(\n    '<!\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"!'\n  )\n  const duration = Date.now() - start\n\n  t.ok(duration < 100, 'should not hang')\n  t.end()\n})\n"], "buggy_code_start_loc": [137, 1, 768], "buggy_code_end_loc": [137, 2, 768], "fixing_code_start_loc": [138, 1, 769], "fixing_code_end_loc": [139, 2, 785], "type": "NVD-CWE-Other", "message": "This affects the package html-parse-stringify before 2.0.1; all versions of package html-parse-stringify2. Sending certain input could cause one of the regular expressions that is used for parsing to backtrack, freezing the process.", "other": {"cve": {"id": "CVE-2021-23346", "sourceIdentifier": "report@snyk.io", "published": "2021-03-04T17:15:13.700", "lastModified": "2021-03-09T14:58:57.520", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package html-parse-stringify before 2.0.1; all versions of package html-parse-stringify2. Sending certain input could cause one of the regular expressions that is used for parsing to backtrack, freezing the process."}, {"lang": "es", "value": "Esto afecta al paquete html-parse-stringify versiones anteriores a 2.0.1;&#xa0;todas las versiones del paquete html-parse-stringify2.&#xa0;Enviando determinada entrada podr\u00eda causar que una de las expresiones regulares que son usadas para analizar el retroceso, congele el proceso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:html-parse-stringify_project:html-parse-stringify:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.1", "matchCriteriaId": "DA04DAE6-E193-476E-8EB7-58DA48AE1E1B"}]}]}], "references": [{"url": "https://github.com/HenrikJoreteg/html-parse-stringify/blob/master/lib/parse.js%23L2", "source": "report@snyk.io", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://github.com/HenrikJoreteg/html-parse-stringify/commit/c7274a48e59c92b2b7e906fedf9065159e73fe12", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rayd/html-parse-stringify2/blob/master/lib/parse.js%23L2", "source": "report@snyk.io", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1080633", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-HTMLPARSESTRINGIFY-1079306", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-HTMLPARSESTRINGIFY2-1079307", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/HenrikJoreteg/html-parse-stringify/commit/c7274a48e59c92b2b7e906fedf9065159e73fe12"}}