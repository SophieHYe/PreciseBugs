{"buggy_code": ["<?php\n\nnamespace Knp\\Snappy;\n\nuse Knp\\Snappy\\Exception\\FileAlreadyExistsException;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\Process\\Process;\nuse Exception;\nuse LogicException;\nuse RuntimeException;\nuse InvalidArgumentException;\n\n/**\n * Base generator class for medias.\n *\n * @author  Matthieu Bontemps <matthieu.bontemps@knplabs.com>\n * @author  Antoine H\u00e9rault <antoine.herault@knplabs.com>\n */\nabstract class AbstractGenerator implements GeneratorInterface, LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    /**\n     * @var array\n     */\n    public $temporaryFiles = [];\n\n    /**\n     * @var string\n     */\n    protected $temporaryFolder;\n\n    /**\n     * @var null|string\n     */\n    private $binary;\n\n    /**\n     * @var array\n     */\n    private $options = [];\n\n    /**\n     * @var null|array\n     */\n    private $env;\n\n    /**\n     * @var null|int\n     */\n    private $timeout;\n\n    /**\n     * @var string\n     */\n    private $defaultExtension;\n\n    /**\n     * @param null|string $binary\n     * @param array       $options\n     * @param null|array  $env\n     */\n    public function __construct($binary, array $options = [], array $env = null)\n    {\n        $this->configure();\n\n        $this->setBinary($binary);\n        $this->setOptions($options);\n        $this->env = empty($env) ? null : $env;\n\n        if (\\is_callable([$this, 'removeTemporaryFiles'])) {\n            \\register_shutdown_function([$this, 'removeTemporaryFiles']);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->removeTemporaryFiles();\n    }\n\n    /**\n     * Sets the default extension.\n     * Useful when letting Snappy deal with file creation.\n     *\n     * @param string $defaultExtension\n     *\n     * @return $this\n     */\n    public function setDefaultExtension($defaultExtension)\n    {\n        $this->defaultExtension = $defaultExtension;\n\n        return $this;\n    }\n\n    /**\n     * Gets the default extension.\n     *\n     * @return string\n     */\n    public function getDefaultExtension(): string\n    {\n        return $this->defaultExtension;\n    }\n\n    /**\n     * Sets an option. Be aware that option values are NOT validated and that\n     * it is your responsibility to validate user inputs.\n     *\n     * @param string $name  The option to set\n     * @param mixed  $value The value (NULL to unset)\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    public function setOption($name, $value)\n    {\n        if (!\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n        }\n\n        $this->options[$name] = $value;\n\n        if (null !== $this->logger) {\n            $this->logger->debug(\\sprintf('Set option \"%s\".', $name), ['value' => $value]);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the timeout.\n     *\n     * @param null|int $timeout The timeout to set\n     *\n     * @return $this\n     */\n    public function setTimeout($timeout)\n    {\n        $this->timeout = $timeout;\n\n        return $this;\n    }\n\n    /**\n     * Sets an array of options.\n     *\n     * @param array $options An associative array of options as name/value\n     *\n     * @return $this\n     */\n    public function setOptions(array $options)\n    {\n        foreach ($options as $name => $value) {\n            $this->setOption($name, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns all the options.\n     *\n     * @return array\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generate($input, $output, array $options = [], $overwrite = false)\n    {\n        $this->prepareOutput($output, $overwrite);\n\n        $command = $this->getCommand($input, $output, $options);\n\n        $inputFiles = \\is_array($input) ? \\implode('\", \"', $input) : $input;\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('Generate from file(s) \"%s\" to file \"%s\".', $inputFiles, $output), [\n                'command' => $command,\n                'env' => $this->env,\n                'timeout' => $this->timeout,\n            ]);\n        }\n\n        try {\n            list($status, $stdout, $stderr) = $this->executeCommand($command);\n            $this->checkProcessStatus($status, $stdout, $stderr, $command);\n            $this->checkOutput($output, $command);\n        } catch (Exception $e) {\n            if (null !== $this->logger) {\n                $this->logger->error(\\sprintf('An error happened while generating \"%s\".', $output), [\n                    'command' => $command,\n                    'status' => $status ?? null,\n                    'stdout' => $stdout ?? null,\n                    'stderr' => $stderr ?? null,\n                ]);\n            }\n\n            throw $e;\n        }\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('File \"%s\" has been successfully generated.', $output), [\n                'command' => $command,\n                'stdout' => $stdout,\n                'stderr' => $stderr,\n            ]);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generateFromHtml($html, $output, array $options = [], $overwrite = false)\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        $this->generate($fileNames, $output, $options, $overwrite);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutput($input, array $options = [])\n    {\n        $filename = $this->createTemporaryFile(null, $this->getDefaultExtension());\n\n        $this->generate($input, $filename, $options);\n\n        return $this->getFileContents($filename);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutputFromHtml($html, array $options = [])\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        return $this->getOutput($fileNames, $options);\n    }\n\n    /**\n     * Defines the binary.\n     *\n     * @param null|string $binary The path/name of the binary\n     *\n     * @return $this\n     */\n    public function setBinary($binary)\n    {\n        $this->binary = $binary;\n\n        return $this;\n    }\n\n    /**\n     * Returns the binary.\n     *\n     * @return null|string\n     */\n    public function getBinary()\n    {\n        return $this->binary;\n    }\n\n    /**\n     * Returns the command for the given input and output files.\n     *\n     * @param array|string $input   The input file\n     * @param string       $output  The ouput file\n     * @param array        $options An optional array of options that will be used\n     *                              only for this command\n     *\n     * @return string\n     */\n    public function getCommand($input, $output, array $options = [])\n    {\n        if (null === $this->binary) {\n            throw new LogicException('You must define a binary prior to conversion.');\n        }\n\n        $options = $this->mergeOptions($options);\n\n        return $this->buildCommand($this->binary, $input, $output, $options);\n    }\n\n    /**\n     * Removes all temporary files.\n     *\n     * @return void\n     */\n    public function removeTemporaryFiles()\n    {\n        foreach ($this->temporaryFiles as $file) {\n            $this->unlink($file);\n        }\n    }\n\n    /**\n     * Get TemporaryFolder.\n     *\n     * @return string\n     */\n    public function getTemporaryFolder()\n    {\n        if ($this->temporaryFolder === null) {\n            return \\sys_get_temp_dir();\n        }\n\n        return $this->temporaryFolder;\n    }\n\n    /**\n     * Set temporaryFolder.\n     *\n     * @param string $temporaryFolder\n     *\n     * @return $this\n     */\n    public function setTemporaryFolder($temporaryFolder)\n    {\n        $this->temporaryFolder = $temporaryFolder;\n\n        return $this;\n    }\n\n    /**\n     * Reset all options to their initial values.\n     *\n     * @return void\n     */\n    public function resetOptions()\n    {\n        $this->options = [];\n        $this->configure();\n    }\n\n    /**\n     * This method must configure the media options.\n     *\n     * @return void\n     *\n     * @see AbstractGenerator::addOption()\n     */\n    abstract protected function configure();\n\n    /**\n     * Adds an option.\n     *\n     * @param string $name    The name\n     * @param mixed  $default An optional default value\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    protected function addOption($name, $default = null)\n    {\n        if (\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' already exists.', $name));\n        }\n\n        $this->options[$name] = $default;\n\n        return $this;\n    }\n\n    /**\n     * Adds an array of options.\n     *\n     * @param array $options\n     *\n     * @return $this\n     */\n    protected function addOptions(array $options)\n    {\n        foreach ($options as $name => $default) {\n            $this->addOption($name, $default);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Merges the given array of options to the instance options and returns\n     * the result options array. It does NOT change the instance options.\n     *\n     * @param array $options\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function mergeOptions(array $options)\n    {\n        $mergedOptions = $this->options;\n\n        foreach ($options as $name => $value) {\n            if (!\\array_key_exists($name, $mergedOptions)) {\n                throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n            }\n\n            $mergedOptions[$name] = $value;\n        }\n\n        return $mergedOptions;\n    }\n\n    /**\n     * Checks the specified output.\n     *\n     * @param string $output  The output filename\n     * @param string $command The generation command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkOutput($output, $command)\n    {\n        // the output file must exist\n        if (!$this->fileExists($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was not created (command: %s).', $output, $command));\n        }\n\n        // the output file must not be empty\n        if (0 === $this->filesize($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was created but is empty (command: %s).', $output, $command));\n        }\n    }\n\n    /**\n     * Checks the process return status.\n     *\n     * @param int    $status  The exit status code\n     * @param string $stdout  The stdout content\n     * @param string $stderr  The stderr content\n     * @param string $command The run command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkProcessStatus($status, $stdout, $stderr, $command)\n    {\n        if (0 !== $status && '' !== $stderr) {\n            throw new RuntimeException(\\sprintf('The exit status code \\'%s\\' says something went wrong:' . \"\\n\" . 'stderr: \"%s\"' . \"\\n\" . 'stdout: \"%s\"' . \"\\n\" . 'command: %s.', $status, $stderr, $stdout, $command), $status);\n        }\n    }\n\n    /**\n     * Creates a temporary file.\n     * The file is not created if the $content argument is null.\n     *\n     * @param null|string $content   Optional content for the temporary file\n     * @param null|string $extension An optional extension for the filename\n     *\n     * @return string The filename\n     */\n    protected function createTemporaryFile($content = null, $extension = null)\n    {\n        $dir = \\rtrim($this->getTemporaryFolder(), \\DIRECTORY_SEPARATOR);\n\n        if (!\\is_dir($dir)) {\n            if (false === @\\mkdir($dir, 0777, true) && !\\is_dir($dir)) {\n                throw new RuntimeException(\\sprintf(\"Unable to create directory: %s\\n\", $dir));\n            }\n        } elseif (!\\is_writable($dir)) {\n            throw new RuntimeException(\\sprintf(\"Unable to write in directory: %s\\n\", $dir));\n        }\n\n        $filename = $dir . \\DIRECTORY_SEPARATOR . \\uniqid('knp_snappy', true);\n\n        if (null !== $extension) {\n            $filename .= '.' . $extension;\n        }\n\n        if (null !== $content) {\n            \\file_put_contents($filename, $content);\n        }\n\n        $this->temporaryFiles[] = $filename;\n\n        return $filename;\n    }\n\n    /**\n     * Builds the command string.\n     *\n     * @param string       $binary  The binary path/name\n     * @param array|string $input   Url(s) or file location(s) of the page(s) to process\n     * @param string       $output  File location to the image-to-be\n     * @param array        $options An array of options\n     *\n     * @return string\n     */\n    protected function buildCommand($binary, $input, $output, array $options = [])\n    {\n        $command = $binary;\n        $escapedBinary = \\escapeshellarg($binary);\n        if (\\is_executable($escapedBinary)) {\n            $command = $escapedBinary;\n        }\n\n        foreach ($options as $key => $option) {\n            if (null !== $option && false !== $option) {\n                if (true === $option) {\n                    // Dont't put '--' if option is 'toc'.\n                    if ($key === 'toc') {\n                        $command .= ' ' . $key;\n                    } else {\n                        $command .= ' --' . $key;\n                    }\n                } elseif (\\is_array($option)) {\n                    if ($this->isAssociativeArray($option)) {\n                        foreach ($option as $k => $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($k) . ' ' . \\escapeshellarg($v);\n                        }\n                    } else {\n                        foreach ($option as $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($v);\n                        }\n                    }\n                } else {\n                    // Dont't add '--' if option is \"cover\"  or \"toc\".\n                    if (\\in_array($key, ['toc', 'cover'])) {\n                        $command .= ' ' . $key . ' ' . \\escapeshellarg($option);\n                    } elseif (\\in_array($key, ['image-dpi', 'image-quality'])) {\n                        $command .= ' --' . $key . ' ' . (int) $option;\n                    } else {\n                        $command .= ' --' . $key . ' ' . \\escapeshellarg($option);\n                    }\n                }\n            }\n        }\n\n        if (\\is_array($input)) {\n            foreach ($input as $i) {\n                $command .= ' ' . \\escapeshellarg($i) . ' ';\n            }\n            $command .= \\escapeshellarg($output);\n        } else {\n            $command .= ' ' . \\escapeshellarg($input) . ' ' . \\escapeshellarg($output);\n        }\n\n        return $command;\n    }\n\n    /**\n     * Return true if the array is an associative array\n     * and not an indexed array.\n     *\n     * @param array $array\n     *\n     * @return bool\n     */\n    protected function isAssociativeArray(array $array)\n    {\n        return (bool) \\count(\\array_filter(\\array_keys($array), 'is_string'));\n    }\n\n    /**\n     * Executes the given command via shell and returns the complete output as\n     * a string.\n     *\n     * @param string $command\n     *\n     * @return array [status, stdout, stderr]\n     */\n    protected function executeCommand($command)\n    {\n        if (\\method_exists(Process::class, 'fromShellCommandline')) {\n            $process = Process::fromShellCommandline($command, null, $this->env);\n        } else {\n            $process = new Process($command, null, $this->env);\n        }\n\n        if (null !== $this->timeout) {\n            $process->setTimeout($this->timeout);\n        }\n\n        $process->run();\n\n        return [\n            $process->getExitCode(),\n            $process->getOutput(),\n            $process->getErrorOutput(),\n        ];\n    }\n\n    /**\n     * Prepares the specified output.\n     *\n     * @param string $filename  The output filename\n     * @param bool   $overwrite Whether to overwrite the file if it already\n     *                          exist\n     *\n     * @throws FileAlreadyExistsException\n     * @throws RuntimeException\n     * @throws InvalidArgumentException\n     *\n     * @return void\n     */\n    protected function prepareOutput($filename, $overwrite)\n    {\n        $directory = \\dirname($filename);\n\n        if ($this->fileExists($filename)) {\n            if (!$this->isFile($filename)) {\n                throw new InvalidArgumentException(\\sprintf('The output file \\'%s\\' already exists and it is a %s.', $filename, $this->isDir($filename) ? 'directory' : 'link'));\n            }\n            if (false === $overwrite) {\n                throw new FileAlreadyExistsException(\\sprintf('The output file \\'%s\\' already exists.', $filename));\n            }\n            if (!$this->unlink($filename)) {\n                throw new RuntimeException(\\sprintf('Could not delete already existing output file \\'%s\\'.', $filename));\n            }\n        } elseif (!$this->isDir($directory) && !$this->mkdir($directory)) {\n            throw new RuntimeException(\\sprintf('The output file\\'s directory \\'%s\\' could not be created.', $directory));\n        }\n    }\n\n    /**\n     * Wrapper for the \"file_get_contents\" function.\n     *\n     * @param string $filename\n     *\n     * @return string\n     */\n    protected function getFileContents($filename)\n    {\n        $fileContent = \\file_get_contents($filename);\n\n        if (false === $fileContent) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' content.', $filename));\n        }\n\n        return $fileContent;\n    }\n\n    /**\n     * Wrapper for the \"file_exists\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function fileExists($filename)\n    {\n        return \\file_exists($filename);\n    }\n\n    /**\n     * Wrapper for the \"is_file\" method.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isFile($filename)\n    {\n        return \\strlen($filename) <= \\PHP_MAXPATHLEN && \\is_file($filename);\n    }\n\n    /**\n     * Wrapper for the \"filesize\" function.\n     *\n     * @param string $filename\n     *\n     * @return int\n     */\n    protected function filesize($filename)\n    {\n        $filesize = \\filesize($filename);\n\n        if (false === $filesize) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' size.', $filename));\n        }\n\n        return $filesize;\n    }\n\n    /**\n     * Wrapper for the \"unlink\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function unlink($filename)\n    {\n        return $this->fileExists($filename) ? \\unlink($filename) : false;\n    }\n\n    /**\n     * Wrapper for the \"is_dir\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isDir($filename)\n    {\n        return \\is_dir($filename);\n    }\n\n    /**\n     * Wrapper for the mkdir function.\n     *\n     * @param string $pathname\n     *\n     * @return bool\n     */\n    protected function mkdir($pathname)\n    {\n        return \\mkdir($pathname, 0777, true);\n    }\n}\n", "<?php\n\nnamespace Tests\\Knp\\Snappy;\n\nuse Knp\\Snappy\\AbstractGenerator;\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Log\\LoggerInterface;\nuse InvalidArgumentException;\nuse RuntimeException;\nuse ReflectionProperty;\nuse ReflectionMethod;\n\nclass AbstractGeneratorTest extends TestCase\n{\n    public function testAddOption(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $this->assertEquals(['foo' => 'bar'], $media->getOptions(), '->addOption() adds an option');\n\n        $r->invokeArgs($media, ['baz', 'bat']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOption() appends the option to the existing ones'\n        );\n\n        $message = '->addOption() raises an exception when the specified option already exists';\n\n        try {\n            $r->invokeArgs($media, ['baz', 'bat']);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testAddOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds all the given options'\n        );\n\n        $r->invokeArgs($media, [['ban' => 'bag', 'bal' => 'bac']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n                'ban' => 'bag',\n                'bal' => 'bac',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds the given options to the existing ones'\n        );\n\n        $message = '->addOptions() raises an exception when one of the given options already exists';\n\n        try {\n            $r->invokeArgs($media, [['bak' => 'bam', 'bah' => 'bap', 'baz' => 'bat']]);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOption(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->once())->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $media->setOption('foo', 'abc');\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n            ],\n            $media->getOptions(),\n            '->setOption() defines the value of an option'\n        );\n\n        $message = '->setOption() raises an exception when the specified option does not exist';\n\n        try {\n            $media->setOption('bad', 'def');\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOptions(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->exactly(4))->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $media->setOptions(['foo' => 'abc', 'baz' => 'def']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n                'baz' => 'def',\n            ],\n            $media->getOptions(),\n            '->setOptions() defines the values of all the specified options'\n        );\n\n        $message = '->setOptions() raises an exception when one of the specified options does not exist';\n\n        try {\n            $media->setOptions(['foo' => 'abc', 'baz' => 'def', 'bad' => 'ghi']);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', []])\n            ->getMock()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger\n            ->expects($this->exactly(2))\n            ->method('info')\n            ->with(\n                $this->logicalOr(\n                    'Generate from file(s) \"the_input_file\" to file \"the_output_file\".',\n                    'File \"the_output_file\" has been successfully generated.'\n                ),\n                $this->logicalOr(\n                    ['command' => 'the command', 'env' => null, 'timeout' => false],\n                    ['command' => 'the command', 'stdout' => 'stdout', 'stderr' => 'stderr']\n                )\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([0, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(0, 'stdout', 'stderr', 'the command')\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkOutput')\n            ->with(\n                $this->equalTo('the_output_file'),\n                $this->equalTo('the command')\n            )\n        ;\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testFailingGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $logger = $this->getMockBuilder(LoggerInterface::class)->getMock();\n        $media->setLogger($logger);\n        $media->setTimeout(2000);\n\n        $logger\n            ->expects($this->once())\n            ->method('info')\n            ->with(\n                $this->equalTo('Generate from file(s) \"the_input_file\" to file \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'env' => ['PATH' => '/usr/bin'], 'timeout' => 2000])\n            )\n        ;\n\n        $logger\n            ->expects($this->once())\n            ->method('error')\n            ->with(\n                $this->equalTo('An error happened while generating \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'status' => 1, 'stdout' => 'stdout', 'stderr' => 'stderr'])\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file')\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([1, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(1, 'stdout', 'stderr', 'the command')\n            ->willThrowException(new RuntimeException())\n        ;\n\n        $this->expectException(RuntimeException::class);\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml('<html>foo</html>', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml(['<html>foo</html>'], 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGetOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getDefaultExtension',\n                'createTemporaryFile',\n                'generate',\n                'getFileContents',\n                'unlink',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getDefaultExtension')\n            ->will($this->returnValue('ext'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo(null),\n                $this->equalTo('ext')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_temporary_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getFileContents')\n            ->will($this->returnValue('the file contents'))\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('unlink')\n            ->with($this->equalTo('the_temporary_file'))\n            ->will($this->returnValue(true))\n        ;\n\n        $this->assertEquals('the file contents', $media->getOutput('the_input_file', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml('<html>foo</html>', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml(['<html>foo</html>'], ['foo' => 'bar']));\n    }\n\n    public function testMergeOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $originalOptions = ['foo' => 'bar', 'baz' => 'bat'];\n\n        $addOptions = new ReflectionMethod($media, 'addOptions');\n        $addOptions->setAccessible(true);\n        $addOptions->invokeArgs($media, [$originalOptions]);\n\n        $r = new ReflectionMethod($media, 'mergeOptions');\n        $r->setAccessible(true);\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bat',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges an option to the instance ones and returns the result options array'\n        );\n\n        $this->assertEquals(\n            $originalOptions,\n            $media->getOptions(),\n            '->mergeOptions() does NOT change the instance options'\n        );\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban', 'baz' => 'bag']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bag',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges many options to the instance ones and returns the result options array'\n        );\n\n        $message = '->mergeOptions() throws an InvalidArgumentException once there is an undefined option in the given array';\n\n        try {\n            $r->invokeArgs($media, [['foo' => 'ban', 'bad' => 'bah']]);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    /**\n     * @dataProvider dataForBuildCommand\n     */\n    public function testBuildCommand(string $binary, string $url, string $path, array $options, string $expected): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($media, 'buildCommand');\n        $r->setAccessible(true);\n\n        $this->assertEquals($expected, $r->invokeArgs($media, [$binary, $url, $path, $options]));\n    }\n\n    public function dataForBuildCommand(): array\n    {\n        $theBinary = $this->getPHPExecutableFromPath() . ' -v'; // i.e.: '/usr/bin/php -v'\n\n        return [\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => null,\n                    'bar' => false,\n                    'baz' => [],\n                ],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => 'foovalue',\n                    'bar' => ['barvalue1', 'barvalue2'],\n                    'baz' => true,\n                ],\n                $theBinary . ' --foo ' . \\escapeshellarg('foovalue') . ' --bar ' . \\escapeshellarg('barvalue1') . ' --bar ' . \\escapeshellarg('barvalue2') . ' --baz ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'cookie' => ['session' => 'bla', 'phpsess' => 12],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --cookie ' . \\escapeshellarg('session') . ' ' . \\escapeshellarg('bla') . ' --cookie ' . \\escapeshellarg('phpsess') . ' ' . \\escapeshellarg('12') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'allow' => ['/path1', '/path2'],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --allow ' . \\escapeshellarg('/path1') . ' --allow ' . \\escapeshellarg('/path2') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'image-dpi' => 100,\n                    'image-quality' => 50,\n                ],\n                $theBinary . ' ' . '--image-dpi 100 --image-quality 50 ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n        ];\n    }\n\n    public function testCheckOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(123))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() checks both file existence and size';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail($message);\n        }\n    }\n\n    public function testCheckOutputWhenTheFileDoesNotExist(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(false))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file does not exist';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckOutputWhenTheFileIsEmpty(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(0))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file is empty';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckProcessStatus(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods(['configure'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $r = new ReflectionMethod($media, 'checkProcessStatus');\n        $r->setAccessible(true);\n\n        try {\n            $r->invokeArgs($media, [0, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('0 status means success');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('1 status means failure, but no stderr content');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', 'Could not connect to X', 'the command']);\n            $this->fail('1 status means failure');\n        } catch (RuntimeException $e) {\n            $this->assertEquals(1, $e->getCode(), 'Exception thrown by checkProcessStatus should pass on the error code');\n        }\n    }\n\n    /**\n     * @dataProvider dataForIsAssociativeArray\n     */\n    public function testIsAssociativeArray(array $array, bool $isAssociativeArray): void\n    {\n        $generator = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($generator, 'isAssociativeArray');\n        $r->setAccessible(true);\n        $this->assertEquals($isAssociativeArray, $r->invokeArgs($generator, [$array]));\n    }\n\n    /**\n     * @expectedException Knp\\Snappy\\Exception\\FileAlreadyExistsException\n     */\n    public function testItThrowsTheProperExceptionWhenFileExistsAndNotOverwritting(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'isFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('fileExists')\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('isFile')\n            ->will($this->returnValue(true))\n        ;\n        $r = new ReflectionMethod($media, 'prepareOutput');\n        $r->setAccessible(true);\n\n        $r->invokeArgs($media, ['', false]);\n    }\n\n    public function dataForIsAssociativeArray(): array\n    {\n        return [\n            [\n                ['key' => 'value'],\n                true,\n            ],\n            [\n                ['key' => 2],\n                true,\n            ],\n            [\n                ['key' => 'value', 'key2' => 'value2'],\n                true,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 'deux' => 'value3'],\n                true,\n            ],\n            [\n                [0 => 'value'],\n                false,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 3 => 'value3'],\n                false,\n            ],\n            [\n                ['0' => 'value', '1' => 'value2', '3' => 'value3'],\n                false,\n            ],\n            [\n                [],\n                false,\n            ],\n        ];\n    }\n\n    public function testCleanupEmptyTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, null, null);\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testleanupTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, '<html/>', 'html');\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testResetOptions(): void\n    {\n        $media = new class('/usr/local/bin/wkhtmltopdf') extends AbstractGenerator {\n            protected function configure(): void\n            {\n                $this->addOptions([\n                    'optionA' => null,\n                    'optionB' => 'abc',\n                ]);\n            }\n        };\n\n        $media->setOption('optionA', 'bar');\n\n        $this->assertEquals(\n            [\n                'optionA' => 'bar',\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n\n        $media->resetOptions();\n\n        $this->assertEquals(\n            [\n                'optionA' => null,\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n    }\n\n    /**\n     * @return null|string\n     */\n    private function getPHPExecutableFromPath(): ?string\n    {\n        if (isset($_SERVER['_'])) {\n            return $_SERVER['_'];\n        }\n\n        if (@\\defined(\\PHP_BINARY)) {\n            return \\PHP_BINARY;\n        }\n\n        if (false === \\getenv('PATH')) {\n            return null;\n        }\n\n        $paths = \\explode(\\PATH_SEPARATOR, \\getenv('PATH'));\n        foreach ($paths as $path) {\n            // we need this for XAMPP (Windows)\n            if (\\strstr($path, 'php.exe') && isset($_SERVER['WINDIR']) && \\file_exists($path) && \\is_file($path)) {\n                return $path;\n            }\n            $php_executable = $path . \\DIRECTORY_SEPARATOR . 'php' . (isset($_SERVER['WINDIR']) ? '.exe' : '');\n            if (\\file_exists($php_executable) && \\is_file($php_executable)) {\n                return $php_executable;\n            }\n        }\n\n        return null; // not found\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Knp\\Snappy;\n\nuse Knp\\Snappy\\Exception\\FileAlreadyExistsException;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\Process\\Process;\nuse Exception;\nuse LogicException;\nuse RuntimeException;\nuse InvalidArgumentException;\n\n/**\n * Base generator class for medias.\n *\n * @author  Matthieu Bontemps <matthieu.bontemps@knplabs.com>\n * @author  Antoine H\u00e9rault <antoine.herault@knplabs.com>\n */\nabstract class AbstractGenerator implements GeneratorInterface, LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    /**\n     * @var array\n     */\n    public $temporaryFiles = [];\n\n    /**\n     * @var string\n     */\n    protected $temporaryFolder;\n\n    /**\n     * @var null|string\n     */\n    private $binary;\n\n    /**\n     * @var array\n     */\n    private $options = [];\n\n    /**\n     * @var null|array\n     */\n    private $env;\n\n    /**\n     * @var null|int\n     */\n    private $timeout;\n\n    /**\n     * @var string\n     */\n    private $defaultExtension;\n\n    /**\n     * @param null|string $binary\n     * @param array       $options\n     * @param null|array  $env\n     */\n    public function __construct($binary, array $options = [], array $env = null)\n    {\n        $this->configure();\n\n        $this->setBinary($binary);\n        $this->setOptions($options);\n        $this->env = empty($env) ? null : $env;\n\n        if (\\is_callable([$this, 'removeTemporaryFiles'])) {\n            \\register_shutdown_function([$this, 'removeTemporaryFiles']);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->removeTemporaryFiles();\n    }\n\n    /**\n     * Sets the default extension.\n     * Useful when letting Snappy deal with file creation.\n     *\n     * @param string $defaultExtension\n     *\n     * @return $this\n     */\n    public function setDefaultExtension($defaultExtension)\n    {\n        $this->defaultExtension = $defaultExtension;\n\n        return $this;\n    }\n\n    /**\n     * Gets the default extension.\n     *\n     * @return string\n     */\n    public function getDefaultExtension(): string\n    {\n        return $this->defaultExtension;\n    }\n\n    /**\n     * Sets an option. Be aware that option values are NOT validated and that\n     * it is your responsibility to validate user inputs.\n     *\n     * @param string $name  The option to set\n     * @param mixed  $value The value (NULL to unset)\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    public function setOption($name, $value)\n    {\n        if (!\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n        }\n\n        $this->options[$name] = $value;\n\n        if (null !== $this->logger) {\n            $this->logger->debug(\\sprintf('Set option \"%s\".', $name), ['value' => $value]);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the timeout.\n     *\n     * @param null|int $timeout The timeout to set\n     *\n     * @return $this\n     */\n    public function setTimeout($timeout)\n    {\n        $this->timeout = $timeout;\n\n        return $this;\n    }\n\n    /**\n     * Sets an array of options.\n     *\n     * @param array $options An associative array of options as name/value\n     *\n     * @return $this\n     */\n    public function setOptions(array $options)\n    {\n        foreach ($options as $name => $value) {\n            $this->setOption($name, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns all the options.\n     *\n     * @return array\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generate($input, $output, array $options = [], $overwrite = false)\n    {\n        $this->prepareOutput($output, $overwrite);\n\n        $command = $this->getCommand($input, $output, $options);\n\n        $inputFiles = \\is_array($input) ? \\implode('\", \"', $input) : $input;\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('Generate from file(s) \"%s\" to file \"%s\".', $inputFiles, $output), [\n                'command' => $command,\n                'env' => $this->env,\n                'timeout' => $this->timeout,\n            ]);\n        }\n\n        try {\n            list($status, $stdout, $stderr) = $this->executeCommand($command);\n            $this->checkProcessStatus($status, $stdout, $stderr, $command);\n            $this->checkOutput($output, $command);\n        } catch (Exception $e) {\n            if (null !== $this->logger) {\n                $this->logger->error(\\sprintf('An error happened while generating \"%s\".', $output), [\n                    'command' => $command,\n                    'status' => $status ?? null,\n                    'stdout' => $stdout ?? null,\n                    'stderr' => $stderr ?? null,\n                ]);\n            }\n\n            throw $e;\n        }\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('File \"%s\" has been successfully generated.', $output), [\n                'command' => $command,\n                'stdout' => $stdout,\n                'stderr' => $stderr,\n            ]);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generateFromHtml($html, $output, array $options = [], $overwrite = false)\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        $this->generate($fileNames, $output, $options, $overwrite);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutput($input, array $options = [])\n    {\n        $filename = $this->createTemporaryFile(null, $this->getDefaultExtension());\n\n        $this->generate($input, $filename, $options);\n\n        return $this->getFileContents($filename);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutputFromHtml($html, array $options = [])\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        return $this->getOutput($fileNames, $options);\n    }\n\n    /**\n     * Defines the binary.\n     *\n     * @param null|string $binary The path/name of the binary\n     *\n     * @return $this\n     */\n    public function setBinary($binary)\n    {\n        $this->binary = $binary;\n\n        return $this;\n    }\n\n    /**\n     * Returns the binary.\n     *\n     * @return null|string\n     */\n    public function getBinary()\n    {\n        return $this->binary;\n    }\n\n    /**\n     * Returns the command for the given input and output files.\n     *\n     * @param array|string $input   The input file\n     * @param string       $output  The ouput file\n     * @param array        $options An optional array of options that will be used\n     *                              only for this command\n     *\n     * @return string\n     */\n    public function getCommand($input, $output, array $options = [])\n    {\n        if (null === $this->binary) {\n            throw new LogicException('You must define a binary prior to conversion.');\n        }\n\n        $options = $this->mergeOptions($options);\n\n        return $this->buildCommand($this->binary, $input, $output, $options);\n    }\n\n    /**\n     * Removes all temporary files.\n     *\n     * @return void\n     */\n    public function removeTemporaryFiles()\n    {\n        foreach ($this->temporaryFiles as $file) {\n            $this->unlink($file);\n        }\n    }\n\n    /**\n     * Get TemporaryFolder.\n     *\n     * @return string\n     */\n    public function getTemporaryFolder()\n    {\n        if ($this->temporaryFolder === null) {\n            return \\sys_get_temp_dir();\n        }\n\n        return $this->temporaryFolder;\n    }\n\n    /**\n     * Set temporaryFolder.\n     *\n     * @param string $temporaryFolder\n     *\n     * @return $this\n     */\n    public function setTemporaryFolder($temporaryFolder)\n    {\n        $this->temporaryFolder = $temporaryFolder;\n\n        return $this;\n    }\n\n    /**\n     * Reset all options to their initial values.\n     *\n     * @return void\n     */\n    public function resetOptions()\n    {\n        $this->options = [];\n        $this->configure();\n    }\n\n    /**\n     * This method must configure the media options.\n     *\n     * @return void\n     *\n     * @see AbstractGenerator::addOption()\n     */\n    abstract protected function configure();\n\n    /**\n     * Adds an option.\n     *\n     * @param string $name    The name\n     * @param mixed  $default An optional default value\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    protected function addOption($name, $default = null)\n    {\n        if (\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' already exists.', $name));\n        }\n\n        $this->options[$name] = $default;\n\n        return $this;\n    }\n\n    /**\n     * Adds an array of options.\n     *\n     * @param array $options\n     *\n     * @return $this\n     */\n    protected function addOptions(array $options)\n    {\n        foreach ($options as $name => $default) {\n            $this->addOption($name, $default);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Merges the given array of options to the instance options and returns\n     * the result options array. It does NOT change the instance options.\n     *\n     * @param array $options\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function mergeOptions(array $options)\n    {\n        $mergedOptions = $this->options;\n\n        foreach ($options as $name => $value) {\n            if (!\\array_key_exists($name, $mergedOptions)) {\n                throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n            }\n\n            $mergedOptions[$name] = $value;\n        }\n\n        return $mergedOptions;\n    }\n\n    /**\n     * Checks the specified output.\n     *\n     * @param string $output  The output filename\n     * @param string $command The generation command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkOutput($output, $command)\n    {\n        // the output file must exist\n        if (!$this->fileExists($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was not created (command: %s).', $output, $command));\n        }\n\n        // the output file must not be empty\n        if (0 === $this->filesize($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was created but is empty (command: %s).', $output, $command));\n        }\n    }\n\n    /**\n     * Checks the process return status.\n     *\n     * @param int    $status  The exit status code\n     * @param string $stdout  The stdout content\n     * @param string $stderr  The stderr content\n     * @param string $command The run command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkProcessStatus($status, $stdout, $stderr, $command)\n    {\n        if (0 !== $status && '' !== $stderr) {\n            throw new RuntimeException(\\sprintf('The exit status code \\'%s\\' says something went wrong:' . \"\\n\" . 'stderr: \"%s\"' . \"\\n\" . 'stdout: \"%s\"' . \"\\n\" . 'command: %s.', $status, $stderr, $stdout, $command), $status);\n        }\n    }\n\n    /**\n     * Creates a temporary file.\n     * The file is not created if the $content argument is null.\n     *\n     * @param null|string $content   Optional content for the temporary file\n     * @param null|string $extension An optional extension for the filename\n     *\n     * @return string The filename\n     */\n    protected function createTemporaryFile($content = null, $extension = null)\n    {\n        $dir = \\rtrim($this->getTemporaryFolder(), \\DIRECTORY_SEPARATOR);\n\n        if (!\\is_dir($dir)) {\n            if (false === @\\mkdir($dir, 0777, true) && !\\is_dir($dir)) {\n                throw new RuntimeException(\\sprintf(\"Unable to create directory: %s\\n\", $dir));\n            }\n        } elseif (!\\is_writable($dir)) {\n            throw new RuntimeException(\\sprintf(\"Unable to write in directory: %s\\n\", $dir));\n        }\n\n        $filename = $dir . \\DIRECTORY_SEPARATOR . \\uniqid('knp_snappy', true);\n\n        if (null !== $extension) {\n            $filename .= '.' . $extension;\n        }\n\n        if (null !== $content) {\n            \\file_put_contents($filename, $content);\n        }\n\n        $this->temporaryFiles[] = $filename;\n\n        return $filename;\n    }\n\n    /**\n     * Builds the command string.\n     *\n     * @param string       $binary  The binary path/name\n     * @param array|string $input   Url(s) or file location(s) of the page(s) to process\n     * @param string       $output  File location to the image-to-be\n     * @param array        $options An array of options\n     *\n     * @return string\n     */\n    protected function buildCommand($binary, $input, $output, array $options = [])\n    {\n        $command = $binary;\n        $escapedBinary = \\escapeshellarg($binary);\n        if (\\is_executable($escapedBinary)) {\n            $command = $escapedBinary;\n        }\n\n        foreach ($options as $key => $option) {\n            if (null !== $option && false !== $option) {\n                if (true === $option) {\n                    // Dont't put '--' if option is 'toc'.\n                    if ($key === 'toc') {\n                        $command .= ' ' . $key;\n                    } else {\n                        $command .= ' --' . $key;\n                    }\n                } elseif (\\is_array($option)) {\n                    if ($this->isAssociativeArray($option)) {\n                        foreach ($option as $k => $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($k) . ' ' . \\escapeshellarg($v);\n                        }\n                    } else {\n                        foreach ($option as $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($v);\n                        }\n                    }\n                } else {\n                    // Dont't add '--' if option is \"cover\"  or \"toc\".\n                    if (\\in_array($key, ['toc', 'cover'])) {\n                        $command .= ' ' . $key . ' ' . \\escapeshellarg($option);\n                    } elseif (\\in_array($key, ['image-dpi', 'image-quality'])) {\n                        $command .= ' --' . $key . ' ' . (int) $option;\n                    } else {\n                        $command .= ' --' . $key . ' ' . \\escapeshellarg($option);\n                    }\n                }\n            }\n        }\n\n        if (\\is_array($input)) {\n            foreach ($input as $i) {\n                $command .= ' ' . \\escapeshellarg($i) . ' ';\n            }\n            $command .= \\escapeshellarg($output);\n        } else {\n            $command .= ' ' . \\escapeshellarg($input) . ' ' . \\escapeshellarg($output);\n        }\n\n        return $command;\n    }\n\n    /**\n     * Return true if the array is an associative array\n     * and not an indexed array.\n     *\n     * @param array $array\n     *\n     * @return bool\n     */\n    protected function isAssociativeArray(array $array)\n    {\n        return (bool) \\count(\\array_filter(\\array_keys($array), 'is_string'));\n    }\n\n    /**\n     * Executes the given command via shell and returns the complete output as\n     * a string.\n     *\n     * @param string $command\n     *\n     * @return array [status, stdout, stderr]\n     */\n    protected function executeCommand($command)\n    {\n        if (\\method_exists(Process::class, 'fromShellCommandline')) {\n            $process = Process::fromShellCommandline($command, null, $this->env);\n        } else {\n            $process = new Process($command, null, $this->env);\n        }\n\n        if (null !== $this->timeout) {\n            $process->setTimeout($this->timeout);\n        }\n\n        $process->run();\n\n        return [\n            $process->getExitCode(),\n            $process->getOutput(),\n            $process->getErrorOutput(),\n        ];\n    }\n\n    /**\n     * Prepares the specified output.\n     *\n     * @param string $filename  The output filename\n     * @param bool   $overwrite Whether to overwrite the file if it already\n     *                          exist\n     *\n     * @throws FileAlreadyExistsException\n     * @throws RuntimeException\n     * @throws InvalidArgumentException\n     *\n     * @return void\n     */\n    protected function prepareOutput($filename, $overwrite)\n    {\n        if (\\strpos($filename, 'phar://') === 0) {\n            throw new InvalidArgumentException('The output file cannot be a phar archive.');\n        }\n\n        $directory = \\dirname($filename);\n\n        if ($this->fileExists($filename)) {\n            if (!$this->isFile($filename)) {\n                throw new InvalidArgumentException(\\sprintf('The output file \\'%s\\' already exists and it is a %s.', $filename, $this->isDir($filename) ? 'directory' : 'link'));\n            }\n            if (false === $overwrite) {\n                throw new FileAlreadyExistsException(\\sprintf('The output file \\'%s\\' already exists.', $filename));\n            }\n            if (!$this->unlink($filename)) {\n                throw new RuntimeException(\\sprintf('Could not delete already existing output file \\'%s\\'.', $filename));\n            }\n        } elseif (!$this->isDir($directory) && !$this->mkdir($directory)) {\n            throw new RuntimeException(\\sprintf('The output file\\'s directory \\'%s\\' could not be created.', $directory));\n        }\n    }\n\n    /**\n     * Wrapper for the \"file_get_contents\" function.\n     *\n     * @param string $filename\n     *\n     * @return string\n     */\n    protected function getFileContents($filename)\n    {\n        $fileContent = \\file_get_contents($filename);\n\n        if (false === $fileContent) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' content.', $filename));\n        }\n\n        return $fileContent;\n    }\n\n    /**\n     * Wrapper for the \"file_exists\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function fileExists($filename)\n    {\n        return \\file_exists($filename);\n    }\n\n    /**\n     * Wrapper for the \"is_file\" method.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isFile($filename)\n    {\n        return \\strlen($filename) <= \\PHP_MAXPATHLEN && \\is_file($filename);\n    }\n\n    /**\n     * Wrapper for the \"filesize\" function.\n     *\n     * @param string $filename\n     *\n     * @return int\n     */\n    protected function filesize($filename)\n    {\n        $filesize = \\filesize($filename);\n\n        if (false === $filesize) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' size.', $filename));\n        }\n\n        return $filesize;\n    }\n\n    /**\n     * Wrapper for the \"unlink\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function unlink($filename)\n    {\n        return $this->fileExists($filename) ? \\unlink($filename) : false;\n    }\n\n    /**\n     * Wrapper for the \"is_dir\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isDir($filename)\n    {\n        return \\is_dir($filename);\n    }\n\n    /**\n     * Wrapper for the mkdir function.\n     *\n     * @param string $pathname\n     *\n     * @return bool\n     */\n    protected function mkdir($pathname)\n    {\n        return \\mkdir($pathname, 0777, true);\n    }\n}\n", "<?php\n\nnamespace Tests\\Knp\\Snappy;\n\nuse Knp\\Snappy\\AbstractGenerator;\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Log\\LoggerInterface;\nuse InvalidArgumentException;\nuse RuntimeException;\nuse ReflectionProperty;\nuse ReflectionMethod;\n\nclass AbstractGeneratorTest extends TestCase\n{\n    public function testAddOption(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $this->assertEquals(['foo' => 'bar'], $media->getOptions(), '->addOption() adds an option');\n\n        $r->invokeArgs($media, ['baz', 'bat']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOption() appends the option to the existing ones'\n        );\n\n        $message = '->addOption() raises an exception when the specified option already exists';\n\n        try {\n            $r->invokeArgs($media, ['baz', 'bat']);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testAddOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds all the given options'\n        );\n\n        $r->invokeArgs($media, [['ban' => 'bag', 'bal' => 'bac']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n                'ban' => 'bag',\n                'bal' => 'bac',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds the given options to the existing ones'\n        );\n\n        $message = '->addOptions() raises an exception when one of the given options already exists';\n\n        try {\n            $r->invokeArgs($media, [['bak' => 'bam', 'bah' => 'bap', 'baz' => 'bat']]);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOption(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->once())->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $media->setOption('foo', 'abc');\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n            ],\n            $media->getOptions(),\n            '->setOption() defines the value of an option'\n        );\n\n        $message = '->setOption() raises an exception when the specified option does not exist';\n\n        try {\n            $media->setOption('bad', 'def');\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOptions(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->exactly(4))->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $media->setOptions(['foo' => 'abc', 'baz' => 'def']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n                'baz' => 'def',\n            ],\n            $media->getOptions(),\n            '->setOptions() defines the values of all the specified options'\n        );\n\n        $message = '->setOptions() raises an exception when one of the specified options does not exist';\n\n        try {\n            $media->setOptions(['foo' => 'abc', 'baz' => 'def', 'bad' => 'ghi']);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', []])\n            ->getMock()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger\n            ->expects($this->exactly(2))\n            ->method('info')\n            ->with(\n                $this->logicalOr(\n                    'Generate from file(s) \"the_input_file\" to file \"the_output_file\".',\n                    'File \"the_output_file\" has been successfully generated.'\n                ),\n                $this->logicalOr(\n                    ['command' => 'the command', 'env' => null, 'timeout' => false],\n                    ['command' => 'the command', 'stdout' => 'stdout', 'stderr' => 'stderr']\n                )\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([0, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(0, 'stdout', 'stderr', 'the command')\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkOutput')\n            ->with(\n                $this->equalTo('the_output_file'),\n                $this->equalTo('the command')\n            )\n        ;\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testFailingGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $logger = $this->getMockBuilder(LoggerInterface::class)->getMock();\n        $media->setLogger($logger);\n        $media->setTimeout(2000);\n\n        $logger\n            ->expects($this->once())\n            ->method('info')\n            ->with(\n                $this->equalTo('Generate from file(s) \"the_input_file\" to file \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'env' => ['PATH' => '/usr/bin'], 'timeout' => 2000])\n            )\n        ;\n\n        $logger\n            ->expects($this->once())\n            ->method('error')\n            ->with(\n                $this->equalTo('An error happened while generating \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'status' => 1, 'stdout' => 'stdout', 'stderr' => 'stderr'])\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file')\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([1, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(1, 'stdout', 'stderr', 'the command')\n            ->willThrowException(new RuntimeException())\n        ;\n\n        $this->expectException(RuntimeException::class);\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml('<html>foo</html>', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml(['<html>foo</html>'], 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGetOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getDefaultExtension',\n                'createTemporaryFile',\n                'generate',\n                'getFileContents',\n                'unlink',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getDefaultExtension')\n            ->will($this->returnValue('ext'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo(null),\n                $this->equalTo('ext')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_temporary_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getFileContents')\n            ->will($this->returnValue('the file contents'))\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('unlink')\n            ->with($this->equalTo('the_temporary_file'))\n            ->will($this->returnValue(true))\n        ;\n\n        $this->assertEquals('the file contents', $media->getOutput('the_input_file', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml('<html>foo</html>', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml(['<html>foo</html>'], ['foo' => 'bar']));\n    }\n\n    public function testMergeOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $originalOptions = ['foo' => 'bar', 'baz' => 'bat'];\n\n        $addOptions = new ReflectionMethod($media, 'addOptions');\n        $addOptions->setAccessible(true);\n        $addOptions->invokeArgs($media, [$originalOptions]);\n\n        $r = new ReflectionMethod($media, 'mergeOptions');\n        $r->setAccessible(true);\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bat',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges an option to the instance ones and returns the result options array'\n        );\n\n        $this->assertEquals(\n            $originalOptions,\n            $media->getOptions(),\n            '->mergeOptions() does NOT change the instance options'\n        );\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban', 'baz' => 'bag']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bag',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges many options to the instance ones and returns the result options array'\n        );\n\n        $message = '->mergeOptions() throws an InvalidArgumentException once there is an undefined option in the given array';\n\n        try {\n            $r->invokeArgs($media, [['foo' => 'ban', 'bad' => 'bah']]);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    /**\n     * @dataProvider dataForBuildCommand\n     */\n    public function testBuildCommand(string $binary, string $url, string $path, array $options, string $expected): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($media, 'buildCommand');\n        $r->setAccessible(true);\n\n        $this->assertEquals($expected, $r->invokeArgs($media, [$binary, $url, $path, $options]));\n    }\n\n    public function dataForBuildCommand(): array\n    {\n        $theBinary = $this->getPHPExecutableFromPath() . ' -v'; // i.e.: '/usr/bin/php -v'\n\n        return [\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => null,\n                    'bar' => false,\n                    'baz' => [],\n                ],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => 'foovalue',\n                    'bar' => ['barvalue1', 'barvalue2'],\n                    'baz' => true,\n                ],\n                $theBinary . ' --foo ' . \\escapeshellarg('foovalue') . ' --bar ' . \\escapeshellarg('barvalue1') . ' --bar ' . \\escapeshellarg('barvalue2') . ' --baz ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'cookie' => ['session' => 'bla', 'phpsess' => 12],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --cookie ' . \\escapeshellarg('session') . ' ' . \\escapeshellarg('bla') . ' --cookie ' . \\escapeshellarg('phpsess') . ' ' . \\escapeshellarg('12') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'allow' => ['/path1', '/path2'],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --allow ' . \\escapeshellarg('/path1') . ' --allow ' . \\escapeshellarg('/path2') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'image-dpi' => 100,\n                    'image-quality' => 50,\n                ],\n                $theBinary . ' ' . '--image-dpi 100 --image-quality 50 ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n        ];\n    }\n\n    public function testCheckOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(123))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() checks both file existence and size';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail($message);\n        }\n    }\n\n    public function testCheckOutputWhenTheFileDoesNotExist(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(false))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file does not exist';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckOutputWhenTheFileIsEmpty(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(0))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file is empty';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckProcessStatus(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods(['configure'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $r = new ReflectionMethod($media, 'checkProcessStatus');\n        $r->setAccessible(true);\n\n        try {\n            $r->invokeArgs($media, [0, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('0 status means success');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('1 status means failure, but no stderr content');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', 'Could not connect to X', 'the command']);\n            $this->fail('1 status means failure');\n        } catch (RuntimeException $e) {\n            $this->assertEquals(1, $e->getCode(), 'Exception thrown by checkProcessStatus should pass on the error code');\n        }\n    }\n\n    /**\n     * @dataProvider dataForIsAssociativeArray\n     */\n    public function testIsAssociativeArray(array $array, bool $isAssociativeArray): void\n    {\n        $generator = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($generator, 'isAssociativeArray');\n        $r->setAccessible(true);\n        $this->assertEquals($isAssociativeArray, $r->invokeArgs($generator, [$array]));\n    }\n\n    /**\n     * @expectedException Knp\\Snappy\\Exception\\FileAlreadyExistsException\n     */\n    public function testItThrowsTheProperExceptionWhenFileExistsAndNotOverwritting(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'isFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('fileExists')\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('isFile')\n            ->will($this->returnValue(true))\n        ;\n        $r = new ReflectionMethod($media, 'prepareOutput');\n        $r->setAccessible(true);\n\n        $r->invokeArgs($media, ['', false]);\n    }\n\n    public function dataForIsAssociativeArray(): array\n    {\n        return [\n            [\n                ['key' => 'value'],\n                true,\n            ],\n            [\n                ['key' => 2],\n                true,\n            ],\n            [\n                ['key' => 'value', 'key2' => 'value2'],\n                true,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 'deux' => 'value3'],\n                true,\n            ],\n            [\n                [0 => 'value'],\n                false,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 3 => 'value3'],\n                false,\n            ],\n            [\n                ['0' => 'value', '1' => 'value2', '3' => 'value3'],\n                false,\n            ],\n            [\n                [],\n                false,\n            ],\n        ];\n    }\n\n    public function testCleanupEmptyTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, null, null);\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testleanupTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, '<html/>', 'html');\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testResetOptions(): void\n    {\n        $media = new class('/usr/local/bin/wkhtmltopdf') extends AbstractGenerator {\n            protected function configure(): void\n            {\n                $this->addOptions([\n                    'optionA' => null,\n                    'optionB' => 'abc',\n                ]);\n            }\n        };\n\n        $media->setOption('optionA', 'bar');\n\n        $this->assertEquals(\n            [\n                'optionA' => 'bar',\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n\n        $media->resetOptions();\n\n        $this->assertEquals(\n            [\n                'optionA' => null,\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n    }\n\n    public function testFailingGenerateWithOutputContainingPharPrefix(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $media->setTimeout(2000);\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('phar://the_output_file'))\n        ;\n\n        $this->expectException(InvalidArgumentException::class);\n\n        $media->generate('the_input_file', 'phar://the_output_file', ['foo' => 'bar']);\n    }\n\n    /**\n     * @return null|string\n     */\n    private function getPHPExecutableFromPath(): ?string\n    {\n        if (isset($_SERVER['_'])) {\n            return $_SERVER['_'];\n        }\n\n        if (@\\defined(\\PHP_BINARY)) {\n            return \\PHP_BINARY;\n        }\n\n        if (false === \\getenv('PATH')) {\n            return null;\n        }\n\n        $paths = \\explode(\\PATH_SEPARATOR, \\getenv('PATH'));\n        foreach ($paths as $path) {\n            // we need this for XAMPP (Windows)\n            if (\\strstr($path, 'php.exe') && isset($_SERVER['WINDIR']) && \\file_exists($path) && \\is_file($path)) {\n                return $path;\n            }\n            $php_executable = $path . \\DIRECTORY_SEPARATOR . 'php' . (isset($_SERVER['WINDIR']) ? '.exe' : '');\n            if (\\file_exists($php_executable) && \\is_file($php_executable)) {\n                return $php_executable;\n            }\n        }\n\n        return null; // not found\n    }\n}\n"], "filenames": ["src/Knp/Snappy/AbstractGenerator.php", "tests/Knp/Snappy/AbstractGeneratorTest.php"], "buggy_code_start_loc": [627, 938], "buggy_code_end_loc": [627, 938], "fixing_code_start_loc": [628, 939], "fixing_code_end_loc": [632, 963], "type": "CWE-502", "message": "Snappy is a PHP library allowing thumbnail, snapshot or PDF generation from a url or a html page. Prior to version 1.4.2, Snappy is vulnerable to PHAR deserialization due to a lack of checking on the protocol before passing it into the `file_exists()` function. If an attacker can upload files of any type to the server he can pass in the phar:// protocol to unserialize the uploaded file and instantiate arbitrary PHP objects. This can lead to remote code execution especially when snappy is used with frameworks with documented POP chains like Laravel/Symfony vulnerable developer code. If a user can control the output file from the `generateFromHtml()` function, it will invoke deserialization. This vulnerability is capable of remote code execution if Snappy is used with frameworks or developer code with vulnerable POP chains. It has been fixed in version 1.4.2.", "other": {"cve": {"id": "CVE-2023-28115", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-17T22:15:11.437", "lastModified": "2023-03-24T16:40:03.083", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Snappy is a PHP library allowing thumbnail, snapshot or PDF generation from a url or a html page. Prior to version 1.4.2, Snappy is vulnerable to PHAR deserialization due to a lack of checking on the protocol before passing it into the `file_exists()` function. If an attacker can upload files of any type to the server he can pass in the phar:// protocol to unserialize the uploaded file and instantiate arbitrary PHP objects. This can lead to remote code execution especially when snappy is used with frameworks with documented POP chains like Laravel/Symfony vulnerable developer code. If a user can control the output file from the `generateFromHtml()` function, it will invoke deserialization. This vulnerability is capable of remote code execution if Snappy is used with frameworks or developer code with vulnerable POP chains. It has been fixed in version 1.4.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:knplabs:snappy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.2", "matchCriteriaId": "63871084-34B8-4CD8-ACEC-3EEAE2CA2EFE"}]}]}], "references": [{"url": "https://github.com/KnpLabs/snappy/blob/5126fb5b335ec929a226314d40cd8dad497c3d67/src/Knp/Snappy/AbstractGenerator.php#L670", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/KnpLabs/snappy/commit/1ee6360cbdbea5d09705909a150df7963a88efd6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/KnpLabs/snappy/commit/b66f79334421c26d9c244427963fa2d92980b5d3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/KnpLabs/snappy/pull/469", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/KnpLabs/snappy/releases/tag/v1.4.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/KnpLabs/snappy/security/advisories/GHSA-gq6w-q6wh-jggc", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/KnpLabs/snappy/commit/1ee6360cbdbea5d09705909a150df7963a88efd6"}}