{"buggy_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_types.h\n * @brief libscp data types definitions\n * @author Simone Fedele\n *\n */\n\n#ifndef LIBSCP_TYPES_H\n#define LIBSCP_TYPES_H\n\n#include \"os_calls.h\"\n#include \"parse.h\"\n#include \"arch.h\"\n#include \"log.h\"\n\n#define SCP_SID      tui32\n#define SCP_DISPLAY  tui16\n\n#define SCP_RESOURCE_SHARING_REQUEST_YES 0x01\n#define SCP_RESOURCE_SHARING_REQUEST_NO  0x00\n\n#define SCP_SESSION_TYPE_XVNC    0x00\n#define SCP_SESSION_TYPE_XRDP    0x01\n#define SCP_SESSION_TYPE_MANAGE  0x02\n#define SCP_SESSION_TYPE_XORG    0x03\n\n/* SCP_GW_AUTHENTICATION can be used when XRDP + sesman act as a gateway\n * XRDP sends this command to let sesman verify if the user is allowed\n * to use the gateway */\n#define SCP_GW_AUTHENTICATION    0x04\n\n#define SCP_ADDRESS_TYPE_IPV4 0x00\n#define SCP_ADDRESS_TYPE_IPV6 0x01\n\n#define SCP_COMMAND_SET_DEFAULT 0x0000\n#define SCP_COMMAND_SET_MANAGE  0x0001\n#define SCP_COMMAND_SET_RSR     0x0002\n\n#define SCP_SERVER_MAX_LIST_SIZE 100\n\n#include \"libscp_types_mng.h\"\n\nstruct SCP_CONNECTION\n{\n  int in_sck;\n  struct stream* in_s;\n  struct stream* out_s;\n};\n\nstruct SCP_SESSION\n{\n  tui8  type;\n  tui32 version;\n  tui16 height;\n  tui16 width;\n  tui8  bpp;\n  tui8  rsr;\n  char  locale[18];\n  char* username;\n  char* password;\n  char* hostname;\n  tui8  addr_type;\n  tui32 ipv4addr;\n  tui8  ipv6addr[16];\n  SCP_DISPLAY display;\n  char* errstr;\n  struct SCP_MNG_DATA* mng;\n  char* domain;\n  char* program;\n  char* directory;\n  char* client_ip;\n  tui8 guid[16];\n};\n\nstruct SCP_DISCONNECTED_SESSION\n{\n  tui32 SID;\n  tui8  type;\n  tui8  status;\n  tui16 height;\n  tui16 width;\n  tui8  bpp;\n  tui8  idle_days;\n  tui8  idle_hours;\n  tui8  idle_minutes;\n  tui16 conn_year;\n  tui8  conn_month;\n  tui8  conn_day;\n  tui8  conn_hour;\n  tui8  conn_minute;\n  tui8  addr_type;\n  tui32 ipv4addr;\n  tui8  ipv6addr[16];\n};\n\nenum SCP_CLIENT_STATES_E\n{\n  SCP_CLIENT_STATE_OK,\n  SCP_CLIENT_STATE_NETWORK_ERR,\n  SCP_CLIENT_STATE_VERSION_ERR,\n  SCP_CLIENT_STATE_SEQUENCE_ERR,\n  SCP_CLIENT_STATE_SIZE_ERR,\n  SCP_CLIENT_STATE_INTERNAL_ERR,\n  SCP_CLIENT_STATE_SESSION_LIST,\n  SCP_CLIENT_STATE_LIST_OK,\n  SCP_CLIENT_STATE_RESEND_CREDENTIALS,\n  SCP_CLIENT_STATE_CONNECTION_DENIED,\n  SCP_CLIENT_STATE_PWD_CHANGE_REQ,\n  SCP_CLIENT_STATE_RECONNECT_SINGLE,\n  SCP_CLIENT_STATE_SELECTION_CANCEL,\n  SCP_CLIENT_STATE_END\n};\n\nenum SCP_SERVER_STATES_E\n{\n  SCP_SERVER_STATE_OK,\n  SCP_SERVER_STATE_VERSION_ERR,\n  SCP_SERVER_STATE_NETWORK_ERR,\n  SCP_SERVER_STATE_SEQUENCE_ERR,\n  SCP_SERVER_STATE_INTERNAL_ERR,\n  SCP_SERVER_STATE_SESSION_TYPE_ERR,\n  SCP_SERVER_STATE_SIZE_ERR,\n  SCP_SERVER_STATE_SELECTION_CANCEL,\n  /*SCP_SERVER_STATE_FORCE_NEW,*/\n  SCP_SERVER_STATE_START_MANAGE,\n  SCP_SERVER_STATE_MNG_LISTREQ,\n  SCP_SERVER_STATE_MNG_ACTION,\n  SCP_SERVER_STATE_END\n};\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_v0.c\n * @brief libscp version 0 code\n * @author Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"libscp_v0.h\"\n\n#include \"os_calls.h\"\n\nextern struct log_config *s_log;\n\n/* client API */\n/******************************************************************************/\nenum SCP_CLIENT_STATES_E\nscp_v0c_connect(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n{\n    tui32 version;\n    tui32 size;\n    tui16 sz;\n\n    init_stream(c->in_s, c->in_s->size);\n    init_stream(c->out_s, c->in_s->size);\n\n    LOG_DBG(\"[v0:%d] starting connection\", __LINE__);\n    g_tcp_set_non_blocking(c->in_sck);\n    g_tcp_set_no_delay(c->in_sck);\n    s_push_layer(c->out_s, channel_hdr, 8);\n\n    /* code */\n    if (s->type == SCP_SESSION_TYPE_XVNC)\n    {\n        out_uint16_be(c->out_s, 0);\n    }\n    else if (s->type == SCP_SESSION_TYPE_XRDP)\n    {\n        out_uint16_be(c->out_s, 10);\n    }\n    else if (s->type == SCP_SESSION_TYPE_XORG)\n    {\n        out_uint16_be(c->out_s, 20);\n    }\n    else\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_INTERNAL_ERR;\n    }\n\n    sz = g_strlen(s->username);\n    out_uint16_be(c->out_s, sz);\n    out_uint8a(c->out_s, s->username, sz);\n\n    sz = g_strlen(s->password);\n    out_uint16_be(c->out_s, sz);\n    out_uint8a(c->out_s, s->password, sz);\n    out_uint16_be(c->out_s, s->width);\n    out_uint16_be(c->out_s, s->height);\n    out_uint16_be(c->out_s, s->bpp);\n\n    s_mark_end(c->out_s);\n    s_pop_layer(c->out_s, channel_hdr);\n\n    /* version */\n    out_uint32_be(c->out_s, 0);\n    /* size */\n    out_uint32_be(c->out_s, c->out_s->end - c->out_s->data);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_NETWORK_ERR;\n    }\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (0 != version)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: version error\", __LINE__);\n        return SCP_CLIENT_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    if (size < 14)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: packet size error\", __LINE__);\n        return SCP_CLIENT_STATE_SIZE_ERR;\n    }\n\n    /* getting payload */\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_NETWORK_ERR;\n    }\n\n    /* check code */\n    in_uint16_be(c->in_s, sz);\n\n    if (3 != sz)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_CLIENT_STATE_SEQUENCE_ERR;\n    }\n\n    /* message payload */\n    in_uint16_be(c->in_s, sz);\n\n    if (1 != sz)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: connection denied\", __LINE__);\n        return SCP_CLIENT_STATE_CONNECTION_DENIED;\n    }\n\n    in_uint16_be(c->in_s, sz);\n    s->display = sz;\n\n    LOG_DBG(\"[v0:%d] connection terminated\", __LINE__);\n    return SCP_CLIENT_STATE_END;\n}\n\n/* server API */\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n{\n    tui32 version = 0;\n    tui32 size;\n    struct SCP_SESSION *session = 0;\n    tui16 sz;\n    tui32 code = 0;\n    char *buf = 0;\n\n    if (!skipVchk)\n    {\n        LOG_DBG(\"[v0:%d] starting connection\", __LINE__);\n\n        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n        {\n            c->in_s->end = c->in_s->data + 8;\n            in_uint32_be(c->in_s, version);\n\n            if (version != 0)\n            {\n                log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: version error\", __LINE__);\n                return SCP_SERVER_STATE_VERSION_ERR;\n            }\n        }\n        else\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    init_stream(c->in_s, 8196);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    in_uint16_be(c->in_s, code);\n\n    if (code == 0 || code == 10 || code == 20)\n    {\n        session = scp_session_create();\n\n        if (0 == session)\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n\n        scp_session_set_version(session, version);\n\n        if (code == 0)\n        {\n            scp_session_set_type(session, SCP_SESSION_TYPE_XVNC);\n        }\n        else if (code == 10)\n        {\n            scp_session_set_type(session, SCP_SESSION_TYPE_XRDP);\n        }\n        else if (code == 20)\n        {\n            scp_session_set_type(session, SCP_SESSION_TYPE_XORG);\n        }\n\n        /* reading username */\n        in_uint16_be(c->in_s, sz);\n        buf = g_new0(char, sz + 1);\n        in_uint8a(c->in_s, buf, sz);\n        buf[sz] = '\\0';\n        if (0 != scp_session_set_username(session, buf))\n        {\n            scp_session_destroy(session);\n            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting username\", __LINE__);\n            g_free(buf);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n        g_free(buf);\n\n        /* reading password */\n        in_uint16_be(c->in_s, sz);\n        buf = g_new0(char, sz + 1);\n        in_uint8a(c->in_s, buf, sz);\n        buf[sz] = '\\0';\n        if (0 != scp_session_set_password(session, buf))\n        {\n            scp_session_destroy(session);\n            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting password\", __LINE__);\n            g_free(buf);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n        g_free(buf);\n\n        /* width */\n        in_uint16_be(c->in_s, sz);\n        scp_session_set_width(session, sz);\n        /* height */\n        in_uint16_be(c->in_s, sz);\n        scp_session_set_height(session, sz);\n        /* bpp */\n        in_uint16_be(c->in_s, sz);\n        if (0 != scp_session_set_bpp(session, (tui8)sz))\n        {\n            scp_session_destroy(session);\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v0:%d] connection aborted: unsupported bpp: %d\",\n                        __LINE__, (tui8)sz);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading domain */\n            in_uint16_be(c->in_s, sz);\n\n            if (sz > 0)\n            {\n                buf = g_new0(char, sz + 1);\n                in_uint8a(c->in_s, buf, sz);\n                buf[sz] = '\\0';\n                scp_session_set_domain(session, buf);\n                g_free(buf);\n            }\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading program */\n            in_uint16_be(c->in_s, sz);\n\n            if (sz > 0)\n            {\n                buf = g_new0(char, sz + 1);\n                in_uint8a(c->in_s, buf, sz);\n                buf[sz] = '\\0';\n                scp_session_set_program(session, buf);\n                g_free(buf);\n            }\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading directory */\n            in_uint16_be(c->in_s, sz);\n\n            if (sz > 0)\n            {\n                buf = g_new0(char, sz + 1);\n                in_uint8a(c->in_s, buf, sz);\n                buf[sz] = '\\0';\n                scp_session_set_directory(session, buf);\n                g_free(buf);\n            }\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading client IP address */\n            in_uint16_be(c->in_s, sz);\n\n            if (sz > 0)\n            {\n                buf = g_new0(char, sz + 1);\n                in_uint8a(c->in_s, buf, sz);\n                buf[sz] = '\\0';\n                scp_session_set_client_ip(session, buf);\n                g_free(buf);\n            }\n        }\n    }\n    else if (code == SCP_GW_AUTHENTICATION)\n    {\n        /* g_writeln(\"Command is SCP_GW_AUTHENTICATION\"); */\n        session = scp_session_create();\n\n        if (0 == session)\n        {\n            /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\",      __LINE__);*/\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n\n        scp_session_set_version(session, version);\n        scp_session_set_type(session, SCP_GW_AUTHENTICATION);\n        /* reading username */\n        in_uint16_be(c->in_s, sz);\n        buf = g_new0(char, sz + 1);\n        in_uint8a(c->in_s, buf, sz);\n        buf[sz] = '\\0';\n\n        /* g_writeln(\"Received user name: %s\",buf); */\n        if (0 != scp_session_set_username(session, buf))\n        {\n            scp_session_destroy(session);\n            /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting        username\", __LINE__);*/\n            g_free(buf);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n        g_free(buf);\n\n        /* reading password */\n        in_uint16_be(c->in_s, sz);\n        buf = g_new0(char, sz + 1);\n        in_uint8a(c->in_s, buf, sz);\n        buf[sz] = '\\0';\n\n        /* g_writeln(\"Received password: %s\",buf); */\n        if (0 != scp_session_set_password(session, buf))\n        {\n            scp_session_destroy(session);\n            /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting password\", __LINE__); */\n            g_free(buf);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n        g_free(buf);\n    }\n    else\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    (*s) = session;\n    return SCP_SERVER_STATE_OK;\n}\n\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_allow_connection(struct SCP_CONNECTION *c, SCP_DISPLAY d, const tui8 *guid)\n{\n    int msg_size;\n\n    msg_size = guid == 0 ? 14 : 14 + 16;\n    out_uint32_be(c->out_s, 0);  /* version */\n    out_uint32_be(c->out_s, msg_size); /* size */\n    out_uint16_be(c->out_s, 3);  /* cmd */\n    out_uint16_be(c->out_s, 1);  /* data */\n    out_uint16_be(c->out_s, d);  /* data */\n    if (msg_size > 14)\n    {\n        out_uint8a(c->out_s, guid, 16);\n    }\n    s_mark_end(c->out_s);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    LOG_DBG(\"[v0:%d] connection terminated (allowed)\", __LINE__);\n    return SCP_SERVER_STATE_OK;\n}\n\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_deny_connection(struct SCP_CONNECTION *c)\n{\n    out_uint32_be(c->out_s, 0);  /* version */\n    out_uint32_be(c->out_s, 14); /* size */\n    out_uint16_be(c->out_s, 3);  /* cmd */\n    out_uint16_be(c->out_s, 0);  /* data = 0 - means NOT ok*/\n    out_uint16_be(c->out_s, 0);  /* reserved for display number*/\n    s_mark_end(c->out_s);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    LOG_DBG(\"[v0:%d] connection terminated (denied)\", __LINE__);\n    return SCP_SERVER_STATE_OK;\n}\n\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_replyauthentication(struct SCP_CONNECTION *c, unsigned short int value)\n{\n    out_uint32_be(c->out_s, 0);  /* version */\n    out_uint32_be(c->out_s, 14); /* size */\n    /* cmd SCP_GW_AUTHENTICATION means authentication reply */\n    out_uint16_be(c->out_s, SCP_GW_AUTHENTICATION);\n    out_uint16_be(c->out_s, value);  /* reply code  */\n    out_uint16_be(c->out_s, 0);  /* dummy data */\n    s_mark_end(c->out_s);\n\n    /* g_writeln(\"Total number of bytes that will be sent %d\",c->out_s->end - c->out_s->data);*/\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__); */\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    /* until syslog merge LOG_DBG(s_log, \"[v0:%d] connection terminated (scp_v0s_deny_authentication)\", __LINE__);*/\n    return SCP_SERVER_STATE_OK;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_v1s.c\n * @brief libscp version 1 server api code\n * @author Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#ifndef LIBSCP_V1S_C\n#define LIBSCP_V1S_C\n\n#include \"libscp_v1s.h\"\n\n//extern struct log_config* s_log;\n\n/* server API */\nenum SCP_SERVER_STATES_E scp_v1s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n{\n    struct SCP_SESSION *session;\n    tui32 version;\n    tui32 size;\n    tui16 cmdset;\n    tui16 cmd;\n    tui8 sz;\n    char buf[257];\n\n    if (!skipVchk)\n    {\n\n        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n        {\n            in_uint32_be(c->in_s, version);\n\n            if (version != 1)\n            {\n                log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n                return SCP_SERVER_STATE_VERSION_ERR;\n            }\n        }\n        else\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    if (size < 12)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    /* reading command set */\n    in_uint16_be(c->in_s, cmdset);\n\n    /* if we are starting a management session */\n    if (cmdset == SCP_COMMAND_SET_MANAGE)\n    {\n        log_message(LOG_LEVEL_DEBUG, \"[v1s:%d] requested management connection\", __LINE__);\n        /* should return SCP_SERVER_STATE_START_MANAGE */\n        return scp_v1s_mng_accept(c, s);\n    }\n\n    /* if we started with resource sharing... */\n    if (cmdset == SCP_COMMAND_SET_RSR)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    /* reading command */\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    session = scp_session_create();\n\n    if (0 == session)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error (malloc returned NULL)\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    scp_session_set_version(session, 1);\n\n    in_uint8(c->in_s, sz);\n\n    if ((sz != SCP_SESSION_TYPE_XVNC) && (sz != SCP_SESSION_TYPE_XRDP))\n    {\n        scp_session_destroy(session);\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: unknown session type\", __LINE__);\n        return SCP_SERVER_STATE_SESSION_TYPE_ERR;\n    }\n\n    scp_session_set_type(session, sz);\n\n    in_uint16_be(c->in_s, cmd);\n    scp_session_set_height(session, cmd);\n    in_uint16_be(c->in_s, cmd);\n    scp_session_set_width(session, cmd);\n    in_uint8(c->in_s, sz);\n    if (0 != scp_session_set_bpp(session, sz))\n    {\n        scp_session_destroy(session);\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s:%d] connection aborted: unsupported bpp: %d\",\n                    __LINE__, sz);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n    in_uint8(c->in_s, sz);\n    scp_session_set_rsr(session, sz);\n    in_uint8a(c->in_s, buf, 17);\n    buf[17] = '\\0';\n    scp_session_set_locale(session, buf);\n\n    in_uint8(c->in_s, sz);\n\n    if (sz == SCP_ADDRESS_TYPE_IPV4)\n    {\n        in_uint32_be(c->in_s, size);\n        scp_session_set_addr(session, sz, &size);\n    }\n    else if (sz == SCP_ADDRESS_TYPE_IPV6)\n    {\n        in_uint8a(c->in_s, buf, 16);\n        scp_session_set_addr(session, sz, buf);\n    }\n\n    buf[256] = '\\0';\n    /* reading hostname */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_hostname(session, buf))\n    {\n        scp_session_destroy(session);\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading username */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_username(session, buf))\n    {\n        scp_session_destroy(session);\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading password */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_password(session, buf))\n    {\n        scp_session_destroy(session);\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* returning the struct */\n    (*s) = session;\n\n    return SCP_SERVER_STATE_OK;\n}\n\nenum SCP_SERVER_STATES_E\nscp_v1s_deny_connection(struct SCP_CONNECTION *c, const char *reason)\n{\n    int rlen;\n\n    init_stream(c->out_s, c->out_s->size);\n\n    /* forcing message not to exceed 64k */\n    rlen = g_strlen(reason);\n\n    if (rlen > 65535)\n    {\n        rlen = 65535;\n    }\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 + 2 + strlen(reason)*/\n    /* version + size + cmdset + cmd + msglen + msg */\n    out_uint32_be(c->out_s, rlen + 14);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n    out_uint16_be(c->out_s, 2);\n    out_uint16_be(c->out_s, rlen);\n    out_uint8p(c->out_s, reason, rlen);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, rlen + 14))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_END;\n}\n\nenum SCP_SERVER_STATES_E\nscp_v1s_request_password(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n                         const char *reason)\n{\n    tui8 sz;\n    tui32 version;\n    tui32 size;\n    tui16 cmdset;\n    tui16 cmd;\n    int rlen;\n    char buf[257];\n\n    init_stream(c->in_s, c->in_s->size);\n    init_stream(c->out_s, c->out_s->size);\n\n    /* forcing message not to exceed 64k */\n    rlen = g_strlen(reason);\n\n    if (rlen > 65535)\n    {\n        rlen = 65535;\n    }\n\n    /* send password request */\n    version = 1;\n    cmd = 3;\n\n    out_uint32_be(c->out_s, version);                 /* version */\n    out_uint32_be(c->out_s, 14 + rlen);               /* size    */\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT); /* cmdset  */\n    out_uint16_be(c->out_s, cmd);                     /* cmd     */\n\n    out_uint16_be(c->out_s, rlen);\n    out_uint8p(c->out_s, reason, rlen);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, 14 + rlen))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    /* receive password & username */\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    if (size < 12)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmdset);\n\n    if (cmdset != SCP_COMMAND_SET_DEFAULT)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 4)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    buf[256] = '\\0';\n    /* reading username */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_username(s, buf))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading password */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_password(s, buf))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n/* 020 */\nenum SCP_SERVER_STATES_E\nscp_v1s_request_pwd_change(struct SCP_CONNECTION *c, char *reason, char *npw)\n{\n    return SCP_SERVER_STATE_INTERNAL_ERR;\n}\n\n/* 023 */\nenum SCP_SERVER_STATES_E\nscp_v1s_pwd_change_error(struct SCP_CONNECTION *c, char *error, int retry, char *npw)\n{\n    return SCP_SERVER_STATE_INTERNAL_ERR;\n}\n\n/* 030 */\nenum SCP_SERVER_STATES_E\nscp_v1s_connect_new_session(struct SCP_CONNECTION *c, SCP_DISPLAY d)\n{\n    /* send password request */\n    tui32 version = 1;\n    tui32 size = 14;\n    tui16 cmd = 30;\n\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, version);                 /* version */\n    out_uint32_be(c->out_s, size);                    /* size    */\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT); /* cmdset  */\n    out_uint16_be(c->out_s, cmd);                     /* cmd     */\n\n    out_uint16_be(c->out_s, d);                       /* display */\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, 14))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n/* 032 */\nenum SCP_SERVER_STATES_E\nscp_v1s_connection_error(struct SCP_CONNECTION *c, const char *error)\n{\n    tui16 len;\n\n    len = g_strlen(error);\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 + len */\n    /* version + size + cmdset + cmd */\n    out_uint32_be(c->out_s, (12 + len));\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n    out_uint16_be(c->out_s, SCP_CMD_CONN_ERROR);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, (12 + len)))\n    {\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_END;\n}\n\n/* 040 */\nenum SCP_SERVER_STATES_E\nscp_v1s_list_sessions(struct SCP_CONNECTION *c, int sescnt, struct SCP_DISCONNECTED_SESSION *ds, SCP_SID *sid)\n{\n    tui32 version = 1;\n    tui32 size = 12;\n    tui16 cmd = 40;\n    int pktcnt;\n    int idx;\n    int sidx;\n    int pidx;\n    struct SCP_DISCONNECTED_SESSION *cds;\n\n    /* first we send a notice that we have some disconnected sessions */\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, version);                 /* version */\n    out_uint32_be(c->out_s, size);                    /* size    */\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT); /* cmdset  */\n    out_uint16_be(c->out_s, cmd);                     /* cmd     */\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    /* then we wait for client ack */\n\n    /*\n     * Maybe this message could say if the session should be resized on\n     * server side or client side.\n     */\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    if (size < 12)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != SCP_COMMAND_SET_DEFAULT)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 41)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    /* calculating the number of packets to send */\n    pktcnt = sescnt / SCP_SERVER_MAX_LIST_SIZE;\n\n    if ((sescnt % SCP_SERVER_MAX_LIST_SIZE) != 0)\n    {\n        pktcnt++;\n    }\n\n    for (idx = 0; idx < pktcnt; idx++)\n    {\n        /* ok, we send session session list */\n        init_stream(c->out_s, c->out_s->size);\n\n        /* size: ver+size+cmdset+cmd+sescnt+continue+count */\n        size = 4 + 4 + 2 + 2 + 4 + 1 + 1;\n\n        /* header */\n        cmd = 42;\n        s_push_layer(c->out_s, channel_hdr, 8);\n        out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n        out_uint16_be(c->out_s, cmd);\n\n        /* session count */\n        out_uint32_be(c->out_s, sescnt);\n\n        /* setting the continue flag */\n        if ((idx + 1)*SCP_SERVER_MAX_LIST_SIZE >= sescnt)\n        {\n            out_uint8(c->out_s, 0);\n            /* setting session count for this packet */\n            pidx = sescnt - (idx * SCP_SERVER_MAX_LIST_SIZE);\n            out_uint8(c->out_s, pidx);\n        }\n        else\n        {\n            out_uint8(c->out_s, 1);\n            /* setting session count for this packet */\n            pidx = SCP_SERVER_MAX_LIST_SIZE;\n            out_uint8(c->out_s, pidx);\n        }\n\n        /* adding session descriptors */\n        for (sidx = 0; sidx < pidx; sidx++)\n        {\n            /* shortcut to the current session to send */\n            cds = ds + ((idx) * SCP_SERVER_MAX_LIST_SIZE) + sidx;\n\n            /* session data */\n            out_uint32_be(c->out_s, cds->SID); /* session id */\n            out_uint8(c->out_s, cds->type);\n            out_uint16_be(c->out_s, cds->height);\n            out_uint16_be(c->out_s, cds->width);\n            out_uint8(c->out_s, cds->bpp);\n            out_uint8(c->out_s, cds->idle_days);\n            out_uint8(c->out_s, cds->idle_hours);\n            out_uint8(c->out_s, cds->idle_minutes);\n            size += 13;\n\n            out_uint16_be(c->out_s, cds->conn_year);\n            out_uint8(c->out_s, cds->conn_month);\n            out_uint8(c->out_s, cds->conn_day);\n            out_uint8(c->out_s, cds->conn_hour);\n            out_uint8(c->out_s, cds->conn_minute);\n            out_uint8(c->out_s, cds->addr_type);\n            size += 7;\n\n            if (cds->addr_type == SCP_ADDRESS_TYPE_IPV4)\n            {\n                in_uint32_be(c->out_s, cds->ipv4addr);\n                size += 4;\n            }\n            else if (cds->addr_type == SCP_ADDRESS_TYPE_IPV6)\n            {\n                in_uint8a(c->out_s, cds->ipv6addr, 16);\n                size += 16;\n            }\n        }\n\n        s_pop_layer(c->out_s, channel_hdr);\n        out_uint32_be(c->out_s, version);\n        out_uint32_be(c->out_s, size);\n\n        if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    /* we get the response */\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    if (size < 12)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    /* rest of the packet */\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != SCP_COMMAND_SET_DEFAULT)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd == 43)\n    {\n        /* select session */\n        in_uint32_be(c->in_s, (*sid));\n\n        /* checking sid value */\n        for (idx = 0; idx < sescnt; idx++)\n        {\n            /* the sid is valid */\n            if (ds[idx].SID == (*sid))\n            {\n                /* ok, session selected */\n                return SCP_SERVER_STATE_OK;\n            }\n        }\n\n        /* if we got here, the requested sid wasn't one from the list we sent */\n        /* we should kill the connection                                      */\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error (no such session in list)\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n    else if (cmd == 44)\n    {\n        /* cancel connection */\n        return SCP_SERVER_STATE_SELECTION_CANCEL;\n    }\n    //  else if (cmd == 45)\n    //  {\n    //    /* force new connection */\n    //    return SCP_SERVER_STATE_FORCE_NEW;\n    //  }\n    else\n    {\n        /* wrong response */\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n/* 046 was: 031 struct SCP_DISCONNECTED_SESSION* ds, */\nenum SCP_SERVER_STATES_E\nscp_v1s_reconnect_session(struct SCP_CONNECTION *c, SCP_DISPLAY d)\n{\n    tui32 version = 1;\n    tui32 size = 14;\n    tui16 cmd = 46;\n\n    /* ok, we send session data and display */\n    init_stream(c->out_s, c->out_s->size);\n\n    /* header */\n    out_uint32_be(c->out_s, version);\n    out_uint32_be(c->out_s, size);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n    out_uint16_be(c->out_s, cmd);\n\n    /* session data */\n    out_uint16_be(c->out_s, d); /* session display */\n    /*out_uint8(c->out_s, ds->type);\n    out_uint16_be(c->out_s, ds->height);\n    out_uint16_be(c->out_s, ds->width);\n    out_uint8(c->out_s, ds->bpp);\n    out_uint8(c->out_s, ds->idle_days);\n    out_uint8(c->out_s, ds->idle_hours);\n    out_uint8(c->out_s, ds->idle_minutes);*/\n    /* these last three are not really needed... */\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_v1s_mng.c\n * @brief libscp version 1 server api code - session management\n * @author Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#ifndef LIBSCP_V1S_MNG_C\n#define LIBSCP_V1S_MNG_C\n\n#include \"libscp_v1s_mng.h\"\n\n//extern struct log_config* s_log;\n\nstatic enum SCP_SERVER_STATES_E\n_scp_v1s_mng_check_response(struct SCP_CONNECTION *c, struct SCP_SESSION *s);\n\n/* server API */\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s)\n{\n    struct SCP_SESSION *session;\n    tui32 ipaddr;\n    tui16 cmd;\n    tui8 sz;\n    char buf[257];\n\n    /* reading command */\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 1) /* manager login */\n    {\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    session = scp_session_create();\n\n    if (0 == session)\n    {\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    scp_session_set_version(session, 1);\n    scp_session_set_type(session, SCP_SESSION_TYPE_MANAGE);\n\n    /* reading username */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_username(session, buf))\n    {\n        scp_session_destroy(session);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading password */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_password(session, buf))\n    {\n        scp_session_destroy(session);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading remote address */\n    in_uint8(c->in_s, sz);\n\n    if (sz == SCP_ADDRESS_TYPE_IPV4)\n    {\n        in_uint32_be(c->in_s, ipaddr);\n        scp_session_set_addr(session, sz, &ipaddr);\n    }\n    else if (sz == SCP_ADDRESS_TYPE_IPV6)\n    {\n        in_uint8a(c->in_s, buf, 16);\n        scp_session_set_addr(session, sz, buf);\n    }\n\n    /* reading hostname */\n    in_uint8(c->in_s, sz);\n    buf[sz] = '\\0';\n    in_uint8a(c->in_s, buf, sz);\n\n    if (0 != scp_session_set_hostname(session, buf))\n    {\n        scp_session_destroy(session);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* returning the struct */\n    (*s) = session;\n\n    return SCP_SERVER_STATE_START_MANAGE;\n}\n\n/* 002 */\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_allow_connection(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n{\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 */\n    /* version + size + cmdset + cmd */\n    out_uint32_be(c->out_s, 12);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_MANAGE);\n    out_uint16_be(c->out_s, SCP_CMD_MNG_LOGIN_ALLOW);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, 12))\n    {\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return _scp_v1s_mng_check_response(c, s);\n}\n\n/* 003 */\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_deny_connection(struct SCP_CONNECTION *c, const char *reason)\n{\n    int rlen;\n\n    init_stream(c->out_s, c->out_s->size);\n\n    /* forcing message not to exceed 64k */\n    rlen = g_strlen(reason);\n\n    if (rlen > 65535)\n    {\n        rlen = 65535;\n    }\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 + 2 + strlen(reason)*/\n    /* version + size + cmdset + cmd + msglen + msg */\n    out_uint32_be(c->out_s, rlen + 14);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_MANAGE);\n    out_uint16_be(c->out_s, SCP_CMD_MNG_LOGIN_DENY);\n    out_uint16_be(c->out_s, rlen);\n    out_uint8p(c->out_s, reason, rlen);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, rlen + 14))\n    {\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_END;\n}\n\n/* 006 */\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_list_sessions(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n                          int sescnt, struct SCP_DISCONNECTED_SESSION *ds)\n{\n    tui32 version = 1;\n    tui32 size = 12;\n    tui16 cmd = SCP_CMD_MNG_LIST;\n    int pktcnt;\n    int idx;\n    int sidx;\n    int pidx;\n    struct SCP_DISCONNECTED_SESSION *cds;\n\n    /* calculating the number of packets to send */\n    if (sescnt == 0)\n    {\n      pktcnt = 1;\n    }\n    else\n    {\n      pktcnt = sescnt / SCP_SERVER_MAX_LIST_SIZE;\n\n      if ((sescnt % SCP_SERVER_MAX_LIST_SIZE) != 0)\n      {\n          pktcnt++;\n      }\n    }\n\n    for (idx = 0; idx < pktcnt; idx++)\n    {\n        /* ok, we send session session list */\n        init_stream(c->out_s, c->out_s->size);\n\n        /* size: ver+size+cmdset+cmd+sescnt+continue+count */\n        size = 4 + 4 + 2 + 2 + 4 + 1 + 1;\n\n        /* header */\n        s_push_layer(c->out_s, channel_hdr, 8);\n        out_uint16_be(c->out_s, SCP_COMMAND_SET_MANAGE);\n        out_uint16_be(c->out_s, cmd);\n\n        /* session count */\n        out_uint32_be(c->out_s, sescnt);\n\n        /* setting the continue flag */\n        if ((idx + 1)*SCP_SERVER_MAX_LIST_SIZE >= sescnt)\n        {\n            out_uint8(c->out_s, 0);\n            /* setting session count for this packet */\n            pidx = sescnt - (idx * SCP_SERVER_MAX_LIST_SIZE);\n            out_uint8(c->out_s, pidx);\n        }\n        else\n        {\n            out_uint8(c->out_s, 1);\n            /* setting session count for this packet */\n            pidx = SCP_SERVER_MAX_LIST_SIZE;\n            out_uint8(c->out_s, pidx);\n        }\n\n        /* adding session descriptors */\n        for (sidx = 0; sidx < pidx; sidx++)\n        {\n            /* shortcut to the current session to send */\n            cds = ds + ((idx) * SCP_SERVER_MAX_LIST_SIZE) + sidx;\n\n            /* session data */\n            out_uint32_be(c->out_s, cds->SID); /* session id */\n            out_uint8(c->out_s, cds->type);\n            out_uint16_be(c->out_s, cds->height);\n            out_uint16_be(c->out_s, cds->width);\n            out_uint8(c->out_s, cds->bpp);\n            out_uint8(c->out_s, cds->idle_days);\n            out_uint8(c->out_s, cds->idle_hours);\n            out_uint8(c->out_s, cds->idle_minutes);\n            size += 13;\n\n            out_uint16_be(c->out_s, cds->conn_year);\n            out_uint8(c->out_s, cds->conn_month);\n            out_uint8(c->out_s, cds->conn_day);\n            out_uint8(c->out_s, cds->conn_hour);\n            out_uint8(c->out_s, cds->conn_minute);\n            out_uint8(c->out_s, cds->addr_type);\n            size += 7;\n\n            if (cds->addr_type == SCP_ADDRESS_TYPE_IPV4)\n            {\n                in_uint32_be(c->out_s, cds->ipv4addr);\n                size += 4;\n            }\n            else if (cds->addr_type == SCP_ADDRESS_TYPE_IPV6)\n            {\n                in_uint8a(c->out_s, cds->ipv6addr, 16);\n                size += 16;\n            }\n        }\n\n        s_pop_layer(c->out_s, channel_hdr);\n        out_uint32_be(c->out_s, version);\n        out_uint32_be(c->out_s, size);\n\n        if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    return _scp_v1s_mng_check_response(c, s);\n}\n\nstatic enum SCP_SERVER_STATES_E\n_scp_v1s_mng_check_response(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n{\n    tui32 version;\n    tui32 size;\n    tui16 cmd;\n    //   tui8 dim;\n    //   char buf[257];\n\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    init_stream(c->in_s, c->in_s->size);\n\n    /* read the rest of the packet */\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != SCP_COMMAND_SET_MANAGE)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd == SCP_CMD_MNG_LIST_REQ) /* request session list */\n    {\n        log_message(LOG_LEVEL_INFO, \"[v1s_mng:%d] request session list\", __LINE__);\n        return SCP_SERVER_STATE_MNG_LISTREQ;\n    }\n    else if (cmd == SCP_CMD_MNG_ACTION) /* execute an action */\n    {\n        /*in_uint8(c->in_s, dim);\n        buf[dim]='\\0';\n        in_uint8a(c->in_s, buf, dim);\n        scp_session_set_errstr(s, buf);*/\n\n        log_message(LOG_LEVEL_INFO, \"[v1s_mng:%d] action request\", __LINE__);\n        return SCP_SERVER_STATE_MNG_ACTION;\n    }\n\n    /* else if (cmd == 20) / * password change * /\n    {\n      in_uint16_be(c->in_s, s->display);\n\n      return SCP_SERVER_STATE_OK;\n    }\n    else if (cmd == 40) / * session list * /\n    {\n      return SCP_SERVER_STATE_SESSION_LIST;\n    }*/\n\n    log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: sequence error\", __LINE__);\n    return SCP_SERVER_STATE_SEQUENCE_ERR;\n}\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2015\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file scp.c\n * @brief scp (sesman control protocol) common code\n *        scp (sesman control protocol) common code\n *        This code controls which version is being used and starts the\n *        appropriate process\n * @author Jay Sorg, Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"sesman.h\"\n\nextern struct config_sesman *g_cfg; /* in sesman.c */\n\n/******************************************************************************/\nvoid *\nscp_process_start(void *sck)\n{\n    struct SCP_CONNECTION scon;\n    struct SCP_SESSION *sdata = NULL;\n\n    scon.in_sck = (int)(tintptr)sck;\n    LOG_DBG(\"started scp thread on socket %d\", scon.in_sck);\n\n    make_stream(scon.in_s);\n    make_stream(scon.out_s);\n\n    init_stream(scon.in_s, 8192);\n    init_stream(scon.out_s, 8192);\n\n    switch (scp_vXs_accept(&scon, &(sdata)))\n    {\n        case SCP_SERVER_STATE_OK:\n\n            if (sdata->version == 0)\n            {\n                /* starts processing an scp v0 connection */\n                LOG_DBG(\"accept ok, go on with scp v0\");\n                scp_v0_process(&scon, sdata);\n            }\n            else\n            {\n                LOG_DBG(\"accept ok, go on with scp v1\");\n                /*LOG_DBG(\"user: %s\\npass: %s\",sdata->username, sdata->password);*/\n                scp_v1_process(&scon, sdata);\n            }\n\n            break;\n        case SCP_SERVER_STATE_START_MANAGE:\n            /* starting a management session */\n            log_message(LOG_LEVEL_WARNING,\n                        \"starting a sesman management session...\");\n            scp_v1_mng_process(&scon, sdata);\n            break;\n        case SCP_SERVER_STATE_VERSION_ERR:\n            /* an unknown scp version was requested, so we shut down the */\n            /* connection (and log the fact)                             */\n            log_message(LOG_LEVEL_WARNING,\n                        \"unknown protocol version specified. connection refused.\");\n            break;\n        case SCP_SERVER_STATE_NETWORK_ERR:\n            log_message(LOG_LEVEL_WARNING, \"libscp network error.\");\n            break;\n        case SCP_SERVER_STATE_SEQUENCE_ERR:\n            log_message(LOG_LEVEL_WARNING, \"libscp sequence error.\");\n            break;\n        case SCP_SERVER_STATE_INTERNAL_ERR:\n            /* internal error occurred (eg. malloc() error, ecc.) */\n            log_message(LOG_LEVEL_ERROR, \"libscp internal error occurred.\");\n            break;\n        default:\n            log_message(LOG_LEVEL_ALWAYS, \"unknown return from scp_vXs_accept()\");\n            break;\n    }\n\n    free_stream(scon.in_s);\n    free_stream(scon.out_s);\n\n    if (sdata)\n    {\n        scp_session_destroy(sdata);\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_types.h\n * @brief libscp data types definitions\n * @author Simone Fedele\n *\n */\n\n#ifndef LIBSCP_TYPES_H\n#define LIBSCP_TYPES_H\n\n#include \"os_calls.h\"\n#include \"parse.h\"\n#include \"arch.h\"\n#include \"log.h\"\n\n#define SCP_SID      tui32\n#define SCP_DISPLAY  tui16\n\n#define SCP_RESOURCE_SHARING_REQUEST_YES 0x01\n#define SCP_RESOURCE_SHARING_REQUEST_NO  0x00\n\n#define SCP_SESSION_TYPE_XVNC    0x00\n#define SCP_SESSION_TYPE_XRDP    0x01\n#define SCP_SESSION_TYPE_MANAGE  0x02\n#define SCP_SESSION_TYPE_XORG    0x03\n\n/* SCP_GW_AUTHENTICATION can be used when XRDP + sesman act as a gateway\n * XRDP sends this command to let sesman verify if the user is allowed\n * to use the gateway */\n#define SCP_GW_AUTHENTICATION    0x04\n\n#define SCP_ADDRESS_TYPE_IPV4 0x00\n#define SCP_ADDRESS_TYPE_IPV6 0x01\n\n#define SCP_COMMAND_SET_DEFAULT 0x0000\n#define SCP_COMMAND_SET_MANAGE  0x0001\n#define SCP_COMMAND_SET_RSR     0x0002\n\n#define SCP_SERVER_MAX_LIST_SIZE 100\n\n#include \"libscp_types_mng.h\"\n\n/* Max server incoming and outgoing message size, used to stop memory\n   exhaustion attempts (CVE-2020-4044) */\n#define SCP_MAX_MESSAGE_SIZE 8192\n\nstruct SCP_CONNECTION\n{\n  int in_sck;\n  struct stream* in_s;\n  struct stream* out_s;\n};\n\nstruct SCP_SESSION\n{\n  tui8  type;\n  tui32 version;\n  tui16 height;\n  tui16 width;\n  tui8  bpp;\n  tui8  rsr;\n  char  locale[18];\n  char* username;\n  char* password;\n  char* hostname;\n  tui8  addr_type;\n  tui32 ipv4addr;\n  tui8  ipv6addr[16];\n  SCP_DISPLAY display;\n  char* errstr;\n  struct SCP_MNG_DATA* mng;\n  char* domain;\n  char* program;\n  char* directory;\n  char* client_ip;\n  tui8 guid[16];\n};\n\nstruct SCP_DISCONNECTED_SESSION\n{\n  tui32 SID;\n  tui8  type;\n  tui8  status;\n  tui16 height;\n  tui16 width;\n  tui8  bpp;\n  tui8  idle_days;\n  tui8  idle_hours;\n  tui8  idle_minutes;\n  tui16 conn_year;\n  tui8  conn_month;\n  tui8  conn_day;\n  tui8  conn_hour;\n  tui8  conn_minute;\n  tui8  addr_type;\n  tui32 ipv4addr;\n  tui8  ipv6addr[16];\n};\n\nenum SCP_CLIENT_STATES_E\n{\n  SCP_CLIENT_STATE_OK,\n  SCP_CLIENT_STATE_NETWORK_ERR,\n  SCP_CLIENT_STATE_VERSION_ERR,\n  SCP_CLIENT_STATE_SEQUENCE_ERR,\n  SCP_CLIENT_STATE_SIZE_ERR,\n  SCP_CLIENT_STATE_INTERNAL_ERR,\n  SCP_CLIENT_STATE_SESSION_LIST,\n  SCP_CLIENT_STATE_LIST_OK,\n  SCP_CLIENT_STATE_RESEND_CREDENTIALS,\n  SCP_CLIENT_STATE_CONNECTION_DENIED,\n  SCP_CLIENT_STATE_PWD_CHANGE_REQ,\n  SCP_CLIENT_STATE_RECONNECT_SINGLE,\n  SCP_CLIENT_STATE_SELECTION_CANCEL,\n  SCP_CLIENT_STATE_END\n};\n\nenum SCP_SERVER_STATES_E\n{\n  SCP_SERVER_STATE_OK,\n  SCP_SERVER_STATE_VERSION_ERR,\n  SCP_SERVER_STATE_NETWORK_ERR,\n  SCP_SERVER_STATE_SEQUENCE_ERR,\n  SCP_SERVER_STATE_INTERNAL_ERR,\n  SCP_SERVER_STATE_SESSION_TYPE_ERR,\n  SCP_SERVER_STATE_SIZE_ERR,\n  SCP_SERVER_STATE_SELECTION_CANCEL,\n  /*SCP_SERVER_STATE_FORCE_NEW,*/\n  SCP_SERVER_STATE_START_MANAGE,\n  SCP_SERVER_STATE_MNG_LISTREQ,\n  SCP_SERVER_STATE_MNG_ACTION,\n  SCP_SERVER_STATE_END\n};\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_v0.c\n * @brief libscp version 0 code\n * @author Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"libscp_v0.h\"\n\n#include \"os_calls.h\"\n\nextern struct log_config *s_log;\n\n/** Maximum length of a string (two bytes + len), excluding the terminator\n *\n * Practially this is limited by [MS-RDPBCGR] TS_INFO_PACKET\n * */\n#define STRING16_MAX_LEN 512\n\n/**\n * Reads a big-endian uint16 followed by a string into a buffer\n *\n * Buffer is null-terminated on success\n *\n * @param s Input stream\n * @param [out] Output buffer (must be >= (STRING16_MAX_LEN+1) chars)\n * @param param Parameter we're reading\n * @param line Line number reference\n * @return != 0 if string read OK\n */\nstatic\nint in_string16(struct stream *s, char str[], const char *param, int line)\n{\n    int result;\n\n    if (!s_check_rem(s, 2))\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v0:%d] connection aborted: %s len missing\",\n                    line, param);\n        result = 0;\n    }\n    else\n    {\n        unsigned int sz;\n\n        in_uint16_be(s, sz);\n        if (sz > STRING16_MAX_LEN)\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v0:%d] connection aborted: %s too long (%u chars)\",\n                        line, param, sz);\n            result = 0;\n        }\n        else\n        {\n            result = s_check_rem(s, sz);\n            if (!result)\n            {\n                log_message(LOG_LEVEL_WARNING,\n                            \"[v0:%d] connection aborted: %s data missing\",\n                            line, param);\n            }\n            else\n            {\n                in_uint8a(s, str, sz);\n                str[sz] = '\\0';\n            }\n        }\n    }\n    return result;\n}\n/* client API */\n/******************************************************************************/\nenum SCP_CLIENT_STATES_E\nscp_v0c_connect(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n{\n    tui32 version;\n    tui32 size;\n    tui16 sz;\n\n    init_stream(c->in_s, c->in_s->size);\n    init_stream(c->out_s, c->in_s->size);\n\n    LOG_DBG(\"[v0:%d] starting connection\", __LINE__);\n    g_tcp_set_non_blocking(c->in_sck);\n    g_tcp_set_no_delay(c->in_sck);\n    s_push_layer(c->out_s, channel_hdr, 8);\n\n    /* code */\n    if (s->type == SCP_SESSION_TYPE_XVNC)\n    {\n        out_uint16_be(c->out_s, 0);\n    }\n    else if (s->type == SCP_SESSION_TYPE_XRDP)\n    {\n        out_uint16_be(c->out_s, 10);\n    }\n    else if (s->type == SCP_SESSION_TYPE_XORG)\n    {\n        out_uint16_be(c->out_s, 20);\n    }\n    else\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_INTERNAL_ERR;\n    }\n\n    sz = g_strlen(s->username);\n    if (sz > STRING16_MAX_LEN)\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v0:%d] connection aborted: username too long\",\n                    __LINE__);\n        return SCP_CLIENT_STATE_SIZE_ERR;\n    }\n    out_uint16_be(c->out_s, sz);\n    out_uint8a(c->out_s, s->username, sz);\n\n    sz = g_strlen(s->password);\n    if (sz > STRING16_MAX_LEN)\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v0:%d] connection aborted: password too long\",\n                    __LINE__);\n        return SCP_CLIENT_STATE_SIZE_ERR;\n    }\n    out_uint16_be(c->out_s, sz);\n    out_uint8a(c->out_s, s->password, sz);\n    out_uint16_be(c->out_s, s->width);\n    out_uint16_be(c->out_s, s->height);\n    out_uint16_be(c->out_s, s->bpp);\n\n    s_mark_end(c->out_s);\n    s_pop_layer(c->out_s, channel_hdr);\n\n    /* version */\n    out_uint32_be(c->out_s, 0);\n    /* size */\n    out_uint32_be(c->out_s, c->out_s->end - c->out_s->data);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_NETWORK_ERR;\n    }\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (0 != version)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: version error\", __LINE__);\n        return SCP_CLIENT_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    if (size < (8 + 2 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v0:%d] connection aborted: msg size = %u\",\n                    __LINE__, (unsigned int)size);\n        return SCP_CLIENT_STATE_SIZE_ERR;\n    }\n\n    /* getting payload */\n    init_stream(c->in_s, size - 8);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_CLIENT_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    /* check code */\n    in_uint16_be(c->in_s, sz);\n\n    if (3 != sz)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_CLIENT_STATE_SEQUENCE_ERR;\n    }\n\n    /* message payload */\n    in_uint16_be(c->in_s, sz);\n\n    if (1 != sz)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: connection denied\", __LINE__);\n        return SCP_CLIENT_STATE_CONNECTION_DENIED;\n    }\n\n    in_uint16_be(c->in_s, sz);\n    s->display = sz;\n\n    LOG_DBG(\"[v0:%d] connection terminated\", __LINE__);\n    return SCP_CLIENT_STATE_END;\n}\n\n/**\n * Initialises a V0 session object\n *\n * At the time of the call, the version has been read from the connection\n *\n * @param c Connection\n * @param [out] session pre-allocated session object\n * @return SCP_SERVER_STATE_OK for success\n */\nstatic enum SCP_SERVER_STATES_E\nscp_v0s_init_session(struct SCP_CONNECTION *c, struct SCP_SESSION *session)\n{\n    tui32 size;\n    tui16 height;\n    tui16 width;\n    tui16 bpp;\n    tui32 code = 0;\n    char buf[STRING16_MAX_LEN + 1];\n\n    scp_session_set_version(session, 0);\n\n    /* Check for a header and a code value in the length */\n    in_uint32_be(c->in_s, size);\n    if (size < (8 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v0:%d] connection aborted: msg size = %u\",\n                    __LINE__, (unsigned int)size);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, size - 8);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    in_uint16_be(c->in_s, code);\n\n    if (code == 0 || code == 10 || code == 20)\n    {\n        if (code == 0)\n        {\n            scp_session_set_type(session, SCP_SESSION_TYPE_XVNC);\n        }\n        else if (code == 10)\n        {\n            scp_session_set_type(session, SCP_SESSION_TYPE_XRDP);\n        }\n        else if (code == 20)\n        {\n            scp_session_set_type(session, SCP_SESSION_TYPE_XORG);\n        }\n\n        /* reading username */\n        if (!in_string16(c->in_s, buf, \"username\", __LINE__))\n        {\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n        if (0 != scp_session_set_username(session, buf))\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting username\", __LINE__);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n\n        /* reading password */\n        if (!in_string16(c->in_s, buf, \"passwd\", __LINE__))\n        {\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n        if (0 != scp_session_set_password(session, buf))\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting password\", __LINE__);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n\n        /* width  + height + bpp */\n        if (!s_check_rem(c->in_s, 2 + 2 + 2))\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v0:%d] connection aborted: width+height+bpp missing\",\n                        __LINE__);\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n        in_uint16_be(c->in_s, width);\n        scp_session_set_width(session, width);\n        in_uint16_be(c->in_s, height);\n        scp_session_set_height(session, height);\n        in_uint16_be(c->in_s, bpp);\n        if (0 != scp_session_set_bpp(session, (tui8)bpp))\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v0:%d] connection aborted: unsupported bpp: %d\",\n                        __LINE__, (tui8)bpp);\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading domain */\n            if (!in_string16(c->in_s, buf, \"domain\", __LINE__))\n            {\n                return SCP_SERVER_STATE_SIZE_ERR;\n            }\n            if (buf[0] != '\\0')\n            {\n                scp_session_set_domain(session, buf);\n            }\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading program */\n            if (!in_string16(c->in_s, buf, \"program\", __LINE__))\n            {\n                return SCP_SERVER_STATE_SIZE_ERR;\n            }\n\n            if (buf[0] != '\\0')\n            {\n                scp_session_set_program(session, buf);\n            }\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading directory */\n            if (!in_string16(c->in_s, buf, \"directory\", __LINE__))\n            {\n                return SCP_SERVER_STATE_SIZE_ERR;\n            }\n\n            if (buf[0] != '\\0')\n            {\n                scp_session_set_directory(session, buf);\n            }\n        }\n\n        if (s_check_rem(c->in_s, 2))\n        {\n            /* reading client IP address */\n            if (!in_string16(c->in_s, buf, \"client IP\", __LINE__))\n            {\n                return SCP_SERVER_STATE_SIZE_ERR;\n            }\n            if (buf[0] != '\\0')\n            {\n                scp_session_set_client_ip(session, buf);\n            }\n        }\n    }\n    else if (code == SCP_GW_AUTHENTICATION)\n    {\n        scp_session_set_type(session, SCP_GW_AUTHENTICATION);\n        /* reading username */\n        if (!in_string16(c->in_s, buf, \"username\", __LINE__))\n        {\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n\n        /* g_writeln(\"Received user name: %s\",buf); */\n        if (0 != scp_session_set_username(session, buf))\n        {\n            /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting        username\", __LINE__);*/\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n\n        /* reading password */\n        if (!in_string16(c->in_s, buf, \"passwd\", __LINE__))\n        {\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n\n        /* g_writeln(\"Received password: %s\",buf); */\n        if (0 != scp_session_set_password(session, buf))\n        {\n            /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: error setting password\", __LINE__); */\n            return SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n    }\n    else\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n\n/* server API */\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n{\n    enum SCP_SERVER_STATES_E result = SCP_SERVER_STATE_OK;\n    struct SCP_SESSION *session = NULL;\n    tui32 version = 0;\n\n    if (!skipVchk)\n    {\n        LOG_DBG(\"[v0:%d] starting connection\", __LINE__);\n\n        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n        {\n            c->in_s->end = c->in_s->data + 8;\n            in_uint32_be(c->in_s, version);\n\n            if (version != 0)\n            {\n                log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: version error\", __LINE__);\n                result = SCP_SERVER_STATE_VERSION_ERR;\n            }\n        }\n        else\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n            result = SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    if (result == SCP_SERVER_STATE_OK)\n    {\n        session = scp_session_create();\n        if (NULL == session)\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v0:%d] connection aborted: no memory\",\n                        __LINE__);\n            result = SCP_SERVER_STATE_INTERNAL_ERR;\n        }\n        else\n        {\n            result = scp_v0s_init_session(c, session);\n            if (result != SCP_SERVER_STATE_OK)\n            {\n                scp_session_destroy(session);\n                session = NULL;\n            }\n        }\n    }\n\n    (*s) = session;\n\n    return result;\n}\n\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_allow_connection(struct SCP_CONNECTION *c, SCP_DISPLAY d, const tui8 *guid)\n{\n    int msg_size;\n\n    msg_size = guid == 0 ? 14 : 14 + 16;\n    out_uint32_be(c->out_s, 0);  /* version */\n    out_uint32_be(c->out_s, msg_size); /* size */\n    out_uint16_be(c->out_s, 3);  /* cmd */\n    out_uint16_be(c->out_s, 1);  /* data */\n    out_uint16_be(c->out_s, d);  /* data */\n    if (msg_size > 14)\n    {\n        out_uint8a(c->out_s, guid, 16);\n    }\n    s_mark_end(c->out_s);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    LOG_DBG(\"[v0:%d] connection terminated (allowed)\", __LINE__);\n    return SCP_SERVER_STATE_OK;\n}\n\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_deny_connection(struct SCP_CONNECTION *c)\n{\n    out_uint32_be(c->out_s, 0);  /* version */\n    out_uint32_be(c->out_s, 14); /* size */\n    out_uint16_be(c->out_s, 3);  /* cmd */\n    out_uint16_be(c->out_s, 0);  /* data = 0 - means NOT ok*/\n    out_uint16_be(c->out_s, 0);  /* reserved for display number*/\n    s_mark_end(c->out_s);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    LOG_DBG(\"[v0:%d] connection terminated (denied)\", __LINE__);\n    return SCP_SERVER_STATE_OK;\n}\n\n/******************************************************************************/\nenum SCP_SERVER_STATES_E\nscp_v0s_replyauthentication(struct SCP_CONNECTION *c, unsigned short int value)\n{\n    out_uint32_be(c->out_s, 0);  /* version */\n    out_uint32_be(c->out_s, 14); /* size */\n    /* cmd SCP_GW_AUTHENTICATION means authentication reply */\n    out_uint16_be(c->out_s, SCP_GW_AUTHENTICATION);\n    out_uint16_be(c->out_s, value);  /* reply code  */\n    out_uint16_be(c->out_s, 0);  /* dummy data */\n    s_mark_end(c->out_s);\n\n    /* g_writeln(\"Total number of bytes that will be sent %d\",c->out_s->end - c->out_s->data);*/\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))\n    {\n        /* until syslog merge log_message(s_log, LOG_LEVEL_WARNING, \"[v0:%d] connection aborted: network error\", __LINE__); */\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    /* until syslog merge LOG_DBG(s_log, \"[v0:%d] connection terminated (scp_v0s_deny_authentication)\", __LINE__);*/\n    return SCP_SERVER_STATE_OK;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_v1s.c\n * @brief libscp version 1 server api code\n * @author Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#ifndef LIBSCP_V1S_C\n#define LIBSCP_V1S_C\n\n#include \"libscp_v1s.h\"\n\n//extern struct log_config* s_log;\n\n/**\n * Reads a uint8 followed by a string into a buffer\n *\n * Buffer is null-terminated on success\n *\n * @param s Input stream\n * @param [out] Output buffer (must be >= 256 chars)\n * @param param Parameter we're reading\n * @param line Line number reference\n * @return != 0 if string read OK\n *\n * @todo\n *     This needs to be merged with the func of the same name in\n *     libscp_v1s_mng.c\n */\nstatic\nint in_string8(struct stream *s, char str[], const char *param, int line)\n{\n    int result;\n\n    if (!s_check_rem(s, 1))\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s:%d] connection aborted: %s len missing\",\n                    line, param);\n        result = 0;\n    }\n    else\n    {\n        unsigned int sz;\n\n        in_uint8(s, sz);\n        result = s_check_rem(s, sz);\n        if (!result)\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v1s:%d] connection aborted: %s data missing\",\n                        line, param);\n        }\n        else\n        {\n            in_uint8a(s, str, sz);\n            str[sz] = '\\0';\n        }\n    }\n    return result;\n}\n/* server API */\n\n/**\n * Initialises a V1 session object\n *\n * This is called after the V1 header, command set and command have been read\n *\n * @param c Connection\n * @param [out] session pre-allocated session object\n * @return SCP_SERVER_STATE_OK for success\n */\nstatic enum SCP_SERVER_STATES_E\nscp_v1s_init_session(struct SCP_CONNECTION *c, struct SCP_SESSION *session)\n{\n    tui8 type;\n    tui16 height;\n    tui16 width;\n    tui8 bpp;\n    tui8 sz;\n    char buf[256];\n\n    scp_session_set_version(session, 1);\n\n    /* Check there's data for the session type, the height, the width, the\n     * bpp, the resource sharing indicator and the locale */\n    if (!s_check_rem(c->in_s, 1 + 2 + 2 + 1 + 1 + 17))\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s:%d] connection aborted: short packet\",\n                    __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    in_uint8(c->in_s, type);\n\n    if ((type != SCP_SESSION_TYPE_XVNC) && (type != SCP_SESSION_TYPE_XRDP))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: unknown session type\", __LINE__);\n        return SCP_SERVER_STATE_SESSION_TYPE_ERR;\n    }\n\n    scp_session_set_type(session, type);\n\n    in_uint16_be(c->in_s, height);\n    scp_session_set_height(session, height);\n    in_uint16_be(c->in_s, width);\n    scp_session_set_width(session, width);\n    in_uint8(c->in_s, bpp);\n    if (0 != scp_session_set_bpp(session, bpp))\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s:%d] connection aborted: unsupported bpp: %d\",\n                    __LINE__, bpp);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n    in_uint8(c->in_s, sz);\n    scp_session_set_rsr(session, sz);\n    in_uint8a(c->in_s, buf, 17);\n    buf[17] = '\\0';\n    scp_session_set_locale(session, buf);\n\n    /* Check there's enough data left for at least an IPv4 address (+len) */\n    if (!s_check_rem(c->in_s, 1 + 4))\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s:%d] connection aborted: IP addr len missing\",\n                    __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    in_uint8(c->in_s, sz);\n\n    if (sz == SCP_ADDRESS_TYPE_IPV4)\n    {\n        tui32 ipv4;\n        in_uint32_be(c->in_s, ipv4);\n        scp_session_set_addr(session, sz, &ipv4);\n    }\n    else if (sz == SCP_ADDRESS_TYPE_IPV6)\n    {\n        if (!s_check_rem(c->in_s, 16))\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v1s:%d] connection aborted: IP addr missing\",\n                        __LINE__);\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n        in_uint8a(c->in_s, buf, 16);\n        scp_session_set_addr(session, sz, buf);\n    }\n\n    /* reading hostname */\n    if (!in_string8(c->in_s, buf, \"hostname\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_hostname(session, buf))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading username */\n    if (!in_string8(c->in_s, buf, \"username\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_username(session, buf))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading password */\n    if (!in_string8(c->in_s, buf, \"passwd\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_password(session, buf))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n/* server API */\nenum SCP_SERVER_STATES_E scp_v1s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)\n{\n    enum SCP_SERVER_STATES_E result;\n    struct SCP_SESSION *session;\n    tui32 version;\n    tui32 size;\n    tui16 cmdset;\n    tui16 cmd;\n\n    (*s) = NULL;\n\n    if (!skipVchk)\n    {\n\n        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n        {\n            in_uint32_be(c->in_s, version);\n\n            if (version != 1)\n            {\n                log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n                return SCP_SERVER_STATE_VERSION_ERR;\n            }\n        }\n        else\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    /* Check the message is big enough for the header, the command set, and\n     * the command (but not too big) */\n    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, size - 8);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    /* reading command set */\n    in_uint16_be(c->in_s, cmdset);\n\n    /* if we are starting a management session */\n    if (cmdset == SCP_COMMAND_SET_MANAGE)\n    {\n        log_message(LOG_LEVEL_DEBUG, \"[v1s:%d] requested management connection\", __LINE__);\n        /* should return SCP_SERVER_STATE_START_MANAGE */\n        return scp_v1s_mng_accept(c, s);\n    }\n\n    /* if we started with resource sharing... */\n    if (cmdset == SCP_COMMAND_SET_RSR)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    /* reading command */\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    session = scp_session_create();\n\n    if (NULL == session)\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s:%d] connection aborted: internal error \"\n                    \"(malloc returned NULL)\", __LINE__);\n        result = SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n    else\n    {\n        result = scp_v1s_init_session(c, session);\n        if (result != SCP_SERVER_STATE_OK)\n        {\n            scp_session_destroy(session);\n            session = NULL;\n        }\n    }\n\n    /* returning the struct */\n    (*s) = session;\n\n    return result;\n}\n\nenum SCP_SERVER_STATES_E\nscp_v1s_deny_connection(struct SCP_CONNECTION *c, const char *reason)\n{\n    int rlen;\n\n    init_stream(c->out_s, c->out_s->size);\n\n    /* forcing message not to exceed 64k */\n    rlen = g_strlen(reason);\n\n    if (rlen > 65535)\n    {\n        rlen = 65535;\n    }\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 + 2 + strlen(reason)*/\n    /* version + size + cmdset + cmd + msglen + msg */\n    out_uint32_be(c->out_s, rlen + 14);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n    out_uint16_be(c->out_s, 2);\n    out_uint16_be(c->out_s, rlen);\n    out_uint8p(c->out_s, reason, rlen);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, rlen + 14))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_END;\n}\n\nenum SCP_SERVER_STATES_E\nscp_v1s_request_password(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n                         const char *reason)\n{\n    tui32 version;\n    tui32 size;\n    tui16 cmdset;\n    tui16 cmd;\n    int rlen;\n    char buf[256];\n\n    init_stream(c->in_s, c->in_s->size);\n    init_stream(c->out_s, c->out_s->size);\n\n    /* forcing message not to exceed 64k */\n    rlen = g_strlen(reason);\n\n    if (rlen > 65535)\n    {\n        rlen = 65535;\n    }\n\n    /* send password request */\n    version = 1;\n    cmd = 3;\n\n    out_uint32_be(c->out_s, version);                 /* version */\n    out_uint32_be(c->out_s, 14 + rlen);               /* size    */\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT); /* cmdset  */\n    out_uint16_be(c->out_s, cmd);                     /* cmd     */\n\n    out_uint16_be(c->out_s, rlen);\n    out_uint8p(c->out_s, reason, rlen);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, 14 + rlen))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    /* receive password & username */\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    /* Check the message is big enough for the header, the command set, and\n     * the command (but not too big) */\n    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s:%d] connection aborted: size error\",\n                    __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, size - 8);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    in_uint16_be(c->in_s, cmdset);\n\n    if (cmdset != SCP_COMMAND_SET_DEFAULT)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 4)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    /* reading username */\n    if (!in_string8(c->in_s, buf, \"username\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_username(s, buf))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading password */\n    if (!in_string8(c->in_s, buf, \"passwd\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_password(s, buf))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n/* 020 */\nenum SCP_SERVER_STATES_E\nscp_v1s_request_pwd_change(struct SCP_CONNECTION *c, char *reason, char *npw)\n{\n    return SCP_SERVER_STATE_INTERNAL_ERR;\n}\n\n/* 023 */\nenum SCP_SERVER_STATES_E\nscp_v1s_pwd_change_error(struct SCP_CONNECTION *c, char *error, int retry, char *npw)\n{\n    return SCP_SERVER_STATE_INTERNAL_ERR;\n}\n\n/* 030 */\nenum SCP_SERVER_STATES_E\nscp_v1s_connect_new_session(struct SCP_CONNECTION *c, SCP_DISPLAY d)\n{\n    /* send password request */\n    tui32 version = 1;\n    tui32 size = 14;\n    tui16 cmd = 30;\n\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, version);                 /* version */\n    out_uint32_be(c->out_s, size);                    /* size    */\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT); /* cmdset  */\n    out_uint16_be(c->out_s, cmd);                     /* cmd     */\n\n    out_uint16_be(c->out_s, d);                       /* display */\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, 14))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n/* 032 */\nenum SCP_SERVER_STATES_E\nscp_v1s_connection_error(struct SCP_CONNECTION *c, const char *error)\n{\n    tui16 len;\n\n    len = g_strlen(error);\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 + len */\n    /* version + size + cmdset + cmd */\n    out_uint32_be(c->out_s, (12 + len));\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n    out_uint16_be(c->out_s, SCP_CMD_CONN_ERROR);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, (12 + len)))\n    {\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_END;\n}\n\n/* 040 */\nenum SCP_SERVER_STATES_E\nscp_v1s_list_sessions(struct SCP_CONNECTION *c, int sescnt, struct SCP_DISCONNECTED_SESSION *ds, SCP_SID *sid)\n{\n    tui32 version = 1;\n    tui32 size = 12;\n    tui16 cmd = 40;\n    int pktcnt;\n    int idx;\n    int sidx;\n    int pidx;\n    struct SCP_DISCONNECTED_SESSION *cds;\n\n    /* first we send a notice that we have some disconnected sessions */\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, version);                 /* version */\n    out_uint32_be(c->out_s, size);                    /* size    */\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT); /* cmdset  */\n    out_uint16_be(c->out_s, cmd);                     /* cmd     */\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    /* then we wait for client ack */\n\n    /*\n     * Maybe this message could say if the session should be resized on\n     * server side or client side.\n     */\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    /* Check the message is big enough for the header, the command set, and\n     * the command (but not too big) */\n    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, size - 8);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != SCP_COMMAND_SET_DEFAULT)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 41)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    /* calculating the number of packets to send */\n    pktcnt = sescnt / SCP_SERVER_MAX_LIST_SIZE;\n\n    if ((sescnt % SCP_SERVER_MAX_LIST_SIZE) != 0)\n    {\n        pktcnt++;\n    }\n\n    for (idx = 0; idx < pktcnt; idx++)\n    {\n        /* ok, we send session session list */\n        init_stream(c->out_s, c->out_s->size);\n\n        /* size: ver+size+cmdset+cmd+sescnt+continue+count */\n        size = 4 + 4 + 2 + 2 + 4 + 1 + 1;\n\n        /* header */\n        cmd = 42;\n        s_push_layer(c->out_s, channel_hdr, 8);\n        out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n        out_uint16_be(c->out_s, cmd);\n\n        /* session count */\n        out_uint32_be(c->out_s, sescnt);\n\n        /* setting the continue flag */\n        if ((idx + 1)*SCP_SERVER_MAX_LIST_SIZE >= sescnt)\n        {\n            out_uint8(c->out_s, 0);\n            /* setting session count for this packet */\n            pidx = sescnt - (idx * SCP_SERVER_MAX_LIST_SIZE);\n            out_uint8(c->out_s, pidx);\n        }\n        else\n        {\n            out_uint8(c->out_s, 1);\n            /* setting session count for this packet */\n            pidx = SCP_SERVER_MAX_LIST_SIZE;\n            out_uint8(c->out_s, pidx);\n        }\n\n        /* adding session descriptors */\n        for (sidx = 0; sidx < pidx; sidx++)\n        {\n            /* shortcut to the current session to send */\n            cds = ds + ((idx) * SCP_SERVER_MAX_LIST_SIZE) + sidx;\n\n            /* session data */\n            out_uint32_be(c->out_s, cds->SID); /* session id */\n            out_uint8(c->out_s, cds->type);\n            out_uint16_be(c->out_s, cds->height);\n            out_uint16_be(c->out_s, cds->width);\n            out_uint8(c->out_s, cds->bpp);\n            out_uint8(c->out_s, cds->idle_days);\n            out_uint8(c->out_s, cds->idle_hours);\n            out_uint8(c->out_s, cds->idle_minutes);\n            size += 13;\n\n            out_uint16_be(c->out_s, cds->conn_year);\n            out_uint8(c->out_s, cds->conn_month);\n            out_uint8(c->out_s, cds->conn_day);\n            out_uint8(c->out_s, cds->conn_hour);\n            out_uint8(c->out_s, cds->conn_minute);\n            out_uint8(c->out_s, cds->addr_type);\n            size += 7;\n\n            if (cds->addr_type == SCP_ADDRESS_TYPE_IPV4)\n            {\n                in_uint32_be(c->out_s, cds->ipv4addr);\n                size += 4;\n            }\n            else if (cds->addr_type == SCP_ADDRESS_TYPE_IPV6)\n            {\n                in_uint8a(c->out_s, cds->ipv6addr, 16);\n                size += 16;\n            }\n        }\n\n        s_pop_layer(c->out_s, channel_hdr);\n        out_uint32_be(c->out_s, version);\n        out_uint32_be(c->out_s, size);\n\n        if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    /* we get the response */\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    /* Check the message is big enough for the header, the command set, and\n     * the command (but not too big) */\n    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    /* rest of the packet */\n    init_stream(c->in_s, size - 8);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != SCP_COMMAND_SET_DEFAULT)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd == 43)\n    {\n        if (!s_check_rem(c->in_s, 4))\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: missing session\", __LINE__);\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n        /* select session */\n        in_uint32_be(c->in_s, (*sid));\n\n        /* checking sid value */\n        for (idx = 0; idx < sescnt; idx++)\n        {\n            /* the sid is valid */\n            if (ds[idx].SID == (*sid))\n            {\n                /* ok, session selected */\n                return SCP_SERVER_STATE_OK;\n            }\n        }\n\n        /* if we got here, the requested sid wasn't one from the list we sent */\n        /* we should kill the connection                                      */\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: internal error (no such session in list)\", __LINE__);\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n    else if (cmd == 44)\n    {\n        /* cancel connection */\n        return SCP_SERVER_STATE_SELECTION_CANCEL;\n    }\n    //  else if (cmd == 45)\n    //  {\n    //    /* force new connection */\n    //    return SCP_SERVER_STATE_FORCE_NEW;\n    //  }\n    else\n    {\n        /* wrong response */\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n/* 046 was: 031 struct SCP_DISCONNECTED_SESSION* ds, */\nenum SCP_SERVER_STATES_E\nscp_v1s_reconnect_session(struct SCP_CONNECTION *c, SCP_DISPLAY d)\n{\n    tui32 version = 1;\n    tui32 size = 14;\n    tui16 cmd = 46;\n\n    /* ok, we send session data and display */\n    init_stream(c->out_s, c->out_s->size);\n\n    /* header */\n    out_uint32_be(c->out_s, version);\n    out_uint32_be(c->out_s, size);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_DEFAULT);\n    out_uint16_be(c->out_s, cmd);\n\n    /* session data */\n    out_uint16_be(c->out_s, d); /* session display */\n    /*out_uint8(c->out_s, ds->type);\n    out_uint16_be(c->out_s, ds->height);\n    out_uint16_be(c->out_s, ds->width);\n    out_uint8(c->out_s, ds->bpp);\n    out_uint8(c->out_s, ds->idle_days);\n    out_uint8(c->out_s, ds->idle_hours);\n    out_uint8(c->out_s, ds->idle_minutes);*/\n    /* these last three are not really needed... */\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_OK;\n}\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2012\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file libscp_v1s_mng.c\n * @brief libscp version 1 server api code - session management\n * @author Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#ifndef LIBSCP_V1S_MNG_C\n#define LIBSCP_V1S_MNG_C\n\n#include \"libscp_v1s_mng.h\"\n\n//extern struct log_config* s_log;\n\nstatic enum SCP_SERVER_STATES_E\n_scp_v1s_mng_check_response(struct SCP_CONNECTION *c, struct SCP_SESSION *s);\n\n/**\n * Reads a uint8 followed by a string into a buffer\n *\n * Buffer is null-terminated on success\n *\n * @param s Input stream\n * @param [out] Output buffer (must be >= 256 chars)\n * @param param Parameter we're reading\n * @param line Line number reference\n * @return != 0 if string read OK\n *\n * @todo\n *     This needs to be merged with the func of the same name in\n *     libscp_v1s.c\n */\nstatic\nint in_string8(struct stream *s, char str[], const char *param, int line)\n{\n    int result;\n\n    if (!s_check_rem(s, 1))\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s_mng:%d] connection aborted: %s len missing\",\n                    line, param);\n        result = 0;\n    }\n    else\n    {\n        unsigned int sz;\n\n        in_uint8(s, sz);\n        result = s_check_rem(s, sz);\n        if (!result)\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v1s_mng:%d] connection aborted: %s data missing\",\n                        line, param);\n        }\n        else\n        {\n            in_uint8a(s, str, sz);\n            str[sz] = '\\0';\n        }\n    }\n    return result;\n}\n/**\n * Initialises a V1 management session object\n *\n * At call time, the command set value has been read from the wire, and\n * the command still needs to be processed.\n *\n * @param c Connection\n * @param [out] session pre-allocated session object\n * @return SCP_SERVER_STATE_START_MANAGE for success\n */\nstatic enum SCP_SERVER_STATES_E\nscp_v1s_mng_init_session(struct SCP_CONNECTION *c, struct SCP_SESSION *session)\n{\n    tui32 ipaddr;\n    tui16 cmd;\n    tui8 sz;\n    char buf[256];\n\n    scp_session_set_version(session, 1);\n\n    /* reading command */\n    if (!s_check_rem(c->in_s, 2))\n    {\n        /* Caller should have checked this */\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != 1) /* manager login */\n    {\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    /* reading username */\n    if (!in_string8(c->in_s, buf, \"username\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_username(session, buf))\n    {\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading password */\n    if (!in_string8(c->in_s, buf, \"passwd\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_password(session, buf))\n    {\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    /* reading remote address\n     * Check there's enough data left for at least an IPv4 address (+len) */\n    if (!s_check_rem(c->in_s, 1 + 4))\n    {\n        log_message(LOG_LEVEL_WARNING,\n                    \"[v1s_mng:%d] connection aborted: IP addr len missing\",\n                    __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    in_uint8(c->in_s, sz);\n    if (sz == SCP_ADDRESS_TYPE_IPV4)\n    {\n        in_uint32_be(c->in_s, ipaddr);\n        scp_session_set_addr(session, sz, &ipaddr);\n    }\n    else if (sz == SCP_ADDRESS_TYPE_IPV6)\n    {\n        if (!s_check_rem(c->in_s, 16))\n        {\n            log_message(LOG_LEVEL_WARNING,\n                        \"[v1s_mng:%d] connection aborted: IP addr missing\",\n                        __LINE__);\n            return SCP_SERVER_STATE_SIZE_ERR;\n        }\n        in_uint8a(c->in_s, buf, 16);\n        scp_session_set_addr(session, sz, buf);\n    }\n\n    /* reading hostname */\n    if (!in_string8(c->in_s, buf, \"hostname\", __LINE__))\n    {\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    if (0 != scp_session_set_hostname(session, buf))\n    {\n        return SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n\n    return SCP_SERVER_STATE_START_MANAGE;\n}\n\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s)\n{\n    enum SCP_SERVER_STATES_E result;\n    struct SCP_SESSION *session;\n\n    session = scp_session_create();\n    if (NULL == session)\n    {\n        result = SCP_SERVER_STATE_INTERNAL_ERR;\n    }\n    else\n    {\n        scp_session_set_type(session, SCP_SESSION_TYPE_MANAGE);\n\n        result = scp_v1s_mng_init_session(c, session);\n        if (result != SCP_SERVER_STATE_START_MANAGE)\n        {\n            scp_session_destroy(session);\n            session = NULL;\n        }\n    }\n\n    (*s) = session;\n\n    return result;\n}\n\n/* 002 */\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_allow_connection(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n{\n    init_stream(c->out_s, c->out_s->size);\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 */\n    /* version + size + cmdset + cmd */\n    out_uint32_be(c->out_s, 12);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_MANAGE);\n    out_uint16_be(c->out_s, SCP_CMD_MNG_LOGIN_ALLOW);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, 12))\n    {\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return _scp_v1s_mng_check_response(c, s);\n}\n\n/* 003 */\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_deny_connection(struct SCP_CONNECTION *c, const char *reason)\n{\n    int rlen;\n\n    init_stream(c->out_s, c->out_s->size);\n\n    /* forcing message not to exceed 64k */\n    rlen = g_strlen(reason);\n\n    if (rlen > 65535)\n    {\n        rlen = 65535;\n    }\n\n    out_uint32_be(c->out_s, 1);\n    /* packet size: 4 + 4 + 2 + 2 + 2 + strlen(reason)*/\n    /* version + size + cmdset + cmd + msglen + msg */\n    out_uint32_be(c->out_s, rlen + 14);\n    out_uint16_be(c->out_s, SCP_COMMAND_SET_MANAGE);\n    out_uint16_be(c->out_s, SCP_CMD_MNG_LOGIN_DENY);\n    out_uint16_be(c->out_s, rlen);\n    out_uint8p(c->out_s, reason, rlen);\n\n    if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, rlen + 14))\n    {\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    return SCP_SERVER_STATE_END;\n}\n\n/* 006 */\nenum SCP_SERVER_STATES_E\nscp_v1s_mng_list_sessions(struct SCP_CONNECTION *c, struct SCP_SESSION *s,\n                          int sescnt, struct SCP_DISCONNECTED_SESSION *ds)\n{\n    tui32 version = 1;\n    tui32 size = 12;\n    tui16 cmd = SCP_CMD_MNG_LIST;\n    int pktcnt;\n    int idx;\n    int sidx;\n    int pidx;\n    struct SCP_DISCONNECTED_SESSION *cds;\n\n    /* calculating the number of packets to send */\n    if (sescnt == 0)\n    {\n      pktcnt = 1;\n    }\n    else\n    {\n      pktcnt = sescnt / SCP_SERVER_MAX_LIST_SIZE;\n\n      if ((sescnt % SCP_SERVER_MAX_LIST_SIZE) != 0)\n      {\n          pktcnt++;\n      }\n    }\n\n    for (idx = 0; idx < pktcnt; idx++)\n    {\n        /* ok, we send session session list */\n        init_stream(c->out_s, c->out_s->size);\n\n        /* size: ver+size+cmdset+cmd+sescnt+continue+count */\n        size = 4 + 4 + 2 + 2 + 4 + 1 + 1;\n\n        /* header */\n        s_push_layer(c->out_s, channel_hdr, 8);\n        out_uint16_be(c->out_s, SCP_COMMAND_SET_MANAGE);\n        out_uint16_be(c->out_s, cmd);\n\n        /* session count */\n        out_uint32_be(c->out_s, sescnt);\n\n        /* setting the continue flag */\n        if ((idx + 1)*SCP_SERVER_MAX_LIST_SIZE >= sescnt)\n        {\n            out_uint8(c->out_s, 0);\n            /* setting session count for this packet */\n            pidx = sescnt - (idx * SCP_SERVER_MAX_LIST_SIZE);\n            out_uint8(c->out_s, pidx);\n        }\n        else\n        {\n            out_uint8(c->out_s, 1);\n            /* setting session count for this packet */\n            pidx = SCP_SERVER_MAX_LIST_SIZE;\n            out_uint8(c->out_s, pidx);\n        }\n\n        /* adding session descriptors */\n        for (sidx = 0; sidx < pidx; sidx++)\n        {\n            /* shortcut to the current session to send */\n            cds = ds + ((idx) * SCP_SERVER_MAX_LIST_SIZE) + sidx;\n\n            /* session data */\n            out_uint32_be(c->out_s, cds->SID); /* session id */\n            out_uint8(c->out_s, cds->type);\n            out_uint16_be(c->out_s, cds->height);\n            out_uint16_be(c->out_s, cds->width);\n            out_uint8(c->out_s, cds->bpp);\n            out_uint8(c->out_s, cds->idle_days);\n            out_uint8(c->out_s, cds->idle_hours);\n            out_uint8(c->out_s, cds->idle_minutes);\n            size += 13;\n\n            out_uint16_be(c->out_s, cds->conn_year);\n            out_uint8(c->out_s, cds->conn_month);\n            out_uint8(c->out_s, cds->conn_day);\n            out_uint8(c->out_s, cds->conn_hour);\n            out_uint8(c->out_s, cds->conn_minute);\n            out_uint8(c->out_s, cds->addr_type);\n            size += 7;\n\n            if (cds->addr_type == SCP_ADDRESS_TYPE_IPV4)\n            {\n                in_uint32_be(c->out_s, cds->ipv4addr);\n                size += 4;\n            }\n            else if (cds->addr_type == SCP_ADDRESS_TYPE_IPV6)\n            {\n                in_uint8a(c->out_s, cds->ipv6addr, 16);\n                size += 16;\n            }\n        }\n\n        s_pop_layer(c->out_s, channel_hdr);\n        out_uint32_be(c->out_s, version);\n        out_uint32_be(c->out_s, size);\n\n        if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, size))\n        {\n            log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: network error\", __LINE__);\n            return SCP_SERVER_STATE_NETWORK_ERR;\n        }\n    }\n\n    return _scp_v1s_mng_check_response(c, s);\n}\n\nstatic enum SCP_SERVER_STATES_E\n_scp_v1s_mng_check_response(struct SCP_CONNECTION *c, struct SCP_SESSION *s)\n{\n    tui32 version;\n    tui32 size;\n    tui16 cmd;\n    //   tui8 dim;\n    //   char buf[257];\n\n    init_stream(c->in_s, c->in_s->size);\n\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    in_uint32_be(c->in_s, version);\n\n    if (version != 1)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: version error\", __LINE__);\n        return SCP_SERVER_STATE_VERSION_ERR;\n    }\n\n    in_uint32_be(c->in_s, size);\n\n    /* Check the message is big enough for the header, the command set, and\n     * the command (but not too big) */\n    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: size error\", __LINE__);\n        return SCP_SERVER_STATE_SIZE_ERR;\n    }\n\n    init_stream(c->in_s, size - 8);\n\n    /* read the rest of the packet */\n    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, size - 8))\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: network error\", __LINE__);\n        return SCP_SERVER_STATE_NETWORK_ERR;\n    }\n\n    c->in_s->end = c->in_s->data + (size - 8);\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd != SCP_COMMAND_SET_MANAGE)\n    {\n        log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: sequence error\", __LINE__);\n        return SCP_SERVER_STATE_SEQUENCE_ERR;\n    }\n\n    in_uint16_be(c->in_s, cmd);\n\n    if (cmd == SCP_CMD_MNG_LIST_REQ) /* request session list */\n    {\n        log_message(LOG_LEVEL_INFO, \"[v1s_mng:%d] request session list\", __LINE__);\n        return SCP_SERVER_STATE_MNG_LISTREQ;\n    }\n    else if (cmd == SCP_CMD_MNG_ACTION) /* execute an action */\n    {\n        /*in_uint8(c->in_s, dim);\n        buf[dim]='\\0';\n        in_uint8a(c->in_s, buf, dim);\n        scp_session_set_errstr(s, buf);*/\n\n        log_message(LOG_LEVEL_INFO, \"[v1s_mng:%d] action request\", __LINE__);\n        return SCP_SERVER_STATE_MNG_ACTION;\n    }\n\n    /* else if (cmd == 20) / * password change * /\n    {\n      in_uint16_be(c->in_s, s->display);\n\n      return SCP_SERVER_STATE_OK;\n    }\n    else if (cmd == 40) / * session list * /\n    {\n      return SCP_SERVER_STATE_SESSION_LIST;\n    }*/\n\n    log_message(LOG_LEVEL_WARNING, \"[v1s_mng:%d] connection aborted: sequence error\", __LINE__);\n    return SCP_SERVER_STATE_SEQUENCE_ERR;\n}\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2015\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file scp.c\n * @brief scp (sesman control protocol) common code\n *        scp (sesman control protocol) common code\n *        This code controls which version is being used and starts the\n *        appropriate process\n * @author Jay Sorg, Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"sesman.h\"\n\nextern struct config_sesman *g_cfg; /* in sesman.c */\n\n/******************************************************************************/\nvoid *\nscp_process_start(void *sck)\n{\n    struct SCP_CONNECTION scon;\n    struct SCP_SESSION *sdata = NULL;\n\n    scon.in_sck = (int)(tintptr)sck;\n    LOG_DBG(\"started scp thread on socket %d\", scon.in_sck);\n\n    make_stream(scon.in_s);\n    make_stream(scon.out_s);\n\n    init_stream(scon.in_s, SCP_MAX_MESSAGE_SIZE);\n    init_stream(scon.out_s, SCP_MAX_MESSAGE_SIZE);\n\n    switch (scp_vXs_accept(&scon, &(sdata)))\n    {\n        case SCP_SERVER_STATE_OK:\n\n            if (sdata->version == 0)\n            {\n                /* starts processing an scp v0 connection */\n                LOG_DBG(\"accept ok, go on with scp v0\");\n                scp_v0_process(&scon, sdata);\n            }\n            else\n            {\n                LOG_DBG(\"accept ok, go on with scp v1\");\n                /*LOG_DBG(\"user: %s\\npass: %s\",sdata->username, sdata->password);*/\n                scp_v1_process(&scon, sdata);\n            }\n\n            break;\n        case SCP_SERVER_STATE_START_MANAGE:\n            /* starting a management session */\n            log_message(LOG_LEVEL_WARNING,\n                        \"starting a sesman management session...\");\n            scp_v1_mng_process(&scon, sdata);\n            break;\n        case SCP_SERVER_STATE_VERSION_ERR:\n        case SCP_SERVER_STATE_SIZE_ERR:\n            /* an unknown scp version was requested, or the message sizes\n               are inconsistent. Shut down the connection and log the\n               fact */\n            log_message(LOG_LEVEL_WARNING,\n                        \"protocol violation. connection refused.\");\n            break;\n        case SCP_SERVER_STATE_NETWORK_ERR:\n            log_message(LOG_LEVEL_WARNING, \"libscp network error.\");\n            break;\n        case SCP_SERVER_STATE_SEQUENCE_ERR:\n            log_message(LOG_LEVEL_WARNING, \"libscp sequence error.\");\n            break;\n        case SCP_SERVER_STATE_INTERNAL_ERR:\n            /* internal error occurred (eg. malloc() error, ecc.) */\n            log_message(LOG_LEVEL_ERROR, \"libscp internal error occurred.\");\n            break;\n        default:\n            log_message(LOG_LEVEL_ALWAYS, \"unknown return from scp_vXs_accept()\");\n            break;\n    }\n\n    free_stream(scon.in_s);\n    free_stream(scon.out_s);\n\n    if (sdata)\n    {\n        scp_session_destroy(sdata);\n    }\n\n    return 0;\n}\n"], "buggy_code_start_loc": [60, 36, 37, 41, 51], "buggy_code_end_loc": [60, 385, 635, 322, 83], "fixing_code_start_loc": [61, 37, 38, 41, 51], "fixing_code_end_loc": [65, 480, 766, 425, 85], "type": "CWE-121", "message": "The xrdp-sesman service before version 0.9.13.1 can be crashed by connecting over port 3350 and supplying a malicious payload. Once the xrdp-sesman process is dead, an unprivileged attacker on the server could then proceed to start their own imposter sesman service listening on port 3350. This will allow them to capture any user credentials that are submitted to XRDP and approve or reject arbitrary login credentials. For xorgxrdp sessions in particular, this allows an unauthorized user to hijack an existing session. This is a buffer overflow attack, so there may be a risk of arbitrary code execution as well.", "other": {"cve": {"id": "CVE-2020-4044", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-30T16:15:16.203", "lastModified": "2020-08-14T21:15:14.397", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The xrdp-sesman service before version 0.9.13.1 can be crashed by connecting over port 3350 and supplying a malicious payload. Once the xrdp-sesman process is dead, an unprivileged attacker on the server could then proceed to start their own imposter sesman service listening on port 3350. This will allow them to capture any user credentials that are submitted to XRDP and approve or reject arbitrary login credentials. For xorgxrdp sessions in particular, this allows an unauthorized user to hijack an existing session. This is a buffer overflow attack, so there may be a risk of arbitrary code execution as well."}, {"lang": "es", "value": "El servicio xrdp-sesman versiones anteriores a 0.9.13.1 puede ser bloqueado al conectarse a trav\u00e9s del puerto 3350 y suministrando una carga maliciosa. Una vez que el proceso xrdp-sesman est\u00e1 inactivo, un atacante sin privilegios en el servidor podr\u00eda comenzar a iniciar su propio servicio impostor sesman escuchando en el puerto 3350. Esto les permitir\u00e1 capturar cualquier credencial de usuario que sea enviada a XRDP y aprobar o rechazar credenciales de inicio de sesi\u00f3n arbitrarias. Para las sesiones xorgxrdp en particular, esto permite a un usuario no autorizado secuestrar una sesi\u00f3n existente. Este es un ataque de desbordamiento del b\u00fafer, por lo que tambi\u00e9n puede existir un riesgo de ejecuci\u00f3n de c\u00f3digo arbitraria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neutrinolabs:xrdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.13.1", "matchCriteriaId": "AB124086-296A-4B17-A012-556DDF1E7E12"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00036.html", "source": "security-advisories@github.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-08/msg00037.html", "source": "security-advisories@github.com"}, {"url": "https://github.com/neutrinolabs/xrdp/commit/0c791d073d0eb344ee7aaafd221513dc9226762c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/neutrinolabs/xrdp/releases/tag/v0.9.13.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/neutrinolabs/xrdp/security/advisories/GHSA-j9fv-6fwf-p3g4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00015.html", "source": "security-advisories@github.com"}, {"url": "https://www.debian.org/security/2020/dsa-4737", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/neutrinolabs/xrdp/commit/0c791d073d0eb344ee7aaafd221513dc9226762c"}}