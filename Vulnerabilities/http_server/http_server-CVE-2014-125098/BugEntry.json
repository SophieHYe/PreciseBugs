{"buggy_code": ["// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of http_server;\n\n\n// Used for signal a directory redirecting, where a tailing slash is missing.\nclass _DirectoryRedirect {\n  const _DirectoryRedirect();\n}\n\ntypedef dynamic _DirCallback(Directory dir, HttpRequest request);\ntypedef dynamic _ErrorCallback(HttpRequest request);\n\n/**\n * A [VirtualDirectory] can serve files and directory-listing from a root path,\n * to [HttpRequest]s.\n *\n * The [VirtualDirectory] providing secure handling of request uris and\n * file-system links, correct mime-types and custom error pages.\n */\nclass VirtualDirectory {\n  final String root;\n\n  /**\n   * Set or get if the [VirtualDirectory] should list the content of\n   * directories.\n   */\n  bool allowDirectoryListing = false;\n\n  /**\n   * Set or get if the [VirtualDirectory] should follow links, that point\n   * to other resources within the [root] directory.\n   */\n  bool followLinks = true;\n\n  /**\n   * Set or get if the [VirtualDirectory] should jail the root. When the root is\n   * not jailed, links can be followed to outside the [root] directory.\n   */\n  bool jailRoot = true;\n\n  final RegExp _invalidPathRegExp = new RegExp(\"[\\\\\\/\\x00]\");\n\n  _ErrorCallback _errorCallback;\n  _DirCallback _dirCallback;\n\n  /*\n   * Create a new [VirtualDirectory] for serving static file content of\n   * the path [root].\n   *\n   * The [root] is not required to exist. If the [root] doesn't exist at time of\n   * a request, a 404 is generated.\n   */\n  VirtualDirectory(this.root);\n\n  /**\n   * Serve a [Stream] of [HttpRequest]s, in this [VirtualDirectory].\n   */\n  StreamSubscription<HttpRequest> serve(Stream<HttpRequest> requests) =>\n      requests.listen(serveRequest);\n\n  /**\n   * Serve a single [HttpRequest], in this [VirtualDirectory].\n   */\n  Future serveRequest(HttpRequest request) {\n    return _locateResource('.', request.uri.pathSegments.iterator..moveNext())\n        .then((entity) {\n          if (entity is File) {\n            serveFile(entity, request);\n          } else if (entity is Directory) {\n            if (allowDirectoryListing) {\n              _serveDirectory(entity, request);\n            } else {\n              _serveErrorPage(HttpStatus.NOT_FOUND, request);\n            }\n          } else if (entity is _DirectoryRedirect) {\n            // TODO(ajohnsen): Use HttpRequest.requestedUri once 1.2 is out.\n            request.response.redirect(Uri.parse('${request.uri}/'),\n                                      status: HttpStatus.MOVED_PERMANENTLY);\n          } else {\n            assert(entity == null);\n            _serveErrorPage(HttpStatus.NOT_FOUND, request);\n          }\n          return request.response.done;\n        });\n  }\n\n  /**\n   * Set the [callback] to override the default directory listing. The\n   * [callback] will be called with the [Directory] to be listed and the\n   * [HttpRequest].\n   */\n  void set directoryHandler(void callback(Directory dir, HttpRequest request)) {\n    _dirCallback = callback;\n  }\n\n  /**\n   * Set the [callback] to override the error page handler. When [callback] is\n   * invoked, the `statusCode` property of the response is set.\n   */\n  void set errorPageHandler(void callback(HttpRequest request)) {\n    _errorCallback = callback;\n  }\n\n  Future _locateResource(String path, Iterator<String> segments) {\n    // Don't allow navigating up paths.\n    if (segments.current == \"..\") return new Future.value(null);\n    path = normalize(path);\n    // If we jail to root, the relative path can never go up.\n    if (jailRoot && split(path).first == \"..\") return new Future.value(null);\n    String fullPath() => join(root, path);\n    return FileSystemEntity.type(fullPath(), followLinks: false)\n        .then((type) {\n          switch (type) {\n            case FileSystemEntityType.FILE:\n              if (segments.current == null) {\n                return new File(fullPath());\n              }\n              break;\n\n            case FileSystemEntityType.DIRECTORY:\n              String dirFullPath() => '${fullPath()}$separator';\n              var current = segments.current;\n              if (current == null) {\n                if (path == '.') return new Directory(dirFullPath());\n                return const _DirectoryRedirect();\n              }\n              bool hasNext = segments.moveNext();\n              if (!hasNext && current == \"\") {\n                return new Directory(dirFullPath());\n              } else {\n                if (_invalidPathRegExp.hasMatch(current)) break;\n                return _locateResource(join(path, current), segments);\n              }\n              break;\n\n            case FileSystemEntityType.LINK:\n              if (followLinks) {\n                return new Link(fullPath()).target()\n                    .then((target) {\n                      String targetPath = normalize(target);\n                      if (isAbsolute(targetPath)) {\n                        // If we jail to root, the path can never be absolute.\n                        if (jailRoot) return null;\n                        return _locateResource(targetPath, segments);\n                      } else {\n                        targetPath = join(dirname(path), targetPath);\n                        return _locateResource(targetPath, segments);\n                      }\n                    });\n              }\n              break;\n          }\n          // Return `null` on fall-through, to indicate NOT_FOUND.\n          return null;\n        });\n  }\n\n  /**\n   * Serve the content of [file] to [request].\n   *\n   * This is usefull when e.g. overriding [directoryHandler] to redirect to\n   * some index file.\n   *\n   * In the request contains the [HttpStatus.IF_MODIFIED_SINCE] header,\n   * [serveFile] will send a [HttpStatus.NOT_MODIFIED] response if the file\n   * was not changed.\n   *\n   * Note that if it was unabled to read from [file], the [request]s response\n   * is closed with error-code [HttpStatus.NOT_FOUND].\n   */\n  void serveFile(File file, HttpRequest request) {\n    var response = request.response;\n    // TODO(ajohnsen): Set up Zone support for these errors.\n    file.lastModified().then((lastModified) {\n      if (request.headers.ifModifiedSince != null &&\n          !lastModified.isAfter(request.headers.ifModifiedSince)) {\n        response.statusCode = HttpStatus.NOT_MODIFIED;\n        response.close();\n        return null;\n      }\n\n      response.headers.set(HttpHeaders.LAST_MODIFIED, lastModified);\n      response.headers.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\n      if (request.method == 'HEAD') {\n        response.close();\n        return null;\n      }\n\n      return file.length().then((length) {\n        String range = request.headers.value(\"range\");\n        if (range != null) {\n          // We only support one range, where the standard support several.\n          Match matches = new RegExp(r\"^bytes=(\\d*)\\-(\\d*)$\").firstMatch(range);\n          // If the range header have the right format, handle it.\n          if (matches != null) {\n            // Serve sub-range.\n            int start;\n            int end;\n            if (matches[1].isEmpty) {\n              start = matches[2].isEmpty ?\n                  length :\n                  length - int.parse(matches[2]);\n              end = length;\n            } else {\n              start = int.parse(matches[1]);\n              end = matches[2].isEmpty ? length : int.parse(matches[2]) + 1;\n            }\n\n            // Override Content-Length with the actual bytes sent.\n            response.headers.set(HttpHeaders.CONTENT_LENGTH, end - start);\n\n            // Set 'Partial Content' status code.\n            response.statusCode = HttpStatus.PARTIAL_CONTENT;\n            response.headers.set(HttpHeaders.CONTENT_RANGE,\n                                 \"bytes $start-${end - 1}/$length\");\n\n            // Pipe the 'range' of the file.\n            file.openRead(start, end)\n                .pipe(new _VirtualDirectoryFileStream(response, file.path))\n                .catchError((_) {\n                  // TODO(kevmoo): log errors\n                });\n            return;\n          }\n        }\n\n        file.openRead()\n            .pipe(new _VirtualDirectoryFileStream(response, file.path))\n            .catchError((_) {\n              // TODO(kevmoo): log errors\n            });\n      });\n    }).catchError((_) {\n      response.statusCode = HttpStatus.NOT_FOUND;\n      response.close();\n    });\n  }\n\n  void _serveDirectory(Directory dir, HttpRequest request) {\n    if (_dirCallback != null) {\n      _dirCallback(dir, request);\n      return;\n    }\n    var response = request.response;\n    dir.stat().then((stats) {\n      if (request.headers.ifModifiedSince != null &&\n          !stats.modified.isAfter(request.headers.ifModifiedSince)) {\n        response.statusCode = HttpStatus.NOT_MODIFIED;\n        response.close();\n        return;\n      }\n\n      response.headers.set(HttpHeaders.LAST_MODIFIED, stats.modified);\n      var path = request.uri.path;\n      var header =\n'''<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<title>Index of $path</title>\n</head>\n<body>\n<h1>Index of $path</h1>\n<table>\n  <tr>\n    <td>Name</td>\n    <td>Last modified</td>\n    <td>Size</td>\n  </tr>\n''';\n      var server = response.headers.value(HttpHeaders.SERVER);\n      if (server == null) server = \"\";\n      var footer =\n'''</table>\n$server\n</body>\n</html>\n''';\n\n      response.write(header);\n\n      void add(String name, String modified, var size) {\n        if (size == null) size = \"-\";\n        if (modified == null) modified = \"\";\n        var p = normalize(join(path, name));\n        var entry =\n'''  <tr>\n    <td><a href=\"$p\">$name</a></td>\n    <td>$modified</td>\n    <td style=\"text-align: right\">$size</td>\n  </tr>''';\n        response.write(entry);\n      }\n\n      if (path != '/') {\n        add('../', null, null);\n      }\n\n      dir.list(followLinks: true).listen((entity) {\n        if (entity is File) {\n          var stat = entity.statSync();\n          add(basename(entity.path),\n              stat.modified.toString(),\n              stat.size);\n        } else if (entity is Directory) {\n          add(basename(entity.path) + '/',\n              entity.statSync().modified.toString(),\n              null);\n        }\n      }, onError: (e) {\n        // TODO(kevmoo): log error\n      }, onDone: () {\n        response.write(footer);\n        response.close();\n      });\n    }, onError: (e) {\n      // TODO(kevmoo): log error\n      response.close();\n    });\n  }\n\n  void _serveErrorPage(int error, HttpRequest request) {\n    var response = request.response;\n    response.statusCode = error;\n    if (_errorCallback != null) {\n      _errorCallback(request);\n      return;\n    }\n    // Default error page.\n    var path = request.uri.path;\n    var reason = response.reasonPhrase;\n\n    var server = response.headers.value(HttpHeaders.SERVER);\n    if (server == null) server = \"\";\n    var page =\n'''<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<title>$reason: $path</title>\n</head>\n<body>\n<h1>Error $error at \\'$path\\': $reason</h1>\n$server\n</body>\n</html>''';\n    response.write(page);\n    response.close();\n  }\n}\n\nclass _VirtualDirectoryFileStream extends StreamConsumer<List<int>> {\n  final HttpResponse response;\n  final String path;\n  List<int> buffer = [];\n\n  _VirtualDirectoryFileStream(HttpResponse this.response, String this.path);\n\n  Future addStream(Stream<List<int>> stream) {\n    stream.listen(\n        (data) {\n          if (buffer == null) {\n            response.add(data);\n            return;\n          }\n          if (buffer.length == 0) {\n            if (data.length >= defaultMagicNumbersMaxLength) {\n              setMimeType(data);\n              response.add(data);\n              buffer = null;\n            } else {\n              buffer.addAll(data);\n            }\n          } else {\n            buffer.addAll(data);\n            if (buffer.length >= defaultMagicNumbersMaxLength) {\n              setMimeType(buffer);\n              response.add(buffer);\n              buffer = null;\n            }\n          }\n        },\n        onDone: () {\n          if (buffer != null) {\n            if (buffer.length == 0) {\n              setMimeType(null);\n            } else {\n              setMimeType(buffer);\n              response.add(buffer);\n            }\n          }\n          response.close();\n        },\n        onError: response.addError);\n    return response.done;\n  }\n\n  Future close() => new Future.value();\n\n  void setMimeType(List<int> bytes) {\n    var mimeType = lookupMimeType(path, headerBytes: bytes);\n    if (mimeType != null) {\n      response.headers.contentType = ContentType.parse(mimeType);\n    }\n  }\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:async';\nimport 'dart:io';\n\nimport \"package:http_server/http_server.dart\";\nimport 'package:path/path.dart' as pathos;\nimport \"package:unittest/unittest.dart\";\n\nimport 'utils.dart';\n\nvoid _testEncoding(name, expected, [bool create = true]) {\n  testVirtualDir('encode-$name', (dir) {\n      if (create) new File('${dir.path}/$name').createSync();\n      var virDir = new VirtualDirectory(dir.path);\n      virDir.allowDirectoryListing = true;\n\n      return getStatusCodeForVirtDir(virDir, '/$name')\n        .then((result) {\n          expect(result, expected);\n        });\n  });\n}\n\nvoid main() {\n  group('serve-root', () {\n    testVirtualDir('dir-exists', (dir) {\n\n      var virDir = new VirtualDirectory(dir.path);\n\n      return getStatusCodeForVirtDir(virDir, '/')\n        .then((result) {\n          expect(result, HttpStatus.NOT_FOUND);\n        });\n    });\n\n    testVirtualDir('dir-not-exists', (dir) {\n      var virDir = new VirtualDirectory(pathos.join(dir.path + 'foo'));\n\n      return getStatusCodeForVirtDir(virDir, '/')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n  });\n\n  group('serve-file', () {\n    group('top-level', () {\n      testVirtualDir('file-exists', (dir) {\n        var file = new File('${dir.path}/file')..createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        return getStatusCodeForVirtDir(virDir, '/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n      });\n\n      testVirtualDir('file-not-exists', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n\n        return getStatusCodeForVirtDir(virDir, '/file')\n            .then((result) {\n              expect(result, HttpStatus.NOT_FOUND);\n            });\n      });\n    });\n\n    group('in-dir', () {\n      testVirtualDir('file-exists', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir2.path}/file')..createSync();\n              var virDir = new VirtualDirectory(dir.path);\n              return getStatusCodeForVirtDir(virDir, '/dir/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n      });\n\n      testVirtualDir('file-not-exists', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir.path}/file')..createSync();\n              var virDir = new VirtualDirectory(dir.path);\n\n              return getStatusCodeForVirtDir(virDir, '/dir/file')\n                .then((result) {\n                  expect(result, HttpStatus.NOT_FOUND);\n                });\n      });\n    });\n  });\n\n  group('serve-dir', () {\n    group('top-level', () {\n      testVirtualDir('simple', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('Index of /'));\n          });\n      });\n\n      testVirtualDir('files', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        for (int i = 0; i < 10; i++) {\n          new File('${dir.path}/$i').createSync();\n        }\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('Index of /'));\n          });\n      });\n\n      testVirtualDir('dirs', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        for (int i = 0; i < 10; i++) {\n          new Directory('${dir.path}/$i').createSync();\n        }\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('Index of /'));\n          });\n      });\n\n      if (!Platform.isWindows) {\n        testVirtualDir('recursive-link', (dir) {\n          var link = new Link('${dir.path}/recursive')..createSync('.');\n          var virDir = new VirtualDirectory(dir.path);\n          virDir.allowDirectoryListing = true;\n\n          return Future.wait([\n              getAsString(virDir, '/').then(\n                  (s) => s.contains('recursive/')),\n              getAsString(virDir, '/').then(\n                  (s) => !s.contains('../')),\n              getAsString(virDir, '/').then(\n                  (s) => s.contains('Index of /')),\n              getAsString(virDir, '/recursive').then(\n                  (s) => s.contains('recursive/')),\n              getAsString(virDir, '/recursive').then(\n                  (s) => s.contains('../')),\n              getAsString(virDir, '/recursive').then(\n                  (s) => s.contains('Index of /recursive'))])\n            .then((result) {\n              expect(result, equals([true, true, true, true, true, true]));\n            });\n        });\n      }\n    });\n\n    group('custom', () {\n      testVirtualDir('simple', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          expect(dir2, isNotNull);\n          expect(FileSystemEntity.identicalSync(dir.path, dir2.path), isTrue);\n          request.response.write('My handler ${request.uri.path}');\n          request.response.close();\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'My handler /');\n          });\n      });\n\n      testVirtualDir('index-1', (dir) {\n        new File('${dir.path}/index.html').writeAsStringSync('index file');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          // Redirect directory-requests to index.html files.\n          var indexUri = new Uri.file(dir2.path).resolve('index.html');\n          return virDir.serveFile(new File(indexUri.toFilePath()), request);\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'index file');\n          });\n      });\n\n      testVirtualDir('index-2', (dir) {\n        new Directory('${dir.path}/dir').createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        virDir.directoryHandler = (dir2, request) {\n          fail('not expected');\n        };\n\n        return getStatusCodeForVirtDir(virDir, '/dir', followRedirects: false)\n          .then((result) {\n            expect(result, 301);\n          });\n      });\n\n      testVirtualDir('index-3', (dir) {\n        new File('${dir.path}/dir/index.html')\n            ..createSync(recursive: true)\n            ..writeAsStringSync('index file');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          // Redirect directory-requests to index.html files.\n          var indexUri = new Uri.file(dir2.path).resolve('index.html');\n          return virDir.serveFile(new File(indexUri.toFilePath()), request);\n        };\n        return getAsString(virDir, '/dir')\n          .then((result) {\n            expect(result, 'index file');\n          });\n      });\n\n      testVirtualDir('index-4', (dir) {\n        new File('${dir.path}/dir/index.html')\n            ..createSync(recursive: true)\n            ..writeAsStringSync('index file');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          // Redirect directory-requests to index.html files.\n          var indexUri = new Uri.file(dir2.path).resolve('index.html');\n          virDir.serveFile(new File(indexUri.toFilePath()), request);\n        };\n        return getAsString(virDir, '/dir/')\n          .then((result) {\n            expect(result, 'index file');\n          });\n      });\n    });\n  });\n\n  group('links', () {\n    if (!Platform.isWindows) {\n      group('follow-links', () {\n        testVirtualDir('dir-link', (dir) {\n          var dir2 = new Directory('${dir.path}/dir2')..createSync();\n          var link = new Link('${dir.path}/dir3')..createSync('dir2');\n          var file = new File('${dir2.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n          virDir.followLinks = true;\n\n          return getStatusCodeForVirtDir(virDir, '/dir3/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n        });\n\n        testVirtualDir('root-link', (dir) {\n          var link = new Link('${dir.path}/dir3')..createSync('.');\n          var file = new File('${dir.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n          virDir.followLinks = true;\n\n          return getStatusCodeForVirtDir(virDir, '/dir3/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n        });\n\n        group('bad-links', () {\n          testVirtualDir('absolute-link', (dir) {\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir.path}/file2')\n                  ..createSync('${dir.path}/file');\n              var virDir = new VirtualDirectory(dir.path);\n              virDir.followLinks = true;\n\n              return getStatusCodeForVirtDir(virDir, '/file2')\n                .then((result) {\n                  expect(result, HttpStatus.NOT_FOUND);\n                });\n          });\n\n          testVirtualDir('relative-parent-link', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir2.path}/file')\n                  ..createSync('../file');\n              var virDir = new VirtualDirectory(dir2.path);\n              virDir.followLinks = true;\n\n              return getStatusCodeForVirtDir(virDir, '/dir3/file')\n                  .then((result) {\n                    expect(result, HttpStatus.NOT_FOUND);\n                  });\n          });\n        });\n      });\n\n      group('not-follow-links', () {\n        testVirtualDir('dir-link', (dir) {\n            var dir2 = new Directory('${dir.path}/dir2')..createSync();\n            var link = new Link('${dir.path}/dir3')..createSync('dir2');\n            var file = new File('${dir2.path}/file')..createSync();\n            var virDir = new VirtualDirectory(dir.path);\n            virDir.followLinks = false;\n\n            return getStatusCodeForVirtDir(virDir, '/dir3/file')\n                .then((result) {\n                  expect(result, HttpStatus.NOT_FOUND);\n                });\n        });\n      });\n\n      group('follow-links', () {\n        group('no-root-jail', () {\n          testVirtualDir('absolute-link', (dir) {\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir.path}/file2')\n                  ..createSync('${dir.path}/file');\n              var virDir = new VirtualDirectory(dir.path);\n              virDir.followLinks = true;\n              virDir.jailRoot = false;\n\n              return getStatusCodeForVirtDir(virDir, '/file2')\n                  .then((result) {\n                    expect(result, HttpStatus.OK);\n                  });\n          });\n\n          testVirtualDir('relative-parent-link', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir2.path}/file')\n                  ..createSync('../file');\n              var virDir = new VirtualDirectory(dir2.path);\n              virDir.followLinks = true;\n              virDir.jailRoot = false;\n\n              return getStatusCodeForVirtDir(virDir, '/file')\n                  .then((result) {\n                    expect(result, HttpStatus.OK);\n                  });\n          });\n        });\n      });\n    }\n  });\n\n  group('last-modified', () {\n    group('file', () {\n      testVirtualDir('file-exists', (dir) {\n          var file = new File('${dir.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file')\n              .then((headers) {\n                expect(headers.value(HttpHeaders.LAST_MODIFIED), isNotNull);\n                var lastModified = HttpDate.parse(\n                    headers.value(HttpHeaders.LAST_MODIFIED));\n\n                return getStatusCodeForVirtDir(\n                    virDir, '/file', ifModifiedSince: lastModified);\n              })\n              .then((result) {\n                expect(result, HttpStatus.NOT_MODIFIED);\n              });\n      });\n\n      testVirtualDir('file-changes', (dir) {\n          var file = new File('${dir.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file')\n              .then((headers) {\n                expect(headers.value(HttpHeaders.LAST_MODIFIED), isNotNull);\n                var lastModified = HttpDate.parse(\n                    headers.value(HttpHeaders.LAST_MODIFIED));\n\n                // Fake file changed by moving date back in time.\n                lastModified = lastModified.subtract(\n                  const Duration(seconds: 10));\n\n                return getStatusCodeForVirtDir(virDir, '/file',\n                    ifModifiedSince: lastModified);\n              })\n              .then((result) {\n                expect(result, HttpStatus.OK);\n              });\n      });\n    });\n  });\n\n  group('content-type', () {\n    group('mime-type', () {\n      testVirtualDir('from-path', (dir) {\n          var file = new File('${dir.path}/file.jpg')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file.jpg')\n              .then((headers) {\n                var contentType = headers.contentType.toString();\n                expect(contentType, 'image/jpeg');\n              });\n      });\n\n      testVirtualDir('from-magic-number', (dir) {\n          var file = new File('${dir.path}/file.jpg')..createSync();\n          file.writeAsBytesSync(\n              [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file.jpg')\n              .then((headers) {\n                var contentType = headers.contentType.toString();\n                expect(contentType, 'image/png');\n              });\n      });\n    });\n  });\n\n  group('error-page', () {\n    testVirtualDir('default', (dir) {\n        var virDir = new VirtualDirectory(pathos.join(dir.path, 'foo'));\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, matches(new RegExp('404.*Not Found')));\n          });\n    });\n\n    testVirtualDir('custom', (dir) {\n        var virDir = new VirtualDirectory(pathos.join(dir.path, 'foo'));\n\n        virDir.errorPageHandler = (request) {\n          request.response.write('my-page ');\n          request.response.write(request.response.statusCode);\n          request.response.close();\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'my-page 404');\n          });\n    });\n  });\n\n  group('escape-root', () {\n    testVirtualDir('escape1', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/../')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    testVirtualDir('escape2', (dir) {\n        new Directory('${dir.path}/dir').createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/dir/../../')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n  });\n\n  group('url-decode', () {\n    testVirtualDir('with-space', (dir) {\n        var file = new File('${dir.path}/my file')..createSync();\n        var virDir = new VirtualDirectory(dir.path);\n\n        return getStatusCodeForVirtDir(virDir, '/my file')\n          .then((result) {\n            expect(result, HttpStatus.OK);\n          });\n    });\n\n    testVirtualDir('encoded-space', (dir) {\n        var file = new File('${dir.path}/my file')..createSync();\n        var virDir = new VirtualDirectory(dir.path);\n\n        return getStatusCodeForVirtDir(virDir, '/my%20file')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    testVirtualDir('encoded-path-separator', (dir) {\n        new Directory('${dir.path}/a').createSync();\n        new Directory('${dir.path}/a/b').createSync();\n        new Directory('${dir.path}/a/b/c').createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/a%2fb/c', rawPath: true)\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    testVirtualDir('encoded-null', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/%00', rawPath: true)\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    _testEncoding('..', HttpStatus.NOT_FOUND, false);\n    _testEncoding('%2e%2e', HttpStatus.OK);\n    _testEncoding('%252e%252e', HttpStatus.OK);\n    _testEncoding('/', HttpStatus.OK, false);\n    _testEncoding('%2f', HttpStatus.NOT_FOUND, false);\n    _testEncoding('%2f', HttpStatus.OK, true);\n  });\n\n  group('serve-file', () {\n    testVirtualDir('from-dir-handler', (dir) {\n        new File('${dir.path}/file')..writeAsStringSync('file contents');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (d, request) {\n          expect(FileSystemEntity.identicalSync(dir.path, d.path), isTrue);\n          return virDir.serveFile(new File('${d.path}/file'), request);\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'file contents');\n          });\n    });\n  });\n}\n"], "fixing_code": ["// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of http_server;\n\n\n// Used for signal a directory redirecting, where a tailing slash is missing.\nclass _DirectoryRedirect {\n  const _DirectoryRedirect();\n}\n\ntypedef dynamic _DirCallback(Directory dir, HttpRequest request);\ntypedef dynamic _ErrorCallback(HttpRequest request);\n\n/**\n * A [VirtualDirectory] can serve files and directory-listing from a root path,\n * to [HttpRequest]s.\n *\n * The [VirtualDirectory] providing secure handling of request uris and\n * file-system links, correct mime-types and custom error pages.\n */\nclass VirtualDirectory {\n  final String root;\n\n  /**\n   * Set or get if the [VirtualDirectory] should list the content of\n   * directories.\n   */\n  bool allowDirectoryListing = false;\n\n  /**\n   * Set or get if the [VirtualDirectory] should follow links, that point\n   * to other resources within the [root] directory.\n   */\n  bool followLinks = true;\n\n  /**\n   * Set or get if the [VirtualDirectory] should jail the root. When the root is\n   * not jailed, links can be followed to outside the [root] directory.\n   */\n  bool jailRoot = true;\n\n  final RegExp _invalidPathRegExp = new RegExp(\"[\\\\\\/\\x00]\");\n\n  _ErrorCallback _errorCallback;\n  _DirCallback _dirCallback;\n\n  /*\n   * Create a new [VirtualDirectory] for serving static file content of\n   * the path [root].\n   *\n   * The [root] is not required to exist. If the [root] doesn't exist at time of\n   * a request, a 404 is generated.\n   */\n  VirtualDirectory(this.root);\n\n  /**\n   * Serve a [Stream] of [HttpRequest]s, in this [VirtualDirectory].\n   */\n  StreamSubscription<HttpRequest> serve(Stream<HttpRequest> requests) =>\n      requests.listen(serveRequest);\n\n  /**\n   * Serve a single [HttpRequest], in this [VirtualDirectory].\n   */\n  Future serveRequest(HttpRequest request) {\n    return _locateResource('.', request.uri.pathSegments.iterator..moveNext())\n        .then((entity) {\n          if (entity is File) {\n            serveFile(entity, request);\n          } else if (entity is Directory) {\n            if (allowDirectoryListing) {\n              _serveDirectory(entity, request);\n            } else {\n              _serveErrorPage(HttpStatus.NOT_FOUND, request);\n            }\n          } else if (entity is _DirectoryRedirect) {\n            // TODO(ajohnsen): Use HttpRequest.requestedUri once 1.2 is out.\n            request.response.redirect(Uri.parse('${request.uri}/'),\n                                      status: HttpStatus.MOVED_PERMANENTLY);\n          } else {\n            assert(entity == null);\n            _serveErrorPage(HttpStatus.NOT_FOUND, request);\n          }\n          return request.response.done;\n        });\n  }\n\n  /**\n   * Set the [callback] to override the default directory listing. The\n   * [callback] will be called with the [Directory] to be listed and the\n   * [HttpRequest].\n   */\n  void set directoryHandler(void callback(Directory dir, HttpRequest request)) {\n    _dirCallback = callback;\n  }\n\n  /**\n   * Set the [callback] to override the error page handler. When [callback] is\n   * invoked, the `statusCode` property of the response is set.\n   */\n  void set errorPageHandler(void callback(HttpRequest request)) {\n    _errorCallback = callback;\n  }\n\n  Future _locateResource(String path, Iterator<String> segments) {\n    // Don't allow navigating up paths.\n    if (segments.current == \"..\") return new Future.value(null);\n    path = normalize(path);\n    // If we jail to root, the relative path can never go up.\n    if (jailRoot && split(path).first == \"..\") return new Future.value(null);\n    String fullPath() => join(root, path);\n    return FileSystemEntity.type(fullPath(), followLinks: false)\n        .then((type) {\n          switch (type) {\n            case FileSystemEntityType.FILE:\n              if (segments.current == null) {\n                return new File(fullPath());\n              }\n              break;\n\n            case FileSystemEntityType.DIRECTORY:\n              String dirFullPath() => '${fullPath()}$separator';\n              var current = segments.current;\n              if (current == null) {\n                if (path == '.') return new Directory(dirFullPath());\n                return const _DirectoryRedirect();\n              }\n              bool hasNext = segments.moveNext();\n              if (!hasNext && current == \"\") {\n                return new Directory(dirFullPath());\n              } else {\n                if (_invalidPathRegExp.hasMatch(current)) break;\n                return _locateResource(join(path, current), segments);\n              }\n              break;\n\n            case FileSystemEntityType.LINK:\n              if (followLinks) {\n                return new Link(fullPath()).target()\n                    .then((target) {\n                      String targetPath = normalize(target);\n                      if (isAbsolute(targetPath)) {\n                        // If we jail to root, the path can never be absolute.\n                        if (jailRoot) return null;\n                        return _locateResource(targetPath, segments);\n                      } else {\n                        targetPath = join(dirname(path), targetPath);\n                        return _locateResource(targetPath, segments);\n                      }\n                    });\n              }\n              break;\n          }\n          // Return `null` on fall-through, to indicate NOT_FOUND.\n          return null;\n        });\n  }\n\n  /**\n   * Serve the content of [file] to [request].\n   *\n   * This is usefull when e.g. overriding [directoryHandler] to redirect to\n   * some index file.\n   *\n   * In the request contains the [HttpStatus.IF_MODIFIED_SINCE] header,\n   * [serveFile] will send a [HttpStatus.NOT_MODIFIED] response if the file\n   * was not changed.\n   *\n   * Note that if it was unabled to read from [file], the [request]s response\n   * is closed with error-code [HttpStatus.NOT_FOUND].\n   */\n  void serveFile(File file, HttpRequest request) {\n    var response = request.response;\n    // TODO(ajohnsen): Set up Zone support for these errors.\n    file.lastModified().then((lastModified) {\n      if (request.headers.ifModifiedSince != null &&\n          !lastModified.isAfter(request.headers.ifModifiedSince)) {\n        response.statusCode = HttpStatus.NOT_MODIFIED;\n        response.close();\n        return null;\n      }\n\n      response.headers.set(HttpHeaders.LAST_MODIFIED, lastModified);\n      response.headers.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\n      if (request.method == 'HEAD') {\n        response.close();\n        return null;\n      }\n\n      return file.length().then((length) {\n        String range = request.headers.value(\"range\");\n        if (range != null) {\n          // We only support one range, where the standard support several.\n          Match matches = new RegExp(r\"^bytes=(\\d*)\\-(\\d*)$\").firstMatch(range);\n          // If the range header have the right format, handle it.\n          if (matches != null) {\n            // Serve sub-range.\n            int start;\n            int end;\n            if (matches[1].isEmpty) {\n              start = matches[2].isEmpty ?\n                  length :\n                  length - int.parse(matches[2]);\n              end = length;\n            } else {\n              start = int.parse(matches[1]);\n              end = matches[2].isEmpty ? length : int.parse(matches[2]) + 1;\n            }\n\n            // Override Content-Length with the actual bytes sent.\n            response.headers.set(HttpHeaders.CONTENT_LENGTH, end - start);\n\n            // Set 'Partial Content' status code.\n            response.statusCode = HttpStatus.PARTIAL_CONTENT;\n            response.headers.set(HttpHeaders.CONTENT_RANGE,\n                                 \"bytes $start-${end - 1}/$length\");\n\n            // Pipe the 'range' of the file.\n            file.openRead(start, end)\n                .pipe(new _VirtualDirectoryFileStream(response, file.path))\n                .catchError((_) {\n                  // TODO(kevmoo): log errors\n                });\n            return;\n          }\n        }\n\n        file.openRead()\n            .pipe(new _VirtualDirectoryFileStream(response, file.path))\n            .catchError((_) {\n              // TODO(kevmoo): log errors\n            });\n      });\n    }).catchError((_) {\n      response.statusCode = HttpStatus.NOT_FOUND;\n      response.close();\n    });\n  }\n\n  void _serveDirectory(Directory dir, HttpRequest request) {\n    if (_dirCallback != null) {\n      _dirCallback(dir, request);\n      return;\n    }\n    var response = request.response;\n    dir.stat().then((stats) {\n      if (request.headers.ifModifiedSince != null &&\n          !stats.modified.isAfter(request.headers.ifModifiedSince)) {\n        response.statusCode = HttpStatus.NOT_MODIFIED;\n        response.close();\n        return;\n      }\n\n      response.headers.set(HttpHeaders.LAST_MODIFIED, stats.modified);\n      var path = Uri.decodeComponent(request.uri.path);\n      var encodedPath = new HtmlEscape().convert(path);\n      var header =\n'''<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<title>Index of $encodedPath</title>\n</head>\n<body>\n<h1>Index of $encodedPath</h1>\n<table>\n  <tr>\n    <td>Name</td>\n    <td>Last modified</td>\n    <td>Size</td>\n  </tr>\n''';\n      var server = response.headers.value(HttpHeaders.SERVER);\n      if (server == null) server = \"\";\n      var footer =\n'''</table>\n$server\n</body>\n</html>\n''';\n\n      response.write(header);\n\n      void add(String name, String modified, var size) {\n        try {\n        if (size == null) size = \"-\";\n        if (modified == null) modified = \"\";\n        var encodedSize = new HtmlEscape().convert(size.toString());\n        var encodedModified = new HtmlEscape().convert(modified);\n        var encodedLink = new HtmlEscape(HtmlEscapeMode.ATTRIBUTE)\n            .convert(Uri.encodeComponent(normalize(join(path, name))));\n        var encodedName = new HtmlEscape().convert(name);\n\n        var entry =\n'''  <tr>\n    <td><a href=\"$encodedLink\">$encodedName</a></td>\n    <td>$encodedModified</td>\n    <td style=\"text-align: right\">$encodedSize</td>\n  </tr>''';\n        response.write(entry);\n        } catch (e) {\n          print(e);\n        }\n      }\n\n      if (path != '/') {\n        add('../', null, null);\n      }\n\n      dir.list(followLinks: true).listen((entity) {\n        if (entity is File) {\n          var stat = entity.statSync();\n          add(basename(entity.path),\n              stat.modified.toString(),\n              stat.size);\n        } else if (entity is Directory) {\n          add(basename(entity.path) + '/',\n              entity.statSync().modified.toString(),\n              null);\n        }\n      }, onError: (e) {\n        // TODO(kevmoo): log error\n      }, onDone: () {\n        response.write(footer);\n        response.close();\n      });\n    }, onError: (e) {\n      // TODO(kevmoo): log error\n      response.close();\n    });\n  }\n\n  void _serveErrorPage(int error, HttpRequest request) {\n    var response = request.response;\n    response.statusCode = error;\n    if (_errorCallback != null) {\n      _errorCallback(request);\n      return;\n    }\n    // Default error page.\n    var path = Uri.decodeComponent(request.uri.path);\n    var encodedPath = new HtmlEscape().convert(path);\n    var encodedReason = new HtmlEscape().convert(response.reasonPhrase);\n    var encodedError = new HtmlEscape().convert(error.toString());\n\n    var server = response.headers.value(HttpHeaders.SERVER);\n    if (server == null) server = \"\";\n    var page =\n'''<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<title>$encodedReason: $encodedPath</title>\n</head>\n<body>\n<h1>Error $encodedError at \\'$encodedPath\\': $encodedReason</h1>\n$server\n</body>\n</html>''';\n    response.write(page);\n    response.close();\n  }\n}\n\nclass _VirtualDirectoryFileStream extends StreamConsumer<List<int>> {\n  final HttpResponse response;\n  final String path;\n  List<int> buffer = [];\n\n  _VirtualDirectoryFileStream(HttpResponse this.response, String this.path);\n\n  Future addStream(Stream<List<int>> stream) {\n    stream.listen(\n        (data) {\n          if (buffer == null) {\n            response.add(data);\n            return;\n          }\n          if (buffer.length == 0) {\n            if (data.length >= defaultMagicNumbersMaxLength) {\n              setMimeType(data);\n              response.add(data);\n              buffer = null;\n            } else {\n              buffer.addAll(data);\n            }\n          } else {\n            buffer.addAll(data);\n            if (buffer.length >= defaultMagicNumbersMaxLength) {\n              setMimeType(buffer);\n              response.add(buffer);\n              buffer = null;\n            }\n          }\n        },\n        onDone: () {\n          if (buffer != null) {\n            if (buffer.length == 0) {\n              setMimeType(null);\n            } else {\n              setMimeType(buffer);\n              response.add(buffer);\n            }\n          }\n          response.close();\n        },\n        onError: response.addError);\n    return response.done;\n  }\n\n  Future close() => new Future.value();\n\n  void setMimeType(List<int> bytes) {\n    var mimeType = lookupMimeType(path, headerBytes: bytes);\n    if (mimeType != null) {\n      response.headers.contentType = ContentType.parse(mimeType);\n    }\n  }\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:async';\nimport 'dart:io';\n\nimport \"package:http_server/http_server.dart\";\nimport 'package:path/path.dart' as pathos;\nimport \"package:unittest/unittest.dart\";\n\nimport 'utils.dart';\n\nvoid _testEncoding(name, expected, [bool create = true]) {\n  testVirtualDir('encode-$name', (dir) {\n      if (create) new File('${dir.path}/$name').createSync();\n      var virDir = new VirtualDirectory(dir.path);\n      virDir.allowDirectoryListing = true;\n\n      return getStatusCodeForVirtDir(virDir, '/$name')\n        .then((result) {\n          expect(result, expected);\n        });\n  });\n}\n\nvoid main() {\n  group('serve-root', () {\n    testVirtualDir('dir-exists', (dir) {\n\n      var virDir = new VirtualDirectory(dir.path);\n\n      return getStatusCodeForVirtDir(virDir, '/')\n        .then((result) {\n          expect(result, HttpStatus.NOT_FOUND);\n        });\n    });\n\n    testVirtualDir('dir-not-exists', (dir) {\n      var virDir = new VirtualDirectory(pathos.join(dir.path + 'foo'));\n\n      return getStatusCodeForVirtDir(virDir, '/')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n  });\n\n  group('serve-file', () {\n    group('top-level', () {\n      testVirtualDir('file-exists', (dir) {\n        var file = new File('${dir.path}/file')..createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        return getStatusCodeForVirtDir(virDir, '/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n      });\n\n      testVirtualDir('file-not-exists', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n\n        return getStatusCodeForVirtDir(virDir, '/file')\n            .then((result) {\n              expect(result, HttpStatus.NOT_FOUND);\n            });\n      });\n    });\n\n    group('in-dir', () {\n      testVirtualDir('file-exists', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir2.path}/file')..createSync();\n              var virDir = new VirtualDirectory(dir.path);\n              return getStatusCodeForVirtDir(virDir, '/dir/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n      });\n\n      testVirtualDir('file-not-exists', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir.path}/file')..createSync();\n              var virDir = new VirtualDirectory(dir.path);\n\n              return getStatusCodeForVirtDir(virDir, '/dir/file')\n                .then((result) {\n                  expect(result, HttpStatus.NOT_FOUND);\n                });\n      });\n    });\n  });\n\n  group('serve-dir', () {\n    group('top-level', () {\n      testVirtualDir('simple', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('Index of &#x2F'));\n          });\n      });\n\n      testVirtualDir('files', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        for (int i = 0; i < 10; i++) {\n          new File('${dir.path}/$i').createSync();\n        }\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('Index of &#x2F'));\n          });\n      });\n\n      testVirtualDir('dirs', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        for (int i = 0; i < 10; i++) {\n          new Directory('${dir.path}/$i').createSync();\n        }\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('Index of &#x2F'));\n          });\n      });\n\n      testVirtualDir('encoded-dir', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        new Directory('${dir.path}/alert(\\'hacked!\\');').createSync();\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/alert(\\'hacked!\\');')\n          .then((result) {\n            expect(result, contains('&#x2F;alert(&#x27;hacked!&#x27;);&#x2F;'));\n          });\n      });\n\n      testVirtualDir('encoded-path', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        new Directory('${dir.path}/javascript:alert(document);\"').createSync();\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('%2Fjavascript%3Aalert(document)%3B%22'));\n          });\n      });\n\n      testVirtualDir('encoded-special', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        new Directory('${dir.path}/<>&\"').createSync();\n        virDir.allowDirectoryListing = true;\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, contains('&lt;&gt;&amp;&quot;&#x2F;'));\n            expect(result, contains('href=\"%2F%3C%3E%26%22\"'));\n          });\n      });\n\n      if (!Platform.isWindows) {\n        testVirtualDir('recursive-link', (dir) {\n          var link = new Link('${dir.path}/recursive')..createSync('.');\n          var virDir = new VirtualDirectory(dir.path);\n          virDir.allowDirectoryListing = true;\n\n          return Future.wait([\n              getAsString(virDir, '/').then(\n                  (s) => s.contains('recursive&#x2F;')),\n              getAsString(virDir, '/').then(\n                  (s) => !s.contains('../')),\n              getAsString(virDir, '/').then(\n                  (s) => s.contains('Index of &#x2F;')),\n              getAsString(virDir, '/recursive').then(\n                  (s) => s.contains('recursive&#x2F;')),\n              getAsString(virDir, '/recursive').then(\n                  (s) => s.contains('..&#x2F;')),\n              getAsString(virDir, '/recursive').then(\n                  (s) => s.contains('Index of &#x2F;recursive'))])\n            .then((result) {\n              expect(result, equals([true, true, true, true, true, true]));\n            });\n        });\n      }\n    });\n\n    group('custom', () {\n      testVirtualDir('simple', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          expect(dir2, isNotNull);\n          expect(FileSystemEntity.identicalSync(dir.path, dir2.path), isTrue);\n          request.response.write('My handler ${request.uri.path}');\n          request.response.close();\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'My handler /');\n          });\n      });\n\n      testVirtualDir('index-1', (dir) {\n        new File('${dir.path}/index.html').writeAsStringSync('index file');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          // Redirect directory-requests to index.html files.\n          var indexUri = new Uri.file(dir2.path).resolve('index.html');\n          return virDir.serveFile(new File(indexUri.toFilePath()), request);\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'index file');\n          });\n      });\n\n      testVirtualDir('index-2', (dir) {\n        new Directory('${dir.path}/dir').createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        virDir.directoryHandler = (dir2, request) {\n          fail('not expected');\n        };\n\n        return getStatusCodeForVirtDir(virDir, '/dir', followRedirects: false)\n          .then((result) {\n            expect(result, 301);\n          });\n      });\n\n      testVirtualDir('index-3', (dir) {\n        new File('${dir.path}/dir/index.html')\n            ..createSync(recursive: true)\n            ..writeAsStringSync('index file');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          // Redirect directory-requests to index.html files.\n          var indexUri = new Uri.file(dir2.path).resolve('index.html');\n          return virDir.serveFile(new File(indexUri.toFilePath()), request);\n        };\n        return getAsString(virDir, '/dir')\n          .then((result) {\n            expect(result, 'index file');\n          });\n      });\n\n      testVirtualDir('index-4', (dir) {\n        new File('${dir.path}/dir/index.html')\n            ..createSync(recursive: true)\n            ..writeAsStringSync('index file');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (dir2, request) {\n          // Redirect directory-requests to index.html files.\n          var indexUri = new Uri.file(dir2.path).resolve('index.html');\n          virDir.serveFile(new File(indexUri.toFilePath()), request);\n        };\n        return getAsString(virDir, '/dir/')\n          .then((result) {\n            expect(result, 'index file');\n          });\n      });\n    });\n  });\n\n  group('links', () {\n    if (!Platform.isWindows) {\n      group('follow-links', () {\n        testVirtualDir('dir-link', (dir) {\n          var dir2 = new Directory('${dir.path}/dir2')..createSync();\n          var link = new Link('${dir.path}/dir3')..createSync('dir2');\n          var file = new File('${dir2.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n          virDir.followLinks = true;\n\n          return getStatusCodeForVirtDir(virDir, '/dir3/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n        });\n\n        testVirtualDir('root-link', (dir) {\n          var link = new Link('${dir.path}/dir3')..createSync('.');\n          var file = new File('${dir.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n          virDir.followLinks = true;\n\n          return getStatusCodeForVirtDir(virDir, '/dir3/file')\n            .then((result) {\n              expect(result, HttpStatus.OK);\n            });\n        });\n\n        group('bad-links', () {\n          testVirtualDir('absolute-link', (dir) {\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir.path}/file2')\n                  ..createSync('${dir.path}/file');\n              var virDir = new VirtualDirectory(dir.path);\n              virDir.followLinks = true;\n\n              return getStatusCodeForVirtDir(virDir, '/file2')\n                .then((result) {\n                  expect(result, HttpStatus.NOT_FOUND);\n                });\n          });\n\n          testVirtualDir('relative-parent-link', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir2.path}/file')\n                  ..createSync('../file');\n              var virDir = new VirtualDirectory(dir2.path);\n              virDir.followLinks = true;\n\n              return getStatusCodeForVirtDir(virDir, '/dir3/file')\n                  .then((result) {\n                    expect(result, HttpStatus.NOT_FOUND);\n                  });\n          });\n        });\n      });\n\n      group('not-follow-links', () {\n        testVirtualDir('dir-link', (dir) {\n            var dir2 = new Directory('${dir.path}/dir2')..createSync();\n            var link = new Link('${dir.path}/dir3')..createSync('dir2');\n            var file = new File('${dir2.path}/file')..createSync();\n            var virDir = new VirtualDirectory(dir.path);\n            virDir.followLinks = false;\n\n            return getStatusCodeForVirtDir(virDir, '/dir3/file')\n                .then((result) {\n                  expect(result, HttpStatus.NOT_FOUND);\n                });\n        });\n      });\n\n      group('follow-links', () {\n        group('no-root-jail', () {\n          testVirtualDir('absolute-link', (dir) {\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir.path}/file2')\n                  ..createSync('${dir.path}/file');\n              var virDir = new VirtualDirectory(dir.path);\n              virDir.followLinks = true;\n              virDir.jailRoot = false;\n\n              return getStatusCodeForVirtDir(virDir, '/file2')\n                  .then((result) {\n                    expect(result, HttpStatus.OK);\n                  });\n          });\n\n          testVirtualDir('relative-parent-link', (dir) {\n              var dir2 = new Directory('${dir.path}/dir')..createSync();\n              var file = new File('${dir.path}/file')..createSync();\n              var link = new Link('${dir2.path}/file')\n                  ..createSync('../file');\n              var virDir = new VirtualDirectory(dir2.path);\n              virDir.followLinks = true;\n              virDir.jailRoot = false;\n\n              return getStatusCodeForVirtDir(virDir, '/file')\n                  .then((result) {\n                    expect(result, HttpStatus.OK);\n                  });\n          });\n        });\n      });\n    }\n  });\n\n  group('last-modified', () {\n    group('file', () {\n      testVirtualDir('file-exists', (dir) {\n          var file = new File('${dir.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file')\n              .then((headers) {\n                expect(headers.value(HttpHeaders.LAST_MODIFIED), isNotNull);\n                var lastModified = HttpDate.parse(\n                    headers.value(HttpHeaders.LAST_MODIFIED));\n\n                return getStatusCodeForVirtDir(\n                    virDir, '/file', ifModifiedSince: lastModified);\n              })\n              .then((result) {\n                expect(result, HttpStatus.NOT_MODIFIED);\n              });\n      });\n\n      testVirtualDir('file-changes', (dir) {\n          var file = new File('${dir.path}/file')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file')\n              .then((headers) {\n                expect(headers.value(HttpHeaders.LAST_MODIFIED), isNotNull);\n                var lastModified = HttpDate.parse(\n                    headers.value(HttpHeaders.LAST_MODIFIED));\n\n                // Fake file changed by moving date back in time.\n                lastModified = lastModified.subtract(\n                  const Duration(seconds: 10));\n\n                return getStatusCodeForVirtDir(virDir, '/file',\n                    ifModifiedSince: lastModified);\n              })\n              .then((result) {\n                expect(result, HttpStatus.OK);\n              });\n      });\n    });\n  });\n\n  group('content-type', () {\n    group('mime-type', () {\n      testVirtualDir('from-path', (dir) {\n          var file = new File('${dir.path}/file.jpg')..createSync();\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file.jpg')\n              .then((headers) {\n                var contentType = headers.contentType.toString();\n                expect(contentType, 'image/jpeg');\n              });\n      });\n\n      testVirtualDir('from-magic-number', (dir) {\n          var file = new File('${dir.path}/file.jpg')..createSync();\n          file.writeAsBytesSync(\n              [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);\n          var virDir = new VirtualDirectory(dir.path);\n\n          return getHeaders(virDir, '/file.jpg')\n              .then((headers) {\n                var contentType = headers.contentType.toString();\n                expect(contentType, 'image/png');\n              });\n      });\n    });\n  });\n\n  group('error-page', () {\n    testVirtualDir('default', (dir) {\n        var virDir = new VirtualDirectory(pathos.join(dir.path, 'foo'));\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, matches(new RegExp('404.*Not Found')));\n          });\n    });\n\n    testVirtualDir('custom', (dir) {\n        var virDir = new VirtualDirectory(pathos.join(dir.path, 'foo'));\n\n        virDir.errorPageHandler = (request) {\n          request.response.write('my-page ');\n          request.response.write(request.response.statusCode);\n          request.response.close();\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'my-page 404');\n          });\n    });\n  });\n\n  group('escape-root', () {\n    testVirtualDir('escape1', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/../')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    testVirtualDir('escape2', (dir) {\n        new Directory('${dir.path}/dir').createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/dir/../../')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n  });\n\n  group('url-decode', () {\n    testVirtualDir('with-space', (dir) {\n        var file = new File('${dir.path}/my file')..createSync();\n        var virDir = new VirtualDirectory(dir.path);\n\n        return getStatusCodeForVirtDir(virDir, '/my file')\n          .then((result) {\n            expect(result, HttpStatus.OK);\n          });\n    });\n\n    testVirtualDir('encoded-space', (dir) {\n        var file = new File('${dir.path}/my file')..createSync();\n        var virDir = new VirtualDirectory(dir.path);\n\n        return getStatusCodeForVirtDir(virDir, '/my%20file')\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    testVirtualDir('encoded-path-separator', (dir) {\n        new Directory('${dir.path}/a').createSync();\n        new Directory('${dir.path}/a/b').createSync();\n        new Directory('${dir.path}/a/b/c').createSync();\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/a%2fb/c', rawPath: true)\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    testVirtualDir('encoded-null', (dir) {\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n\n        return getStatusCodeForVirtDir(virDir, '/%00', rawPath: true)\n          .then((result) {\n            expect(result, HttpStatus.NOT_FOUND);\n          });\n    });\n\n    _testEncoding('..', HttpStatus.NOT_FOUND, false);\n    _testEncoding('%2e%2e', HttpStatus.OK);\n    _testEncoding('%252e%252e', HttpStatus.OK);\n    _testEncoding('/', HttpStatus.OK, false);\n    _testEncoding('%2f', HttpStatus.NOT_FOUND, false);\n    _testEncoding('%2f', HttpStatus.OK, true);\n  });\n\n  group('serve-file', () {\n    testVirtualDir('from-dir-handler', (dir) {\n        new File('${dir.path}/file')..writeAsStringSync('file contents');\n        var virDir = new VirtualDirectory(dir.path);\n        virDir.allowDirectoryListing = true;\n        virDir.directoryHandler = (d, request) {\n          expect(FileSystemEntity.identicalSync(dir.path, d.path), isTrue);\n          return virDir.serveFile(new File('${d.path}/file'), request);\n        };\n\n        return getAsString(virDir, '/')\n          .then((result) {\n            expect(result, 'file contents');\n          });\n    });\n  });\n}\n"], "buggy_code_start_loc": [258, 102], "buggy_code_end_loc": [348, 151], "fixing_code_start_loc": [258, 102], "fixing_code_end_loc": [360, 185], "type": "CWE-79", "message": "A vulnerability was found in Dart http_server up to 0.9.5 and classified as problematic. Affected by this issue is the function VirtualDirectory of the file lib/src/virtual_directory.dart of the component Directory Listing Handler. The manipulation of the argument request.uri.path leads to cross site scripting. The attack may be launched remotely. Upgrading to version 0.9.6 is able to address this issue. The name of the patch is 27c1cbd8125bb0369e675eb72e48218496e48ffb. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-225356.", "other": {"cve": {"id": "CVE-2014-125098", "sourceIdentifier": "cna@vuldb.com", "published": "2023-04-10T04:15:08.050", "lastModified": "2023-04-13T20:20:07.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Dart http_server up to 0.9.5 and classified as problematic. Affected by this issue is the function VirtualDirectory of the file lib/src/virtual_directory.dart of the component Directory Listing Handler. The manipulation of the argument request.uri.path leads to cross site scripting. The attack may be launched remotely. Upgrading to version 0.9.6 is able to address this issue. The name of the patch is 27c1cbd8125bb0369e675eb72e48218496e48ffb. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-225356."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dart:http_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.6", "matchCriteriaId": "982EFFFE-C0B8-4CFA-8674-F8C8798606BD"}]}]}], "references": [{"url": "https://codereview.chromium.org/225813002", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/dart-archive/http_server/commit/27c1cbd8125bb0369e675eb72e48218496e48ffb", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/dart-archive/http_server/releases/tag/0.9.6", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.225356", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.225356", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dart-archive/http_server/commit/27c1cbd8125bb0369e675eb72e48218496e48ffb"}}