{"buggy_code": ["#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n\n#define fiber_ptr(o) ((struct RFiber*)mrb_ptr(o))\n\n#define FIBER_STACK_INIT_SIZE 64\n#define FIBER_CI_INIT_SIZE 8\n#define CI_ACC_RESUMED -3\n\n/*\n *  call-seq:\n *     Fiber.new{...} -> obj\n *\n *  Creates a fiber, whose execution is suspend until it is explicitly\n *  resumed using <code>Fiber#resume</code> method.\n *  The code running inside the fiber can give up control by calling\n *  <code>Fiber.yield</code> in which case it yields control back to caller\n *  (the caller of the <code>Fiber#resume</code>).\n *\n *  Upon yielding or termination the Fiber returns the value of the last\n *  executed expression\n *\n *  For instance:\n *\n *    fiber = Fiber.new do\n *      Fiber.yield 1\n *      2\n *    end\n *\n *    puts fiber.resume\n *    puts fiber.resume\n *    puts fiber.resume\n *\n *  <em>produces</em>\n *\n *    1\n *    2\n *    resuming dead fiber (FiberError)\n *\n *  The <code>Fiber#resume</code> method accepts an arbitrary number of\n *  parameters, if it is the first call to <code>resume</code> then they\n *  will be passed as block arguments. Otherwise they will be the return\n *  value of the call to <code>Fiber.yield</code>\n *\n *  Example:\n *\n *    fiber = Fiber.new do |first|\n *      second = Fiber.yield first + 2\n *    end\n *\n *    puts fiber.resume 10\n *    puts fiber.resume 14\n *    puts fiber.resume 18\n *\n *  <em>produces</em>\n *\n *    12\n *    14\n *    resuming dead fiber (FiberError)\n *\n */\nstatic mrb_value\nfiber_init(mrb_state *mrb, mrb_value self)\n{\n  static const struct mrb_context mrb_context_zero = { 0 };\n  struct RFiber *f = fiber_ptr(self);\n  struct mrb_context *c;\n  struct RProc *p;\n  mrb_callinfo *ci;\n  mrb_value blk;\n  size_t slen;\n\n  mrb_get_args(mrb, \"&\", &blk);\n\n  if (f->cxt) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"cannot initialize twice\");\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Fiber object without a block\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (MRB_PROC_CFUNC_P(p)) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"tried to create Fiber from C defined method\");\n  }\n\n  c = (struct mrb_context*)mrb_malloc(mrb, sizeof(struct mrb_context));\n  *c = mrb_context_zero;\n  f->cxt = c;\n\n  /* initialize VM stack */\n  slen = FIBER_STACK_INIT_SIZE;\n  if (p->body.irep->nregs > slen) {\n    slen += p->body.irep->nregs;\n  }\n  c->stbase = (mrb_value *)mrb_malloc(mrb, slen*sizeof(mrb_value));\n  c->stend = c->stbase + slen;\n  c->stack = c->stbase;\n\n#ifdef MRB_NAN_BOXING\n  {\n    mrb_value *p = c->stbase;\n    mrb_value *pend = c->stend;\n\n    while (p < pend) {\n      SET_NIL_VALUE(*p);\n      p++;\n    }\n  }\n#else\n  memset(c->stbase, 0, slen * sizeof(mrb_value));\n#endif\n\n  /* copy receiver from a block */\n  c->stack[0] = mrb->c->stack[0];\n\n  /* initialize callinfo stack */\n  c->cibase = (mrb_callinfo *)mrb_calloc(mrb, FIBER_CI_INIT_SIZE, sizeof(mrb_callinfo));\n  c->ciend = c->cibase + FIBER_CI_INIT_SIZE;\n  c->ci = c->cibase;\n  c->ci->stackent = c->stack;\n\n  /* adjust return callinfo */\n  ci = c->ci;\n  ci->target_class = MRB_PROC_TARGET_CLASS(p);\n  ci->proc = p;\n  mrb_field_write_barrier(mrb, (struct RBasic*)mrb_obj_ptr(self), (struct RBasic*)p);\n  ci->pc = p->body.irep->iseq;\n  ci->nregs = p->body.irep->nregs;\n  ci[1] = ci[0];\n  c->ci++;                      /* push dummy callinfo */\n\n  c->fib = f;\n  c->status = MRB_FIBER_CREATED;\n\n  return self;\n}\n\nstatic struct mrb_context*\nfiber_check(mrb_state *mrb, mrb_value fib)\n{\n  struct RFiber *f = fiber_ptr(fib);\n\n  mrb_assert(f->tt == MRB_TT_FIBER);\n  if (!f->cxt) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"uninitialized Fiber\");\n  }\n  return f->cxt;\n}\n\nstatic mrb_value\nfiber_result(mrb_state *mrb, const mrb_value *a, mrb_int len)\n{\n  if (len == 0) return mrb_nil_value();\n  if (len == 1) return a[0];\n  return mrb_ary_new_from_values(mrb, len, a);\n}\n\n/* mark return from context modifying method */\n#define MARK_CONTEXT_MODIFY(c) (c)->ci->target_class = NULL\n\nstatic void\nfiber_check_cfunc(mrb_state *mrb, struct mrb_context *c)\n{\n  mrb_callinfo *ci;\n\n  for (ci = c->ci; ci >= c->cibase; ci--) {\n    if (ci->acc < 0) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"can't cross C function boundary\");\n    }\n  }\n}\n\nstatic void\nfiber_switch_context(mrb_state *mrb, struct mrb_context *c)\n{\n  c->status = MRB_FIBER_RUNNING;\n  mrb->c = c;\n}\n\nstatic mrb_value\nfiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  if (resume && c->status == MRB_FIBER_TRANSFERRED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n  }\n  if (c->status == MRB_FIBER_RUNNING || c->status == MRB_FIBER_RESUMED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n  }\n  if (c->status == MRB_FIBER_TERMINATED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n  }\n  mrb->c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  if (c->status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    if (len >= c->stend - c->stack) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"too many arguments to fiber\");\n    }\n    b = c->stack+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    c->cibase->argc = (int)len;\n    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n  }\n  fiber_switch_context(mrb, c);\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}\n\n/*\n *  call-seq:\n *     fiber.resume(args, ...) -> obj\n *\n *  Resumes the fiber from the point at which the last <code>Fiber.yield</code>\n *  was called, or starts running it if it is the first call to\n *  <code>resume</code>. Arguments passed to resume will be the value of\n *  the <code>Fiber.yield</code> expression or will be passed as block\n *  parameters to the fiber's block if this is the first <code>resume</code>.\n *\n *  Alternatively, when resume is called it evaluates to the arguments passed\n *  to the next <code>Fiber.yield</code> statement inside the fiber's block\n *  or to the block value if it runs to completion without any\n *  <code>Fiber.yield</code>\n */\nstatic mrb_value\nfiber_resume(mrb_state *mrb, mrb_value self)\n{\n  mrb_value *a;\n  mrb_int len;\n  mrb_bool vmexec = FALSE;\n\n  mrb_get_args(mrb, \"*!\", &a, &len);\n  if (mrb->c->ci->acc < 0) {\n    vmexec = TRUE;\n  }\n  return fiber_switch(mrb, self, len, a, TRUE, vmexec);\n}\n\n/* resume thread with given arguments */\nMRB_API mrb_value\nmrb_fiber_resume(mrb_state *mrb, mrb_value fib, mrb_int len, const mrb_value *a)\n{\n  return fiber_switch(mrb, fib, len, a, TRUE, TRUE);\n}\n\n/*\n *  call-seq:\n *     fiber.alive? -> true or false\n *\n *  Returns true if the fiber can still be resumed. After finishing\n *  execution of the fiber block this method will always return false.\n */\nMRB_API mrb_value\nmrb_fiber_alive_p(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  return mrb_bool_value(c->status != MRB_FIBER_TERMINATED);\n}\n#define fiber_alive_p mrb_fiber_alive_p\n\nstatic mrb_value\nfiber_eq(mrb_state *mrb, mrb_value self)\n{\n  mrb_value other;\n  mrb_get_args(mrb, \"o\", &other);\n\n  if (mrb_type(other) != MRB_TT_FIBER) {\n    return mrb_false_value();\n  }\n  return mrb_bool_value(fiber_ptr(self) == fiber_ptr(other));\n}\n\n/*\n *  call-seq:\n *     fiber.transfer(args, ...) -> obj\n *\n *  Transfers control to receiver fiber of the method call.\n *  Unlike <code>resume</code> the receiver wouldn't be pushed to call\n * stack of fibers. Instead it will switch to the call stack of\n * transferring fiber.\n *  When resuming a fiber that was transferred to another fiber it would\n * cause double resume error. Though when the fiber is re-transferred\n * and <code>Fiber.yield</code> is called, the fiber would be resumable.\n */\nstatic mrb_value\nfiber_transfer(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  mrb_value* a;\n  mrb_int len;\n\n  fiber_check_cfunc(mrb, mrb->c);\n  mrb_get_args(mrb, \"*!\", &a, &len);\n\n  if (c == mrb->root_c) {\n    mrb->c->status = MRB_FIBER_TRANSFERRED;\n    fiber_switch_context(mrb, c);\n    MARK_CONTEXT_MODIFY(c);\n    return fiber_result(mrb, a, len);\n  }\n\n  if (c == mrb->c) {\n    return fiber_result(mrb, a, len);\n  }\n\n  return fiber_switch(mrb, self, len, a, FALSE, FALSE);\n}\n\n/* yield values to the caller fiber */\n/* mrb_fiber_yield() must be called as `return mrb_fiber_yield(...)` */\nMRB_API mrb_value\nmrb_fiber_yield(mrb_state *mrb, mrb_int len, const mrb_value *a)\n{\n  struct mrb_context *c = mrb->c;\n\n  if (!c->prev) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"can't yield from root fiber\");\n  }\n\n  fiber_check_cfunc(mrb, c);\n  c->prev->status = MRB_FIBER_RUNNING;\n  c->status = MRB_FIBER_SUSPENDED;\n  fiber_switch_context(mrb, c->prev);\n  c->prev = NULL;\n  if (c->vmexec) {\n    c->vmexec = FALSE;\n    mrb->c->ci->acc = CI_ACC_RESUMED;\n  }\n  MARK_CONTEXT_MODIFY(mrb->c);\n  return fiber_result(mrb, a, len);\n}\n\n/*\n *  call-seq:\n *     Fiber.yield(args, ...) -> obj\n *\n *  Yields control back to the context that resumed the fiber, passing\n *  along any arguments that were passed to it. The fiber will resume\n *  processing at this point when <code>resume</code> is called next.\n *  Any arguments passed to the next <code>resume</code> will be the\n *\n *  mruby limitation: Fiber resume/yield cannot cross C function boundary.\n *  thus you cannot yield from #initialize which is called by mrb_funcall().\n */\nstatic mrb_value\nfiber_yield(mrb_state *mrb, mrb_value self)\n{\n  mrb_value *a;\n  mrb_int len;\n\n  mrb_get_args(mrb, \"*!\", &a, &len);\n  return mrb_fiber_yield(mrb, len, a);\n}\n\n/*\n *  call-seq:\n *     Fiber.current() -> fiber\n *\n *  Returns the current fiber. If you are not running in the context of\n *  a fiber this method will return the root fiber.\n */\nstatic mrb_value\nfiber_current(mrb_state *mrb, mrb_value self)\n{\n  if (!mrb->c->fib) {\n    struct RFiber *f = (struct RFiber*)mrb_obj_alloc(mrb, MRB_TT_FIBER, mrb_class_ptr(self));\n\n    f->cxt = mrb->c;\n    mrb->c->fib = f;\n  }\n  return mrb_obj_value(mrb->c->fib);\n}\n\nvoid\nmrb_mruby_fiber_gem_init(mrb_state* mrb)\n{\n  struct RClass *c;\n\n  c = mrb_define_class(mrb, \"Fiber\", mrb->object_class);\n  MRB_SET_INSTANCE_TT(c, MRB_TT_FIBER);\n\n  mrb_define_method(mrb, c, \"initialize\", fiber_init,    MRB_ARGS_NONE());\n  mrb_define_method(mrb, c, \"resume\",     fiber_resume,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, c, \"transfer\",   fiber_transfer, MRB_ARGS_ANY());\n  mrb_define_method(mrb, c, \"alive?\",     fiber_alive_p, MRB_ARGS_NONE());\n  mrb_define_method(mrb, c, \"==\",         fiber_eq,      MRB_ARGS_REQ(1));\n\n  mrb_define_class_method(mrb, c, \"yield\", fiber_yield, MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, c, \"current\", fiber_current, MRB_ARGS_NONE());\n\n  mrb_define_class(mrb, \"FiberError\", mrb->eStandardError_class);\n}\n\nvoid\nmrb_mruby_fiber_gem_final(mrb_state* mrb)\n{\n}\n"], "fixing_code": ["#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n\n#define fiber_ptr(o) ((struct RFiber*)mrb_ptr(o))\n\n#define FIBER_STACK_INIT_SIZE 64\n#define FIBER_CI_INIT_SIZE 8\n#define CI_ACC_RESUMED -3\n\n/*\n *  call-seq:\n *     Fiber.new{...} -> obj\n *\n *  Creates a fiber, whose execution is suspend until it is explicitly\n *  resumed using <code>Fiber#resume</code> method.\n *  The code running inside the fiber can give up control by calling\n *  <code>Fiber.yield</code> in which case it yields control back to caller\n *  (the caller of the <code>Fiber#resume</code>).\n *\n *  Upon yielding or termination the Fiber returns the value of the last\n *  executed expression\n *\n *  For instance:\n *\n *    fiber = Fiber.new do\n *      Fiber.yield 1\n *      2\n *    end\n *\n *    puts fiber.resume\n *    puts fiber.resume\n *    puts fiber.resume\n *\n *  <em>produces</em>\n *\n *    1\n *    2\n *    resuming dead fiber (FiberError)\n *\n *  The <code>Fiber#resume</code> method accepts an arbitrary number of\n *  parameters, if it is the first call to <code>resume</code> then they\n *  will be passed as block arguments. Otherwise they will be the return\n *  value of the call to <code>Fiber.yield</code>\n *\n *  Example:\n *\n *    fiber = Fiber.new do |first|\n *      second = Fiber.yield first + 2\n *    end\n *\n *    puts fiber.resume 10\n *    puts fiber.resume 14\n *    puts fiber.resume 18\n *\n *  <em>produces</em>\n *\n *    12\n *    14\n *    resuming dead fiber (FiberError)\n *\n */\nstatic mrb_value\nfiber_init(mrb_state *mrb, mrb_value self)\n{\n  static const struct mrb_context mrb_context_zero = { 0 };\n  struct RFiber *f = fiber_ptr(self);\n  struct mrb_context *c;\n  struct RProc *p;\n  mrb_callinfo *ci;\n  mrb_value blk;\n  size_t slen;\n\n  mrb_get_args(mrb, \"&\", &blk);\n\n  if (f->cxt) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"cannot initialize twice\");\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Fiber object without a block\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (MRB_PROC_CFUNC_P(p)) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"tried to create Fiber from C defined method\");\n  }\n\n  c = (struct mrb_context*)mrb_malloc(mrb, sizeof(struct mrb_context));\n  *c = mrb_context_zero;\n  f->cxt = c;\n\n  /* initialize VM stack */\n  slen = FIBER_STACK_INIT_SIZE;\n  if (p->body.irep->nregs > slen) {\n    slen += p->body.irep->nregs;\n  }\n  c->stbase = (mrb_value *)mrb_malloc(mrb, slen*sizeof(mrb_value));\n  c->stend = c->stbase + slen;\n  c->stack = c->stbase;\n\n#ifdef MRB_NAN_BOXING\n  {\n    mrb_value *p = c->stbase;\n    mrb_value *pend = c->stend;\n\n    while (p < pend) {\n      SET_NIL_VALUE(*p);\n      p++;\n    }\n  }\n#else\n  memset(c->stbase, 0, slen * sizeof(mrb_value));\n#endif\n\n  /* copy receiver from a block */\n  c->stack[0] = mrb->c->stack[0];\n\n  /* initialize callinfo stack */\n  c->cibase = (mrb_callinfo *)mrb_calloc(mrb, FIBER_CI_INIT_SIZE, sizeof(mrb_callinfo));\n  c->ciend = c->cibase + FIBER_CI_INIT_SIZE;\n  c->ci = c->cibase;\n  c->ci->stackent = c->stack;\n\n  /* adjust return callinfo */\n  ci = c->ci;\n  ci->target_class = MRB_PROC_TARGET_CLASS(p);\n  ci->proc = p;\n  mrb_field_write_barrier(mrb, (struct RBasic*)mrb_obj_ptr(self), (struct RBasic*)p);\n  ci->pc = p->body.irep->iseq;\n  ci->nregs = p->body.irep->nregs;\n  ci[1] = ci[0];\n  c->ci++;                      /* push dummy callinfo */\n\n  c->fib = f;\n  c->status = MRB_FIBER_CREATED;\n\n  return self;\n}\n\nstatic struct mrb_context*\nfiber_check(mrb_state *mrb, mrb_value fib)\n{\n  struct RFiber *f = fiber_ptr(fib);\n\n  mrb_assert(f->tt == MRB_TT_FIBER);\n  if (!f->cxt) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"uninitialized Fiber\");\n  }\n  return f->cxt;\n}\n\nstatic mrb_value\nfiber_result(mrb_state *mrb, const mrb_value *a, mrb_int len)\n{\n  if (len == 0) return mrb_nil_value();\n  if (len == 1) return a[0];\n  return mrb_ary_new_from_values(mrb, len, a);\n}\n\n/* mark return from context modifying method */\n#define MARK_CONTEXT_MODIFY(c) (c)->ci->target_class = NULL\n\nstatic void\nfiber_check_cfunc(mrb_state *mrb, struct mrb_context *c)\n{\n  mrb_callinfo *ci;\n\n  for (ci = c->ci; ci >= c->cibase; ci--) {\n    if (ci->acc < 0) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"can't cross C function boundary\");\n    }\n  }\n}\n\nstatic void\nfiber_switch_context(mrb_state *mrb, struct mrb_context *c)\n{\n  c->status = MRB_FIBER_RUNNING;\n  mrb->c = c;\n}\n\nstatic mrb_value\nfiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  if (resume && status == MRB_FIBER_TRANSFERRED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n  }\n  if (status == MRB_FIBER_RUNNING || status == MRB_FIBER_RESUMED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n  }\n  if (status == MRB_FIBER_TERMINATED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n    b = c->stack+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    c->cibase->argc = (int)len;\n    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}\n\n/*\n *  call-seq:\n *     fiber.resume(args, ...) -> obj\n *\n *  Resumes the fiber from the point at which the last <code>Fiber.yield</code>\n *  was called, or starts running it if it is the first call to\n *  <code>resume</code>. Arguments passed to resume will be the value of\n *  the <code>Fiber.yield</code> expression or will be passed as block\n *  parameters to the fiber's block if this is the first <code>resume</code>.\n *\n *  Alternatively, when resume is called it evaluates to the arguments passed\n *  to the next <code>Fiber.yield</code> statement inside the fiber's block\n *  or to the block value if it runs to completion without any\n *  <code>Fiber.yield</code>\n */\nstatic mrb_value\nfiber_resume(mrb_state *mrb, mrb_value self)\n{\n  mrb_value *a;\n  mrb_int len;\n  mrb_bool vmexec = FALSE;\n\n  mrb_get_args(mrb, \"*!\", &a, &len);\n  if (mrb->c->ci->acc < 0) {\n    vmexec = TRUE;\n  }\n  return fiber_switch(mrb, self, len, a, TRUE, vmexec);\n}\n\n/* resume thread with given arguments */\nMRB_API mrb_value\nmrb_fiber_resume(mrb_state *mrb, mrb_value fib, mrb_int len, const mrb_value *a)\n{\n  return fiber_switch(mrb, fib, len, a, TRUE, TRUE);\n}\n\n/*\n *  call-seq:\n *     fiber.alive? -> true or false\n *\n *  Returns true if the fiber can still be resumed. After finishing\n *  execution of the fiber block this method will always return false.\n */\nMRB_API mrb_value\nmrb_fiber_alive_p(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  return mrb_bool_value(c->status != MRB_FIBER_TERMINATED);\n}\n#define fiber_alive_p mrb_fiber_alive_p\n\nstatic mrb_value\nfiber_eq(mrb_state *mrb, mrb_value self)\n{\n  mrb_value other;\n  mrb_get_args(mrb, \"o\", &other);\n\n  if (mrb_type(other) != MRB_TT_FIBER) {\n    return mrb_false_value();\n  }\n  return mrb_bool_value(fiber_ptr(self) == fiber_ptr(other));\n}\n\n/*\n *  call-seq:\n *     fiber.transfer(args, ...) -> obj\n *\n *  Transfers control to receiver fiber of the method call.\n *  Unlike <code>resume</code> the receiver wouldn't be pushed to call\n * stack of fibers. Instead it will switch to the call stack of\n * transferring fiber.\n *  When resuming a fiber that was transferred to another fiber it would\n * cause double resume error. Though when the fiber is re-transferred\n * and <code>Fiber.yield</code> is called, the fiber would be resumable.\n */\nstatic mrb_value\nfiber_transfer(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  mrb_value* a;\n  mrb_int len;\n\n  fiber_check_cfunc(mrb, mrb->c);\n  mrb_get_args(mrb, \"*!\", &a, &len);\n\n  if (c == mrb->root_c) {\n    mrb->c->status = MRB_FIBER_TRANSFERRED;\n    fiber_switch_context(mrb, c);\n    MARK_CONTEXT_MODIFY(c);\n    return fiber_result(mrb, a, len);\n  }\n\n  if (c == mrb->c) {\n    return fiber_result(mrb, a, len);\n  }\n\n  return fiber_switch(mrb, self, len, a, FALSE, FALSE);\n}\n\n/* yield values to the caller fiber */\n/* mrb_fiber_yield() must be called as `return mrb_fiber_yield(...)` */\nMRB_API mrb_value\nmrb_fiber_yield(mrb_state *mrb, mrb_int len, const mrb_value *a)\n{\n  struct mrb_context *c = mrb->c;\n\n  if (!c->prev) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"can't yield from root fiber\");\n  }\n\n  fiber_check_cfunc(mrb, c);\n  c->prev->status = MRB_FIBER_RUNNING;\n  c->status = MRB_FIBER_SUSPENDED;\n  fiber_switch_context(mrb, c->prev);\n  c->prev = NULL;\n  if (c->vmexec) {\n    c->vmexec = FALSE;\n    mrb->c->ci->acc = CI_ACC_RESUMED;\n  }\n  MARK_CONTEXT_MODIFY(mrb->c);\n  return fiber_result(mrb, a, len);\n}\n\n/*\n *  call-seq:\n *     Fiber.yield(args, ...) -> obj\n *\n *  Yields control back to the context that resumed the fiber, passing\n *  along any arguments that were passed to it. The fiber will resume\n *  processing at this point when <code>resume</code> is called next.\n *  Any arguments passed to the next <code>resume</code> will be the\n *\n *  mruby limitation: Fiber resume/yield cannot cross C function boundary.\n *  thus you cannot yield from #initialize which is called by mrb_funcall().\n */\nstatic mrb_value\nfiber_yield(mrb_state *mrb, mrb_value self)\n{\n  mrb_value *a;\n  mrb_int len;\n\n  mrb_get_args(mrb, \"*!\", &a, &len);\n  return mrb_fiber_yield(mrb, len, a);\n}\n\n/*\n *  call-seq:\n *     Fiber.current() -> fiber\n *\n *  Returns the current fiber. If you are not running in the context of\n *  a fiber this method will return the root fiber.\n */\nstatic mrb_value\nfiber_current(mrb_state *mrb, mrb_value self)\n{\n  if (!mrb->c->fib) {\n    struct RFiber *f = (struct RFiber*)mrb_obj_alloc(mrb, MRB_TT_FIBER, mrb_class_ptr(self));\n\n    f->cxt = mrb->c;\n    mrb->c->fib = f;\n  }\n  return mrb_obj_value(mrb->c->fib);\n}\n\nvoid\nmrb_mruby_fiber_gem_init(mrb_state* mrb)\n{\n  struct RClass *c;\n\n  c = mrb_define_class(mrb, \"Fiber\", mrb->object_class);\n  MRB_SET_INSTANCE_TT(c, MRB_TT_FIBER);\n\n  mrb_define_method(mrb, c, \"initialize\", fiber_init,    MRB_ARGS_NONE());\n  mrb_define_method(mrb, c, \"resume\",     fiber_resume,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, c, \"transfer\",   fiber_transfer, MRB_ARGS_ANY());\n  mrb_define_method(mrb, c, \"alive?\",     fiber_alive_p, MRB_ARGS_NONE());\n  mrb_define_method(mrb, c, \"==\",         fiber_eq,      MRB_ARGS_REQ(1));\n\n  mrb_define_class_method(mrb, c, \"yield\", fiber_yield, MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, c, \"current\", fiber_current, MRB_ARGS_NONE());\n\n  mrb_define_class(mrb, \"FiberError\", mrb->eStandardError_class);\n}\n\nvoid\nmrb_mruby_fiber_gem_final(mrb_state* mrb)\n{\n}\n"], "buggy_code_start_loc": [186], "buggy_code_end_loc": [219], "fixing_code_start_loc": [187], "fixing_code_end_loc": [218], "type": "CWE-125", "message": "An issue was discovered in mruby 1.4.1. There is a heap-based buffer over-read associated with OP_ENTER because mrbgems/mruby-fiber/src/fiber.c does not extend the stack in cases of many arguments to fiber.", "other": {"cve": {"id": "CVE-2018-12248", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-12T14:29:00.400", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in mruby 1.4.1. There is a heap-based buffer over-read associated with OP_ENTER because mrbgems/mruby-fiber/src/fiber.c does not extend the stack in cases of many arguments to fiber."}, {"lang": "es", "value": "Se ha descubierto un problema en mruby 1.4.1. Hay una sobrelectura de b\u00fafer basada en memoria din\u00e1mica (heap) asociada con OP_ENTER debido a que mrbgems/mruby-fiber/src/fiber.c no extiende la pila en casos en los que hay muchos argumentos en fiber."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "C4A86E77-13CC-41B4-AB91-4A7C513791BC"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/778500563a9f7ceba996937dc886bd8cde29b42b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mruby/mruby/issues/4038", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/778500563a9f7ceba996937dc886bd8cde29b42b"}}