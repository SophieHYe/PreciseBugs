{"buggy_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage webhook\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/google/go-containerregistry/pkg/authn/k8schain\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/cosign/pkg/policy\"\n\tcsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/fulcio/pkg/api\"\n\t\"github.com/sigstore/policy-controller/pkg/apis/config\"\n\tpolicyduckv1beta1 \"github.com/sigstore/policy-controller/pkg/apis/duck/v1beta1\"\n\twebhookcip \"github.com/sigstore/policy-controller/pkg/webhook/clusterimagepolicy\"\n\trekor \"github.com/sigstore/rekor/pkg/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/client-go/kubernetes\"\n\tlistersv1 \"k8s.io/client-go/listers/core/v1\"\n\t\"knative.dev/pkg/apis\"\n\tduckv1 \"knative.dev/pkg/apis/duck/v1\"\n\n\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"\n\tsecretinformer \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret\"\n\t\"knative.dev/pkg/logging\"\n\t\"knative.dev/pkg/system\"\n)\n\ntype Validator struct {\n\tclient     kubernetes.Interface\n\tlister     listersv1.SecretLister\n\tsecretName string\n}\n\nfunc NewValidator(ctx context.Context, secretName string) *Validator {\n\treturn &Validator{\n\t\tclient:     kubeclient.Get(ctx),\n\t\tlister:     secretinformer.Get(ctx).Lister(),\n\t\tsecretName: secretName,\n\t}\n}\n\n// isDeletedOrStatusUpdate returns true if the resource in question is being\n// deleted, is already deleted or Status is being updated. In any of those\n// cases, we do not validate the resource\nfunc isDeletedOrStatusUpdate(ctx context.Context, deletionTimestamp *metav1.Time) bool {\n\treturn apis.IsInDelete(ctx) || deletionTimestamp != nil || apis.IsInStatusUpdate(ctx)\n}\n\n// ValidatePodScalable implements policyduckv1beta1.PodScalableValidator\n// It is very similar to ValidatePodSpecable, but allows for spec.replicas\n// to be decremented. This allows for scaling down pods with non-compliant\n// images that would otherwise be forbidden.\nfunc (v *Validator) ValidatePodScalable(ctx context.Context, ps *policyduckv1beta1.PodScalable) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, ps.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\t// If we are being scaled down don't block it.\n\tif ps.IsScalingDown(ctx) {\n\t\tlogging.FromContext(ctx).Debugf(\"Skipping validations due to scale down request %s/%s\", &ps.ObjectMeta.Name, &ps.ObjectMeta.Namespace)\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(ps.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range ps.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          ps.Namespace,\n\t\tServiceAccountName: ps.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, ps.Namespace, &ps.Spec.Template.Spec, opt).ViaField(\"spec.template.spec\")\n}\n\n// ValidatePodSpecable implements duckv1.PodSpecValidator\nfunc (v *Validator) ValidatePodSpecable(ctx context.Context, wp *duckv1.WithPod) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, wp.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(wp.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range wp.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          wp.Namespace,\n\t\tServiceAccountName: wp.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, wp.Namespace, &wp.Spec.Template.Spec, opt).ViaField(\"spec.template.spec\")\n}\n\n// ValidatePod implements duckv1.PodValidator\nfunc (v *Validator) ValidatePod(ctx context.Context, p *duckv1.Pod) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, p.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(p.Spec.ImagePullSecrets))\n\tfor _, s := range p.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          p.Namespace,\n\t\tServiceAccountName: p.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, p.Namespace, &p.Spec, opt).ViaField(\"spec\")\n}\n\n// ValidateCronJob implements duckv1.CronJobValidator\nfunc (v *Validator) ValidateCronJob(ctx context.Context, c *duckv1.CronJob) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, c.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          c.Namespace,\n\t\tServiceAccountName: c.Spec.JobTemplate.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, c.Namespace, &c.Spec.JobTemplate.Spec.Template.Spec, opt).ViaField(\"spec.jobTemplate.spec.template.spec\")\n}\n\nfunc (v *Validator) validatePodSpec(ctx context.Context, namespace string, ps *corev1.PodSpec, opt k8schain.Options) (errs *apis.FieldError) {\n\tkc, err := k8schain.New(ctx, v.client, opt)\n\tif err != nil {\n\t\tlogging.FromContext(ctx).Warnf(\"Unable to build k8schain: %v\", err)\n\t\treturn apis.ErrGeneric(err.Error(), apis.CurrentField)\n\t}\n\n\ts, err := v.lister.Secrets(system.Namespace()).Get(v.secretName)\n\tif err != nil && !apierrs.IsNotFound(err) {\n\t\treturn apis.ErrGeneric(err.Error(), apis.CurrentField)\n\t}\n\t// If the secret is not found, we verify against the fulcio root.\n\tkeys := make([]crypto.PublicKey, 0)\n\tif err == nil {\n\t\tvar kerr *apis.FieldError\n\t\tkeys, kerr = getKeys(ctx, s.Data)\n\t\tif kerr != nil {\n\t\t\treturn kerr\n\t\t}\n\t}\n\n\tcheckContainers := func(cs []corev1.Container, field string) {\n\t\tfor i, c := range cs {\n\t\t\tref, err := name.ParseReference(c.Image)\n\t\t\tif err != nil {\n\t\t\t\terrs = errs.Also(apis.ErrGeneric(err.Error(), \"image\").ViaFieldIndex(field, i))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Require digests, otherwise the validation is meaningless\n\t\t\t// since the tag can move.\n\t\t\tif _, ok := ref.(name.Digest); !ok {\n\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(\n\t\t\t\t\tfmt.Sprintf(\"%s must be an image digest\", c.Image),\n\t\t\t\t\t\"image\",\n\t\t\t\t).ViaFieldIndex(field, i))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainerKeys := keys\n\t\t\tconfig := config.FromContext(ctx)\n\n\t\t\t// During the migration from the secret only validation into policy\n\t\t\t// based ones. If there were matching policies that successfully\n\t\t\t// validated the image, keep tally of it and if all Policies that\n\t\t\t// matched validated, skip the traditional one since they are not\n\t\t\t// necessarily going to play nicely together.\n\t\t\tpassedPolicyChecks := false\n\t\t\tif config != nil {\n\t\t\t\tpolicies, err := config.ImagePolicyConfig.GetMatchingPolicies(ref.Name())\n\t\t\t\tif err != nil {\n\t\t\t\t\terrorField := apis.ErrGeneric(err.Error(), \"image\").ViaFieldIndex(field, i)\n\t\t\t\t\terrorField.Details = c.Image\n\t\t\t\t\terrs = errs.Also(errorField)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// If there is at least one policy that matches, that means it\n\t\t\t\t// has to be satisfied.\n\t\t\t\tif len(policies) > 0 {\n\t\t\t\t\tsignatures, fieldErrors := validatePolicies(ctx, namespace, ref, policies, ociremote.WithRemoteOptions(remote.WithAuthFromKeychain(kc)))\n\n\t\t\t\t\tif len(signatures) != len(policies) {\n\t\t\t\t\t\tlogging.FromContext(ctx).Warnf(\"Failed to validate at least one policy for %s\", ref.Name())\n\t\t\t\t\t\t// Do we really want to add all the error details here?\n\t\t\t\t\t\t// Seems like we can just say which policy failed, so\n\t\t\t\t\t\t// doing that for now.\n\t\t\t\t\t\tfor failingPolicy, policyErrs := range fieldErrors {\n\t\t\t\t\t\t\terrorField := apis.ErrGeneric(fmt.Sprintf(\"failed policy: %s\", failingPolicy), \"image\").ViaFieldIndex(field, i)\n\t\t\t\t\t\t\terrDetails := c.Image\n\t\t\t\t\t\t\tfor _, policyErr := range policyErrs {\n\t\t\t\t\t\t\t\terrDetails = errDetails + \" \" + policyErr.Error()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\terrorField.Details = errDetails\n\t\t\t\t\t\t\terrs = errs.Also(errorField)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Because there was at least one policy that was\n\t\t\t\t\t\t// supposed to be validated, but it failed, then fail\n\t\t\t\t\t\t// this image. It should not fall through to the\n\t\t\t\t\t\t// traditional secret checking so it does not slip\n\t\t\t\t\t\t// through the policy cracks, and also to reduce noise\n\t\t\t\t\t\t// in the errors returned to the user.\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogging.FromContext(ctx).Warnf(\"Validated authorities for %s\", ref.Name())\n\t\t\t\t\t\t// Only say we passed (aka, we skip the traditidional check\n\t\t\t\t\t\t// below) if more than one authority was validated, which\n\t\t\t\t\t\t// means that there was a matching ClusterImagePolicy.\n\t\t\t\t\t\tif len(signatures) > 0 {\n\t\t\t\t\t\t\tpassedPolicyChecks = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"policies: for %v\", policies)\n\t\t\t}\n\n\t\t\tif passedPolicyChecks {\n\t\t\t\tlogging.FromContext(ctx).Debugf(\"Found at least one matching policy and it was validated for %s\", ref.Name())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlogging.FromContext(ctx).Errorf(\"ref: for %v\", ref)\n\t\t\tlogging.FromContext(ctx).Errorf(\"container Keys: for %v\", containerKeys)\n\n\t\t\tif _, err := valid(ctx, ref, nil, containerKeys, ociremote.WithRemoteOptions(remote.WithAuthFromKeychain(kc))); err != nil {\n\t\t\t\terrorField := apis.ErrGeneric(err.Error(), \"image\").ViaFieldIndex(field, i)\n\t\t\t\terrorField.Details = c.Image\n\t\t\t\terrs = errs.Also(errorField)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckContainers(ps.InitContainers, \"initContainers\")\n\tcheckContainers(ps.Containers, \"containers\")\n\n\treturn errs\n}\n\n// validatePolicies will go through all the matching Policies and their\n// Authorities for a given image. Returns the map of policy=>Validated\n// signatures. From the map you can see the number of matched policies along\n// with the signatures that were verified.\n// If there's a policy that did not match, it will be returned in the errors map\n// along with all the errors that caused it to fail.\n// Note that if an image does not match any policies, it's perfectly\n// reasonable that the return value is 0, nil since there were no errors, but\n// the image was not validated against any matching policy and hence authority.\nfunc validatePolicies(ctx context.Context, namespace string, ref name.Reference, policies map[string]webhookcip.ClusterImagePolicy, remoteOpts ...ociremote.Option) (map[string]*PolicyResult, map[string][]error) {\n\ttype retChannelType struct {\n\t\tname         string\n\t\tpolicyResult *PolicyResult\n\t\terrors       []error\n\t}\n\tresults := make(chan retChannelType, len(policies))\n\n\t// For each matching policy it must validate at least one Authority within\n\t// it.\n\t// From the Design document, the part about multiple Policies matching:\n\t// \"If multiple policies match a particular image, then ALL of those\n\t// policies must be satisfied for the image to be admitted.\"\n\t// If none of the Authorities for a given policy pass the checks, gather\n\t// the errors here. If one passes, do not return the errors.\n\tfor cipName, cip := range policies {\n\t\t// Due to running in gofunc\n\t\tcipName := cipName\n\t\tcip := cip\n\t\tlogging.FromContext(ctx).Debugf(\"Checking Policy: %s\", cipName)\n\t\tgo func() {\n\t\t\tresult := retChannelType{name: cipName}\n\n\t\t\tresult.policyResult, result.errors = ValidatePolicy(ctx, namespace, ref, cip, remoteOpts...)\n\t\t\tresults <- result\n\t\t}()\n\t}\n\t// Gather all validated policies here.\n\tpolicyResults := make(map[string]*PolicyResult)\n\t// For a policy that does not pass at least one authority, gather errors\n\t// here so that we can give meaningful errors to the user.\n\tret := map[string][]error{}\n\n\tfor i := 0; i < len(policies); i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tret[\"internalerror\"] = append(ret[\"internalerror\"], fmt.Errorf(\"context was canceled before validation completed\"))\n\t\tcase result, ok := <-results:\n\t\t\tif !ok {\n\t\t\t\tret[\"internalerror\"] = append(ret[\"internalerror\"], fmt.Errorf(\"results channel failed to produce a result\"))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch {\n\t\t\t// Return AuthorityMatches before errors, since even if there\n\t\t\t// are errors, if there are 0 or more authorities that match,\n\t\t\t// it will pass the Policy. Of course, a CIP level policy can\n\t\t\t// override this behaviour, but that has been checked above and\n\t\t\t// if it failed, it will nil out the policyResult.\n\t\t\tcase result.policyResult != nil:\n\t\t\t\tpolicyResults[result.name] = result.policyResult\n\t\t\tcase len(result.errors) > 0:\n\t\t\t\tret[result.name] = append(ret[result.name], result.errors...)\n\t\t\tdefault:\n\t\t\t\tret[result.name] = append(ret[result.name], fmt.Errorf(\"failed to process policy: %s\", result.name))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn policyResults, ret\n}\n\n// ValidatePolicy will go through all the Authorities for a given image/policy\n// and return validated authorities if at least one of the Authorities\n// validated the signatures OR attestations if atttestations were specified.\n// Returns PolicyResult if one or more authorities matched, otherwise nil.\n// In any case returns all errors encountered if none of the authorities\n// passed.\nfunc ValidatePolicy(ctx context.Context, namespace string, ref name.Reference, cip webhookcip.ClusterImagePolicy, remoteOpts ...ociremote.Option) (*PolicyResult, []error) {\n\t// Each gofunc creates and puts one of these into a results channel.\n\t// Once each gofunc finishes, we go through the channel and pull out\n\t// the results.\n\ttype retChannelType struct {\n\t\tname         string\n\t\tstatic       bool\n\t\tattestations map[string][]PolicySignature\n\t\tsignatures   []PolicySignature\n\t\terr          error\n\t}\n\tresults := make(chan retChannelType, len(cip.Authorities))\n\tfor _, authority := range cip.Authorities {\n\t\tauthority := authority // due to gofunc\n\t\tlogging.FromContext(ctx).Debugf(\"Checking Authority: %s\", authority.Name)\n\n\t\tgo func() {\n\t\t\tresult := retChannelType{name: authority.Name}\n\t\t\t// Assignment for appendAssign lint error\n\t\t\tauthorityRemoteOpts := remoteOpts\n\t\t\tauthorityRemoteOpts = append(authorityRemoteOpts, authority.RemoteOpts...)\n\n\t\t\tsignaturePullSecretsOpts, err := authority.SourceSignaturePullSecretsOpts(ctx, namespace)\n\t\t\tif err != nil {\n\t\t\t\tresult.err = err\n\t\t\t\tresults <- result\n\t\t\t\treturn\n\t\t\t}\n\t\t\tauthorityRemoteOpts = append(authorityRemoteOpts, signaturePullSecretsOpts...)\n\n\t\t\tswitch {\n\t\t\tcase authority.Static != nil:\n\t\t\t\tif authority.Static.Action == \"fail\" {\n\t\t\t\t\tresult.err = cosign.NewVerificationError(\"disallowed by static policy\")\n\t\t\t\t\tresults <- result\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresult.static = true\n\n\t\t\tcase len(authority.Attestations) > 0:\n\t\t\t\t// We're doing the verify-attestations path, so validate (.att)\n\t\t\t\tresult.attestations, result.err = ValidatePolicyAttestationsForAuthority(ctx, ref, authority, authorityRemoteOpts...)\n\n\t\t\tdefault:\n\t\t\t\tresult.signatures, result.err = ValidatePolicySignaturesForAuthority(ctx, ref, authority, authorityRemoteOpts...)\n\t\t\t}\n\t\t\tresults <- result\n\t\t}()\n\t}\n\n\t// If none of the Authorities for a given policy pass the checks, gather\n\t// the errors here. Even if there are errors, return the matched\n\t// authoritypolicies.\n\tauthorityErrors := make([]error, 0, len(cip.Authorities))\n\t// We collect all the successfully satisfied Authorities into this and\n\t// return it.\n\tpolicyResult := &PolicyResult{\n\t\tAuthorityMatches: make(map[string]AuthorityMatch, len(cip.Authorities)),\n\t}\n\tfor range cip.Authorities {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tauthorityErrors = append(authorityErrors, fmt.Errorf(\"%w before validation completed\", ctx.Err()))\n\n\t\tcase result, ok := <-results:\n\t\t\tif !ok {\n\t\t\t\tauthorityErrors = append(authorityErrors, errors.New(\"results channel closed before all results were sent\"))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch {\n\t\t\tcase result.err != nil:\n\t\t\t\tauthorityErrors = append(authorityErrors, result.err)\n\n\t\t\tcase len(result.signatures) > 0:\n\t\t\t\tpolicyResult.AuthorityMatches[result.name] = AuthorityMatch{Signatures: result.signatures}\n\n\t\t\tcase len(result.attestations) > 0:\n\t\t\t\tpolicyResult.AuthorityMatches[result.name] = AuthorityMatch{Attestations: result.attestations}\n\n\t\t\tcase result.static:\n\t\t\t\t// This happens when we encounter a policy with:\n\t\t\t\t//   static:\n\t\t\t\t//     action: \"pass\"\n\t\t\t\tpolicyResult.AuthorityMatches[result.name] = AuthorityMatch{\n\t\t\t\t\tStatic: true,\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tauthorityErrors = append(authorityErrors, fmt.Errorf(\"failed to process authority: %s\", result.name))\n\t\t\t}\n\t\t}\n\t}\n\t// Even if there are errors, return the policies, since as per the\n\t// spec, we just need one authority to pass checks. If more than\n\t// one are required, that is enforced at the CIP policy level.\n\t// If however there are no authorityMatches, return nil so we don't have\n\t// to keep checking the length on the returned calls.\n\tif len(policyResult.AuthorityMatches) == 0 {\n\t\treturn nil, authorityErrors\n\t}\n\t// Ok, there's at least one valid authority that matched. If there's a CIP\n\t// level policy, validate it here before returning.\n\tif cip.Policy != nil {\n\t\tlogging.FromContext(ctx).Info(\"Validating CIP level policy\")\n\t\tpolicyJSON, err := json.Marshal(policyResult)\n\t\tif err != nil {\n\t\t\treturn nil, append(authorityErrors, err)\n\t\t}\n\t\terr = policy.EvaluatePolicyAgainstJSON(ctx, \"ClusterImagePolicy\", cip.Policy.Type, cip.Policy.Data, policyJSON)\n\t\tif err != nil {\n\t\t\tlogging.FromContext(ctx).Warnf(\"Failed to validate CIP level policy against %s\", string(policyJSON))\n\t\t\treturn nil, append(authorityErrors, err)\n\t\t}\n\t}\n\treturn policyResult, authorityErrors\n}\n\nfunc ociSignatureToPolicySignature(ctx context.Context, sigs []oci.Signature) []PolicySignature {\n\tret := make([]PolicySignature, 0, len(sigs))\n\tfor _, ociSig := range sigs {\n\t\tlogging.FromContext(ctx).Debugf(\"Converting signature %+v\", ociSig)\n\n\t\tif cert, err := ociSig.Cert(); err == nil && cert != nil {\n\t\t\tce := cosign.CertExtensions{\n\t\t\t\tCert: cert,\n\t\t\t}\n\t\t\tret = append(ret, PolicySignature{\n\t\t\t\tSubject: csigs.CertSubject(cert),\n\t\t\t\tIssuer:  ce.GetIssuer(),\n\t\t\t\tGithubExtensions: GithubExtensions{\n\t\t\t\t\tWorkflowTrigger: ce.GetCertExtensionGithubWorkflowTrigger(),\n\t\t\t\t\tWorkflowSHA:     ce.GetExtensionGithubWorkflowSha(),\n\t\t\t\t\tWorkflowName:    ce.GetCertExtensionGithubWorkflowName(),\n\t\t\t\t\tWorkflowRepo:    ce.GetCertExtensionGithubWorkflowRepository(),\n\t\t\t\t\tWorkflowRef:     ce.GetCertExtensionGithubWorkflowRef(),\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\tret = append(ret, PolicySignature{})\n\t\t}\n\t}\n\treturn ret\n}\n\n// ValidatePolicySignaturesForAuthority takes the Authority and tries to\n// verify a signature against it.\nfunc ValidatePolicySignaturesForAuthority(ctx context.Context, ref name.Reference, authority webhookcip.Authority, remoteOpts ...ociremote.Option) ([]PolicySignature, error) {\n\tname := authority.Name\n\n\tvar rekorClient *client.Rekor\n\tvar err error\n\tif authority.CTLog != nil && authority.CTLog.URL != nil {\n\t\tlogging.FromContext(ctx).Debugf(\"Using CTLog %s for %s\", authority.CTLog.URL, ref.Name())\n\t\trekorClient, err = rekor.GetRekorClient(authority.CTLog.URL.String())\n\t\tif err != nil {\n\t\t\tlogging.FromContext(ctx).Errorf(\"failed creating rekor client: +v\", err)\n\t\t\treturn nil, fmt.Errorf(\"creating Rekor client: %w\", err)\n\t\t}\n\t}\n\n\tswitch {\n\tcase authority.Key != nil && len(authority.Key.PublicKeys) > 0:\n\t\t// TODO(vaikas): What should happen if there are multiple keys\n\t\t// Is it even allowed? 'valid' returns success if any key\n\t\t// matches.\n\t\t// https://github.com/sigstore/policy-controller/issues/1652\n\t\tsps, err := valid(ctx, ref, rekorClient, authority.Key.PublicKeys, remoteOpts...)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"signature key validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t}\n\t\tlogging.FromContext(ctx).Debugf(\"validated signature for %s for authority %s got %d signatures\", ref.Name(), authority.Name, len(sps))\n\t\treturn ociSignatureToPolicySignature(ctx, sps), nil\n\n\tcase authority.Keyless != nil:\n\t\tif authority.Keyless != nil && authority.Keyless.URL != nil {\n\t\t\tlogging.FromContext(ctx).Debugf(\"Fetching FulcioRoot for %s : From: %s \", ref.Name(), authority.Keyless.URL)\n\t\t\tfulcioroot, err := getFulcioCert(authority.Keyless.URL)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fetching FulcioRoot: %w\", err)\n\t\t\t}\n\t\t\tsps, err := validSignaturesWithFulcio(ctx, ref, fulcioroot, rekorClient, authority.Keyless.Identities, remoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"failed validSignatures for authority %s with fulcio for %s: %v\", name, ref.Name(), err)\n\t\t\t\treturn nil, fmt.Errorf(\"signature keyless validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t\t}\n\t\t\tlogging.FromContext(ctx).Debugf(\"validated signature for %s, got %d signatures\", ref.Name(), len(sps))\n\t\t\treturn ociSignatureToPolicySignature(ctx, sps), nil\n\t\t}\n\t}\n\n\t// This should never happen because authority has to have been validated to\n\t// be either having a Key, Keyless, or Static (handled elsewhere)\n\treturn nil, errors.New(\"authority has neither key, keyless, or static specified\")\n}\n\n// ValidatePolicyAttestationsForAuthority takes the Authority and tries to\n// verify attestations against it.\nfunc ValidatePolicyAttestationsForAuthority(ctx context.Context, ref name.Reference, authority webhookcip.Authority, remoteOpts ...ociremote.Option) (map[string][]PolicySignature, error) {\n\tname := authority.Name\n\tvar rekorClient *client.Rekor\n\tvar err error\n\tif authority.CTLog != nil && authority.CTLog.URL != nil {\n\t\tlogging.FromContext(ctx).Debugf(\"Using CTLog %s for %s\", authority.CTLog.URL, ref.Name())\n\t\trekorClient, err = rekor.GetRekorClient(authority.CTLog.URL.String())\n\t\tif err != nil {\n\t\t\tlogging.FromContext(ctx).Errorf(\"failed creating rekor client: +v\", err)\n\t\t\treturn nil, fmt.Errorf(\"creating Rekor client: %w\", err)\n\t\t}\n\t}\n\n\tverifiedAttestations := []oci.Signature{}\n\tswitch {\n\tcase authority.Key != nil && len(authority.Key.PublicKeys) > 0:\n\t\tfor _, k := range authority.Key.PublicKeys {\n\t\t\tverifier, err := signature.LoadVerifier(k, crypto.SHA256)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"error creating verifier: %v\", err)\n\t\t\t\treturn nil, fmt.Errorf(\"creating verifier: %w\", err)\n\t\t\t}\n\t\t\tva, err := validAttestations(ctx, ref, verifier, rekorClient, remoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"error validating attestations: %v\", err)\n\t\t\t\treturn nil, fmt.Errorf(\"attestation key validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t\t}\n\t\t\tverifiedAttestations = append(verifiedAttestations, va...)\n\t\t}\n\n\tcase authority.Keyless != nil:\n\t\tif authority.Keyless != nil && authority.Keyless.URL != nil {\n\t\t\tlogging.FromContext(ctx).Debugf(\"Fetching FulcioRoot for %s : From: %s \", ref.Name(), authority.Keyless.URL)\n\t\t\tfulcioroot, err := getFulcioCert(authority.Keyless.URL)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fetching FulcioRoot: %w\", err)\n\t\t\t}\n\t\t\tva, err := validAttestationsWithFulcio(ctx, ref, fulcioroot, rekorClient, authority.Keyless.Identities, remoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"failed validAttestationsWithFulcio for authority %s with fulcio for %s: %v\", name, ref.Name(), err)\n\t\t\t\treturn nil, fmt.Errorf(\"attestation keyless validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t\t}\n\t\t\tverifiedAttestations = append(verifiedAttestations, va...)\n\t\t}\n\t}\n\n\t// If we didn't get any verified attestations either from the Key or Keyless\n\t// path, then error out\n\tif len(verifiedAttestations) == 0 {\n\t\tlogging.FromContext(ctx).Errorf(\"no valid attestations found for authority %s for %s\", name, ref.Name())\n\t\treturn nil, fmt.Errorf(\"%w for authority %s for %s\", cosign.ErrNoMatchingAttestations, name, ref.Name())\n\t}\n\tlogging.FromContext(ctx).Debugf(\"Found %d valid attestations, validating policies for them\", len(verifiedAttestations))\n\n\t// Now spin through the Attestations that the user specified and validate\n\t// them.\n\t// TODO(vaikas): Pretty inefficient here, figure out a better way if\n\t// possible.\n\tret := make(map[string][]PolicySignature, len(authority.Attestations))\n\tfor _, wantedAttestation := range authority.Attestations {\n\t\t// If there's no type / policy to do more checking against,\n\t\t// then we're done here. It matches all the attestations\n\t\tif wantedAttestation.Type == \"\" {\n\t\t\tret[wantedAttestation.Name] = ociSignatureToPolicySignature(ctx, verifiedAttestations)\n\t\t\tcontinue\n\t\t}\n\t\t// There's a particular type, so we need to go through all the verified\n\t\t// attestations and make sure that our particular one is satisfied.\n\t\tfor _, va := range verifiedAttestations {\n\t\t\tattBytes, err := policy.AttestationToPayloadJSON(ctx, wantedAttestation.PredicateType, va)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to convert attestation payload to json: %w\", err)\n\t\t\t}\n\t\t\tif attBytes == nil {\n\t\t\t\t// This happens when we ask for a predicate type that this\n\t\t\t\t// attestation is not for. It's not an error, so we skip it.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err := policy.EvaluatePolicyAgainstJSON(ctx, wantedAttestation.Name, wantedAttestation.Type, wantedAttestation.Data, attBytes); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t// Ok, so this passed aok, jot it down to our result set as\n\t\t\t// verified attestation with the predicate type match\n\t\t\tret[wantedAttestation.Name] = ociSignatureToPolicySignature(ctx, verifiedAttestations)\n\t\t}\n\t}\n\treturn ret, nil\n}\n\n// ResolvePodScalable implements policyduckv1beta1.PodScalableValidator\nfunc (v *Validator) ResolvePodScalable(ctx context.Context, ps *policyduckv1beta1.PodScalable) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// if status is being updated\n\tif isDeletedOrStatusUpdate(ctx, ps.DeletionTimestamp) {\n\t\treturn\n\t}\n\n\tif ps.IsScalingDown(ctx) {\n\t\tlogging.FromContext(ctx).Debugf(\"Skipping validations due to scale down request %s/%s\", &ps.ObjectMeta.Name, &ps.ObjectMeta.Namespace)\n\t\treturn\n\t}\n\n\timagePullSecrets := make([]string, 0, len(ps.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range ps.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          ps.Namespace,\n\t\tServiceAccountName: ps.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &ps.Spec.Template.Spec, opt)\n}\n\n// ResolvePodSpecable implements duckv1.PodSpecValidator\nfunc (v *Validator) ResolvePodSpecable(ctx context.Context, wp *duckv1.WithPod) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// status update.\n\tif isDeletedOrStatusUpdate(ctx, wp.DeletionTimestamp) {\n\t\treturn\n\t}\n\n\timagePullSecrets := make([]string, 0, len(wp.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range wp.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          wp.Namespace,\n\t\tServiceAccountName: wp.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &wp.Spec.Template.Spec, opt)\n}\n\n// ResolvePod implements duckv1.PodValidator\nfunc (v *Validator) ResolvePod(ctx context.Context, p *duckv1.Pod) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// status update.\n\tif isDeletedOrStatusUpdate(ctx, p.DeletionTimestamp) {\n\t\treturn\n\t}\n\timagePullSecrets := make([]string, 0, len(p.Spec.ImagePullSecrets))\n\tfor _, s := range p.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          p.Namespace,\n\t\tServiceAccountName: p.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &p.Spec, opt)\n}\n\n// ResolveCronJob implements duckv1.CronJobValidator\nfunc (v *Validator) ResolveCronJob(ctx context.Context, c *duckv1.CronJob) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// status update.\n\tif isDeletedOrStatusUpdate(ctx, c.DeletionTimestamp) {\n\t\treturn\n\t}\n\n\timagePullSecrets := make([]string, 0, len(c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          c.Namespace,\n\t\tServiceAccountName: c.Spec.JobTemplate.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &c.Spec.JobTemplate.Spec.Template.Spec, opt)\n}\n\n// For testing\nvar remoteResolveDigest = ociremote.ResolveDigest\n\nfunc (v *Validator) resolvePodSpec(ctx context.Context, ps *corev1.PodSpec, opt k8schain.Options) {\n\tkc, err := k8schain.New(ctx, v.client, opt)\n\tif err != nil {\n\t\tlogging.FromContext(ctx).Warnf(\"Unable to build k8schain: %v\", err)\n\t\treturn\n\t}\n\n\tresolveContainers := func(cs []corev1.Container) {\n\t\tfor i, c := range cs {\n\t\t\tref, err := name.ParseReference(c.Image)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Debugf(\"Unable to parse reference: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If we are in the context of a mutating webhook, then resolve the tag to a digest.\n\t\t\tswitch {\n\t\t\tcase apis.IsInCreate(ctx), apis.IsInUpdate(ctx):\n\t\t\t\tdigest, err := remoteResolveDigest(ref, ociremote.WithRemoteOptions(remote.WithAuthFromKeychain(kc)))\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogging.FromContext(ctx).Debugf(\"Unable to resolve digest %q: %v\", ref.String(), err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcs[i].Image = digest.String()\n\t\t\t}\n\t\t}\n\t}\n\n\tresolveContainers(ps.InitContainers)\n\tresolveContainers(ps.Containers)\n}\n\nfunc getFulcioCert(u *apis.URL) (*x509.CertPool, error) {\n\tfClient := api.NewClient(u.URL())\n\trootCertResponse, err := fClient.RootCert()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"getting root cert: %w\", err)\n\t}\n\n\tcp := x509.NewCertPool()\n\tif !cp.AppendCertsFromPEM(rootCertResponse.ChainPEM) {\n\t\treturn nil, errors.New(\"error appending to root cert pool\")\n\t}\n\treturn cp, nil\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage webhook\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-containerregistry/pkg/authn/k8schain\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/policy-controller/pkg/apis/config\"\n\tpolicyduckv1beta1 \"github.com/sigstore/policy-controller/pkg/apis/duck/v1beta1\"\n\t\"github.com/sigstore/policy-controller/pkg/apis/policy/v1alpha1\"\n\twebhookcip \"github.com/sigstore/policy-controller/pkg/webhook/clusterimagepolicy\"\n\tbatchv1 \"k8s.io/api/batch/v1\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"knative.dev/pkg/apis\"\n\tduckv1 \"knative.dev/pkg/apis/duck/v1\"\n\tfakekube \"knative.dev/pkg/client/injection/kube/client/fake\"\n\tfakesecret \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret/fake\"\n\t\"knative.dev/pkg/ptr\"\n\trtesting \"knative.dev/pkg/reconciler/testing\"\n\t\"knative.dev/pkg/system\"\n)\n\nconst (\n\tfulcioRootCert = \"-----BEGIN CERTIFICATE-----\\nMIICNzCCAd2gAwIBAgITPLBoBQhl1hqFND9S+SGWbfzaRTAKBggqhkjOPQQDAjBo\\nMQswCQYDVQQGEwJVSzESMBAGA1UECBMJV2lsdHNoaXJlMRMwEQYDVQQHEwpDaGlw\\ncGVuaGFtMQ8wDQYDVQQKEwZSZWRIYXQxDDAKBgNVBAsTA0NUTzERMA8GA1UEAxMI\\ndGVzdGNlcnQwHhcNMjEwMzEyMjMyNDQ5WhcNMzEwMjI4MjMyNDQ5WjBoMQswCQYD\\nVQQGEwJVSzESMBAGA1UECBMJV2lsdHNoaXJlMRMwEQYDVQQHEwpDaGlwcGVuaGFt\\nMQ8wDQYDVQQKEwZSZWRIYXQxDDAKBgNVBAsTA0NUTzERMA8GA1UEAxMIdGVzdGNl\\ncnQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQRn+Alyof6xP3GQClSwgV0NFuY\\nYEwmKP/WLWr/LwB6LUYzt5v49RlqG83KuaJSpeOj7G7MVABdpIZYWwqAiZV3o2Yw\\nZDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBATAdBgNVHQ4EFgQU\\nT8Jwm6JuVb0dsiuHUROiHOOVHVkwHwYDVR0jBBgwFoAUT8Jwm6JuVb0dsiuHUROi\\nHOOVHVkwCgYIKoZIzj0EAwIDSAAwRQIhAJkNZmP6sKA+8EebRXFkBa9DPjacBpTc\\nOljJotvKidRhAiAuNrIazKEw2G4dw8x1z6EYk9G+7fJP5m93bjm/JfMBtA==\\n-----END CERTIFICATE-----\"\n\trekorResponse  = \"bad response\"\n\n\t// Random public key (cosign generate-key-pair) 2022-03-18\n\tauthorityKeyCosignPubString = `-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENAyijLvRu5QpCPp2uOj8C79ZW1VJ\nSID/4H61ZiRzN4nqONzp+ZF22qQTk3MFO3D0/ZKmWHAosIf2pf2GHH7myA==\n-----END PUBLIC KEY-----`\n)\n\nfunc TestValidatePodSpec(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\n\tsecretName := \"blah\"\n\n\t// Non-existent URL for testing complete failure\n\tbadURL := apis.HTTP(\"http://example.com/\")\n\n\t// Spin up a Fulcio that responds with a Root Cert\n\tfulcioServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(fulcioRootCert))\n\t}))\n\tt.Cleanup(fulcioServer.Close)\n\tfulcioURL, err := apis.ParseURL(fulcioServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Fulcio URL\")\n\t}\n\n\trekorServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(rekorResponse))\n\t}))\n\tt.Cleanup(rekorServer.Close)\n\trekorURL, err := apis.ParseURL(rekorServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Rekor URL\")\n\t}\n\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\t// Setup service acc and fakeSignaturePullSecrets for \"default\" and \"cosign-system\" namespace\n\tfor _, ns := range []string{\"default\", system.Namespace()} {\n\t\tkc.CoreV1().ServiceAccounts(ns).Create(ctx, &corev1.ServiceAccount{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName: \"default\",\n\t\t\t},\n\t\t}, metav1.CreateOptions{})\n\n\t\tkc.CoreV1().Secrets(ns).Create(ctx, &corev1.Secret{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName: \"fakeSignaturePullSecrets\",\n\t\t\t},\n\t\t\tData: map[string][]byte{\n\t\t\t\t\"dockerconfigjson\": []byte(`{\"auths\":{\"https://index.docker.io/v1/\":{\"username\":\"username\",\"password\":\"password\",\"auth\":\"dXNlcm5hbWU6cGFzc3dvcmQ=\"}}`),\n\t\t\t},\n\t\t}, metav1.CreateOptions{})\n\t}\n\n\tv := NewValidator(ctx, secretName)\n\n\tcvs := cosignVerifySignatures\n\tdefer func() {\n\t\tcosignVerifySignatures = cvs\n\t}()\n\t// Let's just say that everything is verified.\n\tpass := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tsig, err := static.NewSignature(nil, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is not verified.\n\tfail := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\treturn nil, false, errors.New(\"bad signature\")\n\t}\n\n\t// Let's say it is verified if it is the expected Public Key\n\tauthorityPublicKeyCVS := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tactualPublicKey, _ := co.SigVerifier.PublicKey()\n\t\tactualECDSAPubkey := actualPublicKey.(*ecdsa.PublicKey)\n\t\tactualKeyData := elliptic.Marshal(actualECDSAPubkey, actualECDSAPubkey.X, actualECDSAPubkey.Y)\n\n\t\texpectedKeyData := elliptic.Marshal(authorityKeyCosignPub, authorityKeyCosignPub.X, authorityKeyCosignPub.Y)\n\n\t\tif bytes.Equal(actualKeyData, expectedKeyData) {\n\t\t\treturn pass(ctx, signedImgRef, co)\n\t\t}\n\n\t\treturn fail(ctx, signedImgRef, co)\n\t}\n\n\ttests := []struct {\n\t\tname          string\n\t\tps            *corev1.PodSpec\n\t\twant          *apis.FieldError\n\t\tcvs           func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t\tcustomContext context.Context\n\t}{{\n\t\tname: \"simple, no error\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"bad reference\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: \"in@valid\",\n\t\t\t}},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `could not parse reference: in@valid`,\n\t\t\tPaths:   []string{\"containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"not digest\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `invalid value: gcr.io/distroless/static:nonroot must be an image digest`,\n\t\t\tPaths:   []string{\"containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"bad signature\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `bad signature`,\n\t\t\tPaths:   []string{\"containers[0].image\"},\n\t\t\tDetails: digest.String(),\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, no error, authority key\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\t\t\t\t\t\tData:       authorityKeyCosignPubString,\n\t\t\t\t\t\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tcvs: authorityPublicKeyCVS,\n\t}, {\n\t\tname: \"simple, error, authority keyless, bad fulcio\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: badURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s %s\", digest.String(), `fetching FulcioRoot: getting root cert: parse \"http://http:%2F%2Fexample.com%2F/api/v1/rootCert\": invalid port \":%2F%2Fexample.com%2F\" after host`)\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s %s\", digest.String(), `fetching FulcioRoot: getting root cert: parse \"http://http:%2F%2Fexample.com%2F/api/v1/rootCert\": invalid port \":%2F%2Fexample.com%2F\" after host`)\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, error, authority keyless, good fulcio, no rekor\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, authority keyless checks out, good fulcio, bad cip policy\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless-bad-cip\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPolicy: &webhookcip.AttestationPolicy{\n\t\t\t\t\t\t\t\tName: \"invalid json policy\",\n\t\t\t\t\t\t\t\tType: \"cue\",\n\t\t\t\t\t\t\t\tData: `{\"wontgo`,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless-bad-cip\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s failed evaluating cue policy for ClusterImagePolicy: failed to compile the cue policy with error: string literal not terminated\", digest.String())\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless-bad-cip\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s failed evaluating cue policy for ClusterImagePolicy: failed to compile the cue policy with error: string literal not terminated\", digest.String())\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"simple, no error, authority keyless, good fulcio\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"simple, error, authority keyless, good fulcio, bad rekor\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCTLog: &v1alpha1.TLog{\n\t\t\t\t\t\t\t\t\t\tURL: rekorURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, error, authority source signaturePullSecrets, non existing secret\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(ctx,\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\t\t\t\t\t\tData:       authorityKeyCosignPubString,\n\t\t\t\t\t\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSources: []v1alpha1.Source{{\n\t\t\t\t\t\t\t\t\t\tOCI: \"example.com/alternative/signature\",\n\t\t\t\t\t\t\t\t\t\tSignaturePullSecrets: []corev1.LocalObjectReference{{\n\t\t\t\t\t\t\t\t\t\t\tName: \"non-existing-secret\",\n\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s secrets \\\"non-existing-secret\\\" not found\", digest.String())\n\t\t\terrs = errs.Also(fe)\n\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s secrets \\\"non-existing-secret\\\" not found\", digest.String())\n\t\t\terrs = errs.Also(fe2)\n\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, no error, authority source signaturePullSecrets, valid secret\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(ctx,\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\t\t\t\t\t\tData:       authorityKeyCosignPubString,\n\t\t\t\t\t\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSources: []v1alpha1.Source{{\n\t\t\t\t\t\t\t\t\t\tOCI: \"example.com/alternative/signature\",\n\t\t\t\t\t\t\t\t\t\tSignaturePullSecrets: []corev1.LocalObjectReference{{\n\t\t\t\t\t\t\t\t\t\t\tName: \"fakeSignaturePullSecrets\",\n\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tcvs: authorityPublicKeyCVS,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcosignVerifySignatures = test.cvs\n\t\t\ttestContext := context.Background()\n\n\t\t\tif test.customContext != nil {\n\t\t\t\ttestContext = test.customContext\n\t\t\t}\n\n\t\t\t// Check the core mechanics\n\t\t\tgot := v.validatePodSpec(testContext, system.Namespace(), test.ps, k8schain.Options{})\n\t\t\tif (got != nil) != (test.want != nil) {\n\t\t\t\tt.Errorf(\"validatePodSpec() = %v, wanted %v\", got, test.want)\n\t\t\t} else if got != nil && got.Error() != test.want.Error() {\n\t\t\t\tt.Errorf(\"validatePodSpec() = %v, wanted %v\", got, test.want)\n\t\t\t}\n\n\t\t\t// Check wrapped in a Pod\n\t\t\tpod := &duckv1.Pod{\n\t\t\t\tSpec: *test.ps,\n\t\t\t}\n\t\t\tgot = v.ValidatePod(testContext, pod)\n\t\t\twant := test.want.ViaField(\"spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePod() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePod() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tif got := v.ValidatePod(apis.WithinDelete(testContext), pod); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePod() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check wrapped in a WithPod\n\t\t\twithPod := &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tgot = v.ValidatePodSpecable(testContext, withPod)\n\t\t\twant = test.want.ViaField(\"spec.template.spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tif got := v.ValidatePodSpecable(apis.WithinDelete(testContext), withPod); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check wrapped in a podScalable\n\t\t\tpodScalable := &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tgot = v.ValidatePodScalable(testContext, podScalable)\n\t\t\twant = test.want.ViaField(\"spec.template.spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tif got := v.ValidatePodScalable(apis.WithinDelete(testContext), podScalable); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check that we don't block things being scaled down.\n\t\t\toriginal := podScalable.DeepCopy()\n\t\t\toriginal.Spec.Replicas = ptr.Int32(4)\n\t\t\tif got := v.ValidatePodScalable(apis.WithinUpdate(testContext, original), podScalable); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check that we fail as expected if being scaled up.\n\t\t\toriginal.Spec.Replicas = ptr.Int32(2)\n\t\t\tgot = v.ValidatePodScalable(apis.WithinUpdate(testContext, original), podScalable)\n\t\t\twant = test.want.ViaField(\"spec.template.spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateCronJob(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\n\tsecretName := \"blah\"\n\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// No data should make us verify against Fulcio.\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\tkc.CoreV1().ServiceAccounts(\"default\").Create(ctx, &corev1.ServiceAccount{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"default\",\n\t\t},\n\t}, metav1.CreateOptions{})\n\n\tv := NewValidator(ctx, secretName)\n\n\tcvs := cosignVerifySignatures\n\tdefer func() {\n\t\tcosignVerifySignatures = cvs\n\t}()\n\t// Let's just say that everything is verified.\n\tpass := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tsig, err := static.NewSignature(nil, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is not verified.\n\tfail := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\treturn nil, false, errors.New(\"bad signature\")\n\t}\n\n\ttests := []struct {\n\t\tname string\n\t\tc    *duckv1.CronJob\n\t\twant *apis.FieldError\n\t\tcvs  func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t}{{\n\t\tname: \"simple, no error\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"k8schain error (bad service account)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tServiceAccountName: \"not-found\",\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `serviceaccounts \"not-found\" not found`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec\"},\n\t\t},\n\t}, {\n\t\tname: \"k8schain error (bad pull secret)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tImagePullSecrets: []corev1.LocalObjectReference{{\n\t\t\t\t\t\t\t\t\tName: \"not-found\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `secrets \"not-found\" not found`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec\"},\n\t\t},\n\t}, {\n\t\tname: \"bad reference\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `could not parse reference: in@valid`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec.containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"not digest\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `invalid value: gcr.io/distroless/static:nonroot must be an image digest`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec.containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"bad signature\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `bad signature`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec.containers[0].image\"},\n\t\t\tDetails: digest.String(),\n\t\t},\n\t\tcvs: fail,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcosignVerifySignatures = test.cvs\n\n\t\t\t// Check the core mechanics\n\t\t\tgot := v.ValidateCronJob(context.Background(), test.c)\n\t\t\tif (got != nil) != (test.want != nil) {\n\t\t\t\tt.Errorf(\"validateCronJob() = %v, wanted %v\", got, test.want)\n\t\t\t} else if got != nil && got.Error() != test.want.Error() {\n\t\t\t\tt.Errorf(\"validateCronJob() = %v, wanted %v\", got, test.want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tcronJob := test.c.DeepCopy()\n\t\t\tif got := v.ValidateCronJob(apis.WithinDelete(context.Background()), cronJob); got != nil {\n\t\t\t\tt.Errorf(\"ValidateCronJob() = %v, wanted nil\", got)\n\t\t\t}\n\t\t\t// Check that we don't block things already deleted.\n\t\t\tcronJob = test.c.DeepCopy()\n\t\t\tcronJob.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\tif got := v.ValidateCronJob(context.Background(), cronJob); got != nil {\n\t\t\t\tt.Errorf(\"ValidateCronJob() = %v, wanted nil\", got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResolvePodSpec(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\tsecretName := \"blah\"\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\tkc.CoreV1().ServiceAccounts(\"default\").Create(ctx, &corev1.ServiceAccount{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"default\",\n\t\t},\n\t}, metav1.CreateOptions{})\n\n\tv := NewValidator(ctx, secretName)\n\n\trrd := remoteResolveDigest\n\tdefer func() {\n\t\tremoteResolveDigest = rrd\n\t}()\n\tresolve := func(ref name.Reference, opts ...remote.Option) (name.Digest, error) {\n\t\treturn digest.(name.Digest), nil\n\t}\n\n\ttests := []struct {\n\t\tname string\n\t\tps   *corev1.PodSpec\n\t\twant *corev1.PodSpec\n\t\twc   func(context.Context) context.Context\n\t\trrd  func(name.Reference, ...remote.Option) (name.Digest, error)\n\t}{{\n\t\tname: \"nothing changed (not the right update)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (bad reference)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: \"in@valid\",\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: \"in@valid\",\n\t\t\t}},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (unable to resolve)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twc: apis.WithinCreate,\n\t\trrd: func(r name.Reference, o ...remote.Option) (name.Digest, error) {\n\t\t\treturn name.Digest{}, errors.New(\"boom\")\n\t\t},\n\t}, {\n\t\tname: \"digests resolve (in create)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tremoteResolveDigest = test.rrd\n\t\t\tctx := context.Background()\n\t\t\tif test.wc != nil {\n\t\t\t\tctx = test.wc(context.Background())\n\t\t\t}\n\n\t\t\t// Check the core mechanics.\n\t\t\tgot := test.ps.DeepCopy()\n\t\t\tv.resolvePodSpec(ctx, got, k8schain.Options{})\n\t\t\tif !cmp.Equal(got, test.want) {\n\t\t\t\tt.Errorf(\"resolvePodSpec = %s\", cmp.Diff(got, test.want))\n\t\t\t}\n\n\t\t\tvar want runtime.Object\n\n\t\t\t// Check wrapped in a Pod\n\t\t\tpod := &duckv1.Pod{Spec: *test.ps.DeepCopy()}\n\t\t\twant = &duckv1.Pod{Spec: *test.want.DeepCopy()}\n\t\t\tv.ResolvePod(ctx, pod)\n\t\t\tif !cmp.Equal(pod, want) {\n\t\t\t\tt.Errorf(\"ResolvePod = %s\", cmp.Diff(pod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\tpod = &duckv1.Pod{Spec: *test.ps.DeepCopy()}\n\t\t\twant = pod.DeepCopy()\n\t\t\tv.ResolvePod(apis.WithinDelete(ctx), pod)\n\t\t\tif !cmp.Equal(pod, want) {\n\t\t\t\tt.Errorf(\"ResolvePod = %s\", cmp.Diff(pod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's already deleted.\n\t\t\tpod = &duckv1.Pod{Spec: *test.ps.DeepCopy()}\n\t\t\tpod.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\twant = pod.DeepCopy()\n\t\t\tv.ResolvePod(ctx, pod)\n\t\t\tif !cmp.Equal(pod, want) {\n\t\t\t\tt.Errorf(\"ResolvePod = %s\", cmp.Diff(pod, want))\n\t\t\t}\n\n\t\t\t// Check wrapped in a WithPod\n\t\t\twithPod := &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.want.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tv.ResolvePodSpecable(ctx, withPod)\n\t\t\tif !cmp.Equal(withPod, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(withPod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\twithPod = &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = withPod.DeepCopy()\n\t\t\tv.ResolvePodSpecable(apis.WithinDelete(ctx), withPod)\n\t\t\tif !cmp.Equal(withPod, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(withPod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's already deleted.\n\t\t\twithPod = &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twithPod.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\twant = withPod.DeepCopy()\n\t\t\tv.ResolvePodSpecable(ctx, withPod)\n\t\t\tif !cmp.Equal(withPod, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(withPod, want))\n\t\t\t}\n\n\t\t\t// Check wrapped in a PodScalable\n\t\t\tpodScalable := &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.want.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tv.ResolvePodScalable(ctx, podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\tpodScalable = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(2),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = podScalable.DeepCopy()\n\t\t\tv.ResolvePodScalable(apis.WithinDelete(ctx), podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's already deleted.\n\t\t\tpodScalable = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(2),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tpodScalable.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\twant = podScalable.DeepCopy()\n\t\t\tv.ResolvePodScalable(ctx, podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being scaled down.\n\t\t\tpodScalable = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(2),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = podScalable.DeepCopy()\n\t\t\toriginal := &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tv.ResolvePodScalable(apis.WithinUpdate(ctx, original), podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResolveCronJob(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\tsecretName := \"blah\"\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\tkc.CoreV1().ServiceAccounts(\"default\").Create(ctx, &corev1.ServiceAccount{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"default\",\n\t\t},\n\t}, metav1.CreateOptions{})\n\n\tv := NewValidator(ctx, secretName)\n\n\trrd := remoteResolveDigest\n\tdefer func() {\n\t\tremoteResolveDigest = rrd\n\t}()\n\tresolve := func(ref name.Reference, opts ...remote.Option) (name.Digest, error) {\n\t\treturn digest.(name.Digest), nil\n\t}\n\n\ttests := []struct {\n\t\tname string\n\t\tc    *duckv1.CronJob\n\t\twant *duckv1.CronJob\n\t\twc   func(context.Context) context.Context\n\t\trrd  func(name.Reference, ...remote.Option) (name.Digest, error)\n\t}{{\n\t\tname: \"nothing changed (not the right update)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (bad reference)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (unable to resolve)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twc: apis.WithinCreate,\n\t\trrd: func(r name.Reference, o ...remote.Option) (name.Digest, error) {\n\t\t\treturn name.Digest{}, errors.New(\"boom\")\n\t\t},\n\t}, {\n\t\tname: \"digests resolve (in create)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tremoteResolveDigest = test.rrd\n\t\t\tctx := context.Background()\n\t\t\tif test.wc != nil {\n\t\t\t\tctx = test.wc(context.Background())\n\t\t\t}\n\n\t\t\tvar want runtime.Object\n\n\t\t\tcronJob := test.c.DeepCopy()\n\t\t\twant = test.want.DeepCopy()\n\t\t\tv.ResolveCronJob(ctx, cronJob)\n\t\t\tif !cmp.Equal(cronJob, want) {\n\t\t\t\tt.Errorf(\"ResolveCronJob = %s\", cmp.Diff(cronJob, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\tcronJob = test.c.DeepCopy()\n\t\t\twant = cronJob.DeepCopy()\n\t\t\tv.ResolveCronJob(apis.WithinDelete(ctx), cronJob)\n\t\t\tif !cmp.Equal(cronJob, want) {\n\t\t\t\tt.Errorf(\"ResolveCronJob = %s\", cmp.Diff(cronJob, want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidatePolicy(t *testing.T) {\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\n\tsecretName := \"blah\"\n\n\t// Non-existent URL for testing complete failure\n\tbadURL := apis.HTTP(\"http://example.com/\")\n\tt.Logf(\"badURL: %s\", badURL.String())\n\n\t// Spin up a Fulcio that responds with a Root Cert\n\tfulcioServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(fulcioRootCert))\n\t}))\n\tt.Cleanup(fulcioServer.Close)\n\tfulcioURL, err := apis.ParseURL(fulcioServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Fulcio URL\")\n\t}\n\tt.Logf(\"fulcioURL: %s\", fulcioURL.String())\n\n\trekorServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(rekorResponse))\n\t}))\n\tt.Cleanup(rekorServer.Close)\n\trekorURL, err := apis.ParseURL(rekorServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Rekor URL\")\n\t}\n\tt.Logf(\"rekorURL: %s\", rekorURL.String())\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tcvs := cosignVerifySignatures\n\tdefer func() {\n\t\tcosignVerifySignatures = cvs\n\t}()\n\t// Let's just say that everything is verified.\n\tpass := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tsig, err := static.NewSignature(nil, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is verified.\n\tpassKeyless := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\t// This is from 2022/07/29\n\t\t// ghcr.io/distroless/static@sha256:a1e82f6a5f6dfc735165d3442e7cc5a615f72abac3db19452481f5f3c90fbfa8\n\t\tpayload := []byte(`{\"critical\":{\"identity\":{\"docker-reference\":\"ghcr.io/distroless/static\"},\"image\":{\"docker-manifest-digest\":\"sha256:a1e82f6a5f6dfc735165d3442e7cc5a615f72abac3db19452481f5f3c90fbfa8\"},\"type\":\"cosign container image signature\"},\"optional\":{\"run_attempt\":\"1\",\"run_id\":\"2757953139\",\"sha\":\"7e7572e578de7c51a2f1a1791f025cf315503aa2\"}}`)\n\t\tb64sig := \"MEUCIAmudMKGDWEpufGGqrMgeei7KVdpZwhc6clqMaMaw6lyAiEA3JnLUqV3wtKDERcVy8OjMGopJY7IZ8lfks5zEAjlnW0=\"\n\t\tset, err := base64.StdEncoding.DecodeString(\"MEUCIAOMBR9Gh7laJtdvU9+JqK/AiTps8/tzviDzkvfMQqn4AiEAs553xG1bvlIu3aGERoPRf+oR3MfZTIM9M4nQrGeW8D4=\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\tsig, err := static.NewSignature(payload, b64sig, static.WithCertChain(\n\t\t\t[]byte(\"-----BEGIN CERTIFICATE-----\\nMIIDnDCCAyKgAwIBAgIUfMlmBH82a8tub3Mzzv8DBUEjLHwwCgYIKoZIzj0EAwMw\\nNzEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MR4wHAYDVQQDExVzaWdzdG9yZS1pbnRl\\ncm1lZGlhdGUwHhcNMjIwNzI5MDIyNzEzWhcNMjIwNzI5MDIzNzEzWjAAMFkwEwYH\\nKoZIzj0CAQYIKoZIzj0DAQcDQgAEPL3MZbQBWha+4lgvmbZ4JA7BgxcAOcWTq+Ns\\nGgKVhhodbDucZp5JLVRn+QWrEG+Ppd4JzLoAZth2a0BhNlkGC6OCAkEwggI9MA4G\\nA1UdDwEB/wQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQU3yHz\\nvrj7CsZsIsI87Ps9XUXd7+0wHwYDVR0jBBgwFoAU39Ppz1YkEZb5qNjpKFWixi4Y\\nZD8wYQYDVR0RAQH/BFcwVYZTaHR0cHM6Ly9naXRodWIuY29tL2Rpc3Ryb2xlc3Mv\\nc3RhdGljLy5naXRodWIvd29ya2Zsb3dzL3JlbGVhc2UueWFtbEByZWZzL2hlYWRz\\nL21haW4wOQYKKwYBBAGDvzABAQQraHR0cHM6Ly90b2tlbi5hY3Rpb25zLmdpdGh1\\nYnVzZXJjb250ZW50LmNvbTAWBgorBgEEAYO/MAECBAhzY2hlZHVsZTA2BgorBgEE\\nAYO/MAEDBCg3ZTc1NzJlNTc4ZGU3YzUxYTJmMWExNzkxZjAyNWNmMzE1NTAzYWEy\\nMBwGCisGAQQBg78wAQQEDkNyZWF0ZSBSZWxlYXNlMB8GCisGAQQBg78wAQUEEWRp\\nc3Ryb2xlc3Mvc3RhdGljMB0GCisGAQQBg78wAQYED3JlZnMvaGVhZHMvbWFpbjCB\\niQYKKwYBBAHWeQIEAgR7BHkAdwB1AAhgkvAoUv9oRdHRayeEnEVnGKwWPcM40m3m\\nvCIGNm9yAAABgkfHgcEAAAQDAEYwRAIgZteRlFRR3aLNH6RlF3iknW4BfQXwsIWP\\nRnkEOzOlN4MCIBQShlTxp2JJ677LTbFBU30zHLOZfQCa/qj5kpiFDPn6MAoGCCqG\\nSM49BAMDA2gAMGUCMQDG7KFCngua3Nn5C20np9DiSnw74v7/xjbhFBoWQj1m0pio\\nbSbh3ihNMR5neANay6ECMFwFsGFHCeLlL9kmf5ONk2EAZWQuwdJONPvXlbC/28KE\\na7sPOJxVkCUQMdvqf1KBTw==\\n-----END CERTIFICATE-----\\n\"),\n\t\t\t[]byte(\"-----BEGIN CERTIFICATE-----\\nMIICGjCCAaGgAwIBAgIUALnViVfnU0brJasmRkHrn/UnfaQwCgYIKoZIzj0EAwMw\\nKjEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MREwDwYDVQQDEwhzaWdzdG9yZTAeFw0y\\nMjA0MTMyMDA2MTVaFw0zMTEwMDUxMzU2NThaMDcxFTATBgNVBAoTDHNpZ3N0b3Jl\\nLmRldjEeMBwGA1UEAxMVc2lnc3RvcmUtaW50ZXJtZWRpYXRlMHYwEAYHKoZIzj0C\\nAQYFK4EEACIDYgAE8RVS/ysH+NOvuDZyPIZtilgUF9NlarYpAd9HP1vBBH1U5CV7\\n7LSS7s0ZiH4nE7Hv7ptS6LvvR/STk798LVgMzLlJ4HeIfF3tHSaexLcYpSASr1kS\\n0N/RgBJz/9jWCiXno3sweTAOBgNVHQ8BAf8EBAMCAQYwEwYDVR0lBAwwCgYIKwYB\\nBQUHAwMwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU39Ppz1YkEZb5qNjp\\nKFWixi4YZD8wHwYDVR0jBBgwFoAUWMAeX5FFpWapesyQoZMi0CrFxfowCgYIKoZI\\nzj0EAwMDZwAwZAIwPCsQK4DYiZYDPIaDi5HFKnfxXx6ASSVmERfsynYBiX2X6SJR\\nnZU84/9DZdnFvvxmAjBOt6QpBlc4J/0DxvkTCqpclvziL6BCCPnjdlIB3Pu3BxsP\\nmygUY7Ii2zbdCdliiow=\\n-----END CERTIFICATE-----\\n-----BEGIN CERTIFICATE-----\\nMIIB9zCCAXygAwIBAgIUALZNAPFdxHPwjeDloDwyYChAO/4wCgYIKoZIzj0EAwMw\\nKjEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MREwDwYDVQQDEwhzaWdzdG9yZTAeFw0y\\nMTEwMDcxMzU2NTlaFw0zMTEwMDUxMzU2NThaMCoxFTATBgNVBAoTDHNpZ3N0b3Jl\\nLmRldjERMA8GA1UEAxMIc2lnc3RvcmUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAT7\\nXeFT4rb3PQGwS4IajtLk3/OlnpgangaBclYpsYBr5i+4ynB07ceb3LP0OIOZdxex\\nX69c5iVuyJRQ+Hz05yi+UF3uBWAlHpiS5sh0+H2GHE7SXrk1EC5m1Tr19L9gg92j\\nYzBhMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRY\\nwB5fkUWlZql6zJChkyLQKsXF+jAfBgNVHSMEGDAWgBRYwB5fkUWlZql6zJChkyLQ\\nKsXF+jAKBggqhkjOPQQDAwNpADBmAjEAj1nHeXZp+13NWBNa+EDsDP8G1WWg1tCM\\nWP/WHPqpaVo0jhsweNFZgSs0eE7wYI4qAjEA2WB9ot98sIkoF3vZYdd3/VtWB5b9\\nTNMea7Ix/stJ5TfcLLeABLE4BNJOsQ4vnBHJ\\n-----END CERTIFICATE-----\"),\n\t\t), static.WithBundle(&bundle.RekorBundle{\n\t\t\tSignedEntryTimestamp: set,\n\t\t\tPayload: bundle.RekorPayload{\n\t\t\t\tBody:           \"eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiJjYzYxZDc4MzdmYWYzYmMyYjMxMThkNTUxZmY5NTJjYzU5NzljNzM3OTkwNGE4NDEwMzAxMDg3OGVlMmZjMDUwIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FVUNJQW11ZE1LR0RXRXB1ZkdHcXJNZ2VlaTdLVmRwWndoYzZjbHFNYU1hdzZseUFpRUEzSm5MVXFWM3d0S0RFUmNWeThPak1Hb3BKWTdJWjhsZmtzNXpFQWpsblcwPSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2sxSlNVUnVSRU5EUVhsTFowRjNTVUpCWjBsVlprMXNiVUpJT0RKaE9IUjFZak5OZW5wMk9FUkNWVVZxVEVoM2QwTm5XVWxMYjFwSmVtb3dSVUYzVFhjS1RucEZWazFDVFVkQk1WVkZRMmhOVFdNeWJHNWpNMUoyWTIxVmRWcEhWakpOVWpSM1NFRlpSRlpSVVVSRmVGWjZZVmRrZW1SSE9YbGFVekZ3WW01U2JBcGpiVEZzV2tkc2FHUkhWWGRJYUdOT1RXcEpkMDU2U1RWTlJFbDVUbnBGZWxkb1kwNU5ha2wzVG5wSk5VMUVTWHBPZWtWNlYycEJRVTFHYTNkRmQxbElDa3R2V2tsNmFqQkRRVkZaU1V0dldrbDZhakJFUVZGalJGRm5RVVZRVEROTldtSlJRbGRvWVNzMGJHZDJiV0phTkVwQk4wSm5lR05CVDJOWFZIRXJUbk1LUjJkTFZtaG9iMlJpUkhWalduQTFTa3hXVW00clVWZHlSVWNyVUhCa05FcDZURzlCV25Sb01tRXdRbWhPYkd0SFF6WlBRMEZyUlhkblowazVUVUUwUndwQk1WVmtSSGRGUWk5M1VVVkJkMGxJWjBSQlZFSm5UbFpJVTFWRlJFUkJTMEpuWjNKQ1owVkdRbEZqUkVGNlFXUkNaMDVXU0ZFMFJVWm5VVlV6ZVVoNkNuWnlhamREYzFwelNYTkpPRGRRY3psWVZWaGtOeXN3ZDBoM1dVUldVakJxUWtKbmQwWnZRVlV6T1ZCd2VqRlphMFZhWWpWeFRtcHdTMFpYYVhocE5Ga0tXa1E0ZDFsUldVUldVakJTUVZGSUwwSkdZM2RXV1ZwVVlVaFNNR05JVFRaTWVUbHVZVmhTYjJSWFNYVlpNamwwVERKU2NHTXpVbmxpTW5oc1l6Tk5kZ3BqTTFKb1pFZHNha3g1Tlc1aFdGSnZaRmRKZG1ReU9YbGhNbHB6WWpOa2Vrd3pTbXhpUjFab1l6SlZkV1ZYUm5SaVJVSjVXbGRhZWt3eWFHeFpWMUo2Q2t3eU1XaGhWelIzVDFGWlMwdDNXVUpDUVVkRWRucEJRa0ZSVVhKaFNGSXdZMGhOTmt4NU9UQmlNblJzWW1rMWFGa3pVbkJpTWpWNlRHMWtjR1JIYURFS1dXNVdlbHBZU21waU1qVXdXbGMxTUV4dFRuWmlWRUZYUW1kdmNrSm5SVVZCV1U4dlRVRkZRMEpCYUhwWk1taHNXa2hXYzFwVVFUSkNaMjl5UW1kRlJRcEJXVTh2VFVGRlJFSkRaek5hVkdNeFRucEtiRTVVWXpSYVIxVXpXWHBWZUZsVVNtMU5WMFY0VG5wcmVGcHFRWGxPVjA1dFRYcEZNVTVVUVhwWlYwVjVDazFDZDBkRGFYTkhRVkZSUW1jM09IZEJVVkZGUkd0T2VWcFhSakJhVTBKVFdsZDRiRmxZVG14TlFqaEhRMmx6UjBGUlVVSm5OemgzUVZGVlJVVlhVbkFLWXpOU2VXSXllR3hqTTAxMll6TlNhR1JIYkdwTlFqQkhRMmx6UjBGUlVVSm5OemgzUVZGWlJVUXpTbXhhYmsxMllVZFdhRnBJVFhaaVYwWndZbXBEUWdwcFVWbExTM2RaUWtKQlNGZGxVVWxGUVdkU04wSklhMEZrZDBJeFFVRm9aMnQyUVc5VmRqbHZVbVJJVW1GNVpVVnVSVlp1UjB0M1YxQmpUVFF3YlROdENuWkRTVWRPYlRsNVFVRkJRbWRyWmtoblkwVkJRVUZSUkVGRldYZFNRVWxuV25SbFVteEdVbEl6WVV4T1NEWlNiRVl6YVd0dVZ6UkNabEZZZDNOSlYxQUtVbTVyUlU5NlQyeE9ORTFEU1VKUlUyaHNWSGh3TWtwS05qYzNURlJpUmtKVk16QjZTRXhQV21aUlEyRXZjV28xYTNCcFJrUlFialpOUVc5SFEwTnhSd3BUVFRRNVFrRk5SRUV5WjBGTlIxVkRUVkZFUnpkTFJrTnVaM1ZoTTA1dU5VTXlNRzV3T1VScFUyNTNOelIyTnk5NGFtSm9Sa0p2VjFGcU1XMHdjR2x2Q21KVFltZ3phV2hPVFZJMWJtVkJUbUY1TmtWRFRVWjNSbk5IUmtoRFpVeHNURGxyYldZMVQwNXJNa1ZCV2xkUmRYZGtTazlPVUhaWWJHSkRMekk0UzBVS1lUZHpVRTlLZUZaclExVlJUV1IyY1dZeFMwSlVkejA5Q2kwdExTMHRSVTVFSUVORlVsUkpSa2xEUVZSRkxTMHRMUzBLIn19fX0=\",\n\t\t\t\tIntegratedTime: 1659061655,\n\t\t\t\tLogIndex:       3059462,\n\t\t\t\tLogID:          \"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d\",\n\t\t\t},\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is not verified.\n\tfail := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\treturn nil, false, errors.New(\"bad signature\")\n\t}\n\n\t// Let's say it is verified if it is the expected Public Key\n\tauthorityPublicKeyCVS := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tactualPublicKey, _ := co.SigVerifier.PublicKey()\n\t\tactualECDSAPubkey := actualPublicKey.(*ecdsa.PublicKey)\n\t\tactualKeyData := elliptic.Marshal(actualECDSAPubkey, actualECDSAPubkey.X, actualECDSAPubkey.Y)\n\n\t\texpectedKeyData := elliptic.Marshal(authorityKeyCosignPub, authorityKeyCosignPub.X, authorityKeyCosignPub.Y)\n\n\t\tif bytes.Equal(actualKeyData, expectedKeyData) {\n\t\t\treturn pass(ctx, signedImgRef, co)\n\t\t}\n\n\t\treturn fail(ctx, signedImgRef, co)\n\t}\n\n\ttests := []struct {\n\t\tname          string\n\t\tpolicy        webhookcip.ClusterImagePolicy\n\t\twant          *PolicyResult\n\t\twantErrs      []string\n\t\tcva           func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t\tcvs           func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t\tcustomContext context.Context\n\t}{{\n\t\tname: \"simple, public key, no matches\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twantErrs: []string{\"key validation failed for authority authority-0 for gcr.io/distroless/static@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4: bad signature\"},\n\t\tcvs:      fail,\n\t}, {\n\t\tname: \"simple, public key, works\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tSignatures: []PolicySignature{{\n\t\t\t\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t},\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"simple, public key and keyless, one works, one doesn't\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tName: \"authority-1\",\n\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\tURL: badURL,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tSignatures: []PolicySignature{{\n\t\t\t\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t},\n\t\twantErrs: []string{`fetching FulcioRoot: getting root cert: parse \"http://http:%2F%2Fexample.com%2F/api/v1/rootCert\": invalid port \":%2F%2Fexample.com%2F\" after host`},\n\t\tcvs:      authorityPublicKeyCVS,\n\t}, {\n\t\tname: \"simple, static set to pass\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tStatic: &webhookcip.StaticRef{\n\t\t\t\t\tAction: \"pass\",\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tStatic: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"simple, static set to fail\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tStatic: &webhookcip.StaticRef{\n\t\t\t\t\tAction: \"fail\",\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twantErrs: []string{\"disallowed by static policy\"},\n\t}, {\n\t\tname: \"simple, public key, no error\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tSignatures: []PolicySignature{{\n\t\t\t\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t},\n\t\tcvs: authorityPublicKeyCVS,\n\t}, {\n\t\tname: \"simple, keyless attestation, works\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t},\n\t\t\t\tAttestations: []webhookcip.AttestationPolicy{{\n\t\t\t\t\tName:          \"test-att\",\n\t\t\t\t\tPredicateType: \"custom\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tAttestations: map[string][]PolicySignature{\n\t\t\t\t\t\t\"test-att\": {{\n\t\t\t\t\t\t\tSubject: \"https://github.com/distroless/static/.github/workflows/release.yaml@refs/heads/main\",\n\t\t\t\t\t\t\tIssuer:  \"https://token.actions.githubusercontent.com\",\n\t\t\t\t\t\t\tGithubExtensions: GithubExtensions{\n\t\t\t\t\t\t\t\tWorkflowTrigger: \"schedule\",\n\t\t\t\t\t\t\t\tWorkflowSHA:     \"7e7572e578de7c51a2f1a1791f025cf315503aa2\",\n\t\t\t\t\t\t\t\tWorkflowName:    \"Create Release\",\n\t\t\t\t\t\t\t\tWorkflowRepo:    \"distroless/static\",\n\t\t\t\t\t\t\t\tWorkflowRef:     \"refs/heads/main\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcva: passKeyless,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcosignVerifySignatures = test.cvs\n\t\t\tcosignVerifyAttestations = test.cva\n\t\t\ttestContext := context.Background()\n\n\t\t\tif test.customContext != nil {\n\t\t\t\ttestContext = test.customContext\n\t\t\t}\n\t\t\tgot, gotErrs := ValidatePolicy(testContext, system.Namespace(), digest, test.policy)\n\t\t\tvalidateErrors(t, test.wantErrs, gotErrs)\n\t\t\tif !reflect.DeepEqual(test.want, got) {\n\t\t\t\tt.Errorf(\"unexpected PolicyResult, want: %+v got: %+v\", test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc validateErrors(t *testing.T, wantErr []string, got []error) {\n\tt.Helper()\n\tif len(wantErr) != len(got) {\n\t\tt.Errorf(\"Wanted %d errors got %d\", len(wantErr), len(got))\n\t} else {\n\t\tfor i, want := range wantErr {\n\t\t\tif !strings.Contains(got[i].Error(), want) {\n\t\t\t\tt.Errorf(\"Unwanted error at %d want: %s got: %s\", i, want, got[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestValidatePolicyCancelled(t *testing.T) {\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\ttestContext, cancelFunc := context.WithCancel(context.Background())\n\tcip := webhookcip.ClusterImagePolicy{\n\t\tAuthorities: []webhookcip.Authority{{\n\t\t\tName: \"authority-0\",\n\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t},\n\t\t}},\n\t}\n\twantErrs := []string{\"context canceled before validation completed\"}\n\tcancelFunc()\n\t_, gotErrs := ValidatePolicy(testContext, system.Namespace(), digest, cip)\n\tvalidateErrors(t, wantErrs, gotErrs)\n}\n\nfunc TestValidatePoliciesCancelled(t *testing.T) {\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\ttestContext, cancelFunc := context.WithCancel(context.Background())\n\tcip := webhookcip.ClusterImagePolicy{\n\t\tAuthorities: []webhookcip.Authority{{\n\t\t\tName: \"authority-0\",\n\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t},\n\t\t}},\n\t}\n\twantErrs := []string{\"context was canceled before validation completed\"}\n\tcancelFunc()\n\t_, gotErrs := validatePolicies(testContext, system.Namespace(), digest, map[string]webhookcip.ClusterImagePolicy{\"testcip\": cip})\n\tvalidateErrors(t, wantErrs, gotErrs[\"internalerror\"])\n}\n"], "fixing_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage webhook\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/google/go-containerregistry/pkg/authn/k8schain\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/cosign/pkg/policy\"\n\tcsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/fulcio/pkg/api\"\n\t\"github.com/sigstore/policy-controller/pkg/apis/config\"\n\tpolicyduckv1beta1 \"github.com/sigstore/policy-controller/pkg/apis/duck/v1beta1\"\n\twebhookcip \"github.com/sigstore/policy-controller/pkg/webhook/clusterimagepolicy\"\n\trekor \"github.com/sigstore/rekor/pkg/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/client-go/kubernetes\"\n\tlistersv1 \"k8s.io/client-go/listers/core/v1\"\n\t\"knative.dev/pkg/apis\"\n\tduckv1 \"knative.dev/pkg/apis/duck/v1\"\n\n\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"\n\tsecretinformer \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret\"\n\t\"knative.dev/pkg/logging\"\n\t\"knative.dev/pkg/system\"\n)\n\ntype Validator struct {\n\tclient     kubernetes.Interface\n\tlister     listersv1.SecretLister\n\tsecretName string\n}\n\nfunc NewValidator(ctx context.Context, secretName string) *Validator {\n\treturn &Validator{\n\t\tclient:     kubeclient.Get(ctx),\n\t\tlister:     secretinformer.Get(ctx).Lister(),\n\t\tsecretName: secretName,\n\t}\n}\n\n// isDeletedOrStatusUpdate returns true if the resource in question is being\n// deleted, is already deleted or Status is being updated. In any of those\n// cases, we do not validate the resource\nfunc isDeletedOrStatusUpdate(ctx context.Context, deletionTimestamp *metav1.Time) bool {\n\treturn apis.IsInDelete(ctx) || deletionTimestamp != nil || apis.IsInStatusUpdate(ctx)\n}\n\n// ValidatePodScalable implements policyduckv1beta1.PodScalableValidator\n// It is very similar to ValidatePodSpecable, but allows for spec.replicas\n// to be decremented. This allows for scaling down pods with non-compliant\n// images that would otherwise be forbidden.\nfunc (v *Validator) ValidatePodScalable(ctx context.Context, ps *policyduckv1beta1.PodScalable) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, ps.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\t// If we are being scaled down don't block it.\n\tif ps.IsScalingDown(ctx) {\n\t\tlogging.FromContext(ctx).Debugf(\"Skipping validations due to scale down request %s/%s\", &ps.ObjectMeta.Name, &ps.ObjectMeta.Namespace)\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(ps.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range ps.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          ps.Namespace,\n\t\tServiceAccountName: ps.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, ps.Namespace, &ps.Spec.Template.Spec, opt).ViaField(\"spec.template.spec\")\n}\n\n// ValidatePodSpecable implements duckv1.PodSpecValidator\nfunc (v *Validator) ValidatePodSpecable(ctx context.Context, wp *duckv1.WithPod) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, wp.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(wp.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range wp.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          wp.Namespace,\n\t\tServiceAccountName: wp.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, wp.Namespace, &wp.Spec.Template.Spec, opt).ViaField(\"spec.template.spec\")\n}\n\n// ValidatePod implements duckv1.PodValidator\nfunc (v *Validator) ValidatePod(ctx context.Context, p *duckv1.Pod) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, p.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(p.Spec.ImagePullSecrets))\n\tfor _, s := range p.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          p.Namespace,\n\t\tServiceAccountName: p.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, p.Namespace, &p.Spec, opt).ViaField(\"spec\")\n}\n\n// ValidateCronJob implements duckv1.CronJobValidator\nfunc (v *Validator) ValidateCronJob(ctx context.Context, c *duckv1.CronJob) *apis.FieldError {\n\t// If we are deleting (or already deleted) or updating status, don't block.\n\tif isDeletedOrStatusUpdate(ctx, c.DeletionTimestamp) {\n\t\treturn nil\n\t}\n\n\timagePullSecrets := make([]string, 0, len(c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          c.Namespace,\n\t\tServiceAccountName: c.Spec.JobTemplate.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\treturn v.validatePodSpec(ctx, c.Namespace, &c.Spec.JobTemplate.Spec.Template.Spec, opt).ViaField(\"spec.jobTemplate.spec.template.spec\")\n}\n\nfunc (v *Validator) validatePodSpec(ctx context.Context, namespace string, ps *corev1.PodSpec, opt k8schain.Options) (errs *apis.FieldError) {\n\tkc, err := k8schain.New(ctx, v.client, opt)\n\tif err != nil {\n\t\tlogging.FromContext(ctx).Warnf(\"Unable to build k8schain: %v\", err)\n\t\treturn apis.ErrGeneric(err.Error(), apis.CurrentField)\n\t}\n\n\ts, err := v.lister.Secrets(system.Namespace()).Get(v.secretName)\n\tif err != nil && !apierrs.IsNotFound(err) {\n\t\treturn apis.ErrGeneric(err.Error(), apis.CurrentField)\n\t}\n\t// If the secret is not found, we verify against the fulcio root.\n\tkeys := make([]crypto.PublicKey, 0)\n\tif err == nil {\n\t\tvar kerr *apis.FieldError\n\t\tkeys, kerr = getKeys(ctx, s.Data)\n\t\tif kerr != nil {\n\t\t\treturn kerr\n\t\t}\n\t}\n\n\tcheckContainers := func(cs []corev1.Container, field string) {\n\t\tfor i, c := range cs {\n\t\t\tref, err := name.ParseReference(c.Image)\n\t\t\tif err != nil {\n\t\t\t\terrs = errs.Also(apis.ErrGeneric(err.Error(), \"image\").ViaFieldIndex(field, i))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Require digests, otherwise the validation is meaningless\n\t\t\t// since the tag can move.\n\t\t\tif _, ok := ref.(name.Digest); !ok {\n\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(\n\t\t\t\t\tfmt.Sprintf(\"%s must be an image digest\", c.Image),\n\t\t\t\t\t\"image\",\n\t\t\t\t).ViaFieldIndex(field, i))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainerKeys := keys\n\t\t\tconfig := config.FromContext(ctx)\n\n\t\t\t// During the migration from the secret only validation into policy\n\t\t\t// based ones. If there were matching policies that successfully\n\t\t\t// validated the image, keep tally of it and if all Policies that\n\t\t\t// matched validated, skip the traditional one since they are not\n\t\t\t// necessarily going to play nicely together.\n\t\t\tpassedPolicyChecks := false\n\t\t\tif config != nil {\n\t\t\t\tpolicies, err := config.ImagePolicyConfig.GetMatchingPolicies(ref.Name())\n\t\t\t\tif err != nil {\n\t\t\t\t\terrorField := apis.ErrGeneric(err.Error(), \"image\").ViaFieldIndex(field, i)\n\t\t\t\t\terrorField.Details = c.Image\n\t\t\t\t\terrs = errs.Also(errorField)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// If there is at least one policy that matches, that means it\n\t\t\t\t// has to be satisfied.\n\t\t\t\tif len(policies) > 0 {\n\t\t\t\t\tsignatures, fieldErrors := validatePolicies(ctx, namespace, ref, policies, ociremote.WithRemoteOptions(remote.WithAuthFromKeychain(kc)))\n\n\t\t\t\t\tif len(signatures) != len(policies) {\n\t\t\t\t\t\tlogging.FromContext(ctx).Warnf(\"Failed to validate at least one policy for %s\", ref.Name())\n\t\t\t\t\t\t// Do we really want to add all the error details here?\n\t\t\t\t\t\t// Seems like we can just say which policy failed, so\n\t\t\t\t\t\t// doing that for now.\n\t\t\t\t\t\tfor failingPolicy, policyErrs := range fieldErrors {\n\t\t\t\t\t\t\terrorField := apis.ErrGeneric(fmt.Sprintf(\"failed policy: %s\", failingPolicy), \"image\").ViaFieldIndex(field, i)\n\t\t\t\t\t\t\terrDetails := c.Image\n\t\t\t\t\t\t\tfor _, policyErr := range policyErrs {\n\t\t\t\t\t\t\t\terrDetails = errDetails + \" \" + policyErr.Error()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\terrorField.Details = errDetails\n\t\t\t\t\t\t\terrs = errs.Also(errorField)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Because there was at least one policy that was\n\t\t\t\t\t\t// supposed to be validated, but it failed, then fail\n\t\t\t\t\t\t// this image. It should not fall through to the\n\t\t\t\t\t\t// traditional secret checking so it does not slip\n\t\t\t\t\t\t// through the policy cracks, and also to reduce noise\n\t\t\t\t\t\t// in the errors returned to the user.\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogging.FromContext(ctx).Warnf(\"Validated authorities for %s\", ref.Name())\n\t\t\t\t\t\t// Only say we passed (aka, we skip the traditidional check\n\t\t\t\t\t\t// below) if more than one authority was validated, which\n\t\t\t\t\t\t// means that there was a matching ClusterImagePolicy.\n\t\t\t\t\t\tif len(signatures) > 0 {\n\t\t\t\t\t\t\tpassedPolicyChecks = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"policies: for %v\", policies)\n\t\t\t}\n\n\t\t\tif passedPolicyChecks {\n\t\t\t\tlogging.FromContext(ctx).Debugf(\"Found at least one matching policy and it was validated for %s\", ref.Name())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlogging.FromContext(ctx).Errorf(\"ref: for %v\", ref)\n\t\t\tlogging.FromContext(ctx).Errorf(\"container Keys: for %v\", containerKeys)\n\n\t\t\tif _, err := valid(ctx, ref, nil, containerKeys, ociremote.WithRemoteOptions(remote.WithAuthFromKeychain(kc))); err != nil {\n\t\t\t\terrorField := apis.ErrGeneric(err.Error(), \"image\").ViaFieldIndex(field, i)\n\t\t\t\terrorField.Details = c.Image\n\t\t\t\terrs = errs.Also(errorField)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckContainers(ps.InitContainers, \"initContainers\")\n\tcheckContainers(ps.Containers, \"containers\")\n\n\treturn errs\n}\n\n// validatePolicies will go through all the matching Policies and their\n// Authorities for a given image. Returns the map of policy=>Validated\n// signatures. From the map you can see the number of matched policies along\n// with the signatures that were verified.\n// If there's a policy that did not match, it will be returned in the errors map\n// along with all the errors that caused it to fail.\n// Note that if an image does not match any policies, it's perfectly\n// reasonable that the return value is 0, nil since there were no errors, but\n// the image was not validated against any matching policy and hence authority.\nfunc validatePolicies(ctx context.Context, namespace string, ref name.Reference, policies map[string]webhookcip.ClusterImagePolicy, remoteOpts ...ociremote.Option) (map[string]*PolicyResult, map[string][]error) {\n\ttype retChannelType struct {\n\t\tname         string\n\t\tpolicyResult *PolicyResult\n\t\terrors       []error\n\t}\n\tresults := make(chan retChannelType, len(policies))\n\n\t// For each matching policy it must validate at least one Authority within\n\t// it.\n\t// From the Design document, the part about multiple Policies matching:\n\t// \"If multiple policies match a particular image, then ALL of those\n\t// policies must be satisfied for the image to be admitted.\"\n\t// If none of the Authorities for a given policy pass the checks, gather\n\t// the errors here. If one passes, do not return the errors.\n\tfor cipName, cip := range policies {\n\t\t// Due to running in gofunc\n\t\tcipName := cipName\n\t\tcip := cip\n\t\tlogging.FromContext(ctx).Debugf(\"Checking Policy: %s\", cipName)\n\t\tgo func() {\n\t\t\tresult := retChannelType{name: cipName}\n\n\t\t\tresult.policyResult, result.errors = ValidatePolicy(ctx, namespace, ref, cip, remoteOpts...)\n\t\t\tresults <- result\n\t\t}()\n\t}\n\t// Gather all validated policies here.\n\tpolicyResults := make(map[string]*PolicyResult)\n\t// For a policy that does not pass at least one authority, gather errors\n\t// here so that we can give meaningful errors to the user.\n\tret := map[string][]error{}\n\n\tfor i := 0; i < len(policies); i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tret[\"internalerror\"] = append(ret[\"internalerror\"], fmt.Errorf(\"context was canceled before validation completed\"))\n\t\tcase result, ok := <-results:\n\t\t\tif !ok {\n\t\t\t\tret[\"internalerror\"] = append(ret[\"internalerror\"], fmt.Errorf(\"results channel failed to produce a result\"))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch {\n\t\t\t// Return AuthorityMatches before errors, since even if there\n\t\t\t// are errors, if there are 0 or more authorities that match,\n\t\t\t// it will pass the Policy. Of course, a CIP level policy can\n\t\t\t// override this behaviour, but that has been checked above and\n\t\t\t// if it failed, it will nil out the policyResult.\n\t\t\tcase result.policyResult != nil:\n\t\t\t\tpolicyResults[result.name] = result.policyResult\n\t\t\tcase len(result.errors) > 0:\n\t\t\t\tret[result.name] = append(ret[result.name], result.errors...)\n\t\t\tdefault:\n\t\t\t\tret[result.name] = append(ret[result.name], fmt.Errorf(\"failed to process policy: %s\", result.name))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn policyResults, ret\n}\n\n// ValidatePolicy will go through all the Authorities for a given image/policy\n// and return validated authorities if at least one of the Authorities\n// validated the signatures OR attestations if atttestations were specified.\n// Returns PolicyResult if one or more authorities matched, otherwise nil.\n// In any case returns all errors encountered if none of the authorities\n// passed.\nfunc ValidatePolicy(ctx context.Context, namespace string, ref name.Reference, cip webhookcip.ClusterImagePolicy, remoteOpts ...ociremote.Option) (*PolicyResult, []error) {\n\t// Each gofunc creates and puts one of these into a results channel.\n\t// Once each gofunc finishes, we go through the channel and pull out\n\t// the results.\n\ttype retChannelType struct {\n\t\tname         string\n\t\tstatic       bool\n\t\tattestations map[string][]PolicySignature\n\t\tsignatures   []PolicySignature\n\t\terr          error\n\t}\n\tresults := make(chan retChannelType, len(cip.Authorities))\n\tfor _, authority := range cip.Authorities {\n\t\tauthority := authority // due to gofunc\n\t\tlogging.FromContext(ctx).Debugf(\"Checking Authority: %s\", authority.Name)\n\n\t\tgo func() {\n\t\t\tresult := retChannelType{name: authority.Name}\n\t\t\t// Assignment for appendAssign lint error\n\t\t\tauthorityRemoteOpts := remoteOpts\n\t\t\tauthorityRemoteOpts = append(authorityRemoteOpts, authority.RemoteOpts...)\n\n\t\t\tsignaturePullSecretsOpts, err := authority.SourceSignaturePullSecretsOpts(ctx, namespace)\n\t\t\tif err != nil {\n\t\t\t\tresult.err = err\n\t\t\t\tresults <- result\n\t\t\t\treturn\n\t\t\t}\n\t\t\tauthorityRemoteOpts = append(authorityRemoteOpts, signaturePullSecretsOpts...)\n\n\t\t\tswitch {\n\t\t\tcase authority.Static != nil:\n\t\t\t\tif authority.Static.Action == \"fail\" {\n\t\t\t\t\tresult.err = cosign.NewVerificationError(\"disallowed by static policy\")\n\t\t\t\t\tresults <- result\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresult.static = true\n\n\t\t\tcase len(authority.Attestations) > 0:\n\t\t\t\t// We're doing the verify-attestations path, so validate (.att)\n\t\t\t\tresult.attestations, result.err = ValidatePolicyAttestationsForAuthority(ctx, ref, authority, authorityRemoteOpts...)\n\n\t\t\tdefault:\n\t\t\t\tresult.signatures, result.err = ValidatePolicySignaturesForAuthority(ctx, ref, authority, authorityRemoteOpts...)\n\t\t\t}\n\t\t\tresults <- result\n\t\t}()\n\t}\n\n\t// If none of the Authorities for a given policy pass the checks, gather\n\t// the errors here. Even if there are errors, return the matched\n\t// authoritypolicies.\n\tauthorityErrors := make([]error, 0, len(cip.Authorities))\n\t// We collect all the successfully satisfied Authorities into this and\n\t// return it.\n\tpolicyResult := &PolicyResult{\n\t\tAuthorityMatches: make(map[string]AuthorityMatch, len(cip.Authorities)),\n\t}\n\tfor range cip.Authorities {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tauthorityErrors = append(authorityErrors, fmt.Errorf(\"%w before validation completed\", ctx.Err()))\n\n\t\tcase result, ok := <-results:\n\t\t\tif !ok {\n\t\t\t\tauthorityErrors = append(authorityErrors, errors.New(\"results channel closed before all results were sent\"))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch {\n\t\t\tcase result.err != nil:\n\t\t\t\tauthorityErrors = append(authorityErrors, result.err)\n\n\t\t\tcase len(result.signatures) > 0:\n\t\t\t\tpolicyResult.AuthorityMatches[result.name] = AuthorityMatch{Signatures: result.signatures}\n\n\t\t\tcase len(result.attestations) > 0:\n\t\t\t\tpolicyResult.AuthorityMatches[result.name] = AuthorityMatch{Attestations: result.attestations}\n\n\t\t\tcase result.static:\n\t\t\t\t// This happens when we encounter a policy with:\n\t\t\t\t//   static:\n\t\t\t\t//     action: \"pass\"\n\t\t\t\tpolicyResult.AuthorityMatches[result.name] = AuthorityMatch{\n\t\t\t\t\tStatic: true,\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tauthorityErrors = append(authorityErrors, fmt.Errorf(\"failed to process authority: %s\", result.name))\n\t\t\t}\n\t\t}\n\t}\n\t// Even if there are errors, return the policies, since as per the\n\t// spec, we just need one authority to pass checks. If more than\n\t// one are required, that is enforced at the CIP policy level.\n\t// If however there are no authorityMatches, return nil so we don't have\n\t// to keep checking the length on the returned calls.\n\tif len(policyResult.AuthorityMatches) == 0 {\n\t\treturn nil, authorityErrors\n\t}\n\t// Ok, there's at least one valid authority that matched. If there's a CIP\n\t// level policy, validate it here before returning.\n\tif cip.Policy != nil {\n\t\tlogging.FromContext(ctx).Info(\"Validating CIP level policy\")\n\t\tpolicyJSON, err := json.Marshal(policyResult)\n\t\tif err != nil {\n\t\t\treturn nil, append(authorityErrors, err)\n\t\t}\n\t\terr = policy.EvaluatePolicyAgainstJSON(ctx, \"ClusterImagePolicy\", cip.Policy.Type, cip.Policy.Data, policyJSON)\n\t\tif err != nil {\n\t\t\tlogging.FromContext(ctx).Warnf(\"Failed to validate CIP level policy against %s\", string(policyJSON))\n\t\t\treturn nil, append(authorityErrors, err)\n\t\t}\n\t}\n\treturn policyResult, authorityErrors\n}\n\nfunc ociSignatureToPolicySignature(ctx context.Context, sigs []oci.Signature) []PolicySignature {\n\tret := make([]PolicySignature, 0, len(sigs))\n\tfor _, ociSig := range sigs {\n\t\tlogging.FromContext(ctx).Debugf(\"Converting signature %+v\", ociSig)\n\n\t\tif cert, err := ociSig.Cert(); err == nil && cert != nil {\n\t\t\tce := cosign.CertExtensions{\n\t\t\t\tCert: cert,\n\t\t\t}\n\t\t\tret = append(ret, PolicySignature{\n\t\t\t\tSubject: csigs.CertSubject(cert),\n\t\t\t\tIssuer:  ce.GetIssuer(),\n\t\t\t\tGithubExtensions: GithubExtensions{\n\t\t\t\t\tWorkflowTrigger: ce.GetCertExtensionGithubWorkflowTrigger(),\n\t\t\t\t\tWorkflowSHA:     ce.GetExtensionGithubWorkflowSha(),\n\t\t\t\t\tWorkflowName:    ce.GetCertExtensionGithubWorkflowName(),\n\t\t\t\t\tWorkflowRepo:    ce.GetCertExtensionGithubWorkflowRepository(),\n\t\t\t\t\tWorkflowRef:     ce.GetCertExtensionGithubWorkflowRef(),\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\tret = append(ret, PolicySignature{})\n\t\t}\n\t}\n\treturn ret\n}\n\n// ValidatePolicySignaturesForAuthority takes the Authority and tries to\n// verify a signature against it.\nfunc ValidatePolicySignaturesForAuthority(ctx context.Context, ref name.Reference, authority webhookcip.Authority, remoteOpts ...ociremote.Option) ([]PolicySignature, error) {\n\tname := authority.Name\n\n\tvar rekorClient *client.Rekor\n\tvar err error\n\tif authority.CTLog != nil && authority.CTLog.URL != nil {\n\t\tlogging.FromContext(ctx).Debugf(\"Using CTLog %s for %s\", authority.CTLog.URL, ref.Name())\n\t\trekorClient, err = rekor.GetRekorClient(authority.CTLog.URL.String())\n\t\tif err != nil {\n\t\t\tlogging.FromContext(ctx).Errorf(\"failed creating rekor client: +v\", err)\n\t\t\treturn nil, fmt.Errorf(\"creating Rekor client: %w\", err)\n\t\t}\n\t}\n\n\tswitch {\n\tcase authority.Key != nil && len(authority.Key.PublicKeys) > 0:\n\t\t// TODO(vaikas): What should happen if there are multiple keys\n\t\t// Is it even allowed? 'valid' returns success if any key\n\t\t// matches.\n\t\t// https://github.com/sigstore/policy-controller/issues/1652\n\t\tsps, err := valid(ctx, ref, rekorClient, authority.Key.PublicKeys, remoteOpts...)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"signature key validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t}\n\t\tlogging.FromContext(ctx).Debugf(\"validated signature for %s for authority %s got %d signatures\", ref.Name(), authority.Name, len(sps))\n\t\treturn ociSignatureToPolicySignature(ctx, sps), nil\n\n\tcase authority.Keyless != nil:\n\t\tif authority.Keyless != nil && authority.Keyless.URL != nil {\n\t\t\tlogging.FromContext(ctx).Debugf(\"Fetching FulcioRoot for %s : From: %s \", ref.Name(), authority.Keyless.URL)\n\t\t\tfulcioroot, err := getFulcioCert(authority.Keyless.URL)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fetching FulcioRoot: %w\", err)\n\t\t\t}\n\t\t\tsps, err := validSignaturesWithFulcio(ctx, ref, fulcioroot, rekorClient, authority.Keyless.Identities, remoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"failed validSignatures for authority %s with fulcio for %s: %v\", name, ref.Name(), err)\n\t\t\t\treturn nil, fmt.Errorf(\"signature keyless validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t\t}\n\t\t\tlogging.FromContext(ctx).Debugf(\"validated signature for %s, got %d signatures\", ref.Name(), len(sps))\n\t\t\treturn ociSignatureToPolicySignature(ctx, sps), nil\n\t\t}\n\t}\n\n\t// This should never happen because authority has to have been validated to\n\t// be either having a Key, Keyless, or Static (handled elsewhere)\n\treturn nil, errors.New(\"authority has neither key, keyless, or static specified\")\n}\n\n// ValidatePolicyAttestationsForAuthority takes the Authority and tries to\n// verify attestations against it.\nfunc ValidatePolicyAttestationsForAuthority(ctx context.Context, ref name.Reference, authority webhookcip.Authority, remoteOpts ...ociremote.Option) (map[string][]PolicySignature, error) {\n\tname := authority.Name\n\tvar rekorClient *client.Rekor\n\tvar err error\n\tif authority.CTLog != nil && authority.CTLog.URL != nil {\n\t\tlogging.FromContext(ctx).Debugf(\"Using CTLog %s for %s\", authority.CTLog.URL, ref.Name())\n\t\trekorClient, err = rekor.GetRekorClient(authority.CTLog.URL.String())\n\t\tif err != nil {\n\t\t\tlogging.FromContext(ctx).Errorf(\"failed creating rekor client: +v\", err)\n\t\t\treturn nil, fmt.Errorf(\"creating Rekor client: %w\", err)\n\t\t}\n\t}\n\n\tverifiedAttestations := []oci.Signature{}\n\tswitch {\n\tcase authority.Key != nil && len(authority.Key.PublicKeys) > 0:\n\t\tfor _, k := range authority.Key.PublicKeys {\n\t\t\tverifier, err := signature.LoadVerifier(k, crypto.SHA256)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"error creating verifier: %v\", err)\n\t\t\t\treturn nil, fmt.Errorf(\"creating verifier: %w\", err)\n\t\t\t}\n\t\t\tva, err := validAttestations(ctx, ref, verifier, rekorClient, remoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"error validating attestations: %v\", err)\n\t\t\t\treturn nil, fmt.Errorf(\"attestation key validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t\t}\n\t\t\tverifiedAttestations = append(verifiedAttestations, va...)\n\t\t}\n\n\tcase authority.Keyless != nil:\n\t\tif authority.Keyless != nil && authority.Keyless.URL != nil {\n\t\t\tlogging.FromContext(ctx).Debugf(\"Fetching FulcioRoot for %s : From: %s \", ref.Name(), authority.Keyless.URL)\n\t\t\tfulcioroot, err := getFulcioCert(authority.Keyless.URL)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fetching FulcioRoot: %w\", err)\n\t\t\t}\n\t\t\tva, err := validAttestationsWithFulcio(ctx, ref, fulcioroot, rekorClient, authority.Keyless.Identities, remoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Errorf(\"failed validAttestationsWithFulcio for authority %s with fulcio for %s: %v\", name, ref.Name(), err)\n\t\t\t\treturn nil, fmt.Errorf(\"attestation keyless validation failed for authority %s for %s: %w\", name, ref.Name(), err)\n\t\t\t}\n\t\t\tverifiedAttestations = append(verifiedAttestations, va...)\n\t\t}\n\t}\n\n\t// If we didn't get any verified attestations either from the Key or Keyless\n\t// path, then error out\n\tif len(verifiedAttestations) == 0 {\n\t\tlogging.FromContext(ctx).Errorf(\"no valid attestations found for authority %s for %s\", name, ref.Name())\n\t\treturn nil, fmt.Errorf(\"%w for authority %s for %s\", cosign.ErrNoMatchingAttestations, name, ref.Name())\n\t}\n\tlogging.FromContext(ctx).Debugf(\"Found %d valid attestations, validating policies for them\", len(verifiedAttestations))\n\n\t// Now spin through the Attestations that the user specified and validate\n\t// them.\n\t// TODO(vaikas): Pretty inefficient here, figure out a better way if\n\t// possible.\n\tret := make(map[string][]PolicySignature, len(authority.Attestations))\n\tfor _, wantedAttestation := range authority.Attestations {\n\t\t// There's a particular type, so we need to go through all the verified\n\t\t// attestations and make sure that our particular one is satisfied.\n\t\tcheckedAttestations := make([]oci.Signature, 0, len(verifiedAttestations))\n\t\tfor _, va := range verifiedAttestations {\n\t\t\tattBytes, err := policy.AttestationToPayloadJSON(ctx, wantedAttestation.PredicateType, va)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to convert attestation payload to json: %w\", err)\n\t\t\t}\n\t\t\tif attBytes == nil {\n\t\t\t\t// This happens when we ask for a predicate type that this\n\t\t\t\t// attestation is not for. It's not an error, so we skip it.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif wantedAttestation.Type != \"\" {\n\t\t\t\tif err := policy.EvaluatePolicyAgainstJSON(ctx, wantedAttestation.Name, wantedAttestation.Type, wantedAttestation.Data, attBytes); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Ok, so this passed aok, jot it down to our result set as\n\t\t\t// verified attestation with the predicate type match\n\t\t\tcheckedAttestations = append(checkedAttestations, va)\n\t\t}\n\t\tif len(checkedAttestations) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"%w with type %s\", cosign.ErrNoMatchingAttestations, wantedAttestation.PredicateType)\n\t\t}\n\t\tret[wantedAttestation.Name] = ociSignatureToPolicySignature(ctx, checkedAttestations)\n\t}\n\treturn ret, nil\n}\n\n// ResolvePodScalable implements policyduckv1beta1.PodScalableValidator\nfunc (v *Validator) ResolvePodScalable(ctx context.Context, ps *policyduckv1beta1.PodScalable) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// if status is being updated\n\tif isDeletedOrStatusUpdate(ctx, ps.DeletionTimestamp) {\n\t\treturn\n\t}\n\n\tif ps.IsScalingDown(ctx) {\n\t\tlogging.FromContext(ctx).Debugf(\"Skipping validations due to scale down request %s/%s\", &ps.ObjectMeta.Name, &ps.ObjectMeta.Namespace)\n\t\treturn\n\t}\n\n\timagePullSecrets := make([]string, 0, len(ps.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range ps.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          ps.Namespace,\n\t\tServiceAccountName: ps.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &ps.Spec.Template.Spec, opt)\n}\n\n// ResolvePodSpecable implements duckv1.PodSpecValidator\nfunc (v *Validator) ResolvePodSpecable(ctx context.Context, wp *duckv1.WithPod) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// status update.\n\tif isDeletedOrStatusUpdate(ctx, wp.DeletionTimestamp) {\n\t\treturn\n\t}\n\n\timagePullSecrets := make([]string, 0, len(wp.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range wp.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          wp.Namespace,\n\t\tServiceAccountName: wp.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &wp.Spec.Template.Spec, opt)\n}\n\n// ResolvePod implements duckv1.PodValidator\nfunc (v *Validator) ResolvePod(ctx context.Context, p *duckv1.Pod) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// status update.\n\tif isDeletedOrStatusUpdate(ctx, p.DeletionTimestamp) {\n\t\treturn\n\t}\n\timagePullSecrets := make([]string, 0, len(p.Spec.ImagePullSecrets))\n\tfor _, s := range p.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          p.Namespace,\n\t\tServiceAccountName: p.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &p.Spec, opt)\n}\n\n// ResolveCronJob implements duckv1.CronJobValidator\nfunc (v *Validator) ResolveCronJob(ctx context.Context, c *duckv1.CronJob) {\n\t// Don't mess with things that are being deleted or already deleted or\n\t// status update.\n\tif isDeletedOrStatusUpdate(ctx, c.DeletionTimestamp) {\n\t\treturn\n\t}\n\n\timagePullSecrets := make([]string, 0, len(c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets))\n\tfor _, s := range c.Spec.JobTemplate.Spec.Template.Spec.ImagePullSecrets {\n\t\timagePullSecrets = append(imagePullSecrets, s.Name)\n\t}\n\topt := k8schain.Options{\n\t\tNamespace:          c.Namespace,\n\t\tServiceAccountName: c.Spec.JobTemplate.Spec.Template.Spec.ServiceAccountName,\n\t\tImagePullSecrets:   imagePullSecrets,\n\t}\n\tv.resolvePodSpec(ctx, &c.Spec.JobTemplate.Spec.Template.Spec, opt)\n}\n\n// For testing\nvar remoteResolveDigest = ociremote.ResolveDigest\n\nfunc (v *Validator) resolvePodSpec(ctx context.Context, ps *corev1.PodSpec, opt k8schain.Options) {\n\tkc, err := k8schain.New(ctx, v.client, opt)\n\tif err != nil {\n\t\tlogging.FromContext(ctx).Warnf(\"Unable to build k8schain: %v\", err)\n\t\treturn\n\t}\n\n\tresolveContainers := func(cs []corev1.Container) {\n\t\tfor i, c := range cs {\n\t\t\tref, err := name.ParseReference(c.Image)\n\t\t\tif err != nil {\n\t\t\t\tlogging.FromContext(ctx).Debugf(\"Unable to parse reference: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If we are in the context of a mutating webhook, then resolve the tag to a digest.\n\t\t\tswitch {\n\t\t\tcase apis.IsInCreate(ctx), apis.IsInUpdate(ctx):\n\t\t\t\tdigest, err := remoteResolveDigest(ref, ociremote.WithRemoteOptions(remote.WithAuthFromKeychain(kc)))\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogging.FromContext(ctx).Debugf(\"Unable to resolve digest %q: %v\", ref.String(), err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcs[i].Image = digest.String()\n\t\t\t}\n\t\t}\n\t}\n\n\tresolveContainers(ps.InitContainers)\n\tresolveContainers(ps.Containers)\n}\n\nfunc getFulcioCert(u *apis.URL) (*x509.CertPool, error) {\n\tfClient := api.NewClient(u.URL())\n\trootCertResponse, err := fClient.RootCert()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"getting root cert: %w\", err)\n\t}\n\n\tcp := x509.NewCertPool()\n\tif !cp.AppendCertsFromPEM(rootCertResponse.ChainPEM) {\n\t\treturn nil, errors.New(\"error appending to root cert pool\")\n\t}\n\treturn cp, nil\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage webhook\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-containerregistry/pkg/authn/k8schain\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/policy-controller/pkg/apis/config\"\n\tpolicyduckv1beta1 \"github.com/sigstore/policy-controller/pkg/apis/duck/v1beta1\"\n\t\"github.com/sigstore/policy-controller/pkg/apis/policy/v1alpha1\"\n\twebhookcip \"github.com/sigstore/policy-controller/pkg/webhook/clusterimagepolicy\"\n\tbatchv1 \"k8s.io/api/batch/v1\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"knative.dev/pkg/apis\"\n\tduckv1 \"knative.dev/pkg/apis/duck/v1\"\n\tfakekube \"knative.dev/pkg/client/injection/kube/client/fake\"\n\tfakesecret \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret/fake\"\n\t\"knative.dev/pkg/ptr\"\n\trtesting \"knative.dev/pkg/reconciler/testing\"\n\t\"knative.dev/pkg/system\"\n)\n\nconst (\n\tfulcioRootCert = \"-----BEGIN CERTIFICATE-----\\nMIICNzCCAd2gAwIBAgITPLBoBQhl1hqFND9S+SGWbfzaRTAKBggqhkjOPQQDAjBo\\nMQswCQYDVQQGEwJVSzESMBAGA1UECBMJV2lsdHNoaXJlMRMwEQYDVQQHEwpDaGlw\\ncGVuaGFtMQ8wDQYDVQQKEwZSZWRIYXQxDDAKBgNVBAsTA0NUTzERMA8GA1UEAxMI\\ndGVzdGNlcnQwHhcNMjEwMzEyMjMyNDQ5WhcNMzEwMjI4MjMyNDQ5WjBoMQswCQYD\\nVQQGEwJVSzESMBAGA1UECBMJV2lsdHNoaXJlMRMwEQYDVQQHEwpDaGlwcGVuaGFt\\nMQ8wDQYDVQQKEwZSZWRIYXQxDDAKBgNVBAsTA0NUTzERMA8GA1UEAxMIdGVzdGNl\\ncnQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQRn+Alyof6xP3GQClSwgV0NFuY\\nYEwmKP/WLWr/LwB6LUYzt5v49RlqG83KuaJSpeOj7G7MVABdpIZYWwqAiZV3o2Yw\\nZDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBATAdBgNVHQ4EFgQU\\nT8Jwm6JuVb0dsiuHUROiHOOVHVkwHwYDVR0jBBgwFoAUT8Jwm6JuVb0dsiuHUROi\\nHOOVHVkwCgYIKoZIzj0EAwIDSAAwRQIhAJkNZmP6sKA+8EebRXFkBa9DPjacBpTc\\nOljJotvKidRhAiAuNrIazKEw2G4dw8x1z6EYk9G+7fJP5m93bjm/JfMBtA==\\n-----END CERTIFICATE-----\"\n\trekorResponse  = \"bad response\"\n\n\t// Random public key (cosign generate-key-pair) 2022-03-18\n\tauthorityKeyCosignPubString = `-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENAyijLvRu5QpCPp2uOj8C79ZW1VJ\nSID/4H61ZiRzN4nqONzp+ZF22qQTk3MFO3D0/ZKmWHAosIf2pf2GHH7myA==\n-----END PUBLIC KEY-----`\n)\n\nfunc TestValidatePodSpec(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\n\tsecretName := \"blah\"\n\n\t// Non-existent URL for testing complete failure\n\tbadURL := apis.HTTP(\"http://example.com/\")\n\n\t// Spin up a Fulcio that responds with a Root Cert\n\tfulcioServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(fulcioRootCert))\n\t}))\n\tt.Cleanup(fulcioServer.Close)\n\tfulcioURL, err := apis.ParseURL(fulcioServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Fulcio URL\")\n\t}\n\n\trekorServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(rekorResponse))\n\t}))\n\tt.Cleanup(rekorServer.Close)\n\trekorURL, err := apis.ParseURL(rekorServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Rekor URL\")\n\t}\n\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\t// Setup service acc and fakeSignaturePullSecrets for \"default\" and \"cosign-system\" namespace\n\tfor _, ns := range []string{\"default\", system.Namespace()} {\n\t\tkc.CoreV1().ServiceAccounts(ns).Create(ctx, &corev1.ServiceAccount{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName: \"default\",\n\t\t\t},\n\t\t}, metav1.CreateOptions{})\n\n\t\tkc.CoreV1().Secrets(ns).Create(ctx, &corev1.Secret{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName: \"fakeSignaturePullSecrets\",\n\t\t\t},\n\t\t\tData: map[string][]byte{\n\t\t\t\t\"dockerconfigjson\": []byte(`{\"auths\":{\"https://index.docker.io/v1/\":{\"username\":\"username\",\"password\":\"password\",\"auth\":\"dXNlcm5hbWU6cGFzc3dvcmQ=\"}}`),\n\t\t\t},\n\t\t}, metav1.CreateOptions{})\n\t}\n\n\tv := NewValidator(ctx, secretName)\n\n\tcvs := cosignVerifySignatures\n\tdefer func() {\n\t\tcosignVerifySignatures = cvs\n\t}()\n\t// Let's just say that everything is verified.\n\tpass := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tsig, err := static.NewSignature(nil, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is not verified.\n\tfail := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\treturn nil, false, errors.New(\"bad signature\")\n\t}\n\n\t// Let's say it is verified if it is the expected Public Key\n\tauthorityPublicKeyCVS := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tactualPublicKey, _ := co.SigVerifier.PublicKey()\n\t\tactualECDSAPubkey := actualPublicKey.(*ecdsa.PublicKey)\n\t\tactualKeyData := elliptic.Marshal(actualECDSAPubkey, actualECDSAPubkey.X, actualECDSAPubkey.Y)\n\n\t\texpectedKeyData := elliptic.Marshal(authorityKeyCosignPub, authorityKeyCosignPub.X, authorityKeyCosignPub.Y)\n\n\t\tif bytes.Equal(actualKeyData, expectedKeyData) {\n\t\t\treturn pass(ctx, signedImgRef, co)\n\t\t}\n\n\t\treturn fail(ctx, signedImgRef, co)\n\t}\n\n\ttests := []struct {\n\t\tname          string\n\t\tps            *corev1.PodSpec\n\t\twant          *apis.FieldError\n\t\tcvs           func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t\tcustomContext context.Context\n\t}{{\n\t\tname: \"simple, no error\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"bad reference\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: \"in@valid\",\n\t\t\t}},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `could not parse reference: in@valid`,\n\t\t\tPaths:   []string{\"containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"not digest\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `invalid value: gcr.io/distroless/static:nonroot must be an image digest`,\n\t\t\tPaths:   []string{\"containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"bad signature\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `bad signature`,\n\t\t\tPaths:   []string{\"containers[0].image\"},\n\t\t\tDetails: digest.String(),\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, no error, authority key\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\t\t\t\t\t\tData:       authorityKeyCosignPubString,\n\t\t\t\t\t\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tcvs: authorityPublicKeyCVS,\n\t}, {\n\t\tname: \"simple, error, authority keyless, bad fulcio\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: badURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s %s\", digest.String(), `fetching FulcioRoot: getting root cert: parse \"http://http:%2F%2Fexample.com%2F/api/v1/rootCert\": invalid port \":%2F%2Fexample.com%2F\" after host`)\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s %s\", digest.String(), `fetching FulcioRoot: getting root cert: parse \"http://http:%2F%2Fexample.com%2F/api/v1/rootCert\": invalid port \":%2F%2Fexample.com%2F\" after host`)\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, error, authority keyless, good fulcio, no rekor\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, authority keyless checks out, good fulcio, bad cip policy\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless-bad-cip\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPolicy: &webhookcip.AttestationPolicy{\n\t\t\t\t\t\t\t\tName: \"invalid json policy\",\n\t\t\t\t\t\t\t\tType: \"cue\",\n\t\t\t\t\t\t\t\tData: `{\"wontgo`,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless-bad-cip\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s failed evaluating cue policy for ClusterImagePolicy: failed to compile the cue policy with error: string literal not terminated\", digest.String())\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless-bad-cip\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s failed evaluating cue policy for ClusterImagePolicy: failed to compile the cue policy with error: string literal not terminated\", digest.String())\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"simple, no error, authority keyless, good fulcio\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"simple, error, authority keyless, good fulcio, bad rekor\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(context.Background(),\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy-keyless\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\t\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCTLog: &v1alpha1.TLog{\n\t\t\t\t\t\t\t\t\t\tURL: rekorURL,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe)\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy-keyless\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s signature keyless validation failed for authority  for %s: bad signature\", digest.String(), digest.Name())\n\t\t\terrs = errs.Also(fe2)\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, error, authority source signaturePullSecrets, non existing secret\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(ctx,\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\t\t\t\t\t\tData:       authorityKeyCosignPubString,\n\t\t\t\t\t\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSources: []v1alpha1.Source{{\n\t\t\t\t\t\t\t\t\t\tOCI: \"example.com/alternative/signature\",\n\t\t\t\t\t\t\t\t\t\tSignaturePullSecrets: []corev1.LocalObjectReference{{\n\t\t\t\t\t\t\t\t\t\t\tName: \"non-existing-secret\",\n\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\twant: func() *apis.FieldError {\n\t\t\tvar errs *apis.FieldError\n\t\t\tfe := apis.ErrGeneric(\"failed policy: cluster-image-policy\", \"image\").ViaFieldIndex(\"initContainers\", 0)\n\t\t\tfe.Details = fmt.Sprintf(\"%s secrets \\\"non-existing-secret\\\" not found\", digest.String())\n\t\t\terrs = errs.Also(fe)\n\n\t\t\tfe2 := apis.ErrGeneric(\"failed policy: cluster-image-policy\", \"image\").ViaFieldIndex(\"containers\", 0)\n\t\t\tfe2.Details = fmt.Sprintf(\"%s secrets \\\"non-existing-secret\\\" not found\", digest.String())\n\t\t\terrs = errs.Also(fe2)\n\n\t\t\treturn errs\n\t\t}(),\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"simple, no error, authority source signaturePullSecrets, valid secret\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\tcustomContext: config.ToContext(ctx,\n\t\t\t&config.Config{\n\t\t\t\tImagePolicyConfig: &config.ImagePolicyConfig{\n\t\t\t\t\tPolicies: map[string]webhookcip.ClusterImagePolicy{\n\t\t\t\t\t\t\"cluster-image-policy\": {\n\t\t\t\t\t\t\tImages: []v1alpha1.ImagePattern{{\n\t\t\t\t\t\t\t\tGlob: \"gcr.io/*/*\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tAuthorities: []webhookcip.Authority{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\t\t\t\t\t\tData:       authorityKeyCosignPubString,\n\t\t\t\t\t\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSources: []v1alpha1.Source{{\n\t\t\t\t\t\t\t\t\t\tOCI: \"example.com/alternative/signature\",\n\t\t\t\t\t\t\t\t\t\tSignaturePullSecrets: []corev1.LocalObjectReference{{\n\t\t\t\t\t\t\t\t\t\t\tName: \"fakeSignaturePullSecrets\",\n\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tcvs: authorityPublicKeyCVS,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcosignVerifySignatures = test.cvs\n\t\t\ttestContext := context.Background()\n\n\t\t\tif test.customContext != nil {\n\t\t\t\ttestContext = test.customContext\n\t\t\t}\n\n\t\t\t// Check the core mechanics\n\t\t\tgot := v.validatePodSpec(testContext, system.Namespace(), test.ps, k8schain.Options{})\n\t\t\tif (got != nil) != (test.want != nil) {\n\t\t\t\tt.Errorf(\"validatePodSpec() = %v, wanted %v\", got, test.want)\n\t\t\t} else if got != nil && got.Error() != test.want.Error() {\n\t\t\t\tt.Errorf(\"validatePodSpec() = %v, wanted %v\", got, test.want)\n\t\t\t}\n\n\t\t\t// Check wrapped in a Pod\n\t\t\tpod := &duckv1.Pod{\n\t\t\t\tSpec: *test.ps,\n\t\t\t}\n\t\t\tgot = v.ValidatePod(testContext, pod)\n\t\t\twant := test.want.ViaField(\"spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePod() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePod() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tif got := v.ValidatePod(apis.WithinDelete(testContext), pod); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePod() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check wrapped in a WithPod\n\t\t\twithPod := &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tgot = v.ValidatePodSpecable(testContext, withPod)\n\t\t\twant = test.want.ViaField(\"spec.template.spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tif got := v.ValidatePodSpecable(apis.WithinDelete(testContext), withPod); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check wrapped in a podScalable\n\t\t\tpodScalable := &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tgot = v.ValidatePodScalable(testContext, podScalable)\n\t\t\twant = test.want.ViaField(\"spec.template.spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tif got := v.ValidatePodScalable(apis.WithinDelete(testContext), podScalable); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check that we don't block things being scaled down.\n\t\t\toriginal := podScalable.DeepCopy()\n\t\t\toriginal.Spec.Replicas = ptr.Int32(4)\n\t\t\tif got := v.ValidatePodScalable(apis.WithinUpdate(testContext, original), podScalable); got != nil {\n\t\t\t\tt.Errorf(\"ValidatePodSpecable() = %v, wanted nil\", got)\n\t\t\t}\n\n\t\t\t// Check that we fail as expected if being scaled up.\n\t\t\toriginal.Spec.Replicas = ptr.Int32(2)\n\t\t\tgot = v.ValidatePodScalable(apis.WithinUpdate(testContext, original), podScalable)\n\t\t\twant = test.want.ViaField(\"spec.template.spec\")\n\t\t\tif (got != nil) != (want != nil) {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t} else if got != nil && got.Error() != want.Error() {\n\t\t\t\tt.Errorf(\"ValidatePodScalable() = %v, wanted %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateCronJob(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\n\tsecretName := \"blah\"\n\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// No data should make us verify against Fulcio.\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\tkc.CoreV1().ServiceAccounts(\"default\").Create(ctx, &corev1.ServiceAccount{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"default\",\n\t\t},\n\t}, metav1.CreateOptions{})\n\n\tv := NewValidator(ctx, secretName)\n\n\tcvs := cosignVerifySignatures\n\tdefer func() {\n\t\tcosignVerifySignatures = cvs\n\t}()\n\t// Let's just say that everything is verified.\n\tpass := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tsig, err := static.NewSignature(nil, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is not verified.\n\tfail := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\treturn nil, false, errors.New(\"bad signature\")\n\t}\n\n\ttests := []struct {\n\t\tname string\n\t\tc    *duckv1.CronJob\n\t\twant *apis.FieldError\n\t\tcvs  func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t}{{\n\t\tname: \"simple, no error\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"k8schain error (bad service account)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tServiceAccountName: \"not-found\",\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `serviceaccounts \"not-found\" not found`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec\"},\n\t\t},\n\t}, {\n\t\tname: \"k8schain error (bad pull secret)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tImagePullSecrets: []corev1.LocalObjectReference{{\n\t\t\t\t\t\t\t\t\tName: \"not-found\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `secrets \"not-found\" not found`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec\"},\n\t\t},\n\t}, {\n\t\tname: \"bad reference\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `could not parse reference: in@valid`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec.containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"not digest\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `invalid value: gcr.io/distroless/static:nonroot must be an image digest`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec.containers[0].image\"},\n\t\t},\n\t\tcvs: fail,\n\t}, {\n\t\tname: \"bad signature\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &apis.FieldError{\n\t\t\tMessage: `bad signature`,\n\t\t\tPaths:   []string{\"spec.jobTemplate.spec.template.spec.containers[0].image\"},\n\t\t\tDetails: digest.String(),\n\t\t},\n\t\tcvs: fail,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcosignVerifySignatures = test.cvs\n\n\t\t\t// Check the core mechanics\n\t\t\tgot := v.ValidateCronJob(context.Background(), test.c)\n\t\t\tif (got != nil) != (test.want != nil) {\n\t\t\t\tt.Errorf(\"validateCronJob() = %v, wanted %v\", got, test.want)\n\t\t\t} else if got != nil && got.Error() != test.want.Error() {\n\t\t\t\tt.Errorf(\"validateCronJob() = %v, wanted %v\", got, test.want)\n\t\t\t}\n\t\t\t// Check that we don't block things being deleted.\n\t\t\tcronJob := test.c.DeepCopy()\n\t\t\tif got := v.ValidateCronJob(apis.WithinDelete(context.Background()), cronJob); got != nil {\n\t\t\t\tt.Errorf(\"ValidateCronJob() = %v, wanted nil\", got)\n\t\t\t}\n\t\t\t// Check that we don't block things already deleted.\n\t\t\tcronJob = test.c.DeepCopy()\n\t\t\tcronJob.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\tif got := v.ValidateCronJob(context.Background(), cronJob); got != nil {\n\t\t\t\tt.Errorf(\"ValidateCronJob() = %v, wanted nil\", got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResolvePodSpec(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\tsecretName := \"blah\"\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\tkc.CoreV1().ServiceAccounts(\"default\").Create(ctx, &corev1.ServiceAccount{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"default\",\n\t\t},\n\t}, metav1.CreateOptions{})\n\n\tv := NewValidator(ctx, secretName)\n\n\trrd := remoteResolveDigest\n\tdefer func() {\n\t\tremoteResolveDigest = rrd\n\t}()\n\tresolve := func(ref name.Reference, opts ...remote.Option) (name.Digest, error) {\n\t\treturn digest.(name.Digest), nil\n\t}\n\n\ttests := []struct {\n\t\tname string\n\t\tps   *corev1.PodSpec\n\t\twant *corev1.PodSpec\n\t\twc   func(context.Context) context.Context\n\t\trrd  func(name.Reference, ...remote.Option) (name.Digest, error)\n\t}{{\n\t\tname: \"nothing changed (not the right update)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (bad reference)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: \"in@valid\",\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: \"in@valid\",\n\t\t\t}},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (unable to resolve)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twc: apis.WithinCreate,\n\t\trrd: func(r name.Reference, o ...remote.Option) (name.Digest, error) {\n\t\t\treturn name.Digest{}, errors.New(\"boom\")\n\t\t},\n\t}, {\n\t\tname: \"digests resolve (in create)\",\n\t\tps: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: tag.String(),\n\t\t\t}},\n\t\t},\n\t\twant: &corev1.PodSpec{\n\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t\tContainers: []corev1.Container{{\n\t\t\t\tName:  \"user-container\",\n\t\t\t\tImage: digest.String(),\n\t\t\t}},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tremoteResolveDigest = test.rrd\n\t\t\tctx := context.Background()\n\t\t\tif test.wc != nil {\n\t\t\t\tctx = test.wc(context.Background())\n\t\t\t}\n\n\t\t\t// Check the core mechanics.\n\t\t\tgot := test.ps.DeepCopy()\n\t\t\tv.resolvePodSpec(ctx, got, k8schain.Options{})\n\t\t\tif !cmp.Equal(got, test.want) {\n\t\t\t\tt.Errorf(\"resolvePodSpec = %s\", cmp.Diff(got, test.want))\n\t\t\t}\n\n\t\t\tvar want runtime.Object\n\n\t\t\t// Check wrapped in a Pod\n\t\t\tpod := &duckv1.Pod{Spec: *test.ps.DeepCopy()}\n\t\t\twant = &duckv1.Pod{Spec: *test.want.DeepCopy()}\n\t\t\tv.ResolvePod(ctx, pod)\n\t\t\tif !cmp.Equal(pod, want) {\n\t\t\t\tt.Errorf(\"ResolvePod = %s\", cmp.Diff(pod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\tpod = &duckv1.Pod{Spec: *test.ps.DeepCopy()}\n\t\t\twant = pod.DeepCopy()\n\t\t\tv.ResolvePod(apis.WithinDelete(ctx), pod)\n\t\t\tif !cmp.Equal(pod, want) {\n\t\t\t\tt.Errorf(\"ResolvePod = %s\", cmp.Diff(pod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's already deleted.\n\t\t\tpod = &duckv1.Pod{Spec: *test.ps.DeepCopy()}\n\t\t\tpod.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\twant = pod.DeepCopy()\n\t\t\tv.ResolvePod(ctx, pod)\n\t\t\tif !cmp.Equal(pod, want) {\n\t\t\t\tt.Errorf(\"ResolvePod = %s\", cmp.Diff(pod, want))\n\t\t\t}\n\n\t\t\t// Check wrapped in a WithPod\n\t\t\twithPod := &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.want.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tv.ResolvePodSpecable(ctx, withPod)\n\t\t\tif !cmp.Equal(withPod, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(withPod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\twithPod = &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = withPod.DeepCopy()\n\t\t\tv.ResolvePodSpecable(apis.WithinDelete(ctx), withPod)\n\t\t\tif !cmp.Equal(withPod, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(withPod, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's already deleted.\n\t\t\twithPod = &duckv1.WithPod{\n\t\t\t\tSpec: duckv1.WithPodSpec{\n\t\t\t\t\tTemplate: duckv1.PodSpecable{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twithPod.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\twant = withPod.DeepCopy()\n\t\t\tv.ResolvePodSpecable(ctx, withPod)\n\t\t\tif !cmp.Equal(withPod, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(withPod, want))\n\t\t\t}\n\n\t\t\t// Check wrapped in a PodScalable\n\t\t\tpodScalable := &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.want.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tv.ResolvePodScalable(ctx, podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\tpodScalable = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(2),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = podScalable.DeepCopy()\n\t\t\tv.ResolvePodScalable(apis.WithinDelete(ctx), podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's already deleted.\n\t\t\tpodScalable = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(2),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tpodScalable.DeletionTimestamp = &metav1.Time{Time: time.Now()}\n\t\t\twant = podScalable.DeepCopy()\n\t\t\tv.ResolvePodScalable(ctx, podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being scaled down.\n\t\t\tpodScalable = &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(2),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\twant = podScalable.DeepCopy()\n\t\t\toriginal := &policyduckv1beta1.PodScalable{\n\t\t\t\tSpec: policyduckv1beta1.PodScalableSpec{\n\t\t\t\t\tReplicas: ptr.Int32(3),\n\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\tSpec: *test.ps.DeepCopy(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tv.ResolvePodScalable(apis.WithinUpdate(ctx, original), podScalable)\n\t\t\tif !cmp.Equal(podScalable, want) {\n\t\t\t\tt.Errorf(\"ResolvePodSpecable = %s\", cmp.Diff(podScalable, want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResolveCronJob(t *testing.T) {\n\ttag := name.MustParseReference(\"gcr.io/distroless/static:nonroot\")\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\tsecretName := \"blah\"\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tkc := fakekube.Get(ctx)\n\tkc.CoreV1().ServiceAccounts(\"default\").Create(ctx, &corev1.ServiceAccount{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"default\",\n\t\t},\n\t}, metav1.CreateOptions{})\n\n\tv := NewValidator(ctx, secretName)\n\n\trrd := remoteResolveDigest\n\tdefer func() {\n\t\tremoteResolveDigest = rrd\n\t}()\n\tresolve := func(ref name.Reference, opts ...remote.Option) (name.Digest, error) {\n\t\treturn digest.(name.Digest), nil\n\t}\n\n\ttests := []struct {\n\t\tname string\n\t\tc    *duckv1.CronJob\n\t\twant *duckv1.CronJob\n\t\twc   func(context.Context) context.Context\n\t\trrd  func(name.Reference, ...remote.Option) (name.Digest, error)\n\t}{{\n\t\tname: \"nothing changed (not the right update)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (bad reference)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}, {\n\t\tname: \"nothing changed (unable to resolve)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: \"in@valid\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twc: apis.WithinCreate,\n\t\trrd: func(r name.Reference, o ...remote.Option) (name.Digest, error) {\n\t\t\treturn name.Digest{}, errors.New(\"boom\")\n\t\t},\n\t}, {\n\t\tname: \"digests resolve (in create)\",\n\t\tc: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: tag.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &duckv1.CronJob{\n\t\t\tSpec: batchv1.CronJobSpec{\n\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{\n\t\t\t\t\tSpec: batchv1.JobSpec{\n\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{\n\t\t\t\t\t\t\tSpec: corev1.PodSpec{\n\t\t\t\t\t\t\t\tInitContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"setup-stuff\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\tContainers: []corev1.Container{{\n\t\t\t\t\t\t\t\t\tName:  \"user-container\",\n\t\t\t\t\t\t\t\t\tImage: digest.String(),\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twc:  apis.WithinCreate,\n\t\trrd: resolve,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tremoteResolveDigest = test.rrd\n\t\t\tctx := context.Background()\n\t\t\tif test.wc != nil {\n\t\t\t\tctx = test.wc(context.Background())\n\t\t\t}\n\n\t\t\tvar want runtime.Object\n\n\t\t\tcronJob := test.c.DeepCopy()\n\t\t\twant = test.want.DeepCopy()\n\t\t\tv.ResolveCronJob(ctx, cronJob)\n\t\t\tif !cmp.Equal(cronJob, want) {\n\t\t\t\tt.Errorf(\"ResolveCronJob = %s\", cmp.Diff(cronJob, want))\n\t\t\t}\n\n\t\t\t// Check that nothing happens when it's being deleted.\n\t\t\tcronJob = test.c.DeepCopy()\n\t\t\twant = cronJob.DeepCopy()\n\t\t\tv.ResolveCronJob(apis.WithinDelete(ctx), cronJob)\n\t\t\tif !cmp.Equal(cronJob, want) {\n\t\t\t\tt.Errorf(\"ResolveCronJob = %s\", cmp.Diff(cronJob, want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidatePolicy(t *testing.T) {\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\tctx, _ := rtesting.SetupFakeContext(t)\n\tsi := fakesecret.Get(ctx)\n\n\tsecretName := \"blah\"\n\n\t// Non-existent URL for testing complete failure\n\tbadURL := apis.HTTP(\"http://example.com/\")\n\tt.Logf(\"badURL: %s\", badURL.String())\n\n\t// Spin up a Fulcio that responds with a Root Cert\n\tfulcioServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(fulcioRootCert))\n\t}))\n\tt.Cleanup(fulcioServer.Close)\n\tfulcioURL, err := apis.ParseURL(fulcioServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Fulcio URL\")\n\t}\n\tt.Logf(\"fulcioURL: %s\", fulcioURL.String())\n\n\trekorServer := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(rekorResponse))\n\t}))\n\tt.Cleanup(rekorServer.Close)\n\trekorURL, err := apis.ParseURL(rekorServer.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse fake Rekor URL\")\n\t}\n\tt.Logf(\"rekorURL: %s\", rekorURL.String())\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\n\tsi.Informer().GetIndexer().Add(&corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: system.Namespace(),\n\t\t\tName:      secretName,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t// Random public key (cosign generate-key-pair) 2021-09-25\n\t\t\t\"cosign.pub\": []byte(`-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEapTW568kniCbL0OXBFIhuhOboeox\nUoJou2P8sbDxpLiE/v3yLw1/jyOrCPWYHWFXnyyeGlkgSVefG54tNoK7Uw==\n-----END PUBLIC KEY-----\n`),\n\t\t},\n\t})\n\n\tcvs := cosignVerifySignatures\n\tdefer func() {\n\t\tcosignVerifySignatures = cvs\n\t}()\n\t// Let's just say that everything is verified.\n\tpass := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tsig, err := static.NewSignature(nil, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is verified.\n\tpassKeyless := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\t// This is from 2022/07/29\n\t\t// ghcr.io/distroless/static@sha256:a1e82f6a5f6dfc735165d3442e7cc5a615f72abac3db19452481f5f3c90fbfa8\n\t\tpayload := []byte(`{\"payloadType\":\"application/vnd.in-toto+json\",\"payload\":\"eyJfdHlwZSI6Imh0dHBzOi8vaW4tdG90by5pby9TdGF0ZW1lbnQvdjAuMSIsInByZWRpY2F0ZVR5cGUiOiJjb3NpZ24uc2lnc3RvcmUuZGV2L2F0dGVzdGF0aW9uL3Z1bG4vdjEiLCJzdWJqZWN0IjpbeyJuYW1lIjoiZ2hjci5pby9kaXN0cm9sZXNzL3N0YXRpYyIsImRpZ2VzdCI6eyJzaGEyNTYiOiJhMWU4MmY2YTVmNmRmYzczNTE2NWQzNDQyZTdjYzVhNjE1ZjcyYWJhYzNkYjE5NDUyNDgxZjVmM2M5MGZiZmE4In19XSwicHJlZGljYXRlIjp7Imludm9jYXRpb24iOnsicGFyYW1ldGVycyI6bnVsbCwidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2Rpc3Ryb2xlc3Mvc3RhdGljL2FjdGlvbnMvcnVucy8yNzU3OTUzMTM5IiwiZXZlbnRfaWQiOiIyNzU3OTUzMTM5IiwiYnVpbGRlci5pZCI6IkNyZWF0ZSBSZWxlYXNlIn0sInNjYW5uZXIiOnsidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2FxdWFzZWN1cml0eS90cml2eSIsInZlcnNpb24iOiIwLjI5LjIiLCJkYiI6eyJ1cmkiOiIiLCJ2ZXJzaW9uIjoiIn0sInJlc3VsdCI6eyIkc2NoZW1hIjoiaHR0cHM6Ly9qc29uLnNjaGVtYXN0b3JlLm9yZy9zYXJpZi0yLjEuMC1ydG0uNS5qc29uIiwicnVucyI6W3siY29sdW1uS2luZCI6InV0ZjE2Q29kZVVuaXRzIiwib3JpZ2luYWxVcmlCYXNlSWRzIjp7IlJPT1RQQVRIIjp7InVyaSI6ImZpbGU6Ly8vIn19LCJyZXN1bHRzIjpbXSwidG9vbCI6eyJkcml2ZXIiOnsiZnVsbE5hbWUiOiJUcml2eSBWdWxuZXJhYmlsaXR5IFNjYW5uZXIiLCJpbmZvcm1hdGlvblVyaSI6Imh0dHBzOi8vZ2l0aHViLmNvbS9hcXVhc2VjdXJpdHkvdHJpdnkiLCJuYW1lIjoiVHJpdnkiLCJydWxlcyI6W10sInZlcnNpb24iOiIwLjI5LjIifX19XSwidmVyc2lvbiI6IjIuMS4wIn19LCJtZXRhZGF0YSI6eyJzY2FuU3RhcnRlZE9uIjoiMjAyMi0wNy0yOVQwMjoyODo0MloiLCJzY2FuRmluaXNoZWRPbiI6IjIwMjItMDctMjlUMDI6Mjg6NDhaIn19fQ==\",\"signatures\":[{\"keyid\":\"\",\"sig\":\"MEYCIQDeQXMMojIpNvxEDLDXUC5aAwCbPPr/0uckP8TCcdTLjgIhAJG6M00kY40bz/C90W0FeUc2YcWY+txD4BPXhzd8E+tP\"}]}`)\n\t\tset, err := base64.StdEncoding.DecodeString(\"MEQCIDBYWwwDW+nH+1vFoTOqHS4jAtVm4Yezq2nAy7vjcV8zAiBkznmgMrz9em4NuB/hl5X/umubhLgwoXgUAY2NJJwu5A==\")\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\tsig, err := static.NewSignature(payload, \"\", static.WithCertChain(\n\t\t\t[]byte(\"-----BEGIN CERTIFICATE-----\\nMIIDnDCCAyOgAwIBAgIUVGZ4TQgYi4VCLLFghYMU/taKrD8wCgYIKoZIzj0EAwMw\\nNzEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MR4wHAYDVQQDExVzaWdzdG9yZS1pbnRl\\ncm1lZGlhdGUwHhcNMjIwNzI5MDIyODQ4WhcNMjIwNzI5MDIzODQ4WjAAMFkwEwYH\\nKoZIzj0CAQYIKoZIzj0DAQcDQgAEhiVvK5Tqk1+HnXSstf/8byA1RDpZu+Jvn9X6\\nZoaCL/IjSJ7fBakvKAQ0BlzFg/JEtDreg/TFNiX2wnlMBlMV16OCAkIwggI+MA4G\\nA1UdDwEB/wQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQUiMn3\\nza+9v+99n385GpkXzZxZiBIwHwYDVR0jBBgwFoAU39Ppz1YkEZb5qNjpKFWixi4Y\\nZD8wYQYDVR0RAQH/BFcwVYZTaHR0cHM6Ly9naXRodWIuY29tL2Rpc3Ryb2xlc3Mv\\nc3RhdGljLy5naXRodWIvd29ya2Zsb3dzL3JlbGVhc2UueWFtbEByZWZzL2hlYWRz\\nL21haW4wOQYKKwYBBAGDvzABAQQraHR0cHM6Ly90b2tlbi5hY3Rpb25zLmdpdGh1\\nYnVzZXJjb250ZW50LmNvbTAWBgorBgEEAYO/MAECBAhzY2hlZHVsZTA2BgorBgEE\\nAYO/MAEDBCg3ZTc1NzJlNTc4ZGU3YzUxYTJmMWExNzkxZjAyNWNmMzE1NTAzYWEy\\nMBwGCisGAQQBg78wAQQEDkNyZWF0ZSBSZWxlYXNlMB8GCisGAQQBg78wAQUEEWRp\\nc3Ryb2xlc3Mvc3RhdGljMB0GCisGAQQBg78wAQYED3JlZnMvaGVhZHMvbWFpbjCB\\nigYKKwYBBAHWeQIEAgR8BHoAeAB2AAhgkvAoUv9oRdHRayeEnEVnGKwWPcM40m3m\\nvCIGNm9yAAABgkfI9c8AAAQDAEcwRQIgPm4AoftGQF2abbFxMLvtzTjXy+sxwxTp\\nCh5ZsoesBDMCIQCNlwmLpuu1KiqjY74l5527AffSd4kOapDMfpHAlMrpCTAKBggq\\nhkjOPQQDAwNnADBkAjAe7jfVc1OJNhbaZF8BJRJ9nQOAcY6kwFYMav1XfQsJPE0x\\naYpNg/oXVA5UrFcSBLkCMFa4124w3qUzrXSTGq99nlALKQ8HFR8ri17wM5/ZiWxi\\nrtABq5eub32TXpAnfqGSmw==\\n-----END CERTIFICATE-----\\n\"),\n\t\t\t[]byte(\"-----BEGIN CERTIFICATE-----\\nMIICGjCCAaGgAwIBAgIUALnViVfnU0brJasmRkHrn/UnfaQwCgYIKoZIzj0EAwMw\\nKjEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MREwDwYDVQQDEwhzaWdzdG9yZTAeFw0y\\nMjA0MTMyMDA2MTVaFw0zMTEwMDUxMzU2NThaMDcxFTATBgNVBAoTDHNpZ3N0b3Jl\\nLmRldjEeMBwGA1UEAxMVc2lnc3RvcmUtaW50ZXJtZWRpYXRlMHYwEAYHKoZIzj0C\\nAQYFK4EEACIDYgAE8RVS/ysH+NOvuDZyPIZtilgUF9NlarYpAd9HP1vBBH1U5CV7\\n7LSS7s0ZiH4nE7Hv7ptS6LvvR/STk798LVgMzLlJ4HeIfF3tHSaexLcYpSASr1kS\\n0N/RgBJz/9jWCiXno3sweTAOBgNVHQ8BAf8EBAMCAQYwEwYDVR0lBAwwCgYIKwYB\\nBQUHAwMwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU39Ppz1YkEZb5qNjp\\nKFWixi4YZD8wHwYDVR0jBBgwFoAUWMAeX5FFpWapesyQoZMi0CrFxfowCgYIKoZI\\nzj0EAwMDZwAwZAIwPCsQK4DYiZYDPIaDi5HFKnfxXx6ASSVmERfsynYBiX2X6SJR\\nnZU84/9DZdnFvvxmAjBOt6QpBlc4J/0DxvkTCqpclvziL6BCCPnjdlIB3Pu3BxsP\\nmygUY7Ii2zbdCdliiow=\\n-----END CERTIFICATE-----\\n-----BEGIN CERTIFICATE-----\\nMIIB9zCCAXygAwIBAgIUALZNAPFdxHPwjeDloDwyYChAO/4wCgYIKoZIzj0EAwMw\\nKjEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MREwDwYDVQQDEwhzaWdzdG9yZTAeFw0y\\nMTEwMDcxMzU2NTlaFw0zMTEwMDUxMzU2NThaMCoxFTATBgNVBAoTDHNpZ3N0b3Jl\\nLmRldjERMA8GA1UEAxMIc2lnc3RvcmUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAT7\\nXeFT4rb3PQGwS4IajtLk3/OlnpgangaBclYpsYBr5i+4ynB07ceb3LP0OIOZdxex\\nX69c5iVuyJRQ+Hz05yi+UF3uBWAlHpiS5sh0+H2GHE7SXrk1EC5m1Tr19L9gg92j\\nYzBhMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRY\\nwB5fkUWlZql6zJChkyLQKsXF+jAfBgNVHSMEGDAWgBRYwB5fkUWlZql6zJChkyLQ\\nKsXF+jAKBggqhkjOPQQDAwNpADBmAjEAj1nHeXZp+13NWBNa+EDsDP8G1WWg1tCM\\nWP/WHPqpaVo0jhsweNFZgSs0eE7wYI4qAjEA2WB9ot98sIkoF3vZYdd3/VtWB5b9\\nTNMea7Ix/stJ5TfcLLeABLE4BNJOsQ4vnBHJ\\n-----END CERTIFICATE-----\"),\n\t\t), static.WithBundle(&bundle.RekorBundle{\n\t\t\tSignedEntryTimestamp: set,\n\t\t\tPayload: bundle.RekorPayload{\n\t\t\t\tBody:           \"eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaW50b3RvIiwic3BlYyI6eyJjb250ZW50Ijp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIyYjY1Y2JmMGU3OTAxYmEzMWQ1NWIxMmQzMTliY2EzOTQyMGFmNDM4OGQzZTU3MTRkMTZmMjAxOWQ3NGUzYWI3In0sInBheWxvYWRIYXNoIjp7ImFsZ29yaXRobSI6InNoYTI1NiIsInZhbHVlIjoiYzFiNWYwZjRiOGVjZDU1ZWRhMjUwY2Q4NDk2NGQwYzFmYjVkN2E4YTM0OGY0YjdmZmI3ZGFhMmUwNmM0ODM3MyJ9fSwicHVibGljS2V5IjoiTFMwdExTMUNSVWRKVGlCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2sxSlNVUnVSRU5EUVhsUFowRjNTVUpCWjBsVlZrZGFORlJSWjFscE5GWkRURXhHWjJoWlRWVXZkR0ZMY2tRNGQwTm5XVWxMYjFwSmVtb3dSVUYzVFhjS1RucEZWazFDVFVkQk1WVkZRMmhOVFdNeWJHNWpNMUoyWTIxVmRWcEhWakpOVWpSM1NFRlpSRlpSVVVSRmVGWjZZVmRrZW1SSE9YbGFVekZ3WW01U2JBcGpiVEZzV2tkc2FHUkhWWGRJYUdOT1RXcEpkMDU2U1RWTlJFbDVUMFJSTkZkb1kwNU5ha2wzVG5wSk5VMUVTWHBQUkZFMFYycEJRVTFHYTNkRmQxbElDa3R2V2tsNmFqQkRRVkZaU1V0dldrbDZhakJFUVZGalJGRm5RVVZvYVZaMlN6VlVjV3N4SzBodVdGTnpkR1l2T0dKNVFURlNSSEJhZFN0S2RtNDVXRFlLV205aFEwd3ZTV3BUU2pkbVFtRnJka3RCVVRCQ2JIcEdaeTlLUlhSRWNtVm5MMVJHVG1sWU1uZHViRTFDYkUxV01UWlBRMEZyU1hkblowa3JUVUUwUndwQk1WVmtSSGRGUWk5M1VVVkJkMGxJWjBSQlZFSm5UbFpJVTFWRlJFUkJTMEpuWjNKQ1owVkdRbEZqUkVGNlFXUkNaMDVXU0ZFMFJVWm5VVlZwVFc0ekNucGhLemwyS3prNWJqTTROVWR3YTFoNlduaGFhVUpKZDBoM1dVUldVakJxUWtKbmQwWnZRVlV6T1ZCd2VqRlphMFZhWWpWeFRtcHdTMFpYYVhocE5Ga0tXa1E0ZDFsUldVUldVakJTUVZGSUwwSkdZM2RXV1ZwVVlVaFNNR05JVFRaTWVUbHVZVmhTYjJSWFNYVlpNamwwVERKU2NHTXpVbmxpTW5oc1l6Tk5kZ3BqTTFKb1pFZHNha3g1Tlc1aFdGSnZaRmRKZG1ReU9YbGhNbHB6WWpOa2Vrd3pTbXhpUjFab1l6SlZkV1ZYUm5SaVJVSjVXbGRhZWt3eWFHeFpWMUo2Q2t3eU1XaGhWelIzVDFGWlMwdDNXVUpDUVVkRWRucEJRa0ZSVVhKaFNGSXdZMGhOTmt4NU9UQmlNblJzWW1rMWFGa3pVbkJpTWpWNlRHMWtjR1JIYURFS1dXNVdlbHBZU21waU1qVXdXbGMxTUV4dFRuWmlWRUZYUW1kdmNrSm5SVVZCV1U4dlRVRkZRMEpCYUhwWk1taHNXa2hXYzFwVVFUSkNaMjl5UW1kRlJRcEJXVTh2VFVGRlJFSkRaek5hVkdNeFRucEtiRTVVWXpSYVIxVXpXWHBWZUZsVVNtMU5WMFY0VG5wcmVGcHFRWGxPVjA1dFRYcEZNVTVVUVhwWlYwVjVDazFDZDBkRGFYTkhRVkZSUW1jM09IZEJVVkZGUkd0T2VWcFhSakJhVTBKVFdsZDRiRmxZVG14TlFqaEhRMmx6UjBGUlVVSm5OemgzUVZGVlJVVlhVbkFLWXpOU2VXSXllR3hqTTAxMll6TlNhR1JIYkdwTlFqQkhRMmx6UjBGUlVVSm5OemgzUVZGWlJVUXpTbXhhYmsxMllVZFdhRnBJVFhaaVYwWndZbXBEUWdwcFoxbExTM2RaUWtKQlNGZGxVVWxGUVdkU09FSkliMEZsUVVJeVFVRm9aMnQyUVc5VmRqbHZVbVJJVW1GNVpVVnVSVlp1UjB0M1YxQmpUVFF3YlROdENuWkRTVWRPYlRsNVFVRkJRbWRyWmtrNVl6aEJRVUZSUkVGRlkzZFNVVWxuVUcwMFFXOW1kRWRSUmpKaFltSkdlRTFNZG5SNlZHcFllU3R6ZUhkNFZIQUtRMmcxV25OdlpYTkNSRTFEU1ZGRFRteDNiVXh3ZFhVeFMybHhhbGszTkd3MU5USTNRV1ptVTJRMGEwOWhjRVJOWm5CSVFXeE5jbkJEVkVGTFFtZG5jUXBvYTJwUFVGRlJSRUYzVG01QlJFSnJRV3BCWlRkcVpsWmpNVTlLVG1oaVlWcEdPRUpLVWtvNWJsRlBRV05aTm10M1JsbE5ZWFl4V0daUmMwcFFSVEI0Q21GWmNFNW5MMjlZVmtFMVZYSkdZMU5DVEd0RFRVWmhOREV5TkhjemNWVjZjbGhUVkVkeE9UbHViRUZNUzFFNFNFWlNPSEpwTVRkM1RUVXZXbWxYZUdrS2NuUkJRbkUxWlhWaU16SlVXSEJCYm1aeFIxTnRkejA5Q2kwdExTMHRSVTVFSUVORlVsUkpSa2xEUVZSRkxTMHRMUzBLIn19\",\n\t\t\t\tIntegratedTime: 1659061729,\n\t\t\t\tLogIndex:       3059470,\n\t\t\t\tLogID:          \"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d\",\n\t\t\t},\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn []oci.Signature{sig}, true, nil\n\t}\n\t// Let's just say that everything is not verified.\n\tfail := func(_ context.Context, _ name.Reference, _ *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\treturn nil, false, errors.New(\"bad signature\")\n\t}\n\n\t// Let's say it is verified if it is the expected Public Key\n\tauthorityPublicKeyCVS := func(ctx context.Context, signedImgRef name.Reference, co *cosign.CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t\tactualPublicKey, _ := co.SigVerifier.PublicKey()\n\t\tactualECDSAPubkey := actualPublicKey.(*ecdsa.PublicKey)\n\t\tactualKeyData := elliptic.Marshal(actualECDSAPubkey, actualECDSAPubkey.X, actualECDSAPubkey.Y)\n\n\t\texpectedKeyData := elliptic.Marshal(authorityKeyCosignPub, authorityKeyCosignPub.X, authorityKeyCosignPub.Y)\n\n\t\tif bytes.Equal(actualKeyData, expectedKeyData) {\n\t\t\treturn pass(ctx, signedImgRef, co)\n\t\t}\n\n\t\treturn fail(ctx, signedImgRef, co)\n\t}\n\n\ttests := []struct {\n\t\tname          string\n\t\tpolicy        webhookcip.ClusterImagePolicy\n\t\twant          *PolicyResult\n\t\twantErrs      []string\n\t\tcva           func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t\tcvs           func(context.Context, name.Reference, *cosign.CheckOpts) ([]oci.Signature, bool, error)\n\t\tcustomContext context.Context\n\t}{{\n\t\tname: \"simple, public key, no matches\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twantErrs: []string{\"key validation failed for authority authority-0 for gcr.io/distroless/static@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4: bad signature\"},\n\t\tcvs:      fail,\n\t}, {\n\t\tname: \"simple, public key, works\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tSignatures: []PolicySignature{{\n\t\t\t\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t},\n\t\tcvs: pass,\n\t}, {\n\t\tname: \"simple, public key and keyless, one works, one doesn't\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tName: \"authority-1\",\n\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\tURL: badURL,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tSignatures: []PolicySignature{{\n\t\t\t\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t},\n\t\twantErrs: []string{`fetching FulcioRoot: getting root cert: parse \"http://http:%2F%2Fexample.com%2F/api/v1/rootCert\": invalid port \":%2F%2Fexample.com%2F\" after host`},\n\t\tcvs:      authorityPublicKeyCVS,\n\t}, {\n\t\tname: \"simple, static set to pass\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tStatic: &webhookcip.StaticRef{\n\t\t\t\t\tAction: \"pass\",\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tStatic: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"simple, static set to fail\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tStatic: &webhookcip.StaticRef{\n\t\t\t\t\tAction: \"fail\",\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twantErrs: []string{\"disallowed by static policy\"},\n\t}, {\n\t\tname: \"simple, public key, no error\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tSignatures: []PolicySignature{{\n\t\t\t\t\t\t// TODO(mattmoor): Is there anything we should encode for key-based?\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t},\n\t\tcvs: authorityPublicKeyCVS,\n\t}, {\n\t\tname: \"simple, keyless attestation, works\",\n\t\tpolicy: webhookcip.ClusterImagePolicy{\n\t\t\tAuthorities: []webhookcip.Authority{{\n\t\t\t\tName: \"authority-0\",\n\t\t\t\tKeyless: &webhookcip.KeylessRef{\n\t\t\t\t\tURL: fulcioURL,\n\t\t\t\t},\n\t\t\t\tAttestations: []webhookcip.AttestationPolicy{{\n\t\t\t\t\tName:          \"test-att\",\n\t\t\t\t\tPredicateType: \"vuln\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: &PolicyResult{\n\t\t\tAuthorityMatches: map[string]AuthorityMatch{\n\t\t\t\t\"authority-0\": {\n\t\t\t\t\tAttestations: map[string][]PolicySignature{\n\t\t\t\t\t\t\"test-att\": {{\n\t\t\t\t\t\t\tSubject: \"https://github.com/distroless/static/.github/workflows/release.yaml@refs/heads/main\",\n\t\t\t\t\t\t\tIssuer:  \"https://token.actions.githubusercontent.com\",\n\t\t\t\t\t\t\tGithubExtensions: GithubExtensions{\n\t\t\t\t\t\t\t\tWorkflowTrigger: \"schedule\",\n\t\t\t\t\t\t\t\tWorkflowSHA:     \"7e7572e578de7c51a2f1a1791f025cf315503aa2\",\n\t\t\t\t\t\t\t\tWorkflowName:    \"Create Release\",\n\t\t\t\t\t\t\t\tWorkflowRepo:    \"distroless/static\",\n\t\t\t\t\t\t\t\tWorkflowRef:     \"refs/heads/main\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcva: passKeyless,\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcosignVerifySignatures = test.cvs\n\t\t\tcosignVerifyAttestations = test.cva\n\t\t\ttestContext := context.Background()\n\n\t\t\tif test.customContext != nil {\n\t\t\t\ttestContext = test.customContext\n\t\t\t}\n\t\t\tgot, gotErrs := ValidatePolicy(testContext, system.Namespace(), digest, test.policy)\n\t\t\tvalidateErrors(t, test.wantErrs, gotErrs)\n\t\t\tif !reflect.DeepEqual(test.want, got) {\n\t\t\t\tt.Errorf(\"unexpected PolicyResult, want: %+v got: %+v\", test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc validateErrors(t *testing.T, wantErr []string, got []error) {\n\tt.Helper()\n\tif len(wantErr) != len(got) {\n\t\tt.Errorf(\"Wanted %d errors got %d\", len(wantErr), len(got))\n\t} else {\n\t\tfor i, want := range wantErr {\n\t\t\tif !strings.Contains(got[i].Error(), want) {\n\t\t\t\tt.Errorf(\"Unwanted error at %d want: %s got: %s\", i, want, got[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestValidatePolicyCancelled(t *testing.T) {\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\ttestContext, cancelFunc := context.WithCancel(context.Background())\n\tcip := webhookcip.ClusterImagePolicy{\n\t\tAuthorities: []webhookcip.Authority{{\n\t\t\tName: \"authority-0\",\n\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t},\n\t\t}},\n\t}\n\twantErrs := []string{\"context canceled before validation completed\"}\n\tcancelFunc()\n\t_, gotErrs := ValidatePolicy(testContext, system.Namespace(), digest, cip)\n\tvalidateErrors(t, wantErrs, gotErrs)\n}\n\nfunc TestValidatePoliciesCancelled(t *testing.T) {\n\tvar authorityKeyCosignPub *ecdsa.PublicKey\n\tpems := parsePems([]byte(authorityKeyCosignPubString))\n\tif len(pems) > 0 {\n\t\tkey, _ := x509.ParsePKIXPublicKey(pems[0].Bytes)\n\t\tauthorityKeyCosignPub = key.(*ecdsa.PublicKey)\n\t} else {\n\t\tt.Errorf(\"Error parsing authority key from string\")\n\t}\n\t// Resolved via crane digest on 2021/09/25\n\tdigest := name.MustParseReference(\"gcr.io/distroless/static:nonroot@sha256:be5d77c62dbe7fedfb0a4e5ec2f91078080800ab1f18358e5f31fcc8faa023c4\")\n\n\ttestContext, cancelFunc := context.WithCancel(context.Background())\n\tcip := webhookcip.ClusterImagePolicy{\n\t\tAuthorities: []webhookcip.Authority{{\n\t\t\tName: \"authority-0\",\n\t\t\tKey: &webhookcip.KeyRef{\n\t\t\t\tPublicKeys: []crypto.PublicKey{authorityKeyCosignPub},\n\t\t\t},\n\t\t}},\n\t}\n\twantErrs := []string{\"context was canceled before validation completed\"}\n\tcancelFunc()\n\t_, gotErrs := validatePolicies(testContext, system.Namespace(), digest, map[string]webhookcip.ClusterImagePolicy{\"testcip\": cip})\n\tvalidateErrors(t, wantErrs, gotErrs[\"internalerror\"])\n}\n"], "buggy_code_start_loc": [613, 1514], "buggy_code_end_loc": [638, 1679], "fixing_code_start_loc": [612, 1514], "fixing_code_end_loc": [639, 1678], "type": "CWE-347", "message": "PolicyController is a utility used to enforce supply chain policy in Kubernetes clusters. In versions prior to 0.2.1 PolicyController will report a false positive, resulting in an admission when it should not be admitted when there is at least one attestation with a valid signature and there are NO attestations of the type being verified (--type defaults to \"custom\"). An example image that can be used to test this is `ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2`. Users should upgrade to version 0.2.1 to resolve this issue. There are no workarounds for users unable to upgrade.", "other": {"cve": {"id": "CVE-2022-35930", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-04T22:15:08.070", "lastModified": "2022-08-11T18:14:30.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PolicyController is a utility used to enforce supply chain policy in Kubernetes clusters. In versions prior to 0.2.1 PolicyController will report a false positive, resulting in an admission when it should not be admitted when there is at least one attestation with a valid signature and there are NO attestations of the type being verified (--type defaults to \"custom\"). An example image that can be used to test this is `ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2`. Users should upgrade to version 0.2.1 to resolve this issue. There are no workarounds for users unable to upgrade."}, {"lang": "es", "value": "PolicyController es una utilidad usada para hacer cumplir la pol\u00edtica de la cadena de suministro en los cl\u00fasteres de Kubernetes. En versiones anteriores a 0.2.1 PolicyController informar\u00e1 de un falso positivo, resultando en una admisi\u00f3n cuando no deber\u00eda ser admitida cuando se presenta al menos un atestado con una firma v\u00e1lida y NO se presentan atestados del tipo que est\u00e1 siendo verificado (--type por defecto es \"custom\"). Una imagen de ejemplo que puede usarse para probar esto es \"ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2\". Los usuarios deben actualizar a versi\u00f3n 0.2.1 para resolver este problema. No se presentan mitigaciones para usuarios que no puedan actualizar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sigstore:policy_controller:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.1", "matchCriteriaId": "2094DD15-32F7-460A-B4C7-2F2505CE44B7"}]}]}], "references": [{"url": "https://github.com/sigstore/policy-controller/commit/e852af36fb7d42678b21d7e97503c25bd1fd05c8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sigstore/policy-controller/releases/tag/v0.2.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/sigstore/policy-controller/security/advisories/GHSA-739f-hw6h-7wq8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sigstore/policy-controller/commit/e852af36fb7d42678b21d7e97503c25bd1fd05c8"}}