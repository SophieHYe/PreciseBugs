{"buggy_code": ["/**\n *\n * Rhonabwy JSON Web Encryption (JWE) library\n *\n * jwe.c: functions definitions\n *\n * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <string.h>\n#include <ctype.h>\n#include <gnutls/gnutls.h>\n#include <gnutls/crypto.h>\n#include <gnutls/abstract.h>\n#include <gnutls/x509.h>\n#include <orcania.h>\n#include <yder.h>\n#include <rhonabwy.h>\n\n#define R_TAG_MAX_SIZE 16\n\n#define _R_BLOCK_SIZE 256\n\n#define _R_PBES_DEFAULT_ITERATION 4096\n#define _R_PBES_DEFAULT_SALT_LENGTH 8\n#define _R_CURVE_MAX_SIZE 64\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\n#include <nettle/hmac.h>\n#include <nettle/aes.h>\n#include <nettle/memops.h>\n#include <nettle/bignum.h>\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\n#include <nettle/pss-mgf1.h>\n#include <nettle/rsa.h>\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030600\n#include <nettle/curve25519.h>\n#include <nettle/curve448.h>\n#include <nettle/eddsa.h>\n#include <nettle/ecdsa.h>\n#include <nettle/ecc.h>\n#include <nettle/ecc-curve.h>\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030600\n\nstatic int _r_concat_kdf(jwe_t * jwe, jwa_alg alg, const gnutls_datum_t * Z, gnutls_datum_t * kdf) {\n  int ret = RHN_OK;\n  struct _o_datum dat_apu = {0, NULL}, dat_apv = {0, NULL};\n  const char * alg_id = alg==R_JWA_ALG_ECDH_ES?r_jwa_enc_to_str(jwe->enc):r_jwa_alg_to_str(alg),\n             * apu = r_jwe_get_header_str_value(jwe, \"apu\"),\n             * apv = r_jwe_get_header_str_value(jwe, \"apv\");\n  size_t alg_id_len = o_strlen(alg_id), key_data_len = 0;\n\n  kdf->data = NULL;\n  kdf->size = 0;\n  do {\n    if ((kdf->data = o_malloc(4+Z->size)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error malloc kdf->data\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    memset(kdf->data, 0, 3);\n    memset(kdf->data+3, 1, 1);\n    memcpy(kdf->data+4, Z->data, Z->size);\n    kdf->size = 4+Z->size;\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4+alg_id_len)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (1)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    memset(kdf->data+kdf->size, 0, 3);\n    memset(kdf->data+kdf->size+3, (uint8_t)alg_id_len, 1);\n    memcpy(kdf->data+kdf->size+4, alg_id, alg_id_len);\n    kdf->size += 4+alg_id_len;\n\n    if (!o_strnullempty(apu)) {\n      if (!o_base64url_decode_alloc((const unsigned char *)apu, o_strlen(apu), &dat_apu)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error o_base64url_decode_alloc apu\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4+dat_apu.size)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (2)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    kdf->data[kdf->size] = (unsigned char)(dat_apu.size>>24) & 0xFF;\n    kdf->data[kdf->size+1] = (unsigned char)(dat_apu.size>>16) & 0xFF;\n    kdf->data[kdf->size+2] = (unsigned char)(dat_apu.size>>8) & 0xFF;\n    kdf->data[kdf->size+3] = (unsigned char)(dat_apu.size) & 0xFF;\n    if (dat_apu.size) {\n      memcpy(kdf->data+kdf->size+4, dat_apu.data, dat_apu.size);\n    }\n    kdf->size += dat_apu.size+4;\n\n    if (!o_strnullempty(apv)) {\n      if (!o_base64url_decode_alloc((const unsigned char *)apv, o_strlen(apv), &dat_apv)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error o_base64url_decode apv\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4+dat_apv.size)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (3)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    kdf->data[kdf->size] = (unsigned char)(dat_apv.size>>24) & 0xFF;\n    kdf->data[kdf->size+1] = (unsigned char)(dat_apv.size>>16) & 0xFF;\n    kdf->data[kdf->size+2] = (unsigned char)(dat_apv.size>>8) & 0xFF;\n    kdf->data[kdf->size+3] = (unsigned char)(dat_apv.size) & 0xFF;\n    if (dat_apv.size) {\n      memcpy(kdf->data+kdf->size+4, dat_apv.data, dat_apv.size);\n    }\n    kdf->size += dat_apv.size+4;\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      key_data_len = _r_get_key_size(jwe->enc)*8;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A128KW) {\n      key_data_len = 16*8;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A192KW) {\n      key_data_len = 24*8;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A256KW) {\n      key_data_len = 32*8;\n    }\n\n    if (!key_data_len) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error invalid keydatalen\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (4)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    kdf->data[kdf->size] = (unsigned char)(key_data_len>>24) & 0xFF;\n    kdf->data[kdf->size+1] = (unsigned char)(key_data_len>>16) & 0xFF;\n    kdf->data[kdf->size+2] = (unsigned char)(key_data_len>>8) & 0xFF;\n    kdf->data[kdf->size+3] = (unsigned char)(key_data_len) & 0xFF;\n    kdf->size += 4;\n\n  } while (0);\n\n  o_free(dat_apu.data);\n  o_free(dat_apv.data);\n\n  if (ret != RHN_OK) {\n    o_free(kdf->data);\n    kdf->data = NULL;\n    kdf->size = 0;\n  }\n\n  return ret;\n}\n\nstatic int _r_ecdh_compute(uint8_t * priv_d, size_t pub_d_size, uint8_t * pub_x, size_t pub_x_size, uint8_t * pub_y, size_t pub_y_size, const struct ecc_curve * curve, gnutls_datum_t * Z) {\n  int ret = RHN_OK;\n  struct ecc_scalar priv;\n  struct ecc_point pub, r;\n  mpz_t z_priv_d, z_pub_x, z_pub_y, r_x, r_y;\n  uint8_t r_x_u[64] = {0};\n  size_t r_x_u_len = 64;\n\n  mpz_init(z_priv_d);\n  mpz_init(z_pub_x);\n  mpz_init(z_pub_y);\n  mpz_init(r_x);\n  mpz_init(r_y);\n  ecc_scalar_init(&priv, curve);\n  ecc_point_init(&pub, curve);\n  ecc_point_init(&r, curve);\n  do {\n    mpz_import(z_priv_d, pub_d_size, 1, 1, 0, 0, priv_d);\n    if (!ecc_scalar_set(&priv, z_priv_d)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_ecdh_compute - Error ecc_scalar_set\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    mpz_import(z_pub_x, pub_x_size, 1, 1, 0, 0, pub_x);\n    mpz_import(z_pub_y, pub_y_size, 1, 1, 0, 0, pub_y);\n    if (!ecc_point_set(&pub, z_pub_x, z_pub_y)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_ecdh_compute - Error ecc_point_set\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    ecc_point_mul(&r, &priv, &pub);\n    ecc_point_get(&r, r_x, r_y);\n\n    mpz_export(r_x_u, &r_x_u_len, 1, 1, 0, 0, r_x);\n\n    if ((Z->data = gnutls_malloc(r_x_u_len)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_ecdh_compute - Error gnutls_malloc\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n    memcpy(Z->data, r_x_u, r_x_u_len);\n    Z->size = r_x_u_len;\n    ret = RHN_OK;\n  } while (0);\n  mpz_clear(z_priv_d);\n  mpz_clear(z_pub_x);\n  mpz_clear(z_pub_y);\n  mpz_clear(r_x);\n  mpz_clear(r_y);\n  ecc_scalar_clear(&priv);\n  ecc_point_clear(&pub);\n  ecc_point_clear(&r);\n\n  return ret;\n}\n\nstatic int _r_dh_compute(uint8_t * priv_k, uint8_t * pub_x, size_t crv_size, gnutls_datum_t * Z) {\n  int ret;\n  uint8_t q[CURVE448_SIZE] = {0};\n\n  if (crv_size == CURVE25519_SIZE) {\n    curve25519_mul(q, priv_k, pub_x);\n  } else {\n    curve448_mul(q, priv_k, pub_x);\n  }\n\n  if ((Z->data = gnutls_malloc(crv_size)) != NULL) {\n    memcpy(Z->data, q, crv_size);\n    Z->size = crv_size;\n    ret = RHN_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"_r_dh_compute - Error gnutls_malloc\");\n    ret = RHN_ERROR_MEMORY;\n  }\n\n  return ret;\n}\n#endif\n\n// https://git.lysator.liu.se/nettle/nettle/-/merge_requests/20\n#if NETTLE_VERSION_NUMBER >= 0x030400\nint\npkcs1_oaep_decrypt (size_t key_size,\n\t       const mpz_t m,\n\t       /* Hash function */\n\t       size_t hlen,\n\t       void * ctx, const struct nettle_hash *hash, nettle_hash_init_func *hash_init, nettle_hash_update_func *hash_update, nettle_hash_digest_func *hash_digest,\n\t       size_t label_length, const uint8_t *label,\n\t       size_t *length, uint8_t *message)\n{\n  int ret = 1;\n  size_t dbMask_len = key_size-1-hlen, i;\n  uint8_t lHash[hlen], k[hlen], seedMask[hlen], maskedSeed[hlen];\n\n  uint8_t *em, *maskedDB, *dbMask, *db;\n\n  em = o_malloc(key_size);\n  maskedDB = o_malloc(dbMask_len);\n  dbMask = o_malloc(dbMask_len);\n  db = o_malloc(dbMask_len);\n\n  // lHash = Hash(L)\n  hash_init(ctx);\n  hash_update(ctx, label_length, label);\n  hash_digest(ctx, hlen, lHash);\n\n  nettle_mpz_get_str_256(key_size, em, m);\n\n  if (em[0])\n    {\n      ret = 0;\n    }\n\n  memcpy(maskedSeed, em+1, hlen);\n  memcpy(maskedDB, em+1+hlen, key_size-1-hlen);\n\n  // seedMask = MGF(maskedDB, hLen).\n  hash_init(ctx);\n  hash_update(ctx, dbMask_len, maskedDB);\n  pss_mgf1(ctx, hash, hlen, seedMask);\n\n  // seed = maskedSeed \\xor seedMask.\n  for (i=0; i<hlen; i++)\n    {\n      k[i] = maskedSeed[i]^seedMask[i];\n    }\n\n  // dbMask = MGF(seed, k - hLen - 1).\n  hash_init(ctx);\n  hash_update(ctx, hlen, k);\n  pss_mgf1(ctx, hash, dbMask_len, dbMask);\n\n  // DB = maskedDB \\xor dbMask.\n  for (i=0; i<dbMask_len; i++)\n    {\n      db[i] = maskedDB[i]^dbMask[i];\n    }\n\n  if (!memeql_sec(db, lHash, hlen))\n    {\n      ret = 0;\n    }\n\n  for (i=hlen; i<dbMask_len-1; i++)\n    {\n      if (db[i] == 0x01)\n      {\n        break;\n      }\n    }\n\n  if (i < dbMask_len-1 && *length >= dbMask_len-i-1 && i < dbMask_len-1)\n  {\n    *length = dbMask_len-i-1;\n    memcpy(message, db+i+1, *length);\n  }\n  else\n  {\n    ret = 0;\n  }\n\n  o_free(em);\n  o_free(maskedDB);\n  o_free(dbMask);\n  o_free(db);\n\n  return ret;\n}\n\nint\nrsa_oaep_sha1_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha1_ctx ctx;\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA1_DIGEST_SIZE,\n                            &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}\n\nint\nrsa_oaep_sha256_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha256_ctx ctx;\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA256_DIGEST_SIZE,\n                            &ctx, &nettle_sha256, (nettle_hash_init_func*)&sha256_init, (nettle_hash_update_func*)&sha256_update, (nettle_hash_digest_func*)&sha256_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}\n\nint\npkcs1_oaep_encrypt (size_t key_size,\n\t       void *random_ctx, nettle_random_func *random,\n\t       /* Hash function */\n\t       size_t hlen,\n\t       void * ctx, const struct nettle_hash *hash, nettle_hash_init_func *hash_init, nettle_hash_update_func *hash_update, nettle_hash_digest_func *hash_digest,\n\t       size_t label_length, const uint8_t *label,\n\t       size_t message_length, const uint8_t *message,\n\t       mpz_t m)\n{\n  size_t ps_len = key_size - message_length - (2*hlen) - 2, dbMask_len = key_size - hlen - 1, i;\n  uint8_t lHash[hlen], k[hlen], seedMask[hlen], maskedSeed[hlen];\n  int ret = 1;\n\n  if (key_size < (2*hlen) - 2 || message_length > key_size - (2*hlen) - 2)\n    {\n      return 0;\n    }\n  uint8_t *em, *maskedDB, *dbMask, *db;\n\n  em = o_malloc(dbMask_len + hlen + 1);\n  maskedDB = o_malloc(dbMask_len);\n  dbMask = o_malloc(dbMask_len);\n  db = o_malloc(dbMask_len);\n\n  // lHash = Hash(L)\n  hash_init(ctx);\n  hash_update(ctx, label_length, label);\n  hash_digest(ctx, hlen, lHash);\n\n  // DB = lHash || PS || 0x01 || M.\n\n  memcpy(db, lHash, hlen);\n  memset(db+hlen, 0, ps_len);\n  memset(db+hlen+ps_len, 1, 1);\n  memcpy(db+hlen+ps_len+1, message, message_length);\n\n  random(random_ctx, hlen, k);\n\n  // dbMask = MGF(seed, k - hLen - 1).\n  hash_init(ctx);\n  hash_update(ctx, hlen, k);\n  pss_mgf1(ctx, hash, dbMask_len, dbMask);\n\n  // maskedDB = DB \\xor dbMask.\n  for (i=0; i<dbMask_len; i++)\n    {\n      maskedDB[i] = db[i]^dbMask[i];\n    }\n\n  // seedMask = MGF(maskedDB, hLen).\n  memset(seedMask, 0, hlen);\n  hash_init(ctx);\n  hash_update(ctx, dbMask_len, maskedDB);\n  pss_mgf1(ctx, hash, hlen, seedMask);\n\n  // maskedSeed = seed \\xor seedMask.\n  for (i=0; i<hlen; i++)\n    {\n      maskedSeed[i] = k[i]^seedMask[i];\n    }\n\n  // EM = 0x00 || maskedSeed || maskedDB.\n\n  em[0] = 0;\n  memcpy(em+1, maskedSeed, hlen);\n  memcpy(em+1+hlen, maskedDB, dbMask_len);\n\n  nettle_mpz_set_str_256_u(m, dbMask_len + hlen + 1, em);\n\n  o_free(db);\n  o_free(dbMask);\n  o_free(maskedDB);\n  o_free(em);\n\n  return ret;\n}\n\nint\nrsa_oaep_sha1_encrypt(const struct rsa_public_key *key,\n\t    void *random_ctx, nettle_random_func *random,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t length, const uint8_t *message,\n\t    mpz_t gibberish)\n{\n  struct sha1_ctx ctx;\n  if (pkcs1_oaep_encrypt (key->size, random_ctx, random,\n         SHA1_DIGEST_SIZE,\n         &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,\n         label_length, label,\n\t\t     length, message, gibberish))\n    {\n      mpz_powm(gibberish, gibberish, key->e, key->n);\n      return 1;\n    }\n  else\n    return 0;\n}\n\nint\nrsa_oaep_sha256_encrypt(const struct rsa_public_key *key,\n\t    void *random_ctx, nettle_random_func *random,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t length, const uint8_t *message,\n\t    mpz_t gibberish)\n{\n  struct sha256_ctx ctx;\n  if (pkcs1_oaep_encrypt (key->size, random_ctx, random,\n         SHA256_DIGEST_SIZE,\n         &ctx, &nettle_sha256, (nettle_hash_init_func*)&sha256_init, (nettle_hash_update_func*)&sha256_update, (nettle_hash_digest_func*)&sha256_digest,\n         label_length, label,\n\t\t     length, message, gibberish))\n    {\n      mpz_powm(gibberish, gibberish, key->e, key->n);\n      return 1;\n    }\n  else\n    return 0;\n}\n\nstatic void rnd_nonce_func(void *_ctx, size_t length, uint8_t * data)\n{\n  (void)_ctx;\n\tgnutls_rnd(GNUTLS_RND_NONCE, data, length);\n}\n#endif\n\n// https://git.lysator.liu.se/nettle/nettle/-/merge_requests/19\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic void\nnist_keywrap16(const void *ctx, nettle_cipher_func *encrypt,\n               const uint8_t *iv, size_t ciphertext_length,\n               uint8_t *ciphertext, const uint8_t *cleartext) {\n  uint8_t * R = NULL, A[8] = {0}, I[16] = {0}, B[16] = {0};\n  uint64_t A64;\n  size_t i, j, n;\n\n  if ((R = o_malloc(ciphertext_length-8)) == NULL)\n    return;\n\n  n = (ciphertext_length-8)/8;\n  memcpy(R, cleartext, (ciphertext_length-8));\n  memcpy(A, iv, 8);\n\n  for (j=0; j<6; j++) {\n    for (i=0; i<n; i++) {\n      // I = A | R[1]\n      memcpy(I, A, 8);\n      memcpy(I+8, R+(i*8), 8);\n\n      // B = AES(K, I)\n      encrypt(ctx, 16, B, I);\n\n      // A = MSB(64, B) ^ t where t = (n*j)+i\n      A64 = ((uint64_t)B[0] << 56) | ((uint64_t)B[1] << 48) | ((uint64_t)B[2] << 40) | ((uint64_t)B[3] << 32) | ((uint64_t)B[4] << 24) | ((uint64_t)B[5] << 16) | ((uint64_t)B[6] << 8) | (uint64_t)B[7];\n      A64 ^= (n*j)+(i+1);\n      A[7] = (uint8_t)A64;\n      A[6] = (uint8_t)(A64 >> 8);\n      A[5] = (uint8_t)(A64 >> 16);\n      A[4] = (uint8_t)(A64 >> 24);\n      A[3] = (uint8_t)(A64 >> 32);\n      A[2] = (uint8_t)(A64 >> 40);\n      A[1] = (uint8_t)(A64 >> 48);\n      A[0] = (uint8_t)(A64 >> 56);\n\n      //  R[i] = LSB(64, B)\n      memcpy(R+(i*8), B+8, 8);\n\n    }\n  }\n\n  memcpy(ciphertext, A, 8);\n  memcpy(ciphertext+8, R, (ciphertext_length-8));\n  o_free(R);\n}\n\nstatic int\nnist_keyunwrap16(const void *ctx, nettle_cipher_func *decrypt,\n                 const uint8_t *iv, size_t cleartext_length,\n                 uint8_t *cleartext, const uint8_t *ciphertext) {\n  uint8_t * R = NULL, A[8] = {0}, I[16] = {0}, B[16] = {0};\n  uint64_t A64;\n  int i, j, ret;\n  size_t n;\n\n  if ((R = o_malloc(cleartext_length)) == NULL)\n    return 0;\n\n  n = (cleartext_length/8);\n  memcpy(A, ciphertext, 8);\n  memcpy(R, ciphertext+8, cleartext_length);\n\n  for (j=5; j>=0; j--) {\n    for (i=n-1; i>=0; i--) {\n\n      // B = AES-1(K, (A ^ t) | R[i]) where t = n*j+i\n      A64 = ((uint64_t)A[0] << 56) | ((uint64_t)A[1] << 48) | ((uint64_t)A[2] << 40) | ((uint64_t)A[3] << 32) | ((uint64_t)A[4] << 24) | ((uint64_t)A[5] << 16) | ((uint64_t)A[6] << 8) | (uint64_t)A[7];\n      A64 ^= (n*j)+(i+1);\n      I[7] = (uint8_t)A64;\n      I[6] = (uint8_t)(A64 >> 8);\n      I[5] = (uint8_t)(A64 >> 16);\n      I[4] = (uint8_t)(A64 >> 24);\n      I[3] = (uint8_t)(A64 >> 32);\n      I[2] = (uint8_t)(A64 >> 40);\n      I[1] = (uint8_t)(A64 >> 48);\n      I[0] = (uint8_t)(A64 >> 56);\n      memcpy(I+8, R+(i*8), 8);\n      decrypt(ctx, 16, B, I);\n\n      // A = MSB(64, B)\n      memcpy(A, B, 8);\n\n      // R[i] = LSB(64, B)\n      memcpy(R+(i*8), B+8, 8);\n    }\n  }\n\n  if (memeql_sec(A, iv, 8)) {\n    memcpy(cleartext, R, cleartext_length);\n    ret = 1;\n  } else {\n    ret = 0;\n  }\n  o_free(R);\n  return ret;\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic int _r_rsa_oaep_encrypt(gnutls_pubkey_t g_pub, jwa_alg alg, uint8_t * cleartext, size_t cleartext_len, uint8_t * ciphertext, size_t * cyphertext_len) {\n  struct rsa_public_key pub;\n  gnutls_datum_t m = {NULL, 0}, e = {NULL, 0};\n  int ret = RHN_OK;\n  mpz_t gibberish;\n\n  rsa_public_key_init(&pub);\n  mpz_init(gibberish);\n  if (gnutls_pubkey_export_rsa_raw(g_pub, &m, &e) == GNUTLS_E_SUCCESS) {\n    mpz_import(pub.n, m.size, 1, 1, 0, 0, m.data);\n    mpz_import(pub.e, e.size, 1, 1, 0, 0, e.data);\n    rsa_public_key_prepare(&pub);\n    if (*cyphertext_len >= pub.size) {\n      if (alg == R_JWA_ALG_RSA_OAEP) {\n        if (!rsa_oaep_sha1_encrypt(&pub, NULL, rnd_nonce_func, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error rsa_oaep_sha1_encrypt\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        if (!rsa_oaep_sha256_encrypt(&pub, NULL, rnd_nonce_func, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error rsa_oaep_sha256_encrypt\");\n          ret = RHN_ERROR;\n        }\n      }\n      if (ret == RHN_OK) {\n        nettle_mpz_get_str_256(pub.size, ciphertext, gibberish);\n        *cyphertext_len = pub.size;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error cyphertext to small\");\n      ret = RHN_ERROR_PARAM;\n    }\n    gnutls_free(m.data);\n    gnutls_free(e.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error gnutls_pubkey_export_rsa_raw\");\n    ret = RHN_ERROR;\n  }\n  rsa_public_key_clear(&pub);\n  mpz_clear(gibberish);\n\n  return ret;\n}\n\nstatic int _r_rsa_oaep_decrypt(gnutls_privkey_t g_priv, jwa_alg alg, uint8_t * ciphertext, size_t cyphertext_len, uint8_t * cleartext, size_t * cleartext_len) {\n  struct rsa_private_key priv;\n  gnutls_datum_t m = {NULL, 0}, e = {NULL, 0}, d = {NULL, 0}, p = {NULL, 0}, q = {NULL, 0}, u = {NULL, 0}, e1 = {NULL, 0}, e2 = {NULL, 0};\n  int ret = RHN_OK;\n  mpz_t gibberish;\n\n  rsa_private_key_init(&priv);\n  mpz_init(gibberish);\n  nettle_mpz_set_str_256_u(gibberish, cyphertext_len, ciphertext);\n  if (gnutls_privkey_export_rsa_raw(g_priv, &m, &e, &d, &p, &q, &u, &e1, &e2) == GNUTLS_E_SUCCESS) {\n    mpz_import(priv.d, d.size, 1, 1, 0, 0, d.data);\n    mpz_import(priv.p, p.size, 1, 1, 0, 0, p.data);\n    mpz_import(priv.q, q.size, 1, 1, 0, 0, q.data);\n    mpz_import(priv.a, e1.size, 1, 1, 0, 0, e1.data);\n    mpz_import(priv.b, e2.size, 1, 1, 0, 0, e2.data);\n    mpz_import(priv.c, u.size, 1, 1, 0, 0, u.data);\n    rsa_private_key_prepare(&priv);\n    if (cyphertext_len >= priv.size) {\n      if (alg == R_JWA_ALG_RSA_OAEP) {\n        if (!rsa_oaep_sha1_decrypt(&priv, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_decrypt - Error rsa_oaep_sha1_decrypt\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        if (!rsa_oaep_sha256_decrypt(&priv, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_decrypt - Error rsa_oaep_sha256_decrypt\");\n          ret = RHN_ERROR;\n        }\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error cyphertext to small\");\n      ret = RHN_ERROR_PARAM;\n    }\n    gnutls_free(m.data);\n    gnutls_free(e.data);\n    gnutls_free(d.data);\n    gnutls_free(p.data);\n    gnutls_free(q.data);\n    gnutls_free(u.data);\n    gnutls_free(e1.data);\n    gnutls_free(e2.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error gnutls_pubkey_export_rsa_raw\");\n    ret = RHN_ERROR;\n  }\n  rsa_private_key_clear(&priv);\n  mpz_clear(gibberish);\n\n  return ret;\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic void _r_aes_key_wrap(uint8_t * kek, size_t kek_len, uint8_t * key, size_t key_len, uint8_t * wrapped_key) {\n  struct aes128_ctx ctx_128;\n  struct aes192_ctx ctx_192;\n  struct aes256_ctx ctx_256;\n  void * ctx = NULL;\n  nettle_cipher_func * encrypt = NULL;\n  const uint8_t default_iv[] = {0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6};\n\n  if (kek_len == 16) {\n    aes128_set_encrypt_key(&ctx_128, kek);\n    ctx = (void*)&ctx_128;\n    encrypt = (nettle_cipher_func*)&aes128_encrypt;\n  }\n  if (kek_len == 24) {\n    aes192_set_encrypt_key(&ctx_192, kek);\n    ctx = (void*)&ctx_192;\n    encrypt = (nettle_cipher_func*)&aes192_encrypt;\n  }\n  if (kek_len == 32) {\n    aes256_set_encrypt_key(&ctx_256, kek);\n    ctx = (void*)&ctx_256;\n    encrypt = (nettle_cipher_func*)&aes256_encrypt;\n  }\n  nist_keywrap16(ctx, encrypt, default_iv, key_len+8, wrapped_key, key);\n}\n\nstatic int _r_aes_key_unwrap(uint8_t * kek, size_t kek_len, uint8_t * key, size_t key_len, uint8_t * wrapped_key) {\n  struct aes128_ctx ctx_128;\n  struct aes192_ctx ctx_192;\n  struct aes256_ctx ctx_256;\n  void * ctx = NULL;\n  nettle_cipher_func * decrypt = NULL;\n  const uint8_t default_iv[] = {0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6};\n\n  if (kek_len == 16) {\n    aes128_set_decrypt_key(&ctx_128, kek);\n    ctx = (void*)&ctx_128;\n    decrypt = (nettle_cipher_func*)&aes128_decrypt;\n  }\n  if (kek_len == 24) {\n    aes192_set_decrypt_key(&ctx_192, kek);\n    ctx = (void*)&ctx_192;\n    decrypt = (nettle_cipher_func*)&aes192_decrypt;\n  }\n  if (kek_len == 32) {\n    aes256_set_decrypt_key(&ctx_256, kek);\n    ctx = (void*)&ctx_256;\n    decrypt = (nettle_cipher_func*)&aes256_decrypt;\n  }\n  return nist_keyunwrap16(ctx, decrypt, default_iv, key_len, key, wrapped_key);\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030600\nstatic json_t * _r_jwe_ecdh_encrypt(jwe_t * jwe, jwa_alg alg, jwk_t * jwk_pub, jwk_t * jwk_priv, int type, unsigned int bits, int x5u_flags, int * ret) {\n  int type_priv = 0;\n  unsigned int bits_priv = 0;\n  jwk_t * jwk_ephemeral = NULL, * jwk_ephemeral_pub = NULL;\n  gnutls_datum_t Z = {NULL, 0}, kdf = {NULL, 0};\n  unsigned char cipherkey_b64url[256] = {0};\n  uint8_t derived_key[64] = {0}, wrapped_key[72] = {0}, priv_k[_R_CURVE_MAX_SIZE] = {0}, pub_x[_R_CURVE_MAX_SIZE] = {0}, pub_y[_R_CURVE_MAX_SIZE] = {0};\n  size_t derived_key_len = 0, cipherkey_b64url_len = 0, priv_k_size = 0, pub_x_size = 0, pub_y_size = 0, crv_size = 0;\n  const char * key = NULL;\n  json_t * j_return = NULL;\n  const struct ecc_curve * nettle_curve;\n\n  do {\n    if (r_jwk_init(&jwk_ephemeral_pub) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error r_jwk_init jwk_ephemeral_pub\");\n      *ret = RHN_ERROR;\n      break;\n    }\n\n    if (jwk_priv != NULL) {\n      type_priv = r_jwk_key_type(jwk_priv, &bits_priv, x5u_flags);\n\n      if ((type_priv & 0xffffff00) != (type & 0xffffff00)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error invalid ephemeral key\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (bits != bits_priv) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error invalid ephemeral key length\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (r_jwk_extract_pubkey(jwk_priv, jwk_ephemeral_pub, x5u_flags) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error extracting public key from jwk_priv\");\n        *ret = RHN_ERROR;\n        break;\n      }\n    } else {\n      if (r_jwk_init(&jwk_ephemeral) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error r_jwk_init jwk_ephemeral\");\n        *ret = RHN_ERROR;\n        break;\n      }\n\n      if (r_jwk_generate_key_pair(jwk_ephemeral, jwk_ephemeral_pub, type&R_KEY_TYPE_EC?R_KEY_TYPE_EC:R_KEY_TYPE_ECDH, bits, NULL) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error r_jwk_generate_key_pair\");\n        *ret = RHN_ERROR;\n        break;\n      }\n\n      r_jwk_delete_property_str(jwk_ephemeral_pub, \"kid\");\n    }\n\n    if (type & R_KEY_TYPE_EC) {\n      if (bits == 256) {\n        nettle_curve = nettle_get_secp_256r1();\n        crv_size = 32;\n      } else if (bits == 384) {\n        nettle_curve = nettle_get_secp_384r1();\n        crv_size = 48;\n      } else {\n        nettle_curve = nettle_get_secp_521r1();\n        crv_size = 64;\n      }\n\n      if (jwk_priv != NULL) {\n        key = r_jwk_get_property_str(jwk_priv, \"d\");\n      } else {\n        key = r_jwk_get_property_str(jwk_ephemeral, \"d\");\n      }\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid priv_k_size (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid pub_x_size (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_pub, \"y\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode y (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_y_size || pub_y_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid pub_y_size (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_y, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode y (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_ecdh_compute(priv_k, priv_k_size, pub_x, pub_x_size, pub_y, pub_y_size, nettle_curve, &Z) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error _r_ecdh_compute (ecdsa)\");\n        *ret = RHN_ERROR;\n        break;\n      }\n    } else {\n      if (bits == 256) {\n        crv_size = CURVE25519_SIZE;\n      } else {\n        crv_size = CURVE448_SIZE;\n      }\n\n      if (jwk_priv != NULL) {\n        key = r_jwk_get_property_str(jwk_priv, \"d\");\n      } else {\n        key = r_jwk_get_property_str(jwk_ephemeral, \"d\");\n      }\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid priv_k_size (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      pub_x_size = CURVE448_SIZE;\n      key = r_jwk_get_property_str(jwk_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid pub_x_size (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_dh_compute(priv_k, pub_x, crv_size, &Z) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error _r_dh_compute (eddsa)\");\n        *ret = RHN_ERROR;\n        break;\n      }\n    }\n\n\n    if (_r_concat_kdf(jwe, alg, &Z, &kdf) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error _r_concat_kdf\");\n      *ret = RHN_ERROR;\n      break;\n    }\n\n    if (gnutls_hash_fast(GNUTLS_DIG_SHA256, kdf.data, kdf.size, derived_key) != GNUTLS_E_SUCCESS) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error gnutls_hash_fast\");\n      *ret = RHN_ERROR;\n      break;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      derived_key_len = _r_get_key_size(jwe->enc);\n    } else if (alg == R_JWA_ALG_ECDH_ES_A128KW) {\n      derived_key_len = 16;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A192KW) {\n      derived_key_len = 24;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A256KW) {\n      derived_key_len = 32;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      r_jwe_set_cypher_key(jwe, derived_key, derived_key_len);\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      j_return = json_pack(\"{s{ss so}}\", \"header\",\n                                           \"alg\", r_jwa_alg_to_str(alg),\n                                           \"epk\", r_jwk_export_to_json_t(jwk_ephemeral_pub));\n    } else {\n      _r_aes_key_wrap(derived_key, derived_key_len, jwe->key, jwe->key_len, wrapped_key);\n      if (!o_base64url_encode(wrapped_key, jwe->key_len+8, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_encode wrapped_key\");\n        *ret = RHN_ERROR;\n      }\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = (unsigned char *)o_strndup((const char *)cipherkey_b64url, cipherkey_b64url_len);\n      j_return = json_pack(\"{ss%s{ss so}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len,\n                                             \"header\",\n                                               \"alg\", r_jwa_alg_to_str(alg),\n                                               \"epk\", r_jwk_export_to_json_t(jwk_ephemeral_pub));\n    }\n  } while (0);\n\n  o_free(kdf.data);\n  gnutls_free(Z.data);\n  r_jwk_free(jwk_ephemeral);\n  r_jwk_free(jwk_ephemeral_pub);\n\n  return j_return;\n}\n\nstatic int _r_jwe_ecdh_decrypt(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int type, unsigned int bits, int x5u_flags) {\n  int ret = RHN_OK;\n  jwk_t * jwk_ephemeral_pub = NULL;\n  json_t * j_epk = NULL;\n  unsigned int epk_bits = 0;\n  gnutls_datum_t Z = {NULL, 0}, kdf = {NULL, 0};\n  uint8_t derived_key[64] = {0}, key_data[72] = {0}, cipherkey[128] = {0}, priv_k[_R_CURVE_MAX_SIZE] = {0}, pub_x[_R_CURVE_MAX_SIZE] = {0}, pub_y[_R_CURVE_MAX_SIZE] = {0};\n  size_t derived_key_len = 0, cipherkey_len = 0, priv_k_size = 0, pub_x_size = 0, pub_y_size = 0, crv_size = 0;\n  const char * key = NULL;\n  const struct ecc_curve * nettle_curve;\n\n  do {\n    if ((j_epk = r_jwe_get_header_json_t_value(jwe, \"epk\")) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - No epk header\");\n      ret = RHN_ERROR_PARAM;\n      break;\n    }\n\n    if (r_jwk_init(&jwk_ephemeral_pub) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error r_jwk_init\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if (r_jwk_import_from_json_t(jwk_ephemeral_pub, j_epk) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error r_jwk_import_from_json_t\");\n      ret = RHN_ERROR_PARAM;\n      break;\n    }\n\n    if (type & R_KEY_TYPE_EC) {\n      if (!(r_jwk_key_type(jwk_ephemeral_pub, &epk_bits, x5u_flags) & (R_KEY_TYPE_EC|R_KEY_TYPE_PUBLIC)) || epk_bits != bits) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error invalid private key type (ecc)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (bits == 256) {\n        nettle_curve = nettle_get_secp_256r1();\n        crv_size = 32;\n      } else if (bits == 384) {\n        nettle_curve = nettle_get_secp_384r1();\n        crv_size = 48;\n      } else {\n        nettle_curve = nettle_get_secp_521r1();\n        crv_size = 64;\n      }\n\n      key = r_jwk_get_property_str(jwk, \"d\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid priv_k_size (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_ephemeral_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid pub_x_size (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_ephemeral_pub, \"y\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode y (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_y_size || pub_y_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid pub_y_size (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_y, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode y (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_ecdh_compute(priv_k, priv_k_size, pub_x, pub_x_size, pub_y, pub_y_size, nettle_curve, &Z) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error _r_ecdh_compute (ecdsa)\");\n        ret = RHN_ERROR;\n        break;\n      }\n    } else {\n      if (!(r_jwk_key_type(jwk_ephemeral_pub, &epk_bits, x5u_flags) & (R_KEY_TYPE_ECDH|R_KEY_TYPE_PUBLIC)) || epk_bits != bits) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error invalid private key type (eddsa)\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n\n      if (bits == 256) {\n        crv_size = CURVE25519_SIZE;\n      } else {\n        crv_size = CURVE448_SIZE;\n      }\n\n      key = r_jwk_get_property_str(jwk, \"d\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid priv_k_size (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_ephemeral_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid priv_k_size (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_dh_compute(priv_k, pub_x, crv_size, &Z) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error _r_dh_compute (eddsa)\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n\n    if (_r_concat_kdf(jwe, alg, &Z, &kdf) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error _r_concat_kdf\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if (gnutls_hash_fast(GNUTLS_DIG_SHA256, kdf.data, kdf.size, derived_key) != GNUTLS_E_SUCCESS) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error gnutls_hash_fast\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      derived_key_len = _r_get_key_size(jwe->enc);\n    } else if (alg == R_JWA_ALG_ECDH_ES_A128KW) {\n      derived_key_len = 16;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A192KW) {\n      derived_key_len = 24;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A256KW) {\n      derived_key_len = 32;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      r_jwe_set_cypher_key(jwe, derived_key, derived_key_len);\n    } else {\n      if (o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) {\n        if (_r_aes_key_unwrap(derived_key, derived_key_len, key_data, cipherkey_len-8, cipherkey)) {\n          r_jwe_set_cypher_key(jwe, key_data, cipherkey_len-8);\n        } else {\n          ret = RHN_ERROR_INVALID;\n          break;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n  } while (0);\n\n  o_free(kdf.data);\n  gnutls_free(Z.data);\n  r_jwk_free(jwk_ephemeral_pub);\n  json_decref(j_epk);\n\n  return ret;\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic json_t * r_jwe_aes_key_wrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  uint8_t kek[32] = {0}, wrapped_key[72] = {0};\n  unsigned char cipherkey_b64url[256] = {0};\n  size_t kek_len = 32, cipherkey_b64url_len = 0;\n  unsigned int bits = 0;\n  json_t * j_return = NULL;\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    do {\n      if (alg == R_JWA_ALG_A128KW && bits != 128) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key size, expected 128 bits\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (alg == R_JWA_ALG_A192KW && bits != 192) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key size, expected 192 bits\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (alg == R_JWA_ALG_A256KW && bits != 256) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key size, expected 256 bits\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, kek, &kek_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error r_jwk_export_to_symmetric_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      _r_aes_key_wrap(kek, kek_len, jwe->key, jwe->key_len, wrapped_key);\n      if (!o_base64url_encode(wrapped_key, jwe->key_len+8, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error o_base64url_encode wrapped_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      j_return = json_pack(\"{ss%s{ss}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len, \"header\", \"alg\", r_jwa_alg_to_str(alg));\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = (unsigned char *)o_strndup((const char *)cipherkey_b64url, cipherkey_b64url_len);\n    } while (0);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key\");\n    *ret = RHN_ERROR_PARAM;\n  }\n  return j_return;\n}\n\nstatic int r_jwe_aes_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  int ret;\n  uint8_t kek[32] = {0}, key_data[64], cipherkey[128] = {0};\n  size_t kek_len = 32, cipherkey_len = 0;\n  unsigned int bits = 0;\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    ret = RHN_OK;\n\n    do {\n      if (alg == R_JWA_ALG_A128KW && bits != 128) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key size, expected 128 bits\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (alg == R_JWA_ALG_A192KW && bits != 192) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key size, expected 192 bits\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (alg == R_JWA_ALG_A256KW && bits != 256) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key size, expected 256 bits\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, kek, &kek_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error r_jwk_export_to_symmetric_key\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), NULL, &cipherkey_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (cipherkey_len > 72) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid cipherkey len\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (!o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (!_r_aes_key_unwrap(kek, kek_len, key_data, cipherkey_len-8, cipherkey)) {\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwe_set_cypher_key(jwe, key_data, cipherkey_len-8) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error r_jwe_set_cypher_key\");\n        ret = RHN_ERROR;\n      }\n    } while (0);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key\");\n    ret = RHN_ERROR_INVALID;\n  }\n  return ret;\n}\n#endif\n\n#if GNUTLS_VERSION_NUMBER >= 0x03060d\nstatic json_t * r_jwe_pbes2_key_wrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  unsigned char salt_seed[_R_PBES_DEFAULT_SALT_LENGTH] = {0}, salt_seed_b64[_R_PBES_DEFAULT_SALT_LENGTH*2], * salt = NULL, kek[64] = {0}, * key = NULL, wrapped_key[72] = {0}, cipherkey_b64url[256] = {0};\n  size_t alg_len, salt_len, key_len = 0, cipherkey_b64url_len = 0, salt_seed_b64_len = 0, kek_len = 0;\n  const char * p2s = NULL;\n  unsigned int p2c = 0, bits = 0;\n  gnutls_datum_t password = {NULL, 0}, g_salt = {NULL, 0};\n  gnutls_mac_algorithm_t mac = GNUTLS_MAC_UNKNOWN;\n  json_t * j_return = NULL;\n  struct _o_datum dat_dec = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    do {\n      alg_len = o_strlen(r_jwa_alg_to_str(alg));\n      if ((p2s = r_jwe_get_header_str_value(jwe, \"p2s\")) != NULL) {\n        if (!o_base64url_decode_alloc((const unsigned char *)p2s, o_strlen(p2s), &dat_dec)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_base64url_decode_alloc p2s\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        if (dat_dec.size < 8) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error invalid p2s length\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        salt_len = dat_dec.size + alg_len + 1;\n        if ((salt = o_malloc(salt_len)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_malloc salt (1)\");\n          *ret = RHN_ERROR_MEMORY;\n          break;\n        }\n        memcpy(salt, r_jwa_alg_to_str(alg), alg_len);\n        memset(salt+alg_len, 0, 1);\n        memcpy(salt+alg_len+1, dat_dec.data, dat_dec.size);\n      } else {\n        if (gnutls_rnd(GNUTLS_RND_NONCE, salt_seed, _R_PBES_DEFAULT_SALT_LENGTH)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error gnutls_rnd\");\n          *ret = RHN_ERROR;\n          break;\n        }\n        salt_len = _R_PBES_DEFAULT_SALT_LENGTH + alg_len + 1;\n        if ((salt = o_malloc(salt_len)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_malloc salt (2)\");\n          *ret = RHN_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64url_encode(salt_seed, _R_PBES_DEFAULT_SALT_LENGTH, salt_seed_b64, &salt_seed_b64_len)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_base64url_encode salt_seed\");\n          *ret = RHN_ERROR;\n          break;\n        }\n        salt_seed_b64[salt_seed_b64_len] = '\\0';\n\n        memcpy(salt, r_jwa_alg_to_str(alg), alg_len);\n        memset(salt+alg_len, 0, 1);\n        memcpy(salt+alg_len+1, salt_seed, _R_PBES_DEFAULT_SALT_LENGTH);\n      }\n      if ((p2c = (unsigned int)r_jwe_get_header_int_value(jwe, \"p2c\")) <= 0) {\n        p2c = _R_PBES_DEFAULT_ITERATION;\n      }\n\n      key_len = (bits/8)+4;\n      if ((key = o_malloc(key_len)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_malloc key\");\n        *ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error r_jwk_export_to_symmetric_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      password.data = key;\n      password.size = key_len;\n      g_salt.data = salt;\n      g_salt.size = salt_len;\n      if (alg == R_JWA_ALG_PBES2_H256) {\n        kek_len = 16;\n        mac = GNUTLS_MAC_SHA256;\n      } else if (alg == R_JWA_ALG_PBES2_H384) {\n        kek_len = 24;\n        mac = GNUTLS_MAC_SHA384;\n      } else if (alg == R_JWA_ALG_PBES2_H512) {\n        kek_len = 32;\n        mac = GNUTLS_MAC_SHA512;\n      }\n      if (gnutls_pbkdf2(mac, &password, &g_salt, p2c, kek, kek_len) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error gnutls_pbkdf2\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      _r_aes_key_wrap(kek, kek_len, jwe->key, jwe->key_len, wrapped_key);\n      if (!o_base64url_encode(wrapped_key, jwe->key_len+8, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error o_base64url_encode wrapped_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      j_return = json_pack(\"{ss%s{sssssi}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len,\n                                             \"header\",\n                                               \"alg\", r_jwa_alg_to_str(alg),\n                                               \"p2s\", p2s!=NULL?p2s:(const char*)salt_seed_b64,\n                                               \"p2c\", p2c);\n    } while (0);\n    o_free(key);\n    o_free(salt);\n    o_free(dat_dec.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error invalid key\");\n  }\n  return j_return;\n}\n\nstatic int r_jwe_pbes2_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  unsigned char * salt = NULL, kek[64] = {0}, * key = NULL, cipherkey[128] = {0}, key_data[64] = {0};\n  size_t alg_len, salt_len, key_len = 0, cipherkey_len = 0, kek_len = 0;\n  int ret;\n  const char * p2s;\n  unsigned int p2c, bits = 0;\n  gnutls_datum_t password = {NULL, 0}, g_salt = {NULL, 0};\n  gnutls_mac_algorithm_t mac = GNUTLS_MAC_UNKNOWN;\n  struct _o_datum dat_dec = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    ret = RHN_OK;\n\n    do {\n      alg_len = o_strlen(r_jwe_get_header_str_value(jwe, \"alg\"));\n      if ((p2c = (unsigned int)r_jwe_get_header_int_value(jwe, \"p2c\")) <= 0) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error invalid p2c\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (o_strlen(r_jwe_get_header_str_value(jwe, \"p2s\")) < 8) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error invalid p2s\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n      p2s = r_jwe_get_header_str_value(jwe, \"p2s\");\n      if (!o_base64url_decode_alloc((const unsigned char *)p2s, o_strlen(p2s), &dat_dec)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_base64url_decode_alloc p2s\");\n        ret = RHN_ERROR;\n        break;\n      }\n      salt_len = dat_dec.size + alg_len + 1;\n      if ((salt = o_malloc(salt_len)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_malloc salt\");\n        ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      memcpy(salt, r_jwe_get_header_str_value(jwe, \"alg\"), alg_len);\n      memset(salt+alg_len, 0, 1);\n      memcpy(salt+alg_len+1, dat_dec.data, dat_dec.size);\n\n      key_len = (bits/8)+4;\n      if ((key = o_malloc(key_len)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_malloc key\");\n        ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error r_jwk_export_to_symmetric_key\");\n        ret = RHN_ERROR;\n        break;\n      }\n      password.data = key;\n      password.size = key_len;\n      g_salt.data = salt;\n      g_salt.size = salt_len;\n      if (alg == R_JWA_ALG_PBES2_H256) {\n        kek_len = 16;\n        mac = GNUTLS_MAC_SHA256;\n      } else if (alg == R_JWA_ALG_PBES2_H384) {\n        kek_len = 24;\n        mac = GNUTLS_MAC_SHA384;\n      } else if (alg == R_JWA_ALG_PBES2_H512) {\n        kek_len = 32;\n        mac = GNUTLS_MAC_SHA512;\n      }\n      if (gnutls_pbkdf2(mac, &password, &g_salt, p2c, kek, kek_len) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error gnutls_pbkdf2\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!_r_aes_key_unwrap(kek, kek_len, key_data, cipherkey_len-8, cipherkey)) {\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwe_set_cypher_key(jwe, key_data, cipherkey_len-8) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error r_jwe_set_cypher_key\");\n        ret = RHN_ERROR;\n      }\n    } while (0);\n    o_free(key);\n    o_free(salt);\n    o_free(dat_dec.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error invalid key\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n#endif\n\nstatic gnutls_mac_algorithm_t r_jwe_get_digest_from_enc(jwa_enc enc) {\n  gnutls_mac_algorithm_t digest;\n\n  switch (enc) {\n    case R_JWA_ENC_A128CBC:\n      digest = GNUTLS_MAC_SHA256;\n      break;\n    case R_JWA_ENC_A192CBC:\n      digest = GNUTLS_MAC_SHA384;\n      break;\n    case R_JWA_ENC_A256CBC:\n      digest = GNUTLS_MAC_SHA512;\n      break;\n    case R_JWA_ENC_A128GCM:\n      digest = GNUTLS_MAC_SHA256;\n      break;\n    case R_JWA_ENC_A192GCM:\n      digest = GNUTLS_MAC_SHA384;\n      break;\n    case R_JWA_ENC_A256GCM:\n      digest = GNUTLS_MAC_SHA512;\n      break;\n    default:\n      digest = GNUTLS_MAC_UNKNOWN;\n      break;\n  }\n  return digest;\n}\n\nstatic gnutls_cipher_algorithm_t r_jwe_get_alg_from_alg(jwa_alg alg) {\n  gnutls_cipher_algorithm_t ret_alg = GNUTLS_CIPHER_UNKNOWN;\n\n  switch (alg) {\n    case R_JWA_ALG_A128GCMKW:\n      ret_alg = GNUTLS_CIPHER_AES_128_GCM;\n      break;\n    case R_JWA_ALG_A192GCMKW:\n#if GNUTLS_VERSION_NUMBER >= 0x03060e\n      ret_alg = GNUTLS_CIPHER_AES_192_GCM;\n#else\n      ret_alg = GNUTLS_CIPHER_UNKNOWN; // Unsupported until GnuTLS 3.6.14\n#endif\n      break;\n    case R_JWA_ALG_A256GCMKW:\n      ret_alg = GNUTLS_CIPHER_AES_256_GCM;\n      break;\n    default:\n      ret_alg = GNUTLS_CIPHER_UNKNOWN;\n      break;\n  }\n  return ret_alg;\n}\n\nstatic json_t * r_jwe_aesgcm_key_wrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  int res;\n  unsigned char iv[96] = {0}, * key = NULL, cipherkey[64] = {0}, cipherkey_b64url[128] = {0}, tag[128] = {0}, tag_b64url[256] = {0};\n  size_t key_len = 0, cipherkey_b64url_len = 0, tag_b64url_len = 0, iv_size = gnutls_cipher_get_iv_size(r_jwe_get_alg_from_alg(alg)), tag_len = gnutls_cipher_get_tag_size(r_jwe_get_alg_from_alg(alg));\n  unsigned int bits = 0;\n  gnutls_datum_t key_g, iv_g;\n  gnutls_cipher_hd_t handle = NULL;\n  json_t * j_return = NULL;\n  struct _o_datum dat_iv_enc = {0, NULL}, dat_iv_dec = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    key_len = bits;\n\n    do {\n      if ((key = o_malloc(key_len+4)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error allocating resources for key\");\n        *ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error r_jwk_export_to_symmetric_key\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (r_jwe_get_header_str_value(jwe, \"iv\") == NULL) {\n        if (gnutls_rnd(GNUTLS_RND_NONCE, iv, iv_size)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_rnd\");\n          *ret = RHN_ERROR;\n          break;\n        }\n        if (!o_base64url_encode_alloc(iv, iv_size, &dat_iv_enc)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_encode_alloc iv\");\n          *ret = RHN_ERROR;\n          break;\n        }\n      } else {\n        if (!o_base64url_decode_alloc((const unsigned char *)r_jwe_get_header_str_value(jwe, \"iv\"), o_strlen(r_jwe_get_header_str_value(jwe, \"iv\")), &dat_iv_dec)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_decode iv\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        if (dat_iv_dec.size != iv_size) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error invalid iv size in header\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        memcpy(iv, dat_iv_dec.data, dat_iv_dec.size);\n        if (iv_size != gnutls_cipher_get_iv_size(r_jwe_get_alg_from_alg(alg))) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error invalid iv size\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n      }\n      key_g.data = key;\n      key_g.size = key_len;\n      iv_g.data = iv;\n      iv_g.size = iv_size;\n      if ((res = gnutls_cipher_init(&handle, r_jwe_get_alg_from_alg(alg), &key_g, &iv_g))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"%zu - %zu\", key_g.size, iv_g.size);\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if ((res = gnutls_cipher_encrypt2(handle, jwe->key, jwe->key_len, cipherkey, jwe->key_len))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_cipher_encrypt2: '%s'\", gnutls_strerror(res));\n        *ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_encode(cipherkey, jwe->key_len, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_encode cipherkey\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n        *ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_encode(tag, tag_len, tag_b64url, &tag_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_encode tag\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      tag_b64url[tag_b64url_len] = '\\0';\n      j_return = json_pack(\"{ss%s{ssss}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len,\n                                           \"header\",\n                                             \"tag\", tag_b64url,\n                                             \"alg\", r_jwa_alg_to_str(alg));\n      if (r_jwe_get_header_str_value(jwe, \"iv\") == NULL) {\n        json_object_set_new(json_object_get(j_return, \"header\"), \"iv\", json_stringn((const char *)dat_iv_enc.data, dat_iv_enc.size));\n      } else {\n        json_object_set_new(json_object_get(j_return, \"header\"), \"iv\", json_string(r_jwe_get_header_str_value(jwe, \"iv\")));\n      }\n    } while (0);\n    o_free(key);\n    o_free(dat_iv_enc.data);\n    o_free(dat_iv_dec.data);\n    if (handle != NULL) {\n      gnutls_cipher_deinit(handle);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error invalid key\");\n    *ret = RHN_ERROR_PARAM;\n  }\n  return j_return;\n}\n\nstatic int r_jwe_set_alg_header(jwe_t * jwe, json_t * j_header) {\n  int ret = RHN_OK;\n  switch (jwe->alg) {\n    case R_JWA_ALG_NONE:\n      json_object_set_new(j_header, \"alg\", json_string(\"none\"));\n      break;\n    case R_JWA_ALG_RSA1_5:\n      json_object_set_new(j_header, \"alg\", json_string(\"RSA1_5\"));\n      break;\n    case R_JWA_ALG_RSA_OAEP:\n      json_object_set_new(j_header, \"alg\", json_string(\"RSA-OAEP\"));\n      break;\n    case R_JWA_ALG_RSA_OAEP_256:\n      json_object_set_new(j_header, \"alg\", json_string(\"RSA-OAEP-256\"));\n      break;\n    case R_JWA_ALG_A128KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A128KW\"));\n      break;\n    case R_JWA_ALG_A192KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A192KW\"));\n      break;\n    case R_JWA_ALG_A256KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A256KW\"));\n      break;\n    case R_JWA_ALG_DIR:\n      json_object_set_new(j_header, \"alg\", json_string(\"dir\"));\n      break;\n    case R_JWA_ALG_ECDH_ES:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES\"));\n      break;\n    case R_JWA_ALG_ECDH_ES_A128KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES+A128KW\"));\n      break;\n    case R_JWA_ALG_ECDH_ES_A192KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES+A192KW\"));\n      break;\n    case R_JWA_ALG_ECDH_ES_A256KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES+A256KW\"));\n      break;\n    case R_JWA_ALG_A128GCMKW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A128GCMKW\"));\n      break;\n    case R_JWA_ALG_A192GCMKW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A192GCMKW\"));\n      break;\n    case R_JWA_ALG_A256GCMKW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A256GCMKW\"));\n      break;\n    case R_JWA_ALG_PBES2_H256:\n      json_object_set_new(j_header, \"alg\", json_string(\"PBES2-HS256+A128KW\"));\n      break;\n    case R_JWA_ALG_PBES2_H384:\n      json_object_set_new(j_header, \"alg\", json_string(\"PBES2-HS384+A192KW\"));\n      break;\n    case R_JWA_ALG_PBES2_H512:\n      json_object_set_new(j_header, \"alg\", json_string(\"PBES2-HS512+A256KW\"));\n      break;\n    default:\n      ret = RHN_ERROR_PARAM;\n      break;\n  }\n  return ret;\n}\n\nstatic int r_jwe_set_enc_header(jwe_t * jwe, json_t * j_header) {\n  int ret = RHN_OK;\n  switch (jwe->enc) {\n    case R_JWA_ENC_A128CBC:\n      json_object_set_new(j_header, \"enc\", json_string(\"A128CBC-HS256\"));\n      break;\n    case R_JWA_ENC_A192CBC:\n      json_object_set_new(j_header, \"enc\", json_string(\"A192CBC-HS384\"));\n      break;\n    case R_JWA_ENC_A256CBC:\n      json_object_set_new(j_header, \"enc\", json_string(\"A256CBC-HS512\"));\n      break;\n    case R_JWA_ENC_A128GCM:\n      json_object_set_new(j_header, \"enc\", json_string(\"A128GCM\"));\n      break;\n    case R_JWA_ENC_A192GCM:\n      json_object_set_new(j_header, \"enc\", json_string(\"A192GCM\"));\n      break;\n    case R_JWA_ENC_A256GCM:\n      json_object_set_new(j_header, \"enc\", json_string(\"A256GCM\"));\n      break;\n    default:\n      ret = RHN_ERROR_PARAM;\n      break;\n  }\n  return ret;\n}\n\nstatic int r_jwe_aesgcm_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  int ret, res;\n  unsigned char * key = NULL, tag[128] = {0}, tag_b64url[256] = {0};\n  size_t key_len = 0, tag_b64url_len = 0, tag_len = gnutls_cipher_get_tag_size(r_jwe_get_alg_from_alg(alg));\n  unsigned int bits = 0;\n  gnutls_datum_t key_g, iv_g;\n  gnutls_cipher_hd_t handle = NULL;\n  struct _o_datum dat_iv = {0, NULL}, dat_key = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && !o_strnullempty(r_jwe_get_header_str_value(jwe, \"iv\")) && !o_strnullempty(r_jwe_get_header_str_value(jwe, \"tag\"))) {\n    ret = RHN_OK;\n    key_len = bits;\n\n    do {\n      if ((key = o_malloc(key_len+4)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error allocating resources for key\");\n        ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error r_jwk_export_to_symmetric_key\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_decode_alloc((const unsigned char *)r_jwe_get_header_str_value(jwe, \"iv\"), o_strlen(r_jwe_get_header_str_value(jwe, \"iv\")), &dat_iv)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error o_base64url_decode iv\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (!o_base64url_decode_alloc((const unsigned char *)jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), &dat_key)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      key_g.data = key;\n      key_g.size = key_len;\n      iv_g.data = dat_iv.data;\n      iv_g.size = dat_iv.size;\n      if ((res = gnutls_cipher_init(&handle, r_jwe_get_alg_from_alg(alg), &key_g, &iv_g))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if ((res = gnutls_cipher_decrypt(handle, dat_key.data, dat_key.size))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_decrypt: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n        break;\n      }\n      if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_encode(tag, tag_len, tag_b64url, &tag_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error o_base64url_encode tag\");\n        ret = RHN_ERROR;\n        break;\n      }\n      tag_b64url[tag_b64url_len] = '\\0';\n      if (0 != o_strcmp((const char *)tag_b64url, r_jwe_get_header_str_value(jwe, \"tag\"))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Invalid tag %s %s\", tag_b64url, r_jwe_get_header_str_value(jwe, \"tag\"));\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwe_set_cypher_key(jwe, dat_key.data, dat_key.size) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error r_jwe_set_cypher_key\");\n        ret = RHN_ERROR;\n      }\n\n    } while (0);\n    o_free(key);\n    o_free(dat_key.data);\n    o_free(dat_iv.data);\n    if (handle != NULL) {\n      gnutls_cipher_deinit(handle);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error invalid key\");\n    ret = RHN_ERROR_INVALID;\n  }\n  return ret;\n}\n\nstatic int r_jwe_set_ptext_with_block(unsigned char * data, size_t data_len, unsigned char ** ptext, size_t * ptext_len, gnutls_cipher_algorithm_t alg, int cipher_cbc) {\n  size_t b_size = (size_t)gnutls_cipher_get_block_size(alg);\n  int ret;\n\n  *ptext = NULL;\n  if (cipher_cbc) {\n    if (data_len % b_size) {\n      *ptext_len = ((data_len/b_size)+1)*b_size;\n    } else {\n      *ptext_len = data_len;\n    }\n    if (*ptext_len) {\n      if ((*ptext = o_malloc(*ptext_len)) != NULL) {\n        memcpy(*ptext, data, data_len);\n        memset(*ptext+data_len, (*ptext_len)-data_len, (*ptext_len)-data_len);\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_ptext_with_block - Error allocating resources for ptext (1)\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      ret = RHN_ERROR;\n    }\n  } else {\n    *ptext_len = data_len;\n    if ((*ptext = o_malloc(data_len)) != NULL) {\n      memcpy(*ptext, data, data_len);\n      ret = RHN_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_ptext_with_block - Error allocating resources for ptext (2)\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  }\n  return ret;\n}\n\nstatic int r_jwe_extract_header(jwe_t * jwe, json_t * j_header, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  jwk_t * jwk;\n\n  if (json_is_object(j_header)) {\n    ret = RHN_OK;\n\n    if (json_object_get(j_header, \"alg\") != NULL) {\n      if (0 != o_strcmp(\"RSA1_5\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"RSA-OAEP\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"RSA-OAEP-256\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A128KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A192KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A256KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"dir\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES+A128KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES+A192KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES+A256KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A128GCMKW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A192GCMKW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A256GCMKW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"PBES2-HS256+A128KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"PBES2-HS384+A192KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"PBES2-HS512+A256KW\", json_string_value(json_object_get(j_header, \"alg\")))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Invalid alg\");\n        ret = RHN_ERROR_PARAM;\n      } else {\n        jwe->alg = r_str_to_jwa_alg(json_string_value(json_object_get(j_header, \"alg\")));\n      }\n    }\n\n    if (json_object_get(j_header, \"enc\") != NULL) {\n      if (0 != o_strcmp(\"A128CBC-HS256\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A192CBC-HS384\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A256CBC-HS512\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A128GCM\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A192GCM\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A256GCM\", json_string_value(json_object_get(j_header, \"enc\")))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Invalid enc\");\n        ret = RHN_ERROR_PARAM;\n      } else {\n        jwe->enc = r_str_to_jwa_enc(json_string_value(json_object_get(j_header, \"enc\")));\n      }\n    }\n\n    if (json_string_length(json_object_get(j_header, \"jku\")) && (parse_flags&R_PARSE_HEADER_JKU)) {\n      if (r_jwks_import_from_uri(jwe->jwks_pubkey, json_string_value(json_object_get(j_header, \"jku\")), x5u_flags) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error loading jwks from uri %s\", json_string_value(json_object_get(j_header, \"jku\")));\n      }\n    }\n\n    if (json_object_get(j_header, \"jwk\") != NULL && (parse_flags&R_PARSE_HEADER_JWK)) {\n      r_jwk_init(&jwk);\n      if (r_jwk_import_from_json_t(jwk, json_object_get(j_header, \"jwk\")) == RHN_OK && r_jwk_key_type(jwk, NULL, 0)&R_KEY_TYPE_PUBLIC) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error parsing header jwk\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        ret = RHN_ERROR_PARAM;\n      }\n      r_jwk_free(jwk);\n    }\n\n    if (json_object_get(j_header, \"x5u\") != NULL && (parse_flags&R_PARSE_HEADER_X5U)) {\n      r_jwk_init(&jwk);\n      if (r_jwk_import_from_x5u(jwk, x5u_flags, json_string_value(json_object_get(j_header, \"x5u\"))) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk) != RHN_OK) {\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error importing x5u\");\n        ret = RHN_ERROR_PARAM;\n      }\n      r_jwk_free(jwk);\n    }\n\n    if (json_object_get(j_header, \"x5c\") != NULL && (parse_flags&R_PARSE_HEADER_X5C)) {\n      r_jwk_init(&jwk);\n      if (r_jwk_import_from_x5c(jwk, json_string_value(json_array_get(json_object_get(j_header, \"x5c\"), 0))) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk) != RHN_OK) {\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error importing x5c\");\n        ret = RHN_ERROR_PARAM;\n      }\n      r_jwk_free(jwk);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n\n  return ret;\n}\n\nstatic void r_jwe_remove_padding(unsigned char * text, size_t * text_len, unsigned int block_size) {\n  unsigned char pad = text[(*text_len)-1], i;\n  int pad_ok = 1;\n\n  if (pad && pad < (unsigned char)block_size) {\n    for (i=0; i<pad; i++) {\n      if (text[((*text_len)-i-1)] != pad) {\n        pad_ok = 0;\n      }\n    }\n    if (pad_ok) {\n      *text_len -= pad;\n    }\n  }\n}\n\nstatic int r_jwe_compute_hmac_tag(jwe_t * jwe, unsigned char * ciphertext, size_t cyphertext_len, const unsigned char * aad, unsigned char * tag, size_t * tag_len) {\n  int ret, res;\n  unsigned char al[8], * compute_hmac = NULL;\n  uint64_t aad_len;\n  size_t hmac_size = 0, aad_size = o_strlen((const char *)aad), i;\n  gnutls_mac_algorithm_t mac = r_jwe_get_digest_from_enc(jwe->enc);\n\n  aad_len = (uint64_t)(o_strlen((const char *)aad)*8);\n  memset(al, 0, 8);\n  for(i = 0; i < 8; i++) {\n    al[i] = (uint8_t)((aad_len >> 8*(7 - i)) & 0xFF);\n  }\n\n  if ((compute_hmac = o_malloc(aad_size+jwe->iv_len+cyphertext_len+8)) != NULL) {\n    if (aad_size) {\n      memcpy(compute_hmac, aad, aad_size);\n      hmac_size += aad_size;\n    }\n    memcpy(compute_hmac+hmac_size, jwe->iv, jwe->iv_len);\n    hmac_size += jwe->iv_len;\n    memcpy(compute_hmac+hmac_size, ciphertext, cyphertext_len);\n    hmac_size += cyphertext_len;\n    memcpy(compute_hmac+hmac_size, al, 8);\n    hmac_size += 8;\n\n    if (!(res = gnutls_hmac_fast(mac, jwe->key, jwe->key_len/2, compute_hmac, hmac_size, tag))) {\n      *tag_len = gnutls_hmac_get_len(mac)/2;\n      ret = RHN_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compute_hmac_tag - Error gnutls_hmac_fast: '%s'\", gnutls_strerror(res));\n      ret = RHN_ERROR;\n    }\n    o_free(compute_hmac);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compute_hmac_tag - Error allocating resources for compute_hmac\");\n    ret = RHN_ERROR;\n  }\n  return ret;\n}\n\nstatic json_t * r_jwe_perform_key_encryption(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  json_t * j_return = NULL;\n  int res;\n  unsigned int bits = 0;\n  gnutls_pubkey_t g_pub = NULL;\n  gnutls_datum_t plainkey, cypherkey = {NULL, 0};\n  unsigned char key[128] = {0};\n  size_t key_len = 0, index = 0;\n  const char * key_ref = NULL;\n  json_t * j_element = NULL, * j_reference, * j_key_ref_array;\n  struct _o_datum dat = {0, NULL};\n#if NETTLE_VERSION_NUMBER >= 0x030400\n  uint8_t * cyphertext = NULL;\n  size_t cyphertext_len = 0;\n#endif\n#if NETTLE_VERSION_NUMBER >= 0x030600\n  json_t * jwk_priv = NULL;\n#endif\n\n  switch (alg) {\n    case R_JWA_ALG_RSA1_5:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_RSA|R_KEY_TYPE_PUBLIC) && bits >= 2048) {\n        if (jwk != NULL && (g_pub = r_jwk_export_to_gnutls_pubkey(jwk, x5u_flags)) != NULL) {\n          plainkey.data = jwe->key;\n          plainkey.size = jwe->key_len;\n          if (!(res = gnutls_pubkey_encrypt_data(g_pub, 0, &plainkey, &cypherkey))) {\n            if (o_base64url_encode_alloc(cypherkey.data, cypherkey.size, &dat)) {\n              j_return = json_pack(\"{ss%s{ss}}\", \"encrypted_key\", dat.data, dat.size, \"header\", \"alg\", r_jwa_alg_to_str(alg));\n              o_free(dat.data);\n              dat.data = NULL;\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error o_base64url_encode cypherkey_b64\");\n              *ret = RHN_ERROR;\n            }\n            gnutls_free(cypherkey.data);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error gnutls_pubkey_encrypt_data: %s\", gnutls_strerror(res));\n            *ret = RHN_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Unable to export public key\");\n          *ret = RHN_ERROR;\n        }\n        gnutls_pubkey_deinit(g_pub);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error invalid key type\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_RSA_OAEP:\n    case R_JWA_ALG_RSA_OAEP_256:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_RSA|R_KEY_TYPE_PUBLIC) && bits >= 2048) {\n        if (jwk != NULL && (g_pub = r_jwk_export_to_gnutls_pubkey(jwk, x5u_flags)) != NULL) {\n          if ((cyphertext = o_malloc(bits+1)) != NULL) {\n            cyphertext_len = bits+1;\n            if (_r_rsa_oaep_encrypt(g_pub, alg, jwe->key, jwe->key_len, cyphertext, &cyphertext_len) == RHN_OK) {\n              if (o_base64url_encode_alloc(cyphertext, cyphertext_len, &dat)) {\n                j_return = json_pack(\"{ss%s{ss}}\", \"encrypted_key\", dat.data, dat.size, \"header\", \"alg\", r_jwa_alg_to_str(alg));\n                o_free(dat.data);\n                dat.data = NULL;\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error o_base64url_encode cypherkey_b64\");\n                *ret = RHN_ERROR;\n              }\n              gnutls_free(cypherkey.data);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error _r_rsa_oaep_encrypt\");\n              *ret = RHN_ERROR;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error allocating resources for cyphertext\");\n            *ret = RHN_ERROR_MEMORY;\n          }\n          o_free(cyphertext);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Unable to export public key\");\n          *ret = RHN_ERROR;\n        }\n        gnutls_pubkey_deinit(g_pub);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error invalid key type\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n#endif\n    case R_JWA_ALG_DIR:\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      if (jwk != NULL) {\n        if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && bits == _r_get_key_size(jwe->enc)*8) {\n          key_len = bits/8;\n          if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwk_export_to_symmetric_key\");\n            *ret = RHN_ERROR;\n          } else {\n            if (r_jwe_set_cypher_key(jwe, key, key_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_set_cypher_key\");\n              *ret = RHN_ERROR;\n            } else {\n              j_return = json_object();\n            }\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error invalid key type\");\n          *ret = RHN_ERROR_PARAM;\n        }\n      } else if (jwe->key != NULL && jwe->key_len > 0) {\n        j_return = json_object();\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error no key available for alg 'dir'\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n    case R_JWA_ALG_A128GCMKW:\n#if GNUTLS_VERSION_NUMBER >= 0x03060e\n    case R_JWA_ALG_A192GCMKW:\n#endif\n    case R_JWA_ALG_A256GCMKW:\n      if ((j_return = r_jwe_aesgcm_key_wrap(jwe, alg, jwk, x5u_flags, ret)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_aesgcm_key_wrap\");\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_A128KW:\n    case R_JWA_ALG_A192KW:\n    case R_JWA_ALG_A256KW:\n      if ((j_return = r_jwe_aes_key_wrap(jwe, alg, jwk, x5u_flags, ret)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_aes_key_wrap\");\n      }\n      break;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x03060d\n    case R_JWA_ALG_PBES2_H256:\n    case R_JWA_ALG_PBES2_H384:\n    case R_JWA_ALG_PBES2_H512:\n      if ((j_return = r_jwe_pbes2_key_wrap(jwe, alg, jwk, x5u_flags, ret)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_pbes2_key_wrap\");\n      }\n      break;\n#endif\n#if NETTLE_VERSION_NUMBER >= 0x030600\n    case R_JWA_ALG_ECDH_ES:\n    case R_JWA_ALG_ECDH_ES_A128KW:\n    case R_JWA_ALG_ECDH_ES_A192KW:\n    case R_JWA_ALG_ECDH_ES_A256KW:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_EC|R_KEY_TYPE_PUBLIC)) {\n        if (r_jwks_size(jwe->jwks_privkey) == 1) {\n          jwk_priv = r_jwks_get_at(jwe->jwks_privkey, 0);\n        }\n        if ((j_return = _r_jwe_ecdh_encrypt(jwe, alg, jwk, jwk_priv, res, bits, x5u_flags, ret)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error _r_jwe_ecdh_encrypt\");\n        }\n        r_jwk_free(jwk_priv);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - invalid public key type\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n#endif\n    default:\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Unsupported alg\");\n      *ret = RHN_ERROR_PARAM;\n      break;\n  }\n  j_key_ref_array = json_array();\n  json_object_foreach(json_object_get(j_return, \"header\"), key_ref, j_element) {\n    j_reference = json_object_get(jwe->j_header, key_ref);\n    if (j_reference == NULL) {\n      j_reference = json_object_get(jwe->j_unprotected_header, key_ref);\n    }\n    if (j_reference != NULL && json_equal(j_reference, j_element)) {\n      json_array_append_new(j_key_ref_array, json_string(key_ref));\n    }\n  }\n  json_array_foreach(j_key_ref_array, index, j_element) {\n    json_object_del(json_object_get(j_return, \"header\"), json_string_value(j_element));\n  }\n  json_decref(j_key_ref_array);\n  if (!json_object_size(json_object_get(j_return, \"header\"))) {\n    json_object_del(j_return, \"header\");\n  }\n  return j_return;\n}\n\nstatic int r_preform_key_decryption(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  int ret, res;\n  gnutls_datum_t plainkey = {NULL, 0}, cypherkey;\n  gnutls_privkey_t g_priv = NULL;\n  unsigned int bits = 0;\n  unsigned char * key = NULL;\n  size_t key_len = 0;\n  struct _o_datum dat = {0, NULL};\n#if NETTLE_VERSION_NUMBER >= 0x030400\n  uint8_t * clearkey = NULL;\n  size_t clearkey_len = 0;\n#endif\n\n  switch (alg) {\n    case R_JWA_ALG_RSA1_5:\n      if (r_jwk_key_type(jwk, &bits, x5u_flags) & (R_KEY_TYPE_RSA|R_KEY_TYPE_PRIVATE) && bits >= 2048) {\n        if (jwk != NULL && !o_strnullempty((const char *)jwe->encrypted_key_b64url) && (g_priv = r_jwk_export_to_gnutls_privkey(jwk)) != NULL) {\n            if (o_base64url_decode_alloc(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), &dat)) {\n              cypherkey.size = dat.size;\n              cypherkey.data = dat.data;\n              if (!(res = gnutls_privkey_decrypt_data(g_priv, 0, &cypherkey, &plainkey))) {\n                if (r_jwe_set_cypher_key(jwe, plainkey.data, plainkey.size) == RHN_OK) {\n                  ret = RHN_OK;\n                } else {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_set_cypher_key (RSA1_5)\");\n                  ret = RHN_ERROR;\n                }\n                gnutls_free(plainkey.data);\n              } else if (res == GNUTLS_E_DECRYPTION_FAILED) {\n                ret = RHN_ERROR_INVALID;\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error gnutls_privkey_decrypt_data: %s\", gnutls_strerror(res));\n                ret = RHN_ERROR;\n              }\n              o_free(dat.data);\n              dat.data = NULL;\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error o_base64url_decode_alloc encrypted_key_b64url\");\n              ret = RHN_ERROR_PARAM;\n            }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid RSA1_5 input parameters\");\n          ret = RHN_ERROR_PARAM;\n        }\n        gnutls_privkey_deinit(g_priv);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key size RSA1_5\");\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_RSA_OAEP:\n    case R_JWA_ALG_RSA_OAEP_256:\n      if (r_jwk_key_type(jwk, &bits, x5u_flags) & (R_KEY_TYPE_RSA|R_KEY_TYPE_PRIVATE) && bits >= 2048) {\n        if (jwk != NULL && !o_strnullempty((const char *)jwe->encrypted_key_b64url) && (g_priv = r_jwk_export_to_gnutls_privkey(jwk)) != NULL) {\n          if (o_base64url_decode_alloc(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), &dat)) {\n            if ((clearkey = o_malloc(bits+1)) != NULL) {\n              clearkey_len = bits+1;\n              if (_r_rsa_oaep_decrypt(g_priv, alg, dat.data, dat.size, clearkey, &clearkey_len) == RHN_OK) {\n                if (_r_get_key_size(jwe->enc) == clearkey_len) {\n                  if (r_jwe_set_cypher_key(jwe, clearkey, clearkey_len) == RHN_OK) {\n                    ret = RHN_OK;\n                  } else {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_set_cypher_key (RSA_OAEP)\");\n                    ret = RHN_ERROR;\n                  }\n                } else {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key length\");\n                  ret = RHN_ERROR_PARAM;\n                }\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error _r_rsa_oaep_decrypt\");\n                ret = RHN_ERROR_INVALID;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error o_malloc clearkey\");\n              ret = RHN_ERROR_MEMORY;\n            }\n            o_free(clearkey);\n            o_free(dat.data);\n            dat.data = NULL;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error o_base64url_decode_alloc encrypted_key_b64url\");\n            ret = RHN_ERROR_PARAM;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid RSA1-OAEP input parameters\");\n          ret = RHN_ERROR_PARAM;\n        }\n        gnutls_privkey_deinit(g_priv);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key size RSA_OAEP\");\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n#endif\n    case R_JWA_ALG_DIR:\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      if (jwk != NULL) {\n        if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && bits == _r_get_key_size(jwe->enc)*8) {\n          key_len = (size_t)(bits/8);\n          if ((key = o_malloc(key_len+4)) != NULL) {\n            if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) == RHN_OK) {\n              o_free(jwe->encrypted_key_b64url);\n              jwe->encrypted_key_b64url = NULL;\n              ret = r_jwe_set_cypher_key(jwe, key, key_len);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwk_export_to_symmetric_key\");\n              ret = RHN_ERROR_MEMORY;\n            }\n            o_free(key);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error allocating resources for key\");\n            ret = RHN_ERROR_MEMORY;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key type\");\n          ret = RHN_ERROR_PARAM;\n        }\n      } else if (jwe->key != NULL && jwe->key_len > 0) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error no key available for alg 'dir'\");\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n    case R_JWA_ALG_A128GCMKW:\n#if GNUTLS_VERSION_NUMBER >= 0x03060e\n    case R_JWA_ALG_A192GCMKW:\n#endif\n    case R_JWA_ALG_A256GCMKW:\n      if ((res = r_jwe_aesgcm_key_unwrap(jwe, alg, jwk, x5u_flags)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_aesgcm_key_unwrap\");\n        ret = res;\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_A128KW:\n    case R_JWA_ALG_A192KW:\n    case R_JWA_ALG_A256KW:\n      if ((res = r_jwe_aes_key_unwrap(jwe, alg, jwk, x5u_flags)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_aes_key_unwrap\");\n        ret = res;\n      }\n      break;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x03060d\n    case R_JWA_ALG_PBES2_H256:\n    case R_JWA_ALG_PBES2_H384:\n    case R_JWA_ALG_PBES2_H512:\n      if ((res = r_jwe_pbes2_key_unwrap(jwe, alg, jwk, x5u_flags)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_pbes2_key_unwrap\");\n        ret = res;\n      }\n      break;\n#endif\n#if NETTLE_VERSION_NUMBER >= 0x030600\n    case R_JWA_ALG_ECDH_ES:\n    case R_JWA_ALG_ECDH_ES_A128KW:\n    case R_JWA_ALG_ECDH_ES_A192KW:\n    case R_JWA_ALG_ECDH_ES_A256KW:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_EC|R_KEY_TYPE_PRIVATE) || res & (R_KEY_TYPE_EDDSA|R_KEY_TYPE_PRIVATE)) {\n        if ((res = _r_jwe_ecdh_decrypt(jwe, alg, jwk, res, bits, x5u_flags)) == RHN_OK) {\n          ret = RHN_OK;\n        } else {\n          if (res != RHN_ERROR_INVALID) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error _r_jwe_ecdh_decrypt\");\n          }\n          ret = res;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - invalid key type %d\", res);\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n#endif\n    default:\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error unsupported algorithm\");\n      ret = RHN_ERROR_INVALID;\n      break;\n  }\n  return ret;\n}\n\nint r_jwe_init(jwe_t ** jwe) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((*jwe = o_malloc(sizeof(jwe_t))) != NULL) {\n      if (((*jwe)->j_header = json_object()) != NULL) {\n        if (r_jwks_init(&(*jwe)->jwks_pubkey) == RHN_OK) {\n          if (r_jwks_init(&(*jwe)->jwks_privkey) == RHN_OK) {\n            (*jwe)->header_b64url = NULL;\n            (*jwe)->encrypted_key_b64url = NULL;\n            (*jwe)->iv_b64url = NULL;\n            (*jwe)->aad_b64url = NULL;\n            (*jwe)->ciphertext_b64url = NULL;\n            (*jwe)->auth_tag_b64url = NULL;\n            (*jwe)->j_unprotected_header = NULL;\n            (*jwe)->alg = R_JWA_ALG_UNKNOWN;\n            (*jwe)->enc = R_JWA_ENC_UNKNOWN;\n            (*jwe)->key = NULL;\n            (*jwe)->key_len = 0;\n            (*jwe)->iv = NULL;\n            (*jwe)->iv_len = 0;\n            (*jwe)->aad = NULL;\n            (*jwe)->aad_len = 0;\n            (*jwe)->payload = NULL;\n            (*jwe)->payload_len = 0;\n            (*jwe)->j_json_serialization = NULL;\n            (*jwe)->token_mode = R_JSON_MODE_COMPACT;\n            ret = RHN_OK;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for jwks_privkey\");\n            ret = RHN_ERROR_MEMORY;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for jwks_pubkey\");\n          ret = RHN_ERROR_MEMORY;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for j_header\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for jwe\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  if (ret != RHN_OK && jwe != NULL) {\n    r_jwe_free(*jwe);\n    *jwe = NULL;\n  }\n  return ret;\n}\n\nvoid r_jwe_free(jwe_t * jwe) {\n  if (jwe != NULL) {\n    r_jwks_free(jwe->jwks_privkey);\n    r_jwks_free(jwe->jwks_pubkey);\n    o_free(jwe->header_b64url);\n    o_free(jwe->encrypted_key_b64url);\n    o_free(jwe->iv_b64url);\n    o_free(jwe->aad_b64url);\n    o_free(jwe->ciphertext_b64url);\n    o_free(jwe->auth_tag_b64url);\n    json_decref(jwe->j_header);\n    json_decref(jwe->j_unprotected_header);\n    json_decref(jwe->j_json_serialization);\n    o_free(jwe->key);\n    o_free(jwe->iv);\n    o_free(jwe->aad);\n    o_free(jwe->payload);\n    o_free(jwe);\n  }\n}\n\njwe_t * r_jwe_copy(jwe_t * jwe) {\n  jwe_t * jwe_copy = NULL;\n\n  if (jwe != NULL) {\n    if (r_jwe_init(&jwe_copy) == RHN_OK) {\n      jwe_copy->alg = jwe->alg;\n      jwe_copy->enc = jwe->enc;\n      jwe_copy->token_mode = jwe->token_mode;\n      if (r_jwe_set_payload(jwe_copy, jwe->payload, jwe->payload_len) == RHN_OK &&\n          r_jwe_set_iv(jwe_copy, jwe->iv, jwe->iv_len) == RHN_OK &&\n          r_jwe_set_aad(jwe_copy, jwe->aad, jwe->aad_len) == RHN_OK &&\n          r_jwe_set_cypher_key(jwe_copy, jwe->key, jwe->key_len) == RHN_OK &&\n          r_jwe_set_alg(jwe_copy, r_jwe_get_alg(jwe)) == RHN_OK) {\n        jwe_copy->header_b64url = (unsigned char *)o_strdup((const char *)jwe->header_b64url);\n        jwe_copy->encrypted_key_b64url = (unsigned char *)o_strdup((const char *)jwe->encrypted_key_b64url);\n        jwe_copy->ciphertext_b64url = (unsigned char *)o_strdup((const char *)jwe->ciphertext_b64url);\n        jwe_copy->auth_tag_b64url = (unsigned char *)o_strdup((const char *)jwe->auth_tag_b64url);\n        r_jwks_free(jwe_copy->jwks_privkey);\n        jwe_copy->jwks_privkey = r_jwks_copy(jwe->jwks_privkey);\n        r_jwks_free(jwe_copy->jwks_pubkey);\n        jwe_copy->jwks_pubkey = r_jwks_copy(jwe->jwks_pubkey);\n        json_decref(jwe_copy->j_header);\n        jwe_copy->j_header = json_deep_copy(jwe->j_header);\n        jwe_copy->j_unprotected_header = json_deep_copy(jwe->j_unprotected_header);\n        jwe_copy->j_json_serialization = json_deep_copy(jwe->j_json_serialization);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_copy - Error setting values\");\n        r_jwe_free(jwe_copy);\n        jwe_copy = NULL;\n      }\n    }\n  }\n  return jwe_copy;\n}\n\nint r_jwe_set_payload(jwe_t * jwe, const unsigned char * payload, size_t payload_len) {\n  int ret;\n\n  if (jwe != NULL) {\n    o_free(jwe->payload);\n    if (payload != NULL && payload_len) {\n      if ((jwe->payload = o_malloc(payload_len)) != NULL) {\n        memcpy(jwe->payload, payload, payload_len);\n        jwe->payload_len = payload_len;\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_payload - Error allocating resources for payload\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->payload = NULL;\n      jwe->payload_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_payload(jwe_t * jwe, size_t * payload_len) {\n  if (jwe != NULL) {\n    if (payload_len != NULL) {\n      *payload_len = jwe->payload_len;\n    }\n    return jwe->payload;\n  }\n  return NULL;\n}\n\nint r_jwe_set_cypher_key(jwe_t * jwe, const unsigned char * key, size_t key_len) {\n  int ret;\n\n  if (jwe != NULL) {\n    o_free(jwe->key);\n    if (key != NULL && key_len) {\n      if ((jwe->key = o_malloc(key_len)) != NULL) {\n        memcpy(jwe->key, key, key_len);\n        jwe->key_len = key_len;\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_cypher_key - Error allocating resources for key\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->key = NULL;\n      jwe->key_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_cypher_key(jwe_t * jwe, size_t * key_len) {\n  if (jwe != NULL) {\n    if (key_len != NULL) {\n      *key_len = jwe->key_len;\n    }\n    return jwe->key;\n  }\n  return NULL;\n}\n\nint r_jwe_generate_cypher_key(jwe_t * jwe) {\n  int ret;\n\n  if (jwe != NULL && jwe->enc != R_JWA_ENC_UNKNOWN) {\n    o_free(jwe->encrypted_key_b64url);\n    jwe->encrypted_key_b64url = NULL;\n    jwe->key_len = _r_get_key_size(jwe->enc);\n    o_free(jwe->key);\n    if (!jwe->key_len) {\n      ret = RHN_ERROR_PARAM;\n    } else if ((jwe->key = o_malloc(jwe->key_len)) != NULL) {\n      if (!gnutls_rnd(GNUTLS_RND_KEY, jwe->key, jwe->key_len)) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_cypher_key - Error gnutls_rnd\");\n        ret = RHN_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_cypher_key - Error allocating resources for key\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_cypher_key - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_iv(jwe_t * jwe, const unsigned char * iv, size_t iv_len) {\n  int ret;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL) {\n    o_free(jwe->iv);\n    if (iv != NULL && iv_len) {\n      if ((jwe->iv = o_malloc(iv_len)) != NULL) {\n        memcpy(jwe->iv, iv, iv_len);\n        jwe->iv_len = iv_len;\n        if (o_base64url_encode_alloc(jwe->iv, jwe->iv_len, &dat)) {\n          o_free(jwe->iv_b64url);\n          jwe->iv_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n          o_free(dat.data);\n          ret = RHN_OK;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_iv - Error o_base64url_encode_alloc iv\");\n          ret = RHN_ERROR;\n        }\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_iv - Error allocating resources for iv\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->iv = NULL;\n      jwe->iv_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_iv(jwe_t * jwe, size_t * iv_len) {\n  if (jwe != NULL) {\n    if (iv_len != NULL) {\n      *iv_len = jwe->iv_len;\n    }\n    return jwe->iv;\n  }\n  return NULL;\n}\n\nint r_jwe_set_aad(jwe_t * jwe, const unsigned char * aad, size_t aad_len) {\n  int ret;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL) {\n    o_free(jwe->aad_b64url);\n    jwe->aad_b64url = NULL;\n    o_free(jwe->aad);\n    if (aad != NULL && aad_len) {\n      if ((jwe->aad = o_malloc(aad_len)) != NULL) {\n        memcpy(jwe->aad, aad, aad_len);\n        jwe->aad_len = aad_len;\n        if (o_base64url_encode_alloc(jwe->aad, jwe->aad_len, &dat)) {\n          o_free(jwe->aad_b64url);\n          jwe->aad_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n          o_free(dat.data);\n          ret = RHN_OK;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_aad - Error o_base64url_encode_alloc aad\");\n          ret = RHN_ERROR;\n        }\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_aad - Error allocating resources for aad\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->aad = NULL;\n      jwe->aad_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_aad(jwe_t * jwe, size_t * aad_len) {\n  if (jwe != NULL) {\n    if (aad_len != NULL) {\n      *aad_len = jwe->aad_len;\n    }\n    return jwe->aad;\n  }\n  return NULL;\n}\n\nint r_jwe_generate_iv(jwe_t * jwe) {\n  int ret;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL && jwe->enc != R_JWA_ENC_UNKNOWN) {\n    o_free(jwe->iv_b64url);\n    jwe->iv_b64url = NULL;\n    jwe->iv_len = gnutls_cipher_get_iv_size(_r_get_alg_from_enc(jwe->enc));\n    o_free(jwe->iv);\n    jwe->iv = NULL;\n    if (jwe->iv_len) {\n      if ((jwe->iv = o_malloc(jwe->iv_len)) != NULL) {\n        if (!gnutls_rnd(GNUTLS_RND_NONCE, jwe->iv, jwe->iv_len)) {\n          if (o_base64url_encode_alloc(jwe->iv, jwe->iv_len, &dat)) {\n            jwe->iv_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n            o_free(dat.data);\n            ret = RHN_OK;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_iv - Error o_base64url_encode iv_b64\");\n            ret = RHN_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_iv - Error gnutls_rnd\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_iv - Error allocating resources for iv\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->iv_b64url = (unsigned char *)o_strdup(\"\");\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_alg(jwe_t * jwe, jwa_alg alg) {\n  int ret = RHN_OK;\n\n  if (jwe != NULL) {\n    jwe->alg = alg;\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwa_alg r_jwe_get_alg(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return jwe->alg;\n  } else {\n    return R_JWA_ALG_UNKNOWN;\n  }\n}\n\nint r_jwe_set_enc(jwe_t * jwe, jwa_enc enc) {\n  int ret = RHN_OK;\n\n  if (jwe != NULL) {\n    jwe->enc = enc;\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwa_enc r_jwe_get_enc(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return jwe->enc;\n  } else {\n    return R_JWA_ENC_UNKNOWN;\n  }\n}\n\nconst char * r_jwe_get_kid(jwe_t * jwe) {\n  return r_jwe_get_header_str_value(jwe, \"kid\");\n}\n\nint r_jwe_set_header_str_value(jwe_t * jwe, const char * key, const char * str_value) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((ret = _r_json_set_str_value(jwe->j_header, key, str_value)) == RHN_OK) {\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n    }\n    return ret;\n  } else {\n    return RHN_ERROR_PARAM;\n  }\n}\n\nint r_jwe_set_header_int_value(jwe_t * jwe, const char * key, rhn_int_t i_value) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((ret = _r_json_set_int_value(jwe->j_header, key, i_value)) == RHN_OK) {\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n    }\n    return ret;\n  } else {\n    return RHN_ERROR_PARAM;\n  }\n}\n\nint r_jwe_set_header_json_t_value(jwe_t * jwe, const char * key, json_t * j_value) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((ret = _r_json_set_json_t_value(jwe->j_header, key, j_value)) == RHN_OK) {\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n    }\n    return ret;\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst char * r_jwe_get_header_str_value(jwe_t * jwe, const char * key) {\n  if (jwe != NULL) {\n    return _r_json_get_str_value(jwe->j_header, key);\n  }\n  return NULL;\n}\n\nrhn_int_t r_jwe_get_header_int_value(jwe_t * jwe, const char * key) {\n  if (jwe != NULL) {\n    return _r_json_get_int_value(jwe->j_header, key);\n  }\n  return 0;\n}\n\njson_t * r_jwe_get_header_json_t_value(jwe_t * jwe, const char * key) {\n  if (jwe != NULL) {\n    return _r_json_get_json_t_value(jwe->j_header, key);\n  }\n  return NULL;\n}\n\njson_t * r_jwe_get_full_header_json_t(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return _r_json_get_full_json_t(jwe->j_header);\n  }\n  return NULL;\n}\n\nchar * r_jwe_get_full_header_str(jwe_t * jwe) {\n  char * to_return = NULL;\n  if (jwe != NULL) {\n    to_return = json_dumps(jwe->j_header, JSON_COMPACT);\n  }\n  return to_return;\n}\n\njson_t * r_jwe_get_full_unprotected_header_json_t(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return _r_json_get_full_json_t(jwe->j_unprotected_header);\n  }\n  return NULL;\n}\n\nchar * r_jwe_get_full_unprotected_header_str(jwe_t * jwe) {\n  char * to_return = NULL;\n  if (jwe != NULL) {\n    to_return = json_dumps(jwe->j_unprotected_header, JSON_COMPACT);\n  }\n  return to_return;\n}\n\nint r_jwe_add_keys(jwe_t * jwe, jwk_t * jwk_privkey, jwk_t * jwk_pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n\n  if (jwe != NULL && (jwk_privkey != NULL || jwk_pubkey != NULL)) {\n    if (jwk_privkey != NULL) {\n      if (r_jwks_append_jwk(jwe->jwks_privkey, jwk_privkey) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys - Error setting jwk_privkey\");\n        ret = RHN_ERROR;\n      }\n      if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n        r_jwe_set_alg(jwe, alg);\n      }\n    }\n    if (jwk_pubkey != NULL) {\n      if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk_pubkey) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys - Error setting jwk_pubkey\");\n        ret = RHN_ERROR;\n      }\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_jwks(jwe_t * jwe, jwks_t * jwks_privkey, jwks_t * jwks_pubkey) {\n  size_t i;\n  int ret, res;\n  jwk_t * jwk;\n\n  if (jwe != NULL && (jwks_privkey != NULL || jwks_pubkey != NULL)) {\n    ret = RHN_OK;\n    if (jwks_privkey != NULL) {\n      for (i=0; ret==RHN_OK && i<r_jwks_size(jwks_privkey); i++) {\n        jwk = r_jwks_get_at(jwks_privkey, i);\n        if ((res = r_jwe_add_keys(jwe, jwk, NULL)) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_jwks - Error r_jwe_add_keys private key at %zu\", i);\n          ret = res;\n        }\n        r_jwk_free(jwk);\n      }\n    }\n    if (jwks_pubkey != NULL) {\n      for (i=0; ret==RHN_OK && i<r_jwks_size(jwks_pubkey); i++) {\n        jwk = r_jwks_get_at(jwks_pubkey, i);\n        if ((res = r_jwe_add_keys(jwe, NULL, jwk)) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_jwks - Error r_jwe_add_keys public key at %zu\", i);\n          ret = res;\n        }\n        r_jwk_free(jwk);\n      }\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_json_str(jwe_t * jwe, const char * privkey, const char * pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_json_str(j_privkey, privkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_json_str(j_pubkey, pubkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_json_t(jwe_t * jwe, json_t * privkey, json_t * pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_json_t(j_privkey, privkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_json_t(j_pubkey, pubkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_pem_der(jwe_t * jwe, int format, const unsigned char * privkey, size_t privkey_len, const unsigned char * pubkey, size_t pubkey_len) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_pem_der(j_privkey, R_X509_TYPE_PRIVKEY, format, privkey, privkey_len) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_pem_der(j_pubkey, R_X509_TYPE_PUBKEY, format, pubkey, pubkey_len) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_gnutls(jwe_t * jwe, gnutls_privkey_t privkey, gnutls_pubkey_t pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_gnutls_privkey(j_privkey, privkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_gnutls_pubkey(j_pubkey, pubkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_key_symmetric(jwe_t * jwe, const unsigned char * key, size_t key_len) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_key = NULL;\n\n  if (jwe != NULL && key != NULL && key_len) {\n    if (r_jwk_init(&j_key) == RHN_OK && r_jwk_import_from_symmetric_key(j_key, key, key_len) == RHN_OK) {\n      if (r_jwks_append_jwk(jwe->jwks_privkey, j_key) != RHN_OK || r_jwks_append_jwk(jwe->jwks_pubkey, j_key) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_enc_key_symmetric - Error setting key\");\n        ret = RHN_ERROR;\n      }\n      if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_key, \"alg\"))) != R_JWA_ALG_NONE) {\n        r_jwe_set_alg(jwe, alg);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_enc_key_symmetric - Error parsing key\");\n      ret = RHN_ERROR;\n    }\n    r_jwk_free(j_key);\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwks_t * r_jwe_get_jwks_privkey(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return r_jwks_copy(jwe->jwks_privkey);\n  } else {\n    return NULL;\n  }\n}\n\njwks_t * r_jwe_get_jwks_pubkey(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return r_jwks_copy(jwe->jwks_pubkey);\n  } else {\n    return NULL;\n  }\n}\n\nint r_jwe_encrypt_payload(jwe_t * jwe) {\n  int ret = RHN_OK, res;\n  gnutls_cipher_hd_t handle;\n  gnutls_datum_t key, iv;\n  unsigned char * ptext = NULL, * text_zip = NULL, * ciphertext_b64url = NULL, tag[128] = {0}, * tag_b64url = NULL, * aad = NULL;\n  size_t ptext_len = 0, ciphertext_b64url_len = 0, tag_len = 0, text_zip_len = 0;\n  char * str_header = NULL;\n  int cipher_cbc;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL &&\n      jwe->payload != NULL &&\n      jwe->payload_len &&\n      jwe->enc != R_JWA_ENC_UNKNOWN &&\n      jwe->key != NULL &&\n      jwe->iv != NULL &&\n      jwe->iv_len &&\n      jwe->key_len == _r_get_key_size(jwe->enc) &&\n      r_jwe_set_enc_header(jwe, jwe->j_header) == RHN_OK) {\n    cipher_cbc = (jwe->enc == R_JWA_ENC_A128CBC || jwe->enc == R_JWA_ENC_A192CBC || jwe->enc == R_JWA_ENC_A256CBC);\n\n    if ((str_header = json_dumps(jwe->j_header, JSON_COMPACT)) != NULL) {\n      if (o_base64url_encode_alloc((const unsigned char *)str_header, o_strlen(str_header), &dat)) {\n        o_free(jwe->header_b64url);\n        jwe->header_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n        o_free(dat.data);\n        dat.data = NULL;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error o_base64url_encode str_header\");\n        ret = RHN_ERROR;\n      }\n      o_free(str_header);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error json_dumps j_header\");\n      ret = RHN_ERROR;\n    }\n\n    ptext_len = gnutls_cipher_get_block_size(_r_get_alg_from_enc(jwe->enc));\n    if (0 == o_strcmp(\"DEF\", r_jwe_get_header_str_value(jwe, \"zip\"))) {\n      if (_r_deflate_payload(jwe->payload, jwe->payload_len, &text_zip, &text_zip_len) == RHN_OK) {\n        if (r_jwe_set_ptext_with_block(text_zip, text_zip_len, &ptext, &ptext_len, _r_get_alg_from_enc(jwe->enc), cipher_cbc) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error r_jwe_set_ptext_with_block\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error _r_deflate_payload\");\n        ret = RHN_ERROR;\n      }\n      o_free(text_zip);\n    } else {\n      if (r_jwe_set_ptext_with_block(jwe->payload, jwe->payload_len, &ptext, &ptext_len, _r_get_alg_from_enc(jwe->enc), cipher_cbc) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error r_jwe_set_ptext_with_block\");\n        ret = RHN_ERROR;\n      }\n    }\n\n    if (ret == RHN_OK) {\n      if (cipher_cbc) {\n        key.data = jwe->key+(jwe->key_len/2);\n        key.size = jwe->key_len/2;\n      } else {\n        key.data = jwe->key;\n        key.size = jwe->key_len;\n      }\n      iv.data = jwe->iv;\n      iv.size = jwe->iv_len;\n      if (!(res = gnutls_cipher_init(&handle, _r_get_alg_from_enc(jwe->enc), &key, &iv))) {\n        if (jwe->aad_b64url == NULL || jwe->token_mode == R_JSON_MODE_COMPACT) {\n          aad = (unsigned char *)o_strdup((const char *)jwe->header_b64url);\n        } else {\n          aad = (unsigned char *)msprintf(\"%s.%s\", jwe->header_b64url, jwe->aad_b64url);\n        }\n        if (!cipher_cbc && (res = gnutls_cipher_add_auth(handle, aad, o_strlen((const char *)aad)))) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_add_auth: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (ret == RHN_OK) {\n          if (!(res = gnutls_cipher_encrypt(handle, ptext, ptext_len))) {\n            if ((ciphertext_b64url = o_malloc(2*ptext_len)) != NULL) {\n              if (o_base64url_encode(ptext, ptext_len, ciphertext_b64url, &ciphertext_b64url_len)) {\n                o_free(jwe->ciphertext_b64url);\n                jwe->ciphertext_b64url = (unsigned char *)o_strndup((const char *)ciphertext_b64url, ciphertext_b64url_len);\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error o_base64url_encode ciphertext\");\n                ret = RHN_ERROR;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error allocating resources for ciphertext_b64url\");\n              ret = RHN_ERROR_MEMORY;\n            }\n            o_free(ciphertext_b64url);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_encrypt: '%s'\", gnutls_strerror(res));\n            ret = RHN_ERROR;\n          }\n        } else if (!cipher_cbc) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_add_auth: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (ret == RHN_OK) {\n          if (cipher_cbc) {\n            if (r_jwe_compute_hmac_tag(jwe, ptext, ptext_len, aad, tag, &tag_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error r_jwe_compute_hmac_tag\");\n              ret = RHN_ERROR;\n            }\n          } else {\n            tag_len = gnutls_cipher_get_tag_size(_r_get_alg_from_enc(jwe->enc));\n            memset(tag, 0, tag_len);\n            if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n              ret = RHN_ERROR;\n            }\n          }\n          if (ret == RHN_OK && tag_len) {\n            if ((tag_b64url = o_malloc(tag_len*2)) != NULL) {\n              if (o_base64url_encode_alloc(tag, tag_len, &dat)) {\n                o_free(jwe->auth_tag_b64url);\n                jwe->auth_tag_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n                o_free(dat.data);\n                dat.data = NULL;\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error o_base64url_encode tag_b64url\");\n                ret = RHN_ERROR;\n              }\n              o_free(tag_b64url);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error allocating resources for tag_b64url\");\n              ret = RHN_ERROR_MEMORY;\n            }\n          }\n        }\n        o_free(aad);\n        gnutls_cipher_deinit(handle);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  o_free(ptext);\n  return ret;\n}\n\nint r_jwe_decrypt_payload(jwe_t * jwe) {\n  int ret = RHN_OK, res;\n  gnutls_cipher_hd_t handle;\n  gnutls_datum_t key, iv;\n  unsigned char * payload_enc = NULL, * unzip = NULL, * aad = NULL;\n  size_t payload_enc_len = 0, unzip_len = 0;\n  unsigned char tag[128];\n  size_t tag_len = 0;\n  int cipher_cbc;\n  struct _o_datum dat = {0, NULL}, dat_ciph = {0, NULL}, dat_tag = {0, NULL};\n\n  if (jwe != NULL && jwe->enc != R_JWA_ENC_UNKNOWN && !o_strnullempty((const char *)jwe->ciphertext_b64url) && !o_strnullempty((const char *)jwe->iv_b64url) && jwe->key != NULL && jwe->key_len && jwe->key_len == _r_get_key_size(jwe->enc)) {\n    // Decode iv and payload_b64\n    o_free(jwe->iv);\n    if (o_base64url_decode_alloc(jwe->iv_b64url, o_strlen((const char *)jwe->iv_b64url), &dat)) {\n      if ((jwe->iv = o_malloc(dat.size)) != NULL) {\n        jwe->iv_len = dat.size;\n        memcpy(jwe->iv, dat.data, dat.size);\n        if (o_base64url_decode_alloc(jwe->ciphertext_b64url, o_strlen((const char *)jwe->ciphertext_b64url), &dat_ciph)) {\n          if ((payload_enc = o_malloc(dat_ciph.size)) == NULL) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error allocating resources for payload_enc\");\n            ret = RHN_ERROR_MEMORY;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error o_base64url_decode_alloc ciphertext_b64url\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error reallocating resources for iv\");\n        ret = RHN_ERROR_MEMORY;\n      }\n      o_free(dat.data);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error o_base64url_decode_alloc iv\");\n      ret = RHN_ERROR;\n    }\n\n    if (ret == RHN_OK) {\n      if (jwe->enc == R_JWA_ENC_A128CBC || jwe->enc == R_JWA_ENC_A192CBC || jwe->enc == R_JWA_ENC_A256CBC) {\n        key.data = jwe->key+(jwe->key_len/2);\n        key.size = jwe->key_len/2;\n        cipher_cbc = 1;\n      } else {\n        key.data = jwe->key;\n        key.size = jwe->key_len;\n        cipher_cbc = 0;\n      }\n      iv.data = jwe->iv;\n      iv.size = jwe->iv_len;\n      payload_enc_len = dat_ciph.size;\n      if (!(res = gnutls_cipher_init(&handle, _r_get_alg_from_enc(jwe->enc), &key, &iv))) {\n        if (jwe->aad_b64url == NULL || jwe->token_mode == R_JSON_MODE_COMPACT) {\n          aad = (unsigned char *)o_strdup((const char *)jwe->header_b64url);\n        } else {\n          aad = (unsigned char *)msprintf(\"%s.%s\", jwe->header_b64url, jwe->aad_b64url);\n        }\n        if (!cipher_cbc && (res = gnutls_cipher_add_auth(handle, aad, o_strlen((const char *)aad)))) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_add_auth: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (!(res = gnutls_cipher_decrypt2(handle, dat_ciph.data, dat_ciph.size, payload_enc, payload_enc_len))) {\n          if (cipher_cbc) {\n            r_jwe_remove_padding(payload_enc, &payload_enc_len, gnutls_cipher_get_block_size(_r_get_alg_from_enc(jwe->enc)));\n          }\n          if (0 == o_strcmp(\"DEF\", r_jwe_get_header_str_value(jwe, \"zip\"))) {\n            if (_r_inflate_payload(payload_enc, payload_enc_len, &unzip, &unzip_len) == RHN_OK) {\n              if (r_jwe_set_payload(jwe, unzip, unzip_len) != RHN_OK) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error r_jwe_set_payload\");\n                ret = RHN_ERROR;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error _r_inflate_payload\");\n              ret = RHN_ERROR;\n            }\n            o_free(unzip);\n          } else {\n            if (r_jwe_set_payload(jwe, payload_enc, payload_enc_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error r_jwe_set_payload\");\n              ret = RHN_ERROR;\n            }\n          }\n        } else if (res == GNUTLS_E_DECRYPTION_FAILED) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - decryption failed: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR_INVALID;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_decrypt: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (ret == RHN_OK) {\n          if (cipher_cbc) {\n            if (r_jwe_compute_hmac_tag(jwe, dat_ciph.data, dat_ciph.size, aad, tag, &tag_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error r_jwe_compute_hmac_tag\");\n              ret = RHN_ERROR;\n            }\n          } else {\n            tag_len = gnutls_cipher_get_tag_size(_r_get_alg_from_enc(jwe->enc));\n            memset(tag, 0, tag_len);\n            if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n              ret = RHN_ERROR;\n            }\n          }\n          if (ret == RHN_OK && tag_len) {\n            if (o_base64url_encode_alloc(tag, tag_len, &dat_tag)) {\n              if (dat_tag.size != o_strlen((const char *)jwe->auth_tag_b64url) || 0 != memcmp(dat_tag.data, jwe->auth_tag_b64url, dat_tag.size)) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Invalid tag\");\n                ret = RHN_ERROR_INVALID;\n              }\n              o_free(dat_tag.data);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error o_base64url_encode_alloc tag\");\n              ret = RHN_ERROR;\n            }\n          }\n        }\n        o_free(aad);\n        gnutls_cipher_deinit(handle);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  o_free(payload_enc);\n  o_free(dat_ciph.data);\n\n  return ret;\n}\n\nint r_jwe_encrypt_key(jwe_t * jwe, jwk_t * jwk_s, int x5u_flags) {\n  int ret, res = RHN_OK;\n  jwk_t * jwk = NULL;\n  jwa_alg alg;\n  const char * kid;\n  json_t * j_header = NULL, * j_cur_header = NULL;\n\n  if (jwe != NULL) {\n    if (jwk_s != NULL) {\n      jwk = r_jwk_copy(jwk_s);\n      if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk, \"alg\"))) != R_JWA_ALG_NONE) {\n        r_jwe_set_alg(jwe, alg);\n      }\n    } else {\n      if (r_jwe_get_header_str_value(jwe, \"kid\") != NULL) {\n        jwk = r_jwks_get_by_kid(jwe->jwks_pubkey, r_jwe_get_header_str_value(jwe, \"kid\"));\n      } else if (r_jwks_size(jwe->jwks_pubkey) == 1) {\n        jwk = r_jwks_get_at(jwe->jwks_pubkey, 0);\n      }\n    }\n  }\n\n  if (jwe != NULL && jwe->key != NULL && jwe->key_len && jwe->alg != R_JWA_ALG_UNKNOWN && jwe->alg != R_JWA_ALG_NONE) {\n    if ((kid = r_jwk_get_property_str(jwk, \"kid\")) != NULL && r_jwe_get_header_str_value(jwe, \"kid\") == NULL) {\n      r_jwe_set_header_str_value(jwe, \"kid\", kid);\n    }\n    if ((j_header = r_jwe_perform_key_encryption(jwe, jwe->alg, jwk, x5u_flags, &res)) != NULL) {\n      j_cur_header = r_jwe_get_full_header_json_t(jwe);\n      json_object_update(j_cur_header, json_object_get(j_header, \"header\"));\n      r_jwe_set_full_header_json_t(jwe, j_cur_header);\n      json_decref(j_cur_header);\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(j_header, \"encrypted_key\")));\n      json_decref(j_header);\n      ret = RHN_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_key - Error r_jwe_perform_key_encryption\");\n      ret = res;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_key - invalid input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n\n  r_jwk_free(jwk);\n  return ret;\n}\n\nint r_jwe_decrypt_key(jwe_t * jwe, jwk_t * jwk_s, int x5u_flags) {\n  int ret;\n  jwk_t * jwk = NULL;\n\n  if (jwe != NULL) {\n    if (jwk_s != NULL) {\n      jwk = r_jwk_copy(jwk_s);\n    } else {\n      if (r_jwe_get_header_str_value(jwe, \"kid\") != NULL) {\n        jwk = r_jwks_get_by_kid(jwe->jwks_privkey, r_jwe_get_header_str_value(jwe, \"kid\"));\n      } else if (r_jwks_size(jwe->jwks_privkey) == 1) {\n        jwk = r_jwks_get_at(jwe->jwks_privkey, 0);\n      }\n    }\n  }\n\n  if (jwe != NULL && jwe->alg != R_JWA_ALG_UNKNOWN && jwe->alg != R_JWA_ALG_NONE) {\n    ret = r_preform_key_decryption(jwe, jwe->alg, jwk, x5u_flags);\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n\n  r_jwk_free(jwk);\n  return ret;\n}\n\nint r_jwe_parse(jwe_t * jwe, const char * jwe_str, int x5u_flags) {\n  return r_jwe_parsen(jwe, jwe_str, o_strlen(jwe_str), x5u_flags);\n}\n\nint r_jwe_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, int x5u_flags) {\n  int ret;\n  char * str = (char *)jwe_str;\n\n  if (jwe != NULL && str != NULL && jwe_str_len) {\n    while(isspace((unsigned char)*str) && jwe_str_len) {\n      str++;\n      jwe_str_len--;\n    }\n\n    if (0 == o_strncmp(\"ey\", str, 2)) {\n      ret = r_jwe_compact_parsen(jwe, jwe_str, jwe_str_len, x5u_flags);\n    } else if (*str == '{') {\n      ret = r_jwe_parsen_json_str(jwe, jwe_str, jwe_str_len, x5u_flags);\n    } else {\n      ret = RHN_ERROR_PARAM;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_advanced_parse(jwe_t * jwe, const char * jwe_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_advanced_parsen(jwe, jwe_str, o_strlen(jwe_str), parse_flags, x5u_flags);\n}\n\nint r_jwe_advanced_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  char * str = (char *)jwe_str;\n\n  if (jwe != NULL && str != NULL && jwe_str_len) {\n    while(isspace((unsigned char)*str) && jwe_str_len) {\n      str++;\n      jwe_str_len--;\n    }\n\n    if (0 == o_strncmp(\"ey\", str, 2)) {\n      ret = r_jwe_advanced_compact_parsen(jwe, jwe_str, jwe_str_len, parse_flags, x5u_flags);\n    } else if (*str == '{') {\n      ret = r_jwe_advanced_parsen_json_str(jwe, jwe_str, jwe_str_len, parse_flags, x5u_flags);\n    } else {\n      ret = RHN_ERROR_PARAM;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_compact_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, int x5u_flags) {\n  return r_jwe_advanced_compact_parsen(jwe, jwe_str, jwe_str_len, R_PARSE_HEADER_ALL, x5u_flags);\n}\n\nint r_jwe_compact_parse(jwe_t * jwe, const char * jwe_str, int x5u_flags) {\n  return r_jwe_compact_parsen(jwe, jwe_str, o_strlen(jwe_str), x5u_flags);\n}\n\nint r_jwe_advanced_compact_parse(jwe_t * jwe, const char * jwe_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_advanced_compact_parsen(jwe, jwe_str, o_strlen(jwe_str), parse_flags, x5u_flags);\n}\n\nint r_jwe_advanced_compact_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  char ** str_array = NULL;\n  char * token = NULL, * tmp;\n  size_t cypher_key_len = 0, cypher_len = 0, tag_len = 0;\n  json_t * j_header = NULL;\n  struct _o_datum dat_header = {0, NULL}, dat_iv = {0, NULL};\n\n  if (jwe != NULL && jwe_str != NULL && jwe_str_len) {\n    token = o_strndup(jwe_str, jwe_str_len);\n    // Remove whitespaces and newlines\n    tmp = str_replace(token, \" \", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\n\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\t\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\v\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\f\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\r\", \"\");\n    o_free(token);\n    token = tmp;\n    if (split_string(token, \".\", &str_array) == 5 && !o_strnullempty(str_array[0]) && !o_strnullempty(str_array[2]) && !o_strnullempty(str_array[3]) && !o_strnullempty(str_array[4])) {\n      // Check if all elements 0, 2 and 3 are base64url encoded\n      if (o_base64url_decode_alloc((unsigned char *)str_array[0], o_strlen(str_array[0]), &dat_header) &&\n         (o_strnullempty(str_array[1]) || o_base64url_decode((unsigned char *)str_array[1], o_strlen(str_array[1]), NULL, &cypher_key_len)) &&\n          o_base64url_decode_alloc((unsigned char *)str_array[2], o_strlen(str_array[2]), &dat_iv) &&\n          o_base64url_decode((unsigned char *)str_array[3], o_strlen(str_array[3]), NULL, &cypher_len) &&\n          o_base64url_decode((unsigned char *)str_array[4], o_strlen(str_array[4]), NULL, &tag_len)) {\n        ret = RHN_OK;\n        jwe->token_mode = R_JSON_MODE_COMPACT;\n        do {\n          // Decode header\n          if ((j_header = json_loadb((const char *)dat_header.data, dat_header.size, JSON_DECODE_ANY, NULL)) == NULL) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compact_parsen - Error json_loadb dat_header\");\n            ret = RHN_ERROR_PARAM;\n            break;\n          }\n\n          if (r_jwe_extract_header(jwe, j_header, parse_flags, x5u_flags) != RHN_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compact_parsen - error extracting header params\");\n            ret = RHN_ERROR_PARAM;\n            break;\n          }\n          json_decref(jwe->j_header);\n\n          jwe->j_header = json_incref(j_header);\n\n          // Decode iv\n          if (r_jwe_set_iv(jwe, dat_iv.data, dat_iv.size) != RHN_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compact_parsen - Error r_jwe_set_iv\");\n            ret = RHN_ERROR;\n            break;\n          }\n\n          o_free(jwe->header_b64url);\n          jwe->header_b64url = (unsigned char *)o_strdup(str_array[0]);\n          o_free(jwe->aad_b64url);\n          jwe->aad_b64url = (unsigned char *)o_strdup(str_array[0]);\n          o_free(jwe->encrypted_key_b64url);\n          jwe->encrypted_key_b64url = (unsigned char *)o_strdup(str_array[1]);\n          o_free(jwe->iv_b64url);\n          jwe->iv_b64url = (unsigned char *)o_strdup(str_array[2]);\n          o_free(jwe->ciphertext_b64url);\n          jwe->ciphertext_b64url = (unsigned char *)o_strdup(str_array[3]);\n          o_free(jwe->auth_tag_b64url);\n          jwe->auth_tag_b64url = (unsigned char *)o_strdup(str_array[4]);\n\n        } while (0);\n        json_decref(j_header);\n      } else {\n        ret = RHN_ERROR_PARAM;\n      }\n      o_free(dat_header.data);\n      o_free(dat_iv.data);\n    } else {\n      ret = RHN_ERROR_PARAM;\n    }\n    free_string_array(str_array);\n    o_free(token);\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_parse_json_str(jwe_t * jwe, const char * jwe_json_str, int x5u_flags) {\n  return r_jwe_parsen_json_str(jwe, jwe_json_str, o_strlen(jwe_json_str), x5u_flags);\n}\n\nint r_jwe_parsen_json_str(jwe_t * jwe, const char * jwe_json_str, size_t jwe_json_str_len, int x5u_flags) {\n  json_t * jwe_json = NULL;\n  int ret;\n\n  jwe_json = json_loadb(jwe_json_str, jwe_json_str_len, JSON_DECODE_ANY, NULL);\n  ret = r_jwe_parse_json_t(jwe, jwe_json, x5u_flags);\n  json_decref(jwe_json);\n\n  return ret;\n}\n\nint r_jwe_parse_json_t(jwe_t * jwe, json_t * jwe_json, int x5u_flags) {\n  return r_jwe_advanced_parse_json_t(jwe, jwe_json, R_PARSE_HEADER_ALL, x5u_flags);\n}\n\nint r_jwe_advanced_parse_json_str(jwe_t * jwe, const char * jwe_json_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_advanced_parsen_json_str(jwe, jwe_json_str, o_strlen(jwe_json_str), parse_flags, x5u_flags);\n}\n\nint r_jwe_advanced_parsen_json_str(jwe_t * jwe, const char * jwe_json_str, size_t jwe_json_str_len, uint32_t parse_flags, int x5u_flags) {\n  json_t * jwe_json = NULL;\n  int ret;\n\n  jwe_json = json_loadb(jwe_json_str, jwe_json_str_len, JSON_DECODE_ANY, NULL);\n  ret = r_jwe_advanced_parse_json_t(jwe, jwe_json, parse_flags, x5u_flags);\n  json_decref(jwe_json);\n\n  return ret;\n}\n\nint r_jwe_advanced_parse_json_t(jwe_t * jwe, json_t * jwe_json, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  size_t cypher_key_len = 0, index = 0;;\n  json_t * j_header = NULL, * j_recipient;\n  struct _o_datum dat_header = {0, NULL}, dat_iv = {0, NULL};\n\n  if (jwe != NULL && json_is_object(jwe_json)) {\n    if (json_string_length(json_object_get(jwe_json, \"protected\")) &&\n        json_string_length(json_object_get(jwe_json, \"iv\")) &&\n        json_string_length(json_object_get(jwe_json, \"ciphertext\")) &&\n        json_string_length(json_object_get(jwe_json, \"tag\"))) {\n      ret = RHN_OK;\n      r_jwe_set_cypher_key(jwe, NULL, 0);\n      r_jwe_set_iv(jwe, NULL, 0);\n      r_jwe_set_aad(jwe, NULL, 0);\n      r_jwe_set_payload(jwe, NULL, 0);\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      o_free(jwe->iv_b64url);\n      jwe->iv_b64url = NULL;\n      o_free(jwe->ciphertext_b64url);\n      jwe->ciphertext_b64url = NULL;\n      o_free(jwe->auth_tag_b64url);\n      jwe->auth_tag_b64url = NULL;\n      o_free(jwe->aad_b64url);\n      jwe->aad_b64url = NULL;\n      json_decref(jwe->j_header);\n      jwe->j_header = json_object();\n      json_decref(jwe->j_unprotected_header);\n      jwe->j_unprotected_header = NULL;\n      do {\n        json_decref(jwe->j_json_serialization);\n        if ((jwe->j_json_serialization = json_deep_copy(jwe_json)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error setting j_json_serialization\");\n          ret = RHN_ERROR;\n          break;\n        }\n\n        if (json_object_get(jwe_json, \"unprotected\") != NULL && r_jwe_set_full_unprotected_header_json_t(jwe, json_object_get(jwe_json, \"unprotected\")) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error r_jwe_set_full_unprotected_header_json_t\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if (!o_base64url_decode_alloc((unsigned char *)json_string_value(json_object_get(jwe_json, \"protected\")), json_string_length(json_object_get(jwe_json, \"protected\")), &dat_header)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error invalid protected base64\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if ((j_header = json_loadb((const char *)dat_header.data, dat_header.size, JSON_DECODE_ANY, NULL)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error json_loadb dat_header\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if (r_jwe_extract_header(jwe, j_header, parse_flags, x5u_flags) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - error extracting header params\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n        json_decref(jwe->j_header);\n\n        jwe->j_header = json_incref(j_header);\n\n        // Decode iv\n        if (!o_base64url_decode_alloc((unsigned char *)json_string_value(json_object_get(jwe_json, \"iv\")), json_string_length(json_object_get(jwe_json, \"iv\")), &dat_iv)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error o_base64url_decode_alloc iv\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if (r_jwe_set_iv(jwe, dat_iv.data, dat_iv.size) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error r_jwe_set_iv\");\n          ret = RHN_ERROR;\n          break;\n        }\n        jwe->header_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"protected\")));\n        jwe->ciphertext_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"ciphertext\")));\n        jwe->auth_tag_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"tag\")));\n        jwe->aad_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"aad\")));\n\n      } while (0);\n      json_decref(j_header);\n      o_free(dat_header.data);\n      o_free(dat_iv.data);\n      if (ret == RHN_OK) {\n        if (json_array_size(json_object_get(jwe_json, \"recipients\"))) {\n          jwe->token_mode = R_JSON_MODE_GENERAL;\n          json_array_foreach(json_object_get(jwe_json, \"recipients\"), index, j_recipient) {\n            if (!json_is_object(j_recipient)) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Invalid recipient at index %zu, must be a JSON object\", index);\n              ret = RHN_ERROR_PARAM;\n              break;\n            } else {\n              if (!o_base64url_decode((const unsigned char*)json_string_value(json_object_get(j_recipient, \"encrypted_key\")), json_string_length(json_object_get(j_recipient, \"encrypted_key\")), NULL, &cypher_key_len)) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error at index %zu, invalid encrypted_key base64 %s\", index);\n                ret = RHN_ERROR_PARAM;\n                break;\n              }\n              if (json_object_get(j_recipient, \"header\") != NULL && !json_is_object(json_object_get(j_recipient, \"header\"))) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Invalid header at index %zu, must be a JSON object\", index);\n                ret = RHN_ERROR_PARAM;\n                break;\n              }\n            }\n          }\n        } else {\n          jwe->token_mode = R_JSON_MODE_FLATTENED;\n          jwe->encrypted_key_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"encrypted_key\")));\n          if (json_object_get(jwe_json, \"header\") == NULL || r_jwe_extract_header(jwe, json_object_get(jwe_json, \"header\"), parse_flags, x5u_flags) == RHN_OK) {\n            json_object_update_missing(jwe->j_header, json_object_get(jwe_json, \"header\"));\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - error extracting header params\");\n            ret = RHN_ERROR_PARAM;\n          }\n        }\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error invalid content\");\n      ret = RHN_ERROR_PARAM;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwe_t * r_jwe_quick_parse(const char * jwe_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_quick_parsen(jwe_str, o_strlen(jwe_str), parse_flags, x5u_flags);\n}\n\njwe_t * r_jwe_quick_parsen(const char * jwe_str, size_t jwe_str_len, uint32_t parse_flags, int x5u_flags) {\n  jwe_t * jwe = NULL;\n  int ret;\n\n  if (r_jwe_init(&jwe) == RHN_OK) {\n    ret = r_jwe_advanced_parsen(jwe, jwe_str, jwe_str_len, parse_flags, x5u_flags);\n    if (ret != RHN_OK) {\n      r_jwe_free(jwe);\n      jwe = NULL;\n    }\n  } else {\n    r_jwe_free(jwe);\n    jwe = NULL;\n  }\n  return jwe;\n}\n\nint r_jwe_decrypt(jwe_t * jwe, jwk_t * jwk_privkey, int x5u_flags) {\n  int ret, res;\n  json_t * j_recipient = NULL, * j_header, * j_cur_header;\n  size_t index = 0, i;\n  jwk_t * jwk = NULL, * cur_jwk = NULL;\n  jwa_alg alg;\n\n  if (jwe != NULL) {\n    if (jwk_privkey != NULL) {\n      jwk = r_jwk_copy(jwk_privkey);\n    } else {\n      if (r_jwe_get_header_str_value(jwe, \"kid\") != NULL) {\n        jwk = r_jwks_get_by_kid(jwe->jwks_privkey, r_jwe_get_header_str_value(jwe, \"kid\"));\n      } else if (r_jwks_size(jwe->jwks_privkey) == 1) {\n        jwk = r_jwks_get_at(jwe->jwks_privkey, 0);\n      }\n    }\n  }\n\n  if (jwe != NULL) {\n    if (jwe->token_mode == R_JSON_MODE_GENERAL) {\n      ret = RHN_ERROR_INVALID;\n      o_free(jwe->encrypted_key_b64url);\n      j_header = r_jwe_get_full_header_json_t(jwe);\n      json_array_foreach(json_object_get(jwe->j_json_serialization, \"recipients\"), index, j_recipient) {\n        j_cur_header = json_deep_copy(j_header);\n        json_object_update(j_cur_header, json_object_get(j_recipient, \"header\"));\n        r_jwe_set_full_header_json_t(jwe, j_cur_header);\n        json_decref(j_cur_header);\n        jwe->encrypted_key_b64url = (unsigned char *)json_string_value(json_object_get(j_recipient, \"encrypted_key\"));\n        alg = r_jwe_get_alg(jwe);\n        if (json_object_get(jwe->j_unprotected_header, \"alg\") != NULL) {\n          alg = r_str_to_jwa_alg(json_string_value(json_object_get(jwe->j_unprotected_header, \"alg\")));\n        }\n        if (json_object_get(json_object_get(j_recipient, \"header\"), \"alg\") != NULL) {\n          alg = r_str_to_jwa_alg(json_string_value(json_object_get(json_object_get(j_recipient, \"header\"), \"alg\")));\n        }\n        if (alg != R_JWA_ALG_UNKNOWN && alg != R_JWA_ALG_ECDH_ES) {\n          if (jwk_privkey != NULL) {\n            if (r_jwk_get_property_str(jwk_privkey, \"kid\") == NULL || json_object_get(json_object_get(j_recipient, \"header\"), \"kid\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(json_object_get(j_recipient, \"header\"), \"kid\")), r_jwk_get_property_str(jwk_privkey, \"kid\"))) {\n              if ((res = r_preform_key_decryption(jwe, alg, jwk_privkey, x5u_flags)) != RHN_ERROR_INVALID) {\n                ret = res;\n                break;\n              }\n            }\n          } else {\n            if (json_object_get(json_object_get(j_recipient, \"header\"), \"kid\") != NULL) {\n              cur_jwk = r_jwks_get_by_kid(jwe->jwks_privkey, json_string_value(json_object_get(json_object_get(j_recipient, \"header\"), \"kid\")));\n              if ((res = r_preform_key_decryption(jwe, alg, cur_jwk, x5u_flags)) != RHN_ERROR_INVALID) {\n                ret = res;\n                r_jwk_free(cur_jwk);\n                break;\n              }\n              r_jwk_free(cur_jwk);\n            } else {\n              for (i=0; i<r_jwks_size(jwe->jwks_privkey); i++) {\n                cur_jwk = r_jwks_get_at(jwe->jwks_privkey, i);\n                if ((res = r_preform_key_decryption(jwe, alg, cur_jwk, x5u_flags)) != RHN_ERROR_INVALID) {\n                  ret = res;\n                  r_jwk_free(cur_jwk);\n                  break;\n                }\n                r_jwk_free(cur_jwk);\n              }\n              if (ret != RHN_ERROR_INVALID) {\n                break;\n              }\n            }\n          }\n          cur_jwk = NULL;\n        } else if (alg == R_JWA_ALG_ECDH_ES) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"r_jwe_decrypt - Unsupported algorithm ECDH-ES on general serialization\");\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt - Invalid alg value at index %zu: %d\", index, (alg));\n          ret = RHN_ERROR_PARAM;\n        }\n      }\n      r_jwe_set_full_header_json_t(jwe, j_header);\n      json_decref(j_header);\n      jwe->encrypted_key_b64url = NULL;\n      if (ret == RHN_OK) {\n        ret = r_jwe_decrypt_payload(jwe);\n      }\n    } else {\n      j_header = r_jwe_get_full_header_json_t(jwe);\n      j_cur_header = json_deep_copy(j_header);\n      json_object_update(j_cur_header, json_object_get(j_recipient, \"header\"));\n      if (jwe->j_unprotected_header != NULL) {\n        json_object_update(j_cur_header, jwe->j_unprotected_header);\n      }\n      r_jwe_set_full_header_json_t(jwe, j_cur_header);\n      json_decref(j_cur_header);\n      if ((res = r_jwe_decrypt_key(jwe, jwk, x5u_flags)) == RHN_OK && (res = r_jwe_decrypt_payload(jwe)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        if (res != RHN_ERROR_INVALID) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt - Error decrypting data\");\n        }\n        ret = res;\n      }\n      r_jwe_set_full_header_json_t(jwe, j_header);\n      json_decref(j_header);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  r_jwk_free(jwk);\n  return ret;\n}\n\nchar * r_jwe_serialize(jwe_t * jwe, jwk_t * jwk_pubkey, int x5u_flags) {\n  char * jwe_str = NULL;\n  int res = RHN_OK;\n  unsigned int bits = 0;\n  unsigned char * key = NULL;\n  size_t key_len = 0;\n\n  if (jwk_pubkey != NULL && jwe != NULL && jwe->alg == R_JWA_ALG_DIR) {\n    if (r_jwk_key_type(jwk_pubkey, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && bits == _r_get_key_size(jwe->enc)*8) {\n      key_len = (size_t)(bits/8);\n      if ((key = o_malloc(key_len+4)) != NULL) {\n        if (r_jwk_export_to_symmetric_key(jwk_pubkey, key, &key_len) == RHN_OK) {\n          res = r_jwe_set_cypher_key(jwe, key, key_len);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error r_jwk_export_to_symmetric_key\");\n          res = RHN_ERROR_MEMORY;\n        }\n        o_free(key);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error allocating resources for key\");\n        res = RHN_ERROR_MEMORY;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error invalid key type\");\n      res = RHN_ERROR_PARAM;\n    }\n  } else {\n    res = RHN_OK;\n  }\n\n  if (res == RHN_OK) {\n    if (jwe->key == NULL || !jwe->key_len) {\n      if (r_jwe_generate_cypher_key(jwe) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error r_jwe_generate_cypher_key\");\n        res = RHN_ERROR;\n      }\n    }\n    if (jwe->iv == NULL || !jwe->iv_len) {\n      if (r_jwe_generate_iv(jwe) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error r_jwe_generate_iv\");\n        res = RHN_ERROR;\n      }\n    }\n  }\n  if (res == RHN_OK && r_jwe_set_alg_header(jwe, jwe->j_header) == RHN_OK && r_jwe_encrypt_key(jwe, jwk_pubkey, x5u_flags) == RHN_OK && r_jwe_encrypt_payload(jwe) == RHN_OK) {\n    jwe_str = msprintf(\"%s.%s.%s.%s.%s\",\n                      jwe->header_b64url,\n                      jwe->encrypted_key_b64url!=NULL?(const char *)jwe->encrypted_key_b64url:\"\",\n                      jwe->iv_b64url,\n                      jwe->ciphertext_b64url,\n                      jwe->auth_tag_b64url);\n\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error input parameters\");\n  }\n  return jwe_str;\n}\n\nchar * r_jwe_serialize_json_str(jwe_t * jwe, jwks_t * jwks_pubkey, int x5u_flags, int mode) {\n  json_t * j_result = r_jwe_serialize_json_t(jwe, jwks_pubkey, x5u_flags, mode);\n  char * str_result = json_dumps(j_result, JSON_COMPACT);\n  json_decref(j_result);\n  return str_result;\n}\n\njson_t * r_jwe_serialize_json_t(jwe_t * jwe, jwks_t * jwks_pubkey, int x5u_flags, int mode) {\n  json_t * j_return = NULL, * j_result;\n  jwk_t * jwk = NULL;\n  jwa_alg alg = R_JWA_ALG_NONE;\n  const char * kid = NULL;\n  size_t i = 0;\n  int res = RHN_OK;\n\n  if (jwks_pubkey == NULL) {\n    jwks_pubkey = jwe->jwks_pubkey;\n  }\n  if (jwe != NULL && r_jwks_size(jwks_pubkey)) {\n    jwe->token_mode = mode;\n    if (mode == R_JSON_MODE_FLATTENED) {\n      if ((kid = r_jwe_get_header_str_value(jwe, \"kid\")) != NULL) {\n        jwk = r_jwks_get_by_kid(jwks_pubkey, kid);\n      } else {\n        jwk = r_jwks_get_at(jwks_pubkey, 0);\n        kid = r_jwk_get_property_str(jwk, \"kid\");\n      }\n      alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk, \"alg\"));\n      if (alg == R_JWA_ALG_UNKNOWN) {\n        alg = jwe->alg;\n      }\n      if (jwe->key == NULL || !jwe->key_len) {\n        if (r_jwe_generate_cypher_key(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_cypher_key\");\n          res = RHN_ERROR;\n        }\n      }\n      if (jwe->iv == NULL || !jwe->iv_len) {\n        if (r_jwe_generate_iv(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_iv\");\n          res = RHN_ERROR;\n        }\n      }\n      if (res == RHN_OK) {\n        if ((j_result = r_jwe_perform_key_encryption(jwe, alg, jwk, x5u_flags, &res)) != NULL) {\n          if (r_jwe_encrypt_payload(jwe) == RHN_OK) {\n            if ((kid = r_jwe_get_header_str_value(jwe, \"kid\")) == NULL) {\n              kid = r_jwk_get_property_str(jwk, \"kid\");\n            }\n            j_return = json_pack(\"{ss sO* ss ss ss sO*}\", \"protected\", jwe->header_b64url,\n                                                          \"encrypted_key\", json_object_get(j_result, \"encrypted_key\"),\n                                                          \"iv\", jwe->iv_b64url,\n                                                          \"ciphertext\", jwe->ciphertext_b64url,\n                                                          \"tag\", jwe->auth_tag_b64url,\n                                                          \"header\", json_object_get(j_result, \"header\"));\n            if (jwe->aad_b64url != NULL) {\n              json_object_set_new(j_return, \"aad\", json_string((const char *)jwe->aad_b64url));\n            }\n            if (jwe->j_unprotected_header != NULL) {\n              json_object_set_new(j_return, \"unprotected\", json_deep_copy(jwe->j_unprotected_header));\n            }\n            if (kid != NULL) {\n              json_object_set_new(json_object_get(j_return, \"header\"), \"kid\", json_string(kid));\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error input parameters\");\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error invalid encryption key\");\n        }\n        json_decref(j_result);\n      }\n      r_jwk_free(jwk);\n    } else if (mode == R_JSON_MODE_GENERAL) {\n      if (jwe->key == NULL || !jwe->key_len) {\n        if (r_jwe_generate_cypher_key(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_cypher_key\");\n          res = RHN_ERROR;\n        }\n      }\n      if (jwe->iv == NULL || !jwe->iv_len) {\n        if (r_jwe_generate_iv(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_iv\");\n          res = RHN_ERROR;\n        }\n      }\n      if (res == RHN_OK && r_jwe_encrypt_payload(jwe) == RHN_OK) {\n        j_return = json_pack(\"{ss ss ss ss s[]}\", \"protected\", jwe->header_b64url,\n                                              \"iv\", jwe->iv_b64url,\n                                              \"ciphertext\", jwe->ciphertext_b64url,\n                                              \"tag\", jwe->auth_tag_b64url,\n                                              \"recipients\");\n        if (jwe->aad_b64url != NULL) {\n          json_object_set_new(j_return, \"aad\", json_string((const char *)jwe->aad_b64url));\n        }\n        if (jwe->j_unprotected_header != NULL) {\n          json_object_set_new(j_return, \"unprotected\", json_deep_copy(jwe->j_unprotected_header));\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error input parameters\");\n      }\n      //r_jwe_set_header_str_value(jwe, \"alg\", NULL);\n      for (i=0; i<r_jwks_size(jwks_pubkey); i++) {\n        jwk = r_jwks_get_at(jwks_pubkey, i);\n        kid = r_jwk_get_property_str(jwk, \"kid\");\n        if ((alg = r_jwe_get_alg(jwe)) == R_JWA_ALG_UNKNOWN || alg == R_JWA_ALG_NONE) {\n          alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk, \"alg\"));\n        }\n        if (alg != R_JWA_ALG_UNKNOWN && alg != R_JWA_ALG_ECDH_ES) {\n          if ((j_result = r_jwe_perform_key_encryption(jwe, alg, jwk, x5u_flags, &res)) != NULL) {\n            if (json_object_get(jwe->j_header, \"kid\") == NULL && json_object_get(jwe->j_unprotected_header, \"kid\") == NULL) {\n              json_object_set_new(json_object_get(j_result, \"header\"), \"kid\", json_string(r_jwk_get_property_str(jwk, \"kid\")));\n            }\n            json_array_append(json_object_get(j_return, \"recipients\"), j_result);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error invalid encryption key at index %zu\", i);\n          }\n          json_decref(j_result);\n        } else if (alg == R_JWA_ALG_ECDH_ES) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"r_jwe_serialize_json_t - Unsupported algorithm for JWE with multiple recipients\");\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error invalid encryption algorithm at index %zu\", i);\n        }\n        r_jwk_free(jwk);\n      }\n      if (!json_array_size(json_object_get(j_return, \"recipients\"))) {\n        json_decref(j_return);\n        j_return = NULL;\n      }\n    }\n    json_decref(jwe->j_json_serialization);\n    jwe->j_json_serialization = json_deep_copy(j_return);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error input parameters\");\n  }\n  return j_return;\n}\n\nint r_jwe_set_full_header_json_t(jwe_t * jwe, json_t * j_header) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwa_enc enc;\n\n  if (jwe != NULL && json_is_object(j_header)) {\n    if (json_object_get(j_header, \"alg\") != NULL) {\n      if ((alg = r_str_to_jwa_alg(json_string_value(json_object_get(j_header, \"alg\")))) != R_JWA_ALG_UNKNOWN) {\n        jwe->alg = alg;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error invalid alg parameter\");\n        ret = RHN_ERROR_PARAM;\n      }\n    }\n    if (json_object_get(j_header, \"enc\") != NULL) {\n      if ((enc = r_str_to_jwa_enc(json_string_value(json_object_get(j_header, \"enc\")))) != R_JWA_ENC_UNKNOWN) {\n        jwe->enc = enc;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error invalid enc parameter\");\n        ret = RHN_ERROR_PARAM;\n      }\n    }\n    if (ret == RHN_OK) {\n      json_decref(jwe->j_header);\n      if ((jwe->j_header = json_deep_copy(j_header)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error setting header\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_full_header_json_str(jwe_t * jwe, const char * str_header) {\n  int ret;\n  json_t * j_header = json_loads(str_header, JSON_DECODE_ANY, NULL);\n\n  ret = r_jwe_set_full_header_json_t(jwe, j_header);\n  json_decref(j_header);\n\n  return ret;\n}\n\nint r_jwe_set_full_unprotected_header_json_t(jwe_t * jwe, json_t * j_unprotected_header) {\n  int ret = RHN_OK;\n\n  if (jwe != NULL && json_is_object(j_unprotected_header)) {\n    json_decref(jwe->j_unprotected_header);\n    if ((jwe->j_unprotected_header = json_deep_copy(j_unprotected_header)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_unprotected_header_json_t - Error setting header\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_unprotected_header_json_t - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_full_unprotected_header_json_str(jwe_t * jwe, const char * str_unprotected_header) {\n  int ret;\n  json_t * j_unprotected_header = json_loads(str_unprotected_header, JSON_DECODE_ANY, NULL);\n\n  ret = r_jwe_set_full_unprotected_header_json_t(jwe, j_unprotected_header);\n  json_decref(j_unprotected_header);\n\n  return ret;\n}\n\nint r_jwe_set_properties(jwe_t * jwe, ...) {\n  rhn_opt option;\n  int ret = RHN_OK;\n  int i_value;\n  rhn_int_t r_value;\n  unsigned int ui_value;\n  const char * str_key, * str_value;\n  json_t * j_value;\n  const unsigned char * ustr_value;\n  size_t size_value;\n  jwk_t * jwk;\n  jwks_t * jwks;\n  gnutls_privkey_t privkey;\n  gnutls_pubkey_t pubkey;\n  va_list vl;\n\n  if (jwe != NULL) {\n    va_start(vl, jwe);\n    for (option = va_arg(vl, rhn_opt); option != RHN_OPT_NONE && ret == RHN_OK; option = va_arg(vl, rhn_opt)) {\n      switch (option) {\n        case RHN_OPT_HEADER_INT_VALUE:\n          str_key = va_arg(vl, const char *);\n          i_value = va_arg(vl, int);\n          ret = r_jwe_set_header_int_value(jwe, str_key, (rhn_int_t)i_value);\n          break;\n        case RHN_OPT_HEADER_RHN_INT_VALUE:\n          str_key = va_arg(vl, const char *);\n          r_value = va_arg(vl, rhn_int_t);\n          ret = r_jwe_set_header_int_value(jwe, str_key, r_value);\n          break;\n        case RHN_OPT_HEADER_STR_VALUE:\n          str_key = va_arg(vl, const char *);\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_set_header_str_value(jwe, str_key, str_value);\n          break;\n        case RHN_OPT_HEADER_JSON_T_VALUE:\n          str_key = va_arg(vl, const char *);\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_set_header_json_t_value(jwe, str_key, j_value);\n          break;\n        case RHN_OPT_HEADER_FULL_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_set_full_header_json_t(jwe, j_value);\n          break;\n        case RHN_OPT_HEADER_FULL_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_set_full_header_json_str(jwe, str_value);\n          break;\n        case RHN_OPT_UN_HEADER_FULL_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_set_full_unprotected_header_json_t(jwe, j_value);\n          break;\n        case RHN_OPT_UN_HEADER_FULL_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_set_full_unprotected_header_json_str(jwe, str_value);\n          break;\n        case RHN_OPT_PAYLOAD:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_payload(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_ENC_ALG:\n          ui_value = va_arg(vl, unsigned int);\n          ret = r_jwe_set_alg(jwe, (jwa_alg)ui_value);\n          break;\n        case RHN_OPT_ENC:\n          ui_value = va_arg(vl, unsigned int);\n          ret = r_jwe_set_enc(jwe, (jwa_enc)ui_value);\n          break;\n        case RHN_OPT_CIPHER_KEY:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_cypher_key(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_IV:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_iv(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_AAD:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_aad(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JWK:\n          jwk = va_arg(vl, jwk_t *);\n          ret = r_jwe_add_keys(jwe, NULL, jwk);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JWKS:\n          jwks = va_arg(vl, jwks_t *);\n          ret = r_jwe_add_jwks(jwe, NULL, jwks);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_GNUTLS:\n          pubkey = va_arg(vl, gnutls_pubkey_t);\n          ret = r_jwe_add_keys_gnutls(jwe, NULL, pubkey);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_add_keys_json_t(jwe, NULL, j_value);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_add_keys_json_str(jwe, NULL, str_value);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_PEM_DER:\n          ui_value = va_arg(vl, unsigned int);\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_add_keys_pem_der(jwe, ui_value, NULL, 0, ustr_value, size_value);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JWK:\n          jwk = va_arg(vl, jwk_t *);\n          ret = r_jwe_add_keys(jwe, jwk, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JWKS:\n          jwks = va_arg(vl, jwks_t *);\n          ret = r_jwe_add_jwks(jwe, jwks, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_GNUTLS:\n          privkey = va_arg(vl, gnutls_privkey_t);\n          ret = r_jwe_add_keys_gnutls(jwe, privkey, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_add_keys_json_t(jwe, j_value, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_add_keys_json_str(jwe, str_value, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_PEM_DER:\n          ui_value = va_arg(vl, unsigned int);\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_add_keys_pem_der(jwe, ui_value, ustr_value, size_value, NULL, 0);\n          break;\n        default:\n          ret = RHN_ERROR_PARAM;\n          break;\n      }\n    }\n    va_end(vl);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_properties - Error input parameter\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n"], "fixing_code": ["/**\n *\n * Rhonabwy JSON Web Encryption (JWE) library\n *\n * jwe.c: functions definitions\n *\n * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <string.h>\n#include <ctype.h>\n#include <gnutls/gnutls.h>\n#include <gnutls/crypto.h>\n#include <gnutls/abstract.h>\n#include <gnutls/x509.h>\n#include <orcania.h>\n#include <yder.h>\n#include <rhonabwy.h>\n\n#define R_TAG_MAX_SIZE 16\n\n#define _R_BLOCK_SIZE 256\n\n#define _R_PBES_DEFAULT_ITERATION 4096\n#define _R_PBES_DEFAULT_SALT_LENGTH 8\n#define _R_CURVE_MAX_SIZE 64\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\n#include <nettle/hmac.h>\n#include <nettle/aes.h>\n#include <nettle/memops.h>\n#include <nettle/bignum.h>\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\n#include <nettle/pss-mgf1.h>\n#include <nettle/rsa.h>\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030600\n#include <nettle/curve25519.h>\n#include <nettle/curve448.h>\n#include <nettle/eddsa.h>\n#include <nettle/ecdsa.h>\n#include <nettle/ecc.h>\n#include <nettle/ecc-curve.h>\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030600\n\nstatic int _r_concat_kdf(jwe_t * jwe, jwa_alg alg, const gnutls_datum_t * Z, gnutls_datum_t * kdf) {\n  int ret = RHN_OK;\n  struct _o_datum dat_apu = {0, NULL}, dat_apv = {0, NULL};\n  const char * alg_id = alg==R_JWA_ALG_ECDH_ES?r_jwa_enc_to_str(jwe->enc):r_jwa_alg_to_str(alg),\n             * apu = r_jwe_get_header_str_value(jwe, \"apu\"),\n             * apv = r_jwe_get_header_str_value(jwe, \"apv\");\n  size_t alg_id_len = o_strlen(alg_id), key_data_len = 0;\n\n  kdf->data = NULL;\n  kdf->size = 0;\n  do {\n    if ((kdf->data = o_malloc(4+Z->size)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error malloc kdf->data\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    memset(kdf->data, 0, 3);\n    memset(kdf->data+3, 1, 1);\n    memcpy(kdf->data+4, Z->data, Z->size);\n    kdf->size = 4+Z->size;\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4+alg_id_len)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (1)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    memset(kdf->data+kdf->size, 0, 3);\n    memset(kdf->data+kdf->size+3, (uint8_t)alg_id_len, 1);\n    memcpy(kdf->data+kdf->size+4, alg_id, alg_id_len);\n    kdf->size += 4+alg_id_len;\n\n    if (!o_strnullempty(apu)) {\n      if (!o_base64url_decode_alloc((const unsigned char *)apu, o_strlen(apu), &dat_apu)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error o_base64url_decode_alloc apu\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4+dat_apu.size)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (2)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    kdf->data[kdf->size] = (unsigned char)(dat_apu.size>>24) & 0xFF;\n    kdf->data[kdf->size+1] = (unsigned char)(dat_apu.size>>16) & 0xFF;\n    kdf->data[kdf->size+2] = (unsigned char)(dat_apu.size>>8) & 0xFF;\n    kdf->data[kdf->size+3] = (unsigned char)(dat_apu.size) & 0xFF;\n    if (dat_apu.size) {\n      memcpy(kdf->data+kdf->size+4, dat_apu.data, dat_apu.size);\n    }\n    kdf->size += dat_apu.size+4;\n\n    if (!o_strnullempty(apv)) {\n      if (!o_base64url_decode_alloc((const unsigned char *)apv, o_strlen(apv), &dat_apv)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error o_base64url_decode apv\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4+dat_apv.size)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (3)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    kdf->data[kdf->size] = (unsigned char)(dat_apv.size>>24) & 0xFF;\n    kdf->data[kdf->size+1] = (unsigned char)(dat_apv.size>>16) & 0xFF;\n    kdf->data[kdf->size+2] = (unsigned char)(dat_apv.size>>8) & 0xFF;\n    kdf->data[kdf->size+3] = (unsigned char)(dat_apv.size) & 0xFF;\n    if (dat_apv.size) {\n      memcpy(kdf->data+kdf->size+4, dat_apv.data, dat_apv.size);\n    }\n    kdf->size += dat_apv.size+4;\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      key_data_len = _r_get_key_size(jwe->enc)*8;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A128KW) {\n      key_data_len = 16*8;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A192KW) {\n      key_data_len = 24*8;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A256KW) {\n      key_data_len = 32*8;\n    }\n\n    if (!key_data_len) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error invalid keydatalen\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if ((kdf->data = o_realloc(kdf->data, kdf->size+4)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_concat_kdf - Error realloc kdf->data (4)\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n\n    kdf->data[kdf->size] = (unsigned char)(key_data_len>>24) & 0xFF;\n    kdf->data[kdf->size+1] = (unsigned char)(key_data_len>>16) & 0xFF;\n    kdf->data[kdf->size+2] = (unsigned char)(key_data_len>>8) & 0xFF;\n    kdf->data[kdf->size+3] = (unsigned char)(key_data_len) & 0xFF;\n    kdf->size += 4;\n\n  } while (0);\n\n  o_free(dat_apu.data);\n  o_free(dat_apv.data);\n\n  if (ret != RHN_OK) {\n    o_free(kdf->data);\n    kdf->data = NULL;\n    kdf->size = 0;\n  }\n\n  return ret;\n}\n\nstatic int _r_ecdh_compute(uint8_t * priv_d, size_t pub_d_size, uint8_t * pub_x, size_t pub_x_size, uint8_t * pub_y, size_t pub_y_size, const struct ecc_curve * curve, gnutls_datum_t * Z) {\n  int ret = RHN_OK;\n  struct ecc_scalar priv;\n  struct ecc_point pub, r;\n  mpz_t z_priv_d, z_pub_x, z_pub_y, r_x, r_y;\n  uint8_t r_x_u[64] = {0};\n  size_t r_x_u_len = 64;\n\n  mpz_init(z_priv_d);\n  mpz_init(z_pub_x);\n  mpz_init(z_pub_y);\n  mpz_init(r_x);\n  mpz_init(r_y);\n  ecc_scalar_init(&priv, curve);\n  ecc_point_init(&pub, curve);\n  ecc_point_init(&r, curve);\n  do {\n    mpz_import(z_priv_d, pub_d_size, 1, 1, 0, 0, priv_d);\n    if (!ecc_scalar_set(&priv, z_priv_d)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_ecdh_compute - Error ecc_scalar_set\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    mpz_import(z_pub_x, pub_x_size, 1, 1, 0, 0, pub_x);\n    mpz_import(z_pub_y, pub_y_size, 1, 1, 0, 0, pub_y);\n    if (!ecc_point_set(&pub, z_pub_x, z_pub_y)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_ecdh_compute - Error ecc_point_set\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    ecc_point_mul(&r, &priv, &pub);\n    ecc_point_get(&r, r_x, r_y);\n\n    mpz_export(r_x_u, &r_x_u_len, 1, 1, 0, 0, r_x);\n\n    if ((Z->data = gnutls_malloc(r_x_u_len)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_ecdh_compute - Error gnutls_malloc\");\n      ret = RHN_ERROR_MEMORY;\n      break;\n    }\n    memcpy(Z->data, r_x_u, r_x_u_len);\n    Z->size = r_x_u_len;\n    ret = RHN_OK;\n  } while (0);\n  mpz_clear(z_priv_d);\n  mpz_clear(z_pub_x);\n  mpz_clear(z_pub_y);\n  mpz_clear(r_x);\n  mpz_clear(r_y);\n  ecc_scalar_clear(&priv);\n  ecc_point_clear(&pub);\n  ecc_point_clear(&r);\n\n  return ret;\n}\n\nstatic int _r_dh_compute(uint8_t * priv_k, uint8_t * pub_x, size_t crv_size, gnutls_datum_t * Z) {\n  int ret;\n  uint8_t q[CURVE448_SIZE] = {0};\n\n  if (crv_size == CURVE25519_SIZE) {\n    curve25519_mul(q, priv_k, pub_x);\n  } else {\n    curve448_mul(q, priv_k, pub_x);\n  }\n\n  if ((Z->data = gnutls_malloc(crv_size)) != NULL) {\n    memcpy(Z->data, q, crv_size);\n    Z->size = crv_size;\n    ret = RHN_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"_r_dh_compute - Error gnutls_malloc\");\n    ret = RHN_ERROR_MEMORY;\n  }\n\n  return ret;\n}\n#endif\n\n// https://git.lysator.liu.se/nettle/nettle/-/merge_requests/20\n#if NETTLE_VERSION_NUMBER >= 0x030400\nint\npkcs1_oaep_decrypt (size_t key_size,\n\t       const mpz_t m,\n\t       /* Hash function */\n\t       size_t hlen,\n\t       void * ctx, const struct nettle_hash *hash, nettle_hash_init_func *hash_init, nettle_hash_update_func *hash_update, nettle_hash_digest_func *hash_digest,\n\t       size_t label_length, const uint8_t *label,\n\t       size_t *length, uint8_t *message)\n{\n  int ret = 1;\n  size_t dbMask_len = key_size-1-hlen, i;\n  uint8_t lHash[hlen], k[hlen], seedMask[hlen], maskedSeed[hlen];\n\n  uint8_t *em, *maskedDB, *dbMask, *db;\n\n  em = o_malloc(key_size);\n  maskedDB = o_malloc(dbMask_len);\n  dbMask = o_malloc(dbMask_len);\n  db = o_malloc(dbMask_len);\n\n  // lHash = Hash(L)\n  hash_init(ctx);\n  hash_update(ctx, label_length, label);\n  hash_digest(ctx, hlen, lHash);\n\n  nettle_mpz_get_str_256(key_size, em, m);\n\n  if (em[0])\n    {\n      ret = 0;\n    }\n\n  memcpy(maskedSeed, em+1, hlen);\n  memcpy(maskedDB, em+1+hlen, key_size-1-hlen);\n\n  // seedMask = MGF(maskedDB, hLen).\n  hash_init(ctx);\n  hash_update(ctx, dbMask_len, maskedDB);\n  pss_mgf1(ctx, hash, hlen, seedMask);\n\n  // seed = maskedSeed \\xor seedMask.\n  for (i=0; i<hlen; i++)\n    {\n      k[i] = maskedSeed[i]^seedMask[i];\n    }\n\n  // dbMask = MGF(seed, k - hLen - 1).\n  hash_init(ctx);\n  hash_update(ctx, hlen, k);\n  pss_mgf1(ctx, hash, dbMask_len, dbMask);\n\n  // DB = maskedDB \\xor dbMask.\n  for (i=0; i<dbMask_len; i++)\n    {\n      db[i] = maskedDB[i]^dbMask[i];\n    }\n\n  if (!memeql_sec(db, lHash, hlen))\n    {\n      ret = 0;\n    }\n\n  for (i=hlen; i<dbMask_len-1; i++)\n    {\n      if (db[i] == 0x01)\n      {\n        break;\n      }\n    }\n\n  if (i < dbMask_len-1 && *length >= dbMask_len-i-1 && i < dbMask_len-1)\n  {\n    *length = dbMask_len-i-1;\n    memcpy(message, db+i+1, *length);\n  }\n  else\n  {\n    ret = 0;\n  }\n\n  o_free(em);\n  o_free(maskedDB);\n  o_free(dbMask);\n  o_free(db);\n\n  return ret;\n}\n\nint\nrsa_oaep_sha1_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha1_ctx ctx;\n\n  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n    return 0;\n  }\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA1_DIGEST_SIZE,\n                            &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}\n\nint\nrsa_oaep_sha256_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha256_ctx ctx;\n\n  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n    return 0;\n  }\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA256_DIGEST_SIZE,\n                            &ctx, &nettle_sha256, (nettle_hash_init_func*)&sha256_init, (nettle_hash_update_func*)&sha256_update, (nettle_hash_digest_func*)&sha256_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}\n\nint\npkcs1_oaep_encrypt (size_t key_size,\n\t       void *random_ctx, nettle_random_func *random,\n\t       /* Hash function */\n\t       size_t hlen,\n\t       void * ctx, const struct nettle_hash *hash, nettle_hash_init_func *hash_init, nettle_hash_update_func *hash_update, nettle_hash_digest_func *hash_digest,\n\t       size_t label_length, const uint8_t *label,\n\t       size_t message_length, const uint8_t *message,\n\t       mpz_t m)\n{\n  size_t ps_len = key_size - message_length - (2*hlen) - 2, dbMask_len = key_size - hlen - 1, i;\n  uint8_t lHash[hlen], k[hlen], seedMask[hlen], maskedSeed[hlen];\n  int ret = 1;\n\n  if (key_size < (2*hlen) - 2 || message_length > key_size - (2*hlen) - 2)\n    {\n      return 0;\n    }\n  uint8_t *em, *maskedDB, *dbMask, *db;\n\n  em = o_malloc(dbMask_len + hlen + 1);\n  maskedDB = o_malloc(dbMask_len);\n  dbMask = o_malloc(dbMask_len);\n  db = o_malloc(dbMask_len);\n\n  // lHash = Hash(L)\n  hash_init(ctx);\n  hash_update(ctx, label_length, label);\n  hash_digest(ctx, hlen, lHash);\n\n  // DB = lHash || PS || 0x01 || M.\n\n  memcpy(db, lHash, hlen);\n  memset(db+hlen, 0, ps_len);\n  memset(db+hlen+ps_len, 1, 1);\n  memcpy(db+hlen+ps_len+1, message, message_length);\n\n  random(random_ctx, hlen, k);\n\n  // dbMask = MGF(seed, k - hLen - 1).\n  hash_init(ctx);\n  hash_update(ctx, hlen, k);\n  pss_mgf1(ctx, hash, dbMask_len, dbMask);\n\n  // maskedDB = DB \\xor dbMask.\n  for (i=0; i<dbMask_len; i++)\n    {\n      maskedDB[i] = db[i]^dbMask[i];\n    }\n\n  // seedMask = MGF(maskedDB, hLen).\n  memset(seedMask, 0, hlen);\n  hash_init(ctx);\n  hash_update(ctx, dbMask_len, maskedDB);\n  pss_mgf1(ctx, hash, hlen, seedMask);\n\n  // maskedSeed = seed \\xor seedMask.\n  for (i=0; i<hlen; i++)\n    {\n      maskedSeed[i] = k[i]^seedMask[i];\n    }\n\n  // EM = 0x00 || maskedSeed || maskedDB.\n\n  em[0] = 0;\n  memcpy(em+1, maskedSeed, hlen);\n  memcpy(em+1+hlen, maskedDB, dbMask_len);\n\n  nettle_mpz_set_str_256_u(m, dbMask_len + hlen + 1, em);\n\n  o_free(db);\n  o_free(dbMask);\n  o_free(maskedDB);\n  o_free(em);\n\n  return ret;\n}\n\nint\nrsa_oaep_sha1_encrypt(const struct rsa_public_key *key,\n\t    void *random_ctx, nettle_random_func *random,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t length, const uint8_t *message,\n\t    mpz_t gibberish)\n{\n  struct sha1_ctx ctx;\n  if (pkcs1_oaep_encrypt (key->size, random_ctx, random,\n         SHA1_DIGEST_SIZE,\n         &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,\n         label_length, label,\n\t\t     length, message, gibberish))\n    {\n      mpz_powm(gibberish, gibberish, key->e, key->n);\n      return 1;\n    }\n  else\n    return 0;\n}\n\nint\nrsa_oaep_sha256_encrypt(const struct rsa_public_key *key,\n\t    void *random_ctx, nettle_random_func *random,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t length, const uint8_t *message,\n\t    mpz_t gibberish)\n{\n  struct sha256_ctx ctx;\n  if (pkcs1_oaep_encrypt (key->size, random_ctx, random,\n         SHA256_DIGEST_SIZE,\n         &ctx, &nettle_sha256, (nettle_hash_init_func*)&sha256_init, (nettle_hash_update_func*)&sha256_update, (nettle_hash_digest_func*)&sha256_digest,\n         label_length, label,\n\t\t     length, message, gibberish))\n    {\n      mpz_powm(gibberish, gibberish, key->e, key->n);\n      return 1;\n    }\n  else\n    return 0;\n}\n\nstatic void rnd_nonce_func(void *_ctx, size_t length, uint8_t * data)\n{\n  (void)_ctx;\n\tgnutls_rnd(GNUTLS_RND_NONCE, data, length);\n}\n#endif\n\n// https://git.lysator.liu.se/nettle/nettle/-/merge_requests/19\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic void\nnist_keywrap16(const void *ctx, nettle_cipher_func *encrypt,\n               const uint8_t *iv, size_t ciphertext_length,\n               uint8_t *ciphertext, const uint8_t *cleartext) {\n  uint8_t * R = NULL, A[8] = {0}, I[16] = {0}, B[16] = {0};\n  uint64_t A64;\n  size_t i, j, n;\n\n  if ((R = o_malloc(ciphertext_length-8)) == NULL)\n    return;\n\n  n = (ciphertext_length-8)/8;\n  memcpy(R, cleartext, (ciphertext_length-8));\n  memcpy(A, iv, 8);\n\n  for (j=0; j<6; j++) {\n    for (i=0; i<n; i++) {\n      // I = A | R[1]\n      memcpy(I, A, 8);\n      memcpy(I+8, R+(i*8), 8);\n\n      // B = AES(K, I)\n      encrypt(ctx, 16, B, I);\n\n      // A = MSB(64, B) ^ t where t = (n*j)+i\n      A64 = ((uint64_t)B[0] << 56) | ((uint64_t)B[1] << 48) | ((uint64_t)B[2] << 40) | ((uint64_t)B[3] << 32) | ((uint64_t)B[4] << 24) | ((uint64_t)B[5] << 16) | ((uint64_t)B[6] << 8) | (uint64_t)B[7];\n      A64 ^= (n*j)+(i+1);\n      A[7] = (uint8_t)A64;\n      A[6] = (uint8_t)(A64 >> 8);\n      A[5] = (uint8_t)(A64 >> 16);\n      A[4] = (uint8_t)(A64 >> 24);\n      A[3] = (uint8_t)(A64 >> 32);\n      A[2] = (uint8_t)(A64 >> 40);\n      A[1] = (uint8_t)(A64 >> 48);\n      A[0] = (uint8_t)(A64 >> 56);\n\n      //  R[i] = LSB(64, B)\n      memcpy(R+(i*8), B+8, 8);\n\n    }\n  }\n\n  memcpy(ciphertext, A, 8);\n  memcpy(ciphertext+8, R, (ciphertext_length-8));\n  o_free(R);\n}\n\nstatic int\nnist_keyunwrap16(const void *ctx, nettle_cipher_func *decrypt,\n                 const uint8_t *iv, size_t cleartext_length,\n                 uint8_t *cleartext, const uint8_t *ciphertext) {\n  uint8_t * R = NULL, A[8] = {0}, I[16] = {0}, B[16] = {0};\n  uint64_t A64;\n  int i, j, ret;\n  size_t n;\n\n  if ((R = o_malloc(cleartext_length)) == NULL)\n    return 0;\n\n  n = (cleartext_length/8);\n  memcpy(A, ciphertext, 8);\n  memcpy(R, ciphertext+8, cleartext_length);\n\n  for (j=5; j>=0; j--) {\n    for (i=n-1; i>=0; i--) {\n\n      // B = AES-1(K, (A ^ t) | R[i]) where t = n*j+i\n      A64 = ((uint64_t)A[0] << 56) | ((uint64_t)A[1] << 48) | ((uint64_t)A[2] << 40) | ((uint64_t)A[3] << 32) | ((uint64_t)A[4] << 24) | ((uint64_t)A[5] << 16) | ((uint64_t)A[6] << 8) | (uint64_t)A[7];\n      A64 ^= (n*j)+(i+1);\n      I[7] = (uint8_t)A64;\n      I[6] = (uint8_t)(A64 >> 8);\n      I[5] = (uint8_t)(A64 >> 16);\n      I[4] = (uint8_t)(A64 >> 24);\n      I[3] = (uint8_t)(A64 >> 32);\n      I[2] = (uint8_t)(A64 >> 40);\n      I[1] = (uint8_t)(A64 >> 48);\n      I[0] = (uint8_t)(A64 >> 56);\n      memcpy(I+8, R+(i*8), 8);\n      decrypt(ctx, 16, B, I);\n\n      // A = MSB(64, B)\n      memcpy(A, B, 8);\n\n      // R[i] = LSB(64, B)\n      memcpy(R+(i*8), B+8, 8);\n    }\n  }\n\n  if (memeql_sec(A, iv, 8)) {\n    memcpy(cleartext, R, cleartext_length);\n    ret = 1;\n  } else {\n    ret = 0;\n  }\n  o_free(R);\n  return ret;\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic int _r_rsa_oaep_encrypt(gnutls_pubkey_t g_pub, jwa_alg alg, uint8_t * cleartext, size_t cleartext_len, uint8_t * ciphertext, size_t * cyphertext_len) {\n  struct rsa_public_key pub;\n  gnutls_datum_t m = {NULL, 0}, e = {NULL, 0};\n  int ret = RHN_OK;\n  mpz_t gibberish;\n\n  rsa_public_key_init(&pub);\n  mpz_init(gibberish);\n  if (gnutls_pubkey_export_rsa_raw(g_pub, &m, &e) == GNUTLS_E_SUCCESS) {\n    mpz_import(pub.n, m.size, 1, 1, 0, 0, m.data);\n    mpz_import(pub.e, e.size, 1, 1, 0, 0, e.data);\n    rsa_public_key_prepare(&pub);\n    if (*cyphertext_len >= pub.size) {\n      if (alg == R_JWA_ALG_RSA_OAEP) {\n        if (!rsa_oaep_sha1_encrypt(&pub, NULL, rnd_nonce_func, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error rsa_oaep_sha1_encrypt\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        if (!rsa_oaep_sha256_encrypt(&pub, NULL, rnd_nonce_func, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error rsa_oaep_sha256_encrypt\");\n          ret = RHN_ERROR;\n        }\n      }\n      if (ret == RHN_OK) {\n        nettle_mpz_get_str_256(pub.size, ciphertext, gibberish);\n        *cyphertext_len = pub.size;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error cyphertext to small\");\n      ret = RHN_ERROR_PARAM;\n    }\n    gnutls_free(m.data);\n    gnutls_free(e.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error gnutls_pubkey_export_rsa_raw\");\n    ret = RHN_ERROR;\n  }\n  rsa_public_key_clear(&pub);\n  mpz_clear(gibberish);\n\n  return ret;\n}\n\nstatic int _r_rsa_oaep_decrypt(gnutls_privkey_t g_priv, jwa_alg alg, uint8_t * ciphertext, size_t cyphertext_len, uint8_t * cleartext, size_t * cleartext_len) {\n  struct rsa_private_key priv;\n  gnutls_datum_t m = {NULL, 0}, e = {NULL, 0}, d = {NULL, 0}, p = {NULL, 0}, q = {NULL, 0}, u = {NULL, 0}, e1 = {NULL, 0}, e2 = {NULL, 0};\n  int ret = RHN_OK;\n  mpz_t gibberish;\n\n  rsa_private_key_init(&priv);\n  mpz_init(gibberish);\n  nettle_mpz_set_str_256_u(gibberish, cyphertext_len, ciphertext);\n  if (gnutls_privkey_export_rsa_raw(g_priv, &m, &e, &d, &p, &q, &u, &e1, &e2) == GNUTLS_E_SUCCESS) {\n    mpz_import(priv.d, d.size, 1, 1, 0, 0, d.data);\n    mpz_import(priv.p, p.size, 1, 1, 0, 0, p.data);\n    mpz_import(priv.q, q.size, 1, 1, 0, 0, q.data);\n    mpz_import(priv.a, e1.size, 1, 1, 0, 0, e1.data);\n    mpz_import(priv.b, e2.size, 1, 1, 0, 0, e2.data);\n    mpz_import(priv.c, u.size, 1, 1, 0, 0, u.data);\n    rsa_private_key_prepare(&priv);\n    if (cyphertext_len >= priv.size) {\n      if (alg == R_JWA_ALG_RSA_OAEP) {\n        if (!rsa_oaep_sha1_decrypt(&priv, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_decrypt - Error rsa_oaep_sha1_decrypt\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        if (!rsa_oaep_sha256_decrypt(&priv, 0, NULL, cleartext_len, cleartext, gibberish)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_decrypt - Error rsa_oaep_sha256_decrypt\");\n          ret = RHN_ERROR;\n        }\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error cyphertext to small\");\n      ret = RHN_ERROR_PARAM;\n    }\n    gnutls_free(m.data);\n    gnutls_free(e.data);\n    gnutls_free(d.data);\n    gnutls_free(p.data);\n    gnutls_free(q.data);\n    gnutls_free(u.data);\n    gnutls_free(e1.data);\n    gnutls_free(e2.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"_r_rsa_oaep_encrypt - Error gnutls_pubkey_export_rsa_raw\");\n    ret = RHN_ERROR;\n  }\n  rsa_private_key_clear(&priv);\n  mpz_clear(gibberish);\n\n  return ret;\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic void _r_aes_key_wrap(uint8_t * kek, size_t kek_len, uint8_t * key, size_t key_len, uint8_t * wrapped_key) {\n  struct aes128_ctx ctx_128;\n  struct aes192_ctx ctx_192;\n  struct aes256_ctx ctx_256;\n  void * ctx = NULL;\n  nettle_cipher_func * encrypt = NULL;\n  const uint8_t default_iv[] = {0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6};\n\n  if (kek_len == 16) {\n    aes128_set_encrypt_key(&ctx_128, kek);\n    ctx = (void*)&ctx_128;\n    encrypt = (nettle_cipher_func*)&aes128_encrypt;\n  }\n  if (kek_len == 24) {\n    aes192_set_encrypt_key(&ctx_192, kek);\n    ctx = (void*)&ctx_192;\n    encrypt = (nettle_cipher_func*)&aes192_encrypt;\n  }\n  if (kek_len == 32) {\n    aes256_set_encrypt_key(&ctx_256, kek);\n    ctx = (void*)&ctx_256;\n    encrypt = (nettle_cipher_func*)&aes256_encrypt;\n  }\n  nist_keywrap16(ctx, encrypt, default_iv, key_len+8, wrapped_key, key);\n}\n\nstatic int _r_aes_key_unwrap(uint8_t * kek, size_t kek_len, uint8_t * key, size_t key_len, uint8_t * wrapped_key) {\n  struct aes128_ctx ctx_128;\n  struct aes192_ctx ctx_192;\n  struct aes256_ctx ctx_256;\n  void * ctx = NULL;\n  nettle_cipher_func * decrypt = NULL;\n  const uint8_t default_iv[] = {0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6};\n\n  if (kek_len == 16) {\n    aes128_set_decrypt_key(&ctx_128, kek);\n    ctx = (void*)&ctx_128;\n    decrypt = (nettle_cipher_func*)&aes128_decrypt;\n  }\n  if (kek_len == 24) {\n    aes192_set_decrypt_key(&ctx_192, kek);\n    ctx = (void*)&ctx_192;\n    decrypt = (nettle_cipher_func*)&aes192_decrypt;\n  }\n  if (kek_len == 32) {\n    aes256_set_decrypt_key(&ctx_256, kek);\n    ctx = (void*)&ctx_256;\n    decrypt = (nettle_cipher_func*)&aes256_decrypt;\n  }\n  return nist_keyunwrap16(ctx, decrypt, default_iv, key_len, key, wrapped_key);\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030600\nstatic json_t * _r_jwe_ecdh_encrypt(jwe_t * jwe, jwa_alg alg, jwk_t * jwk_pub, jwk_t * jwk_priv, int type, unsigned int bits, int x5u_flags, int * ret) {\n  int type_priv = 0;\n  unsigned int bits_priv = 0;\n  jwk_t * jwk_ephemeral = NULL, * jwk_ephemeral_pub = NULL;\n  gnutls_datum_t Z = {NULL, 0}, kdf = {NULL, 0};\n  unsigned char cipherkey_b64url[256] = {0};\n  uint8_t derived_key[64] = {0}, wrapped_key[72] = {0}, priv_k[_R_CURVE_MAX_SIZE] = {0}, pub_x[_R_CURVE_MAX_SIZE] = {0}, pub_y[_R_CURVE_MAX_SIZE] = {0};\n  size_t derived_key_len = 0, cipherkey_b64url_len = 0, priv_k_size = 0, pub_x_size = 0, pub_y_size = 0, crv_size = 0;\n  const char * key = NULL;\n  json_t * j_return = NULL;\n  const struct ecc_curve * nettle_curve;\n\n  do {\n    if (r_jwk_init(&jwk_ephemeral_pub) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error r_jwk_init jwk_ephemeral_pub\");\n      *ret = RHN_ERROR;\n      break;\n    }\n\n    if (jwk_priv != NULL) {\n      type_priv = r_jwk_key_type(jwk_priv, &bits_priv, x5u_flags);\n\n      if ((type_priv & 0xffffff00) != (type & 0xffffff00)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error invalid ephemeral key\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (bits != bits_priv) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error invalid ephemeral key length\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (r_jwk_extract_pubkey(jwk_priv, jwk_ephemeral_pub, x5u_flags) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error extracting public key from jwk_priv\");\n        *ret = RHN_ERROR;\n        break;\n      }\n    } else {\n      if (r_jwk_init(&jwk_ephemeral) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error r_jwk_init jwk_ephemeral\");\n        *ret = RHN_ERROR;\n        break;\n      }\n\n      if (r_jwk_generate_key_pair(jwk_ephemeral, jwk_ephemeral_pub, type&R_KEY_TYPE_EC?R_KEY_TYPE_EC:R_KEY_TYPE_ECDH, bits, NULL) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error r_jwk_generate_key_pair\");\n        *ret = RHN_ERROR;\n        break;\n      }\n\n      r_jwk_delete_property_str(jwk_ephemeral_pub, \"kid\");\n    }\n\n    if (type & R_KEY_TYPE_EC) {\n      if (bits == 256) {\n        nettle_curve = nettle_get_secp_256r1();\n        crv_size = 32;\n      } else if (bits == 384) {\n        nettle_curve = nettle_get_secp_384r1();\n        crv_size = 48;\n      } else {\n        nettle_curve = nettle_get_secp_521r1();\n        crv_size = 64;\n      }\n\n      if (jwk_priv != NULL) {\n        key = r_jwk_get_property_str(jwk_priv, \"d\");\n      } else {\n        key = r_jwk_get_property_str(jwk_ephemeral, \"d\");\n      }\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid priv_k_size (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid pub_x_size (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_pub, \"y\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode y (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_y_size || pub_y_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid pub_y_size (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_y, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode y (ecdsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_ecdh_compute(priv_k, priv_k_size, pub_x, pub_x_size, pub_y, pub_y_size, nettle_curve, &Z) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error _r_ecdh_compute (ecdsa)\");\n        *ret = RHN_ERROR;\n        break;\n      }\n    } else {\n      if (bits == 256) {\n        crv_size = CURVE25519_SIZE;\n      } else {\n        crv_size = CURVE448_SIZE;\n      }\n\n      if (jwk_priv != NULL) {\n        key = r_jwk_get_property_str(jwk_priv, \"d\");\n      } else {\n        key = r_jwk_get_property_str(jwk_ephemeral, \"d\");\n      }\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid priv_k_size (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode d (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      pub_x_size = CURVE448_SIZE;\n      key = r_jwk_get_property_str(jwk_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Invalid pub_x_size (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_decode x (eddsa)\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_dh_compute(priv_k, pub_x, crv_size, &Z) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error _r_dh_compute (eddsa)\");\n        *ret = RHN_ERROR;\n        break;\n      }\n    }\n\n\n    if (_r_concat_kdf(jwe, alg, &Z, &kdf) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error _r_concat_kdf\");\n      *ret = RHN_ERROR;\n      break;\n    }\n\n    if (gnutls_hash_fast(GNUTLS_DIG_SHA256, kdf.data, kdf.size, derived_key) != GNUTLS_E_SUCCESS) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error gnutls_hash_fast\");\n      *ret = RHN_ERROR;\n      break;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      derived_key_len = _r_get_key_size(jwe->enc);\n    } else if (alg == R_JWA_ALG_ECDH_ES_A128KW) {\n      derived_key_len = 16;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A192KW) {\n      derived_key_len = 24;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A256KW) {\n      derived_key_len = 32;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      r_jwe_set_cypher_key(jwe, derived_key, derived_key_len);\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      j_return = json_pack(\"{s{ss so}}\", \"header\",\n                                           \"alg\", r_jwa_alg_to_str(alg),\n                                           \"epk\", r_jwk_export_to_json_t(jwk_ephemeral_pub));\n    } else {\n      _r_aes_key_wrap(derived_key, derived_key_len, jwe->key, jwe->key_len, wrapped_key);\n      if (!o_base64url_encode(wrapped_key, jwe->key_len+8, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_encrypt - Error o_base64url_encode wrapped_key\");\n        *ret = RHN_ERROR;\n      }\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = (unsigned char *)o_strndup((const char *)cipherkey_b64url, cipherkey_b64url_len);\n      j_return = json_pack(\"{ss%s{ss so}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len,\n                                             \"header\",\n                                               \"alg\", r_jwa_alg_to_str(alg),\n                                               \"epk\", r_jwk_export_to_json_t(jwk_ephemeral_pub));\n    }\n  } while (0);\n\n  o_free(kdf.data);\n  gnutls_free(Z.data);\n  r_jwk_free(jwk_ephemeral);\n  r_jwk_free(jwk_ephemeral_pub);\n\n  return j_return;\n}\n\nstatic int _r_jwe_ecdh_decrypt(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int type, unsigned int bits, int x5u_flags) {\n  int ret = RHN_OK;\n  jwk_t * jwk_ephemeral_pub = NULL;\n  json_t * j_epk = NULL;\n  unsigned int epk_bits = 0;\n  gnutls_datum_t Z = {NULL, 0}, kdf = {NULL, 0};\n  uint8_t derived_key[64] = {0}, key_data[72] = {0}, cipherkey[128] = {0}, priv_k[_R_CURVE_MAX_SIZE] = {0}, pub_x[_R_CURVE_MAX_SIZE] = {0}, pub_y[_R_CURVE_MAX_SIZE] = {0};\n  size_t derived_key_len = 0, cipherkey_len = 0, priv_k_size = 0, pub_x_size = 0, pub_y_size = 0, crv_size = 0;\n  const char * key = NULL;\n  const struct ecc_curve * nettle_curve;\n\n  do {\n    if ((j_epk = r_jwe_get_header_json_t_value(jwe, \"epk\")) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - No epk header\");\n      ret = RHN_ERROR_PARAM;\n      break;\n    }\n\n    if (r_jwk_init(&jwk_ephemeral_pub) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error r_jwk_init\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if (r_jwk_import_from_json_t(jwk_ephemeral_pub, j_epk) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error r_jwk_import_from_json_t\");\n      ret = RHN_ERROR_PARAM;\n      break;\n    }\n\n    if (type & R_KEY_TYPE_EC) {\n      if (!(r_jwk_key_type(jwk_ephemeral_pub, &epk_bits, x5u_flags) & (R_KEY_TYPE_EC|R_KEY_TYPE_PUBLIC)) || epk_bits != bits) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error invalid private key type (ecc)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (bits == 256) {\n        nettle_curve = nettle_get_secp_256r1();\n        crv_size = 32;\n      } else if (bits == 384) {\n        nettle_curve = nettle_get_secp_384r1();\n        crv_size = 48;\n      } else {\n        nettle_curve = nettle_get_secp_521r1();\n        crv_size = 64;\n      }\n\n      key = r_jwk_get_property_str(jwk, \"d\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid priv_k_size (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_ephemeral_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid pub_x_size (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_ephemeral_pub, \"y\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode y (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_y_size || pub_y_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid pub_y_size (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_y, &pub_y_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode y (ecdsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_ecdh_compute(priv_k, priv_k_size, pub_x, pub_x_size, pub_y, pub_y_size, nettle_curve, &Z) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error _r_ecdh_compute (ecdsa)\");\n        ret = RHN_ERROR;\n        break;\n      }\n    } else {\n      if (!(r_jwk_key_type(jwk_ephemeral_pub, &epk_bits, x5u_flags) & (R_KEY_TYPE_ECDH|R_KEY_TYPE_PUBLIC)) || epk_bits != bits) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error invalid private key type (eddsa)\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n\n      if (bits == 256) {\n        crv_size = CURVE25519_SIZE;\n      } else {\n        crv_size = CURVE448_SIZE;\n      }\n\n      key = r_jwk_get_property_str(jwk, \"d\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), priv_k, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!priv_k_size || priv_k_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid priv_k_size (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &priv_k_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode d (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      key = r_jwk_get_property_str(jwk_ephemeral_pub, \"x\");\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), pub_x, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!pub_x_size || pub_x_size > _R_CURVE_MAX_SIZE) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Invalid priv_k_size (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (!o_base64url_decode((const unsigned char *)key, o_strlen(key), NULL, &pub_x_size)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode x (eddsa)\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n\n      if (_r_dh_compute(priv_k, pub_x, crv_size, &Z) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error _r_dh_compute (eddsa)\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n\n    if (_r_concat_kdf(jwe, alg, &Z, &kdf) != RHN_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error _r_concat_kdf\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if (gnutls_hash_fast(GNUTLS_DIG_SHA256, kdf.data, kdf.size, derived_key) != GNUTLS_E_SUCCESS) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error gnutls_hash_fast\");\n      ret = RHN_ERROR;\n      break;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      derived_key_len = _r_get_key_size(jwe->enc);\n    } else if (alg == R_JWA_ALG_ECDH_ES_A128KW) {\n      derived_key_len = 16;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A192KW) {\n      derived_key_len = 24;\n    } else if (alg == R_JWA_ALG_ECDH_ES_A256KW) {\n      derived_key_len = 32;\n    }\n\n    if (alg == R_JWA_ALG_ECDH_ES) {\n      r_jwe_set_cypher_key(jwe, derived_key, derived_key_len);\n    } else {\n      if (o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) {\n        if (_r_aes_key_unwrap(derived_key, derived_key_len, key_data, cipherkey_len-8, cipherkey)) {\n          r_jwe_set_cypher_key(jwe, key_data, cipherkey_len-8);\n        } else {\n          ret = RHN_ERROR_INVALID;\n          break;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"_r_jwe_ecdh_decrypt - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR;\n        break;\n      }\n    }\n  } while (0);\n\n  o_free(kdf.data);\n  gnutls_free(Z.data);\n  r_jwk_free(jwk_ephemeral_pub);\n  json_decref(j_epk);\n\n  return ret;\n}\n#endif\n\n#if NETTLE_VERSION_NUMBER >= 0x030400\nstatic json_t * r_jwe_aes_key_wrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  uint8_t kek[32] = {0}, wrapped_key[72] = {0};\n  unsigned char cipherkey_b64url[256] = {0};\n  size_t kek_len = 32, cipherkey_b64url_len = 0;\n  unsigned int bits = 0;\n  json_t * j_return = NULL;\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    do {\n      if (alg == R_JWA_ALG_A128KW && bits != 128) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key size, expected 128 bits\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (alg == R_JWA_ALG_A192KW && bits != 192) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key size, expected 192 bits\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (alg == R_JWA_ALG_A256KW && bits != 256) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key size, expected 256 bits\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, kek, &kek_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error r_jwk_export_to_symmetric_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      _r_aes_key_wrap(kek, kek_len, jwe->key, jwe->key_len, wrapped_key);\n      if (!o_base64url_encode(wrapped_key, jwe->key_len+8, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error o_base64url_encode wrapped_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      j_return = json_pack(\"{ss%s{ss}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len, \"header\", \"alg\", r_jwa_alg_to_str(alg));\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = (unsigned char *)o_strndup((const char *)cipherkey_b64url, cipherkey_b64url_len);\n    } while (0);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error invalid key\");\n    *ret = RHN_ERROR_PARAM;\n  }\n  return j_return;\n}\n\nstatic int r_jwe_aes_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  int ret;\n  uint8_t kek[32] = {0}, key_data[64], cipherkey[128] = {0};\n  size_t kek_len = 32, cipherkey_len = 0;\n  unsigned int bits = 0;\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    ret = RHN_OK;\n\n    do {\n      if (alg == R_JWA_ALG_A128KW && bits != 128) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key size, expected 128 bits\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (alg == R_JWA_ALG_A192KW && bits != 192) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key size, expected 192 bits\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (alg == R_JWA_ALG_A256KW && bits != 256) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key size, expected 256 bits\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, kek, &kek_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error r_jwk_export_to_symmetric_key\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), NULL, &cipherkey_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (cipherkey_len > 72) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid cipherkey len\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (!o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (!_r_aes_key_unwrap(kek, kek_len, key_data, cipherkey_len-8, cipherkey)) {\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwe_set_cypher_key(jwe, key_data, cipherkey_len-8) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error r_jwe_set_cypher_key\");\n        ret = RHN_ERROR;\n      }\n    } while (0);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_unwrap - Error invalid key\");\n    ret = RHN_ERROR_INVALID;\n  }\n  return ret;\n}\n#endif\n\n#if GNUTLS_VERSION_NUMBER >= 0x03060d\nstatic json_t * r_jwe_pbes2_key_wrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  unsigned char salt_seed[_R_PBES_DEFAULT_SALT_LENGTH] = {0}, salt_seed_b64[_R_PBES_DEFAULT_SALT_LENGTH*2], * salt = NULL, kek[64] = {0}, * key = NULL, wrapped_key[72] = {0}, cipherkey_b64url[256] = {0};\n  size_t alg_len, salt_len, key_len = 0, cipherkey_b64url_len = 0, salt_seed_b64_len = 0, kek_len = 0;\n  const char * p2s = NULL;\n  unsigned int p2c = 0, bits = 0;\n  gnutls_datum_t password = {NULL, 0}, g_salt = {NULL, 0};\n  gnutls_mac_algorithm_t mac = GNUTLS_MAC_UNKNOWN;\n  json_t * j_return = NULL;\n  struct _o_datum dat_dec = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    do {\n      alg_len = o_strlen(r_jwa_alg_to_str(alg));\n      if ((p2s = r_jwe_get_header_str_value(jwe, \"p2s\")) != NULL) {\n        if (!o_base64url_decode_alloc((const unsigned char *)p2s, o_strlen(p2s), &dat_dec)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_base64url_decode_alloc p2s\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        if (dat_dec.size < 8) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error invalid p2s length\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        salt_len = dat_dec.size + alg_len + 1;\n        if ((salt = o_malloc(salt_len)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_malloc salt (1)\");\n          *ret = RHN_ERROR_MEMORY;\n          break;\n        }\n        memcpy(salt, r_jwa_alg_to_str(alg), alg_len);\n        memset(salt+alg_len, 0, 1);\n        memcpy(salt+alg_len+1, dat_dec.data, dat_dec.size);\n      } else {\n        if (gnutls_rnd(GNUTLS_RND_NONCE, salt_seed, _R_PBES_DEFAULT_SALT_LENGTH)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error gnutls_rnd\");\n          *ret = RHN_ERROR;\n          break;\n        }\n        salt_len = _R_PBES_DEFAULT_SALT_LENGTH + alg_len + 1;\n        if ((salt = o_malloc(salt_len)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_malloc salt (2)\");\n          *ret = RHN_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64url_encode(salt_seed, _R_PBES_DEFAULT_SALT_LENGTH, salt_seed_b64, &salt_seed_b64_len)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_base64url_encode salt_seed\");\n          *ret = RHN_ERROR;\n          break;\n        }\n        salt_seed_b64[salt_seed_b64_len] = '\\0';\n\n        memcpy(salt, r_jwa_alg_to_str(alg), alg_len);\n        memset(salt+alg_len, 0, 1);\n        memcpy(salt+alg_len+1, salt_seed, _R_PBES_DEFAULT_SALT_LENGTH);\n      }\n      if ((p2c = (unsigned int)r_jwe_get_header_int_value(jwe, \"p2c\")) <= 0) {\n        p2c = _R_PBES_DEFAULT_ITERATION;\n      }\n\n      key_len = (bits/8)+4;\n      if ((key = o_malloc(key_len)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error o_malloc key\");\n        *ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error r_jwk_export_to_symmetric_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      password.data = key;\n      password.size = key_len;\n      g_salt.data = salt;\n      g_salt.size = salt_len;\n      if (alg == R_JWA_ALG_PBES2_H256) {\n        kek_len = 16;\n        mac = GNUTLS_MAC_SHA256;\n      } else if (alg == R_JWA_ALG_PBES2_H384) {\n        kek_len = 24;\n        mac = GNUTLS_MAC_SHA384;\n      } else if (alg == R_JWA_ALG_PBES2_H512) {\n        kek_len = 32;\n        mac = GNUTLS_MAC_SHA512;\n      }\n      if (gnutls_pbkdf2(mac, &password, &g_salt, p2c, kek, kek_len) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error gnutls_pbkdf2\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      _r_aes_key_wrap(kek, kek_len, jwe->key, jwe->key_len, wrapped_key);\n      if (!o_base64url_encode(wrapped_key, jwe->key_len+8, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aes_key_wrap - Error o_base64url_encode wrapped_key\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      j_return = json_pack(\"{ss%s{sssssi}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len,\n                                             \"header\",\n                                               \"alg\", r_jwa_alg_to_str(alg),\n                                               \"p2s\", p2s!=NULL?p2s:(const char*)salt_seed_b64,\n                                               \"p2c\", p2c);\n    } while (0);\n    o_free(key);\n    o_free(salt);\n    o_free(dat_dec.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_wrap - Error invalid key\");\n  }\n  return j_return;\n}\n\nstatic int r_jwe_pbes2_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  unsigned char * salt = NULL, kek[64] = {0}, * key = NULL, cipherkey[128] = {0}, key_data[64] = {0};\n  size_t alg_len, salt_len, key_len = 0, cipherkey_len = 0, kek_len = 0;\n  int ret;\n  const char * p2s;\n  unsigned int p2c, bits = 0;\n  gnutls_datum_t password = {NULL, 0}, g_salt = {NULL, 0};\n  gnutls_mac_algorithm_t mac = GNUTLS_MAC_UNKNOWN;\n  struct _o_datum dat_dec = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    ret = RHN_OK;\n\n    do {\n      alg_len = o_strlen(r_jwe_get_header_str_value(jwe, \"alg\"));\n      if ((p2c = (unsigned int)r_jwe_get_header_int_value(jwe, \"p2c\")) <= 0) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error invalid p2c\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (o_strlen(r_jwe_get_header_str_value(jwe, \"p2s\")) < 8) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error invalid p2s\");\n        ret = RHN_ERROR_PARAM;\n        break;\n      }\n      p2s = r_jwe_get_header_str_value(jwe, \"p2s\");\n      if (!o_base64url_decode_alloc((const unsigned char *)p2s, o_strlen(p2s), &dat_dec)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_base64url_decode_alloc p2s\");\n        ret = RHN_ERROR;\n        break;\n      }\n      salt_len = dat_dec.size + alg_len + 1;\n      if ((salt = o_malloc(salt_len)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_malloc salt\");\n        ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      memcpy(salt, r_jwe_get_header_str_value(jwe, \"alg\"), alg_len);\n      memset(salt+alg_len, 0, 1);\n      memcpy(salt+alg_len+1, dat_dec.data, dat_dec.size);\n\n      key_len = (bits/8)+4;\n      if ((key = o_malloc(key_len)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_malloc key\");\n        ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error r_jwk_export_to_symmetric_key\");\n        ret = RHN_ERROR;\n        break;\n      }\n      password.data = key;\n      password.size = key_len;\n      g_salt.data = salt;\n      g_salt.size = salt_len;\n      if (alg == R_JWA_ALG_PBES2_H256) {\n        kek_len = 16;\n        mac = GNUTLS_MAC_SHA256;\n      } else if (alg == R_JWA_ALG_PBES2_H384) {\n        kek_len = 24;\n        mac = GNUTLS_MAC_SHA384;\n      } else if (alg == R_JWA_ALG_PBES2_H512) {\n        kek_len = 32;\n        mac = GNUTLS_MAC_SHA512;\n      }\n      if (gnutls_pbkdf2(mac, &password, &g_salt, p2c, kek, kek_len) != GNUTLS_E_SUCCESS) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error gnutls_pbkdf2\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_decode(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!_r_aes_key_unwrap(kek, kek_len, key_data, cipherkey_len-8, cipherkey)) {\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwe_set_cypher_key(jwe, key_data, cipherkey_len-8) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error r_jwe_set_cypher_key\");\n        ret = RHN_ERROR;\n      }\n    } while (0);\n    o_free(key);\n    o_free(salt);\n    o_free(dat_dec.data);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_pbes2_key_unwrap - Error invalid key\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n#endif\n\nstatic gnutls_mac_algorithm_t r_jwe_get_digest_from_enc(jwa_enc enc) {\n  gnutls_mac_algorithm_t digest;\n\n  switch (enc) {\n    case R_JWA_ENC_A128CBC:\n      digest = GNUTLS_MAC_SHA256;\n      break;\n    case R_JWA_ENC_A192CBC:\n      digest = GNUTLS_MAC_SHA384;\n      break;\n    case R_JWA_ENC_A256CBC:\n      digest = GNUTLS_MAC_SHA512;\n      break;\n    case R_JWA_ENC_A128GCM:\n      digest = GNUTLS_MAC_SHA256;\n      break;\n    case R_JWA_ENC_A192GCM:\n      digest = GNUTLS_MAC_SHA384;\n      break;\n    case R_JWA_ENC_A256GCM:\n      digest = GNUTLS_MAC_SHA512;\n      break;\n    default:\n      digest = GNUTLS_MAC_UNKNOWN;\n      break;\n  }\n  return digest;\n}\n\nstatic gnutls_cipher_algorithm_t r_jwe_get_alg_from_alg(jwa_alg alg) {\n  gnutls_cipher_algorithm_t ret_alg = GNUTLS_CIPHER_UNKNOWN;\n\n  switch (alg) {\n    case R_JWA_ALG_A128GCMKW:\n      ret_alg = GNUTLS_CIPHER_AES_128_GCM;\n      break;\n    case R_JWA_ALG_A192GCMKW:\n#if GNUTLS_VERSION_NUMBER >= 0x03060e\n      ret_alg = GNUTLS_CIPHER_AES_192_GCM;\n#else\n      ret_alg = GNUTLS_CIPHER_UNKNOWN; // Unsupported until GnuTLS 3.6.14\n#endif\n      break;\n    case R_JWA_ALG_A256GCMKW:\n      ret_alg = GNUTLS_CIPHER_AES_256_GCM;\n      break;\n    default:\n      ret_alg = GNUTLS_CIPHER_UNKNOWN;\n      break;\n  }\n  return ret_alg;\n}\n\nstatic json_t * r_jwe_aesgcm_key_wrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  int res;\n  unsigned char iv[96] = {0}, * key = NULL, cipherkey[64] = {0}, cipherkey_b64url[128] = {0}, tag[128] = {0}, tag_b64url[256] = {0};\n  size_t key_len = 0, cipherkey_b64url_len = 0, tag_b64url_len = 0, iv_size = gnutls_cipher_get_iv_size(r_jwe_get_alg_from_alg(alg)), tag_len = gnutls_cipher_get_tag_size(r_jwe_get_alg_from_alg(alg));\n  unsigned int bits = 0;\n  gnutls_datum_t key_g, iv_g;\n  gnutls_cipher_hd_t handle = NULL;\n  json_t * j_return = NULL;\n  struct _o_datum dat_iv_enc = {0, NULL}, dat_iv_dec = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC) {\n    key_len = bits;\n\n    do {\n      if ((key = o_malloc(key_len+4)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error allocating resources for key\");\n        *ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error r_jwk_export_to_symmetric_key\");\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if (r_jwe_get_header_str_value(jwe, \"iv\") == NULL) {\n        if (gnutls_rnd(GNUTLS_RND_NONCE, iv, iv_size)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_rnd\");\n          *ret = RHN_ERROR;\n          break;\n        }\n        if (!o_base64url_encode_alloc(iv, iv_size, &dat_iv_enc)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_encode_alloc iv\");\n          *ret = RHN_ERROR;\n          break;\n        }\n      } else {\n        if (!o_base64url_decode_alloc((const unsigned char *)r_jwe_get_header_str_value(jwe, \"iv\"), o_strlen(r_jwe_get_header_str_value(jwe, \"iv\")), &dat_iv_dec)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_decode iv\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        if (dat_iv_dec.size != iv_size) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error invalid iv size in header\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n        memcpy(iv, dat_iv_dec.data, dat_iv_dec.size);\n        if (iv_size != gnutls_cipher_get_iv_size(r_jwe_get_alg_from_alg(alg))) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error invalid iv size\");\n          *ret = RHN_ERROR_PARAM;\n          break;\n        }\n      }\n      key_g.data = key;\n      key_g.size = key_len;\n      iv_g.data = iv;\n      iv_g.size = iv_size;\n      if ((res = gnutls_cipher_init(&handle, r_jwe_get_alg_from_alg(alg), &key_g, &iv_g))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"%zu - %zu\", key_g.size, iv_g.size);\n        *ret = RHN_ERROR_PARAM;\n        break;\n      }\n      if ((res = gnutls_cipher_encrypt2(handle, jwe->key, jwe->key_len, cipherkey, jwe->key_len))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_cipher_encrypt2: '%s'\", gnutls_strerror(res));\n        *ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_encode(cipherkey, jwe->key_len, cipherkey_b64url, &cipherkey_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_encode cipherkey\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n        *ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_encode(tag, tag_len, tag_b64url, &tag_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error o_base64url_encode tag\");\n        *ret = RHN_ERROR;\n        break;\n      }\n      tag_b64url[tag_b64url_len] = '\\0';\n      j_return = json_pack(\"{ss%s{ssss}}\", \"encrypted_key\", cipherkey_b64url, cipherkey_b64url_len,\n                                           \"header\",\n                                             \"tag\", tag_b64url,\n                                             \"alg\", r_jwa_alg_to_str(alg));\n      if (r_jwe_get_header_str_value(jwe, \"iv\") == NULL) {\n        json_object_set_new(json_object_get(j_return, \"header\"), \"iv\", json_stringn((const char *)dat_iv_enc.data, dat_iv_enc.size));\n      } else {\n        json_object_set_new(json_object_get(j_return, \"header\"), \"iv\", json_string(r_jwe_get_header_str_value(jwe, \"iv\")));\n      }\n    } while (0);\n    o_free(key);\n    o_free(dat_iv_enc.data);\n    o_free(dat_iv_dec.data);\n    if (handle != NULL) {\n      gnutls_cipher_deinit(handle);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_wrap - Error invalid key\");\n    *ret = RHN_ERROR_PARAM;\n  }\n  return j_return;\n}\n\nstatic int r_jwe_set_alg_header(jwe_t * jwe, json_t * j_header) {\n  int ret = RHN_OK;\n  switch (jwe->alg) {\n    case R_JWA_ALG_NONE:\n      json_object_set_new(j_header, \"alg\", json_string(\"none\"));\n      break;\n    case R_JWA_ALG_RSA1_5:\n      json_object_set_new(j_header, \"alg\", json_string(\"RSA1_5\"));\n      break;\n    case R_JWA_ALG_RSA_OAEP:\n      json_object_set_new(j_header, \"alg\", json_string(\"RSA-OAEP\"));\n      break;\n    case R_JWA_ALG_RSA_OAEP_256:\n      json_object_set_new(j_header, \"alg\", json_string(\"RSA-OAEP-256\"));\n      break;\n    case R_JWA_ALG_A128KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A128KW\"));\n      break;\n    case R_JWA_ALG_A192KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A192KW\"));\n      break;\n    case R_JWA_ALG_A256KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A256KW\"));\n      break;\n    case R_JWA_ALG_DIR:\n      json_object_set_new(j_header, \"alg\", json_string(\"dir\"));\n      break;\n    case R_JWA_ALG_ECDH_ES:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES\"));\n      break;\n    case R_JWA_ALG_ECDH_ES_A128KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES+A128KW\"));\n      break;\n    case R_JWA_ALG_ECDH_ES_A192KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES+A192KW\"));\n      break;\n    case R_JWA_ALG_ECDH_ES_A256KW:\n      json_object_set_new(j_header, \"alg\", json_string(\"ECDH-ES+A256KW\"));\n      break;\n    case R_JWA_ALG_A128GCMKW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A128GCMKW\"));\n      break;\n    case R_JWA_ALG_A192GCMKW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A192GCMKW\"));\n      break;\n    case R_JWA_ALG_A256GCMKW:\n      json_object_set_new(j_header, \"alg\", json_string(\"A256GCMKW\"));\n      break;\n    case R_JWA_ALG_PBES2_H256:\n      json_object_set_new(j_header, \"alg\", json_string(\"PBES2-HS256+A128KW\"));\n      break;\n    case R_JWA_ALG_PBES2_H384:\n      json_object_set_new(j_header, \"alg\", json_string(\"PBES2-HS384+A192KW\"));\n      break;\n    case R_JWA_ALG_PBES2_H512:\n      json_object_set_new(j_header, \"alg\", json_string(\"PBES2-HS512+A256KW\"));\n      break;\n    default:\n      ret = RHN_ERROR_PARAM;\n      break;\n  }\n  return ret;\n}\n\nstatic int r_jwe_set_enc_header(jwe_t * jwe, json_t * j_header) {\n  int ret = RHN_OK;\n  switch (jwe->enc) {\n    case R_JWA_ENC_A128CBC:\n      json_object_set_new(j_header, \"enc\", json_string(\"A128CBC-HS256\"));\n      break;\n    case R_JWA_ENC_A192CBC:\n      json_object_set_new(j_header, \"enc\", json_string(\"A192CBC-HS384\"));\n      break;\n    case R_JWA_ENC_A256CBC:\n      json_object_set_new(j_header, \"enc\", json_string(\"A256CBC-HS512\"));\n      break;\n    case R_JWA_ENC_A128GCM:\n      json_object_set_new(j_header, \"enc\", json_string(\"A128GCM\"));\n      break;\n    case R_JWA_ENC_A192GCM:\n      json_object_set_new(j_header, \"enc\", json_string(\"A192GCM\"));\n      break;\n    case R_JWA_ENC_A256GCM:\n      json_object_set_new(j_header, \"enc\", json_string(\"A256GCM\"));\n      break;\n    default:\n      ret = RHN_ERROR_PARAM;\n      break;\n  }\n  return ret;\n}\n\nstatic int r_jwe_aesgcm_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  int ret, res;\n  unsigned char * key = NULL, tag[128] = {0}, tag_b64url[256] = {0};\n  size_t key_len = 0, tag_b64url_len = 0, tag_len = gnutls_cipher_get_tag_size(r_jwe_get_alg_from_alg(alg));\n  unsigned int bits = 0;\n  gnutls_datum_t key_g, iv_g;\n  gnutls_cipher_hd_t handle = NULL;\n  struct _o_datum dat_iv = {0, NULL}, dat_key = {0, NULL};\n\n  if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && !o_strnullempty(r_jwe_get_header_str_value(jwe, \"iv\")) && !o_strnullempty(r_jwe_get_header_str_value(jwe, \"tag\"))) {\n    ret = RHN_OK;\n    key_len = bits;\n\n    do {\n      if ((key = o_malloc(key_len+4)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error allocating resources for key\");\n        ret = RHN_ERROR_MEMORY;\n        break;\n      }\n      if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error r_jwk_export_to_symmetric_key\");\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_decode_alloc((const unsigned char *)r_jwe_get_header_str_value(jwe, \"iv\"), o_strlen(r_jwe_get_header_str_value(jwe, \"iv\")), &dat_iv)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error o_base64url_decode iv\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (!o_base64url_decode_alloc((const unsigned char *)jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), &dat_key)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error o_base64url_decode cipherkey\");\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      key_g.data = key;\n      key_g.size = key_len;\n      iv_g.data = dat_iv.data;\n      iv_g.size = dat_iv.size;\n      if ((res = gnutls_cipher_init(&handle, r_jwe_get_alg_from_alg(alg), &key_g, &iv_g))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if ((res = gnutls_cipher_decrypt(handle, dat_key.data, dat_key.size))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_decrypt: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n        break;\n      }\n      if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n        break;\n      }\n      if (!o_base64url_encode(tag, tag_len, tag_b64url, &tag_b64url_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error o_base64url_encode tag\");\n        ret = RHN_ERROR;\n        break;\n      }\n      tag_b64url[tag_b64url_len] = '\\0';\n      if (0 != o_strcmp((const char *)tag_b64url, r_jwe_get_header_str_value(jwe, \"tag\"))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Invalid tag %s %s\", tag_b64url, r_jwe_get_header_str_value(jwe, \"tag\"));\n        ret = RHN_ERROR_INVALID;\n        break;\n      }\n      if (r_jwe_set_cypher_key(jwe, dat_key.data, dat_key.size) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error r_jwe_set_cypher_key\");\n        ret = RHN_ERROR;\n      }\n\n    } while (0);\n    o_free(key);\n    o_free(dat_key.data);\n    o_free(dat_iv.data);\n    if (handle != NULL) {\n      gnutls_cipher_deinit(handle);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error invalid key\");\n    ret = RHN_ERROR_INVALID;\n  }\n  return ret;\n}\n\nstatic int r_jwe_set_ptext_with_block(unsigned char * data, size_t data_len, unsigned char ** ptext, size_t * ptext_len, gnutls_cipher_algorithm_t alg, int cipher_cbc) {\n  size_t b_size = (size_t)gnutls_cipher_get_block_size(alg);\n  int ret;\n\n  *ptext = NULL;\n  if (cipher_cbc) {\n    if (data_len % b_size) {\n      *ptext_len = ((data_len/b_size)+1)*b_size;\n    } else {\n      *ptext_len = data_len;\n    }\n    if (*ptext_len) {\n      if ((*ptext = o_malloc(*ptext_len)) != NULL) {\n        memcpy(*ptext, data, data_len);\n        memset(*ptext+data_len, (*ptext_len)-data_len, (*ptext_len)-data_len);\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_ptext_with_block - Error allocating resources for ptext (1)\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      ret = RHN_ERROR;\n    }\n  } else {\n    *ptext_len = data_len;\n    if ((*ptext = o_malloc(data_len)) != NULL) {\n      memcpy(*ptext, data, data_len);\n      ret = RHN_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_ptext_with_block - Error allocating resources for ptext (2)\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  }\n  return ret;\n}\n\nstatic int r_jwe_extract_header(jwe_t * jwe, json_t * j_header, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  jwk_t * jwk;\n\n  if (json_is_object(j_header)) {\n    ret = RHN_OK;\n\n    if (json_object_get(j_header, \"alg\") != NULL) {\n      if (0 != o_strcmp(\"RSA1_5\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"RSA-OAEP\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"RSA-OAEP-256\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A128KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A192KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A256KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"dir\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES+A128KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES+A192KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"ECDH-ES+A256KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A128GCMKW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A192GCMKW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"A256GCMKW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"PBES2-HS256+A128KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"PBES2-HS384+A192KW\", json_string_value(json_object_get(j_header, \"alg\"))) &&\n      0 != o_strcmp(\"PBES2-HS512+A256KW\", json_string_value(json_object_get(j_header, \"alg\")))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Invalid alg\");\n        ret = RHN_ERROR_PARAM;\n      } else {\n        jwe->alg = r_str_to_jwa_alg(json_string_value(json_object_get(j_header, \"alg\")));\n      }\n    }\n\n    if (json_object_get(j_header, \"enc\") != NULL) {\n      if (0 != o_strcmp(\"A128CBC-HS256\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A192CBC-HS384\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A256CBC-HS512\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A128GCM\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A192GCM\", json_string_value(json_object_get(j_header, \"enc\"))) &&\n      0 != o_strcmp(\"A256GCM\", json_string_value(json_object_get(j_header, \"enc\")))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Invalid enc\");\n        ret = RHN_ERROR_PARAM;\n      } else {\n        jwe->enc = r_str_to_jwa_enc(json_string_value(json_object_get(j_header, \"enc\")));\n      }\n    }\n\n    if (json_string_length(json_object_get(j_header, \"jku\")) && (parse_flags&R_PARSE_HEADER_JKU)) {\n      if (r_jwks_import_from_uri(jwe->jwks_pubkey, json_string_value(json_object_get(j_header, \"jku\")), x5u_flags) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error loading jwks from uri %s\", json_string_value(json_object_get(j_header, \"jku\")));\n      }\n    }\n\n    if (json_object_get(j_header, \"jwk\") != NULL && (parse_flags&R_PARSE_HEADER_JWK)) {\n      r_jwk_init(&jwk);\n      if (r_jwk_import_from_json_t(jwk, json_object_get(j_header, \"jwk\")) == RHN_OK && r_jwk_key_type(jwk, NULL, 0)&R_KEY_TYPE_PUBLIC) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error parsing header jwk\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        ret = RHN_ERROR_PARAM;\n      }\n      r_jwk_free(jwk);\n    }\n\n    if (json_object_get(j_header, \"x5u\") != NULL && (parse_flags&R_PARSE_HEADER_X5U)) {\n      r_jwk_init(&jwk);\n      if (r_jwk_import_from_x5u(jwk, x5u_flags, json_string_value(json_object_get(j_header, \"x5u\"))) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk) != RHN_OK) {\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error importing x5u\");\n        ret = RHN_ERROR_PARAM;\n      }\n      r_jwk_free(jwk);\n    }\n\n    if (json_object_get(j_header, \"x5c\") != NULL && (parse_flags&R_PARSE_HEADER_X5C)) {\n      r_jwk_init(&jwk);\n      if (r_jwk_import_from_x5c(jwk, json_string_value(json_array_get(json_object_get(j_header, \"x5c\"), 0))) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk) != RHN_OK) {\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_extract_header - Error importing x5c\");\n        ret = RHN_ERROR_PARAM;\n      }\n      r_jwk_free(jwk);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n\n  return ret;\n}\n\nstatic void r_jwe_remove_padding(unsigned char * text, size_t * text_len, unsigned int block_size) {\n  unsigned char pad = text[(*text_len)-1], i;\n  int pad_ok = 1;\n\n  if (pad && pad < (unsigned char)block_size) {\n    for (i=0; i<pad; i++) {\n      if (text[((*text_len)-i-1)] != pad) {\n        pad_ok = 0;\n      }\n    }\n    if (pad_ok) {\n      *text_len -= pad;\n    }\n  }\n}\n\nstatic int r_jwe_compute_hmac_tag(jwe_t * jwe, unsigned char * ciphertext, size_t cyphertext_len, const unsigned char * aad, unsigned char * tag, size_t * tag_len) {\n  int ret, res;\n  unsigned char al[8], * compute_hmac = NULL;\n  uint64_t aad_len;\n  size_t hmac_size = 0, aad_size = o_strlen((const char *)aad), i;\n  gnutls_mac_algorithm_t mac = r_jwe_get_digest_from_enc(jwe->enc);\n\n  aad_len = (uint64_t)(o_strlen((const char *)aad)*8);\n  memset(al, 0, 8);\n  for(i = 0; i < 8; i++) {\n    al[i] = (uint8_t)((aad_len >> 8*(7 - i)) & 0xFF);\n  }\n\n  if ((compute_hmac = o_malloc(aad_size+jwe->iv_len+cyphertext_len+8)) != NULL) {\n    if (aad_size) {\n      memcpy(compute_hmac, aad, aad_size);\n      hmac_size += aad_size;\n    }\n    memcpy(compute_hmac+hmac_size, jwe->iv, jwe->iv_len);\n    hmac_size += jwe->iv_len;\n    memcpy(compute_hmac+hmac_size, ciphertext, cyphertext_len);\n    hmac_size += cyphertext_len;\n    memcpy(compute_hmac+hmac_size, al, 8);\n    hmac_size += 8;\n\n    if (!(res = gnutls_hmac_fast(mac, jwe->key, jwe->key_len/2, compute_hmac, hmac_size, tag))) {\n      *tag_len = gnutls_hmac_get_len(mac)/2;\n      ret = RHN_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compute_hmac_tag - Error gnutls_hmac_fast: '%s'\", gnutls_strerror(res));\n      ret = RHN_ERROR;\n    }\n    o_free(compute_hmac);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compute_hmac_tag - Error allocating resources for compute_hmac\");\n    ret = RHN_ERROR;\n  }\n  return ret;\n}\n\nstatic json_t * r_jwe_perform_key_encryption(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags, int * ret) {\n  json_t * j_return = NULL;\n  int res;\n  unsigned int bits = 0;\n  gnutls_pubkey_t g_pub = NULL;\n  gnutls_datum_t plainkey, cypherkey = {NULL, 0};\n  unsigned char key[128] = {0};\n  size_t key_len = 0, index = 0;\n  const char * key_ref = NULL;\n  json_t * j_element = NULL, * j_reference, * j_key_ref_array;\n  struct _o_datum dat = {0, NULL};\n#if NETTLE_VERSION_NUMBER >= 0x030400\n  uint8_t * cyphertext = NULL;\n  size_t cyphertext_len = 0;\n#endif\n#if NETTLE_VERSION_NUMBER >= 0x030600\n  json_t * jwk_priv = NULL;\n#endif\n\n  switch (alg) {\n    case R_JWA_ALG_RSA1_5:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_RSA|R_KEY_TYPE_PUBLIC) && bits >= 2048) {\n        if (jwk != NULL && (g_pub = r_jwk_export_to_gnutls_pubkey(jwk, x5u_flags)) != NULL) {\n          plainkey.data = jwe->key;\n          plainkey.size = jwe->key_len;\n          if (!(res = gnutls_pubkey_encrypt_data(g_pub, 0, &plainkey, &cypherkey))) {\n            if (o_base64url_encode_alloc(cypherkey.data, cypherkey.size, &dat)) {\n              j_return = json_pack(\"{ss%s{ss}}\", \"encrypted_key\", dat.data, dat.size, \"header\", \"alg\", r_jwa_alg_to_str(alg));\n              o_free(dat.data);\n              dat.data = NULL;\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error o_base64url_encode cypherkey_b64\");\n              *ret = RHN_ERROR;\n            }\n            gnutls_free(cypherkey.data);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error gnutls_pubkey_encrypt_data: %s\", gnutls_strerror(res));\n            *ret = RHN_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Unable to export public key\");\n          *ret = RHN_ERROR;\n        }\n        gnutls_pubkey_deinit(g_pub);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error invalid key type\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_RSA_OAEP:\n    case R_JWA_ALG_RSA_OAEP_256:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_RSA|R_KEY_TYPE_PUBLIC) && bits >= 2048) {\n        if (jwk != NULL && (g_pub = r_jwk_export_to_gnutls_pubkey(jwk, x5u_flags)) != NULL) {\n          if ((cyphertext = o_malloc(bits+1)) != NULL) {\n            cyphertext_len = bits+1;\n            if (_r_rsa_oaep_encrypt(g_pub, alg, jwe->key, jwe->key_len, cyphertext, &cyphertext_len) == RHN_OK) {\n              if (o_base64url_encode_alloc(cyphertext, cyphertext_len, &dat)) {\n                j_return = json_pack(\"{ss%s{ss}}\", \"encrypted_key\", dat.data, dat.size, \"header\", \"alg\", r_jwa_alg_to_str(alg));\n                o_free(dat.data);\n                dat.data = NULL;\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error o_base64url_encode cypherkey_b64\");\n                *ret = RHN_ERROR;\n              }\n              gnutls_free(cypherkey.data);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error _r_rsa_oaep_encrypt\");\n              *ret = RHN_ERROR;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error allocating resources for cyphertext\");\n            *ret = RHN_ERROR_MEMORY;\n          }\n          o_free(cyphertext);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Unable to export public key\");\n          *ret = RHN_ERROR;\n        }\n        gnutls_pubkey_deinit(g_pub);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error invalid key type\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n#endif\n    case R_JWA_ALG_DIR:\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      if (jwk != NULL) {\n        if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && bits == _r_get_key_size(jwe->enc)*8) {\n          key_len = bits/8;\n          if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwk_export_to_symmetric_key\");\n            *ret = RHN_ERROR;\n          } else {\n            if (r_jwe_set_cypher_key(jwe, key, key_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_set_cypher_key\");\n              *ret = RHN_ERROR;\n            } else {\n              j_return = json_object();\n            }\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error invalid key type\");\n          *ret = RHN_ERROR_PARAM;\n        }\n      } else if (jwe->key != NULL && jwe->key_len > 0) {\n        j_return = json_object();\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error no key available for alg 'dir'\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n    case R_JWA_ALG_A128GCMKW:\n#if GNUTLS_VERSION_NUMBER >= 0x03060e\n    case R_JWA_ALG_A192GCMKW:\n#endif\n    case R_JWA_ALG_A256GCMKW:\n      if ((j_return = r_jwe_aesgcm_key_wrap(jwe, alg, jwk, x5u_flags, ret)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_aesgcm_key_wrap\");\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_A128KW:\n    case R_JWA_ALG_A192KW:\n    case R_JWA_ALG_A256KW:\n      if ((j_return = r_jwe_aes_key_wrap(jwe, alg, jwk, x5u_flags, ret)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_aes_key_wrap\");\n      }\n      break;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x03060d\n    case R_JWA_ALG_PBES2_H256:\n    case R_JWA_ALG_PBES2_H384:\n    case R_JWA_ALG_PBES2_H512:\n      if ((j_return = r_jwe_pbes2_key_wrap(jwe, alg, jwk, x5u_flags, ret)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error r_jwe_pbes2_key_wrap\");\n      }\n      break;\n#endif\n#if NETTLE_VERSION_NUMBER >= 0x030600\n    case R_JWA_ALG_ECDH_ES:\n    case R_JWA_ALG_ECDH_ES_A128KW:\n    case R_JWA_ALG_ECDH_ES_A192KW:\n    case R_JWA_ALG_ECDH_ES_A256KW:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_EC|R_KEY_TYPE_PUBLIC)) {\n        if (r_jwks_size(jwe->jwks_privkey) == 1) {\n          jwk_priv = r_jwks_get_at(jwe->jwks_privkey, 0);\n        }\n        if ((j_return = _r_jwe_ecdh_encrypt(jwe, alg, jwk, jwk_priv, res, bits, x5u_flags, ret)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Error _r_jwe_ecdh_encrypt\");\n        }\n        r_jwk_free(jwk_priv);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - invalid public key type\");\n        *ret = RHN_ERROR_PARAM;\n      }\n      break;\n#endif\n    default:\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_perform_key_encryption - Unsupported alg\");\n      *ret = RHN_ERROR_PARAM;\n      break;\n  }\n  j_key_ref_array = json_array();\n  json_object_foreach(json_object_get(j_return, \"header\"), key_ref, j_element) {\n    j_reference = json_object_get(jwe->j_header, key_ref);\n    if (j_reference == NULL) {\n      j_reference = json_object_get(jwe->j_unprotected_header, key_ref);\n    }\n    if (j_reference != NULL && json_equal(j_reference, j_element)) {\n      json_array_append_new(j_key_ref_array, json_string(key_ref));\n    }\n  }\n  json_array_foreach(j_key_ref_array, index, j_element) {\n    json_object_del(json_object_get(j_return, \"header\"), json_string_value(j_element));\n  }\n  json_decref(j_key_ref_array);\n  if (!json_object_size(json_object_get(j_return, \"header\"))) {\n    json_object_del(j_return, \"header\");\n  }\n  return j_return;\n}\n\nstatic int r_preform_key_decryption(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) {\n  int ret, res;\n  gnutls_datum_t plainkey = {NULL, 0}, cypherkey;\n  gnutls_privkey_t g_priv = NULL;\n  unsigned int bits = 0;\n  unsigned char * key = NULL;\n  size_t key_len = 0;\n  struct _o_datum dat = {0, NULL};\n#if NETTLE_VERSION_NUMBER >= 0x030400\n  uint8_t * clearkey = NULL;\n  size_t clearkey_len = 0;\n#endif\n\n  switch (alg) {\n    case R_JWA_ALG_RSA1_5:\n      if (r_jwk_key_type(jwk, &bits, x5u_flags) & (R_KEY_TYPE_RSA|R_KEY_TYPE_PRIVATE) && bits >= 2048) {\n        if (jwk != NULL && !o_strnullempty((const char *)jwe->encrypted_key_b64url) && (g_priv = r_jwk_export_to_gnutls_privkey(jwk)) != NULL) {\n            if (o_base64url_decode_alloc(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), &dat)) {\n              cypherkey.size = dat.size;\n              cypherkey.data = dat.data;\n              if (!(res = gnutls_privkey_decrypt_data(g_priv, 0, &cypherkey, &plainkey))) {\n                if (r_jwe_set_cypher_key(jwe, plainkey.data, plainkey.size) == RHN_OK) {\n                  ret = RHN_OK;\n                } else {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_set_cypher_key (RSA1_5)\");\n                  ret = RHN_ERROR;\n                }\n                gnutls_free(plainkey.data);\n              } else if (res == GNUTLS_E_DECRYPTION_FAILED) {\n                ret = RHN_ERROR_INVALID;\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error gnutls_privkey_decrypt_data: %s\", gnutls_strerror(res));\n                ret = RHN_ERROR;\n              }\n              o_free(dat.data);\n              dat.data = NULL;\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error o_base64url_decode_alloc encrypted_key_b64url\");\n              ret = RHN_ERROR_PARAM;\n            }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid RSA1_5 input parameters\");\n          ret = RHN_ERROR_PARAM;\n        }\n        gnutls_privkey_deinit(g_priv);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key size RSA1_5\");\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_RSA_OAEP:\n    case R_JWA_ALG_RSA_OAEP_256:\n      if (r_jwk_key_type(jwk, &bits, x5u_flags) & (R_KEY_TYPE_RSA|R_KEY_TYPE_PRIVATE) && bits >= 2048) {\n        if (jwk != NULL && !o_strnullempty((const char *)jwe->encrypted_key_b64url) && (g_priv = r_jwk_export_to_gnutls_privkey(jwk)) != NULL) {\n          if (o_base64url_decode_alloc(jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), &dat)) {\n            if ((clearkey = o_malloc(bits+1)) != NULL) {\n              clearkey_len = bits+1;\n              if (_r_rsa_oaep_decrypt(g_priv, alg, dat.data, dat.size, clearkey, &clearkey_len) == RHN_OK) {\n                if (_r_get_key_size(jwe->enc) == clearkey_len) {\n                  if (r_jwe_set_cypher_key(jwe, clearkey, clearkey_len) == RHN_OK) {\n                    ret = RHN_OK;\n                  } else {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_set_cypher_key (RSA_OAEP)\");\n                    ret = RHN_ERROR;\n                  }\n                } else {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key length\");\n                  ret = RHN_ERROR_PARAM;\n                }\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error _r_rsa_oaep_decrypt\");\n                ret = RHN_ERROR_INVALID;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error o_malloc clearkey\");\n              ret = RHN_ERROR_MEMORY;\n            }\n            o_free(clearkey);\n            o_free(dat.data);\n            dat.data = NULL;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error o_base64url_decode_alloc encrypted_key_b64url\");\n            ret = RHN_ERROR_PARAM;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid RSA1-OAEP input parameters\");\n          ret = RHN_ERROR_PARAM;\n        }\n        gnutls_privkey_deinit(g_priv);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key size RSA_OAEP\");\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n#endif\n    case R_JWA_ALG_DIR:\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      if (jwk != NULL) {\n        if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && bits == _r_get_key_size(jwe->enc)*8) {\n          key_len = (size_t)(bits/8);\n          if ((key = o_malloc(key_len+4)) != NULL) {\n            if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) == RHN_OK) {\n              o_free(jwe->encrypted_key_b64url);\n              jwe->encrypted_key_b64url = NULL;\n              ret = r_jwe_set_cypher_key(jwe, key, key_len);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwk_export_to_symmetric_key\");\n              ret = RHN_ERROR_MEMORY;\n            }\n            o_free(key);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error allocating resources for key\");\n            ret = RHN_ERROR_MEMORY;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error invalid key type\");\n          ret = RHN_ERROR_PARAM;\n        }\n      } else if (jwe->key != NULL && jwe->key_len > 0) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error no key available for alg 'dir'\");\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n    case R_JWA_ALG_A128GCMKW:\n#if GNUTLS_VERSION_NUMBER >= 0x03060e\n    case R_JWA_ALG_A192GCMKW:\n#endif\n    case R_JWA_ALG_A256GCMKW:\n      if ((res = r_jwe_aesgcm_key_unwrap(jwe, alg, jwk, x5u_flags)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_aesgcm_key_unwrap\");\n        ret = res;\n      }\n      break;\n#if NETTLE_VERSION_NUMBER >= 0x030400\n    case R_JWA_ALG_A128KW:\n    case R_JWA_ALG_A192KW:\n    case R_JWA_ALG_A256KW:\n      if ((res = r_jwe_aes_key_unwrap(jwe, alg, jwk, x5u_flags)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_aes_key_unwrap\");\n        ret = res;\n      }\n      break;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x03060d\n    case R_JWA_ALG_PBES2_H256:\n    case R_JWA_ALG_PBES2_H384:\n    case R_JWA_ALG_PBES2_H512:\n      if ((res = r_jwe_pbes2_key_unwrap(jwe, alg, jwk, x5u_flags)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error r_jwe_pbes2_key_unwrap\");\n        ret = res;\n      }\n      break;\n#endif\n#if NETTLE_VERSION_NUMBER >= 0x030600\n    case R_JWA_ALG_ECDH_ES:\n    case R_JWA_ALG_ECDH_ES_A128KW:\n    case R_JWA_ALG_ECDH_ES_A192KW:\n    case R_JWA_ALG_ECDH_ES_A256KW:\n      res = r_jwk_key_type(jwk, &bits, x5u_flags);\n      if (res & (R_KEY_TYPE_EC|R_KEY_TYPE_PRIVATE) || res & (R_KEY_TYPE_EDDSA|R_KEY_TYPE_PRIVATE)) {\n        if ((res = _r_jwe_ecdh_decrypt(jwe, alg, jwk, res, bits, x5u_flags)) == RHN_OK) {\n          ret = RHN_OK;\n        } else {\n          if (res != RHN_ERROR_INVALID) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error _r_jwe_ecdh_decrypt\");\n          }\n          ret = res;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - invalid key type %d\", res);\n        ret = RHN_ERROR_INVALID;\n      }\n      break;\n#endif\n    default:\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_preform_key_decryption - Error unsupported algorithm\");\n      ret = RHN_ERROR_INVALID;\n      break;\n  }\n  return ret;\n}\n\nint r_jwe_init(jwe_t ** jwe) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((*jwe = o_malloc(sizeof(jwe_t))) != NULL) {\n      if (((*jwe)->j_header = json_object()) != NULL) {\n        if (r_jwks_init(&(*jwe)->jwks_pubkey) == RHN_OK) {\n          if (r_jwks_init(&(*jwe)->jwks_privkey) == RHN_OK) {\n            (*jwe)->header_b64url = NULL;\n            (*jwe)->encrypted_key_b64url = NULL;\n            (*jwe)->iv_b64url = NULL;\n            (*jwe)->aad_b64url = NULL;\n            (*jwe)->ciphertext_b64url = NULL;\n            (*jwe)->auth_tag_b64url = NULL;\n            (*jwe)->j_unprotected_header = NULL;\n            (*jwe)->alg = R_JWA_ALG_UNKNOWN;\n            (*jwe)->enc = R_JWA_ENC_UNKNOWN;\n            (*jwe)->key = NULL;\n            (*jwe)->key_len = 0;\n            (*jwe)->iv = NULL;\n            (*jwe)->iv_len = 0;\n            (*jwe)->aad = NULL;\n            (*jwe)->aad_len = 0;\n            (*jwe)->payload = NULL;\n            (*jwe)->payload_len = 0;\n            (*jwe)->j_json_serialization = NULL;\n            (*jwe)->token_mode = R_JSON_MODE_COMPACT;\n            ret = RHN_OK;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for jwks_privkey\");\n            ret = RHN_ERROR_MEMORY;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for jwks_pubkey\");\n          ret = RHN_ERROR_MEMORY;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for j_header\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_init - Error allocating resources for jwe\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  if (ret != RHN_OK && jwe != NULL) {\n    r_jwe_free(*jwe);\n    *jwe = NULL;\n  }\n  return ret;\n}\n\nvoid r_jwe_free(jwe_t * jwe) {\n  if (jwe != NULL) {\n    r_jwks_free(jwe->jwks_privkey);\n    r_jwks_free(jwe->jwks_pubkey);\n    o_free(jwe->header_b64url);\n    o_free(jwe->encrypted_key_b64url);\n    o_free(jwe->iv_b64url);\n    o_free(jwe->aad_b64url);\n    o_free(jwe->ciphertext_b64url);\n    o_free(jwe->auth_tag_b64url);\n    json_decref(jwe->j_header);\n    json_decref(jwe->j_unprotected_header);\n    json_decref(jwe->j_json_serialization);\n    o_free(jwe->key);\n    o_free(jwe->iv);\n    o_free(jwe->aad);\n    o_free(jwe->payload);\n    o_free(jwe);\n  }\n}\n\njwe_t * r_jwe_copy(jwe_t * jwe) {\n  jwe_t * jwe_copy = NULL;\n\n  if (jwe != NULL) {\n    if (r_jwe_init(&jwe_copy) == RHN_OK) {\n      jwe_copy->alg = jwe->alg;\n      jwe_copy->enc = jwe->enc;\n      jwe_copy->token_mode = jwe->token_mode;\n      if (r_jwe_set_payload(jwe_copy, jwe->payload, jwe->payload_len) == RHN_OK &&\n          r_jwe_set_iv(jwe_copy, jwe->iv, jwe->iv_len) == RHN_OK &&\n          r_jwe_set_aad(jwe_copy, jwe->aad, jwe->aad_len) == RHN_OK &&\n          r_jwe_set_cypher_key(jwe_copy, jwe->key, jwe->key_len) == RHN_OK &&\n          r_jwe_set_alg(jwe_copy, r_jwe_get_alg(jwe)) == RHN_OK) {\n        jwe_copy->header_b64url = (unsigned char *)o_strdup((const char *)jwe->header_b64url);\n        jwe_copy->encrypted_key_b64url = (unsigned char *)o_strdup((const char *)jwe->encrypted_key_b64url);\n        jwe_copy->ciphertext_b64url = (unsigned char *)o_strdup((const char *)jwe->ciphertext_b64url);\n        jwe_copy->auth_tag_b64url = (unsigned char *)o_strdup((const char *)jwe->auth_tag_b64url);\n        r_jwks_free(jwe_copy->jwks_privkey);\n        jwe_copy->jwks_privkey = r_jwks_copy(jwe->jwks_privkey);\n        r_jwks_free(jwe_copy->jwks_pubkey);\n        jwe_copy->jwks_pubkey = r_jwks_copy(jwe->jwks_pubkey);\n        json_decref(jwe_copy->j_header);\n        jwe_copy->j_header = json_deep_copy(jwe->j_header);\n        jwe_copy->j_unprotected_header = json_deep_copy(jwe->j_unprotected_header);\n        jwe_copy->j_json_serialization = json_deep_copy(jwe->j_json_serialization);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_copy - Error setting values\");\n        r_jwe_free(jwe_copy);\n        jwe_copy = NULL;\n      }\n    }\n  }\n  return jwe_copy;\n}\n\nint r_jwe_set_payload(jwe_t * jwe, const unsigned char * payload, size_t payload_len) {\n  int ret;\n\n  if (jwe != NULL) {\n    o_free(jwe->payload);\n    if (payload != NULL && payload_len) {\n      if ((jwe->payload = o_malloc(payload_len)) != NULL) {\n        memcpy(jwe->payload, payload, payload_len);\n        jwe->payload_len = payload_len;\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_payload - Error allocating resources for payload\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->payload = NULL;\n      jwe->payload_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_payload(jwe_t * jwe, size_t * payload_len) {\n  if (jwe != NULL) {\n    if (payload_len != NULL) {\n      *payload_len = jwe->payload_len;\n    }\n    return jwe->payload;\n  }\n  return NULL;\n}\n\nint r_jwe_set_cypher_key(jwe_t * jwe, const unsigned char * key, size_t key_len) {\n  int ret;\n\n  if (jwe != NULL) {\n    o_free(jwe->key);\n    if (key != NULL && key_len) {\n      if ((jwe->key = o_malloc(key_len)) != NULL) {\n        memcpy(jwe->key, key, key_len);\n        jwe->key_len = key_len;\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_cypher_key - Error allocating resources for key\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->key = NULL;\n      jwe->key_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_cypher_key(jwe_t * jwe, size_t * key_len) {\n  if (jwe != NULL) {\n    if (key_len != NULL) {\n      *key_len = jwe->key_len;\n    }\n    return jwe->key;\n  }\n  return NULL;\n}\n\nint r_jwe_generate_cypher_key(jwe_t * jwe) {\n  int ret;\n\n  if (jwe != NULL && jwe->enc != R_JWA_ENC_UNKNOWN) {\n    o_free(jwe->encrypted_key_b64url);\n    jwe->encrypted_key_b64url = NULL;\n    jwe->key_len = _r_get_key_size(jwe->enc);\n    o_free(jwe->key);\n    if (!jwe->key_len) {\n      ret = RHN_ERROR_PARAM;\n    } else if ((jwe->key = o_malloc(jwe->key_len)) != NULL) {\n      if (!gnutls_rnd(GNUTLS_RND_KEY, jwe->key, jwe->key_len)) {\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_cypher_key - Error gnutls_rnd\");\n        ret = RHN_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_cypher_key - Error allocating resources for key\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_cypher_key - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_iv(jwe_t * jwe, const unsigned char * iv, size_t iv_len) {\n  int ret;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL) {\n    o_free(jwe->iv);\n    if (iv != NULL && iv_len) {\n      if ((jwe->iv = o_malloc(iv_len)) != NULL) {\n        memcpy(jwe->iv, iv, iv_len);\n        jwe->iv_len = iv_len;\n        if (o_base64url_encode_alloc(jwe->iv, jwe->iv_len, &dat)) {\n          o_free(jwe->iv_b64url);\n          jwe->iv_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n          o_free(dat.data);\n          ret = RHN_OK;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_iv - Error o_base64url_encode_alloc iv\");\n          ret = RHN_ERROR;\n        }\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_iv - Error allocating resources for iv\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->iv = NULL;\n      jwe->iv_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_iv(jwe_t * jwe, size_t * iv_len) {\n  if (jwe != NULL) {\n    if (iv_len != NULL) {\n      *iv_len = jwe->iv_len;\n    }\n    return jwe->iv;\n  }\n  return NULL;\n}\n\nint r_jwe_set_aad(jwe_t * jwe, const unsigned char * aad, size_t aad_len) {\n  int ret;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL) {\n    o_free(jwe->aad_b64url);\n    jwe->aad_b64url = NULL;\n    o_free(jwe->aad);\n    if (aad != NULL && aad_len) {\n      if ((jwe->aad = o_malloc(aad_len)) != NULL) {\n        memcpy(jwe->aad, aad, aad_len);\n        jwe->aad_len = aad_len;\n        if (o_base64url_encode_alloc(jwe->aad, jwe->aad_len, &dat)) {\n          o_free(jwe->aad_b64url);\n          jwe->aad_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n          o_free(dat.data);\n          ret = RHN_OK;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_aad - Error o_base64url_encode_alloc aad\");\n          ret = RHN_ERROR;\n        }\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_aad - Error allocating resources for aad\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->aad = NULL;\n      jwe->aad_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst unsigned char * r_jwe_get_aad(jwe_t * jwe, size_t * aad_len) {\n  if (jwe != NULL) {\n    if (aad_len != NULL) {\n      *aad_len = jwe->aad_len;\n    }\n    return jwe->aad;\n  }\n  return NULL;\n}\n\nint r_jwe_generate_iv(jwe_t * jwe) {\n  int ret;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL && jwe->enc != R_JWA_ENC_UNKNOWN) {\n    o_free(jwe->iv_b64url);\n    jwe->iv_b64url = NULL;\n    jwe->iv_len = gnutls_cipher_get_iv_size(_r_get_alg_from_enc(jwe->enc));\n    o_free(jwe->iv);\n    jwe->iv = NULL;\n    if (jwe->iv_len) {\n      if ((jwe->iv = o_malloc(jwe->iv_len)) != NULL) {\n        if (!gnutls_rnd(GNUTLS_RND_NONCE, jwe->iv, jwe->iv_len)) {\n          if (o_base64url_encode_alloc(jwe->iv, jwe->iv_len, &dat)) {\n            jwe->iv_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n            o_free(dat.data);\n            ret = RHN_OK;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_iv - Error o_base64url_encode iv_b64\");\n            ret = RHN_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_iv - Error gnutls_rnd\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_generate_iv - Error allocating resources for iv\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->iv_b64url = (unsigned char *)o_strdup(\"\");\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_alg(jwe_t * jwe, jwa_alg alg) {\n  int ret = RHN_OK;\n\n  if (jwe != NULL) {\n    jwe->alg = alg;\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwa_alg r_jwe_get_alg(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return jwe->alg;\n  } else {\n    return R_JWA_ALG_UNKNOWN;\n  }\n}\n\nint r_jwe_set_enc(jwe_t * jwe, jwa_enc enc) {\n  int ret = RHN_OK;\n\n  if (jwe != NULL) {\n    jwe->enc = enc;\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwa_enc r_jwe_get_enc(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return jwe->enc;\n  } else {\n    return R_JWA_ENC_UNKNOWN;\n  }\n}\n\nconst char * r_jwe_get_kid(jwe_t * jwe) {\n  return r_jwe_get_header_str_value(jwe, \"kid\");\n}\n\nint r_jwe_set_header_str_value(jwe_t * jwe, const char * key, const char * str_value) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((ret = _r_json_set_str_value(jwe->j_header, key, str_value)) == RHN_OK) {\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n    }\n    return ret;\n  } else {\n    return RHN_ERROR_PARAM;\n  }\n}\n\nint r_jwe_set_header_int_value(jwe_t * jwe, const char * key, rhn_int_t i_value) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((ret = _r_json_set_int_value(jwe->j_header, key, i_value)) == RHN_OK) {\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n    }\n    return ret;\n  } else {\n    return RHN_ERROR_PARAM;\n  }\n}\n\nint r_jwe_set_header_json_t_value(jwe_t * jwe, const char * key, json_t * j_value) {\n  int ret;\n\n  if (jwe != NULL) {\n    if ((ret = _r_json_set_json_t_value(jwe->j_header, key, j_value)) == RHN_OK) {\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n    }\n    return ret;\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nconst char * r_jwe_get_header_str_value(jwe_t * jwe, const char * key) {\n  if (jwe != NULL) {\n    return _r_json_get_str_value(jwe->j_header, key);\n  }\n  return NULL;\n}\n\nrhn_int_t r_jwe_get_header_int_value(jwe_t * jwe, const char * key) {\n  if (jwe != NULL) {\n    return _r_json_get_int_value(jwe->j_header, key);\n  }\n  return 0;\n}\n\njson_t * r_jwe_get_header_json_t_value(jwe_t * jwe, const char * key) {\n  if (jwe != NULL) {\n    return _r_json_get_json_t_value(jwe->j_header, key);\n  }\n  return NULL;\n}\n\njson_t * r_jwe_get_full_header_json_t(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return _r_json_get_full_json_t(jwe->j_header);\n  }\n  return NULL;\n}\n\nchar * r_jwe_get_full_header_str(jwe_t * jwe) {\n  char * to_return = NULL;\n  if (jwe != NULL) {\n    to_return = json_dumps(jwe->j_header, JSON_COMPACT);\n  }\n  return to_return;\n}\n\njson_t * r_jwe_get_full_unprotected_header_json_t(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return _r_json_get_full_json_t(jwe->j_unprotected_header);\n  }\n  return NULL;\n}\n\nchar * r_jwe_get_full_unprotected_header_str(jwe_t * jwe) {\n  char * to_return = NULL;\n  if (jwe != NULL) {\n    to_return = json_dumps(jwe->j_unprotected_header, JSON_COMPACT);\n  }\n  return to_return;\n}\n\nint r_jwe_add_keys(jwe_t * jwe, jwk_t * jwk_privkey, jwk_t * jwk_pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n\n  if (jwe != NULL && (jwk_privkey != NULL || jwk_pubkey != NULL)) {\n    if (jwk_privkey != NULL) {\n      if (r_jwks_append_jwk(jwe->jwks_privkey, jwk_privkey) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys - Error setting jwk_privkey\");\n        ret = RHN_ERROR;\n      }\n      if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n        r_jwe_set_alg(jwe, alg);\n      }\n    }\n    if (jwk_pubkey != NULL) {\n      if (r_jwks_append_jwk(jwe->jwks_pubkey, jwk_pubkey) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys - Error setting jwk_pubkey\");\n        ret = RHN_ERROR;\n      }\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_jwks(jwe_t * jwe, jwks_t * jwks_privkey, jwks_t * jwks_pubkey) {\n  size_t i;\n  int ret, res;\n  jwk_t * jwk;\n\n  if (jwe != NULL && (jwks_privkey != NULL || jwks_pubkey != NULL)) {\n    ret = RHN_OK;\n    if (jwks_privkey != NULL) {\n      for (i=0; ret==RHN_OK && i<r_jwks_size(jwks_privkey); i++) {\n        jwk = r_jwks_get_at(jwks_privkey, i);\n        if ((res = r_jwe_add_keys(jwe, jwk, NULL)) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_jwks - Error r_jwe_add_keys private key at %zu\", i);\n          ret = res;\n        }\n        r_jwk_free(jwk);\n      }\n    }\n    if (jwks_pubkey != NULL) {\n      for (i=0; ret==RHN_OK && i<r_jwks_size(jwks_pubkey); i++) {\n        jwk = r_jwks_get_at(jwks_pubkey, i);\n        if ((res = r_jwe_add_keys(jwe, NULL, jwk)) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_jwks - Error r_jwe_add_keys public key at %zu\", i);\n          ret = res;\n        }\n        r_jwk_free(jwk);\n      }\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_json_str(jwe_t * jwe, const char * privkey, const char * pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_json_str(j_privkey, privkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_json_str(j_pubkey, pubkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_str - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_json_t(jwe_t * jwe, json_t * privkey, json_t * pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_json_t(j_privkey, privkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_json_t(j_pubkey, pubkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_json_t - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_pem_der(jwe_t * jwe, int format, const unsigned char * privkey, size_t privkey_len, const unsigned char * pubkey, size_t pubkey_len) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_pem_der(j_privkey, R_X509_TYPE_PRIVKEY, format, privkey, privkey_len) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_pem_der(j_pubkey, R_X509_TYPE_PUBKEY, format, pubkey, pubkey_len) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_pem_der - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_keys_gnutls(jwe_t * jwe, gnutls_privkey_t privkey, gnutls_pubkey_t pubkey) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_privkey = NULL, * j_pubkey = NULL;\n\n  if (jwe != NULL && (privkey != NULL || pubkey != NULL)) {\n    if (privkey != NULL) {\n      if (r_jwk_init(&j_privkey) == RHN_OK && r_jwk_import_from_gnutls_privkey(j_privkey, privkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_privkey, j_privkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error setting privkey\");\n          ret = RHN_ERROR;\n        }\n        if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_privkey, \"alg\"))) != R_JWA_ALG_NONE) {\n          r_jwe_set_alg(jwe, alg);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error parsing privkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_privkey);\n    }\n    if (pubkey != NULL) {\n      if (r_jwk_init(&j_pubkey) == RHN_OK && r_jwk_import_from_gnutls_pubkey(j_pubkey, pubkey) == RHN_OK) {\n        if (r_jwks_append_jwk(jwe->jwks_pubkey, j_pubkey) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error setting pubkey\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_keys_gnutls - Error parsing pubkey\");\n        ret = RHN_ERROR;\n      }\n      r_jwk_free(j_pubkey);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_add_key_symmetric(jwe_t * jwe, const unsigned char * key, size_t key_len) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwk_t * j_key = NULL;\n\n  if (jwe != NULL && key != NULL && key_len) {\n    if (r_jwk_init(&j_key) == RHN_OK && r_jwk_import_from_symmetric_key(j_key, key, key_len) == RHN_OK) {\n      if (r_jwks_append_jwk(jwe->jwks_privkey, j_key) != RHN_OK || r_jwks_append_jwk(jwe->jwks_pubkey, j_key) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_enc_key_symmetric - Error setting key\");\n        ret = RHN_ERROR;\n      }\n      if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(j_key, \"alg\"))) != R_JWA_ALG_NONE) {\n        r_jwe_set_alg(jwe, alg);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_add_enc_key_symmetric - Error parsing key\");\n      ret = RHN_ERROR;\n    }\n    r_jwk_free(j_key);\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwks_t * r_jwe_get_jwks_privkey(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return r_jwks_copy(jwe->jwks_privkey);\n  } else {\n    return NULL;\n  }\n}\n\njwks_t * r_jwe_get_jwks_pubkey(jwe_t * jwe) {\n  if (jwe != NULL) {\n    return r_jwks_copy(jwe->jwks_pubkey);\n  } else {\n    return NULL;\n  }\n}\n\nint r_jwe_encrypt_payload(jwe_t * jwe) {\n  int ret = RHN_OK, res;\n  gnutls_cipher_hd_t handle;\n  gnutls_datum_t key, iv;\n  unsigned char * ptext = NULL, * text_zip = NULL, * ciphertext_b64url = NULL, tag[128] = {0}, * tag_b64url = NULL, * aad = NULL;\n  size_t ptext_len = 0, ciphertext_b64url_len = 0, tag_len = 0, text_zip_len = 0;\n  char * str_header = NULL;\n  int cipher_cbc;\n  struct _o_datum dat = {0, NULL};\n\n  if (jwe != NULL &&\n      jwe->payload != NULL &&\n      jwe->payload_len &&\n      jwe->enc != R_JWA_ENC_UNKNOWN &&\n      jwe->key != NULL &&\n      jwe->iv != NULL &&\n      jwe->iv_len &&\n      jwe->key_len == _r_get_key_size(jwe->enc) &&\n      r_jwe_set_enc_header(jwe, jwe->j_header) == RHN_OK) {\n    cipher_cbc = (jwe->enc == R_JWA_ENC_A128CBC || jwe->enc == R_JWA_ENC_A192CBC || jwe->enc == R_JWA_ENC_A256CBC);\n\n    if ((str_header = json_dumps(jwe->j_header, JSON_COMPACT)) != NULL) {\n      if (o_base64url_encode_alloc((const unsigned char *)str_header, o_strlen(str_header), &dat)) {\n        o_free(jwe->header_b64url);\n        jwe->header_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n        o_free(dat.data);\n        dat.data = NULL;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error o_base64url_encode str_header\");\n        ret = RHN_ERROR;\n      }\n      o_free(str_header);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error json_dumps j_header\");\n      ret = RHN_ERROR;\n    }\n\n    ptext_len = gnutls_cipher_get_block_size(_r_get_alg_from_enc(jwe->enc));\n    if (0 == o_strcmp(\"DEF\", r_jwe_get_header_str_value(jwe, \"zip\"))) {\n      if (_r_deflate_payload(jwe->payload, jwe->payload_len, &text_zip, &text_zip_len) == RHN_OK) {\n        if (r_jwe_set_ptext_with_block(text_zip, text_zip_len, &ptext, &ptext_len, _r_get_alg_from_enc(jwe->enc), cipher_cbc) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error r_jwe_set_ptext_with_block\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error _r_deflate_payload\");\n        ret = RHN_ERROR;\n      }\n      o_free(text_zip);\n    } else {\n      if (r_jwe_set_ptext_with_block(jwe->payload, jwe->payload_len, &ptext, &ptext_len, _r_get_alg_from_enc(jwe->enc), cipher_cbc) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error r_jwe_set_ptext_with_block\");\n        ret = RHN_ERROR;\n      }\n    }\n\n    if (ret == RHN_OK) {\n      if (cipher_cbc) {\n        key.data = jwe->key+(jwe->key_len/2);\n        key.size = jwe->key_len/2;\n      } else {\n        key.data = jwe->key;\n        key.size = jwe->key_len;\n      }\n      iv.data = jwe->iv;\n      iv.size = jwe->iv_len;\n      if (!(res = gnutls_cipher_init(&handle, _r_get_alg_from_enc(jwe->enc), &key, &iv))) {\n        if (jwe->aad_b64url == NULL || jwe->token_mode == R_JSON_MODE_COMPACT) {\n          aad = (unsigned char *)o_strdup((const char *)jwe->header_b64url);\n        } else {\n          aad = (unsigned char *)msprintf(\"%s.%s\", jwe->header_b64url, jwe->aad_b64url);\n        }\n        if (!cipher_cbc && (res = gnutls_cipher_add_auth(handle, aad, o_strlen((const char *)aad)))) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_add_auth: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (ret == RHN_OK) {\n          if (!(res = gnutls_cipher_encrypt(handle, ptext, ptext_len))) {\n            if ((ciphertext_b64url = o_malloc(2*ptext_len)) != NULL) {\n              if (o_base64url_encode(ptext, ptext_len, ciphertext_b64url, &ciphertext_b64url_len)) {\n                o_free(jwe->ciphertext_b64url);\n                jwe->ciphertext_b64url = (unsigned char *)o_strndup((const char *)ciphertext_b64url, ciphertext_b64url_len);\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error o_base64url_encode ciphertext\");\n                ret = RHN_ERROR;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error allocating resources for ciphertext_b64url\");\n              ret = RHN_ERROR_MEMORY;\n            }\n            o_free(ciphertext_b64url);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_encrypt: '%s'\", gnutls_strerror(res));\n            ret = RHN_ERROR;\n          }\n        } else if (!cipher_cbc) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_add_auth: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (ret == RHN_OK) {\n          if (cipher_cbc) {\n            if (r_jwe_compute_hmac_tag(jwe, ptext, ptext_len, aad, tag, &tag_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error r_jwe_compute_hmac_tag\");\n              ret = RHN_ERROR;\n            }\n          } else {\n            tag_len = gnutls_cipher_get_tag_size(_r_get_alg_from_enc(jwe->enc));\n            memset(tag, 0, tag_len);\n            if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n              ret = RHN_ERROR;\n            }\n          }\n          if (ret == RHN_OK && tag_len) {\n            if ((tag_b64url = o_malloc(tag_len*2)) != NULL) {\n              if (o_base64url_encode_alloc(tag, tag_len, &dat)) {\n                o_free(jwe->auth_tag_b64url);\n                jwe->auth_tag_b64url = (unsigned char *)o_strndup((const char *)dat.data, dat.size);\n                o_free(dat.data);\n                dat.data = NULL;\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error o_base64url_encode tag_b64url\");\n                ret = RHN_ERROR;\n              }\n              o_free(tag_b64url);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error allocating resources for tag_b64url\");\n              ret = RHN_ERROR_MEMORY;\n            }\n          }\n        }\n        o_free(aad);\n        gnutls_cipher_deinit(handle);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_payload - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  o_free(ptext);\n  return ret;\n}\n\nint r_jwe_decrypt_payload(jwe_t * jwe) {\n  int ret = RHN_OK, res;\n  gnutls_cipher_hd_t handle;\n  gnutls_datum_t key, iv;\n  unsigned char * payload_enc = NULL, * unzip = NULL, * aad = NULL;\n  size_t payload_enc_len = 0, unzip_len = 0;\n  unsigned char tag[128];\n  size_t tag_len = 0;\n  int cipher_cbc;\n  struct _o_datum dat = {0, NULL}, dat_ciph = {0, NULL}, dat_tag = {0, NULL};\n\n  if (jwe != NULL && jwe->enc != R_JWA_ENC_UNKNOWN && !o_strnullempty((const char *)jwe->ciphertext_b64url) && !o_strnullempty((const char *)jwe->iv_b64url) && jwe->key != NULL && jwe->key_len && jwe->key_len == _r_get_key_size(jwe->enc)) {\n    // Decode iv and payload_b64\n    o_free(jwe->iv);\n    if (o_base64url_decode_alloc(jwe->iv_b64url, o_strlen((const char *)jwe->iv_b64url), &dat)) {\n      if ((jwe->iv = o_malloc(dat.size)) != NULL) {\n        jwe->iv_len = dat.size;\n        memcpy(jwe->iv, dat.data, dat.size);\n        if (o_base64url_decode_alloc(jwe->ciphertext_b64url, o_strlen((const char *)jwe->ciphertext_b64url), &dat_ciph)) {\n          if ((payload_enc = o_malloc(dat_ciph.size)) == NULL) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error allocating resources for payload_enc\");\n            ret = RHN_ERROR_MEMORY;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error o_base64url_decode_alloc ciphertext_b64url\");\n          ret = RHN_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error reallocating resources for iv\");\n        ret = RHN_ERROR_MEMORY;\n      }\n      o_free(dat.data);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error o_base64url_decode_alloc iv\");\n      ret = RHN_ERROR;\n    }\n\n    if (ret == RHN_OK) {\n      if (jwe->enc == R_JWA_ENC_A128CBC || jwe->enc == R_JWA_ENC_A192CBC || jwe->enc == R_JWA_ENC_A256CBC) {\n        key.data = jwe->key+(jwe->key_len/2);\n        key.size = jwe->key_len/2;\n        cipher_cbc = 1;\n      } else {\n        key.data = jwe->key;\n        key.size = jwe->key_len;\n        cipher_cbc = 0;\n      }\n      iv.data = jwe->iv;\n      iv.size = jwe->iv_len;\n      payload_enc_len = dat_ciph.size;\n      if (!(res = gnutls_cipher_init(&handle, _r_get_alg_from_enc(jwe->enc), &key, &iv))) {\n        if (jwe->aad_b64url == NULL || jwe->token_mode == R_JSON_MODE_COMPACT) {\n          aad = (unsigned char *)o_strdup((const char *)jwe->header_b64url);\n        } else {\n          aad = (unsigned char *)msprintf(\"%s.%s\", jwe->header_b64url, jwe->aad_b64url);\n        }\n        if (!cipher_cbc && (res = gnutls_cipher_add_auth(handle, aad, o_strlen((const char *)aad)))) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_add_auth: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (!(res = gnutls_cipher_decrypt2(handle, dat_ciph.data, dat_ciph.size, payload_enc, payload_enc_len))) {\n          if (cipher_cbc) {\n            r_jwe_remove_padding(payload_enc, &payload_enc_len, gnutls_cipher_get_block_size(_r_get_alg_from_enc(jwe->enc)));\n          }\n          if (0 == o_strcmp(\"DEF\", r_jwe_get_header_str_value(jwe, \"zip\"))) {\n            if (_r_inflate_payload(payload_enc, payload_enc_len, &unzip, &unzip_len) == RHN_OK) {\n              if (r_jwe_set_payload(jwe, unzip, unzip_len) != RHN_OK) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error r_jwe_set_payload\");\n                ret = RHN_ERROR;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error _r_inflate_payload\");\n              ret = RHN_ERROR;\n            }\n            o_free(unzip);\n          } else {\n            if (r_jwe_set_payload(jwe, payload_enc, payload_enc_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error r_jwe_set_payload\");\n              ret = RHN_ERROR;\n            }\n          }\n        } else if (res == GNUTLS_E_DECRYPTION_FAILED) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - decryption failed: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR_INVALID;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_decrypt: '%s'\", gnutls_strerror(res));\n          ret = RHN_ERROR;\n        }\n        if (ret == RHN_OK) {\n          if (cipher_cbc) {\n            if (r_jwe_compute_hmac_tag(jwe, dat_ciph.data, dat_ciph.size, aad, tag, &tag_len) != RHN_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error r_jwe_compute_hmac_tag\");\n              ret = RHN_ERROR;\n            }\n          } else {\n            tag_len = gnutls_cipher_get_tag_size(_r_get_alg_from_enc(jwe->enc));\n            memset(tag, 0, tag_len);\n            if ((res = gnutls_cipher_tag(handle, tag, tag_len))) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_tag: '%s'\", gnutls_strerror(res));\n              ret = RHN_ERROR;\n            }\n          }\n          if (ret == RHN_OK && tag_len) {\n            if (o_base64url_encode_alloc(tag, tag_len, &dat_tag)) {\n              if (dat_tag.size != o_strlen((const char *)jwe->auth_tag_b64url) || 0 != memcmp(dat_tag.data, jwe->auth_tag_b64url, dat_tag.size)) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Invalid tag\");\n                ret = RHN_ERROR_INVALID;\n              }\n              o_free(dat_tag.data);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error o_base64url_encode_alloc tag\");\n              ret = RHN_ERROR;\n            }\n          }\n        }\n        o_free(aad);\n        gnutls_cipher_deinit(handle);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error gnutls_cipher_init: '%s'\", gnutls_strerror(res));\n        ret = RHN_ERROR;\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt_payload - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  o_free(payload_enc);\n  o_free(dat_ciph.data);\n\n  return ret;\n}\n\nint r_jwe_encrypt_key(jwe_t * jwe, jwk_t * jwk_s, int x5u_flags) {\n  int ret, res = RHN_OK;\n  jwk_t * jwk = NULL;\n  jwa_alg alg;\n  const char * kid;\n  json_t * j_header = NULL, * j_cur_header = NULL;\n\n  if (jwe != NULL) {\n    if (jwk_s != NULL) {\n      jwk = r_jwk_copy(jwk_s);\n      if (jwe->alg == R_JWA_ALG_UNKNOWN && (alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk, \"alg\"))) != R_JWA_ALG_NONE) {\n        r_jwe_set_alg(jwe, alg);\n      }\n    } else {\n      if (r_jwe_get_header_str_value(jwe, \"kid\") != NULL) {\n        jwk = r_jwks_get_by_kid(jwe->jwks_pubkey, r_jwe_get_header_str_value(jwe, \"kid\"));\n      } else if (r_jwks_size(jwe->jwks_pubkey) == 1) {\n        jwk = r_jwks_get_at(jwe->jwks_pubkey, 0);\n      }\n    }\n  }\n\n  if (jwe != NULL && jwe->key != NULL && jwe->key_len && jwe->alg != R_JWA_ALG_UNKNOWN && jwe->alg != R_JWA_ALG_NONE) {\n    if ((kid = r_jwk_get_property_str(jwk, \"kid\")) != NULL && r_jwe_get_header_str_value(jwe, \"kid\") == NULL) {\n      r_jwe_set_header_str_value(jwe, \"kid\", kid);\n    }\n    if ((j_header = r_jwe_perform_key_encryption(jwe, jwe->alg, jwk, x5u_flags, &res)) != NULL) {\n      j_cur_header = r_jwe_get_full_header_json_t(jwe);\n      json_object_update(j_cur_header, json_object_get(j_header, \"header\"));\n      r_jwe_set_full_header_json_t(jwe, j_cur_header);\n      json_decref(j_cur_header);\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(j_header, \"encrypted_key\")));\n      json_decref(j_header);\n      ret = RHN_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_key - Error r_jwe_perform_key_encryption\");\n      ret = res;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_encrypt_key - invalid input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n\n  r_jwk_free(jwk);\n  return ret;\n}\n\nint r_jwe_decrypt_key(jwe_t * jwe, jwk_t * jwk_s, int x5u_flags) {\n  int ret;\n  jwk_t * jwk = NULL;\n\n  if (jwe != NULL) {\n    if (jwk_s != NULL) {\n      jwk = r_jwk_copy(jwk_s);\n    } else {\n      if (r_jwe_get_header_str_value(jwe, \"kid\") != NULL) {\n        jwk = r_jwks_get_by_kid(jwe->jwks_privkey, r_jwe_get_header_str_value(jwe, \"kid\"));\n      } else if (r_jwks_size(jwe->jwks_privkey) == 1) {\n        jwk = r_jwks_get_at(jwe->jwks_privkey, 0);\n      }\n    }\n  }\n\n  if (jwe != NULL && jwe->alg != R_JWA_ALG_UNKNOWN && jwe->alg != R_JWA_ALG_NONE) {\n    ret = r_preform_key_decryption(jwe, jwe->alg, jwk, x5u_flags);\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n\n  r_jwk_free(jwk);\n  return ret;\n}\n\nint r_jwe_parse(jwe_t * jwe, const char * jwe_str, int x5u_flags) {\n  return r_jwe_parsen(jwe, jwe_str, o_strlen(jwe_str), x5u_flags);\n}\n\nint r_jwe_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, int x5u_flags) {\n  int ret;\n  char * str = (char *)jwe_str;\n\n  if (jwe != NULL && str != NULL && jwe_str_len) {\n    while(isspace((unsigned char)*str) && jwe_str_len) {\n      str++;\n      jwe_str_len--;\n    }\n\n    if (0 == o_strncmp(\"ey\", str, 2)) {\n      ret = r_jwe_compact_parsen(jwe, jwe_str, jwe_str_len, x5u_flags);\n    } else if (*str == '{') {\n      ret = r_jwe_parsen_json_str(jwe, jwe_str, jwe_str_len, x5u_flags);\n    } else {\n      ret = RHN_ERROR_PARAM;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_advanced_parse(jwe_t * jwe, const char * jwe_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_advanced_parsen(jwe, jwe_str, o_strlen(jwe_str), parse_flags, x5u_flags);\n}\n\nint r_jwe_advanced_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  char * str = (char *)jwe_str;\n\n  if (jwe != NULL && str != NULL && jwe_str_len) {\n    while(isspace((unsigned char)*str) && jwe_str_len) {\n      str++;\n      jwe_str_len--;\n    }\n\n    if (0 == o_strncmp(\"ey\", str, 2)) {\n      ret = r_jwe_advanced_compact_parsen(jwe, jwe_str, jwe_str_len, parse_flags, x5u_flags);\n    } else if (*str == '{') {\n      ret = r_jwe_advanced_parsen_json_str(jwe, jwe_str, jwe_str_len, parse_flags, x5u_flags);\n    } else {\n      ret = RHN_ERROR_PARAM;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_compact_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, int x5u_flags) {\n  return r_jwe_advanced_compact_parsen(jwe, jwe_str, jwe_str_len, R_PARSE_HEADER_ALL, x5u_flags);\n}\n\nint r_jwe_compact_parse(jwe_t * jwe, const char * jwe_str, int x5u_flags) {\n  return r_jwe_compact_parsen(jwe, jwe_str, o_strlen(jwe_str), x5u_flags);\n}\n\nint r_jwe_advanced_compact_parse(jwe_t * jwe, const char * jwe_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_advanced_compact_parsen(jwe, jwe_str, o_strlen(jwe_str), parse_flags, x5u_flags);\n}\n\nint r_jwe_advanced_compact_parsen(jwe_t * jwe, const char * jwe_str, size_t jwe_str_len, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  char ** str_array = NULL;\n  char * token = NULL, * tmp;\n  size_t cypher_key_len = 0, cypher_len = 0, tag_len = 0;\n  json_t * j_header = NULL;\n  struct _o_datum dat_header = {0, NULL}, dat_iv = {0, NULL};\n\n  if (jwe != NULL && jwe_str != NULL && jwe_str_len) {\n    token = o_strndup(jwe_str, jwe_str_len);\n    // Remove whitespaces and newlines\n    tmp = str_replace(token, \" \", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\n\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\t\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\v\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\f\", \"\");\n    o_free(token);\n    token = tmp;\n    tmp = str_replace(token, \"\\r\", \"\");\n    o_free(token);\n    token = tmp;\n    if (split_string(token, \".\", &str_array) == 5 && !o_strnullempty(str_array[0]) && !o_strnullempty(str_array[2]) && !o_strnullempty(str_array[3]) && !o_strnullempty(str_array[4])) {\n      // Check if all elements 0, 2 and 3 are base64url encoded\n      if (o_base64url_decode_alloc((unsigned char *)str_array[0], o_strlen(str_array[0]), &dat_header) &&\n         (o_strnullempty(str_array[1]) || o_base64url_decode((unsigned char *)str_array[1], o_strlen(str_array[1]), NULL, &cypher_key_len)) &&\n          o_base64url_decode_alloc((unsigned char *)str_array[2], o_strlen(str_array[2]), &dat_iv) &&\n          o_base64url_decode((unsigned char *)str_array[3], o_strlen(str_array[3]), NULL, &cypher_len) &&\n          o_base64url_decode((unsigned char *)str_array[4], o_strlen(str_array[4]), NULL, &tag_len)) {\n        ret = RHN_OK;\n        jwe->token_mode = R_JSON_MODE_COMPACT;\n        do {\n          // Decode header\n          if ((j_header = json_loadb((const char *)dat_header.data, dat_header.size, JSON_DECODE_ANY, NULL)) == NULL) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compact_parsen - Error json_loadb dat_header\");\n            ret = RHN_ERROR_PARAM;\n            break;\n          }\n\n          if (r_jwe_extract_header(jwe, j_header, parse_flags, x5u_flags) != RHN_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compact_parsen - error extracting header params\");\n            ret = RHN_ERROR_PARAM;\n            break;\n          }\n          json_decref(jwe->j_header);\n\n          jwe->j_header = json_incref(j_header);\n\n          // Decode iv\n          if (r_jwe_set_iv(jwe, dat_iv.data, dat_iv.size) != RHN_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_compact_parsen - Error r_jwe_set_iv\");\n            ret = RHN_ERROR;\n            break;\n          }\n\n          o_free(jwe->header_b64url);\n          jwe->header_b64url = (unsigned char *)o_strdup(str_array[0]);\n          o_free(jwe->aad_b64url);\n          jwe->aad_b64url = (unsigned char *)o_strdup(str_array[0]);\n          o_free(jwe->encrypted_key_b64url);\n          jwe->encrypted_key_b64url = (unsigned char *)o_strdup(str_array[1]);\n          o_free(jwe->iv_b64url);\n          jwe->iv_b64url = (unsigned char *)o_strdup(str_array[2]);\n          o_free(jwe->ciphertext_b64url);\n          jwe->ciphertext_b64url = (unsigned char *)o_strdup(str_array[3]);\n          o_free(jwe->auth_tag_b64url);\n          jwe->auth_tag_b64url = (unsigned char *)o_strdup(str_array[4]);\n\n        } while (0);\n        json_decref(j_header);\n      } else {\n        ret = RHN_ERROR_PARAM;\n      }\n      o_free(dat_header.data);\n      o_free(dat_iv.data);\n    } else {\n      ret = RHN_ERROR_PARAM;\n    }\n    free_string_array(str_array);\n    o_free(token);\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_parse_json_str(jwe_t * jwe, const char * jwe_json_str, int x5u_flags) {\n  return r_jwe_parsen_json_str(jwe, jwe_json_str, o_strlen(jwe_json_str), x5u_flags);\n}\n\nint r_jwe_parsen_json_str(jwe_t * jwe, const char * jwe_json_str, size_t jwe_json_str_len, int x5u_flags) {\n  json_t * jwe_json = NULL;\n  int ret;\n\n  jwe_json = json_loadb(jwe_json_str, jwe_json_str_len, JSON_DECODE_ANY, NULL);\n  ret = r_jwe_parse_json_t(jwe, jwe_json, x5u_flags);\n  json_decref(jwe_json);\n\n  return ret;\n}\n\nint r_jwe_parse_json_t(jwe_t * jwe, json_t * jwe_json, int x5u_flags) {\n  return r_jwe_advanced_parse_json_t(jwe, jwe_json, R_PARSE_HEADER_ALL, x5u_flags);\n}\n\nint r_jwe_advanced_parse_json_str(jwe_t * jwe, const char * jwe_json_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_advanced_parsen_json_str(jwe, jwe_json_str, o_strlen(jwe_json_str), parse_flags, x5u_flags);\n}\n\nint r_jwe_advanced_parsen_json_str(jwe_t * jwe, const char * jwe_json_str, size_t jwe_json_str_len, uint32_t parse_flags, int x5u_flags) {\n  json_t * jwe_json = NULL;\n  int ret;\n\n  jwe_json = json_loadb(jwe_json_str, jwe_json_str_len, JSON_DECODE_ANY, NULL);\n  ret = r_jwe_advanced_parse_json_t(jwe, jwe_json, parse_flags, x5u_flags);\n  json_decref(jwe_json);\n\n  return ret;\n}\n\nint r_jwe_advanced_parse_json_t(jwe_t * jwe, json_t * jwe_json, uint32_t parse_flags, int x5u_flags) {\n  int ret;\n  size_t cypher_key_len = 0, index = 0;;\n  json_t * j_header = NULL, * j_recipient;\n  struct _o_datum dat_header = {0, NULL}, dat_iv = {0, NULL};\n\n  if (jwe != NULL && json_is_object(jwe_json)) {\n    if (json_string_length(json_object_get(jwe_json, \"protected\")) &&\n        json_string_length(json_object_get(jwe_json, \"iv\")) &&\n        json_string_length(json_object_get(jwe_json, \"ciphertext\")) &&\n        json_string_length(json_object_get(jwe_json, \"tag\"))) {\n      ret = RHN_OK;\n      r_jwe_set_cypher_key(jwe, NULL, 0);\n      r_jwe_set_iv(jwe, NULL, 0);\n      r_jwe_set_aad(jwe, NULL, 0);\n      r_jwe_set_payload(jwe, NULL, 0);\n      o_free(jwe->header_b64url);\n      jwe->header_b64url = NULL;\n      o_free(jwe->encrypted_key_b64url);\n      jwe->encrypted_key_b64url = NULL;\n      o_free(jwe->iv_b64url);\n      jwe->iv_b64url = NULL;\n      o_free(jwe->ciphertext_b64url);\n      jwe->ciphertext_b64url = NULL;\n      o_free(jwe->auth_tag_b64url);\n      jwe->auth_tag_b64url = NULL;\n      o_free(jwe->aad_b64url);\n      jwe->aad_b64url = NULL;\n      json_decref(jwe->j_header);\n      jwe->j_header = json_object();\n      json_decref(jwe->j_unprotected_header);\n      jwe->j_unprotected_header = NULL;\n      do {\n        json_decref(jwe->j_json_serialization);\n        if ((jwe->j_json_serialization = json_deep_copy(jwe_json)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error setting j_json_serialization\");\n          ret = RHN_ERROR;\n          break;\n        }\n\n        if (json_object_get(jwe_json, \"unprotected\") != NULL && r_jwe_set_full_unprotected_header_json_t(jwe, json_object_get(jwe_json, \"unprotected\")) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error r_jwe_set_full_unprotected_header_json_t\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if (!o_base64url_decode_alloc((unsigned char *)json_string_value(json_object_get(jwe_json, \"protected\")), json_string_length(json_object_get(jwe_json, \"protected\")), &dat_header)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error invalid protected base64\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if ((j_header = json_loadb((const char *)dat_header.data, dat_header.size, JSON_DECODE_ANY, NULL)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error json_loadb dat_header\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if (r_jwe_extract_header(jwe, j_header, parse_flags, x5u_flags) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - error extracting header params\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n        json_decref(jwe->j_header);\n\n        jwe->j_header = json_incref(j_header);\n\n        // Decode iv\n        if (!o_base64url_decode_alloc((unsigned char *)json_string_value(json_object_get(jwe_json, \"iv\")), json_string_length(json_object_get(jwe_json, \"iv\")), &dat_iv)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error o_base64url_decode_alloc iv\");\n          ret = RHN_ERROR_PARAM;\n          break;\n        }\n\n        if (r_jwe_set_iv(jwe, dat_iv.data, dat_iv.size) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error r_jwe_set_iv\");\n          ret = RHN_ERROR;\n          break;\n        }\n        jwe->header_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"protected\")));\n        jwe->ciphertext_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"ciphertext\")));\n        jwe->auth_tag_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"tag\")));\n        jwe->aad_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"aad\")));\n\n      } while (0);\n      json_decref(j_header);\n      o_free(dat_header.data);\n      o_free(dat_iv.data);\n      if (ret == RHN_OK) {\n        if (json_array_size(json_object_get(jwe_json, \"recipients\"))) {\n          jwe->token_mode = R_JSON_MODE_GENERAL;\n          json_array_foreach(json_object_get(jwe_json, \"recipients\"), index, j_recipient) {\n            if (!json_is_object(j_recipient)) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Invalid recipient at index %zu, must be a JSON object\", index);\n              ret = RHN_ERROR_PARAM;\n              break;\n            } else {\n              if (!o_base64url_decode((const unsigned char*)json_string_value(json_object_get(j_recipient, \"encrypted_key\")), json_string_length(json_object_get(j_recipient, \"encrypted_key\")), NULL, &cypher_key_len)) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error at index %zu, invalid encrypted_key base64 %s\", index);\n                ret = RHN_ERROR_PARAM;\n                break;\n              }\n              if (json_object_get(j_recipient, \"header\") != NULL && !json_is_object(json_object_get(j_recipient, \"header\"))) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Invalid header at index %zu, must be a JSON object\", index);\n                ret = RHN_ERROR_PARAM;\n                break;\n              }\n            }\n          }\n        } else {\n          jwe->token_mode = R_JSON_MODE_FLATTENED;\n          jwe->encrypted_key_b64url = (unsigned char *)o_strdup(json_string_value(json_object_get(jwe_json, \"encrypted_key\")));\n          if (json_object_get(jwe_json, \"header\") == NULL || r_jwe_extract_header(jwe, json_object_get(jwe_json, \"header\"), parse_flags, x5u_flags) == RHN_OK) {\n            json_object_update_missing(jwe->j_header, json_object_get(jwe_json, \"header\"));\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - error extracting header params\");\n            ret = RHN_ERROR_PARAM;\n          }\n        }\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error invalid content\");\n      ret = RHN_ERROR_PARAM;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_parse_json_t - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\njwe_t * r_jwe_quick_parse(const char * jwe_str, uint32_t parse_flags, int x5u_flags) {\n  return r_jwe_quick_parsen(jwe_str, o_strlen(jwe_str), parse_flags, x5u_flags);\n}\n\njwe_t * r_jwe_quick_parsen(const char * jwe_str, size_t jwe_str_len, uint32_t parse_flags, int x5u_flags) {\n  jwe_t * jwe = NULL;\n  int ret;\n\n  if (r_jwe_init(&jwe) == RHN_OK) {\n    ret = r_jwe_advanced_parsen(jwe, jwe_str, jwe_str_len, parse_flags, x5u_flags);\n    if (ret != RHN_OK) {\n      r_jwe_free(jwe);\n      jwe = NULL;\n    }\n  } else {\n    r_jwe_free(jwe);\n    jwe = NULL;\n  }\n  return jwe;\n}\n\nint r_jwe_decrypt(jwe_t * jwe, jwk_t * jwk_privkey, int x5u_flags) {\n  int ret, res;\n  json_t * j_recipient = NULL, * j_header, * j_cur_header;\n  size_t index = 0, i;\n  jwk_t * jwk = NULL, * cur_jwk = NULL;\n  jwa_alg alg;\n\n  if (jwe != NULL) {\n    if (jwk_privkey != NULL) {\n      jwk = r_jwk_copy(jwk_privkey);\n    } else {\n      if (r_jwe_get_header_str_value(jwe, \"kid\") != NULL) {\n        jwk = r_jwks_get_by_kid(jwe->jwks_privkey, r_jwe_get_header_str_value(jwe, \"kid\"));\n      } else if (r_jwks_size(jwe->jwks_privkey) == 1) {\n        jwk = r_jwks_get_at(jwe->jwks_privkey, 0);\n      }\n    }\n  }\n\n  if (jwe != NULL) {\n    if (jwe->token_mode == R_JSON_MODE_GENERAL) {\n      ret = RHN_ERROR_INVALID;\n      o_free(jwe->encrypted_key_b64url);\n      j_header = r_jwe_get_full_header_json_t(jwe);\n      json_array_foreach(json_object_get(jwe->j_json_serialization, \"recipients\"), index, j_recipient) {\n        j_cur_header = json_deep_copy(j_header);\n        json_object_update(j_cur_header, json_object_get(j_recipient, \"header\"));\n        r_jwe_set_full_header_json_t(jwe, j_cur_header);\n        json_decref(j_cur_header);\n        jwe->encrypted_key_b64url = (unsigned char *)json_string_value(json_object_get(j_recipient, \"encrypted_key\"));\n        alg = r_jwe_get_alg(jwe);\n        if (json_object_get(jwe->j_unprotected_header, \"alg\") != NULL) {\n          alg = r_str_to_jwa_alg(json_string_value(json_object_get(jwe->j_unprotected_header, \"alg\")));\n        }\n        if (json_object_get(json_object_get(j_recipient, \"header\"), \"alg\") != NULL) {\n          alg = r_str_to_jwa_alg(json_string_value(json_object_get(json_object_get(j_recipient, \"header\"), \"alg\")));\n        }\n        if (alg != R_JWA_ALG_UNKNOWN && alg != R_JWA_ALG_ECDH_ES) {\n          if (jwk_privkey != NULL) {\n            if (r_jwk_get_property_str(jwk_privkey, \"kid\") == NULL || json_object_get(json_object_get(j_recipient, \"header\"), \"kid\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(json_object_get(j_recipient, \"header\"), \"kid\")), r_jwk_get_property_str(jwk_privkey, \"kid\"))) {\n              if ((res = r_preform_key_decryption(jwe, alg, jwk_privkey, x5u_flags)) != RHN_ERROR_INVALID) {\n                ret = res;\n                break;\n              }\n            }\n          } else {\n            if (json_object_get(json_object_get(j_recipient, \"header\"), \"kid\") != NULL) {\n              cur_jwk = r_jwks_get_by_kid(jwe->jwks_privkey, json_string_value(json_object_get(json_object_get(j_recipient, \"header\"), \"kid\")));\n              if ((res = r_preform_key_decryption(jwe, alg, cur_jwk, x5u_flags)) != RHN_ERROR_INVALID) {\n                ret = res;\n                r_jwk_free(cur_jwk);\n                break;\n              }\n              r_jwk_free(cur_jwk);\n            } else {\n              for (i=0; i<r_jwks_size(jwe->jwks_privkey); i++) {\n                cur_jwk = r_jwks_get_at(jwe->jwks_privkey, i);\n                if ((res = r_preform_key_decryption(jwe, alg, cur_jwk, x5u_flags)) != RHN_ERROR_INVALID) {\n                  ret = res;\n                  r_jwk_free(cur_jwk);\n                  break;\n                }\n                r_jwk_free(cur_jwk);\n              }\n              if (ret != RHN_ERROR_INVALID) {\n                break;\n              }\n            }\n          }\n          cur_jwk = NULL;\n        } else if (alg == R_JWA_ALG_ECDH_ES) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"r_jwe_decrypt - Unsupported algorithm ECDH-ES on general serialization\");\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt - Invalid alg value at index %zu: %d\", index, (alg));\n          ret = RHN_ERROR_PARAM;\n        }\n      }\n      r_jwe_set_full_header_json_t(jwe, j_header);\n      json_decref(j_header);\n      jwe->encrypted_key_b64url = NULL;\n      if (ret == RHN_OK) {\n        ret = r_jwe_decrypt_payload(jwe);\n      }\n    } else {\n      j_header = r_jwe_get_full_header_json_t(jwe);\n      j_cur_header = json_deep_copy(j_header);\n      json_object_update(j_cur_header, json_object_get(j_recipient, \"header\"));\n      if (jwe->j_unprotected_header != NULL) {\n        json_object_update(j_cur_header, jwe->j_unprotected_header);\n      }\n      r_jwe_set_full_header_json_t(jwe, j_cur_header);\n      json_decref(j_cur_header);\n      if ((res = r_jwe_decrypt_key(jwe, jwk, x5u_flags)) == RHN_OK && (res = r_jwe_decrypt_payload(jwe)) == RHN_OK) {\n        ret = RHN_OK;\n      } else {\n        if (res != RHN_ERROR_INVALID) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_decrypt - Error decrypting data\");\n        }\n        ret = res;\n      }\n      r_jwe_set_full_header_json_t(jwe, j_header);\n      json_decref(j_header);\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  r_jwk_free(jwk);\n  return ret;\n}\n\nchar * r_jwe_serialize(jwe_t * jwe, jwk_t * jwk_pubkey, int x5u_flags) {\n  char * jwe_str = NULL;\n  int res = RHN_OK;\n  unsigned int bits = 0;\n  unsigned char * key = NULL;\n  size_t key_len = 0;\n\n  if (jwk_pubkey != NULL && jwe != NULL && jwe->alg == R_JWA_ALG_DIR) {\n    if (r_jwk_key_type(jwk_pubkey, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && bits == _r_get_key_size(jwe->enc)*8) {\n      key_len = (size_t)(bits/8);\n      if ((key = o_malloc(key_len+4)) != NULL) {\n        if (r_jwk_export_to_symmetric_key(jwk_pubkey, key, &key_len) == RHN_OK) {\n          res = r_jwe_set_cypher_key(jwe, key, key_len);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error r_jwk_export_to_symmetric_key\");\n          res = RHN_ERROR_MEMORY;\n        }\n        o_free(key);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error allocating resources for key\");\n        res = RHN_ERROR_MEMORY;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error invalid key type\");\n      res = RHN_ERROR_PARAM;\n    }\n  } else {\n    res = RHN_OK;\n  }\n\n  if (res == RHN_OK) {\n    if (jwe->key == NULL || !jwe->key_len) {\n      if (r_jwe_generate_cypher_key(jwe) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error r_jwe_generate_cypher_key\");\n        res = RHN_ERROR;\n      }\n    }\n    if (jwe->iv == NULL || !jwe->iv_len) {\n      if (r_jwe_generate_iv(jwe) != RHN_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error r_jwe_generate_iv\");\n        res = RHN_ERROR;\n      }\n    }\n  }\n  if (res == RHN_OK && r_jwe_set_alg_header(jwe, jwe->j_header) == RHN_OK && r_jwe_encrypt_key(jwe, jwk_pubkey, x5u_flags) == RHN_OK && r_jwe_encrypt_payload(jwe) == RHN_OK) {\n    jwe_str = msprintf(\"%s.%s.%s.%s.%s\",\n                      jwe->header_b64url,\n                      jwe->encrypted_key_b64url!=NULL?(const char *)jwe->encrypted_key_b64url:\"\",\n                      jwe->iv_b64url,\n                      jwe->ciphertext_b64url,\n                      jwe->auth_tag_b64url);\n\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize - Error input parameters\");\n  }\n  return jwe_str;\n}\n\nchar * r_jwe_serialize_json_str(jwe_t * jwe, jwks_t * jwks_pubkey, int x5u_flags, int mode) {\n  json_t * j_result = r_jwe_serialize_json_t(jwe, jwks_pubkey, x5u_flags, mode);\n  char * str_result = json_dumps(j_result, JSON_COMPACT);\n  json_decref(j_result);\n  return str_result;\n}\n\njson_t * r_jwe_serialize_json_t(jwe_t * jwe, jwks_t * jwks_pubkey, int x5u_flags, int mode) {\n  json_t * j_return = NULL, * j_result;\n  jwk_t * jwk = NULL;\n  jwa_alg alg = R_JWA_ALG_NONE;\n  const char * kid = NULL;\n  size_t i = 0;\n  int res = RHN_OK;\n\n  if (jwks_pubkey == NULL) {\n    jwks_pubkey = jwe->jwks_pubkey;\n  }\n  if (jwe != NULL && r_jwks_size(jwks_pubkey)) {\n    jwe->token_mode = mode;\n    if (mode == R_JSON_MODE_FLATTENED) {\n      if ((kid = r_jwe_get_header_str_value(jwe, \"kid\")) != NULL) {\n        jwk = r_jwks_get_by_kid(jwks_pubkey, kid);\n      } else {\n        jwk = r_jwks_get_at(jwks_pubkey, 0);\n        kid = r_jwk_get_property_str(jwk, \"kid\");\n      }\n      alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk, \"alg\"));\n      if (alg == R_JWA_ALG_UNKNOWN) {\n        alg = jwe->alg;\n      }\n      if (jwe->key == NULL || !jwe->key_len) {\n        if (r_jwe_generate_cypher_key(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_cypher_key\");\n          res = RHN_ERROR;\n        }\n      }\n      if (jwe->iv == NULL || !jwe->iv_len) {\n        if (r_jwe_generate_iv(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_iv\");\n          res = RHN_ERROR;\n        }\n      }\n      if (res == RHN_OK) {\n        if ((j_result = r_jwe_perform_key_encryption(jwe, alg, jwk, x5u_flags, &res)) != NULL) {\n          if (r_jwe_encrypt_payload(jwe) == RHN_OK) {\n            if ((kid = r_jwe_get_header_str_value(jwe, \"kid\")) == NULL) {\n              kid = r_jwk_get_property_str(jwk, \"kid\");\n            }\n            j_return = json_pack(\"{ss sO* ss ss ss sO*}\", \"protected\", jwe->header_b64url,\n                                                          \"encrypted_key\", json_object_get(j_result, \"encrypted_key\"),\n                                                          \"iv\", jwe->iv_b64url,\n                                                          \"ciphertext\", jwe->ciphertext_b64url,\n                                                          \"tag\", jwe->auth_tag_b64url,\n                                                          \"header\", json_object_get(j_result, \"header\"));\n            if (jwe->aad_b64url != NULL) {\n              json_object_set_new(j_return, \"aad\", json_string((const char *)jwe->aad_b64url));\n            }\n            if (jwe->j_unprotected_header != NULL) {\n              json_object_set_new(j_return, \"unprotected\", json_deep_copy(jwe->j_unprotected_header));\n            }\n            if (kid != NULL) {\n              json_object_set_new(json_object_get(j_return, \"header\"), \"kid\", json_string(kid));\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error input parameters\");\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error invalid encryption key\");\n        }\n        json_decref(j_result);\n      }\n      r_jwk_free(jwk);\n    } else if (mode == R_JSON_MODE_GENERAL) {\n      if (jwe->key == NULL || !jwe->key_len) {\n        if (r_jwe_generate_cypher_key(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_cypher_key\");\n          res = RHN_ERROR;\n        }\n      }\n      if (jwe->iv == NULL || !jwe->iv_len) {\n        if (r_jwe_generate_iv(jwe) != RHN_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error r_jwe_generate_iv\");\n          res = RHN_ERROR;\n        }\n      }\n      if (res == RHN_OK && r_jwe_encrypt_payload(jwe) == RHN_OK) {\n        j_return = json_pack(\"{ss ss ss ss s[]}\", \"protected\", jwe->header_b64url,\n                                              \"iv\", jwe->iv_b64url,\n                                              \"ciphertext\", jwe->ciphertext_b64url,\n                                              \"tag\", jwe->auth_tag_b64url,\n                                              \"recipients\");\n        if (jwe->aad_b64url != NULL) {\n          json_object_set_new(j_return, \"aad\", json_string((const char *)jwe->aad_b64url));\n        }\n        if (jwe->j_unprotected_header != NULL) {\n          json_object_set_new(j_return, \"unprotected\", json_deep_copy(jwe->j_unprotected_header));\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error input parameters\");\n      }\n      //r_jwe_set_header_str_value(jwe, \"alg\", NULL);\n      for (i=0; i<r_jwks_size(jwks_pubkey); i++) {\n        jwk = r_jwks_get_at(jwks_pubkey, i);\n        kid = r_jwk_get_property_str(jwk, \"kid\");\n        if ((alg = r_jwe_get_alg(jwe)) == R_JWA_ALG_UNKNOWN || alg == R_JWA_ALG_NONE) {\n          alg = r_str_to_jwa_alg(r_jwk_get_property_str(jwk, \"alg\"));\n        }\n        if (alg != R_JWA_ALG_UNKNOWN && alg != R_JWA_ALG_ECDH_ES) {\n          if ((j_result = r_jwe_perform_key_encryption(jwe, alg, jwk, x5u_flags, &res)) != NULL) {\n            if (json_object_get(jwe->j_header, \"kid\") == NULL && json_object_get(jwe->j_unprotected_header, \"kid\") == NULL) {\n              json_object_set_new(json_object_get(j_result, \"header\"), \"kid\", json_string(r_jwk_get_property_str(jwk, \"kid\")));\n            }\n            json_array_append(json_object_get(j_return, \"recipients\"), j_result);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error invalid encryption key at index %zu\", i);\n          }\n          json_decref(j_result);\n        } else if (alg == R_JWA_ALG_ECDH_ES) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"r_jwe_serialize_json_t - Unsupported algorithm for JWE with multiple recipients\");\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error invalid encryption algorithm at index %zu\", i);\n        }\n        r_jwk_free(jwk);\n      }\n      if (!json_array_size(json_object_get(j_return, \"recipients\"))) {\n        json_decref(j_return);\n        j_return = NULL;\n      }\n    }\n    json_decref(jwe->j_json_serialization);\n    jwe->j_json_serialization = json_deep_copy(j_return);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_serialize_json_t - Error input parameters\");\n  }\n  return j_return;\n}\n\nint r_jwe_set_full_header_json_t(jwe_t * jwe, json_t * j_header) {\n  int ret = RHN_OK;\n  jwa_alg alg;\n  jwa_enc enc;\n\n  if (jwe != NULL && json_is_object(j_header)) {\n    if (json_object_get(j_header, \"alg\") != NULL) {\n      if ((alg = r_str_to_jwa_alg(json_string_value(json_object_get(j_header, \"alg\")))) != R_JWA_ALG_UNKNOWN) {\n        jwe->alg = alg;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error invalid alg parameter\");\n        ret = RHN_ERROR_PARAM;\n      }\n    }\n    if (json_object_get(j_header, \"enc\") != NULL) {\n      if ((enc = r_str_to_jwa_enc(json_string_value(json_object_get(j_header, \"enc\")))) != R_JWA_ENC_UNKNOWN) {\n        jwe->enc = enc;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error invalid enc parameter\");\n        ret = RHN_ERROR_PARAM;\n      }\n    }\n    if (ret == RHN_OK) {\n      json_decref(jwe->j_header);\n      if ((jwe->j_header = json_deep_copy(j_header)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error setting header\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_header_json_t - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_full_header_json_str(jwe_t * jwe, const char * str_header) {\n  int ret;\n  json_t * j_header = json_loads(str_header, JSON_DECODE_ANY, NULL);\n\n  ret = r_jwe_set_full_header_json_t(jwe, j_header);\n  json_decref(j_header);\n\n  return ret;\n}\n\nint r_jwe_set_full_unprotected_header_json_t(jwe_t * jwe, json_t * j_unprotected_header) {\n  int ret = RHN_OK;\n\n  if (jwe != NULL && json_is_object(j_unprotected_header)) {\n    json_decref(jwe->j_unprotected_header);\n    if ((jwe->j_unprotected_header = json_deep_copy(j_unprotected_header)) == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_unprotected_header_json_t - Error setting header\");\n      ret = RHN_ERROR_MEMORY;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_full_unprotected_header_json_t - Error input parameters\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n\nint r_jwe_set_full_unprotected_header_json_str(jwe_t * jwe, const char * str_unprotected_header) {\n  int ret;\n  json_t * j_unprotected_header = json_loads(str_unprotected_header, JSON_DECODE_ANY, NULL);\n\n  ret = r_jwe_set_full_unprotected_header_json_t(jwe, j_unprotected_header);\n  json_decref(j_unprotected_header);\n\n  return ret;\n}\n\nint r_jwe_set_properties(jwe_t * jwe, ...) {\n  rhn_opt option;\n  int ret = RHN_OK;\n  int i_value;\n  rhn_int_t r_value;\n  unsigned int ui_value;\n  const char * str_key, * str_value;\n  json_t * j_value;\n  const unsigned char * ustr_value;\n  size_t size_value;\n  jwk_t * jwk;\n  jwks_t * jwks;\n  gnutls_privkey_t privkey;\n  gnutls_pubkey_t pubkey;\n  va_list vl;\n\n  if (jwe != NULL) {\n    va_start(vl, jwe);\n    for (option = va_arg(vl, rhn_opt); option != RHN_OPT_NONE && ret == RHN_OK; option = va_arg(vl, rhn_opt)) {\n      switch (option) {\n        case RHN_OPT_HEADER_INT_VALUE:\n          str_key = va_arg(vl, const char *);\n          i_value = va_arg(vl, int);\n          ret = r_jwe_set_header_int_value(jwe, str_key, (rhn_int_t)i_value);\n          break;\n        case RHN_OPT_HEADER_RHN_INT_VALUE:\n          str_key = va_arg(vl, const char *);\n          r_value = va_arg(vl, rhn_int_t);\n          ret = r_jwe_set_header_int_value(jwe, str_key, r_value);\n          break;\n        case RHN_OPT_HEADER_STR_VALUE:\n          str_key = va_arg(vl, const char *);\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_set_header_str_value(jwe, str_key, str_value);\n          break;\n        case RHN_OPT_HEADER_JSON_T_VALUE:\n          str_key = va_arg(vl, const char *);\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_set_header_json_t_value(jwe, str_key, j_value);\n          break;\n        case RHN_OPT_HEADER_FULL_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_set_full_header_json_t(jwe, j_value);\n          break;\n        case RHN_OPT_HEADER_FULL_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_set_full_header_json_str(jwe, str_value);\n          break;\n        case RHN_OPT_UN_HEADER_FULL_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_set_full_unprotected_header_json_t(jwe, j_value);\n          break;\n        case RHN_OPT_UN_HEADER_FULL_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_set_full_unprotected_header_json_str(jwe, str_value);\n          break;\n        case RHN_OPT_PAYLOAD:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_payload(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_ENC_ALG:\n          ui_value = va_arg(vl, unsigned int);\n          ret = r_jwe_set_alg(jwe, (jwa_alg)ui_value);\n          break;\n        case RHN_OPT_ENC:\n          ui_value = va_arg(vl, unsigned int);\n          ret = r_jwe_set_enc(jwe, (jwa_enc)ui_value);\n          break;\n        case RHN_OPT_CIPHER_KEY:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_cypher_key(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_IV:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_iv(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_AAD:\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_set_aad(jwe, ustr_value, size_value);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JWK:\n          jwk = va_arg(vl, jwk_t *);\n          ret = r_jwe_add_keys(jwe, NULL, jwk);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JWKS:\n          jwks = va_arg(vl, jwks_t *);\n          ret = r_jwe_add_jwks(jwe, NULL, jwks);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_GNUTLS:\n          pubkey = va_arg(vl, gnutls_pubkey_t);\n          ret = r_jwe_add_keys_gnutls(jwe, NULL, pubkey);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_add_keys_json_t(jwe, NULL, j_value);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_add_keys_json_str(jwe, NULL, str_value);\n          break;\n        case RHN_OPT_ENCRYPT_KEY_PEM_DER:\n          ui_value = va_arg(vl, unsigned int);\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_add_keys_pem_der(jwe, ui_value, NULL, 0, ustr_value, size_value);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JWK:\n          jwk = va_arg(vl, jwk_t *);\n          ret = r_jwe_add_keys(jwe, jwk, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JWKS:\n          jwks = va_arg(vl, jwks_t *);\n          ret = r_jwe_add_jwks(jwe, jwks, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_GNUTLS:\n          privkey = va_arg(vl, gnutls_privkey_t);\n          ret = r_jwe_add_keys_gnutls(jwe, privkey, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JSON_T:\n          j_value = va_arg(vl, json_t *);\n          ret = r_jwe_add_keys_json_t(jwe, j_value, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_JSON_STR:\n          str_value = va_arg(vl, const char *);\n          ret = r_jwe_add_keys_json_str(jwe, str_value, NULL);\n          break;\n        case RHN_OPT_DECRYPT_KEY_PEM_DER:\n          ui_value = va_arg(vl, unsigned int);\n          ustr_value = va_arg(vl, const unsigned char *);\n          size_value = va_arg(vl, size_t);\n          ret = r_jwe_add_keys_pem_der(jwe, ui_value, ustr_value, size_value, NULL, 0);\n          break;\n        default:\n          ret = RHN_ERROR_PARAM;\n          break;\n      }\n    }\n    va_end(vl);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_properties - Error input parameter\");\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}\n"], "buggy_code_start_loc": [366], "buggy_code_end_loc": [385], "fixing_code_start_loc": [367], "fixing_code_end_loc": [396], "type": "CWE-347", "message": "Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private key length before RSA-OAEP decryption. This allows attackers to cause a Denial of Service via a crafted JWE (JSON Web Encryption) token.", "other": {"cve": {"id": "CVE-2022-38493", "sourceIdentifier": "cve@mitre.org", "published": "2022-08-20T20:15:08.613", "lastModified": "2022-08-23T18:51:29.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private key length before RSA-OAEP decryption. This allows attackers to cause a Denial of Service via a crafted JWE (JSON Web Encryption) token."}, {"lang": "es", "value": "Rhonabwy versiones 0.9.99 hasta 1.1.x anteriores a 1.1.7, no comprueba la longitud de la clave privada RSA antes del descifrado RSA-OAEP. Esto permite a atacantes causar una denegaci\u00f3n de servicio por medio de un token JWE (JSON Web Encryption) dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rhonabwy_project:rhonabwy:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.99", "versionEndExcluding": "1.1.6", "matchCriteriaId": "BF163694-1FE7-4B5B-864A-55D2FC49526E"}]}]}], "references": [{"url": "https://github.com/babelouest/rhonabwy/commit/dd528b3aabd13863f855a68e76966e4e019fc399", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/babelouest/rhonabwy/commit/dd528b3aabd13863f855a68e76966e4e019fc399"}}