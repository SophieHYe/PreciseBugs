{"buggy_code": ["<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizeRequest;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompleteAuthorizeError;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizeError;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizeRedirectResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\AwaitingAuthorizeResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompleteAuthorizeRequest;\n\nclass AuthorizeService extends PaymentService\n{\n    /**\n     * Start an authorization request\n     *\n     * @inheritdoc\n     */\n    public function initiate($data = array())\n    {\n        if ($this->payment->Status !== 'Created') {\n            throw new InvalidStateException('Cannot authorize this payment. Status is not \"Created\"');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsAuthorize()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support authorize', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeAuthorize', $gatewayData);\n        $request = $this->oGateway()->authorize($gatewayData);\n        $this->extend('onAfterAuthorize', $request);\n\n        $this->createMessage(AuthorizeRequest::class, $request);\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(AuthorizeError::class, $e);\n            // create an error response\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendAuthorize', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = 'PendingAuthorization';\n            $this->payment->write();\n\n            $this->createMessage(\n                $serviceResponse->isRedirect() ? AuthorizeRedirectResponse::class : AwaitingAuthorizeResponse::class,\n                $response\n            );\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(AuthorizeError::class, $response);\n        } else {\n            $this->markCompleted('Authorized', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Finalise this authorization, after off-site external processing.\n     * This is usually only called by PaymentGatewayController.\n     * @inheritdoc\n     */\n    public function complete($data = array(), $isNotification = false)\n    {\n        $flags = $isNotification ? ServiceResponse::SERVICE_NOTIFICATION : 0;\n\n        // The payment is already captured\n        if ($this->payment->Status === 'Authorized') {\n            return $this->generateServiceResponse($flags);\n        }\n\n        if ($this->payment->Status !== 'PendingAuthorization') {\n            throw new InvalidStateException('Cannot complete this payment. Status is not \"PendingAuthorization\"');\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCompleteAuthorize()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support completeAuthorize', $this->payment->Gateway)\n            );\n        }\n\n        // purchase and completePurchase should use the same data\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCompleteAuthorize', $gatewayData);\n        $request = $gateway->completeAuthorize($gatewayData);\n        $this->extend('onAfterCompleteAuthorize', $request);\n\n        $this->createMessage(CompleteAuthorizeRequest::class, $request);\n        $response = null;\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(CompleteAuthorizeError::class, $e);\n\n            return $this->generateServiceResponse($flags | ServiceResponse::SERVICE_ERROR);\n        }\n\n        $serviceResponse = $this->wrapOmnipayResponse($response, $isNotification);\n\n        if ($serviceResponse->isError()) {\n            $this->createMessage(CompleteAuthorizeError::class, $response);\n            return $serviceResponse;\n        }\n\n        if (!$serviceResponse->isAwaitingNotification()) {\n            $this->markCompleted('Authorized', $serviceResponse, $response);\n        } else {\n            ErrorHandling::safeExtend($this->payment, 'onAwaitingAuthorized', $serviceResponse);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(AuthorizedResponse::class, $gatewayMessage);\n        ErrorHandling::safeExtend($this->payment, 'onAuthorized', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Exception\\OmnipayException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidParameterException;\nuse SilverStripe\\Omnipay\\Exception\\MissingParameterException;\nuse SilverStripe\\Omnipay\\GatewayInfo;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message\\CapturedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CaptureError;\nuse SilverStripe\\Omnipay\\Model\\Message\\CaptureRequest;\nuse SilverStripe\\Omnipay\\Model\\Message\\PartiallyCapturedResponse;\nuse SilverStripe\\Omnipay\\Helper\\PaymentMath;\nuse SilverStripe\\Omnipay\\Model\\Payment;\n\n/**\n * Service used in tandem with AuthorizeService.\n *\n * This service captures a previously authorized amount\n */\nclass CaptureService extends NotificationCompleteService\n{\n    protected $startState = 'Authorized';\n\n    protected $endState = 'Captured';\n\n    protected $pendingState = 'PendingCapture';\n\n    protected $requestMessageType = CaptureRequest::class;\n\n    protected $errorMessageType = CaptureError::class;\n\n    /**\n     * Capture a previously authorized payment\n     *\n     * If the transaction-reference of the payment to capture is known, pass it via $data as\n     * `transactionReference` parameter. Otherwise the service will try to look up the reference from previous payment\n     * messages.\n     *\n     * If there's no transaction-reference to be found, this method will raise an exception.\n     *\n     * You can issue partial captures (if the gateway supports it) by passing an `amount` parameter in the $data\n     * array. The amount can also exceed the authorized amount, if the configuration allows it (`max_capture` setting).\n     * An amount that exceeds the authorized amount will always be considered as a full capture!\n     * If the amount given is not a number, or if it exceeds the total possible capture amount, an exception\n     * will be raised.\n     *\n     * @inheritdoc\n     * @throws MissingParameterException if no transaction reference can be found from messages or parameters\n     * @throws InvalidParameterException if the amount parameter was invalid\n     */\n    public function initiate($data = array())\n    {\n        if (!$this->payment->canCapture()) {\n            throw new InvalidConfigurationException('Capture of this payment not allowed.');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $reference = null;\n\n        // If the gateway isn't manual, we need a transaction reference to refund a payment\n        if (!GatewayInfo::isManual($this->payment->Gateway)) {\n            if (!empty($data['transactionReference'])) {\n                $reference = $data['transactionReference'];\n            } elseif (!empty($data['receipt'])) { // legacy code?\n                $reference = $data['receipt'];\n            } else {\n                $reference = $this->payment->TransactionReference;\n            }\n\n            if (empty($reference)) {\n                throw new MissingParameterException('transactionReference not found and is not set as parameter');\n            }\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCapture()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support capture', $this->payment->Gateway)\n            );\n        }\n\n        $authorized = $amount = $this->payment->MoneyAmount;\n        $diff = 0;\n\n        if (!empty($data['amount'])) {\n            $amount = $data['amount'];\n            if (!is_numeric($amount)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be numeric.');\n            }\n\n            if (!($amount > 0)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be positive.');\n            }\n\n            // check if the amount exceeds the max. amount that can be captured\n            if (PaymentMath::compare($this->payment->getMaxCaptureAmount(), $amount) === -1) {\n                throw new InvalidParameterException('The \"amount\" given exceeds the amount that can be captured.');\n            }\n\n            $diff = PaymentMath::subtract($amount, $authorized);\n        }\n\n        if ($diff < 0 && !$this->payment->canCapture(null, true)) {\n            throw new InvalidParameterException('This payment cannot be partially captured (unsupported by gateway).');\n        }\n\n        $gatewayData = array_merge(\n            $data,\n            array(\n                'amount' => (float)$amount,\n                'currency' => $this->payment->MoneyCurrency,\n                'transactionReference' => $reference,\n                'notifyUrl' => $this->getEndpointUrl('notify')\n            )\n        );\n\n        $this->extend('onBeforeCapture', $gatewayData);\n        $request = $this->oGateway()->capture($gatewayData);\n        $this->extend('onAfterCapture', $request);\n\n        $message = $this->createMessage($this->requestMessageType, $request);\n        $message->write();\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (OmnipayException $e) {\n            $this->createMessage($this->errorMessageType, $e);\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendCapture', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isAwaitingNotification()) {\n            if ($diff < 0) {\n                $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n            } elseif ($diff > 0) {\n                $this->createPartialPayment($diff, $this->pendingState);\n            }\n            $this->payment->Status = $this->pendingState;\n            $this->payment->write();\n        } else {\n            if ($serviceResponse->isError()) {\n                $this->createMessage($this->errorMessageType, $response);\n            } else {\n                if ($diff < 0) {\n                    $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n                } elseif ($diff > 0) {\n                    $this->createPartialPayment($diff, $this->pendingState);\n                }\n                $this->markCompleted($this->endState, $serviceResponse, $response);\n            }\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        // Get partial payments\n        $partials = $this->payment->getPartialPayments()->filter('Status', $this->pendingState);\n\n        if ($partials->count() > 0) {\n            $i = 0;\n            $total = $originalTotal = $this->payment->MoneyAmount;\n            /** @var Payment $payment */\n            foreach ($partials as $payment) {\n                // only the first, eg. most recent payment should be considered valid. All others should be set to void\n                if ($i === 0) {\n                    $total = PaymentMath::add($total, $payment->MoneyAmount);\n\n                    // deal with partial capture\n                    if ($payment->MoneyAmount < 0) {\n                        $payment->Status = 'Created';\n                        $payment->setAmount(PaymentMath::multiply($payment->MoneyAmount, '-1'));\n                        $payment->Status = 'Captured';\n                    } else {\n                        // void excess amounts\n                        $payment->Status = 'Void';\n                    }\n                } else {\n                    $payment->Status = 'Void';\n                }\n                $payment->write();\n                $i++;\n            }\n\n            // Ugly hack to set the money amount\n            $this->payment->Status = 'Created';\n            $this->payment->setAmount($total);\n\n            // If not everything was captured (partial),\n            // the payment should be refunded or still Authorized (in case multiple captures are possible)\n            if ($total > 0 && $total < $originalTotal) {\n                $endStatus = GatewayInfo::captureMode($this->payment->Gateway) === GatewayInfo::MULTIPLE\n                    ? 'Authorized'\n                    : 'Refunded';\n            }\n        }\n\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n\n        if ($endStatus === 'Captured') {\n            $this->createMessage(CapturedResponse::class, $gatewayMessage);\n        } else {\n            $this->createMessage(PartiallyCapturedResponse::class, $gatewayMessage);\n        }\n\n        ErrorHandling::safeExtend($this->payment, 'onCaptured', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Message\\RequestInterface;\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message;\n\nclass CreateCardService extends PaymentService\n{\n\n    /**\n     * Start a createcard request\n     *\n     * @inheritdoc\n     */\n    public function initiate($data = array())\n    {\n        if ($this->payment->Status !== 'Created') {\n            throw new InvalidStateException('Cannot create a card for this payment. Status is not \"Created\"');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCreateCard()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support create card', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCreateCard', $gatewayData);\n        $request = $this->oGateway()->createCard($gatewayData);\n        $this->extend('onAfterCreateCard', $request);\n\n        $this->createMessage(Message\\CreateCardRequest::class, $request);\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(Message\\CreateCardError::class, $e);\n            // create an error response\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendCreateCard', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = 'PendingCreateCard';\n            $this->payment->write();\n\n            $this->createMessage(\n                $serviceResponse->isRedirect() ? Message\\CreateCardRedirectResponse::class : Message\\AwaitingCreateCardResponse::class,\n                $response\n            );\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(Message\\CreateCardError::class, $response);\n        } else {\n            $this->markCompleted('CardCreated', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Finalise this createcard request, after off-site external processing.\n     * This is usually only called by PaymentGatewayController.\n     * @inheritdoc\n     */\n    public function complete($data = array(), $isNotification = false)\n    {\n        $flags = $isNotification ? ServiceResponse::SERVICE_NOTIFICATION : 0;\n\n        // The card is already created\n        if ($this->payment->Status === 'CardCreated') {\n            return $this->generateServiceResponse($flags);\n        }\n\n        if ($this->payment->Status !== 'PendingCreateCard') {\n            throw new InvalidStateException('Cannot complete this payment. Status is not \"PendingCreateCard\"');\n        }\n\n        $gateway = $this->oGateway();\n        if (!method_exists($gateway, \"completeCreateCard\")) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support completeCreateCard', $this->payment->Gateway)\n            );\n        }\n\n        // purchase and completePurchase should use the same data\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCompleteCreateCard', $gatewayData);\n        /** @var RequestInterface $request */\n        $request = $gateway->completeCreateCard($gatewayData);\n        $this->extend('onAfterCompleteCreateCard', $request);\n\n        $this->createMessage(Message\\CompleteCreateCardRequest::class, $request);\n        $response = null;\n        try {\n            $response       = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(Message\\CompleteCreateCardError::class, $e);\n            return $this->generateServiceResponse($flags | ServiceResponse::SERVICE_ERROR);\n        }\n\n        $serviceResponse = $this->wrapOmnipayResponse($response, $isNotification);\n\n        if ($serviceResponse->isError()) {\n            $this->createMessage(Message\\CompleteCreateCardError::class, $response);\n            return $serviceResponse;\n        }\n\n        if (!$serviceResponse->isAwaitingNotification()) {\n            $this->markCompleted('CardCreated', $serviceResponse, $response);\n        } else {\n            ErrorHandling::safeExtend($this->payment, 'onAwaitingCreateCard', $serviceResponse);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(Message\\CreateCardResponse::class, $gatewayMessage);\n        ErrorHandling::safeExtend($this->payment, 'onCardCreated', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Model\\Payment;\n\n/**\n * Abstract base class for payment services that operate on an existing transaction. Examples of this are:\n * Void, Refund and Capture.\n *\n * This service models the following pattern:\n * * A request is made to the gateway, using an existing transaction ID.\n * * If the request is successful, the goal state is reached.\n * * If the payment provider will report success via async notification, the notification is being handled in the `complete` method.\n *\n * @package SilverStripe\\Omnipay\\Service\n */\nabstract class NotificationCompleteService extends PaymentService\n{\n    /** @var string the start state  */\n    protected $startState;\n\n    /** @var string the end state to reach */\n    protected $endState;\n\n    /** @var string the pending state name */\n    protected $pendingState;\n\n    /** @var string message type used to store requests */\n    protected $requestMessageType;\n\n    /** @var  string message type used to store errors */\n    protected $errorMessageType;\n\n    /**\n     * Complete a pending task.\n     * This is only needed for notification, so this method will always assume $isNotification is true!\n     *\n     * @param array $data\n     * @param bool $isNotification\n     * @return ServiceResponse\n     * @throws InvalidConfigurationException\n     * @throws InvalidStateException\n     */\n    public function complete($data = array(), $isNotification = true)\n    {\n        // The payment is already in the desired endstate\n        if ($this->payment->Status === $this->endState) {\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_NOTIFICATION);\n        }\n\n        // we're still in the start state, cannot complete here\n        if ($this->payment->Status === $this->startState) {\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_NOTIFICATION | ServiceResponse::SERVICE_ERROR);\n        }\n\n        if ($this->payment->Status !== $this->pendingState) {\n            throw new InvalidStateException('Cannot modify this payment. Status is not \"'. $this->pendingState .'\"');\n        }\n\n        $serviceResponse = $this->handleNotification();\n\n        // exit early\n        if ($serviceResponse->isError()) {\n            $this->notificationFailure($serviceResponse);\n            return $serviceResponse;\n        }\n\n        // safety check the payment transaction-number against the transaction reference we get from the notification\n        if (!(\n            $serviceResponse->getOmnipayResponse() &&\n            $serviceResponse->getOmnipayResponse()->getTransactionReference() == $this->payment->TransactionReference\n        )) {\n            // flag as an error if transaction references don't match\n            $serviceResponse->addFlag(ServiceResponse::SERVICE_ERROR);\n            $this->createMessage($this->errorMessageType, 'Transaction references do not match!');\n        }\n\n        // check if we're done\n        if (!$serviceResponse->isError() && !$serviceResponse->isAwaitingNotification()) {\n            $this->markCompleted($this->endState, $serviceResponse, $serviceResponse->getOmnipayResponse());\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Method to handle notification failures. Here we have to check if the gateway actually reported a failure\n     * and then update the payment status accordingly!\n     * @param ServiceResponse $serviceResponse\n     * @return void\n     */\n    protected function notificationFailure($serviceResponse)\n    {\n        $omnipayResponse = $serviceResponse->getOmnipayResponse();\n\n        // if there's no response from the gateway, don't bother. Errors are already in messages/log\n        if (!$omnipayResponse) {\n            return;\n        }\n\n        // void any pending partial payments\n        $pending = $this->payment->getPartialPayments()->filter('Status', $this->pendingState);\n\n        /** @var Payment $payment */\n        foreach ($pending as $payment) {\n            $payment->Status = 'Void';\n            $payment->write();\n        }\n\n        // reset the payment to the start-state\n        $this->payment->Status = $this->startState;\n        $this->payment->write();\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message;\n\nclass PurchaseService extends PaymentService\n{\n    /**\n     * Attempt to make a payment.\n     *\n     * @inheritdoc\n     * @param  array $data returnUrl/cancelUrl + customer creditcard and billing/shipping details.\n     *  Some keys (e.g. \"amount\") are overwritten with data from the associated {@link $payment}.\n     *  If this array is constructed from user data (e.g. a form submission), please take care\n     *  to whitelist accepted fields, in order to ensure sensitive gateway parameters like \"freeShipping\" can't be set.\n     *  If using {@link Form->getData()}, only fields which exist in the form are returned,\n     *  effectively whitelisting against arbitrary user input.\n     */\n    public function initiate($data = array())\n    {\n        if ($this->payment->Status !== 'Created') {\n            throw new InvalidStateException('Cannot initiate a purchase with this payment. Status is not \"Created\"');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsPurchase()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support purchase', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforePurchase', $gatewayData);\n        $request = $this->oGateway()->purchase($gatewayData);\n        $this->extend('onAfterPurchase', $request);\n\n        $this->createMessage(Message\\PurchaseRequest::class, $request);\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(Message\\PurchaseError::class, $e);\n            // create an error response\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendPurchase', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = 'PendingPurchase';\n            $this->payment->write();\n\n            $this->createMessage(\n                $serviceResponse->isRedirect() ? Message\\PurchaseRedirectResponse::class : Message\\AwaitingPurchaseResponse::class,\n                $response\n            );\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(Message\\PurchaseError::class, $response);\n        } else {\n            $this->markCompleted('Captured', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Finalise this payment, after off-site external processing.\n     * This is usually only called by PaymentGatewayController.\n     * @inheritdoc\n     */\n    public function complete($data = array(), $isNotification = false)\n    {\n        $flags = $isNotification ? ServiceResponse::SERVICE_NOTIFICATION : 0;\n        // The payment is already captured\n        if ($this->payment->Status === 'Captured') {\n            return $this->generateServiceResponse($flags);\n        }\n\n        if ($this->payment->Status !== 'PendingPurchase') {\n            throw new InvalidStateException('Cannot complete this payment. Status is not \"PendingPurchase\"');\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCompletePurchase()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support completePurchase', $this->payment->Gateway)\n            );\n        }\n\n        // purchase and completePurchase should use the same data\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCompletePurchase', $gatewayData);\n        $request = $gateway->completePurchase($gatewayData);\n        $this->extend('onAfterCompletePurchase', $request);\n\n        $this->createMessage(Message\\CompletePurchaseRequest::class, $request);\n        $response = null;\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(Message\\CompletePurchaseError::class, $e);\n            return $this->generateServiceResponse($flags | ServiceResponse::SERVICE_ERROR);\n        }\n\n        $serviceResponse = $this->wrapOmnipayResponse($response, $isNotification);\n        if ($serviceResponse->isError()) {\n            $this->createMessage(Message\\CompletePurchaseError::class, $response);\n            return $serviceResponse;\n        }\n\n        // only update payment status if we're not waiting for a notification\n        if (!$serviceResponse->isAwaitingNotification()) {\n            $this->markCompleted('Captured', $serviceResponse, $response);\n        } else {\n            ErrorHandling::safeExtend($this->payment, 'onAwaitingCaptured', $serviceResponse);\n        }\n\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(Message\\PurchasedResponse::class, $gatewayMessage);\n        ErrorHandling::safeExtend($this->payment, 'onCaptured', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Exception\\OmnipayException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidParameterException;\nuse SilverStripe\\Omnipay\\Exception\\MissingParameterException;\nuse SilverStripe\\Omnipay\\GatewayInfo;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Helper\\PaymentMath;\nuse SilverStripe\\Omnipay\\Model\\Message;\nuse SilverStripe\\Omnipay\\Model\\Payment;\n\nclass RefundService extends NotificationCompleteService\n{\n    protected $startState = 'Captured';\n\n    protected $endState = 'Refunded';\n\n    protected $pendingState = 'PendingRefund';\n\n    protected $requestMessageType = Message\\RefundRequest::class;\n\n    protected $errorMessageType = Message\\RefundError::class;\n\n    /**\n     * Return money to the previously charged credit card.\n     *\n     * If the transaction-reference of the payment to refund is known, pass it via $data as\n     * `transactionReference` parameter. Otherwise the service will look up the previous reference\n     * from the payment itself.\n     * If there's no transaction-reference to be found, this method will raise an exception.\n     *\n     * You can issue partial refunds (if the gateway supports it) by passing an `amount` parameter in the $data\n     * array. If the amount given is not a number, or if it exceeds the total amount of the payment, an exception\n     * will be raised.\n     *\n     * @inheritdoc\n     * @throws MissingParameterException if no transaction reference can be found from messages or parameters\n     * @throws InvalidParameterException if the amount parameter was invalid\n     */\n    public function initiate($data = array())\n    {\n        if (!$this->payment->canRefund()) {\n            throw new InvalidConfigurationException('Refunding of this payment not allowed.');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $reference = null;\n\n        // If the gateway isn't manual, we need a transaction reference to refund a payment\n        if (!GatewayInfo::isManual($this->payment->Gateway)) {\n            if (!empty($data['transactionReference'])) {\n                $reference = $data['transactionReference'];\n            } elseif (!empty($data['receipt'])) { // legacy code?\n                $reference = $data['receipt'];\n            } else {\n                $reference = $this->payment->TransactionReference;\n            }\n\n            if (empty($reference)) {\n                throw new MissingParameterException('transactionReference not found and is not set as parameter');\n            }\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsRefund()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support refunds', $this->payment->Gateway)\n            );\n        }\n\n        $amount = $this->payment->MoneyAmount;\n        $isPartial = false;\n\n        if (!empty($data['amount'])) {\n            $amount = $data['amount'];\n            if (!is_numeric($amount)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be numeric.');\n            }\n\n            if (!($amount > 0)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be positive.');\n            }\n\n            $compare = PaymentMath::compare($this->payment->MoneyAmount, $amount);\n            if ($compare === -1) {\n                throw new InvalidParameterException('The \"amount\" to refund cannot exceed the captured amount.');\n            }\n\n            $isPartial = $compare === 1;\n        }\n\n        if ($isPartial && !$this->payment->canRefund(null, true)) {\n            throw new InvalidParameterException('This payment cannot be partially refunded (unsupported by gateway).');\n        }\n\n        $gatewayData = array_merge(\n            $data,\n            array(\n                'amount' => (float)$amount,\n                'currency' => $this->payment->MoneyCurrency,\n                'transactionReference' => $reference,\n                'notifyUrl' => $this->getEndpointUrl('notify')\n            )\n        );\n\n        $this->extend('onBeforeRefund', $gatewayData);\n        $request = $this->oGateway()->refund($gatewayData);\n        $this->extend('onAfterRefund', $request);\n\n        $message = $this->createMessage($this->requestMessageType, $request);\n        $message->write();\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (OmnipayException $e) {\n            $this->createMessage($this->errorMessageType, $e);\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendRefund', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isAwaitingNotification()) {\n            if ($isPartial) {\n                $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n            }\n            $this->payment->Status = $this->pendingState;\n            $this->payment->write();\n        } else {\n            if ($serviceResponse->isError()) {\n                $this->createMessage($this->errorMessageType, $response);\n            } else {\n                if ($isPartial) {\n                    $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n                }\n                $this->markCompleted($this->endState, $serviceResponse, $response);\n            }\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        // Get partial payments\n        $partials = $this->payment->getPartialPayments()->filter('Status', $this->pendingState);\n\n        if ($partials->count() > 0) {\n            $i = 0;\n            $total = $this->payment->MoneyAmount;\n            /** @var Payment $payment */\n            foreach ($partials as $payment) {\n                // only the first, eg. most recent payment should be considered valid. All others should be set to void\n                if ($i === 0) {\n                    $total = PaymentMath::add($total, $payment->MoneyAmount);\n                    $payment->Status = 'Created';\n                    $payment->setAmount(PaymentMath::multiply($payment->MoneyAmount, '-1'));\n                    $payment->Status = 'Refunded';\n                } else {\n                    $payment->Status = 'Void';\n                }\n                $payment->write();\n                $i++;\n            }\n\n            // Ugly hack to set the money amount\n            $this->payment->Status = 'Created';\n            $this->payment->setAmount($total);\n\n            // If not everything was refunded, the payment should still have the \"Captured\" status\n            if ($total > 0) {\n                $endStatus = 'Captured';\n            }\n        }\n\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        if ($endStatus === 'Captured') {\n            $this->createMessage(Message\\PartiallyRefundedResponse::class, $gatewayMessage);\n        } else {\n            $this->createMessage(Message\\RefundedResponse::class, $gatewayMessage);\n        }\n\n        ErrorHandling::safeExtend($this->payment, 'onRefunded', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Message\\AbstractResponse;\nuse Omnipay\\Common\\Message\\NotificationInterface;\nuse SilverStripe\\Omnipay\\Exception\\ServiceException;\nuse SilverStripe\\Omnipay\\Model\\Payment;\nuse SilverStripe\\Control\\HTTPResponse;\nuse SilverStripe\\Control\\Controller;\n\n/**\n * Class ServiceResponse.\n *\n * A response generated by a service. This response holds several answer-related properties, such as\n * an HTTP Response, the response from the Omnipay gateway and several flags that give information about the\n * nature of this response\n *\n * This should be used more of container that gives access to several parts that need to be transmitted\n * from the service to the application.\n *\n * Do not implement application logic into service responses.\n *\n * @package SilverStripe\\Omnipay\\Service\\Response\n */\nclass ServiceResponse\n{\n    /**\n     * Flag to mark this response as an error\n     */\n    const SERVICE_ERROR = 1;\n\n    /**\n     * Flag to mark this response as pending (eg. waiting for an asynchronous response)\n     */\n    const SERVICE_PENDING = 2;\n\n    /**\n     * Flag to mark this response as a notification response (eg. HTTP response will be returned to the payment gateway)\n     */\n    const SERVICE_NOTIFICATION = 4;\n\n    /**\n     * Flag to mark this response as a cancelled payment\n     */\n    const SERVICE_CANCELLED = 8;\n\n    /**\n     * @var AbstractResponse|NotificationInterface\n     */\n    protected $omnipayResponse;\n\n    /**\n     * @var int\n     */\n    protected $flags = 0;\n\n    /**\n     * @var bool\n     */\n    protected $isAwaitingNotification = false;\n\n    /**\n     * @var Payment\n     */\n    protected $payment;\n\n    /**\n     * @var string\n     */\n    protected $targetUrl;\n\n    /**\n     * @var HTTPResponse\n     */\n    protected $httpResponse;\n\n\n    /**\n     * Additional arguments will be treated as state flags\n     *\n     * @param Payment $payment the payment instance\n     */\n    public function __construct(Payment $payment)\n    {\n        $this->payment = $payment;\n        for ($i = 1, $len = func_num_args(); $i < $len; $i++) {\n            $this->addFlag(func_get_arg($i));\n        }\n    }\n\n    /**\n     * @return Payment\n     */\n    public function getPayment()\n    {\n        return $this->payment;\n    }\n\n    /**\n     * Whether or not this is an *offsite* redirect.\n     * This is only the case when there's an Omnipay response present that *is* a redirect.\n     *\n     * @return bool\n     */\n    public function isRedirect()\n    {\n        return ($this->omnipayResponse instanceof AbstractResponse) && $this->omnipayResponse->isRedirect();\n    }\n\n    /**\n     * Whether or not this response is an error-response.\n     *\n     * Attention: This doesn't necessarily correlate with the Omnipay response being successful or not\u2026\n     * A redirect is not successful in terms of completing a payment (response from omnipay isn't successful), yet the\n     * service completed successfully and shouldn't report an error here!\n     *\n     * @return boolean\n     */\n    public function isError()\n    {\n        return $this->hasFlag(self::SERVICE_ERROR);\n    }\n\n    /**\n     * Whether or not the request is pending and waiting for an async notification.\n     *\n     * @return bool\n     */\n    public function isAwaitingNotification()\n    {\n        return $this->hasFlag(self::SERVICE_PENDING);\n    }\n\n    /**\n     * Whether or not this is a response to a notification.\n     *\n     * @return bool\n     */\n    public function isNotification()\n    {\n        return $this->hasFlag(self::SERVICE_NOTIFICATION);\n    }\n\n    /**\n     * Whether or not the payment was cancelled.\n     *\n     * @return bool\n     */\n    public function isCancelled()\n    {\n        return $this->hasFlag(self::SERVICE_CANCELLED);\n    }\n\n    /**\n     * Check if the given flag(s) is set (active)\n     * @param int $flag the flag to check. Can be a combination of several flags (joined with binary OR)\n     * @return bool true if the given flag/s match\n     */\n    public function hasFlag($flag)\n    {\n        if (!is_int($flag)) {\n            throw new \\InvalidArgumentException('Flag must be of type int');\n        }\n        return ($this->flags & $flag) === $flag;\n    }\n\n    /**\n     * Add a flag for this response.\n     * Example: `$r->addFlag(ServiceResponse::SERVICE_PENDING)`\n     *\n     * @param int $flag\n     * @throws \\InvalidArgumentException if the parameter is not of type int\n     * @return $this\n     */\n    public function addFlag($flag)\n    {\n        if (!is_int($flag)) {\n            throw new \\InvalidArgumentException('Flag must be of type int');\n        }\n        $this->flags |= $flag;\n        return $this;\n    }\n\n    /**\n     * Remove a flag from this response.\n     * Example: `$r->removeFlag(ServiceResponse::SERVICE_PENDING)`\n     *\n     * @param int $flag\n     * @throws \\InvalidArgumentException if the parameter is not of type int\n     * @return $this\n     */\n    public function removeFlag($flag)\n    {\n        if (!is_int($flag)) {\n            throw new \\InvalidArgumentException('Flag must be of type int');\n        }\n        $this->flags &= ~$flag;\n        return $this;\n    }\n\n    /**\n     * The target url where this response should redirect to (this will be used to redirect internally, if\n     * the response wasn't set specifically)\n     * @return string\n     */\n    public function getTargetUrl()\n    {\n        return $this->targetUrl;\n    }\n\n    /**\n     * Set the target url.\n     * In the case of a redirect, the URL is given by the Omnipay response and should be considered immutable.\n     * When trying to set a targetUrl in this scenario, an Exception will be raised.\n     * @param string $value the new target url\n     * @return $this\n     * @throws ServiceException if trying to set a targetUrl for a redirect.\n     */\n    public function setTargetUrl($value)\n    {\n        if ($this->isRedirect()) {\n            throw new ServiceException('Unable to override target URL of redirect response');\n        }\n        $this->targetUrl = $value;\n        return $this;\n    }\n\n    /**\n     * Get the response given by the omnipay gateway.\n     * This can be an instance of AbstractResponse or NotificationInterface (in case of a notification)\n     * @return AbstractResponse|NotificationInterface|null\n     */\n    public function getOmnipayResponse()\n    {\n        return $this->omnipayResponse;\n    }\n\n    /**\n     * Set the response from Omnipay\n     * @param AbstractResponse|NotificationInterface $response the response or notification from the Omnipay gateway\n     * @return $this\n     */\n    public function setOmnipayResponse($response)\n    {\n        $this->omnipayResponse = $response;\n        // also set the target Url if the response is a redirect\n        if ($this->isRedirect()) {\n            $redirectResponse = $this->omnipayResponse->getRedirectResponse();\n            if ($redirectResponse instanceof \\Symfony\\Component\\HttpFoundation\\RedirectResponse) {\n                $this->targetUrl = $redirectResponse->getTargetUrl();\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Create a redirect or a response.\n     * This should be called when the application is ready to redirect!\n     *\n     * If the response is a redirect, the redirect takes precedence.\n     * Next, the HTTP response will be returned (if set) and lastly\n     * a redirect response to the  @see getTargetUrl.\n     *\n     * If none of these parameters are given, this method will return null\n     *\n     * @return HTTPResponse\n     */\n    public function redirectOrRespond()\n    {\n        if ($this->isRedirect()) {\n            $redirectResponse = $this->omnipayResponse->getRedirectResponse();\n            if ($redirectResponse instanceof \\Symfony\\Component\\HttpFoundation\\RedirectResponse) {\n                $this->targetUrl = $redirectResponse->getTargetUrl();\n\n                return Controller::curr()->redirect($this->targetUrl);\n            } else {\n                return new HTTPResponse((string)$redirectResponse->getContent(), 200);\n            }\n        }\n\n        if ($this->httpResponse) {\n            return $this->httpResponse;\n        }\n\n        if ($this->targetUrl) {\n            return Controller::curr()->redirect($this->targetUrl);\n        }\n\n        // return some default HTTP responses\n        return $this->isError()\n            ? new HTTPResponse(\"NOK\", 500)\n            : new HTTPResponse(\"OK\", 200);\n    }\n\n    /**\n     * Return the HTTP response given by this gateway.\n     * This could be a redirect, but might also be a response with content.\n     * @return HTTPResponse\n     */\n    public function getHttpResponse()\n    {\n        return $this->httpResponse;\n    }\n\n    /**\n     * Set the HTTP response.\n     *\n     * @param HTTPResponse $response the HTTP response. Can be used to return directly from a payment request\n     *\n     * @return $this\n     */\n    public function setHttpResponse(HTTPResponse $response)\n    {\n        $this->httpResponse = $response;\n        return $this;\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\MissingParameterException;\nuse Omnipay\\Common\\Exception\\OmnipayException;\nuse SilverStripe\\Omnipay\\GatewayInfo;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message;\n\nclass VoidService extends NotificationCompleteService\n{\n    protected $startState = 'Authorized';\n\n    protected $endState = 'Void';\n\n    protected $pendingState = 'PendingVoid';\n\n    protected $requestMessageType = Message\\VoidRequest::class;\n\n    protected $errorMessageType = Message\\VoidError::class;\n\n    /**\n     * Void/cancel a payment\n     *\n     * If the transaction-reference of the payment to capture is known, pass it via $data as\n     * `transactionReference` parameter. Otherwise the service will try to look up the reference\n     * from previous payment messages.\n     *\n     * If there's no transaction-reference to be found, this method will raise an exception.\n     *\n     * @inheritdoc\n     * @throws MissingParameterException if no transaction reference can be found from messages or parameters\n     */\n    public function initiate($data = array())\n    {\n        if (!$this->payment->canVoid()) {\n            throw new InvalidConfigurationException('Voiding of this payment not allowed.');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $reference = null;\n\n        // If the gateway isn't manual, we need a transaction reference to void a payment\n        if (!GatewayInfo::isManual($this->payment->Gateway)) {\n            if (!empty($data['transactionReference'])) {\n                $reference = $data['transactionReference'];\n            } elseif (!empty($data['receipt'])) { // legacy code?\n                $reference = $data['receipt'];\n            } else {\n                $reference = $this->payment->TransactionReference;\n            }\n\n            if (empty($reference)) {\n                throw new MissingParameterException('transactionReference not found and is not set as parameter');\n            }\n        }\n\n        $gateway = $this->oGateway();\n\n        if (!$gateway->supportsVoid()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support void', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = array_merge(\n            $data,\n            array(\n                'amount' => (float)$this->payment->MoneyAmount,\n                'currency' => $this->payment->MoneyCurrency,\n                'transactionReference' => $reference,\n                'notifyUrl' => $this->getEndpointUrl('notify')\n            )\n        );\n\n        $this->extend('onBeforeVoid', $gatewayData);\n        $request = $this->oGateway()->void($gatewayData);\n        $this->extend('onAfterVoid', $request);\n\n        $message = $this->createMessage($this->requestMessageType, $request);\n        $message->write();\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (OmnipayException $e) {\n            $this->createMessage($this->errorMessageType, $e);\n\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendVoid', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = $this->pendingState;\n            $this->payment->write();\n        } else {\n            if ($serviceResponse->isError()) {\n                $this->createMessage($this->errorMessageType, $response);\n            } else {\n                $this->markCompleted($this->endState, $serviceResponse, $response);\n            }\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(Message\\VoidedResponse::class, $gatewayMessage);\n\n        ErrorHandling::safeExtend($this->payment, 'onVoid', $serviceResponse);\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizeError;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizeRedirectResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\AuthorizeRequest;\nuse SilverStripe\\Omnipay\\Model\\Message\\AwaitingAuthorizeResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompleteAuthorizeError;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompleteAuthorizeRequest;\n\nclass AuthorizeService extends PaymentService\n{\n    /**\n     * Start an authorization request\n     *\n     * @inheritdoc\n     */\n    public function initiate($data = array())\n    {\n        if ($this->payment->Status !== 'Created') {\n            throw new InvalidStateException('Cannot authorize this payment. Status is not \"Created\"');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsAuthorize()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support authorize', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeAuthorize', $gatewayData);\n        $request = $this->oGateway()->authorize($gatewayData);\n        $this->extend('onAfterAuthorize', $request);\n\n        $this->createMessage(AuthorizeRequest::class, $request);\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(AuthorizeError::class, $e);\n            // create an error response\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendAuthorize', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = 'PendingAuthorization';\n            $this->payment->write();\n\n            $this->createMessage(\n                $serviceResponse->isRedirect() ? AuthorizeRedirectResponse::class : AwaitingAuthorizeResponse::class,\n                $response\n            );\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(AuthorizeError::class, $response);\n        } elseif ($serviceResponse->isSuccessful()) {\n            $this->markCompleted('Authorized', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Finalise this authorization, after off-site external processing.\n     * This is usually only called by PaymentGatewayController.\n     * @inheritdoc\n     */\n    public function complete($data = array(), $isNotification = false)\n    {\n        $flags = $isNotification ? ServiceResponse::SERVICE_NOTIFICATION : 0;\n\n        // The payment is already captured\n        if ($this->payment->Status === 'Authorized') {\n            return $this->generateServiceResponse($flags);\n        }\n\n        if ($this->payment->Status !== 'PendingAuthorization') {\n            throw new InvalidStateException('Cannot complete this payment. Status is not \"PendingAuthorization\"');\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCompleteAuthorize()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support completeAuthorize', $this->payment->Gateway)\n            );\n        }\n\n        // purchase and completePurchase should use the same data\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCompleteAuthorize', $gatewayData);\n        $request = $gateway->completeAuthorize($gatewayData);\n        $this->extend('onAfterCompleteAuthorize', $request);\n\n        $this->createMessage(CompleteAuthorizeRequest::class, $request);\n        $response = null;\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(CompleteAuthorizeError::class, $e);\n\n            return $this->generateServiceResponse($flags | ServiceResponse::SERVICE_ERROR);\n        }\n\n        $serviceResponse = $this->wrapOmnipayResponse($response, $isNotification);\n\n        if ($serviceResponse->isAwaitingNotification()) {\n            ErrorHandling::safeExtend($this->payment, 'onAwaitingAuthorized', $serviceResponse);\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(CompleteAuthorizeError::class, $response);\n        } elseif ($serviceResponse->isSuccessful()) {\n            $this->markCompleted('Authorized', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(AuthorizedResponse::class, $gatewayMessage);\n        ErrorHandling::safeExtend($this->payment, 'onAuthorized', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Exception\\OmnipayException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidParameterException;\nuse SilverStripe\\Omnipay\\Exception\\MissingParameterException;\nuse SilverStripe\\Omnipay\\GatewayInfo;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message\\CapturedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CaptureError;\nuse SilverStripe\\Omnipay\\Model\\Message\\CaptureRequest;\nuse SilverStripe\\Omnipay\\Model\\Message\\PartiallyCapturedResponse;\nuse SilverStripe\\Omnipay\\Helper\\PaymentMath;\nuse SilverStripe\\Omnipay\\Model\\Payment;\n\n/**\n * Service used in tandem with AuthorizeService.\n *\n * This service captures a previously authorized amount\n */\nclass CaptureService extends NotificationCompleteService\n{\n    protected $startState = 'Authorized';\n\n    protected $endState = 'Captured';\n\n    protected $pendingState = 'PendingCapture';\n\n    protected $requestMessageType = CaptureRequest::class;\n\n    protected $errorMessageType = CaptureError::class;\n\n    /**\n     * Capture a previously authorized payment\n     *\n     * If the transaction-reference of the payment to capture is known, pass it via $data as\n     * `transactionReference` parameter. Otherwise the service will try to look up the reference from previous payment\n     * messages.\n     *\n     * If there's no transaction-reference to be found, this method will raise an exception.\n     *\n     * You can issue partial captures (if the gateway supports it) by passing an `amount` parameter in the $data\n     * array. The amount can also exceed the authorized amount, if the configuration allows it (`max_capture` setting).\n     * An amount that exceeds the authorized amount will always be considered as a full capture!\n     * If the amount given is not a number, or if it exceeds the total possible capture amount, an exception\n     * will be raised.\n     *\n     * @inheritdoc\n     * @throws MissingParameterException if no transaction reference can be found from messages or parameters\n     * @throws InvalidParameterException if the amount parameter was invalid\n     */\n    public function initiate($data = array())\n    {\n        if (!$this->payment->canCapture()) {\n            throw new InvalidConfigurationException('Capture of this payment not allowed.');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $reference = null;\n\n        // If the gateway isn't manual, we need a transaction reference to refund a payment\n        if (!GatewayInfo::isManual($this->payment->Gateway)) {\n            if (!empty($data['transactionReference'])) {\n                $reference = $data['transactionReference'];\n            } elseif (!empty($data['receipt'])) { // legacy code?\n                $reference = $data['receipt'];\n            } else {\n                $reference = $this->payment->TransactionReference;\n            }\n\n            if (empty($reference)) {\n                throw new MissingParameterException('transactionReference not found and is not set as parameter');\n            }\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCapture()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support capture', $this->payment->Gateway)\n            );\n        }\n\n        $authorized = $amount = $this->payment->MoneyAmount;\n        $diff = 0;\n\n        if (!empty($data['amount'])) {\n            $amount = $data['amount'];\n            if (!is_numeric($amount)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be numeric.');\n            }\n\n            if (!($amount > 0)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be positive.');\n            }\n\n            // check if the amount exceeds the max. amount that can be captured\n            if (PaymentMath::compare($this->payment->getMaxCaptureAmount(), $amount) === -1) {\n                throw new InvalidParameterException('The \"amount\" given exceeds the amount that can be captured.');\n            }\n\n            $diff = PaymentMath::subtract($amount, $authorized);\n        }\n\n        if ($diff < 0 && !$this->payment->canCapture(null, true)) {\n            throw new InvalidParameterException('This payment cannot be partially captured (unsupported by gateway).');\n        }\n\n        $gatewayData = array_merge(\n            $data,\n            array(\n                'amount' => (float)$amount,\n                'currency' => $this->payment->MoneyCurrency,\n                'transactionReference' => $reference,\n                'notifyUrl' => $this->getEndpointUrl('notify')\n            )\n        );\n\n        $this->extend('onBeforeCapture', $gatewayData);\n        $request = $this->oGateway()->capture($gatewayData);\n        $this->extend('onAfterCapture', $request);\n\n        $message = $this->createMessage($this->requestMessageType, $request);\n        $message->write();\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (OmnipayException $e) {\n            $this->createMessage($this->errorMessageType, $e);\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendCapture', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isError()) {\n            $this->createMessage($this->errorMessageType, $response);\n        } elseif ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            if ($diff < 0) {\n                $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n            } elseif ($diff > 0) {\n                $this->createPartialPayment($diff, $this->pendingState);\n            }\n            $this->payment->Status = $this->pendingState;\n            $this->payment->write();\n        } elseif ($serviceResponse->isSuccessful()) {\n            if ($diff < 0) {\n                $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n            } elseif ($diff > 0) {\n                $this->createPartialPayment($diff, $this->pendingState);\n            }\n            $this->markCompleted($this->endState, $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        // Get partial payments\n        $partials = $this->payment->getPartialPayments()->filter('Status', $this->pendingState);\n\n        if ($partials->count() > 0) {\n            $i = 0;\n            $total = $originalTotal = $this->payment->MoneyAmount;\n            /** @var Payment $payment */\n            foreach ($partials as $payment) {\n                // only the first, eg. most recent payment should be considered valid. All others should be set to void\n                if ($i === 0) {\n                    $total = PaymentMath::add($total, $payment->MoneyAmount);\n\n                    // deal with partial capture\n                    if ($payment->MoneyAmount < 0) {\n                        $payment->Status = 'Created';\n                        $payment->setAmount(PaymentMath::multiply($payment->MoneyAmount, '-1'));\n                        $payment->Status = 'Captured';\n                    } else {\n                        // void excess amounts\n                        $payment->Status = 'Void';\n                    }\n                } else {\n                    $payment->Status = 'Void';\n                }\n                $payment->write();\n                $i++;\n            }\n\n            // Ugly hack to set the money amount\n            $this->payment->Status = 'Created';\n            $this->payment->setAmount($total);\n\n            // If not everything was captured (partial),\n            // the payment should be refunded or still Authorized (in case multiple captures are possible)\n            if ($total > 0 && $total < $originalTotal) {\n                $endStatus = GatewayInfo::captureMode($this->payment->Gateway) === GatewayInfo::MULTIPLE\n                    ? 'Authorized'\n                    : 'Refunded';\n            }\n        }\n\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n\n        if ($endStatus === 'Captured') {\n            $this->createMessage(CapturedResponse::class, $gatewayMessage);\n        } else {\n            $this->createMessage(PartiallyCapturedResponse::class, $gatewayMessage);\n        }\n\n        ErrorHandling::safeExtend($this->payment, 'onCaptured', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Message\\RequestInterface;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message\\AwaitingCreateCardResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompleteCreateCardError;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompleteCreateCardRequest;\nuse SilverStripe\\Omnipay\\Model\\Message\\CreateCardError;\nuse SilverStripe\\Omnipay\\Model\\Message\\CreateCardRedirectResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CreateCardRequest;\nuse SilverStripe\\Omnipay\\Model\\Message\\CreateCardResponse;\n\nclass CreateCardService extends PaymentService\n{\n    /**\n     * Start a createcard request\n     *\n     * @inheritdoc\n     */\n    public function initiate($data = array())\n    {\n        if ($this->payment->Status !== 'Created') {\n            throw new InvalidStateException('Cannot create a card for this payment. Status is not \"Created\"');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCreateCard()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support create card', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCreateCard', $gatewayData);\n        $request = $this->oGateway()->createCard($gatewayData);\n        $this->extend('onAfterCreateCard', $request);\n\n        $this->createMessage(CreateCardRequest::class, $request);\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(CreateCardError::class, $e);\n            // create an error response\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendCreateCard', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = 'PendingCreateCard';\n            $this->payment->write();\n\n            $this->createMessage(\n                $serviceResponse->isRedirect() ? CreateCardRedirectResponse::class : AwaitingCreateCardResponse::class,\n                $response\n            );\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(CreateCardError::class, $response);\n        } elseif ($serviceResponse->isSuccessful()) {\n            $this->markCompleted('CardCreated', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Finalise this createcard request, after off-site external processing.\n     * This is usually only called by PaymentGatewayController.\n     * @inheritdoc\n     */\n    public function complete($data = array(), $isNotification = false)\n    {\n        $flags = $isNotification ? ServiceResponse::SERVICE_NOTIFICATION : 0;\n\n        // The card is already created\n        if ($this->payment->Status === 'CardCreated') {\n            return $this->generateServiceResponse($flags);\n        }\n\n        if ($this->payment->Status !== 'PendingCreateCard') {\n            throw new InvalidStateException('Cannot complete this payment. Status is not \"PendingCreateCard\"');\n        }\n\n        $gateway = $this->oGateway();\n        if (!method_exists($gateway, \"completeCreateCard\")) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support completeCreateCard', $this->payment->Gateway)\n            );\n        }\n\n        // purchase and completePurchase should use the same data\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCompleteCreateCard', $gatewayData);\n        /** @var RequestInterface $request */\n        $request = $gateway->completeCreateCard($gatewayData);\n        $this->extend('onAfterCompleteCreateCard', $request);\n\n        $this->createMessage(CompleteCreateCardRequest::class, $request);\n        $response = null;\n        try {\n            $response       = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(CompleteCreateCardError::class, $e);\n            return $this->generateServiceResponse($flags | ServiceResponse::SERVICE_ERROR);\n        }\n\n        $serviceResponse = $this->wrapOmnipayResponse($response, $isNotification);\n\n        if ($serviceResponse->isAwaitingNotification()) {\n            ErrorHandling::safeExtend($this->payment, 'onAwaitingCreateCard', $serviceResponse);\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(CompleteCreateCardError::class, $response);\n        } elseif ($serviceResponse->isSuccessful()) {\n            $this->markCompleted('CardCreated', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(CreateCardResponse::class, $gatewayMessage);\n        ErrorHandling::safeExtend($this->payment, 'onCardCreated', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Model\\Payment;\n\n/**\n * Abstract base class for payment services that operate on an existing transaction. Examples of this are:\n * Void, Refund and Capture.\n *\n * This service models the following pattern:\n * * A request is made to the gateway, using an existing transaction ID.\n * * If the request is successful, the goal state is reached.\n * * If the payment provider will report success via async notification, the notification is being handled in the `complete` method.\n *\n * @package SilverStripe\\Omnipay\\Service\n */\nabstract class NotificationCompleteService extends PaymentService\n{\n    /** @var string the start state  */\n    protected $startState;\n\n    /** @var string the end state to reach */\n    protected $endState;\n\n    /** @var string the pending state name */\n    protected $pendingState;\n\n    /** @var string message type used to store requests */\n    protected $requestMessageType;\n\n    /** @var  string message type used to store errors */\n    protected $errorMessageType;\n\n    /**\n     * Complete a pending task.\n     * This is only needed for notification, so this method will always assume $isNotification is true!\n     *\n     * @param array $data\n     * @param bool $isNotification\n     * @return ServiceResponse\n     * @throws InvalidConfigurationException\n     * @throws InvalidStateException\n     */\n    public function complete($data = array(), $isNotification = true)\n    {\n        // The payment is already in the desired endstate\n        if ($this->payment->Status === $this->endState) {\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_NOTIFICATION);\n        }\n\n        // we're still in the start state, cannot complete here\n        if ($this->payment->Status === $this->startState) {\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_NOTIFICATION | ServiceResponse::SERVICE_ERROR);\n        }\n\n        if ($this->payment->Status !== $this->pendingState) {\n            throw new InvalidStateException('Cannot modify this payment. Status is not \"'. $this->pendingState .'\"');\n        }\n\n        $serviceResponse = $this->handleNotification();\n\n        // exit early\n        if ($serviceResponse->isError()) {\n            $this->notificationFailure($serviceResponse);\n            return $serviceResponse;\n        }\n\n        // safety check the payment transaction-number against the transaction reference we get from the notification\n        if (!(\n            $serviceResponse->getOmnipayResponse() &&\n            $serviceResponse->getOmnipayResponse()->getTransactionReference() == $this->payment->TransactionReference\n        )) {\n            // flag as an error if transaction references don't match\n            $serviceResponse->addFlag(ServiceResponse::SERVICE_ERROR);\n            $this->createMessage($this->errorMessageType, 'Transaction references do not match!');\n        }\n\n        // check if we're done\n        if (!$serviceResponse->isError()\n            && !$serviceResponse->isAwaitingNotification()\n            && $serviceResponse->isSuccessful()\n        ) {\n            $this->markCompleted($this->endState, $serviceResponse, $serviceResponse->getOmnipayResponse());\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Method to handle notification failures. Here we have to check if the gateway actually reported a failure\n     * and then update the payment status accordingly!\n     * @param ServiceResponse $serviceResponse\n     * @return void\n     */\n    protected function notificationFailure($serviceResponse)\n    {\n        $omnipayResponse = $serviceResponse->getOmnipayResponse();\n\n        // if there's no response from the gateway, don't bother. Errors are already in messages/log\n        if (!$omnipayResponse) {\n            return;\n        }\n\n        // void any pending partial payments\n        $pending = $this->payment->getPartialPayments()->filter('Status', $this->pendingState);\n\n        /** @var Payment $payment */\n        foreach ($pending as $payment) {\n            $payment->Status = 'Void';\n            $payment->write();\n        }\n\n        // reset the payment to the start-state\n        $this->payment->Status = $this->startState;\n        $this->payment->write();\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse SilverStripe\\Omnipay\\Exception\\InvalidStateException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message\\AwaitingPurchaseResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompletePurchaseError;\nuse SilverStripe\\Omnipay\\Model\\Message\\CompletePurchaseRequest;\nuse SilverStripe\\Omnipay\\Model\\Message\\PurchasedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\PurchaseError;\nuse SilverStripe\\Omnipay\\Model\\Message\\PurchaseRedirectResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\PurchaseRequest;\n\nclass PurchaseService extends PaymentService\n{\n    /**\n     * Attempt to make a payment.\n     *\n     * @inheritdoc\n     * @param  array $data returnUrl/cancelUrl + customer creditcard and billing/shipping details.\n     *  Some keys (e.g. \"amount\") are overwritten with data from the associated {@link $payment}.\n     *  If this array is constructed from user data (e.g. a form submission), please take care\n     *  to whitelist accepted fields, in order to ensure sensitive gateway parameters like \"freeShipping\" can't be set.\n     *  If using {@link Form->getData()}, only fields which exist in the form are returned,\n     *  effectively whitelisting against arbitrary user input.\n     */\n    public function initiate($data = array())\n    {\n        if ($this->payment->Status !== 'Created') {\n            throw new InvalidStateException('Cannot initiate a purchase with this payment. Status is not \"Created\"');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsPurchase()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support purchase', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforePurchase', $gatewayData);\n        $request = $this->oGateway()->purchase($gatewayData);\n        $this->extend('onAfterPurchase', $request);\n\n        $this->createMessage(PurchaseRequest::class, $request);\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(PurchaseError::class, $e);\n            // create an error response\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendPurchase', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = 'PendingPurchase';\n            $this->payment->write();\n\n            $this->createMessage(\n                $serviceResponse->isRedirect() ? PurchaseRedirectResponse::class : AwaitingPurchaseResponse::class,\n                $response\n            );\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(PurchaseError::class, $response);\n        } elseif ($serviceResponse->isSuccessful()) {\n            $this->markCompleted('Captured', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    /**\n     * Finalise this payment, after off-site external processing.\n     * This is usually only called by PaymentGatewayController.\n     * @inheritdoc\n     */\n    public function complete($data = array(), $isNotification = false)\n    {\n        $flags = $isNotification ? ServiceResponse::SERVICE_NOTIFICATION : 0;\n        // The payment is already captured\n        if ($this->payment->Status === 'Captured') {\n            return $this->generateServiceResponse($flags);\n        }\n\n        if ($this->payment->Status !== 'PendingPurchase') {\n            throw new InvalidStateException('Cannot complete this payment. Status is not \"PendingPurchase\"');\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsCompletePurchase()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support completePurchase', $this->payment->Gateway)\n            );\n        }\n\n        // purchase and completePurchase should use the same data\n        $gatewayData = $this->gatherGatewayData($data);\n\n        $this->extend('onBeforeCompletePurchase', $gatewayData);\n        $request = $gateway->completePurchase($gatewayData);\n        $this->extend('onAfterCompletePurchase', $request);\n\n        $this->createMessage(CompletePurchaseRequest::class, $request);\n        $response = null;\n        try {\n            $response = $this->response = $request->send();\n        } catch (\\Omnipay\\Common\\Exception\\OmnipayException $e) {\n            $this->createMessage(CompletePurchaseError::class, $e);\n            return $this->generateServiceResponse($flags | ServiceResponse::SERVICE_ERROR);\n        }\n\n        $serviceResponse = $this->wrapOmnipayResponse($response, $isNotification);\n\n        if ($serviceResponse->isAwaitingNotification()) {\n            ErrorHandling::safeExtend($this->payment, 'onAwaitingCaptured', $serviceResponse);\n        } elseif ($serviceResponse->isError()) {\n            $this->createMessage(CompletePurchaseError::class, $response);\n        } elseif ($serviceResponse->isSuccessful()) {\n            $this->markCompleted('Captured', $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(PurchasedResponse::class, $gatewayMessage);\n        ErrorHandling::safeExtend($this->payment, 'onCaptured', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Exception\\OmnipayException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidParameterException;\nuse SilverStripe\\Omnipay\\Exception\\MissingParameterException;\nuse SilverStripe\\Omnipay\\GatewayInfo;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Helper\\PaymentMath;\nuse SilverStripe\\Omnipay\\Model\\Message\\PartiallyRefundedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\RefundedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\RefundError;\nuse SilverStripe\\Omnipay\\Model\\Message\\RefundRequest;\nuse SilverStripe\\Omnipay\\Model\\Payment;\n\nclass RefundService extends NotificationCompleteService\n{\n    protected $startState = 'Captured';\n\n    protected $endState = 'Refunded';\n\n    protected $pendingState = 'PendingRefund';\n\n    protected $requestMessageType = RefundRequest::class;\n\n    protected $errorMessageType = RefundError::class;\n\n    /**\n     * Return money to the previously charged credit card.\n     *\n     * If the transaction-reference of the payment to refund is known, pass it via $data as\n     * `transactionReference` parameter. Otherwise the service will look up the previous reference\n     * from the payment itself.\n     * If there's no transaction-reference to be found, this method will raise an exception.\n     *\n     * You can issue partial refunds (if the gateway supports it) by passing an `amount` parameter in the $data\n     * array. If the amount given is not a number, or if it exceeds the total amount of the payment, an exception\n     * will be raised.\n     *\n     * @inheritdoc\n     * @throws MissingParameterException if no transaction reference can be found from messages or parameters\n     * @throws InvalidParameterException if the amount parameter was invalid\n     */\n    public function initiate($data = array())\n    {\n        if (!$this->payment->canRefund()) {\n            throw new InvalidConfigurationException('Refunding of this payment not allowed.');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $reference = null;\n\n        // If the gateway isn't manual, we need a transaction reference to refund a payment\n        if (!GatewayInfo::isManual($this->payment->Gateway)) {\n            if (!empty($data['transactionReference'])) {\n                $reference = $data['transactionReference'];\n            } elseif (!empty($data['receipt'])) { // legacy code?\n                $reference = $data['receipt'];\n            } else {\n                $reference = $this->payment->TransactionReference;\n            }\n\n            if (empty($reference)) {\n                throw new MissingParameterException('transactionReference not found and is not set as parameter');\n            }\n        }\n\n        $gateway = $this->oGateway();\n        if (!$gateway->supportsRefund()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support refunds', $this->payment->Gateway)\n            );\n        }\n\n        $amount = $this->payment->MoneyAmount;\n        $isPartial = false;\n\n        if (!empty($data['amount'])) {\n            $amount = $data['amount'];\n            if (!is_numeric($amount)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be numeric.');\n            }\n\n            if (!($amount > 0)) {\n                throw new InvalidParameterException('The \"amount\" parameter has to be positive.');\n            }\n\n            $compare = PaymentMath::compare($this->payment->MoneyAmount, $amount);\n            if ($compare === -1) {\n                throw new InvalidParameterException('The \"amount\" to refund cannot exceed the captured amount.');\n            }\n\n            $isPartial = $compare === 1;\n        }\n\n        if ($isPartial && !$this->payment->canRefund(null, true)) {\n            throw new InvalidParameterException('This payment cannot be partially refunded (unsupported by gateway).');\n        }\n\n        $gatewayData = array_merge(\n            $data,\n            array(\n                'amount' => (float)$amount,\n                'currency' => $this->payment->MoneyCurrency,\n                'transactionReference' => $reference,\n                'notifyUrl' => $this->getEndpointUrl('notify')\n            )\n        );\n\n        $this->extend('onBeforeRefund', $gatewayData);\n        $request = $this->oGateway()->refund($gatewayData);\n        $this->extend('onAfterRefund', $request);\n\n        $message = $this->createMessage($this->requestMessageType, $request);\n        $message->write();\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (OmnipayException $e) {\n            $this->createMessage($this->errorMessageType, $e);\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendRefund', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isError()) {\n            $this->createMessage($this->errorMessageType, $response);\n        } elseif ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            if ($isPartial) {\n                $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n            }\n            $this->payment->Status = $this->pendingState;\n            $this->payment->write();\n        } elseif ($serviceResponse->isSuccessful()) {\n            if ($isPartial) {\n                $this->createPartialPayment(PaymentMath::multiply($amount, '-1'), $this->pendingState);\n            }\n\n            $this->markCompleted($this->endState, $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        // Get partial payments\n        $partials = $this->payment->getPartialPayments()->filter('Status', $this->pendingState);\n\n        if ($partials->count() > 0) {\n            $i = 0;\n            $total = $this->payment->MoneyAmount;\n            /** @var Payment $payment */\n            foreach ($partials as $payment) {\n                // only the first, eg. most recent payment should be considered valid. All others should be set to void\n                if ($i === 0) {\n                    $total = PaymentMath::add($total, $payment->MoneyAmount);\n                    $payment->Status = 'Created';\n                    $payment->setAmount(PaymentMath::multiply($payment->MoneyAmount, '-1'));\n                    $payment->Status = 'Refunded';\n                } else {\n                    $payment->Status = 'Void';\n                }\n                $payment->write();\n                $i++;\n            }\n\n            // Ugly hack to set the money amount\n            $this->payment->Status = 'Created';\n            $this->payment->setAmount($total);\n\n            // If not everything was refunded, the payment should still have the \"Captured\" status\n            if ($total > 0) {\n                $endStatus = 'Captured';\n            }\n        }\n\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        if ($endStatus === 'Captured') {\n            $this->createMessage(PartiallyRefundedResponse::class, $gatewayMessage);\n        } else {\n            $this->createMessage(RefundedResponse::class, $gatewayMessage);\n        }\n\n        ErrorHandling::safeExtend($this->payment, 'onRefunded', $serviceResponse);\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Message\\AbstractResponse;\nuse Omnipay\\Common\\Message\\NotificationInterface;\nuse SilverStripe\\Omnipay\\Exception\\ServiceException;\nuse SilverStripe\\Omnipay\\Model\\Payment;\nuse SilverStripe\\Control\\HTTPResponse;\nuse SilverStripe\\Control\\Controller;\n\n/**\n * Class ServiceResponse.\n *\n * A response generated by a service. This response holds several answer-related properties, such as\n * an HTTP Response, the response from the Omnipay gateway and several flags that give information about the\n * nature of this response\n *\n * This should be used more of container that gives access to several parts that need to be transmitted\n * from the service to the application.\n *\n * Do not implement application logic into service responses.\n *\n * @package SilverStripe\\Omnipay\\Service\\Response\n */\nclass ServiceResponse\n{\n    /**\n     * Flag to mark this response as an error\n     */\n    const SERVICE_ERROR = 1;\n\n    /**\n     * Flag to mark this response as pending (eg. waiting for an asynchronous response)\n     */\n    const SERVICE_PENDING = 2;\n\n    /**\n     * Flag to mark this response as a notification response (eg. HTTP response will be returned to the payment gateway)\n     */\n    const SERVICE_NOTIFICATION = 4;\n\n    /**\n     * Flag to mark this response as a cancelled payment\n     */\n    const SERVICE_CANCELLED = 8;\n\n    /**\n     * @var AbstractResponse|NotificationInterface\n     */\n    protected $omnipayResponse;\n\n    /**\n     * @var int\n     */\n    protected $flags = 0;\n\n    /**\n     * @var bool\n     */\n    protected $isAwaitingNotification = false;\n\n    /**\n     * @var Payment\n     */\n    protected $payment;\n\n    /**\n     * @var string\n     */\n    protected $targetUrl;\n\n    /**\n     * @var HTTPResponse\n     */\n    protected $httpResponse;\n\n\n    /**\n     * Additional arguments will be treated as state flags\n     *\n     * @param Payment $payment the payment instance\n     */\n    public function __construct(Payment $payment)\n    {\n        $this->payment = $payment;\n        for ($i = 1, $len = func_num_args(); $i < $len; $i++) {\n            $this->addFlag(func_get_arg($i));\n        }\n    }\n\n    /**\n     * @return Payment\n     */\n    public function getPayment()\n    {\n        return $this->payment;\n    }\n\n    /**\n     * Whether the response is marked as successful by Omnipay.\n     *\n     * @return bool\n     */\n    public function isSuccessful()\n    {\n        if ($this->omnipayResponse instanceof NotificationInterface) {\n            return $this->omnipayResponse->getTransactionStatus() === NotificationInterface::STATUS_COMPLETED;\n        } elseif ($this->omnipayResponse instanceof AbstractResponse) {\n            return $this->omnipayResponse->isSuccessful();\n        }\n\n        return false;\n    }\n\n    /**\n     * Whether or not this is an *offsite* redirect.\n     * This is only the case when there's an Omnipay response present that *is* a redirect.\n     *\n     * @return bool\n     */\n    public function isRedirect()\n    {\n        return ($this->omnipayResponse instanceof AbstractResponse) && $this->omnipayResponse->isRedirect();\n    }\n\n    /**\n     * Whether or not this response is an error-response.\n     *\n     * Attention: This doesn't necessarily correlate with the Omnipay response being successful or not\u2026\n     * A redirect is not successful in terms of completing a payment (response from omnipay isn't successful), yet the\n     * service completed successfully and shouldn't report an error here!\n     *\n     * @return boolean\n     */\n    public function isError()\n    {\n        return $this->hasFlag(self::SERVICE_ERROR);\n    }\n\n    /**\n     * Whether or not the request is pending and waiting for an async notification.\n     *\n     * @return bool\n     */\n    public function isAwaitingNotification()\n    {\n        return $this->hasFlag(self::SERVICE_PENDING);\n    }\n\n    /**\n     * Whether or not this is a response to a notification.\n     *\n     * @return bool\n     */\n    public function isNotification()\n    {\n        return $this->hasFlag(self::SERVICE_NOTIFICATION);\n    }\n\n    /**\n     * Whether or not the payment was cancelled.\n     *\n     * @return bool\n     */\n    public function isCancelled()\n    {\n        return $this->hasFlag(self::SERVICE_CANCELLED);\n    }\n\n    /**\n     * Check if the given flag(s) is set (active)\n     * @param int $flag the flag to check. Can be a combination of several flags (joined with binary OR)\n     * @return bool true if the given flag/s match\n     */\n    public function hasFlag($flag)\n    {\n        if (!is_int($flag)) {\n            throw new \\InvalidArgumentException('Flag must be of type int');\n        }\n        return ($this->flags & $flag) === $flag;\n    }\n\n    /**\n     * Add a flag for this response.\n     * Example: `$r->addFlag(ServiceResponse::SERVICE_PENDING)`\n     *\n     * @param int $flag\n     * @throws \\InvalidArgumentException if the parameter is not of type int\n     * @return $this\n     */\n    public function addFlag($flag)\n    {\n        if (!is_int($flag)) {\n            throw new \\InvalidArgumentException('Flag must be of type int');\n        }\n        $this->flags |= $flag;\n        return $this;\n    }\n\n    /**\n     * Remove a flag from this response.\n     * Example: `$r->removeFlag(ServiceResponse::SERVICE_PENDING)`\n     *\n     * @param int $flag\n     * @throws \\InvalidArgumentException if the parameter is not of type int\n     * @return $this\n     */\n    public function removeFlag($flag)\n    {\n        if (!is_int($flag)) {\n            throw new \\InvalidArgumentException('Flag must be of type int');\n        }\n        $this->flags &= ~$flag;\n        return $this;\n    }\n\n    /**\n     * The target url where this response should redirect to (this will be used to redirect internally, if\n     * the response wasn't set specifically)\n     * @return string\n     */\n    public function getTargetUrl()\n    {\n        return $this->targetUrl;\n    }\n\n    /**\n     * Set the target url.\n     * In the case of a redirect, the URL is given by the Omnipay response and should be considered immutable.\n     * When trying to set a targetUrl in this scenario, an Exception will be raised.\n     * @param string $value the new target url\n     * @return $this\n     * @throws ServiceException if trying to set a targetUrl for a redirect.\n     */\n    public function setTargetUrl($value)\n    {\n        if ($this->isRedirect()) {\n            throw new ServiceException('Unable to override target URL of redirect response');\n        }\n        $this->targetUrl = $value;\n        return $this;\n    }\n\n    /**\n     * Get the response given by the omnipay gateway.\n     * This can be an instance of AbstractResponse or NotificationInterface (in case of a notification)\n     * @return AbstractResponse|NotificationInterface|null\n     */\n    public function getOmnipayResponse()\n    {\n        return $this->omnipayResponse;\n    }\n\n    /**\n     * Set the response from Omnipay\n     * @param AbstractResponse|NotificationInterface $response the response or notification from the Omnipay gateway\n     * @return $this\n     */\n    public function setOmnipayResponse($response)\n    {\n        $this->omnipayResponse = $response;\n        // also set the target Url if the response is a redirect\n        if ($this->isRedirect()) {\n            $redirectResponse = $this->omnipayResponse->getRedirectResponse();\n            if ($redirectResponse instanceof \\Symfony\\Component\\HttpFoundation\\RedirectResponse) {\n                $this->targetUrl = $redirectResponse->getTargetUrl();\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Create a redirect or a response.\n     * This should be called when the application is ready to redirect!\n     *\n     * If the response is a redirect, the redirect takes precedence.\n     * Next, the HTTP response will be returned (if set) and lastly\n     * a redirect response to the  @see getTargetUrl.\n     *\n     * If none of these parameters are given, this method will return null\n     *\n     * @return HTTPResponse\n     */\n    public function redirectOrRespond()\n    {\n        if ($this->isRedirect()) {\n            $redirectResponse = $this->omnipayResponse->getRedirectResponse();\n            if ($redirectResponse instanceof \\Symfony\\Component\\HttpFoundation\\RedirectResponse) {\n                $this->targetUrl = $redirectResponse->getTargetUrl();\n\n                return Controller::curr()->redirect($this->targetUrl);\n            } else {\n                return new HTTPResponse((string)$redirectResponse->getContent(), 200);\n            }\n        }\n\n        if ($this->httpResponse) {\n            return $this->httpResponse;\n        }\n\n        if ($this->targetUrl) {\n            return Controller::curr()->redirect($this->targetUrl);\n        }\n\n        // return some default HTTP responses\n        return $this->isError()\n            ? new HTTPResponse(\"NOK\", 500)\n            : new HTTPResponse(\"OK\", 200);\n    }\n\n    /**\n     * Return the HTTP response given by this gateway.\n     * This could be a redirect, but might also be a response with content.\n     * @return HTTPResponse\n     */\n    public function getHttpResponse()\n    {\n        return $this->httpResponse;\n    }\n\n    /**\n     * Set the HTTP response.\n     *\n     * @param HTTPResponse $response the HTTP response. Can be used to return directly from a payment request\n     *\n     * @return $this\n     */\n    public function setHttpResponse(HTTPResponse $response)\n    {\n        $this->httpResponse = $response;\n        return $this;\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Omnipay\\Service;\n\nuse Omnipay\\Common\\Exception\\OmnipayException;\nuse SilverStripe\\Omnipay\\Exception\\InvalidConfigurationException;\nuse SilverStripe\\Omnipay\\Exception\\MissingParameterException;\nuse SilverStripe\\Omnipay\\GatewayInfo;\nuse SilverStripe\\Omnipay\\Helper\\ErrorHandling;\nuse SilverStripe\\Omnipay\\Model\\Message\\VoidedResponse;\nuse SilverStripe\\Omnipay\\Model\\Message\\VoidError;\nuse SilverStripe\\Omnipay\\Model\\Message\\VoidRequest;\n\nclass VoidService extends NotificationCompleteService\n{\n    protected $startState = 'Authorized';\n\n    protected $endState = 'Void';\n\n    protected $pendingState = 'PendingVoid';\n\n    protected $requestMessageType = VoidRequest::class;\n\n    protected $errorMessageType = VoidError::class;\n\n    /**\n     * Void/cancel a payment\n     *\n     * If the transaction-reference of the payment to capture is known, pass it via $data as\n     * `transactionReference` parameter. Otherwise the service will try to look up the reference\n     * from previous payment messages.\n     *\n     * If there's no transaction-reference to be found, this method will raise an exception.\n     *\n     * @inheritdoc\n     * @throws MissingParameterException if no transaction reference can be found from messages or parameters\n     */\n    public function initiate($data = array())\n    {\n        if (!$this->payment->canVoid()) {\n            throw new InvalidConfigurationException('Voiding of this payment not allowed.');\n        }\n\n        if (!$this->payment->isInDB()) {\n            $this->payment->write();\n        }\n\n        $reference = null;\n\n        // If the gateway isn't manual, we need a transaction reference to void a payment\n        if (!GatewayInfo::isManual($this->payment->Gateway)) {\n            if (!empty($data['transactionReference'])) {\n                $reference = $data['transactionReference'];\n            } elseif (!empty($data['receipt'])) { // legacy code?\n                $reference = $data['receipt'];\n            } else {\n                $reference = $this->payment->TransactionReference;\n            }\n\n            if (empty($reference)) {\n                throw new MissingParameterException('transactionReference not found and is not set as parameter');\n            }\n        }\n\n        $gateway = $this->oGateway();\n\n        if (!$gateway->supportsVoid()) {\n            throw new InvalidConfigurationException(\n                sprintf('The gateway \"%s\" doesn\\'t support void', $this->payment->Gateway)\n            );\n        }\n\n        $gatewayData = array_merge(\n            $data,\n            array(\n                'amount' => (float)$this->payment->MoneyAmount,\n                'currency' => $this->payment->MoneyCurrency,\n                'transactionReference' => $reference,\n                'notifyUrl' => $this->getEndpointUrl('notify')\n            )\n        );\n\n        $this->extend('onBeforeVoid', $gatewayData);\n        $request = $this->oGateway()->void($gatewayData);\n        $this->extend('onAfterVoid', $request);\n\n        $message = $this->createMessage($this->requestMessageType, $request);\n        $message->write();\n\n        try {\n            $response = $this->response = $request->send();\n        } catch (OmnipayException $e) {\n            $this->createMessage($this->errorMessageType, $e);\n\n            return $this->generateServiceResponse(ServiceResponse::SERVICE_ERROR);\n        }\n\n        ErrorHandling::safeExtend($this, 'onAfterSendVoid', $request, $response);\n\n        $serviceResponse = $this->wrapOmnipayResponse($response);\n\n        if ($serviceResponse->isError()) {\n            $this->createMessage($this->errorMessageType, $response);\n        } elseif ($serviceResponse->isRedirect() || $serviceResponse->isAwaitingNotification()) {\n            $this->payment->Status = $this->pendingState;\n            $this->payment->write();\n        } elseif ($serviceResponse->isSuccessful()) {\n            $this->markCompleted($this->endState, $serviceResponse, $response);\n        }\n\n        return $serviceResponse;\n    }\n\n    protected function markCompleted($endStatus, ServiceResponse $serviceResponse, $gatewayMessage)\n    {\n        parent::markCompleted($endStatus, $serviceResponse, $gatewayMessage);\n        $this->createMessage(VoidedResponse::class, $gatewayMessage);\n\n        ErrorHandling::safeExtend($this->payment, 'onVoid', $serviceResponse);\n    }\n}\n"], "buggy_code_start_loc": [4, 141, 5, 82, 8, 12, 100, 4], "buggy_code_end_loc": [130, 160, 135, 83, 138, 188, 100, 118], "fixing_code_start_loc": [5, 141, 6, 82, 8, 12, 101, 5], "fixing_code_end_loc": [126, 158, 137, 86, 140, 190, 117, 118], "type": "CWE-436", "message": "silverstripe-omnipay is a SilverStripe integration with Omnipay PHP payments library. For a subset of Omnipay gateways (those that use intermediary states like `isNotification()` or `isRedirect()`), if the payment identifier or success URL is exposed it is possible for payments to be prematurely marked as completed without payment being taken. This is mitigated by the fact that most payment gateways hide this information from users, however some issuing banks offer flawed 3DSecure implementations that may inadvertently expose this data. The following versions have been patched to fix this issue: `2.5.2`, `3.0.2`, `3.1.4`, and `3.2.1`. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2022-29254", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T07:15:06.913", "lastModified": "2022-06-17T16:26:30.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "silverstripe-omnipay is a SilverStripe integration with Omnipay PHP payments library. For a subset of Omnipay gateways (those that use intermediary states like `isNotification()` or `isRedirect()`), if the payment identifier or success URL is exposed it is possible for payments to be prematurely marked as completed without payment being taken. This is mitigated by the fact that most payment gateways hide this information from users, however some issuing banks offer flawed 3DSecure implementations that may inadvertently expose this data. The following versions have been patched to fix this issue: `2.5.2`, `3.0.2`, `3.1.4`, and `3.2.1`. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "silverstripe-omnipay es una integraci\u00f3n de SilverStripe con la biblioteca de pagos Omnipay PHP. Para un subconjunto de pasarelas Omnipay (aquellas que usan estados intermedios como \"isNotification()\" o \"isRedirect()\"), si el identificador de pago o la URL de \u00e9xito est\u00e1n expuestos es posible que los pagos sean marcados prematuramente como completados sin que el pago haya sido realizado. Esto es mitigado por el hecho de que la mayor\u00eda de las pasarelas de pago ocultan esta informaci\u00f3n a usuarios, sin embargo, algunos bancos emisores ofrecen implementaciones defectuosas de 3DSecure que pueden exponer inadvertidamente estos datos. Las siguientes versiones han sido parcheadas para corregir este problema: \"2.5.2\", \"3.0.2\", \"3.1.4\" y \"3.2.1\". No son conocidas mitigaciones para esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:silverstripe:silverstripe-omnipay:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.2", "matchCriteriaId": "799E2C05-64C5-4E09-AB8B-C3592B8B23D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:silverstripe:silverstripe-omnipay:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.2", "matchCriteriaId": "17D11AA0-3FBE-428B-B4E6-F7BF52F2C619"}, {"vulnerable": true, "criteria": "cpe:2.3:a:silverstripe:silverstripe-omnipay:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.1.4", "matchCriteriaId": "9AE46E4E-F81F-491C-88FC-46C557753BC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:silverstripe:silverstripe-omnipay:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.1", "matchCriteriaId": "BA3A91F2-1855-496B-B1EA-6DD865FB60A1"}]}]}], "references": [{"url": "https://github.com/silverstripe/silverstripe-omnipay/commit/7dee9a1e0a5f54c2dc06e018cff3d9a19044e01b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/silverstripe/silverstripe-omnipay/security/advisories/GHSA-48f2-m7jg-866x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/silverstripe/silverstripe-omnipay/commit/7dee9a1e0a5f54c2dc06e018cff3d9a19044e01b"}}