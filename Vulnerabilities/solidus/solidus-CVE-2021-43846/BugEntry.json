{"buggy_code": ["# frozen_string_literal: true\n\nmodule Spree\n  class OrdersController < Spree::StoreController\n    helper 'spree/products', 'spree/orders'\n\n    respond_to :html\n\n    before_action :store_guest_token\n    before_action :assign_order, only: :update\n    # note: do not lock the #edit action because that's where we redirect when we fail to acquire a lock\n    around_action :lock_order, only: :update\n    skip_before_action :verify_authenticity_token, only: [:populate]\n\n    def show\n      @order = Spree::Order.find_by!(number: params[:id])\n      authorize! :show, @order, cookies.signed[:guest_token]\n    end\n\n    def update\n      authorize! :update, @order, cookies.signed[:guest_token]\n      if @order.contents.update_cart(order_params)\n        @order.next if params.key?(:checkout) && @order.cart?\n\n        respond_with(@order) do |format|\n          format.html do\n            if params.key?(:checkout)\n              redirect_to checkout_state_path(@order.checkout_steps.first)\n            else\n              redirect_to cart_path\n            end\n          end\n        end\n      else\n        respond_with(@order)\n      end\n    end\n\n    # Shows the current incomplete order from the session\n    def edit\n      @order = current_order(build_order_if_necessary: true)\n      authorize! :edit, @order, cookies.signed[:guest_token]\n      associate_user\n      if params[:id] && @order.number != params[:id]\n        flash[:error] = t('spree.cannot_edit_orders')\n        redirect_to cart_path\n      end\n    end\n\n    # Adds a new item to the order (creating a new order if none already exists)\n    def populate\n      @order = current_order(create_order_if_necessary: true)\n      authorize! :update, @order, cookies.signed[:guest_token]\n\n      variant  = Spree::Variant.find(params[:variant_id])\n      quantity = params[:quantity].present? ? params[:quantity].to_i : 1\n\n      # 2,147,483,647 is crazy. See issue https://github.com/spree/spree/issues/2695.\n      if !quantity.between?(1, 2_147_483_647)\n        @order.errors.add(:base, t('spree.please_enter_reasonable_quantity'))\n      else\n        begin\n          @line_item = @order.contents.add(variant, quantity)\n        rescue ActiveRecord::RecordInvalid => error\n          @order.errors.add(:base, error.record.errors.full_messages.join(\", \"))\n        end\n      end\n\n      respond_with(@order) do |format|\n        format.html do\n          if @order.errors.any?\n            flash[:error] = @order.errors.full_messages.join(\", \")\n            redirect_back_or_default(spree.root_path)\n            return\n          else\n            redirect_to cart_path\n          end\n        end\n      end\n    end\n\n    def populate_redirect\n      flash[:error] = t('spree.populate_get_error')\n      redirect_to spree.cart_path\n    end\n\n    def empty\n      if @order = current_order\n        authorize! :update, @order, cookies.signed[:guest_token]\n        @order.empty!\n      end\n\n      redirect_to spree.cart_path\n    end\n\n    def accurate_title\n      if @order && @order.completed?\n        t('spree.order_number', number: @order.number)\n      else\n        t('spree.shopping_cart')\n      end\n    end\n\n    private\n\n    def store_guest_token\n      cookies.permanent.signed[:guest_token] = params[:token] if params[:token]\n    end\n\n    def order_params\n      if params[:order]\n        params[:order].permit(*permitted_order_attributes)\n      else\n        {}\n      end\n    end\n\n    def assign_order\n      @order = current_order\n      unless @order\n        flash[:error] = t('spree.order_not_found')\n        redirect_to(root_path) && return\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nmodule Spree\n  class OrdersController < Spree::StoreController\n    helper 'spree/products', 'spree/orders'\n\n    respond_to :html\n\n    before_action :store_guest_token\n    before_action :assign_order, only: :update\n    # note: do not lock the #edit action because that's where we redirect when we fail to acquire a lock\n    around_action :lock_order, only: :update\n\n    def show\n      @order = Spree::Order.find_by!(number: params[:id])\n      authorize! :show, @order, cookies.signed[:guest_token]\n    end\n\n    def update\n      authorize! :update, @order, cookies.signed[:guest_token]\n      if @order.contents.update_cart(order_params)\n        @order.next if params.key?(:checkout) && @order.cart?\n\n        respond_with(@order) do |format|\n          format.html do\n            if params.key?(:checkout)\n              redirect_to checkout_state_path(@order.checkout_steps.first)\n            else\n              redirect_to cart_path\n            end\n          end\n        end\n      else\n        respond_with(@order)\n      end\n    end\n\n    # Shows the current incomplete order from the session\n    def edit\n      @order = current_order(build_order_if_necessary: true)\n      authorize! :edit, @order, cookies.signed[:guest_token]\n      associate_user\n      if params[:id] && @order.number != params[:id]\n        flash[:error] = t('spree.cannot_edit_orders')\n        redirect_to cart_path\n      end\n    end\n\n    # Adds a new item to the order (creating a new order if none already exists)\n    def populate\n      @order = current_order(create_order_if_necessary: true)\n      authorize! :update, @order, cookies.signed[:guest_token]\n\n      variant  = Spree::Variant.find(params[:variant_id])\n      quantity = params[:quantity].present? ? params[:quantity].to_i : 1\n\n      # 2,147,483,647 is crazy. See issue https://github.com/spree/spree/issues/2695.\n      if !quantity.between?(1, 2_147_483_647)\n        @order.errors.add(:base, t('spree.please_enter_reasonable_quantity'))\n      else\n        begin\n          @line_item = @order.contents.add(variant, quantity)\n        rescue ActiveRecord::RecordInvalid => error\n          @order.errors.add(:base, error.record.errors.full_messages.join(\", \"))\n        end\n      end\n\n      respond_with(@order) do |format|\n        format.html do\n          if @order.errors.any?\n            flash[:error] = @order.errors.full_messages.join(\", \")\n            redirect_back_or_default(spree.root_path)\n            return\n          else\n            redirect_to cart_path\n          end\n        end\n      end\n    end\n\n    def populate_redirect\n      flash[:error] = t('spree.populate_get_error')\n      redirect_to spree.cart_path\n    end\n\n    def empty\n      if @order = current_order\n        authorize! :update, @order, cookies.signed[:guest_token]\n        @order.empty!\n      end\n\n      redirect_to spree.cart_path\n    end\n\n    def accurate_title\n      if @order && @order.completed?\n        t('spree.order_number', number: @order.number)\n      else\n        t('spree.shopping_cart')\n      end\n    end\n\n    private\n\n    def store_guest_token\n      cookies.permanent.signed[:guest_token] = params[:token] if params[:token]\n    end\n\n    def order_params\n      if params[:order]\n        params[:order].permit(*permitted_order_attributes)\n      else\n        {}\n      end\n    end\n\n    def assign_order\n      @order = current_order\n      unless @order\n        flash[:error] = t('spree.order_not_found')\n        redirect_to(root_path) && return\n      end\n    end\n  end\nend\n"], "buggy_code_start_loc": [13], "buggy_code_end_loc": [14], "fixing_code_start_loc": [12], "fixing_code_end_loc": [12], "type": "CWE-352", "message": "`solidus_frontend` is the cart and storefront for the Solidus e-commerce project. Versions of `solidus_frontend` prior to 3.1.5, 3.0.5, and 2.11.14 contain a cross-site request forgery (CSRF) vulnerability that allows a malicious site to add an item to the user's cart without their knowledge. Versions 3.1.5, 3.0.5, and 2.11.14 contain a patch for this issue. The patch adds CSRF token verification to the \"Add to cart\" action. Adding forgery protection to a form that missed it can have some side effects. Other CSRF protection strategies as well as a workaround involving modifcation to config/application.rb` are available. More details on these mitigations are available in the GitHub Security Advisory.", "other": {"cve": {"id": "CVE-2021-43846", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-20T22:15:07.947", "lastModified": "2021-12-29T18:26:19.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "`solidus_frontend` is the cart and storefront for the Solidus e-commerce project. Versions of `solidus_frontend` prior to 3.1.5, 3.0.5, and 2.11.14 contain a cross-site request forgery (CSRF) vulnerability that allows a malicious site to add an item to the user's cart without their knowledge. Versions 3.1.5, 3.0.5, and 2.11.14 contain a patch for this issue. The patch adds CSRF token verification to the \"Add to cart\" action. Adding forgery protection to a form that missed it can have some side effects. Other CSRF protection strategies as well as a workaround involving modifcation to config/application.rb` are available. More details on these mitigations are available in the GitHub Security Advisory."}, {"lang": "es", "value": "\"solidus_frontend\" es el carrito y el escaparate del proyecto de comercio electr\u00f3nico Solidus. Las versiones de \"solidus_frontend\" anteriores a 3.1.5, 3.0.5 y 2.11.14, contienen una vulnerabilidad de tipo cross-site request forgery (CSRF) que permite a un sitio malicioso a\u00f1adir un art\u00edculo al carrito del usuario sin su conocimiento. Las versiones 3.1.5, 3.0.5 y 2.11.14 contienen un parche para este problema. El parche a\u00f1ade la verificaci\u00f3n del token CSRF a la acci\u00f3n \"Add to cart\". A\u00f1adir protecci\u00f3n contra falsificaciones a un formulario que no la ten\u00eda puede tener algunos efectos secundarios. Est\u00e1n disponibles otras estrategias de protecci\u00f3n contra CSRF, as\u00ed como una soluci\u00f3n que implica la modificaci\u00f3n del archivo config/application.rb. M\u00e1s detalles sobre estas mitigaciones est\u00e1n disponibles en el aviso de seguridad de GitHub"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nebulab:solidus:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11.14", "matchCriteriaId": "BBFCB5C4-83E5-4AD7-8C52-92B863DD15B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nebulab:solidus:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.5", "matchCriteriaId": "B58D450A-ADBF-4E0F-9C11-B11752ADE39E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nebulab:solidus:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.1.5", "matchCriteriaId": "3A7D9C43-3C12-4B42-8DB2-FF18AD5BEF0E"}]}]}], "references": [{"url": "https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81"}}