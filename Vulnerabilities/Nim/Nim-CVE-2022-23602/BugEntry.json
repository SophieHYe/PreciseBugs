{"buggy_code": ["#\n#\n#           The Nim Compiler\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n# This is the documentation generator. Cross-references are generated\n# by knowing how the anchors are going to be named.\n\nimport\n  ast, strutils, strtabs, algorithm, sequtils, options, msgs, os, idents,\n  wordrecg, syntaxes, renderer, lexer,\n  packages/docutils/[rst, rstgen, dochelpers],\n  json, xmltree, trees, types,\n  typesrenderer, astalgo, lineinfos, intsets,\n  pathutils, tables, nimpaths, renderverbatim, osproc\nimport packages/docutils/rstast except FileIndex, TLineInfo\n\nfrom uri import encodeUrl\nfrom std/private/globs import nativeToUnixPath\nfrom nodejs import findNodeJs\n\nconst\n  exportSection = skField\n  docCmdSkip = \"skip\"\n  DocColOffset = \"## \".len  # assuming that a space was added after ##\n\ntype\n  ItemFragment = object  ## A fragment from each item will be eventually\n                         ## constructed by converting `rst` fields to strings.\n    case isRst: bool\n    of true:\n      rst: PRstNode\n    of false:            ## contains ready markup e.g. from runnableExamples\n      str: string\n  ItemPre = seq[ItemFragment]  ## A pre-processed item.\n  Item = object        ## Any item in documentation, e.g. symbol\n                       ## entry. Configuration variable ``doc.item``\n                       ## is used for its HTML rendering.\n    descRst: ItemPre     ## Description of the item (may contain\n                         ## runnableExamples).\n    substitutions: seq[string]    ## Variable names in `doc.item`...\n    sortName: string    ## The string used for sorting in output\n    info: rstast.TLineInfo  ## place where symbol was defined (for messages)\n    anchor: string  ## e.g. HTML anchor\n    name: string  ## short name of the symbol, not unique\n                  ## (includes backticks ` if present)\n    detailedName: string  ## longer name like `proc search(x: int): int`\n  ModSection = object  ## Section like Procs, Types, etc.\n    secItems: Table[string, seq[Item]]\n                         ## Map basic name -> pre-processed items.\n    finalMarkup: string  ## The items, after RST pass 2 and rendering.\n  ModSections = array[TSymKind, ModSection]\n  TocItem = object  ## HTML TOC item\n    content: string\n    sortName: string\n  TocSectionsFinal = array[TSymKind, string]\n  ExampleGroup = ref object\n    ## a group of runnableExamples with same rdoccmd\n    rdoccmd: string ## from 1st arg in `runnableExamples(rdoccmd): body`\n    docCmd: string ## from user config, e.g. --doccmd:-d:foo\n    code: string ## contains imports; each import contains `body`\n    index: int ## group index\n  JsonItem = object  # pre-processed item: `rst` should be finalized\n    json: JsonNode\n    rst: PRstNode\n    rstField: string\n  TDocumentor = object of rstgen.RstGenerator\n    modDescPre: ItemPre   # module description, not finalized\n    modDescFinal: string  # module description, after RST pass 2 and rendering\n    module: PSym\n    modDeprecationMsg: string\n    section: ModSections     # entries of ``.nim`` file (for `proc`s, etc)\n    tocSimple: array[TSymKind, seq[TocItem]]\n      # TOC entries for non-overloadable symbols (e.g. types, constants)...\n    tocTable:  array[TSymKind, Table[string, seq[TocItem]]]\n      # ...otherwise (e.g. procs)\n    toc2: TocSectionsFinal  # TOC `content`, which is probably wrapped\n                            # in `doc.section.toc2`\n    toc: TocSectionsFinal  # final TOC (wrapped in `doc.section.toc`)\n    indexValFilename: string\n    analytics: string  # Google Analytics javascript, \"\" if doesn't exist\n    seenSymbols: StringTableRef # avoids duplicate symbol generation for HTML.\n    jEntriesPre: seq[JsonItem] # pre-processed RST + JSON content\n    jEntriesFinal: JsonNode    # final JSON after RST pass 2 and rendering\n    types: TStrTable\n    sharedState: PRstSharedState\n    isPureRst: bool\n    conf*: ConfigRef\n    cache*: IdentCache\n    exampleCounter: int\n    emitted: IntSet # we need to track which symbols have been emitted\n                    # already. See bug #3655\n    thisDir*: AbsoluteDir\n    exampleGroups: OrderedTable[string, ExampleGroup]\n    wroteSupportFiles*: bool\n    nimToRstFid: Table[lineinfos.FileIndex, rstast.FileIndex]\n      ## map Nim FileIndex -> RST one, it's needed because we keep them separate\n\n  PDoc* = ref TDocumentor ## Alias to type less.\n\nproc add(dest: var ItemPre, rst: PRstNode) = dest.add ItemFragment(isRst: true, rst: rst)\nproc add(dest: var ItemPre, str: string) = dest.add ItemFragment(isRst: false, str: str)\n\nproc addRstFileIndex(d: PDoc, info: lineinfos.TLineInfo): rstast.FileIndex =\n  let invalid = rstast.FileIndex(-1)\n  result = d.nimToRstFid.getOrDefault(info.fileIndex, default = invalid)\n  if result == invalid:\n    let fname = toFullPath(d.conf, info)\n    result = addFilename(d.sharedState, fname)\n    d.nimToRstFid[info.fileIndex] = result\n\nproc cmpDecimalsIgnoreCase(a, b: string): int =\n  ## For sorting with correct handling of cases like 'uint8' and 'uint16'.\n  ## Also handles leading zeros well (however note that leading zeros are\n  ## significant when lengths of numbers mismatch, e.g. 'bar08' > 'bar8' !).\n  runnableExamples:\n    doAssert cmpDecimalsIgnoreCase(\"uint8\", \"uint16\") < 0\n    doAssert cmpDecimalsIgnoreCase(\"val00032\", \"val16suffix\") > 0\n    doAssert cmpDecimalsIgnoreCase(\"val16suffix\", \"val16\") > 0\n    doAssert cmpDecimalsIgnoreCase(\"val_08_32\", \"val_08_8\") > 0\n    doAssert cmpDecimalsIgnoreCase(\"val_07_32\", \"val_08_8\") < 0\n    doAssert cmpDecimalsIgnoreCase(\"ab8\", \"ab08\") < 0\n    doAssert cmpDecimalsIgnoreCase(\"ab8de\", \"ab08c\") < 0 # sanity check\n  let aLen = a.len\n  let bLen = b.len\n  var\n    iA = 0\n    iB = 0\n  while iA < aLen and iB < bLen:\n    if isDigit(a[iA]) and isDigit(b[iB]):\n      var\n        limitA = iA  # index after the last (least significant) digit\n        limitB = iB\n      while limitA < aLen and isDigit(a[limitA]): inc limitA\n      while limitB < bLen and isDigit(b[limitB]): inc limitB\n      var pos = max(limitA-iA, limitB-iA)\n      while pos > 0:\n        if limitA-pos < iA:  # digit in `a` is 0 effectively\n          result = ord('0') - ord(b[limitB-pos])\n        elif limitB-pos < iB:  # digit in `b` is 0 effectively\n          result = ord(a[limitA-pos]) - ord('0')\n        else:\n          result = ord(a[limitA-pos]) - ord(b[limitB-pos])\n        if result != 0: return\n        dec pos\n      result = (limitA - iA) - (limitB - iB)  # consider 'bar08' > 'bar8'\n      if result != 0: return\n      iA = limitA\n      iB = limitB\n    else:\n      result = ord(toLowerAscii(a[iA])) - ord(toLowerAscii(b[iB]))\n      if result != 0: return\n      inc iA\n      inc iB\n  result = (aLen - iA) - (bLen - iB)\n\nproc prettyString(a: object): string =\n  # xxx pending std/prettyprint refs https://github.com/nim-lang/RFCs/issues/203#issuecomment-602534906\n  for k, v in fieldPairs(a):\n    result.add k & \": \" & $v & \"\\n\"\n\nproc presentationPath*(conf: ConfigRef, file: AbsoluteFile): RelativeFile =\n  ## returns a relative file that will be appended to outDir\n  let file2 = $file\n  template bail() =\n    result = relativeTo(file, conf.projectPath)\n  proc nimbleDir(): AbsoluteDir =\n    getNimbleFile(conf, file2).parentDir.AbsoluteDir\n  case conf.docRoot:\n  of docRootDefault:\n    result = getRelativePathFromConfigPath(conf, file)\n    let dir = nimbleDir()\n    if not dir.isEmpty:\n      let result2 = relativeTo(file, dir)\n      if not result2.isEmpty and (result.isEmpty or result2.string.len < result.string.len):\n        result = result2\n    if result.isEmpty: bail()\n  of \"@pkg\":\n    let dir = nimbleDir()\n    if dir.isEmpty: bail()\n    else: result = relativeTo(file, dir)\n  of \"@path\":\n    result = getRelativePathFromConfigPath(conf, file)\n    if result.isEmpty: bail()\n  elif conf.docRoot.len > 0:\n    # we're (currently) requiring `isAbsolute` to avoid confusion when passing\n    # a relative path (would it be relative with regard to $PWD or to projectfile)\n    conf.globalAssert conf.docRoot.isAbsolute, arg=conf.docRoot\n    conf.globalAssert conf.docRoot.dirExists, arg=conf.docRoot\n    # needed because `canonicalizePath` called on `file`\n    result = file.relativeTo conf.docRoot.expandFilename.AbsoluteDir\n  else:\n    bail()\n  if isAbsolute(result.string):\n    result = file.string.splitPath()[1].RelativeFile\n  result = result.string.replace(\"..\", dotdotMangle).RelativeFile\n  doAssert not result.isEmpty\n  doAssert not isAbsolute(result.string)\n\nproc whichType(d: PDoc; n: PNode): PSym =\n  if n.kind == nkSym:\n    if d.types.strTableContains(n.sym):\n      result = n.sym\n  else:\n    for i in 0..<n.safeLen:\n      let x = whichType(d, n[i])\n      if x != nil: return x\n\nproc attachToType(d: PDoc; p: PSym): PSym =\n  let params = p.ast[paramsPos]\n  template check(i) =\n    result = whichType(d, params[i])\n    if result != nil: return result\n\n  # first check the first parameter, then the return type,\n  # then the other parameter:\n  if params.len > 1: check(1)\n  if params.len > 0: check(0)\n  for i in 2..<params.len: check(i)\n\ntemplate declareClosures =\n  proc compilerMsgHandler(filename: string, line, col: int,\n                          msgKind: rst.MsgKind, arg: string) {.gcsafe.} =\n    # translate msg kind:\n    var k: TMsgKind\n    case msgKind\n    of meCannotOpenFile: k = errCannotOpenFile\n    of meExpected: k = errXExpected\n    of meGridTableNotImplemented: k = errRstGridTableNotImplemented\n    of meMarkdownIllformedTable: k = errRstMarkdownIllformedTable\n    of meNewSectionExpected: k = errRstNewSectionExpected\n    of meGeneralParseError: k = errRstGeneralParseError\n    of meInvalidDirective: k = errRstInvalidDirectiveX\n    of meInvalidField: k = errRstInvalidField\n    of meFootnoteMismatch: k = errRstFootnoteMismatch\n    of mwRedefinitionOfLabel: k = warnRstRedefinitionOfLabel\n    of mwUnknownSubstitution: k = warnRstUnknownSubstitutionX\n    of mwAmbiguousLink: k = warnRstAmbiguousLink\n    of mwBrokenLink: k = warnRstBrokenLink\n    of mwUnsupportedLanguage: k = warnRstLanguageXNotSupported\n    of mwUnsupportedField: k = warnRstFieldXNotSupported\n    of mwRstStyle: k = warnRstStyle\n    {.gcsafe.}:\n      globalError(conf, newLineInfo(conf, AbsoluteFile filename, line, col), k, arg)\n\n  proc docgenFindFile(s: string): string {.gcsafe.} =\n    result = options.findFile(conf, s).string\n    if result.len == 0:\n      result = getCurrentDir() / s\n      if not fileExists(result): result = \"\"\n\nproc parseRst(text: string,\n              line, column: int,\n              conf: ConfigRef, sharedState: PRstSharedState): PRstNode =\n  declareClosures()\n  result = rstParsePass1(text, line, column, sharedState)\n\nproc getOutFile2(conf: ConfigRef; filename: RelativeFile,\n                 ext: string, guessTarget: bool): AbsoluteFile =\n  if optWholeProject in conf.globalOptions or guessTarget:\n    let d = conf.outDir\n    createDir(d)\n    result = d / changeFileExt(filename, ext)\n  elif not conf.outFile.isEmpty:\n    result = absOutFile(conf)\n  else:\n    result = getOutFile(conf, filename, ext)\n\nproc isLatexCmd(conf: ConfigRef): bool = conf.cmd in {cmdRst2tex, cmdDoc2tex}\n\nproc newDocumentor*(filename: AbsoluteFile; cache: IdentCache; conf: ConfigRef,\n                    outExt: string = HtmlExt, module: PSym = nil,\n                    isPureRst = false): PDoc =\n  declareClosures()\n  new(result)\n  result.module = module\n  result.conf = conf\n  result.cache = cache\n  result.outDir = conf.outDir.string\n  result.isPureRst = isPureRst\n  var options= {roSupportRawDirective, roSupportMarkdown, roPreferMarkdown}\n  if not isPureRst: options.incl roNimFile\n  result.sharedState = newRstSharedState(\n      options, filename.string,\n      docgenFindFile, compilerMsgHandler)\n  initRstGenerator(result[], (if conf.isLatexCmd: outLatex else: outHtml),\n                   conf.configVars, filename.string,\n                   docgenFindFile, compilerMsgHandler)\n\n  if conf.configVars.hasKey(\"doc.googleAnalytics\"):\n    result.analytics = \"\"\"\n<script>\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n  ga('create', '$1', 'auto');\n  ga('send', 'pageview');\n\n</script>\n    \"\"\" % [conf.configVars.getOrDefault\"doc.googleAnalytics\"]\n  else:\n    result.analytics = \"\"\n\n  result.seenSymbols = newStringTable(modeCaseInsensitive)\n  result.id = 100\n  result.jEntriesFinal = newJArray()\n  initStrTable result.types\n  result.onTestSnippet =\n    proc (gen: var RstGenerator; filename, cmd: string; status: int; content: string) =\n      if conf.docCmd == docCmdSkip: return\n      inc(gen.id)\n      var d = (ptr TDocumentor)(addr gen)\n      var outp: AbsoluteFile\n      if filename.len == 0:\n        let nameOnly = splitFile(d.filename).name\n        # \"snippets\" needed, refs bug #17183\n        outp = getNimcacheDir(conf) / \"snippets\".RelativeDir / RelativeDir(nameOnly) /\n               RelativeFile(nameOnly & \"_snippet_\" & $d.id & \".nim\")\n      elif isAbsolute(filename):\n        outp = AbsoluteFile(filename)\n      else:\n        # Nim's convention: every path is relative to the file it was written in:\n        let nameOnly = splitFile(d.filename).name\n        outp = AbsoluteDir(nameOnly) / RelativeFile(filename)\n      # Make sure the destination directory exists\n      createDir(outp.splitFile.dir)\n      # Include the current file if we're parsing a nim file\n      let importStmt = if d.isPureRst: \"\" else: \"import \\\"$1\\\"\\n\" % [d.filename.replace(\"\\\\\", \"/\")]\n      writeFile(outp, importStmt & content)\n\n      proc interpSnippetCmd(cmd: string): string =\n        # backward compatibility hacks; interpolation commands should explicitly use `$`\n        if cmd.startsWith \"nim \": result = \"$nim \" & cmd[4..^1]\n        else: result = cmd\n        # factor with D20210224T221756\n        result = result.replace(\"$1\", \"$options\") % [\n          \"nim\", os.getAppFilename().quoteShell,\n          \"libpath\", quoteShell(d.conf.libpath),\n          \"docCmd\", d.conf.docCmd,\n          \"backend\", $d.conf.backend,\n          \"options\", outp.quoteShell,\n            # xxx `quoteShell` seems buggy if user passes options = \"-d:foo somefile.nim\"\n        ]\n      let cmd = cmd.interpSnippetCmd\n      rawMessage(conf, hintExecuting, cmd)\n      let (output, gotten) = execCmdEx(cmd)\n      if gotten != status:\n        rawMessage(conf, errGenerated, \"snippet failed: cmd: '$1' status: $2 expected: $3 output: $4\" % [cmd, $gotten, $status, output])\n  result.emitted = initIntSet()\n  result.destFile = getOutFile2(conf, presentationPath(conf, filename), outExt, false).string\n  result.thisDir = result.destFile.AbsoluteFile.splitFile.dir\n\ntemplate dispA(conf: ConfigRef; dest: var string, xml, tex: string,\n               args: openArray[string]) =\n  if not conf.isLatexCmd: dest.addf(xml, args)\n  else: dest.addf(tex, args)\n\nproc getVarIdx(varnames: openArray[string], id: string): int =\n  for i in 0..high(varnames):\n    if cmpIgnoreStyle(varnames[i], id) == 0:\n      return i\n  result = -1\n\nproc genComment(d: PDoc, n: PNode): PRstNode =\n  if n.comment.len > 0:\n    d.sharedState.currFileIdx = addRstFileIndex(d, n.info)\n    result = parseRst(n.comment,\n                      toLinenumber(n.info),\n                      toColumn(n.info) + DocColOffset,\n                      d.conf, d.sharedState)\n\nproc genRecCommentAux(d: PDoc, n: PNode): PRstNode =\n  if n == nil: return nil\n  result = genComment(d, n)\n  if result == nil:\n    if n.kind in {nkStmtList, nkStmtListExpr, nkTypeDef, nkConstDef,\n                  nkObjectTy, nkRefTy, nkPtrTy, nkAsgn, nkFastAsgn, nkHiddenStdConv}:\n      # notin {nkEmpty..nkNilLit, nkEnumTy, nkTupleTy}:\n      for i in 0..<n.len:\n        result = genRecCommentAux(d, n[i])\n        if result != nil: return\n  else:\n    n.comment = \"\"\n\nproc genRecComment(d: PDoc, n: PNode): PRstNode =\n  if n == nil: return nil\n  result = genComment(d, n)\n  if result == nil:\n    if n.kind in {nkProcDef, nkFuncDef, nkMethodDef, nkIteratorDef,\n                  nkMacroDef, nkTemplateDef, nkConverterDef}:\n      result = genRecCommentAux(d, n[bodyPos])\n    else:\n      result = genRecCommentAux(d, n)\n\nproc getPlainDocstring(n: PNode): string =\n  ## Gets the plain text docstring of a node non destructively.\n  ##\n  ## You need to call this before genRecComment, whose side effects are removal\n  ## of comments from the tree. The proc will recursively scan and return all\n  ## the concatenated ``##`` comments of the node.\n  if n == nil: result = \"\"\n  elif startsWith(n.comment, \"##\"):\n    result = n.comment\n  else:\n    for i in 0..<n.safeLen:\n      result = getPlainDocstring(n[i])\n      if result.len > 0: return\n\nproc belongsToPackage(conf: ConfigRef; module: PSym): bool =\n  result = module.kind == skModule and module.getnimblePkgId == conf.mainPackageId\n\nproc externalDep(d: PDoc; module: PSym): string =\n  if optWholeProject in d.conf.globalOptions or d.conf.docRoot.len > 0:\n    let full = AbsoluteFile toFullPath(d.conf, FileIndex module.position)\n    let tmp = getOutFile2(d.conf, presentationPath(d.conf, full), HtmlExt, sfMainModule notin module.flags)\n    result = relativeTo(tmp, d.thisDir, '/').string\n  else:\n    result = extractFilename toFullPath(d.conf, FileIndex module.position)\n\nproc nodeToHighlightedHtml(d: PDoc; n: PNode; result: var string;\n                           renderFlags: TRenderFlags = {};\n                           procLink: string) =\n  var r: TSrcGen\n  var literal = \"\"\n  initTokRender(r, n, renderFlags)\n  var kind = tkEof\n  var tokenPos = 0\n  var procTokenPos = 0\n  template escLit(): untyped = esc(d.target, literal)\n  while true:\n    getNextTok(r, kind, literal)\n    inc tokenPos\n    case kind\n    of tkEof:\n      break\n    of tkComment:\n      dispA(d.conf, result, \"<span class=\\\"Comment\\\">$1</span>\", \"\\\\spanComment{$1}\",\n            [escLit])\n    of tokKeywordLow..tokKeywordHigh:\n      if kind in {tkProc, tkMethod, tkIterator, tkMacro, tkTemplate, tkFunc, tkConverter}:\n        procTokenPos = tokenPos\n      dispA(d.conf, result, \"<span class=\\\"Keyword\\\">$1</span>\", \"\\\\spanKeyword{$1}\",\n            [literal])\n    of tkOpr:\n      dispA(d.conf, result, \"<span class=\\\"Operator\\\">$1</span>\", \"\\\\spanOperator{$1}\",\n            [escLit])\n    of tkStrLit..tkTripleStrLit, tkCustomLit:\n      dispA(d.conf, result, \"<span class=\\\"StringLit\\\">$1</span>\",\n            \"\\\\spanStringLit{$1}\", [escLit])\n    of tkCharLit:\n      dispA(d.conf, result, \"<span class=\\\"CharLit\\\">$1</span>\", \"\\\\spanCharLit{$1}\",\n            [escLit])\n    of tkIntLit..tkUInt64Lit:\n      dispA(d.conf, result, \"<span class=\\\"DecNumber\\\">$1</span>\",\n            \"\\\\spanDecNumber{$1}\", [escLit])\n    of tkFloatLit..tkFloat128Lit:\n      dispA(d.conf, result, \"<span class=\\\"FloatNumber\\\">$1</span>\",\n            \"\\\\spanFloatNumber{$1}\", [escLit])\n    of tkSymbol:\n      let s = getTokSym(r)\n      # -2 because of the whitespace in between:\n      if procTokenPos == tokenPos-2 and procLink != \"\":\n        dispA(d.conf, result, \"<a href=\\\"#$2\\\"><span class=\\\"Identifier\\\">$1</span></a>\",\n              \"\\\\spanIdentifier{$1}\", [escLit, procLink])\n      elif s != nil and s.kind in {skType, skVar, skLet, skConst} and\n           sfExported in s.flags and s.owner != nil and\n           belongsToPackage(d.conf, s.owner) and d.target == outHtml:\n        let external = externalDep(d, s.owner)\n        result.addf \"<a href=\\\"$1#$2\\\"><span class=\\\"Identifier\\\">$3</span></a>\",\n          [changeFileExt(external, \"html\"), literal,\n           escLit]\n      else:\n        dispA(d.conf, result, \"<span class=\\\"Identifier\\\">$1</span>\",\n              \"\\\\spanIdentifier{$1}\", [escLit])\n    of tkSpaces, tkInvalid:\n      result.add(literal)\n    of tkHideableStart:\n      template fun(s) = dispA(d.conf, result, s, \"\\\\spanOther{$1}\", [escLit])\n      if renderRunnableExamples in renderFlags: fun \"$1\"\n      else:\n        # 1st span is required for the JS to work properly\n        fun \"\"\"\n<span>\n<span class=\"Other pragmadots\">...</span>\n</span>\n<span class=\"pragmawrap\">\"\"\".replace(\"\\n\", \"\")  # Must remove newlines because wrapped in a <pre>\n    of tkHideableEnd:\n      template fun(s) = dispA(d.conf, result, s, \"\\\\spanOther{$1}\", [escLit])\n      if renderRunnableExamples in renderFlags: fun \"$1\"\n      else: fun \"</span>\"\n    of tkCurlyDotLe: dispA(d.conf, result, \"$1\", \"\\\\spanOther{$1}\", [escLit])\n    of tkCurlyDotRi: dispA(d.conf, result, \"$1\", \"\\\\spanOther{$1}\", [escLit])\n    of tkParLe, tkParRi, tkBracketLe, tkBracketRi, tkCurlyLe, tkCurlyRi,\n       tkBracketDotLe, tkBracketDotRi, tkParDotLe,\n       tkParDotRi, tkComma, tkSemiColon, tkColon, tkEquals, tkDot, tkDotDot,\n       tkAccent, tkColonColon,\n       tkGStrLit, tkGTripleStrLit, tkInfixOpr, tkPrefixOpr, tkPostfixOpr,\n       tkBracketLeColon:\n      dispA(d.conf, result, \"<span class=\\\"Other\\\">$1</span>\", \"\\\\spanOther{$1}\",\n            [escLit])\n\nproc exampleOutputDir(d: PDoc): AbsoluteDir = d.conf.getNimcacheDir / RelativeDir\"runnableExamples\"\n\nproc runAllExamples(d: PDoc) =\n  # This used to be: `let backend = if isDefined(d.conf, \"js\"): \"js\"` (etc), however\n  # using `-d:js` (etc) cannot work properly, e.g. would fail with `importjs`\n  # since semantics are affected by `config.backend`, not by isDefined(d.conf, \"js\")\n  let outputDir = d.exampleOutputDir\n  for _, group in d.exampleGroups:\n    if group.docCmd == docCmdSkip: continue\n    let outp = outputDir / RelativeFile(\"$1_group$2_examples.nim\" % [d.filename.splitFile.name, $group.index])\n    group.code = \"# autogenerated by docgen\\n# source: $1\\n# rdoccmd: $2\\n$3\" % [d.filename, group.rdoccmd, group.code]\n    writeFile(outp, group.code)\n    # most useful semantics is that `docCmd` comes after `rdoccmd`, so that we can (temporarily) override\n    # via command line\n    # D20210224T221756:here\n    let cmd = \"$nim $backend -r --lib:$libpath --warning:UnusedImport:off --path:$path --nimcache:$nimcache $rdoccmd $docCmd $file\" % [\n      \"nim\", quoteShell(os.getAppFilename()),\n      \"backend\", $d.conf.backend,\n      \"path\", quoteShell(d.conf.projectPath),\n      \"libpath\", quoteShell(d.conf.libpath),\n      \"nimcache\", quoteShell(outputDir),\n      \"file\", quoteShell(outp),\n      \"rdoccmd\", group.rdoccmd,\n      \"docCmd\", group.docCmd,\n    ]\n    if d.conf.backend == backendJs and findNodeJs() == \"\":\n      discard \"ignore JS runnableExample\"\n    elif os.execShellCmd(cmd) != 0:\n      d.conf.quitOrRaise \"[runnableExamples] failed: generated file: '$1' group: '$2' cmd: $3\" % [outp.string, group[].prettyString, cmd]\n    else:\n      # keep generated source file `outp` to allow inspection.\n      rawMessage(d.conf, hintSuccess, [\"runnableExamples: \" & outp.string])\n      # removeFile(outp.changeFileExt(ExeExt)) # it's in nimcache, no need to remove\n\nproc quoted(a: string): string = result.addQuoted(a)\n\nproc toInstantiationInfo(conf: ConfigRef, info: TLineInfo): auto =\n  # xxx expose in compiler/lineinfos.nim\n  (conf.toMsgFilename(info), info.line.int, info.col.int + ColOffset)\n\nproc prepareExample(d: PDoc; n: PNode, topLevel: bool): tuple[rdoccmd: string, code: string] =\n  ## returns `rdoccmd` and source code for this runnableExamples\n  var rdoccmd = \"\"\n  if n.len < 2 or n.len > 3: globalError(d.conf, n.info, \"runnableExamples invalid\")\n  if n.len == 3:\n    let n1 = n[1]\n    # xxx this should be evaluated during sempass\n    if n1.kind notin nkStrKinds: globalError(d.conf, n1.info, \"string litteral expected\")\n    rdoccmd = n1.strVal\n\n  let useRenderModule = false\n  let loc = d.conf.toFileLineCol(n.info)\n  let code = extractRunnableExamplesSource(d.conf, n)\n  let codeIndent = extractRunnableExamplesSource(d.conf, n, indent = 2)\n\n  if d.conf.errorCounter > 0:\n    return (rdoccmd, code)\n\n  let comment = \"autogenerated by docgen\\nloc: $1\\nrdoccmd: $2\" % [loc, rdoccmd]\n  let outputDir = d.exampleOutputDir\n  createDir(outputDir)\n  inc d.exampleCounter\n  let outp = outputDir / RelativeFile(\"$#_examples_$#.nim\" % [d.filename.extractFilename.changeFileExt\"\", $d.exampleCounter])\n\n  if useRenderModule:\n    var docComment = newTree(nkCommentStmt)\n    docComment.comment = comment\n    var runnableExamples = newTree(nkStmtList,\n        docComment,\n        newTree(nkImportStmt, newStrNode(nkStrLit, d.filename)))\n    runnableExamples.info = n.info\n    for a in n.lastSon: runnableExamples.add a\n\n    # buggy, refs bug #17292\n    # still worth fixing as it can affect other code relying on `renderModule`,\n    # so we keep this code path here for now, which could still be useful in some\n    # other situations.\n    renderModule(runnableExamples, outp.string, conf = d.conf)\n\n  else:\n    var code2 = code\n    if code.len > 0 and \"codeReordering\" notin code:\n      # hacky but simplest solution, until we devise a way to make `{.line.}`\n      # work without introducing a scope\n      code2 = \"\"\"\n{.line: $#.}:\n$#\n\"\"\" % [$toInstantiationInfo(d.conf, n.info), codeIndent]\n    code2 = \"\"\"\n#[\n$#\n]#\nimport $#\n$#\n\"\"\" % [comment, d.filename.quoted, code2]\n    writeFile(outp.string, code2)\n\n  if rdoccmd notin d.exampleGroups:\n    d.exampleGroups[rdoccmd] = ExampleGroup(rdoccmd: rdoccmd, docCmd: d.conf.docCmd, index: d.exampleGroups.len)\n  d.exampleGroups[rdoccmd].code.add \"import $1\\n\" % outp.string.quoted\n\n  var codeShown: string\n  if topLevel: # refs https://github.com/nim-lang/RFCs/issues/352\n    let title = canonicalImport(d.conf, AbsoluteFile d.filename)\n    codeShown = \"import $#\\n$#\" % [title, code]\n  else:\n    codeShown = code\n  result = (rdoccmd, codeShown)\n  when false:\n    proc extractImports(n: PNode; result: PNode) =\n      if n.kind in {nkImportStmt, nkImportExceptStmt, nkFromStmt}:\n        result.add copyTree(n)\n        n.kind = nkEmpty\n        return\n      for i in 0..<n.safeLen: extractImports(n[i], result)\n    let imports = newTree(nkStmtList)\n    var savedLastSon = copyTree n.lastSon\n    extractImports(savedLastSon, imports)\n    for imp in imports: runnableExamples.add imp\n    runnableExamples.add newTree(nkBlockStmt, newNode(nkEmpty), copyTree savedLastSon)\n\ntype RunnableState = enum\n  rsStart\n  rsComment\n  rsRunnable\n  rsDone\n\nproc getAllRunnableExamplesImpl(d: PDoc; n: PNode, dest: var ItemPre,\n                                state: RunnableState, topLevel: bool):\n                               RunnableState =\n  ##[\n  Simple state machine to tell whether we render runnableExamples and doc comments.\n  This is to ensure that we can interleave runnableExamples and doc comments freely;\n  the logic is easy to change but currently a doc comment following another doc comment\n  will not render, to avoid rendering in following case:\n\n  proc fn* =\n    runnableExamples: discard\n    ## d1\n    runnableExamples: discard\n    ## d2\n\n    ## internal explanation  # <- this one should be out; it's part of rest of function body and would likey not make sense in doc comment\n    discard # some code\n  ]##\n\n  case n.kind\n  of nkCommentStmt:\n    if state in {rsStart, rsRunnable}:\n      dest.add genRecComment(d, n)\n      return rsComment\n  of nkCallKinds:\n    if isRunnableExamples(n[0]) and\n        n.len >= 2 and n.lastSon.kind == nkStmtList:\n      if state in {rsStart, rsComment, rsRunnable}:\n        let (rdoccmd, code) = prepareExample(d, n, topLevel)\n        var msg = \"Example:\"\n        if rdoccmd.len > 0: msg.add \" cmd: \" & rdoccmd\n        var s: string\n        dispA(d.conf, s, \"\\n<p><strong class=\\\"examples_text\\\">$1</strong></p>\\n\",\n            \"\\n\\n\\\\textbf{$1}\\n\", [msg])\n        dest.add s\n        inc d.listingCounter\n        let id = $d.listingCounter\n        dest.add(d.config.getOrDefault\"doc.listing_start\" % [id, \"langNim\", \"\"])\n        var dest2 = \"\"\n        renderNimCode(dest2, code, d.target)\n        dest.add dest2\n        dest.add(d.config.getOrDefault\"doc.listing_end\" % id)\n        return rsRunnable\n      else:\n        localError(d.conf, n.info, errUser, \"runnableExamples must appear before the first non-comment statement\")\n  else: discard\n  return rsDone\n    # change this to `rsStart` if you want to keep generating doc comments\n    # and runnableExamples that occur after some code in routine\n\nproc getRoutineBody(n: PNode): PNode =\n  ##[\n  nim transforms these quite differently:\n\n  proc someType*(): int =\n    ## foo\n    result = 3\n=>\n  result =\n    ## foo\n    3;\n\n  proc someType*(): int =\n    ## foo\n    3\n=>\n  ## foo\n  result = 3;\n\n  so we normalize the results to get to the statement list containing the\n  (0 or more) doc comments and runnableExamples.\n  ]##\n  result = n[bodyPos]\n\n  # This won't be transformed: result.id = 10. Namely result[0].kind != nkSym.\n  if result.kind == nkAsgn and result[0].kind == nkSym and\n                               n.len > bodyPos+1 and n[bodyPos+1].kind == nkSym:\n    doAssert result.len == 2\n    result = result[1]\n\nproc getAllRunnableExamples(d: PDoc, n: PNode, dest: var ItemPre) =\n  var n = n\n  var state = rsStart\n  template fn(n2, topLevel) =\n    state = getAllRunnableExamplesImpl(d, n2, dest, state, topLevel)\n  dest.add genComment(d, n)\n  case n.kind\n  of routineDefs:\n    n = n.getRoutineBody\n    case n.kind\n    of nkCommentStmt, nkCallKinds: fn(n, topLevel = false)\n    else:\n      for i in 0..<n.safeLen:\n        fn(n[i], topLevel = false)\n        if state == rsDone: discard # check all sons\n  else: fn(n, topLevel = true)\n\nproc isVisible(d: PDoc; n: PNode): bool =\n  result = false\n  if n.kind == nkPostfix:\n    if n.len == 2 and n[0].kind == nkIdent:\n      var v = n[0].ident\n      result = v.id == ord(wStar) or v.id == ord(wMinus)\n  elif n.kind == nkSym:\n    # we cannot generate code for forwarded symbols here as we have no\n    # exception tracking information here. Instead we copy over the comment\n    # from the proc header.\n    if optDocInternal in d.conf.globalOptions:\n      result = {sfFromGeneric, sfForward}*n.sym.flags == {}\n    else:\n      result = {sfExported, sfFromGeneric, sfForward}*n.sym.flags == {sfExported}\n    if result and containsOrIncl(d.emitted, n.sym.id):\n      result = false\n  elif n.kind == nkPragmaExpr:\n    result = isVisible(d, n[0])\n\nproc getName(d: PDoc, n: PNode, splitAfter = -1): string =\n  case n.kind\n  of nkPostfix: result = getName(d, n[1], splitAfter)\n  of nkPragmaExpr: result = getName(d, n[0], splitAfter)\n  of nkSym: result = esc(d.target, n.sym.renderDefinitionName, splitAfter)\n  of nkIdent: result = esc(d.target, n.ident.s, splitAfter)\n  of nkAccQuoted:\n    result = esc(d.target, \"`\")\n    for i in 0..<n.len: result.add(getName(d, n[i], splitAfter))\n    result.add esc(d.target, \"`\")\n  of nkOpenSymChoice, nkClosedSymChoice:\n    result = getName(d, n[0], splitAfter)\n  else:\n    result = \"\"\n\nproc getNameIdent(cache: IdentCache; n: PNode): PIdent =\n  case n.kind\n  of nkPostfix: result = getNameIdent(cache, n[1])\n  of nkPragmaExpr: result = getNameIdent(cache, n[0])\n  of nkSym: result = n.sym.name\n  of nkIdent: result = n.ident\n  of nkAccQuoted:\n    var r = \"\"\n    for i in 0..<n.len: r.add(getNameIdent(cache, n[i]).s)\n    result = getIdent(cache, r)\n  of nkOpenSymChoice, nkClosedSymChoice:\n    result = getNameIdent(cache, n[0])\n  else:\n    result = nil\n\nproc getRstName(n: PNode): PRstNode =\n  case n.kind\n  of nkPostfix: result = getRstName(n[1])\n  of nkPragmaExpr: result = getRstName(n[0])\n  of nkSym: result = newRstLeaf(n.sym.renderDefinitionName)\n  of nkIdent: result = newRstLeaf(n.ident.s)\n  of nkAccQuoted:\n    result = getRstName(n[0])\n    for i in 1..<n.len: result.text.add(getRstName(n[i]).text)\n  of nkOpenSymChoice, nkClosedSymChoice:\n    result = getRstName(n[0])\n  else:\n    result = nil\n\nproc newUniquePlainSymbol(d: PDoc, original: string): string =\n  ## Returns a new unique plain symbol made up from the original.\n  ##\n  ## When a collision is found in the seenSymbols table, new numerical variants\n  ## with underscore + number will be generated.\n  if not d.seenSymbols.hasKey(original):\n    result = original\n    d.seenSymbols[original] = \"\"\n    return\n  # Iterate over possible numeric variants of the original name.\n  var count = 2\n  while true:\n    result = original & \"_\" & $count\n    if not d.seenSymbols.hasKey(result):\n      d.seenSymbols[result] = \"\"\n      break\n    count += 1\n\nproc complexName(k: TSymKind, n: PNode, baseName: string): string =\n  ## Builds a complex unique href name for the node.\n  ##\n  ## Pass as ``baseName`` the plain symbol obtained from the nodeName. The\n  ## format of the returned symbol will be ``baseName(.callable type)?,(param\n  ## type)?(,param type)*``. The callable type part will be added only if the\n  ## node is not a proc, as those are the common ones. The suffix will be a dot\n  ## and a single letter representing the type of the callable. The parameter\n  ## types will be added with a preceding dash. Return types won't be added.\n  ##\n  ## If you modify the output of this proc, please update the anchor generation\n  ## section of ``doc/docgen.rst``.\n  result = baseName\n  case k\n  of skProc, skFunc: discard\n  of skMacro: result.add(\".m\")\n  of skMethod: result.add(\".e\")\n  of skIterator: result.add(\".i\")\n  of skTemplate: result.add(\".t\")\n  of skConverter: result.add(\".c\")\n  else: discard\n  if n.safeLen > paramsPos and n[paramsPos].kind == nkFormalParams:\n    let params = renderParamTypes(n[paramsPos])\n    if params.len > 0:\n      result.add(defaultParamSeparator)\n      result.add(params)\n\nproc docstringSummary(rstText: string): string =\n  ## Returns just the first line or a brief chunk of text from a rst string.\n  ##\n  ## Most docstrings will contain a one liner summary, so stripping at the\n  ## first newline is usually fine. If after that the content is still too big,\n  ## it is stripped at the first comma, colon or dot, usual English sentence\n  ## separators.\n  ##\n  ## No guarantees are made on the size of the output, but it should be small.\n  ## Also, we hope to not break the rst, but maybe we do. If there is any\n  ## trimming done, an ellipsis unicode char is added.\n  const maxDocstringChars = 100\n  assert(rstText.len < 2 or (rstText[0] == '#' and rstText[1] == '#'))\n  result = rstText.substr(2).strip\n  var pos = result.find('\\L')\n  if pos > 0:\n    result.setLen(pos - 1)\n    result.add(\"\u2026\")\n  if pos < maxDocstringChars:\n    return\n  # Try to keep trimming at other natural boundaries.\n  pos = result.find({'.', ',', ':'})\n  let last = result.len - 1\n  if pos > 0 and pos < last:\n    result.setLen(pos - 1)\n    result.add(\"\u2026\")\n\nproc genDeprecationMsg(d: PDoc, n: PNode): string =\n  ## Given a nkPragma wDeprecated node output a well-formatted section\n  if n == nil: return\n\n  case n.safeLen:\n  of 0: # Deprecated w/o any message\n    result = getConfigVar(d.conf, \"doc.deprecationmsg\") % [\n       \"label\" , \"Deprecated\", \"message\", \"\"]\n  of 2: # Deprecated w/ a message\n    if n[1].kind in {nkStrLit..nkTripleStrLit}:\n      result = getConfigVar(d.conf, \"doc.deprecationmsg\") % [\n          \"label\", \"Deprecated:\", \"message\", xmltree.escape(n[1].strVal)]\n  else:\n    doAssert false\n\ntype DocFlags = enum\n  kDefault\n  kForceExport\n\nproc genSeeSrc(d: PDoc, path: string, line: int): string =\n  let docItemSeeSrc = getConfigVar(d.conf, \"doc.item.seesrc\")\n  if docItemSeeSrc.len > 0:\n    let path = relativeTo(AbsoluteFile path, AbsoluteDir getCurrentDir(), '/')\n    when false:\n      let cwd = canonicalizePath(d.conf, getCurrentDir())\n      var path = path\n      if path.startsWith(cwd):\n        path = path[cwd.len+1..^1].replace('\\\\', '/')\n    let gitUrl = getConfigVar(d.conf, \"git.url\")\n    if gitUrl.len > 0:\n      let defaultBranch =\n        if NimPatch mod 2 == 1: \"devel\"\n        else: \"version-$1-$2\" % [$NimMajor, $NimMinor]\n      let commit = getConfigVar(d.conf, \"git.commit\", defaultBranch)\n      let develBranch = getConfigVar(d.conf, \"git.devel\", \"devel\")\n      dispA(d.conf, result, \"$1\", \"\", [docItemSeeSrc % [\n          \"path\", path.string, \"line\", $line, \"url\", gitUrl,\n          \"commit\", commit, \"devel\", develBranch]])\n\nproc symbolPriority(k: TSymKind): int =\n  result = case k\n    of skMacro: -3\n    of skTemplate: -2\n    of skIterator: -1\n    else: 0  # including skProc which have higher priority\n    # documentation itself has even higher priority 1\n\nproc toLangSymbol(k: TSymKind, n: PNode, baseName: string): LangSymbol =\n  ## Converts symbol info (names/types/parameters) in `n` into format\n  ## `LangSymbol` convenient for ``rst.nim``/``dochelpers.nim``.\n  result.name = baseName.nimIdentNormalize\n  result.symKind = k.toHumanStr\n  if k in routineKinds:\n    var\n      paramTypes: seq[string]\n    renderParamTypes(paramTypes, n[paramsPos], toNormalize=true)\n    let paramNames = renderParamNames(n[paramsPos], toNormalize=true)\n    # In some rare cases (system.typeof) parameter type is not set for default:\n    doAssert paramTypes.len <= paramNames.len\n    for i in 0 ..< paramNames.len:\n      if i < paramTypes.len:\n        result.parameters.add (paramNames[i], paramTypes[i])\n      else:\n        result.parameters.add (paramNames[i], \"\")\n    result.parametersProvided = true\n\n    result.outType = renderOutType(n[paramsPos], toNormalize=true)\n\n  if k in {skProc, skFunc, skType, skIterator}:\n    # Obtain `result.generics`\n    # Use `n[miscPos]` since n[genericParamsPos] does not contain constraints\n    var genNode: PNode = nil\n    if k == skType:\n      genNode = n[1]  # FIXME: what is index 1?\n    else:\n      if n[miscPos].kind != nkEmpty:\n        genNode = n[miscPos][1]   # FIXME: what is index 1?\n    if genNode != nil:\n      var literal = \"\"\n      var r: TSrcGen\n      initTokRender(r, genNode, {renderNoBody, renderNoComments,\n        renderNoPragmas, renderNoProcDefs})\n      var kind = tkEof\n      while true:\n        getNextTok(r, kind, literal)\n        if kind == tkEof:\n          break\n        if kind != tkSpaces:\n          result.generics.add(literal.nimIdentNormalize)\n\n  if k == skType:\n    case n[2].kind\n    of nkEnumTy: result.symTypeKind = \"enum\"\n    of nkObjectTy: result.symTypeKind = \"object\"\n    of nkTupleTy: result.symTypeKind = \"tuple\"\n    else: discard\n\nproc genItem(d: PDoc, n, nameNode: PNode, k: TSymKind, docFlags: DocFlags) =\n  if (docFlags != kForceExport) and not isVisible(d, nameNode): return\n  let\n    name = getName(d, nameNode)\n  var plainDocstring = getPlainDocstring(n) # call here before genRecComment!\n  var result = \"\"\n  var literal, plainName = \"\"\n  var kind = tkEof\n  var comm: ItemPre\n  if n.kind in routineDefs:\n    getAllRunnableExamples(d, n, comm)\n  else:\n    comm.add genRecComment(d, n)\n\n  var r: TSrcGen\n  # Obtain the plain rendered string for hyperlink titles.\n  initTokRender(r, n, {renderNoBody, renderNoComments, renderDocComments,\n    renderNoPragmas, renderNoProcDefs})\n  while true:\n    getNextTok(r, kind, literal)\n    if kind == tkEof:\n      break\n    plainName.add(literal)\n\n  var pragmaNode = getDeclPragma(n)\n  if pragmaNode != nil: pragmaNode = findPragma(pragmaNode, wDeprecated)\n\n  inc(d.id)\n  let\n    plainNameEsc = esc(d.target, plainName.strip)\n    detailedName = k.toHumanStr & \" \" & (\n        if k in routineKinds: plainName else: name)\n    uniqueName = if k in routineKinds: plainNameEsc else: name\n    sortName = if k in routineKinds: plainName.strip else: name\n    cleanPlainSymbol = renderPlainSymbolName(nameNode)\n    complexSymbol = complexName(k, n, cleanPlainSymbol)\n    plainSymbolEnc = encodeUrl(cleanPlainSymbol, usePlus = false)\n    symbolOrId = d.newUniquePlainSymbol(complexSymbol)\n    symbolOrIdEnc = encodeUrl(symbolOrId, usePlus = false)\n    deprecationMsg = genDeprecationMsg(d, pragmaNode)\n    rstLangSymbol = toLangSymbol(k, n, cleanPlainSymbol)\n\n  # we generate anchors automatically for subsequent use in doc comments\n  let lineinfo = rstast.TLineInfo(\n      line: nameNode.info.line, col: nameNode.info.col,\n      fileIndex: addRstFileIndex(d, nameNode.info))\n  addAnchorNim(d.sharedState, refn = symbolOrId, tooltip = detailedName,\n               rstLangSymbol, priority = symbolPriority(k), info = lineinfo)\n\n  nodeToHighlightedHtml(d, n, result, {renderNoBody, renderNoComments,\n    renderDocComments, renderSyms}, symbolOrIdEnc)\n\n  let seeSrc = genSeeSrc(d, toFullPath(d.conf, n.info), n.info.line.int)\n\n  d.section[k].secItems.mgetOrPut(cleanPlainSymbol, newSeq[Item]()).add Item(\n    descRst: comm,\n    sortName: sortName,\n    info: lineinfo,\n    anchor: symbolOrId,\n    detailedName: detailedName,\n    name: name,\n    substitutions: @[\n     \"uniqueName\", uniqueName,\n     \"header\", result, \"itemID\", $d.id,\n     \"header_plain\", plainNameEsc, \"itemSym\", cleanPlainSymbol,\n     \"itemSymEnc\", plainSymbolEnc,\n     \"itemSymOrIDEnc\", symbolOrIdEnc, \"seeSrc\", seeSrc,\n     \"deprecationMsg\", deprecationMsg])\n\n  let external = d.destFile.AbsoluteFile.relativeTo(d.conf.outDir, '/').changeFileExt(HtmlExt).string\n\n  var attype = \"\"\n  if k in routineKinds and nameNode.kind == nkSym:\n    let att = attachToType(d, nameNode.sym)\n    if att != nil:\n      attype = esc(d.target, att.name.s)\n  elif k == skType and nameNode.kind == nkSym and nameNode.sym.typ.kind in {tyEnum, tyBool}:\n    let etyp = nameNode.sym.typ\n    for e in etyp.n:\n      if e.sym.kind != skEnumField: continue\n      let plain = renderPlainSymbolName(e)\n      let symbolOrId = d.newUniquePlainSymbol(plain)\n      setIndexTerm(d[], external, symbolOrId, plain, nameNode.sym.name.s & '.' & plain,\n        xmltree.escape(getPlainDocstring(e).docstringSummary))\n\n  d.tocSimple[k].add TocItem(\n    sortName: sortName,\n    content: getConfigVar(d.conf, \"doc.item.toc\") % [\n      \"name\", name, \"header_plain\", plainNameEsc,\n      \"itemSymOrIDEnc\", symbolOrIdEnc])\n\n  d.tocTable[k].mgetOrPut(cleanPlainSymbol, newSeq[TocItem]()).add TocItem(\n    sortName: sortName,\n    content: getConfigVar(d.conf, \"doc.item.tocTable\") % [\n      \"name\", name, \"header_plain\", plainNameEsc,\n      \"itemSymOrID\", symbolOrId.replace(\",\", \",<wbr>\"),\n      \"itemSymOrIDEnc\", symbolOrIdEnc])\n\n  # Ironically for types the complexSymbol is *cleaner* than the plainName\n  # because it doesn't include object fields or documentation comments. So we\n  # use the plain one for callable elements, and the complex for the rest.\n  var linkTitle = changeFileExt(extractFilename(d.filename), \"\") & \": \"\n  if n.kind in routineDefs: linkTitle.add(xmltree.escape(plainName.strip))\n  else: linkTitle.add(xmltree.escape(complexSymbol.strip))\n\n  setIndexTerm(d[], external, symbolOrId, name, linkTitle,\n    xmltree.escape(plainDocstring.docstringSummary))\n  if k == skType and nameNode.kind == nkSym:\n    d.types.strTableAdd nameNode.sym\n\nproc genJsonItem(d: PDoc, n, nameNode: PNode, k: TSymKind): JsonItem =\n  if not isVisible(d, nameNode): return\n  var\n    name = getName(d, nameNode)\n    comm = genRecComment(d, n)\n    r: TSrcGen\n  initTokRender(r, n, {renderNoBody, renderNoComments, renderDocComments})\n  result.json = %{ \"name\": %name, \"type\": %($k), \"line\": %n.info.line.int,\n                   \"col\": %n.info.col}\n  if comm != nil:\n    result.rst = comm\n    result.rstField = \"description\"\n  if r.buf.len > 0:\n    result.json[\"code\"] = %r.buf\n  if k in routineKinds:\n    result.json[\"signature\"] = newJObject()\n    if n[paramsPos][0].kind != nkEmpty:\n      result.json[\"signature\"][\"return\"] = %($n[paramsPos][0])\n    if n[paramsPos].len > 1:\n      result.json[\"signature\"][\"arguments\"] = newJArray()\n    for paramIdx in 1 ..< n[paramsPos].len:\n      for identIdx in 0 ..< n[paramsPos][paramIdx].len - 2:\n        let\n          paramName = $n[paramsPos][paramIdx][identIdx]\n          paramType = $n[paramsPos][paramIdx][^2]\n        if n[paramsPos][paramIdx][^1].kind != nkEmpty:\n          let paramDefault = $n[paramsPos][paramIdx][^1]\n          result.json[\"signature\"][\"arguments\"].add %{\"name\": %paramName, \"type\": %paramType, \"default\": %paramDefault}\n        else:\n          result.json[\"signature\"][\"arguments\"].add %{\"name\": %paramName, \"type\": %paramType}\n    if n[pragmasPos].kind != nkEmpty:\n      result.json[\"signature\"][\"pragmas\"] = newJArray()\n      for pragma in n[pragmasPos]:\n        result.json[\"signature\"][\"pragmas\"].add %($pragma)\n    if n[genericParamsPos].kind != nkEmpty:\n      result.json[\"signature\"][\"genericParams\"] = newJArray()\n      for genericParam in n[genericParamsPos]:\n        var param = %{\"name\": %($genericParam)}\n        if genericParam.sym.typ.sons.len > 0:\n          param[\"types\"] = newJArray()\n        for kind in genericParam.sym.typ.sons:\n          param[\"types\"].add %($kind)\n        result.json[\"signature\"][\"genericParams\"].add param\n\nproc checkForFalse(n: PNode): bool =\n  result = n.kind == nkIdent and cmpIgnoreStyle(n.ident.s, \"false\") == 0\n\nproc traceDeps(d: PDoc, it: PNode) =\n  const k = skModule\n  if it.kind == nkInfix and it.len == 3 and it[2].kind == nkBracket:\n    let sep = it[0]\n    let dir = it[1]\n    let a = newNodeI(nkInfix, it.info)\n    a.add sep\n    a.add dir\n    a.add sep # dummy entry, replaced in the loop\n    for x in it[2]:\n      a[2] = x\n      traceDeps(d, a)\n  elif it.kind == nkSym and belongsToPackage(d.conf, it.sym):\n    let external = externalDep(d, it.sym)\n    if d.section[k].finalMarkup != \"\": d.section[k].finalMarkup.add(\", \")\n    dispA(d.conf, d.section[k].finalMarkup,\n          \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n          \"$1\", [esc(d.target, external.prettyLink),\n                 changeFileExt(external, \"html\")])\n\nproc exportSym(d: PDoc; s: PSym) =\n  const k = exportSection\n  if s.kind == skModule and belongsToPackage(d.conf, s):\n    let external = externalDep(d, s)\n    if d.section[k].finalMarkup != \"\": d.section[k].finalMarkup.add(\", \")\n    dispA(d.conf, d.section[k].finalMarkup,\n          \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n          \"$1\", [esc(d.target, external.prettyLink),\n                 changeFileExt(external, \"html\")])\n  elif s.kind != skModule and s.owner != nil:\n    let module = originatingModule(s)\n    if belongsToPackage(d.conf, module):\n      let\n        complexSymbol = complexName(s.kind, s.ast, s.name.s)\n        symbolOrId = d.newUniquePlainSymbol(complexSymbol)\n        external = externalDep(d, module)\n      if d.section[k].finalMarkup != \"\": d.section[k].finalMarkup.add(\", \")\n      # XXX proper anchor generation here\n      dispA(d.conf, d.section[k].finalMarkup,\n            \"<a href=\\\"$2#$3\\\"><span class=\\\"Identifier\\\">$1</span></a>\",\n            \"$1\", [esc(d.target, s.name.s),\n                   changeFileExt(external, \"html\"),\n                   symbolOrId])\n\nproc documentNewEffect(cache: IdentCache; n: PNode): PNode =\n  let s = n[namePos].sym\n  if tfReturnsNew in s.typ.flags:\n    result = newIdentNode(getIdent(cache, \"new\"), n.info)\n\nproc documentEffect(cache: IdentCache; n, x: PNode, effectType: TSpecialWord, idx: int): PNode =\n  let spec = effectSpec(x, effectType)\n  if isNil(spec):\n    let s = n[namePos].sym\n\n    let actual = s.typ.n[0]\n    if actual.len != effectListLen: return\n    let real = actual[idx]\n    if real == nil: return\n    let realLen = real.len\n    # warning: hack ahead:\n    var effects = newNodeI(nkBracket, n.info, realLen)\n    for i in 0..<realLen:\n      var t = typeToString(real[i].typ)\n      if t.startsWith(\"ref \"): t = substr(t, 4)\n      effects[i] = newIdentNode(getIdent(cache, t), n.info)\n      # set the type so that the following analysis doesn't screw up:\n      effects[i].typ = real[i].typ\n\n    result = newTreeI(nkExprColonExpr, n.info,\n      newIdentNode(getIdent(cache, $effectType), n.info), effects)\n\nproc documentWriteEffect(cache: IdentCache; n: PNode; flag: TSymFlag; pragmaName: string): PNode =\n  let s = n[namePos].sym\n  let params = s.typ.n\n\n  var effects = newNodeI(nkBracket, n.info)\n  for i in 1..<params.len:\n    if params[i].kind == nkSym and flag in params[i].sym.flags:\n      effects.add params[i]\n\n  if effects.len > 0:\n    result = newTreeI(nkExprColonExpr, n.info,\n      newIdentNode(getIdent(cache, pragmaName), n.info), effects)\n\nproc documentRaises*(cache: IdentCache; n: PNode) =\n  if n[namePos].kind != nkSym: return\n  let pragmas = n[pragmasPos]\n  let p1 = documentEffect(cache, n, pragmas, wRaises, exceptionEffects)\n  let p2 = documentEffect(cache, n, pragmas, wTags, tagEffects)\n  let p3 = documentWriteEffect(cache, n, sfWrittenTo, \"writes\")\n  let p4 = documentNewEffect(cache, n)\n  let p5 = documentWriteEffect(cache, n, sfEscapes, \"escapes\")\n\n  if p1 != nil or p2 != nil or p3 != nil or p4 != nil or p5 != nil:\n    if pragmas.kind == nkEmpty:\n      n[pragmasPos] = newNodeI(nkPragma, n.info)\n    if p1 != nil: n[pragmasPos].add p1\n    if p2 != nil: n[pragmasPos].add p2\n    if p3 != nil: n[pragmasPos].add p3\n    if p4 != nil: n[pragmasPos].add p4\n    if p5 != nil: n[pragmasPos].add p5\n\nproc generateDoc*(d: PDoc, n, orig: PNode, docFlags: DocFlags = kDefault) =\n  ## Goes through nim nodes recursively and collects doc comments.\n  ## Main function for `doc`:option: command,\n  ## which is implemented in ``docgen2.nim``.\n  template genItemAux(skind) =\n    genItem(d, n, n[namePos], skind, docFlags)\n  case n.kind\n  of nkPragma:\n    let pragmaNode = findPragma(n, wDeprecated)\n    d.modDeprecationMsg.add(genDeprecationMsg(d, pragmaNode))\n  of nkCommentStmt: d.modDescPre.add(genComment(d, n))\n  of nkProcDef, nkFuncDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skProc)\n  of nkMethodDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skMethod)\n  of nkIteratorDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skIterator)\n  of nkMacroDef: genItemAux(skMacro)\n  of nkTemplateDef: genItemAux(skTemplate)\n  of nkConverterDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skConverter)\n  of nkTypeSection, nkVarSection, nkLetSection, nkConstSection:\n    for i in 0..<n.len:\n      if n[i].kind != nkCommentStmt:\n        # order is always 'type var let const':\n        genItem(d, n[i], n[i][0],\n                succ(skType, ord(n.kind)-ord(nkTypeSection)), docFlags)\n  of nkStmtList:\n    for i in 0..<n.len: generateDoc(d, n[i], orig)\n  of nkWhenStmt:\n    # generate documentation for the first branch only:\n    if not checkForFalse(n[0][0]):\n      generateDoc(d, lastSon(n[0]), orig)\n  of nkImportStmt:\n    for it in n: traceDeps(d, it)\n  of nkExportStmt:\n    for it in n:\n      if it.kind == nkSym:\n        if d.module != nil and d.module == it.sym.owner:\n          generateDoc(d, it.sym.ast, orig, kForceExport)\n        elif it.sym.ast != nil:\n          exportSym(d, it.sym)\n  of nkExportExceptStmt: discard \"transformed into nkExportStmt by semExportExcept\"\n  of nkFromStmt, nkImportExceptStmt: traceDeps(d, n[0])\n  of nkCallKinds:\n    var comm: ItemPre\n    getAllRunnableExamples(d, n, comm)\n    if comm.len != 0: d.modDescPre.add(comm)\n  else: discard\n\nproc overloadGroupName(s: string, k: TSymKind): string =\n  ## Turns a name like `f` into anchor `f-procs-all`\n  #s & \" \" & k.toHumanStr & \"s all\"\n  s & \"-\" & k.toHumanStr & \"s-all\"\n\nproc finishGenerateDoc*(d: var PDoc) =\n  ## Perform 2nd RST pass for resolution of links/footnotes/headings...\n  # copy file map `filenames` to ``rstgen.nim`` for its warnings\n  d.filenames = d.sharedState.filenames\n\n  # Main title/subtitle are allowed only in the first RST fragment of document\n  var firstRst = PRstNode(nil)\n  for fragment in d.modDescPre:\n    if fragment.isRst:\n      firstRst = fragment.rst\n      break\n  preparePass2(d.sharedState, firstRst)\n\n  # add anchors to overload groups before RST resolution\n  for k in TSymKind:\n    if k in routineKinds:\n      for plainName, overloadChoices in d.section[k].secItems:\n        if overloadChoices.len > 1:\n          let refn = overloadGroupName(plainName, k)\n          let tooltip = \"$1 ($2 overloads)\" % [\n                      k.toHumanStr & \" \" & plainName, $overloadChoices.len]\n          addAnchorNim(d.sharedState, refn, tooltip,\n                       LangSymbol(symKind: k.toHumanStr,\n                                  name: nimIdentBackticksNormalize(plainName),\n                                  isGroup: true),\n                       priority = symbolPriority(k),\n                       # select index `0` just to have any meaningful warning:\n                       info = overloadChoices[0].info)\n\n  # Finalize fragments of ``.nim`` or ``.rst`` file\n  proc renderItemPre(d: PDoc, fragments: ItemPre, result: var string) =\n    for f in fragments:\n      case f.isRst:\n      of true:\n        var resolved = resolveSubs(d.sharedState, f.rst)\n        renderRstToOut(d[], resolved, result)\n      of false: result &= f.str\n  proc cmp(x, y: Item): int = cmpDecimalsIgnoreCase(x.sortName, y.sortName)\n  for k in TSymKind:\n    # add symbols to section for each `k`, while optionally wrapping\n    # overloadable items with the same basic name by ``doc.item2``\n    let overloadableNames = toSeq(keys(d.section[k].secItems))\n    for plainName in overloadableNames.sorted(cmpDecimalsIgnoreCase):\n      var overloadChoices = d.section[k].secItems[plainName]\n      overloadChoices.sort(cmp)\n      var nameContent = \"\"\n      for item in overloadChoices:\n        var itemDesc: string\n        renderItemPre(d, item.descRst, itemDesc)\n        nameContent.add(\n          getConfigVar(d.conf, \"doc.item\") % (\n              item.substitutions & @[\n                \"desc\", itemDesc,\n                \"name\", item.name,\n                \"itemSymOrID\", item.anchor]))\n      if k in routineKinds:\n        let plainNameEsc1 = esc(d.target, plainName.strip)\n        let plainNameEsc2 = esc(d.target, plainName.strip, escMode=emUrl)\n        d.section[k].finalMarkup.add(\n          getConfigVar(d.conf, \"doc.item2\") % (\n            @[\"header_plain\", plainNameEsc1,\n              \"overloadGroupName\", overloadGroupName(plainNameEsc2, k),\n              \"content\", nameContent]))\n      else:\n        d.section[k].finalMarkup.add(nameContent)\n    d.section[k].secItems.clear\n  renderItemPre(d, d.modDescPre, d.modDescFinal)\n  d.modDescPre.setLen 0\n  d.hasToc = d.hasToc or d.sharedState.hasToc\n\n  # Finalize fragments of ``.json`` file\n  for i, entry in d.jEntriesPre:\n    if entry.rst != nil:\n      let resolved = resolveSubs(d.sharedState, entry.rst)\n      var str: string\n      renderRstToOut(d[], resolved, str)\n      entry.json[entry.rstField] = %str\n      d.jEntriesFinal.add entry.json\n      d.jEntriesPre[i].rst = nil\n\nproc add(d: PDoc; j: JsonItem) =\n  if j.json != nil or j.rst != nil: d.jEntriesPre.add j\n\nproc generateJson*(d: PDoc, n: PNode, includeComments: bool = true) =\n  case n.kind\n  of nkCommentStmt:\n    if includeComments:\n      d.add JsonItem(rst: genComment(d, n), rstField: \"comment\",\n                     json: %Table[string, string]())\n    else:\n      d.modDescPre.add(genComment(d, n))\n  of nkProcDef, nkFuncDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skProc)\n  of nkMethodDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skMethod)\n  of nkIteratorDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skIterator)\n  of nkMacroDef:\n    d.add genJsonItem(d, n, n[namePos], skMacro)\n  of nkTemplateDef:\n    d.add genJsonItem(d, n, n[namePos], skTemplate)\n  of nkConverterDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skConverter)\n  of nkTypeSection, nkVarSection, nkLetSection, nkConstSection:\n    for i in 0..<n.len:\n      if n[i].kind != nkCommentStmt:\n        # order is always 'type var let const':\n        d.add genJsonItem(d, n[i], n[i][0],\n                succ(skType, ord(n.kind)-ord(nkTypeSection)))\n  of nkStmtList:\n    for i in 0..<n.len:\n      generateJson(d, n[i], includeComments)\n  of nkWhenStmt:\n    # generate documentation for the first branch only:\n    if not checkForFalse(n[0][0]):\n      generateJson(d, lastSon(n[0]), includeComments)\n  else: discard\n\nproc genTagsItem(d: PDoc, n, nameNode: PNode, k: TSymKind): string =\n  result = getName(d, nameNode) & \"\\n\"\n\nproc generateTags*(d: PDoc, n: PNode, r: var string) =\n  case n.kind\n  of nkCommentStmt:\n    if startsWith(n.comment, \"##\"):\n      let stripped = n.comment.substr(2).strip\n      r.add stripped\n  of nkProcDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skProc)\n  of nkFuncDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skFunc)\n  of nkMethodDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skMethod)\n  of nkIteratorDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skIterator)\n  of nkMacroDef:\n    r.add genTagsItem(d, n, n[namePos], skMacro)\n  of nkTemplateDef:\n    r.add genTagsItem(d, n, n[namePos], skTemplate)\n  of nkConverterDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skConverter)\n  of nkTypeSection, nkVarSection, nkLetSection, nkConstSection:\n    for i in 0..<n.len:\n      if n[i].kind != nkCommentStmt:\n        # order is always 'type var let const':\n        r.add genTagsItem(d, n[i], n[i][0],\n                succ(skType, ord(n.kind)-ord(nkTypeSection)))\n  of nkStmtList:\n    for i in 0..<n.len:\n      generateTags(d, n[i], r)\n  of nkWhenStmt:\n    # generate documentation for the first branch only:\n    if not checkForFalse(n[0][0]):\n      generateTags(d, lastSon(n[0]), r)\n  else: discard\n\nproc genSection(d: PDoc, kind: TSymKind, groupedToc = false) =\n  const sectionNames: array[skModule..skField, string] = [\n    \"Imports\", \"Types\", \"Vars\", \"Lets\", \"Consts\", \"Vars\", \"Procs\", \"Funcs\",\n    \"Methods\", \"Iterators\", \"Converters\", \"Macros\", \"Templates\", \"Exports\"\n  ]\n  if d.section[kind].finalMarkup == \"\": return\n  var title = sectionNames[kind]\n  d.section[kind].finalMarkup = getConfigVar(d.conf, \"doc.section\") % [\n      \"sectionid\", $ord(kind), \"sectionTitle\", title,\n      \"sectionTitleID\", $(ord(kind) + 50), \"content\", d.section[kind].finalMarkup]\n\n  proc cmp(x, y: TocItem): int = cmpDecimalsIgnoreCase(x.sortName, y.sortName)\n  if groupedToc:\n    let overloadableNames = toSeq(keys(d.tocTable[kind]))\n    for plainName in overloadableNames.sorted(cmpDecimalsIgnoreCase):\n      var overloadChoices = d.tocTable[kind][plainName]\n      overloadChoices.sort(cmp)\n      var content: string\n      for item in overloadChoices:\n        content.add item.content\n      d.toc2[kind].add getConfigVar(d.conf, \"doc.section.toc2\") % [\n          \"sectionid\", $ord(kind), \"sectionTitle\", title,\n          \"sectionTitleID\", $(ord(kind) + 50),\n          \"content\", content, \"plainName\", plainName]\n  else:\n    for item in d.tocSimple[kind].sorted(cmp):\n      d.toc2[kind].add item.content\n\n  d.toc[kind] = getConfigVar(d.conf, \"doc.section.toc\") % [\n      \"sectionid\", $ord(kind), \"sectionTitle\", title,\n      \"sectionTitleID\", $(ord(kind) + 50), \"content\", d.toc2[kind]]\n\nproc relLink(outDir: AbsoluteDir, destFile: AbsoluteFile, linkto: RelativeFile): string =\n  $relativeTo(outDir / linkto, destFile.splitFile().dir, '/')\n\nproc genOutFile(d: PDoc, groupedToc = false): string =\n  var\n    code, content: string\n    title = \"\"\n  var j = 0\n  var toc = \"\"\n  renderTocEntries(d[], j, 1, toc)\n  for i in TSymKind:\n    var shouldSort = i in routineKinds and groupedToc\n    genSection(d, i, shouldSort)\n    toc.add(d.toc[i])\n  if toc != \"\" or d.target == outLatex:\n    # for Latex $doc.toc will automatically generate TOC if `d.hasToc` is set\n    toc = getConfigVar(d.conf, \"doc.toc\") % [\"content\", toc]\n  for i in TSymKind: code.add(d.section[i].finalMarkup)\n\n  # Extract the title. Non API modules generate an entry in the index table.\n  if d.meta[metaTitle].len != 0:\n    title = d.meta[metaTitle]\n    let external = presentationPath(d.conf, AbsoluteFile d.filename).changeFileExt(HtmlExt).string.nativeToUnixPath\n    setIndexTerm(d[], external, \"\", title)\n  else:\n    # Modules get an automatic title for the HTML, but no entry in the index.\n    title = canonicalImport(d.conf, AbsoluteFile d.filename)\n  title = esc(d.target, title)\n  var subtitle = \"\"\n  if d.meta[metaSubtitle] != \"\":\n    dispA(d.conf, subtitle, \"<h2 class=\\\"subtitle\\\">$1</h2>\",\n        \"\\\\\\\\\\\\vspace{0.5em}\\\\large $1\", [esc(d.target, d.meta[metaSubtitle])])\n\n  var groupsection = getConfigVar(d.conf, \"doc.body_toc_groupsection\")\n  let bodyname = if d.hasToc and not d.isPureRst and not d.conf.isLatexCmd:\n                   groupsection.setLen 0\n                   \"doc.body_toc_group\"\n                 elif d.hasToc: \"doc.body_toc\"\n                 else: \"doc.body_no_toc\"\n  let seeSrc = genSeeSrc(d, d.filename, 1)\n  content = getConfigVar(d.conf, bodyname) % [\n      \"title\", title, \"subtitle\", subtitle,\n      \"tableofcontents\", toc, \"moduledesc\", d.modDescFinal, \"date\", getDateStr(),\n      \"time\", getClockStr(), \"content\", code,\n      \"deprecationMsg\", d.modDeprecationMsg,\n      \"theindexhref\", relLink(d.conf.outDir, d.destFile.AbsoluteFile,\n                              theindexFname.RelativeFile),\n      \"body_toc_groupsection\", groupsection, \"seeSrc\", seeSrc]\n  if optCompileOnly notin d.conf.globalOptions:\n    # XXX what is this hack doing here? 'optCompileOnly' means raw output!?\n    code = getConfigVar(d.conf, \"doc.file\") % [\n        \"nimdoccss\", relLink(d.conf.outDir, d.destFile.AbsoluteFile,\n                             nimdocOutCss.RelativeFile),\n        \"dochackjs\", relLink(d.conf.outDir, d.destFile.AbsoluteFile,\n                             docHackJsFname.RelativeFile),\n        \"title\", title, \"subtitle\", subtitle, \"tableofcontents\", toc,\n        \"moduledesc\", d.modDescFinal, \"date\", getDateStr(), \"time\", getClockStr(),\n        \"content\", content, \"author\", d.meta[metaAuthor],\n        \"version\", esc(d.target, d.meta[metaVersion]), \"analytics\", d.analytics,\n        \"deprecationMsg\", d.modDeprecationMsg]\n  else:\n    code = content\n  result = code\n\nproc generateIndex*(d: PDoc) =\n  if optGenIndex in d.conf.globalOptions:\n    let dir = d.conf.outDir\n    createDir(dir)\n    let dest = dir / changeFileExt(presentationPath(d.conf, AbsoluteFile d.filename), IndexExt)\n    writeIndexFile(d[], dest.string)\n\nproc updateOutfile(d: PDoc, outfile: AbsoluteFile) =\n  if d.module == nil or sfMainModule in d.module.flags: # nil for e.g. for commandRst2Html\n    if d.conf.outFile.isEmpty:\n      d.conf.outFile = outfile.relativeTo(d.conf.outDir)\n      if isAbsolute(d.conf.outFile.string):\n        d.conf.outFile = splitPath(d.conf.outFile.string)[1].RelativeFile\n\nproc writeOutput*(d: PDoc, useWarning = false, groupedToc = false) =\n  runAllExamples(d)\n  var content = genOutFile(d, groupedToc)\n  if optStdout in d.conf.globalOptions:\n    write(stdout, content)\n  else:\n    template outfile: untyped = d.destFile.AbsoluteFile\n    #let outfile = getOutFile2(d.conf, shortenDir(d.conf, filename), outExt)\n    let dir = outfile.splitFile.dir\n    createDir(dir)\n    updateOutfile(d, outfile)\n    try:\n      writeFile(outfile, content)\n    except IOError:\n      rawMessage(d.conf, if useWarning: warnCannotOpenFile else: errCannotOpenFile,\n        outfile.string)\n    if not d.wroteSupportFiles: # nimdoc.css + dochack.js\n      let nimr = $d.conf.getPrefixDir()\n      copyFile(docCss.interp(nimr = nimr), $d.conf.outDir / nimdocOutCss)\n      if optGenIndex in d.conf.globalOptions:\n        let docHackJs2 = getDocHacksJs(nimr, nim = getAppFilename())\n        copyFile(docHackJs2, $d.conf.outDir / docHackJs2.lastPathPart)\n      d.wroteSupportFiles = true\n\nproc writeOutputJson*(d: PDoc, useWarning = false) =\n  runAllExamples(d)\n  var modDesc: string\n  for desc in d.modDescFinal:\n    modDesc &= desc\n  let content = %*{\"orig\": d.filename,\n    \"nimble\": getPackageName(d.conf, d.filename),\n    \"moduleDescription\": modDesc,\n    \"entries\": d.jEntriesFinal}\n  if optStdout in d.conf.globalOptions:\n    write(stdout, $content)\n  else:\n    var f: File\n    if open(f, d.destFile, fmWrite):\n      write(f, $content)\n      close(f)\n      updateOutfile(d, d.destFile.AbsoluteFile)\n    else:\n      localError(d.conf, newLineInfo(d.conf, AbsoluteFile d.filename, -1, -1),\n                 warnUser, \"unable to open file \\\"\" & d.destFile &\n                 \"\\\" for writing\")\n\nproc handleDocOutputOptions*(conf: ConfigRef) =\n  if optWholeProject in conf.globalOptions:\n    # Backward compatibility with previous versions\n    # xxx this is buggy when user provides `nim doc --project -o:sub/bar.html main`,\n    # it'd write to `sub/bar.html/main.html`\n    conf.outDir = AbsoluteDir(conf.outDir / conf.outFile)\n\nproc commandDoc*(cache: IdentCache, conf: ConfigRef) =\n  ## implementation of deprecated ``doc0`` command (without semantic checking)\n  handleDocOutputOptions conf\n  var ast = parseFile(conf.projectMainIdx, cache, conf)\n  if ast == nil: return\n  var d = newDocumentor(conf.projectFull, cache, conf)\n  d.hasToc = true\n  generateDoc(d, ast, ast)\n  finishGenerateDoc(d)\n  writeOutput(d)\n  generateIndex(d)\n\nproc commandRstAux(cache: IdentCache, conf: ConfigRef;\n                   filename: AbsoluteFile, outExt: string) =\n  var filen = addFileExt(filename, \"txt\")\n  var d = newDocumentor(filen, cache, conf, outExt, isPureRst = true)\n  let rst = parseRst(readFile(filen.string),\n                     line=LineRstInit, column=ColRstInit,\n                     conf, d.sharedState)\n  d.modDescPre = @[ItemFragment(isRst: true, rst: rst)]\n  finishGenerateDoc(d)\n  writeOutput(d)\n  generateIndex(d)\n\nproc commandRst2Html*(cache: IdentCache, conf: ConfigRef) =\n  commandRstAux(cache, conf, conf.projectFull, HtmlExt)\n\nproc commandRst2TeX*(cache: IdentCache, conf: ConfigRef) =\n  commandRstAux(cache, conf, conf.projectFull, TexExt)\n\nproc commandJson*(cache: IdentCache, conf: ConfigRef) =\n  ## implementation of a deprecated jsondoc0 command\n  var ast = parseFile(conf.projectMainIdx, cache, conf)\n  if ast == nil: return\n  var d = newDocumentor(conf.projectFull, cache, conf)\n  d.onTestSnippet = proc (d: var RstGenerator; filename, cmd: string;\n                          status: int; content: string) =\n    localError(conf, newLineInfo(conf, AbsoluteFile d.filename, -1, -1),\n               warnUser, \"the ':test:' attribute is not supported by this backend\")\n  d.hasToc = true\n  generateJson(d, ast)\n  finishGenerateDoc(d)\n  let json = d.jEntriesFinal\n  let content = pretty(json)\n\n  if optStdout in d.conf.globalOptions:\n    write(stdout, content)\n  else:\n    #echo getOutFile(gProjectFull, JsonExt)\n    let filename = getOutFile(conf, RelativeFile conf.projectName, JsonExt)\n    try:\n      writeFile(filename, content)\n    except:\n      rawMessage(conf, errCannotOpenFile, filename.string)\n\nproc commandTags*(cache: IdentCache, conf: ConfigRef) =\n  var ast = parseFile(conf.projectMainIdx, cache, conf)\n  if ast == nil: return\n  var d = newDocumentor(conf.projectFull, cache, conf)\n  d.onTestSnippet = proc (d: var RstGenerator; filename, cmd: string;\n                          status: int; content: string) =\n    localError(conf, newLineInfo(conf, AbsoluteFile d.filename, -1, -1),\n               warnUser, \"the ':test:' attribute is not supported by this backend\")\n  d.hasToc = true\n  var\n    content = \"\"\n  generateTags(d, ast, content)\n\n  if optStdout in d.conf.globalOptions:\n    write(stdout, content)\n  else:\n    #echo getOutFile(gProjectFull, TagsExt)\n    let filename = getOutFile(conf, RelativeFile conf.projectName, TagsExt)\n    try:\n      writeFile(filename, content)\n    except:\n      rawMessage(conf, errCannotOpenFile, filename.string)\n\nproc commandBuildIndex*(conf: ConfigRef, dir: string, outFile = RelativeFile\"\") =\n  var content = mergeIndexes(dir)\n\n  var outFile = outFile\n  if outFile.isEmpty: outFile = theindexFname.RelativeFile.changeFileExt(\"\")\n  let filename = getOutFile(conf, outFile, HtmlExt)\n\n  let code = getConfigVar(conf, \"doc.file\") % [\n      \"nimdoccss\", relLink(conf.outDir, filename, nimdocOutCss.RelativeFile),\n      \"dochackjs\", relLink(conf.outDir, filename, docHackJsFname.RelativeFile),\n      \"title\", \"Index\",\n      \"subtitle\", \"\", \"tableofcontents\", \"\", \"moduledesc\", \"\",\n      \"date\", getDateStr(), \"time\", getClockStr(),\n      \"content\", content, \"author\", \"\", \"version\", \"\", \"analytics\", \"\"]\n  # no analytics because context is not available\n\n  try:\n    writeFile(filename, code)\n  except:\n    rawMessage(conf, errCannotOpenFile, filename.string)\n", "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## ==================================\n##                rst\n## ==================================\n##\n## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n## Nim-flavored reStructuredText and Markdown\n## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n##\n## This module implements a `reStructuredText`:idx: (RST) parser.\n## A large subset is implemented with some limitations_ and\n## `Nim-specific features`_.\n## A few `extra features`_ of the `Markdown`:idx: syntax are\n## also supported.\n##\n## Nim can output the result to HTML [#html]_ or Latex [#latex]_.\n##\n## .. [#html] commands `nim doc`:cmd: for ``*.nim`` files and\n##    `nim rst2html`:cmd: for ``*.rst`` files\n##\n## .. [#latex] commands `nim doc2tex`:cmd: for ``*.nim`` and\n##    `nim rst2tex`:cmd: for ``*.rst``.\n##\n## If you are new to RST please consider reading the following:\n##\n## 1) a short `quick introduction`_\n## 2) an `RST reference`_: a comprehensive cheatsheet for RST\n## 3) a more formal 50-page `RST specification`_.\n##\n## Features\n## --------\n##\n## Supported standard RST features:\n##\n## * body elements\n##   + sections\n##   + transitions\n##   + paragraphs\n##   + bullet lists using \\+, \\*, \\-\n##   + enumerated lists using arabic numerals or alphabet\n##     characters:  1. ... 2. ... *or* a. ... b. ... *or* A. ... B. ...\n##   + footnotes (including manually numbered, auto-numbered, auto-numbered\n##     with label, and auto-symbol footnotes) and citations\n##   + definition lists\n##   + field lists\n##   + option lists\n##   + indented literal blocks\n##   + quoted literal blocks\n##   + line blocks\n##   + simple tables\n##   + directives (see official documentation in `RST directives list`_):\n##     - ``image``, ``figure`` for including images and videos\n##     - ``code``\n##     - ``contents`` (table of contents), ``container``, ``raw``\n##     - ``include``\n##     - admonitions: \"attention\", \"caution\", \"danger\", \"error\", \"hint\",\n##       \"important\", \"note\", \"tip\", \"warning\", \"admonition\"\n##     - substitution definitions: `replace` and `image`\n##   + comments\n## * inline markup\n##   + *emphasis*, **strong emphasis**,\n##     ``inline literals``, hyperlink references (including embedded URI),\n##     substitution references, standalone hyperlinks,\n##     internal links (inline and outline)\n##   + \\`interpreted text\\` with roles ``:literal:``, ``:strong:``,\n##     ``emphasis``, ``:sub:``/``:subscript:``, ``:sup:``/``:superscript:``\n##     (see `RST roles list`_ for description).\n##   + inline internal targets\n##\n## .. _`Nim-specific features`:\n##\n## Additional Nim-specific features:\n##\n## * directives: ``code-block`` [cmp:Sphinx]_, ``title``,\n##   ``index`` [cmp:Sphinx]_\n## * predefined roles\n##   - ``:nim:`` (default), ``:c:`` (C programming language),\n##     ``:python:``, ``:yaml:``, ``:java:``, ``:cpp:`` (C++), ``:csharp`` (C#).\n##     That is every language that `highlite <highlite.html>`_ supports.\n##     They turn on appropriate syntax highlighting in inline code.\n##\n##     .. Note:: default role for Nim files is ``:nim:``,\n##               for ``*.rst`` it's currently ``:literal:``.\n##\n##   - generic command line highlighting roles:\n##     - ``:cmd:`` for commands and common shells syntax\n##     - ``:console:`` the same  for interactive sessions\n##       (commands should be prepended by ``$``)\n##     - ``:program:`` for executable names [cmp:Sphinx]_\n##       (one can just use ``:cmd:`` on single word)\n##     - ``:option:`` for command line options [cmp:Sphinx]_\n##   - ``:tok:``, a role for highlighting of programming language tokens\n## * ***triple emphasis*** (bold and italic) using \\*\\*\\*\n## * ``:idx:`` role for \\`interpreted text\\` to include the link to this\n##   text into an index (example: `Nim index`_).\n## * double slash `//` in option lists serves as a prefix for any option that\n##   starts from a word (without any leading symbols like `-`, `--`, `/`)::\n##\n##     //compile   compile the project\n##     //doc       generate documentation\n##\n##   Here the dummy `//` will disappear, while options `compile`:option:\n##   and `doc`:option: will be left in the final document.\n##\n## .. [cmp:Sphinx] similar but different from the directives of\n##    Python `Sphinx directives`_ and `Sphinx roles`_ extensions\n##\n## .. _`extra features`:\n##\n## Optional additional features, turned on by ``options: RstParseOption`` in\n## `proc rstParse`_:\n##\n## * emoji / smiley symbols\n## * Markdown tables\n## * Markdown code blocks\n## * Markdown links\n## * Markdown headlines\n## * Markdown block quotes\n## * using ``1`` as auto-enumerator in enumerated lists like RST ``#``\n##   (auto-enumerator ``1`` can not be used with ``#`` in the same list)\n##\n## .. Note:: By default Nim has ``roSupportMarkdown`` and\n##    ``roSupportRawDirective`` turned **on**.\n##\n## .. warning:: Using Nim-specific features can cause other RST implementations\n##   to fail on your document.\n##\n## Idiosyncrasies\n## --------------\n##\n## Currently we do **not** aim at 100% Markdown or RST compatibility in inline\n## markup recognition rules because that would provide very little user value.\n## This parser has 2 modes for inline markup:\n##\n## 1) Markdown-like mode which is enabled by `roPreferMarkdown` option\n##    (turned **on** by default).\n##\n##    .. Note:: RST features like directives are still turned **on**\n##\n## 2) Compatibility mode which is RST rules.\n##\n## .. Note:: in both modes the parser interpretes text between single\n##      backticks (code) identically:\n##      backslash does not escape; the only exception: ``\\`` folowed by `\n##      does escape so that we can always input a single backtick ` in\n##      inline code. However that makes impossible to input code with\n##      ``\\`` at the end in *single* backticks, one must use *double*\n##      backticks::\n##\n##        `\\`   -- WRONG\n##        ``\\`` -- GOOD\n##        So single backticks can always be input: `\\`` will turn to ` code\n##\n## .. Attention::\n##    We don't support some obviously poor design choices of Markdown (or RST).\n##\n##    - no support for the rule of 2 spaces causing a line break in Markdown\n##      (use RST \"line blocks\" syntax for making line breaks)\n##\n##    - interpretation of Markdown block quotes is also slightly different,\n##      e.g. case\n##\n##      ::\n##\n##        >>> foo\n##        > bar\n##        >>baz\n##\n##      is a single 3rd-level quote `foo bar baz` in original Markdown, while\n##      in Nim we naturally see it as 3rd-level quote `foo` + 1st level `bar` +\n##      2nd level `baz`:\n##\n##      >>> foo\n##      > bar\n##      >>baz\n##\n## Limitations\n## -----------\n##\n## * no Unicode support in character width calculations\n## * body elements\n##   - no roman numerals in enumerated lists\n##   - no doctest blocks\n##   - no grid tables\n##   - some directives are missing (check official `RST directives list`_):\n##     ``parsed-literal``, ``sidebar``, ``topic``, ``math``, ``rubric``,\n##     ``epigraph``, ``highlights``, ``pull-quote``, ``compound``,\n##     ``table``, ``csv-table``, ``list-table``, ``section-numbering``,\n##     ``header``, ``footer``, ``meta``, ``class``\n##     - no ``role`` directives and no custom interpreted text roles\n##     - some standard roles are not supported (check `RST roles list`_)\n##     - no generic admonition support\n## * inline markup\n##   - no simple-inline-markup\n##   - no embedded aliases\n##\n## Usage\n## -----\n##\n## See `Nim DocGen Tools Guide <docgen.html>`_ for the details about\n## `nim doc`:cmd:, `nim rst2html`:cmd: and `nim rst2tex`:cmd: commands.\n##\n## See `packages/docutils/rstgen module <rstgen.html>`_ to know how to\n## generate HTML or Latex strings to embed them into your documents.\n##\n## .. _quick introduction: https://docutils.sourceforge.io/docs/user/rst/quickstart.html\n## .. _RST reference: https://docutils.sourceforge.io/docs/user/rst/quickref.html\n## .. _RST specification: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html\n## .. _RST directives list: https://docutils.sourceforge.io/docs/ref/rst/directives.html\n## .. _RST roles list: https://docutils.sourceforge.io/docs/ref/rst/roles.html\n## .. _Nim index: https://nim-lang.org/docs/theindex.html\n## .. _Sphinx directives: https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html\n## .. _Sphinx roles: https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html\n\nimport\n  os, strutils, rstast, dochelpers, std/enumutils, algorithm, lists, sequtils,\n  std/private/miscdollars, tables\nfrom highlite import SourceLanguage, getSourceLanguage\n\ntype\n  RstParseOption* = enum     ## options for the RST parser\n    roSupportSmilies,         ## make the RST parser support smilies like ``:)``\n    roSupportRawDirective,    ## support the ``raw`` directive (don't support\n                              ## it for sandboxing)\n    roSupportMarkdown,        ## support additional features of Markdown\n    roPreferMarkdown,         ## parse as Markdown (keeping RST as \"extension\"\n                              ## to Markdown) -- implies `roSupportMarkdown`\n    roNimFile                 ## set for Nim files where default interpreted\n                              ## text role should be :nim:\n\n  RstParseOptions* = set[RstParseOption]\n\n  MsgClass* = enum\n    mcHint = \"Hint\",\n    mcWarning = \"Warning\",\n    mcError = \"Error\"\n\n  # keep the order in sync with compiler/docgen.nim and compiler/lineinfos.nim:\n  MsgKind* = enum          ## the possible messages\n    meCannotOpenFile = \"cannot open '$1'\",\n    meExpected = \"'$1' expected\",\n    meGridTableNotImplemented = \"grid table is not implemented\",\n    meMarkdownIllformedTable = \"illformed delimiter row of a Markdown table\",\n    meNewSectionExpected = \"new section expected $1\",\n    meGeneralParseError = \"general parse error\",\n    meInvalidDirective = \"invalid directive: '$1'\",\n    meInvalidField = \"invalid field: $1\",\n    meFootnoteMismatch = \"mismatch in number of footnotes and their refs: $1\",\n    mwRedefinitionOfLabel = \"redefinition of label '$1'\",\n    mwUnknownSubstitution = \"unknown substitution '$1'\",\n    mwAmbiguousLink = \"ambiguous doc link $1\",\n    mwBrokenLink = \"broken link '$1'\",\n    mwUnsupportedLanguage = \"language '$1' not supported\",\n    mwUnsupportedField = \"field '$1' not supported\",\n    mwRstStyle = \"RST style: $1\"\n\n  MsgHandler* = proc (filename: string, line, col: int, msgKind: MsgKind,\n                       arg: string) {.closure, gcsafe.} ## what to do in case of an error\n  FindFileHandler* = proc (filename: string): string {.closure, gcsafe.}\n\nproc rstnodeToRefname*(n: PRstNode): string\nproc addNodes*(n: PRstNode): string\nproc getFieldValue*(n: PRstNode, fieldname: string): string\nproc getArgument*(n: PRstNode): string\n\n# ----------------------------- scanner part --------------------------------\n\nconst\n  SymChars: set[char] = {'a'..'z', 'A'..'Z', '0'..'9', '\\x80'..'\\xFF'}\n  SmileyStartChars: set[char] = {':', ';', '8'}\n  Smilies = {\n    \":D\": \"icon_e_biggrin\",\n    \":-D\": \"icon_e_biggrin\",\n    \":)\": \"icon_e_smile\",\n    \":-)\": \"icon_e_smile\",\n    \";)\": \"icon_e_wink\",\n    \";-)\": \"icon_e_wink\",\n    \":(\": \"icon_e_sad\",\n    \":-(\": \"icon_e_sad\",\n    \":o\": \"icon_e_surprised\",\n    \":-o\": \"icon_e_surprised\",\n    \":shock:\": \"icon_eek\",\n    \":?\": \"icon_e_confused\",\n    \":-?\": \"icon_e_confused\",\n    \":-/\": \"icon_e_confused\",\n\n    \"8-)\": \"icon_cool\",\n\n    \":lol:\": \"icon_lol\",\n    \":x\": \"icon_mad\",\n    \":-x\": \"icon_mad\",\n    \":P\": \"icon_razz\",\n    \":-P\": \"icon_razz\",\n    \":oops:\": \"icon_redface\",\n    \":cry:\": \"icon_cry\",\n    \":evil:\": \"icon_evil\",\n    \":twisted:\": \"icon_twisted\",\n    \":roll:\": \"icon_rolleyes\",\n    \":!:\": \"icon_exclaim\",\n\n    \":?:\": \"icon_question\",\n    \":idea:\": \"icon_idea\",\n    \":arrow:\": \"icon_arrow\",\n    \":|\": \"icon_neutral\",\n    \":-|\": \"icon_neutral\",\n    \":mrgreen:\": \"icon_mrgreen\",\n    \":geek:\": \"icon_e_geek\",\n    \":ugeek:\": \"icon_e_ugeek\"\n  }\n\ntype\n  TokType = enum\n    tkEof, tkIndent,\n    tkWhite, tkWord,\n    tkAdornment,              # used for chapter adornment, transitions and\n                              # horizontal table borders\n    tkPunct,                  # one or many punctuation characters\n    tkOther\n  Token = object              # a RST token\n    kind*: TokType            # the type of the token\n    ival*: int                # the indentation or parsed integer value\n    symbol*: string           # the parsed symbol as string\n    line*, col*: int          # line and column of the token\n\n  TokenSeq = seq[Token]\n  Lexer = object of RootObj\n    buf*: cstring\n    bufpos*: int\n    line*, col*, baseIndent*: int\n    adornmentLine*: bool\n    escapeNext*: bool\n\nproc getThing(L: var Lexer, tok: var Token, s: set[char]) =\n  tok.kind = tkWord\n  tok.line = L.line\n  tok.col = L.col\n  var pos = L.bufpos\n  while true:\n    tok.symbol.add(L.buf[pos])\n    inc pos\n    if L.buf[pos] notin s: break\n  inc L.col, pos - L.bufpos\n  L.bufpos = pos\n\nproc isCurrentLineAdornment(L: var Lexer): bool =\n  var pos = L.bufpos\n  let c = L.buf[pos]\n  while true:\n    inc pos\n    if L.buf[pos] in {'\\c', '\\l', '\\0'}:\n      break\n    if c == '+':  # grid table\n      if L.buf[pos] notin {'-', '=', '+'}:\n        return false\n    else:  # section adornment or table horizontal border\n      if L.buf[pos] notin {c, ' ', '\\t', '\\v', '\\f'}:\n        return false\n  result = true\n\nproc getPunctAdornment(L: var Lexer, tok: var Token) =\n  if L.adornmentLine:\n    tok.kind = tkAdornment\n  else:\n    tok.kind = tkPunct\n  tok.line = L.line\n  tok.col = L.col\n  var pos = L.bufpos\n  let c = L.buf[pos]\n  if not L.escapeNext and (c != '\\\\' or L.adornmentLine):\n    while true:\n      tok.symbol.add(L.buf[pos])\n      inc pos\n      if L.buf[pos] != c: break\n  elif L.escapeNext:\n    tok.symbol.add(L.buf[pos])\n    inc pos\n  else:  # not L.escapeNext and c == '\\\\' and not L.adornmentLine\n    tok.symbol.add '\\\\'\n    inc pos\n    L.escapeNext = true\n  inc L.col, pos - L.bufpos\n  L.bufpos = pos\n  if tok.symbol == \"\\\\\": tok.kind = tkPunct\n    # nim extension: standalone \\ can not be adornment\n\nproc getBracket(L: var Lexer, tok: var Token) =\n  tok.kind = tkPunct\n  tok.line = L.line\n  tok.col = L.col\n  tok.symbol.add(L.buf[L.bufpos])\n  inc L.col\n  inc L.bufpos\n\nproc getIndentAux(L: var Lexer, start: int): int =\n  var pos = start\n  # skip the newline (but include it in the token!)\n  if L.buf[pos] == '\\r':\n    if L.buf[pos + 1] == '\\n': inc pos, 2\n    else: inc pos\n  elif L.buf[pos] == '\\n':\n    inc pos\n  while true:\n    case L.buf[pos]\n    of ' ', '\\v', '\\f':\n      inc pos\n      inc result\n    of '\\t':\n      inc pos\n      result = result - (result mod 8) + 8\n    else:\n      break                   # EndOfFile also leaves the loop\n  if L.buf[pos] == '\\0':\n    result = 0\n  elif L.buf[pos] == '\\n' or L.buf[pos] == '\\r':\n    # look at the next line for proper indentation:\n    result = getIndentAux(L, pos)\n  L.bufpos = pos              # no need to set back buf\n\nproc getIndent(L: var Lexer, tok: var Token) =\n  tok.col = 0\n  tok.kind = tkIndent         # skip the newline (but include it in the token!)\n  tok.ival = getIndentAux(L, L.bufpos)\n  inc L.line\n  tok.line = L.line\n  L.col = tok.ival\n  tok.ival = max(tok.ival - L.baseIndent, 0)\n  tok.symbol = \"\\n\" & spaces(tok.ival)\n\nproc rawGetTok(L: var Lexer, tok: var Token) =\n  tok.symbol = \"\"\n  tok.ival = 0\n  if L.col == 0:\n    L.adornmentLine = false\n  var c = L.buf[L.bufpos]\n  case c\n  of 'a'..'z', 'A'..'Z', '\\x80'..'\\xFF', '0'..'9':\n    getThing(L, tok, SymChars)\n  of ' ', '\\t', '\\v', '\\f':\n    getThing(L, tok, {' ', '\\t'})\n    tok.kind = tkWhite\n    if L.buf[L.bufpos] in {'\\r', '\\n'}:\n      rawGetTok(L, tok)       # ignore spaces before \\n\n  of '\\r', '\\n':\n    getIndent(L, tok)\n    L.adornmentLine = false\n  of '!', '\\\"', '#', '$', '%', '&', '\\'',  '*', '+', ',', '-', '.',\n     '/', ':', ';', '<', '=', '>', '?', '@', '\\\\', '^', '_', '`',\n     '|', '~':\n    if L.col == 0:\n      L.adornmentLine = L.isCurrentLineAdornment()\n    getPunctAdornment(L, tok)\n  of '(', ')', '[', ']', '{', '}':\n    getBracket(L, tok)\n  else:\n    tok.line = L.line\n    tok.col = L.col\n    if c == '\\0':\n      tok.kind = tkEof\n    else:\n      tok.kind = tkOther\n      tok.symbol.add(c)\n      inc L.bufpos\n      inc L.col\n  tok.col = max(tok.col - L.baseIndent, 0)\n\nproc getTokens(buffer: string, tokens: var TokenSeq) =\n  var L: Lexer\n  var length = tokens.len\n  L.buf = cstring(buffer)\n  L.line = 0                  # skip UTF-8 BOM\n  if L.buf[0] == '\\xEF' and L.buf[1] == '\\xBB' and L.buf[2] == '\\xBF':\n    inc L.bufpos, 3\n  while true:\n    inc length\n    setLen(tokens, length)\n    let toEscape = L.escapeNext\n    rawGetTok(L, tokens[length - 1])\n    if toEscape: L.escapeNext = false\n    if tokens[length - 1].kind == tkEof: break\n  if tokens[0].kind == tkWhite:\n    # BUGFIX\n    tokens[0].ival = tokens[0].symbol.len\n    tokens[0].kind = tkIndent\n\ntype\n  LevelInfo = object\n    symbol: char         # adornment character\n    hasOverline: bool    # has also overline (besides underline)?\n    line: int            # the last line of this style occurrence\n                         # (for error message)\n    hasPeers: bool       # has headings on the same level of hierarchy?\n  LiteralBlockKind = enum  # RST-style literal blocks after `::`\n    lbNone,\n    lbIndentedLiteralBlock,\n    lbQuotedLiteralBlock\n  LevelMap = seq[LevelInfo]   # Saves for each possible title adornment\n                              # style its level in the current document.\n  SubstitutionKind = enum\n    rstSubstitution = \"substitution\",\n    hyperlinkAlias = \"hyperlink alias\",\n    implicitHyperlinkAlias = \"implicitly-generated hyperlink alias\"\n  Substitution = object\n    kind*: SubstitutionKind\n    key*: string\n    value*: PRstNode\n    info*: TLineInfo   # place where the substitution was defined\n  AnchorRule = enum\n    arInternalRst,  ## For automatically generated RST anchors (from\n                    ## headings, footnotes, inline internal targets):\n                    ## case-insensitive, 1-space-significant (by RST spec)\n    arNim   ## For anchors generated by ``docgen.rst``: Nim-style case\n            ## sensitivity, etc. (see `proc normalizeNimName`_ for details)\n    arHyperlink,  ## For links with manually set anchors in\n                  ## form `text <pagename.html#anchor>`_\n  RstAnchorKind = enum\n    manualDirectiveAnchor = \"manual directive anchor\",\n    manualInlineAnchor = \"manual inline anchor\",\n    footnoteAnchor = \"footnote anchor\",\n    headlineAnchor = \"implicitly-generated headline anchor\"\n  AnchorSubst = object\n    mainAnchor: ref string  # A reference name that will be inserted directly\n                            # into HTML/Latex. It's declared as `ref` because\n                            # it can be shared between aliases.\n    info: TLineInfo         # where the anchor was defined\n    priority: int\n    case kind: range[arInternalRst .. arNim]\n    of arInternalRst:\n      anchorType: RstAnchorKind\n    of arNim:\n      tooltip: string       # displayed tooltip for Nim-generated anchors\n      langSym: LangSymbol\n  AnchorSubstTable = Table[string, seq[AnchorSubst]]\n                         # use `seq` to account for duplicate anchors\n  FootnoteType = enum\n    fnManualNumber,     # manually numbered footnote like [3]\n    fnAutoNumber,       # auto-numbered footnote [#]\n    fnAutoNumberLabel,  # auto-numbered with label [#label]\n    fnAutoSymbol,       # auto-symbol footnote [*]\n    fnCitation          # simple text label like [citation2021]\n  FootnoteSubst = tuple\n    kind: FootnoteType  # discriminator\n    number: int         # valid for fnManualNumber (always) and fnAutoNumber,\n                        # fnAutoNumberLabel after resolveSubs is called\n    autoNumIdx: int     # order of occurence: fnAutoNumber, fnAutoNumberLabel\n    autoSymIdx: int     # order of occurence: fnAutoSymbol\n    label: string       # valid for fnAutoNumberLabel\n  RstFileTable* = object\n    filenameToIdx*: Table[string, FileIndex]\n    idxToFilename*: seq[string]\n  RstSharedState = object\n    options: RstParseOptions    # parsing options\n    hLevels: LevelMap           # hierarchy of heading styles\n    hTitleCnt: int              # =0 if no title, =1 if only main title,\n                                # =2 if both title and subtitle are present\n    hCurLevel: int              # current section level\n    currRole: string            # current interpreted text role\n    currRoleKind: RstNodeKind   # ... and its node kind\n    subs: seq[Substitution]     # substitutions\n    refs*: seq[Substitution]    # references\n    anchors*: AnchorSubstTable\n                                # internal target substitutions\n    lineFootnoteNum: seq[TLineInfo]     # footnote line, auto numbers .. [#]\n    lineFootnoteNumRef: seq[TLineInfo]  # footnote line, their reference [#]_\n    currFootnoteNumRef: int             # ... their counter for `resolveSubs`\n    lineFootnoteSym: seq[TLineInfo]     # footnote line, auto symbols .. [*]\n    lineFootnoteSymRef: seq[TLineInfo]  # footnote line, their reference [*]_\n    currFootnoteSymRef: int             # ... their counter for `resolveSubs`\n    footnotes: seq[FootnoteSubst] # correspondence b/w footnote label,\n                                  # number, order of occurrence\n    msgHandler: MsgHandler      # How to handle errors.\n    findFile: FindFileHandler   # How to find files.\n    filenames*: RstFileTable    # map file name <-> FileIndex (for storing\n                                # file names for warnings after 1st stage)\n    currFileIdx*: FileIndex     # current index in `filenames`\n    hasToc*: bool\n\n  PRstSharedState* = ref RstSharedState\n  RstParser = object of RootObj\n    idx*: int\n    tok*: TokenSeq\n    s*: PRstSharedState\n    indentStack*: seq[int]\n    line*, col*: int            ## initial line/column of whole text or\n                                ## documenation fragment that will be added\n                                ## in case of error/warning reporting to\n                                ## (relative) line/column of the token.\n    curAnchor*: string          # variable to track latest anchor in s.anchors\n    curAnchorName*: string      # corresponding name in human-readable format\n\n  EParseError* = object of ValueError\n\nconst\n  LineRstInit* = 1  ## Initial line number for standalone RST text\n  ColRstInit* = 0   ## Initial column number for standalone RST text\n                    ## (Nim global reporting adds ColOffset=1)\n  ColRstOffset* = 1 ## 1: a replica of ColOffset for internal use\n\ntemplate currentTok(p: RstParser): Token = p.tok[p.idx]\ntemplate prevTok(p: RstParser): Token = p.tok[p.idx - 1]\ntemplate nextTok(p: RstParser): Token = p.tok[p.idx + 1]\n\nproc whichMsgClass*(k: MsgKind): MsgClass =\n  ## returns which message class `k` belongs to.\n  case k.symbolName[1]\n  of 'e', 'E': result = mcError\n  of 'w', 'W': result = mcWarning\n  of 'h', 'H': result = mcHint\n  else: assert false, \"msgkind does not fit naming scheme\"\n\nproc defaultMsgHandler*(filename: string, line, col: int, msgkind: MsgKind,\n                        arg: string) =\n  let mc = msgkind.whichMsgClass\n  let a = $msgkind % arg\n  var message: string\n  toLocation(message, filename, line, col + ColRstOffset)\n  message.add \" $1: $2\" % [$mc, a]\n  if mc == mcError: raise newException(EParseError, message)\n  else: writeLine(stdout, message)\n\nproc defaultFindFile*(filename: string): string =\n  if fileExists(filename): result = filename\n  else: result = \"\"\n\nproc defaultRole(options: RstParseOptions): string =\n  if roNimFile in options: \"nim\" else: \"literal\"\n\nproc whichRoleAux(sym: string): RstNodeKind =\n  let r = sym.toLowerAscii\n  case r\n  of \"idx\": result = rnIdx\n  of \"literal\": result = rnInlineLiteral\n  of \"strong\": result = rnStrongEmphasis\n  of \"emphasis\": result = rnEmphasis\n  of \"sub\", \"subscript\": result = rnSub\n  of \"sup\", \"superscript\": result = rnSup\n  # literal and code are the same in our implementation\n  of \"code\": result = rnInlineLiteral\n  of \"program\", \"option\", \"tok\": result = rnCodeFragment\n  # c++ currently can be spelled only as cpp, c# only as csharp\n  elif getSourceLanguage(r) != langNone:\n    result = rnInlineCode\n  else:  # unknown role\n    result = rnUnknownRole\n\nproc len(filenames: RstFileTable): int = filenames.idxToFilename.len\n\nproc addFilename*(s: PRstSharedState, file1: string): FileIndex =\n  ## Returns index of filename, adding it if it has not been used before\n  let nextIdx = s.filenames.len.FileIndex\n  result = getOrDefault(s.filenames.filenameToIdx, file1, default = nextIdx)\n  if result == nextIdx:\n    s.filenames.filenameToIdx[file1] = result\n    s.filenames.idxToFilename.add file1\n\nproc setCurrFilename*(s: PRstSharedState, file1: string) =\n  s.currFileIdx = addFilename(s, file1)\n\nproc getFilename(filenames: RstFileTable, fid: FileIndex): string =\n  doAssert(0 <= fid.int and fid.int < filenames.len,\n      \"incorrect FileIndex $1 (range 0..$2)\" % [\n        $fid.int, $(filenames.len - 1)])\n  result = filenames.idxToFilename[fid.int]\n\nproc currFilename(s: PRstSharedState): string =\n  getFilename(s.filenames, s.currFileIdx)\n\nproc newRstSharedState*(options: RstParseOptions,\n                        filename: string,\n                        findFile: FindFileHandler,\n                        msgHandler: MsgHandler): PRstSharedState =\n  let r = defaultRole(options)\n  result = PRstSharedState(\n      currRole: r,\n      currRoleKind: whichRoleAux(r),\n      options: options,\n      msgHandler: if not isNil(msgHandler): msgHandler else: defaultMsgHandler,\n      findFile: if not isNil(findFile): findFile else: defaultFindFile\n  )\n  setCurrFilename(result, filename)\n\nproc curLine(p: RstParser): int = p.line + currentTok(p).line\n\nproc findRelativeFile(p: RstParser; filename: string): string =\n  result = p.s.currFilename.splitFile.dir / filename\n  if not fileExists(result):\n    result = p.s.findFile(filename)\n\nproc rstMessage(p: RstParser, msgKind: MsgKind, arg: string) =\n  p.s.msgHandler(p.s.currFilename, curLine(p),\n                             p.col + currentTok(p).col, msgKind, arg)\n\nproc rstMessage(s: PRstSharedState, msgKind: MsgKind, arg: string) =\n  s.msgHandler(s.currFilename, LineRstInit, ColRstInit, msgKind, arg)\n\nproc rstMessage*(filenames: RstFileTable, f: MsgHandler,\n                 info: TLineInfo, msgKind: MsgKind, arg: string) =\n  ## Print warnings using `info`, i.e. in 2nd-pass warnings for\n  ## footnotes/substitutions/references or from ``rstgen.nim``.\n  let file = getFilename(filenames, info.fileIndex)\n  f(file, info.line.int, info.col.int, msgKind, arg)\n\nproc rstMessage(p: RstParser, msgKind: MsgKind, arg: string, line, col: int) =\n  p.s.msgHandler(p.s.currFilename, p.line + line,\n                             p.col + col, msgKind, arg)\n\nproc rstMessage(p: RstParser, msgKind: MsgKind) =\n  p.s.msgHandler(p.s.currFilename, curLine(p),\n                             p.col + currentTok(p).col, msgKind,\n                             currentTok(p).symbol)\n\nproc currInd(p: RstParser): int =\n  result = p.indentStack[high(p.indentStack)]\n\nproc pushInd(p: var RstParser, ind: int) =\n  p.indentStack.add(ind)\n\nproc popInd(p: var RstParser) =\n  if p.indentStack.len > 1: setLen(p.indentStack, p.indentStack.len - 1)\n\n# Working with indentation in rst.nim\n# -----------------------------------\n#\n# Every line break has an associated tkIndent.\n# The tokenizer writes back the first column of next non-blank line\n# in all preceeding tkIndent tokens to the `ival` field of tkIndent.\n#\n# RST document is separated into body elements (B.E.), every of which\n# has a dedicated handler proc (or block of logic when B.E. is a block quote)\n# that should follow the next rule:\n#   Every B.E. handler proc should finish at tkIndent (newline)\n#   after its B.E. finishes.\n#   Then its callers (which is `parseSection` or another B.E. handler)\n#   check for tkIndent ival (without necessity to advance `p.idx`)\n#   and decide themselves whether they continue processing or also stop.\n#\n# An example::\n#\n#   L    RST text fragment                  indentation\n#     +--------------------+\n#   1 |                    | <- (empty line at the start of file) no tokens\n#   2 |First paragraph.    | <- tkIndent has ival=0, and next tkWord has col=0\n#   3 |                    | <- tkIndent has ival=0\n#   4 |* bullet item and   | <- tkIndent has ival=0, and next tkPunct has col=0\n#   5 |  its continuation  | <- tkIndent has ival=2, and next tkWord has col=2\n#   6 |                    | <- tkIndent has ival=4\n#   7 |    Block quote     | <- tkIndent has ival=4, and next tkWord has col=4\n#   8 |                    | <- tkIndent has ival=0\n#   9 |                    | <- tkIndent has ival=0\n#   10|Final paragraph     | <- tkIndent has ival=0, and tkWord has col=0\n#     +--------------------+\n#    C:01234\n#\n# Here parser starts with initial `indentStack=[0]` and then calls the\n# 1st `parseSection`:\n#\n#   - `parseSection` calls `parseParagraph` and \"First paragraph\" is parsed\n#   - bullet list handler is started at reaching ``*`` (L4 C0), it\n#     starts bullet item logic (L4 C2), which calls `pushInd(p, ind=2)`,\n#     then calls `parseSection` (2nd call, nested) which parses\n#     paragraph \"bullet list and its continuation\" and then starts\n#     a block quote logic (L7 C4).\n#     The block quote logic calls calls `pushInd(p, ind=4)` and\n#     calls `parseSection` again, so a (simplified) sequence of calls now is::\n#\n#       parseSection -> parseBulletList ->\n#         parseSection (+block quote logic) -> parseSection\n#\n#     3rd `parseSection` finishes, block quote logic calls `popInd(p)`,\n#     it returns to bullet item logic, which sees that next tkIndent has\n#     ival=0 and stops there since the required indentation for a bullet item\n#     is 2 and 0<2; the bullet item logic calls `popInd(p)`.\n#     Then bullet list handler checks that next tkWord (L10 C0) has the\n#     right indentation but does not have ``*`` so stops at tkIndent (L10).\n#   - 1st `parseSection` invocation calls `parseParagraph` and the\n#     \"Final paragraph\" is parsed.\n#\n# If a B.E. handler has advanced `p.idx` past tkIndent to check\n# whether it should continue its processing or not, and decided not to,\n# then this B.E. handler should step back (e.g. do `dec p.idx`).\n\nproc initParser(p: var RstParser, sharedState: PRstSharedState) =\n  p.indentStack = @[0]\n  p.tok = @[]\n  p.idx = 0\n  p.col = ColRstInit\n  p.line = LineRstInit\n  p.s = sharedState\n\nproc addNodesAux(n: PRstNode, result: var string) =\n  if n == nil:\n    return\n  if n.kind == rnLeaf:\n    result.add(n.text)\n  else:\n    for i in 0 ..< n.len: addNodesAux(n.sons[i], result)\n\nproc addNodes(n: PRstNode): string =\n  n.addNodesAux(result)\n\nproc linkName(n: PRstNode): string =\n  ## Returns a normalized reference name, see:\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#reference-names\n  n.addNodes.toLowerAscii\n\nproc rstnodeToRefnameAux(n: PRstNode, r: var string, b: var bool) =\n  template special(s) =\n    if b:\n      r.add('-')\n      b = false\n    r.add(s)\n\n  if n == nil: return\n  if n.kind == rnLeaf:\n    for i in 0 ..< n.text.len:\n      case n.text[i]\n      of '0'..'9':\n        if b:\n          r.add('-')\n          b = false\n        if r.len == 0: r.add('Z')\n        r.add(n.text[i])\n      of 'a'..'z', '\\128'..'\\255':\n        if b:\n          r.add('-')\n          b = false\n        r.add(n.text[i])\n      of 'A'..'Z':\n        if b:\n          r.add('-')\n          b = false\n        r.add(chr(ord(n.text[i]) - ord('A') + ord('a')))\n      of '$': special \"dollar\"\n      of '%': special \"percent\"\n      of '&': special \"amp\"\n      of '^': special \"roof\"\n      of '!': special \"emark\"\n      of '?': special \"qmark\"\n      of '*': special \"star\"\n      of '+': special \"plus\"\n      of '-': special \"minus\"\n      of '/': special \"slash\"\n      of '\\\\': special \"backslash\"\n      of '=': special \"eq\"\n      of '<': special \"lt\"\n      of '>': special \"gt\"\n      of '~': special \"tilde\"\n      of ':': special \"colon\"\n      of '.': special \"dot\"\n      of '@': special \"at\"\n      of '|': special \"bar\"\n      else:\n        if r.len > 0: b = true\n  else:\n    for i in 0 ..< n.len: rstnodeToRefnameAux(n.sons[i], r, b)\n\nproc rstnodeToRefname(n: PRstNode): string =\n  var b = false\n  rstnodeToRefnameAux(n, result, b)\n\nproc findSub(s: PRstSharedState, n: PRstNode): int =\n  var key = addNodes(n)\n  # the spec says: if no exact match, try one without case distinction:\n  for i in countup(0, high(s.subs)):\n    if key == s.subs[i].key:\n      return i\n  for i in countup(0, high(s.subs)):\n    if cmpIgnoreStyle(key, s.subs[i].key) == 0:\n      return i\n  result = -1\n\nproc lineInfo(p: RstParser, iTok: int): TLineInfo =\n  result.col = int16(p.col + p.tok[iTok].col)\n  result.line = uint16(p.line + p.tok[iTok].line)\n  result.fileIndex = p.s.currFileIdx\n\nproc lineInfo(p: RstParser): TLineInfo = lineInfo(p, p.idx)\n# TODO: we need this simplification because we don't preserve exact starting\n# token of currently parsed element:\nproc prevLineInfo(p: RstParser): TLineInfo = lineInfo(p, p.idx-1)\n\nproc setSub(p: var RstParser, key: string, value: PRstNode) =\n  var length = p.s.subs.len\n  for i in 0 ..< length:\n    if key == p.s.subs[i].key:\n      p.s.subs[i].value = value\n      return\n  p.s.subs.add(Substitution(key: key, value: value, info: prevLineInfo(p)))\n\nproc setRef(p: var RstParser, key: string, value: PRstNode,\n            refType: SubstitutionKind) =\n  var length = p.s.refs.len\n  for i in 0 ..< length:\n    if key == p.s.refs[i].key:\n      if p.s.refs[i].value.addNodes != value.addNodes:\n        rstMessage(p, mwRedefinitionOfLabel, key)\n      p.s.refs[i].value = value\n      return\n  p.s.refs.add(Substitution(kind: refType, key: key, value: value,\n                            info: prevLineInfo(p)))\n\nproc findRef(s: PRstSharedState, key: string): seq[Substitution] =\n  for i in countup(0, high(s.refs)):\n    if key == s.refs[i].key:\n      result.add s.refs[i]\n\n# Ambiguity in links: we don't follow procedure of removing implicit targets\n# defined in https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#implicit-hyperlink-targets\n# Instead we just give explicit links a higher priority than to implicit ones\n# and report ambiguities as warnings. Hopefully it is easy to remove\n# ambiguities manually. Nim auto-generated links from ``docgen.nim``\n# have lowest priority: 1 (for procs) and below for other symbol types.\n\nproc refPriority(k: SubstitutionKind): int =\n  case k\n  of rstSubstitution: result = 8\n  of hyperlinkAlias: result = 7\n  of implicitHyperlinkAlias: result = 2\n\nproc internalRefPriority(k: RstAnchorKind): int =\n  case k\n  of manualDirectiveAnchor: result = 6\n  of manualInlineAnchor: result = 5\n  of footnoteAnchor: result = 4\n  of headlineAnchor: result = 3\n\nproc addAnchorRst(p: var RstParser, name: string, refn: string, reset: bool,\n                  anchorType: RstAnchorKind) =\n  ## Adds anchor `refn` with an alias `name` and\n  ## updates the corresponding `curAnchor` / `curAnchorName`.\n  let prio = internalRefPriority(anchorType)\n  if p.curAnchorName == \"\":\n    var anchRef = new string\n    anchRef[] = refn\n    p.s.anchors.mgetOrPut(name, newSeq[AnchorSubst]()).add(\n        AnchorSubst(kind: arInternalRst, mainAnchor: anchRef, priority: prio,\n                    info: prevLineInfo(p), anchorType: anchorType))\n  else:\n    # override previous mainAnchor by `ref` in all aliases\n    var anchRef = p.s.anchors[p.curAnchorName][0].mainAnchor\n    anchRef[] = refn\n    p.s.anchors.mgetOrPut(name, newSeq[AnchorSubst]()).add(\n        AnchorSubst(kind: arInternalRst, mainAnchor: anchRef, priority: prio,\n                    info: prevLineInfo(p), anchorType: anchorType))\n  if reset:\n    p.curAnchor = \"\"\n    p.curAnchorName = \"\"\n  else:\n    p.curAnchor = refn\n    p.curAnchorName = name\n\nproc addAnchorNim*(s: var PRstSharedState, refn: string, tooltip: string,\n                   langSym: LangSymbol, priority: int,\n                   info: TLineInfo) =\n  ## Adds an anchor `refn` (`mainAnchor`), which follows\n  ## the rule `arNim` (i.e. a symbol in ``*.nim`` file)\n  var anchRef = new string\n  anchRef[] = refn\n  s.anchors.mgetOrPut(langSym.name, newSeq[AnchorSubst]()).add(\n      AnchorSubst(kind: arNim, mainAnchor: anchRef, langSym: langSym,\n                  tooltip: tooltip, priority: priority,\n                  info: info))\n\nproc findMainAnchorNim(s: PRstSharedState, signature: PRstNode,\n                       info: TLineInfo):\n                      seq[AnchorSubst] =\n  let langSym = toLangSymbol(signature)\n  let substitutions = s.anchors.getOrDefault(langSym.name,\n                                             newSeq[AnchorSubst]())\n  if substitutions.len == 0:\n    return\n  # map symKind (like \"proc\") -> found symbols/groups:\n  var found: Table[string, seq[AnchorSubst]]\n  for s in substitutions:\n    if s.kind == arNim:\n      if match(s.langSym, langSym):\n        found.mgetOrPut(s.langSym.symKind, newSeq[AnchorSubst]()).add s\n  for symKind, sList in found:\n    if sList.len == 1:\n      result.add sList[0]\n    else:  # > 1, there are overloads, potential ambiguity in this `symKind`\n      if langSym.parametersProvided:\n        # there are non-group signatures, select only them\n        for s in sList:\n          if not s.langSym.isGroup:\n            result.add s\n      else:  # when there are many overloads a link like foo_ points to all\n             # of them, so selecting the group\n        var foundGroup = false\n        for s in sList:\n          if s.langSym.isGroup:\n            result.add s\n            foundGroup = true\n            break\n        doAssert foundGroup, \"docgen has not generated the group\"\n\nproc findMainAnchorRst(s: PRstSharedState, linkText: string, info: TLineInfo):\n                      seq[AnchorSubst] =\n  let name = linkText.toLowerAscii\n  let substitutions = s.anchors.getOrDefault(name, newSeq[AnchorSubst]())\n  for s in substitutions:\n    if s.kind == arInternalRst:\n      result.add s\n\nproc addFootnoteNumManual(p: var RstParser, num: int) =\n  ## add manually-numbered footnote\n  for fnote in p.s.footnotes:\n    if fnote.number == num:\n      rstMessage(p, mwRedefinitionOfLabel, $num)\n      return\n  p.s.footnotes.add((fnManualNumber, num, -1, -1, $num))\n\nproc addFootnoteNumAuto(p: var RstParser, label: string) =\n  ## add auto-numbered footnote.\n  ## Empty label [#] means it'll be resolved by the occurrence.\n  if label == \"\":  # simple auto-numbered [#]\n    p.s.lineFootnoteNum.add lineInfo(p)\n    p.s.footnotes.add((fnAutoNumber, -1, p.s.lineFootnoteNum.len, -1, label))\n  else:           # auto-numbered with label [#label]\n    for fnote in p.s.footnotes:\n      if fnote.label == label:\n        rstMessage(p, mwRedefinitionOfLabel, label)\n        return\n    p.s.footnotes.add((fnAutoNumberLabel, -1, -1, -1, label))\n\nproc addFootnoteSymAuto(p: var RstParser) =\n  p.s.lineFootnoteSym.add lineInfo(p)\n  p.s.footnotes.add((fnAutoSymbol, -1, -1, p.s.lineFootnoteSym.len, \"\"))\n\nproc orderFootnotes(s: PRstSharedState) =\n  ## numerate auto-numbered footnotes taking into account that all\n  ## manually numbered ones always have preference.\n  ## Save the result back to `s.footnotes`.\n\n  # Report an error if found any mismatch in number of automatic footnotes\n  proc listFootnotes(locations: seq[TLineInfo]): string =\n    var lines: seq[string]\n    for info in locations:\n      if s.filenames.len > 1:\n        let file = getFilename(s.filenames, info.fileIndex)\n        lines.add file & \":\"\n      else:  # no need to add file name here if there is only 1\n        lines.add \"\"\n      lines[^1].add $info.line\n    result.add $lines.len & \" (lines \" & join(lines, \", \") & \")\"\n  if s.lineFootnoteNum.len != s.lineFootnoteNumRef.len:\n    rstMessage(s, meFootnoteMismatch,\n      \"$1 != $2\" % [listFootnotes(s.lineFootnoteNum),\n                    listFootnotes(s.lineFootnoteNumRef)] &\n        \" for auto-numbered footnotes\")\n  if s.lineFootnoteSym.len != s.lineFootnoteSymRef.len:\n    rstMessage(s, meFootnoteMismatch,\n      \"$1 != $2\" % [listFootnotes(s.lineFootnoteSym),\n                    listFootnotes(s.lineFootnoteSymRef)] &\n        \" for auto-symbol footnotes\")\n\n  var result: seq[FootnoteSubst]\n  var manuallyN, autoN, autoSymbol: seq[FootnoteSubst]\n  for fs in s.footnotes:\n    if fs.kind == fnManualNumber: manuallyN.add fs\n    elif fs.kind in {fnAutoNumber, fnAutoNumberLabel}: autoN.add fs\n    else: autoSymbol.add fs\n\n  if autoN.len == 0:\n    result = manuallyN\n  else:\n    # fill gaps between manually numbered footnotes in ascending order\n    manuallyN.sort()  # sort by number - its first field\n    var lst = initSinglyLinkedList[FootnoteSubst]()\n    for elem in manuallyN: lst.append(elem)\n    var firstAuto = 0\n    if lst.head == nil or lst.head.value.number != 1:\n      # no manual footnote [1], start numeration from 1 for auto-numbered\n      lst.prepend (autoN[0].kind, 1, autoN[0].autoNumIdx, -1, autoN[0].label)\n      firstAuto = 1\n    var curNode = lst.head\n    var nextNode: SinglyLinkedNode[FootnoteSubst]\n    # go simultaneously through `autoN` and `lst` looking for gaps\n    for (kind, x, autoNumIdx, y, label) in autoN[firstAuto .. ^1]:\n      while (nextNode = curNode.next; nextNode != nil):\n        if nextNode.value.number - curNode.value.number > 1:\n          # gap found, insert new node `n` between curNode and nextNode:\n          var n = newSinglyLinkedNode((kind, curNode.value.number + 1,\n                                       autoNumIdx, -1, label))\n          curNode.next = n\n          n.next = nextNode\n          curNode = n\n          break\n        else:\n          curNode = nextNode\n      if nextNode == nil:  # no gap found, just append\n        lst.append (kind, curNode.value.number + 1, autoNumIdx, -1, label)\n        curNode = lst.tail\n    result = lst.toSeq\n\n  # we use ASCII symbols instead of those recommended in RST specification:\n  const footnoteAutoSymbols = [\"*\", \"^\", \"+\", \"=\", \"~\", \"$\", \"@\", \"%\", \"&\"]\n  for fs in autoSymbol:\n    # assignment order: *, **, ***, ^, ^^, ^^^, ... &&&, ****, *****, ...\n    let i = fs.autoSymIdx - 1\n    let symbolNum = (i div 3) mod footnoteAutoSymbols.len\n    let nSymbols = (1 + i mod 3) + 3 * (i div (3 * footnoteAutoSymbols.len))\n    let label = footnoteAutoSymbols[symbolNum].repeat(nSymbols)\n    result.add((fs.kind, -1, -1, fs.autoSymIdx, label))\n\n  s.footnotes = result\n\nproc getFootnoteNum(s: PRstSharedState, label: string): int =\n  ## get number from label. Must be called after `orderFootnotes`.\n  result = -1\n  for fnote in s.footnotes:\n    if fnote.label == label:\n      return fnote.number\n\nproc getFootnoteNum(s: PRstSharedState, order: int): int =\n  ## get number from occurrence. Must be called after `orderFootnotes`.\n  result = -1\n  for fnote in s.footnotes:\n    if fnote.autoNumIdx == order:\n      return fnote.number\n\nproc getAutoSymbol(s: PRstSharedState, order: int): string =\n  ## get symbol from occurrence of auto-symbol footnote.\n  result = \"???\"\n  for fnote in s.footnotes:\n    if fnote.autoSymIdx == order:\n      return fnote.label\n\nproc newRstNodeA(p: var RstParser, kind: RstNodeKind): PRstNode =\n  ## create node and consume the current anchor\n  result = newRstNode(kind)\n  if p.curAnchor != \"\":\n    result.anchor = p.curAnchor\n    p.curAnchor = \"\"\n    p.curAnchorName = \"\"\n\ntemplate newLeaf(s: string): PRstNode = newRstLeaf(s)\n\nproc newLeaf(p: var RstParser): PRstNode =\n  result = newLeaf(currentTok(p).symbol)\n\nproc validRefnamePunct(x: string): bool =\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#reference-names\n  x.len == 1 and x[0] in {'-', '_', '.', ':', '+'}\n\nfunc getRefnameIdx(p: RstParser, startIdx: int): int =\n  ## Gets last token index of a refname (\"word\" in RST terminology):\n  ##\n  ##   reference names are single words consisting of alphanumerics plus\n  ##   isolated (no two adjacent) internal hyphens, underscores, periods,\n  ##   colons and plus signs; no whitespace or other characters are allowed.\n  ##\n  ## Refnames are used for:\n  ## - reference names\n  ## - role names\n  ## - directive names\n  ## - footnote labels\n  ##\n  # TODO: use this func in all other relevant places\n  var j = startIdx\n  if p.tok[j].kind == tkWord:\n    inc j\n    while p.tok[j].kind == tkPunct and validRefnamePunct(p.tok[j].symbol) and\n        p.tok[j+1].kind == tkWord:\n      inc j, 2\n  result = j - 1\n\nfunc getRefname(p: RstParser, startIdx: int): (string, int) =\n  let lastIdx = getRefnameIdx(p, startIdx)\n  result[1] = lastIdx\n  for j in startIdx..lastIdx:\n    result[0].add p.tok[j].symbol\n\nproc getReferenceName(p: var RstParser, endStr: string): PRstNode =\n  var res = newRstNode(rnInner)\n  while true:\n    case currentTok(p).kind\n    of tkWord, tkOther, tkWhite:\n      res.add(newLeaf(p))\n    of tkPunct:\n      if currentTok(p).symbol == endStr:\n        inc p.idx\n        break\n      else:\n        res.add(newLeaf(p))\n    else:\n      rstMessage(p, meExpected, endStr)\n      break\n    inc p.idx\n  result = res\n\nproc untilEol(p: var RstParser): PRstNode =\n  result = newRstNode(rnInner)\n  while currentTok(p).kind notin {tkIndent, tkEof}:\n    result.add(newLeaf(p))\n    inc p.idx\n\nproc expect(p: var RstParser, tok: string) =\n  if currentTok(p).symbol == tok: inc p.idx\n  else: rstMessage(p, meExpected, tok)\n\nproc inlineMarkdownEnd(p: RstParser): bool =\n  result = prevTok(p).kind notin {tkIndent, tkWhite}\n  ## (For a special case of ` we don't allow spaces surrounding it\n  ## unlike original Markdown because this behavior confusing/useless)\n\nproc inlineRstEnd(p: RstParser): bool =\n  # rst rules: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules\n  # Rule 2:\n  result = prevTok(p).kind notin {tkIndent, tkWhite}\n  if not result: return\n  # Rule 7:\n  result = nextTok(p).kind in {tkIndent, tkWhite, tkEof} or\n      nextTok(p).symbol[0] in\n      {'\\'', '\\\"', ')', ']', '}', '>', '-', '/', '\\\\', ':', '.', ',', ';', '!', '?', '_'}\n\nproc isInlineMarkupEnd(p: RstParser, markup: string, exact: bool): bool =\n  if exact:\n    result = currentTok(p).symbol == markup\n  else:\n    result = currentTok(p).symbol.endsWith markup\n    if (not result) and markup == \"``\":\n      # check that escaping may have splitted `` to 2 tokens ` and `\n      result = currentTok(p).symbol == \"`\" and prevTok(p).symbol == \"`\"\n  if not result: return\n  # surroundings check\n  if markup in [\"_\", \"__\"]:\n    result = inlineRstEnd(p)\n  else:\n    if roPreferMarkdown in p.s.options: result = inlineMarkdownEnd(p)\n    else: result = inlineRstEnd(p)\n\nproc rstRuleSurround(p: RstParser): bool =\n  result = true\n  # Rules 4 & 5:\n  if p.idx > 0:\n    var d: char\n    var c = prevTok(p).symbol[0]\n    case c\n    of '\\'', '\\\"': d = c\n    of '(': d = ')'\n    of '[': d = ']'\n    of '{': d = '}'\n    of '<': d = '>'\n    else: d = '\\0'\n    if d != '\\0': result = nextTok(p).symbol[0] != d\n\nproc inlineMarkdownStart(p: RstParser): bool =\n  result = nextTok(p).kind notin {tkIndent, tkWhite, tkEof}\n  if not result: return\n  # this rst rule is really nice, let us use it in Markdown mode too.\n  result = rstRuleSurround(p)\n\nproc inlineRstStart(p: RstParser): bool =\n  ## rst rules: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules\n  # Rule 6\n  result = p.idx == 0 or prevTok(p).kind in {tkIndent, tkWhite} or\n      prevTok(p).symbol[0] in {'\\'', '\\\"', '(', '[', '{', '<', '-', '/', ':', '_'}\n  if not result: return\n  # Rule 1:\n  result = nextTok(p).kind notin {tkIndent, tkWhite, tkEof}\n  if not result: return\n  result = rstRuleSurround(p)\n\nproc isInlineMarkupStart(p: RstParser, markup: string): bool =\n  if markup != \"_`\":\n    result = currentTok(p).symbol == markup\n  else:  # _` is a 2 token case\n    result = currentTok(p).symbol == \"_\" and nextTok(p).symbol == \"`\"\n  if not result: return\n  # surroundings check\n  if markup in [\"_\", \"__\", \"[\", \"|\"]:\n    # Note: we require space/punctuation even before [markdown link](...)\n    result = inlineRstStart(p)\n  else:\n    if roPreferMarkdown in p.s.options: result = inlineMarkdownStart(p)\n    else: result = inlineRstStart(p)\n\nproc match(p: RstParser, start: int, expr: string): bool =\n  # regular expressions are:\n  # special char     exact match\n  # 'w'              tkWord\n  # ' '              tkWhite\n  # 'a'              tkAdornment\n  # 'i'              tkIndent\n  # 'I'              tkIndent or tkEof\n  # 'p'              tkPunct\n  # 'T'              always true\n  # 'E'              whitespace, indent or eof\n  # 'e'              any enumeration sequence or '#' (for enumeration lists)\n  # 'x'              a..z or '#' (for enumeration lists)\n  # 'n'              0..9 or '#' (for enumeration lists)\n  var i = 0\n  var j = start\n  var last = expr.len - 1\n  while i <= last:\n    case expr[i]\n    of 'w':\n      let lastIdx = getRefnameIdx(p, j)\n      result = lastIdx >= j\n      if result: j = lastIdx\n    of ' ': result = p.tok[j].kind == tkWhite\n    of 'i': result = p.tok[j].kind == tkIndent\n    of 'I': result = p.tok[j].kind in {tkIndent, tkEof}\n    of 'p': result = p.tok[j].kind == tkPunct\n    of 'a': result = p.tok[j].kind == tkAdornment\n    of 'o': result = p.tok[j].kind == tkOther\n    of 'T': result = true\n    of 'E': result = p.tok[j].kind in {tkEof, tkWhite, tkIndent}\n    of 'e', 'x', 'n':\n      result = p.tok[j].kind == tkWord or p.tok[j].symbol == \"#\"\n      if result:\n        case p.tok[j].symbol[0]\n        of '#': result = true\n        of 'a'..'z', 'A'..'Z':\n          result = expr[i] in {'e', 'x'} and p.tok[j].symbol.len == 1\n        of '0'..'9':\n          result = expr[i] in {'e', 'n'} and\n                     allCharsInSet(p.tok[j].symbol, {'0'..'9'})\n        else: result = false\n    else:\n      var c = expr[i]\n      var length = 0\n      while i <= last and expr[i] == c:\n        inc i\n        inc length\n      dec i\n      result = p.tok[j].kind in {tkPunct, tkAdornment} and\n          p.tok[j].symbol.len == length and p.tok[j].symbol[0] == c\n    if not result: return\n    inc j\n    inc i\n  result = true\n\nproc fixupEmbeddedRef(n, a, b: PRstNode) =\n  var sep = - 1\n  for i in countdown(n.len - 2, 0):\n    if n.sons[i].text == \"<\":\n      sep = i\n      break\n  var incr = if sep > 0 and n.sons[sep - 1].text[0] == ' ': 2 else: 1\n  for i in countup(0, sep - incr): a.add(n.sons[i])\n  for i in countup(sep + 1, n.len - 2): b.add(n.sons[i])\n\nproc whichRole(p: RstParser, sym: string): RstNodeKind =\n  result = whichRoleAux(sym)\n  if result == rnUnknownRole:\n    rstMessage(p, mwUnsupportedLanguage, sym)\n\nproc toInlineCode(n: PRstNode, language: string): PRstNode =\n  ## Creates rnInlineCode and attaches `n` contents as code (in 3rd son).\n  result = newRstNode(rnInlineCode, info=n.info)\n  let args = newRstNode(rnDirArg)\n  var lang = language\n  if language == \"cpp\": lang = \"c++\"\n  elif language == \"csharp\": lang = \"c#\"\n  args.add newLeaf(lang)\n  result.add args\n  result.add PRstNode(nil)\n  var lb = newRstNode(rnLiteralBlock)\n  var s: string\n  for i in n.sons:\n    assert i.kind == rnLeaf\n    s.add i.text\n  lb.add newLeaf(s)\n  result.add lb\n\nproc toOtherRole(n: PRstNode, kind: RstNodeKind, roleName: string): PRstNode =\n  let newN = newRstNode(rnInner, n.sons)\n  let newSons = @[newN, newLeaf(roleName)]\n  result = newRstNode(kind, newSons)\n\nproc parsePostfix(p: var RstParser, n: PRstNode): PRstNode =\n  ## Finalizes node `n` that was tentatively determined as interpreted text.\n  var newKind = n.kind\n  var newSons = n.sons\n\n  proc finalizeInterpreted(node: PRstNode, newKind: RstNodeKind,\n                           newSons: seq[PRstNode], roleName: string):\n                          PRstNode {.nimcall.} =\n    # fixes interpreted text (`x` or `y`:role:) to proper internal AST format\n    if newKind in {rnUnknownRole, rnCodeFragment}:\n      result = node.toOtherRole(newKind, roleName)\n    elif newKind == rnInlineCode:\n      result = node.toInlineCode(language=roleName)\n    else:\n      result = newRstNode(newKind, newSons)\n\n  if isInlineMarkupEnd(p, \"_\", exact=true) or\n      isInlineMarkupEnd(p, \"__\", exact=true):\n    inc p.idx\n    if p.tok[p.idx-2].symbol == \"`\" and p.tok[p.idx-3].symbol == \">\":\n      var a = newRstNode(rnInner)\n      var b = newRstNode(rnInner)\n      fixupEmbeddedRef(n, a, b)\n      if a.len == 0:\n        newKind = rnStandaloneHyperlink\n        newSons = @[b]\n      else:\n        newKind = rnHyperlink\n        newSons = @[a, b]\n        setRef(p, rstnodeToRefname(a), b, implicitHyperlinkAlias)\n      result = newRstNode(newKind, newSons)\n    else:  # some link that will be resolved in `resolveSubs`\n      newKind = rnRef\n      result = newRstNode(newKind, sons=newSons, info=n.info)\n  elif match(p, p.idx, \":w:\"):\n    # a role:\n    let (roleName, lastIdx) = getRefname(p, p.idx+1)\n    newKind = whichRole(p, roleName)\n    result = n.finalizeInterpreted(newKind, newSons, roleName)\n    p.idx = lastIdx + 2\n  else:\n    result = n.finalizeInterpreted(p.s.currRoleKind, newSons, p.s.currRole)\n\nproc matchVerbatim(p: RstParser, start: int, expr: string): int =\n  result = start\n  var j = 0\n  while j < expr.len and result < p.tok.len and\n        continuesWith(expr, p.tok[result].symbol, j):\n    inc j, p.tok[result].symbol.len\n    inc result\n  if j < expr.len: result = 0\n\nproc parseSmiley(p: var RstParser): PRstNode =\n  if currentTok(p).symbol[0] notin SmileyStartChars: return\n  for key, val in items(Smilies):\n    let m = matchVerbatim(p, p.idx, key)\n    if m > 0:\n      p.idx = m\n      result = newRstNode(rnSmiley)\n      result.text = val\n      return\n\nproc isUrl(p: RstParser, i: int): bool =\n  result = p.tok[i+1].symbol == \":\" and p.tok[i+2].symbol == \"//\" and\n    p.tok[i+3].kind == tkWord and\n    p.tok[i].symbol in [\"http\", \"https\", \"ftp\", \"telnet\", \"file\"]\n\nproc checkParen(token: Token, parensStack: var seq[char]): bool {.inline.} =\n  ## Returns `true` iff `token` is a closing parenthesis for some\n  ## previous opening parenthesis saved in `parensStack`.\n  ## This is according Markdown balanced parentheses rule\n  ## (https://spec.commonmark.org/0.29/#link-destination)\n  ## to allow links like\n  ## https://en.wikipedia.org/wiki/APL_(programming_language),\n  ## we use it for RST also.\n  result = false\n  if token.kind == tkPunct:\n    let c = token.symbol[0]\n    if c in {'(', '[', '{'}:  # push\n      parensStack.add c\n    elif c in {')', ']', '}'}:  # try pop\n      # a case like ([) inside a link is allowed and [ is also `pop`ed:\n      for i in countdown(parensStack.len - 1, 0):\n        if (parensStack[i] == '(' and c == ')' or\n            parensStack[i] == '[' and c == ']' or\n            parensStack[i] == '{' and c == '}'):\n          parensStack.setLen i\n          result = true\n          break\n\nproc parseUrl(p: var RstParser): PRstNode =\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#standalone-hyperlinks\n  result = newRstNode(rnStandaloneHyperlink)\n  var lastIdx = p.idx\n  var closedParenIdx = p.idx - 1  # for balanced parens rule\n  var parensStack: seq[char]\n  while p.tok[lastIdx].kind in {tkWord, tkPunct, tkOther}:\n    let isClosing = checkParen(p.tok[lastIdx], parensStack)\n    if isClosing:\n      closedParenIdx = lastIdx\n    inc lastIdx\n  dec lastIdx\n  # standalone URL can not end with punctuation in RST\n  while lastIdx > closedParenIdx and p.tok[lastIdx].kind == tkPunct and\n      p.tok[lastIdx].symbol != \"/\":\n    dec lastIdx\n  var s = \"\"\n  for i in p.idx .. lastIdx: s.add p.tok[i].symbol\n  result.add s\n  p.idx = lastIdx + 1\n\nproc parseWordOrRef(p: var RstParser, father: PRstNode) =\n  ## Parses a normal word or may be a reference or URL.\n  if nextTok(p).kind != tkPunct:  # <- main path, a normal word\n    father.add newLeaf(p)\n    inc p.idx\n  elif isUrl(p, p.idx):           # URL http://something\n    father.add parseUrl(p)\n  else:\n    # check for reference (probably, long one like some.ref.with.dots_ )\n    var saveIdx = p.idx\n    var reference: PRstNode = nil\n    inc p.idx\n    while currentTok(p).kind in {tkWord, tkPunct}:\n      if currentTok(p).kind == tkPunct:\n        if isInlineMarkupEnd(p, \"_\", exact=true):\n          reference = newRstNode(rnRef, info=lineInfo(p, saveIdx))\n          break\n        if not validRefnamePunct(currentTok(p).symbol):\n          break\n      inc p.idx\n    if reference != nil:\n      for i in saveIdx..p.idx-1: reference.add newLeaf(p.tok[i].symbol)\n      father.add reference\n      inc p.idx  # skip final _\n    else:  # 1 normal word\n      father.add newLeaf(p.tok[saveIdx].symbol)\n      p.idx = saveIdx + 1\n\nproc parseBackslash(p: var RstParser, father: PRstNode) =\n  assert(currentTok(p).kind == tkPunct)\n  if currentTok(p).symbol == \"\\\\\":\n    # XXX: Unicode?\n    inc p.idx\n    if currentTok(p).kind != tkWhite: father.add(newLeaf(p))\n    if currentTok(p).kind != tkEof: inc p.idx\n  else:\n    father.add(newLeaf(p))\n    inc p.idx\n\nproc parseUntil(p: var RstParser, father: PRstNode, postfix: string,\n                interpretBackslash: bool) =\n  let\n    line = currentTok(p).line\n    col = currentTok(p).col\n  inc p.idx\n  while true:\n    case currentTok(p).kind\n    of tkPunct:\n      if isInlineMarkupEnd(p, postfix, exact=false):\n        let l = currentTok(p).symbol.len\n        if l > postfix.len:\n          # handle cases like *emphasis with stars****. (It's valid RST!)\n          father.add newLeaf(currentTok(p).symbol[0 ..< l - postfix.len])\n        elif postfix == \"``\" and currentTok(p).symbol == \"`\" and\n            prevTok(p).symbol == \"`\":\n          # handle cases like ``literal\\`` - delete ` already added after \\\n          father.sons.setLen(father.sons.len - 1)\n        inc p.idx\n        break\n      else:\n        if postfix == \"`\":\n          if currentTok(p).symbol == \"\\\\\":\n            if nextTok(p).symbol == \"\\\\\":\n              father.add newLeaf(\"\\\\\")\n              father.add newLeaf(\"\\\\\")\n              inc p.idx, 2\n            elif nextTok(p).symbol == \"`\":  # escape `\n              father.add newLeaf(\"`\")\n              inc p.idx, 2\n            else:\n              father.add newLeaf(\"\\\\\")\n              inc p.idx\n          else:\n            father.add(newLeaf(p))\n            inc p.idx\n        else:\n          if interpretBackslash:\n            parseBackslash(p, father)\n          else:\n            father.add(newLeaf(p))\n            inc p.idx\n    of tkAdornment, tkWord, tkOther:\n      father.add(newLeaf(p))\n      inc p.idx\n    of tkIndent:\n      father.add newLeaf(\" \")\n      inc p.idx\n      if currentTok(p).kind == tkIndent:\n        rstMessage(p, meExpected, postfix, line, col)\n        break\n    of tkWhite:\n      father.add newLeaf(\" \")\n      inc p.idx\n    else: rstMessage(p, meExpected, postfix, line, col)\n\nproc parseMarkdownCodeblock(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnCodeBlock)\n  result.info = lineInfo(p)\n  var args = newRstNode(rnDirArg)\n  if currentTok(p).kind == tkWord:\n    args.add(newLeaf(p))\n    inc p.idx\n  else:\n    args = nil\n  var n = newLeaf(\"\")\n  while true:\n    case currentTok(p).kind\n    of tkEof:\n      rstMessage(p, meExpected, \"```\")\n      break\n    of tkPunct, tkAdornment:\n      if currentTok(p).symbol == \"```\":\n        inc p.idx\n        break\n      else:\n        n.text.add(currentTok(p).symbol)\n        inc p.idx\n    else:\n      n.text.add(currentTok(p).symbol)\n      inc p.idx\n  var lb = newRstNode(rnLiteralBlock)\n  lb.add(n)\n  result.add(args)\n  result.add(PRstNode(nil))\n  result.add(lb)\n\nproc parseMarkdownLink(p: var RstParser; father: PRstNode): bool =\n  result = true\n  var desc, link = \"\"\n  var i = p.idx\n\n  var parensStack: seq[char]\n  template parse(endToken, dest) =\n    parensStack.setLen 0\n    inc i # skip begin token\n    while true:\n      if p.tok[i].kind in {tkEof, tkIndent}: return false\n      let isClosing = checkParen(p.tok[i], parensStack)\n      if p.tok[i].symbol == endToken and not isClosing:\n        break\n      dest.add p.tok[i].symbol\n      inc i\n    inc i # skip end token\n\n  parse(\"]\", desc)\n  if p.tok[i].symbol != \"(\": return false\n  parse(\")\", link)\n  let child = newRstNode(rnHyperlink)\n  child.add desc\n  child.add link\n  # only commit if we detected no syntax error:\n  father.add child\n  p.idx = i\n  result = true\n\nproc getFootnoteType(label: PRstNode): (FootnoteType, int) =\n  if label.sons.len >= 1 and label.sons[0].kind == rnLeaf and\n      label.sons[0].text == \"#\":\n    if label.sons.len == 1:\n      result = (fnAutoNumber, -1)\n    else:\n      result = (fnAutoNumberLabel, -1)\n  elif label.len == 1 and label.sons[0].kind == rnLeaf and\n       label.sons[0].text == \"*\":\n    result = (fnAutoSymbol, -1)\n  elif label.len == 1 and label.sons[0].kind == rnLeaf:\n    try:\n      result = (fnManualNumber, parseInt(label.sons[0].text))\n    except:\n      result = (fnCitation, -1)\n  else:\n    result = (fnCitation, -1)\n\nproc parseFootnoteName(p: var RstParser, reference: bool): PRstNode =\n  ## parse footnote/citation label. Precondition: start at `[`.\n  ## Label text should be valid ref. name symbol, otherwise nil is returned.\n  var i = p.idx + 1\n  result = newRstNode(rnInner)\n  while true:\n    if p.tok[i].kind in {tkEof, tkIndent, tkWhite}:\n      return nil\n    if p.tok[i].kind == tkPunct:\n      case p.tok[i].symbol:\n      of \"]\":\n        if i > p.idx + 1 and (not reference or (p.tok[i+1].kind == tkPunct and p.tok[i+1].symbol == \"_\")):\n          inc i                # skip ]\n          if reference: inc i  # skip _\n          break  # to succeed, it's a footnote/citation indeed\n        else:\n          return nil\n      of \"#\":\n        if i != p.idx + 1:\n          return nil\n      of \"*\":\n        if i != p.idx + 1 and p.tok[i].kind != tkPunct and p.tok[i+1].symbol != \"]\":\n          return nil\n      else:\n        if not validRefnamePunct(p.tok[i].symbol):\n          return nil\n    result.add newLeaf(p.tok[i].symbol)\n    inc i\n  p.idx = i\n\nproc parseInline(p: var RstParser, father: PRstNode) =\n  var n: PRstNode  # to be used in `if` condition\n  let saveIdx = p.idx\n  case currentTok(p).kind\n  of tkPunct:\n    if isInlineMarkupStart(p, \"***\"):\n      var n = newRstNode(rnTripleEmphasis)\n      parseUntil(p, n, \"***\", true)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"**\"):\n      var n = newRstNode(rnStrongEmphasis)\n      parseUntil(p, n, \"**\", true)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"*\"):\n      var n = newRstNode(rnEmphasis)\n      parseUntil(p, n, \"*\", true)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"_`\"):\n      var n = newRstNode(rnInlineTarget)\n      inc p.idx\n      parseUntil(p, n, \"`\", false)\n      let refn = rstnodeToRefname(n)\n      addAnchorRst(p, name = linkName(n), refn = refn, reset = true,\n                   anchorType=manualInlineAnchor)\n      father.add(n)\n    elif roSupportMarkdown in p.s.options and currentTok(p).symbol == \"```\":\n      inc p.idx\n      father.add(parseMarkdownCodeblock(p))\n    elif isInlineMarkupStart(p, \"``\"):\n      var n = newRstNode(rnInlineLiteral)\n      parseUntil(p, n, \"``\", false)\n      father.add(n)\n    elif match(p, p.idx, \":w:\") and\n        (var lastIdx = getRefnameIdx(p, p.idx + 1);\n         p.tok[lastIdx+2].symbol == \"`\"):\n      let (roleName, _) = getRefname(p, p.idx+1)\n      let k = whichRole(p, roleName)\n      var n = newRstNode(k)\n      p.idx = lastIdx + 2\n      if k == rnInlineCode:\n        n = n.toInlineCode(language=roleName)\n      parseUntil(p, n, \"`\", false) # bug #17260\n      if k in {rnUnknownRole, rnCodeFragment}:\n        n = n.toOtherRole(k, roleName)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"`\"):\n      var n = newRstNode(rnInterpretedText, info=lineInfo(p, p.idx+1))\n      parseUntil(p, n, \"`\", false) # bug #17260\n      n = parsePostfix(p, n)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"|\"):\n      var n = newRstNode(rnSubstitutionReferences, info=lineInfo(p, p.idx+1))\n      parseUntil(p, n, \"|\", false)\n      father.add(n)\n    elif roSupportMarkdown in p.s.options and\n        currentTok(p).symbol == \"[\" and nextTok(p).symbol != \"[\" and\n        parseMarkdownLink(p, father):\n      discard \"parseMarkdownLink already processed it\"\n    elif isInlineMarkupStart(p, \"[\") and nextTok(p).symbol != \"[\" and\n         (n = parseFootnoteName(p, reference=true); n != nil):\n      var nn = newRstNode(rnFootnoteRef)\n      nn.info = lineInfo(p, saveIdx+1)\n      nn.add n\n      let (fnType, _) = getFootnoteType(n)\n      case fnType\n      of fnAutoSymbol:\n        p.s.lineFootnoteSymRef.add lineInfo(p)\n      of fnAutoNumber:\n        p.s.lineFootnoteNumRef.add lineInfo(p)\n      else: discard\n      father.add(nn)\n    else:\n      if roSupportSmilies in p.s.options:\n        let n = parseSmiley(p)\n        if n != nil:\n          father.add(n)\n          return\n      parseBackslash(p, father)\n  of tkWord:\n    if roSupportSmilies in p.s.options:\n      let n = parseSmiley(p)\n      if n != nil:\n        father.add(n)\n        return\n    parseWordOrRef(p, father)\n  of tkAdornment, tkOther, tkWhite:\n    if roSupportMarkdown in p.s.options and currentTok(p).symbol == \"```\":\n      inc p.idx\n      father.add(parseMarkdownCodeblock(p))\n      return\n    if roSupportSmilies in p.s.options:\n      let n = parseSmiley(p)\n      if n != nil:\n        father.add(n)\n        return\n    father.add(newLeaf(p))\n    inc p.idx\n  else: discard\n\nproc getDirective(p: var RstParser): string =\n  result = \"\"\n  if currentTok(p).kind == tkWhite:\n    let (name, lastIdx) = getRefname(p, p.idx + 1)\n    let afterIdx = lastIdx + 1\n    if name.len > 0:\n      if p.tok[afterIdx].symbol == \"::\":\n        result = name\n        p.idx = afterIdx + 1\n        if currentTok(p).kind == tkWhite:\n          inc p.idx\n        elif currentTok(p).kind != tkIndent:\n          rstMessage(p, mwRstStyle,\n              \"whitespace or newline expected after directive \" & name)\n        result = result.toLowerAscii()\n      elif p.tok[afterIdx].symbol == \":\":\n        rstMessage(p, mwRstStyle,\n            \"double colon :: may be missing at end of '\" & name & \"'\",\n            p.tok[afterIdx].line, p.tok[afterIdx].col)\n      elif p.tok[afterIdx].kind == tkPunct and p.tok[afterIdx].symbol[0] == ':':\n        rstMessage(p, mwRstStyle,\n            \"too many colons for a directive (should be ::)\",\n            p.tok[afterIdx].line, p.tok[afterIdx].col)\n\nproc parseComment(p: var RstParser, col: int): PRstNode =\n  if currentTok(p).kind != tkEof and nextTok(p).kind == tkIndent:\n    inc p.idx              # empty comment\n  else:\n    while currentTok(p).kind != tkEof:\n      if currentTok(p).kind == tkIndent and currentTok(p).ival > col or\n         currentTok(p).kind != tkIndent and currentTok(p).col > col:\n        inc p.idx\n      else:\n        break\n  result = nil\n\nproc parseLine(p: var RstParser, father: PRstNode) =\n  while true:\n    case currentTok(p).kind\n    of tkWhite, tkWord, tkOther, tkPunct: parseInline(p, father)\n    else: break\n\nproc parseUntilNewline(p: var RstParser, father: PRstNode) =\n  while true:\n    case currentTok(p).kind\n    of tkWhite, tkWord, tkAdornment, tkOther, tkPunct: parseInline(p, father)\n    of tkEof, tkIndent: break\n\nproc parseSection(p: var RstParser, result: PRstNode) {.gcsafe.}\n\nproc tokenAfterNewline(p: RstParser, start: int): int =\n  result = start\n  while true:\n    case p.tok[result].kind\n    of tkEof:\n      break\n    of tkIndent:\n      inc result\n      break\n    else: inc result\n\nproc tokenAfterNewline(p: RstParser): int {.inline.} =\n  result = tokenAfterNewline(p, p.idx)\n\nproc getWrappableIndent(p: RstParser): int =\n  ## Gets baseline indentation for bodies of field lists and directives.\n  ## Handles situations like this (with possible de-indent in [case.3])::\n  ##\n  ##   :field:   definition                                          [case.1]\n  ##\n  ##   currInd   currentTok(p).col\n  ##   |         |\n  ##   v         v\n  ##\n  ##   .. Note:: defItem:                                            [case.2]\n  ##                 definition\n  ##\n  ##                 ^\n  ##                 |\n  ##                 nextIndent\n  ##\n  ##   .. Note:: - point1                                            [case.3]\n  ##       - point 2\n  ##\n  ##       ^\n  ##       |\n  ##       nextIndent\n  if currentTok(p).kind == tkIndent:\n    result = currentTok(p).ival\n  else:\n    var nextIndent = p.tok[tokenAfterNewline(p)-1].ival\n    if nextIndent <= currInd(p):          # parse only this line     [case.1]\n      result = currentTok(p).col\n    elif nextIndent >= currentTok(p).col: # may be a definition list [case.2]\n      result = currentTok(p).col\n    else:\n      result = nextIndent                 #                          [case.3]\n\nproc parseField(p: var RstParser): PRstNode =\n  ## Returns a parsed rnField node.\n  ##\n  ## rnField nodes have two children nodes, a rnFieldName and a rnFieldBody.\n  result = newRstNode(rnField, info=lineInfo(p))\n  var col = currentTok(p).col\n  var fieldname = newRstNode(rnFieldName)\n  parseUntil(p, fieldname, \":\", false)\n  var fieldbody = newRstNode(rnFieldBody)\n  if currentTok(p).kind == tkWhite: inc p.idx\n  let indent = getWrappableIndent(p)\n  if indent > col:\n    pushInd(p, indent)\n    parseSection(p, fieldbody)\n    popInd(p)\n  result.add(fieldname)\n  result.add(fieldbody)\n\nproc parseFields(p: var RstParser): PRstNode =\n  ## Parses fields for a section or directive block.\n  ##\n  ## This proc may return nil if the parsing doesn't find anything of value,\n  ## otherwise it will return a node of rnFieldList type with children.\n  result = nil\n  var atStart = p.idx == 0 and p.tok[0].symbol == \":\"\n  if currentTok(p).kind == tkIndent and nextTok(p).symbol == \":\" or\n      atStart:\n    var col = if atStart: currentTok(p).col else: currentTok(p).ival\n    result = newRstNodeA(p, rnFieldList)\n    if not atStart: inc p.idx\n    while true:\n      result.add(parseField(p))\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n          nextTok(p).symbol == \":\":\n        inc p.idx\n      else:\n        break\n\nproc getFieldValue*(n: PRstNode): string =\n  ## Returns the value of a specific ``rnField`` node.\n  ##\n  ## This proc will assert if the node is not of the expected type. The empty\n  ## string will be returned as a minimum. Any value in the rst will be\n  ## stripped form leading/trailing whitespace.\n  assert n.kind == rnField\n  assert n.len == 2\n  assert n.sons[0].kind == rnFieldName\n  assert n.sons[1].kind == rnFieldBody\n  result = addNodes(n.sons[1]).strip\n\nproc getFieldValue(n: PRstNode, fieldname: string): string =\n  if n.sons[1] == nil: return\n  if n.sons[1].kind != rnFieldList:\n    #InternalError(\"getFieldValue (2): \" & $n.sons[1].kind)\n    # We don't like internal errors here anymore as that would break the forum!\n    return\n  for i in 0 ..< n.sons[1].len:\n    var f = n.sons[1].sons[i]\n    if cmpIgnoreStyle(addNodes(f.sons[0]), fieldname) == 0:\n      result = addNodes(f.sons[1])\n      if result == \"\": result = \"\\x01\\x01\" # indicates that the field exists\n      return\n\nproc getArgument(n: PRstNode): string =\n  if n.sons[0] == nil: result = \"\"\n  else: result = addNodes(n.sons[0])\n\nproc parseDotDot(p: var RstParser): PRstNode {.gcsafe.}\nproc parseLiteralBlock(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnLiteralBlock)\n  var n = newLeaf(\"\")\n  if currentTok(p).kind == tkIndent:\n    var indent = currentTok(p).ival\n    while currentTok(p).kind == tkIndent: inc p.idx  # skip blank lines\n    while true:\n      case currentTok(p).kind\n      of tkEof:\n        break\n      of tkIndent:\n        if currentTok(p).ival < indent:\n          break\n        else:\n          n.text.add(\"\\n\")\n          n.text.add(spaces(currentTok(p).ival - indent))\n          inc p.idx\n      else:\n        n.text.add(currentTok(p).symbol)\n        inc p.idx\n  else:\n    while currentTok(p).kind notin {tkIndent, tkEof}:\n      n.text.add(currentTok(p).symbol)\n      inc p.idx\n  result.add(n)\n\nproc parseQuotedLiteralBlock(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnLiteralBlock)\n  var n = newLeaf(\"\")\n  if currentTok(p).kind == tkIndent:\n    var indent = currInd(p)\n    while currentTok(p).kind == tkIndent: inc p.idx  # skip blank lines\n    var quoteSym = currentTok(p).symbol[0]\n    while true:\n      case currentTok(p).kind\n      of tkEof:\n        break\n      of tkIndent:\n        if currentTok(p).ival < indent:\n          break\n        elif currentTok(p).ival == indent:\n          if nextTok(p).kind == tkPunct and nextTok(p).symbol[0] == quoteSym:\n            n.text.add(\"\\n\")\n            inc p.idx\n          elif nextTok(p).kind == tkIndent:\n            break\n          else:\n            rstMessage(p, mwRstStyle, \"no newline after quoted literal block\")\n            break\n        else:\n          rstMessage(p, mwRstStyle,\n                     \"unexpected indentation in quoted literal block\")\n          break\n      else:\n        n.text.add(currentTok(p).symbol)\n        inc p.idx\n  result.add(n)\n\nproc parseRstLiteralBlock(p: var RstParser, kind: LiteralBlockKind): PRstNode =\n  if kind == lbIndentedLiteralBlock:\n    result = parseLiteralBlock(p)\n  else:\n    result = parseQuotedLiteralBlock(p)\n\nproc getLevel(p: var RstParser, c: char, hasOverline: bool): int =\n  ## Returns (preliminary) heading level corresponding to `c` and\n  ## `hasOverline`. If level does not exist, add it first.\n  for i, hType in p.s.hLevels:\n    if hType.symbol == c and hType.hasOverline == hasOverline:\n      p.s.hLevels[i].line = curLine(p)\n      p.s.hLevels[i].hasPeers = true\n      return i\n  p.s.hLevels.add LevelInfo(symbol: c, hasOverline: hasOverline,\n                            line: curLine(p), hasPeers: false)\n  result = p.s.hLevels.len - 1\n\nproc countTitles(s: PRstSharedState, n: PRstNode) =\n  ## Fill `s.hTitleCnt`\n  if n == nil: return\n  for node in n.sons:\n    if node != nil:\n      if node.kind notin {rnOverline, rnSubstitutionDef, rnDefaultRole}:\n        break\n      if node.kind == rnOverline:\n        if s.hLevels[s.hTitleCnt].hasPeers:\n          break\n        inc s.hTitleCnt\n        if s.hTitleCnt >= 2:\n          break\n\nproc isAdornmentHeadline(p: RstParser, adornmentIdx: int): bool =\n  ## check that underline/overline length is enough for the heading.\n  ## No support for Unicode.\n  if p.tok[adornmentIdx].symbol in [\"::\", \"..\", \"|\"]:\n    return false\n  var headlineLen = 0\n  var failure = \"\"\n  if p.idx < adornmentIdx:  # check for underline\n    if p.idx > 0:\n      headlineLen = currentTok(p).col - p.tok[adornmentIdx].col\n    if headlineLen > 0:\n      rstMessage(p, mwRstStyle, \"indentation of heading text allowed\" &\n          \" only for overline titles\")\n    for i in p.idx ..< adornmentIdx-1:  # adornmentIdx-1 is a linebreak\n      headlineLen += p.tok[i].symbol.len\n    result = p.tok[adornmentIdx].symbol.len >= headlineLen and headlineLen != 0\n    if not result:\n      failure = \"(underline '\" & p.tok[adornmentIdx].symbol & \"' is too short)\"\n  else:  # p.idx == adornmentIdx, at overline. Check overline and underline\n    var i = p.idx + 2\n    headlineLen = p.tok[i].col - p.tok[adornmentIdx].col\n    while p.tok[i].kind notin {tkEof, tkIndent}:\n      headlineLen += p.tok[i].symbol.len\n      inc i\n    result = p.tok[adornmentIdx].symbol.len >= headlineLen and\n         headlineLen != 0\n    if result:\n      result = result and p.tok[i].kind == tkIndent and\n         p.tok[i+1].kind == tkAdornment and\n         p.tok[i+1].symbol == p.tok[adornmentIdx].symbol\n      if not result:\n        failure = \"(underline '\" & p.tok[i+1].symbol & \"' does not match \" &\n            \"overline '\" & p.tok[adornmentIdx].symbol & \"')\"\n    else:\n      failure = \"(overline '\" & p.tok[adornmentIdx].symbol & \"' is too short)\"\n  if not result:\n    rstMessage(p, meNewSectionExpected, failure)\n\nproc isLineBlock(p: RstParser): bool =\n  var j = tokenAfterNewline(p)\n  result = currentTok(p).col == p.tok[j].col and p.tok[j].symbol == \"|\" or\n      p.tok[j].col > currentTok(p).col or\n      p.tok[j].symbol == \"\\n\"\n\nproc isMarkdownBlockQuote(p: RstParser): bool =\n  result = currentTok(p).symbol[0] == '>'\n\nproc whichRstLiteralBlock(p: RstParser): LiteralBlockKind =\n  ## Checks that the following tokens are either Indented Literal Block or\n  ## Quoted Literal Block (which is not quite the same as Markdown quote block).\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#quoted-literal-blocks\n  if currentTok(p).symbol == \"::\" and nextTok(p).kind == tkIndent:\n    if currInd(p) > nextTok(p).ival:\n      result = lbNone\n    if currInd(p) < nextTok(p).ival:\n      result = lbIndentedLiteralBlock\n    elif currInd(p) == nextTok(p).ival:\n      var i = p.idx + 1\n      while p.tok[i].kind == tkIndent: inc i\n      const validQuotingCharacters = {\n          '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-',\n          '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^',\n          '_', '`', '{', '|', '}', '~'}\n      if p.tok[i].kind in {tkPunct, tkAdornment} and\n          p.tok[i].symbol[0] in validQuotingCharacters:\n        result = lbQuotedLiteralBlock\n      else:\n        result = lbNone\n  else:\n    result = lbNone\n\nproc predNL(p: RstParser): bool =\n  result = true\n  if p.idx > 0:\n    result = prevTok(p).kind == tkIndent and\n        prevTok(p).ival == currInd(p)\n\nproc isDefList(p: RstParser): bool =\n  var j = tokenAfterNewline(p)\n  result = currentTok(p).col < p.tok[j].col and\n      p.tok[j].kind in {tkWord, tkOther, tkPunct} and\n      p.tok[j - 2].symbol != \"::\"\n\nproc isOptionList(p: RstParser): bool =\n  result = match(p, p.idx, \"-w\") or match(p, p.idx, \"--w\") or\n           match(p, p.idx, \"/w\") or match(p, p.idx, \"//w\")\n\nproc isMarkdownHeadlinePattern(s: string): bool =\n  if s.len >= 1 and s.len <= 6:\n    for c in s:\n      if c != '#': return false\n    result = true\n\nproc isMarkdownHeadline(p: RstParser): bool =\n  if roSupportMarkdown in p.s.options:\n    if isMarkdownHeadlinePattern(currentTok(p).symbol) and nextTok(p).kind == tkWhite:\n      if p.tok[p.idx+2].kind in {tkWord, tkOther, tkPunct}:\n        result = true\n\nproc findPipe(p: RstParser, start: int): bool =\n  var i = start\n  while true:\n    if p.tok[i].symbol == \"|\": return true\n    if p.tok[i].kind in {tkIndent, tkEof}: return false\n    inc i\n\nproc whichSection(p: RstParser): RstNodeKind =\n  if currentTok(p).kind in {tkAdornment, tkPunct}:\n    # for punctuation sequences that can be both tkAdornment and tkPunct\n    if roSupportMarkdown in p.s.options and currentTok(p).symbol == \"```\":\n      return rnCodeBlock\n    elif currentTok(p).symbol == \"::\":\n      return rnLiteralBlock\n    elif currentTok(p).symbol == \"..\"  and\n       nextTok(p).kind in {tkWhite, tkIndent}:\n     return rnDirective\n  case currentTok(p).kind\n  of tkAdornment:\n    if match(p, p.idx + 1, \"iI\") and currentTok(p).symbol.len >= 4:\n      result = rnTransition\n    elif match(p, p.idx, \"+a+\"):\n      result = rnGridTable\n      rstMessage(p, meGridTableNotImplemented)\n    elif match(p, p.idx + 1, \" a\"): result = rnTable\n    elif currentTok(p).symbol == \"|\" and isLineBlock(p):\n      result = rnLineBlock\n    elif roSupportMarkdown in p.s.options and isMarkdownBlockQuote(p):\n      result = rnMarkdownBlockQuote\n    elif match(p, p.idx + 1, \"i\") and isAdornmentHeadline(p, p.idx):\n      result = rnOverline\n    else:\n      result = rnLeaf\n  of tkPunct:\n    if isMarkdownHeadline(p):\n      result = rnMarkdownHeadline\n    elif roSupportMarkdown in p.s.options and predNL(p) and\n        match(p, p.idx, \"| w\") and findPipe(p, p.idx+3):\n      result = rnMarkdownTable\n    elif currentTok(p).symbol == \"|\" and isLineBlock(p):\n      result = rnLineBlock\n    elif roSupportMarkdown in p.s.options and isMarkdownBlockQuote(p):\n      result = rnMarkdownBlockQuote\n    elif match(p, tokenAfterNewline(p), \"aI\") and\n        isAdornmentHeadline(p, tokenAfterNewline(p)):\n      result = rnHeadline\n    elif currentTok(p).symbol in [\"+\", \"*\", \"-\"] and nextTok(p).kind == tkWhite:\n      result = rnBulletList\n    elif match(p, p.idx, \":w:E\"):\n      # (currentTok(p).symbol == \":\")\n      result = rnFieldList\n    elif match(p, p.idx, \"(e) \") or match(p, p.idx, \"e) \") or\n         match(p, p.idx, \"e. \"):\n      result = rnEnumList\n    elif isOptionList(p):\n      result = rnOptionList\n    elif isDefList(p):\n      result = rnDefList\n    else:\n      result = rnParagraph\n  of tkWord, tkOther, tkWhite:\n    let tokIdx = tokenAfterNewline(p)\n    if match(p, tokIdx, \"aI\"):\n      if isAdornmentHeadline(p, tokIdx): result = rnHeadline\n      else: result = rnParagraph\n    elif match(p, p.idx, \"e) \") or match(p, p.idx, \"e. \"): result = rnEnumList\n    elif isDefList(p): result = rnDefList\n    else: result = rnParagraph\n  else: result = rnLeaf\n\nproc parseLineBlock(p: var RstParser): PRstNode =\n  ## Returns rnLineBlock with all sons of type rnLineBlockItem\n  result = nil\n  if nextTok(p).kind in {tkWhite, tkIndent}:\n    var col = currentTok(p).col\n    result = newRstNodeA(p, rnLineBlock)\n    while true:\n      var item = newRstNode(rnLineBlockItem)\n      if nextTok(p).kind == tkWhite:\n        if nextTok(p).symbol.len > 1:  # pass additional indentation after '| '\n          item.lineIndent = nextTok(p).symbol\n        inc p.idx, 2\n        pushInd(p, p.tok[p.idx].col)\n        parseSection(p, item)\n        popInd(p)\n      else:  # tkIndent => add an empty line\n        item.lineIndent = \"\\n\"\n        inc p.idx, 1\n      result.add(item)\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n          nextTok(p).symbol == \"|\" and\n          p.tok[p.idx + 2].kind in {tkWhite, tkIndent}:\n        inc p.idx, 1\n      else:\n        break\n\nproc parseDoc(p: var RstParser): PRstNode {.gcsafe.}\n\nproc getQuoteSymbol(p: RstParser, idx: int): tuple[sym: string, depth: int, tokens: int] =\n  result = (\"\", 0, 0)\n  var i = idx\n  result.sym &= p.tok[i].symbol\n  result.depth += p.tok[i].symbol.len\n  inc result.tokens\n  inc i\n  while p.tok[i].kind == tkWhite and i+1 < p.tok.len and\n        p.tok[i+1].kind == tkPunct and p.tok[i+1].symbol[0] == '>':\n    result.sym &= p.tok[i].symbol\n    result.sym &= p.tok[i+1].symbol\n    result.depth += p.tok[i+1].symbol.len\n    inc result.tokens, 2\n    inc i, 2\n\nproc parseMarkdownQuoteSegment(p: var RstParser, curSym: string, col: int):\n                              PRstNode =\n  ## We define *segment* as a group of lines that starts with exactly the\n  ## same quote symbol. If the following lines don't contain any `>` (*lazy*\n  ## continuation) they considered as continuation of the current segment.\n  var q: RstParser  # to delete `>` at a start of line and then parse normally\n  initParser(q, p.s)\n  q.col = p.col\n  q.line = p.line\n  var minCol = int.high  # minimum colum num in the segment\n  while true:  # move tokens of segment from `p` to `q` skipping `curSym`\n    case currentTok(p).kind\n    of tkEof:\n      break\n    of tkIndent:\n      if nextTok(p).kind in {tkIndent, tkEof}:\n        break\n      else:\n        if nextTok(p).symbol[0] == '>':\n          var (quoteSym, _, quoteTokens) = getQuoteSymbol(p, p.idx + 1)\n          if quoteSym == curSym:  # the segment continues\n            var iTok = tokenAfterNewline(p, p.idx+1)\n            if p.tok[iTok].kind notin {tkEof, tkIndent} and\n                p.tok[iTok].symbol[0] != '>':\n              rstMessage(p, mwRstStyle,\n                  \"two or more quoted lines are followed by unquoted line \" &\n                  $(curLine(p) + 1))\n              break\n            q.tok.add currentTok(p)\n            var ival = currentTok(p).ival + quoteSym.len\n            inc p.idx, (1 + quoteTokens)  # skip newline and > > >\n            if currentTok(p).kind == tkWhite:\n              ival += currentTok(p).symbol.len\n              inc p.idx\n            # fix up previous `tkIndent`s to ival (as if >>> were not there)\n            var j = q.tok.len - 1\n            while j >= 0 and q.tok[j].kind == tkIndent:\n              q.tok[j].ival = ival\n              dec j\n          else:  # next segment started\n            break\n        elif currentTok(p).ival < col:\n          break\n        else:  # the segment continues, a case like:\n               # > beginning\n               # continuation\n          q.tok.add currentTok(p)\n          inc p.idx\n    else:\n      if currentTok(p).col < minCol: minCol = currentTok(p).col\n      q.tok.add currentTok(p)\n      inc p.idx\n  q.indentStack = @[minCol]\n  # if initial indentation `minCol` is > 0 then final newlines\n  # should be omitted so that parseDoc could advance to the end of tokens:\n  var j = q.tok.len - 1\n  while q.tok[j].kind == tkIndent: dec j\n  q.tok.setLen (j+1)\n  q.tok.add Token(kind: tkEof, line: currentTok(p).line)\n  result = parseDoc(q)\n\nproc parseMarkdownBlockQuote(p: var RstParser): PRstNode =\n  var (curSym, quotationDepth, quoteTokens) = getQuoteSymbol(p, p.idx)\n  let col = currentTok(p).col\n  result = newRstNodeA(p, rnMarkdownBlockQuote)\n  inc p.idx, quoteTokens  # skip first >\n  while true:\n    var item = newRstNode(rnMarkdownBlockQuoteItem)\n    item.quotationDepth = quotationDepth\n    if currentTok(p).kind == tkWhite: inc p.idx\n    item.add parseMarkdownQuoteSegment(p, curSym, col)\n    result.add(item)\n    if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n        nextTok(p).kind != tkEof and nextTok(p).symbol[0] == '>':\n      (curSym, quotationDepth, quoteTokens) = getQuoteSymbol(p, p.idx + 1)\n      inc p.idx, (1 + quoteTokens)  # skip newline and > > >\n    else:\n      break\n\nproc parseParagraph(p: var RstParser, result: PRstNode) =\n  while true:\n    case currentTok(p).kind\n    of tkIndent:\n      if nextTok(p).kind == tkIndent:\n        inc p.idx\n        break\n      elif currentTok(p).ival == currInd(p):\n        inc p.idx\n        case whichSection(p)\n        of rnParagraph, rnLeaf, rnHeadline, rnMarkdownHeadline,\n            rnOverline, rnDirective:\n          result.add newLeaf(\" \")\n        of rnLineBlock:\n          result.addIfNotNil(parseLineBlock(p))\n        of rnMarkdownBlockQuote:\n          result.addIfNotNil(parseMarkdownBlockQuote(p))\n        else: break\n      else:\n        break\n    of tkPunct:\n      if (let literalBlockKind = whichRstLiteralBlock(p);\n          literalBlockKind != lbNone):\n        result.add newLeaf(\":\")\n        inc p.idx            # skip '::'\n        result.add(parseRstLiteralBlock(p, literalBlockKind))\n        break\n      else:\n        parseInline(p, result)\n    of tkWhite, tkWord, tkAdornment, tkOther:\n      parseInline(p, result)\n    else: break\n\nproc checkHeadingHierarchy(p: RstParser, lvl: int) =\n  if lvl - p.s.hCurLevel > 1:  # broken hierarchy!\n    proc descr(l: int): string =\n      (if p.s.hLevels[l].hasOverline: \"overline \" else: \"underline \") &\n      repeat(p.s.hLevels[l].symbol, 5)\n    var msg = \"(section level inconsistent: \"\n    msg.add descr(lvl) & \" unexpectedly found, \" &\n      \"while the following intermediate section level(s) are missing on lines \"\n    msg.add $p.s.hLevels[p.s.hCurLevel].line & \"..\" & $curLine(p) & \":\"\n    for l in p.s.hCurLevel+1 .. lvl-1:\n      msg.add \" \" & descr(l)\n      if l != lvl-1: msg.add \",\"\n    rstMessage(p, meNewSectionExpected, msg & \")\")\n\nproc parseHeadline(p: var RstParser): PRstNode =\n  if isMarkdownHeadline(p):\n    result = newRstNode(rnMarkdownHeadline)\n    # Note that level hierarchy is not checked for markdown headings\n    result.level = currentTok(p).symbol.len\n    assert(nextTok(p).kind == tkWhite)\n    inc p.idx, 2\n    parseUntilNewline(p, result)\n  else:\n    result = newRstNode(rnHeadline)\n    parseUntilNewline(p, result)\n    assert(currentTok(p).kind == tkIndent)\n    assert(nextTok(p).kind == tkAdornment)\n    var c = nextTok(p).symbol[0]\n    inc p.idx, 2\n    result.level = getLevel(p, c, hasOverline=false)\n    checkHeadingHierarchy(p, result.level)\n    p.s.hCurLevel = result.level\n  addAnchorRst(p, linkName(result), rstnodeToRefname(result), reset=true,\n               anchorType=headlineAnchor)\n\nproc parseOverline(p: var RstParser): PRstNode =\n  var c = currentTok(p).symbol[0]\n  inc p.idx, 2\n  result = newRstNode(rnOverline)\n  while true:\n    parseUntilNewline(p, result)\n    if currentTok(p).kind == tkIndent:\n      inc p.idx\n      if prevTok(p).ival > currInd(p):\n        result.add newLeaf(\" \")\n      else:\n        break\n    else:\n      break\n  result.level = getLevel(p, c, hasOverline=true)\n  checkHeadingHierarchy(p, result.level)\n  p.s.hCurLevel = result.level\n  if currentTok(p).kind == tkAdornment:\n    inc p.idx\n    if currentTok(p).kind == tkIndent: inc p.idx\n  addAnchorRst(p, linkName(result), rstnodeToRefname(result), reset=true,\n               anchorType=headlineAnchor)\n\ntype\n  IntSeq = seq[int]\n  ColumnLimits = tuple\n    first, last: int\n  ColSeq = seq[ColumnLimits]\n\nproc tokEnd(p: RstParser): int =\n  result = currentTok(p).col + currentTok(p).symbol.len - 1\n\nproc getColumns(p: var RstParser, cols: var IntSeq) =\n  var L = 0\n  while true:\n    inc L\n    setLen(cols, L)\n    cols[L - 1] = tokEnd(p)\n    assert(currentTok(p).kind == tkAdornment)\n    inc p.idx\n    if currentTok(p).kind != tkWhite: break\n    inc p.idx\n    if currentTok(p).kind != tkAdornment: break\n  if currentTok(p).kind == tkIndent: inc p.idx\n  # last column has no limit:\n  cols[L - 1] = 32000\n\nproc parseSimpleTable(p: var RstParser): PRstNode =\n  var\n    cols: IntSeq\n    row: seq[string]\n    i, last, line: int\n    c: char\n    q: RstParser\n    a, b: PRstNode\n  result = newRstNodeA(p, rnTable)\n  cols = @[]\n  row = @[]\n  a = nil\n  c = currentTok(p).symbol[0]\n  while true:\n    if currentTok(p).kind == tkAdornment:\n      last = tokenAfterNewline(p)\n      if p.tok[last].kind in {tkEof, tkIndent}:\n        # skip last adornment line:\n        p.idx = last\n        break\n      getColumns(p, cols)\n      setLen(row, cols.len)\n      if a != nil:\n        for j in 0 ..< a.len:  # fix rnTableDataCell -> rnTableHeaderCell\n          a.sons[j] = newRstNode(rnTableHeaderCell, a.sons[j].sons)\n    if currentTok(p).kind == tkEof: break\n    for j in countup(0, high(row)): row[j] = \"\"\n    # the following while loop iterates over the lines a single cell may span:\n    line = currentTok(p).line\n    while true:\n      i = 0\n      while currentTok(p).kind notin {tkIndent, tkEof}:\n        if tokEnd(p) <= cols[i]:\n          row[i].add(currentTok(p).symbol)\n          inc p.idx\n        else:\n          if currentTok(p).kind == tkWhite: inc p.idx\n          inc i\n      if currentTok(p).kind == tkIndent: inc p.idx\n      if tokEnd(p) <= cols[0]: break\n      if currentTok(p).kind in {tkEof, tkAdornment}: break\n      for j in countup(1, high(row)): row[j].add('\\n')\n    a = newRstNode(rnTableRow)\n    for j in countup(0, high(row)):\n      initParser(q, p.s)\n      q.col = cols[j]\n      q.line = line - 1\n      getTokens(row[j], q.tok)\n      b = newRstNode(rnTableDataCell)\n      b.add(parseDoc(q))\n      a.add(b)\n    result.add(a)\n\nproc readTableRow(p: var RstParser): ColSeq =\n  if currentTok(p).symbol == \"|\": inc p.idx\n  while currentTok(p).kind notin {tkIndent, tkEof}:\n    var limits: ColumnLimits\n    limits.first = p.idx\n    while currentTok(p).kind notin {tkIndent, tkEof}:\n      if currentTok(p).symbol == \"|\" and prevTok(p).symbol != \"\\\\\": break\n      inc p.idx\n    limits.last = p.idx\n    result.add(limits)\n    if currentTok(p).kind in {tkIndent, tkEof}: break\n    inc p.idx\n  p.idx = tokenAfterNewline(p)\n\nproc getColContents(p: var RstParser, colLim: ColumnLimits): string =\n  for i in colLim.first ..< colLim.last:\n    result.add(p.tok[i].symbol)\n  result.strip\n\nproc isValidDelimiterRow(p: var RstParser, colNum: int): bool =\n  let row = readTableRow(p)\n  if row.len != colNum: return false\n  for limits in row:\n    let content = getColContents(p, limits)\n    if content.len < 3 or not (content.startsWith(\"--\") or content.startsWith(\":-\")):\n      return false\n  return true\n\nproc parseMarkdownTable(p: var RstParser): PRstNode =\n  var\n    row: ColSeq\n    colNum: int\n    a, b: PRstNode\n    q: RstParser\n  result = newRstNodeA(p, rnMarkdownTable)\n\n  proc parseRow(p: var RstParser, cellKind: RstNodeKind, result: PRstNode) =\n    row = readTableRow(p)\n    if colNum == 0: colNum = row.len # table header\n    elif row.len < colNum: row.setLen(colNum)\n    a = newRstNode(rnTableRow)\n    for j in 0 ..< colNum:\n      b = newRstNode(cellKind)\n      initParser(q, p.s)\n      q.col = p.col\n      q.line = currentTok(p).line - 1\n      getTokens(getColContents(p, row[j]), q.tok)\n      b.add(parseDoc(q))\n      a.add(b)\n    result.add(a)\n\n  parseRow(p, rnTableHeaderCell, result)\n  if not isValidDelimiterRow(p, colNum): rstMessage(p, meMarkdownIllformedTable)\n  while predNL(p) and currentTok(p).symbol == \"|\":\n    parseRow(p, rnTableDataCell, result)\n\nproc parseTransition(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnTransition)\n  inc p.idx\n  if currentTok(p).kind == tkIndent: inc p.idx\n  if currentTok(p).kind == tkIndent: inc p.idx\n\nproc parseBulletList(p: var RstParser): PRstNode =\n  result = nil\n  if nextTok(p).kind == tkWhite:\n    var bullet = currentTok(p).symbol\n    var col = currentTok(p).col\n    result = newRstNodeA(p, rnBulletList)\n    pushInd(p, p.tok[p.idx + 2].col)\n    inc p.idx, 2\n    while true:\n      var item = newRstNode(rnBulletItem)\n      parseSection(p, item)\n      result.add(item)\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n          nextTok(p).symbol == bullet and\n          p.tok[p.idx + 2].kind == tkWhite:\n        inc p.idx, 3\n      else:\n        break\n    popInd(p)\n\nproc parseOptionList(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnOptionList)\n  let col = currentTok(p).col\n  var order = 1\n  while true:\n    if currentTok(p).col == col and isOptionList(p):\n      var a = newRstNode(rnOptionGroup)\n      var b = newRstNode(rnDescription)\n      var c = newRstNode(rnOptionListItem)\n      if match(p, p.idx, \"//w\"): inc p.idx\n      while currentTok(p).kind notin {tkIndent, tkEof}:\n        if currentTok(p).kind == tkWhite and currentTok(p).symbol.len > 1:\n          inc p.idx\n          break\n        a.add(newLeaf(p))\n        inc p.idx\n      var j = tokenAfterNewline(p)\n      if j > 0 and p.tok[j - 1].kind == tkIndent and p.tok[j - 1].ival > currInd(p):\n        pushInd(p, p.tok[j - 1].ival)\n        parseSection(p, b)\n        popInd(p)\n      else:\n        parseLine(p, b)\n      while currentTok(p).kind == tkIndent: inc p.idx\n      c.add(a)\n      c.add(b)\n      c.order = order; inc order\n      result.add(c)\n    else:\n      if currentTok(p).kind != tkEof: dec p.idx  # back to tkIndent\n      break\n\nproc parseDefinitionList(p: var RstParser): PRstNode =\n  result = nil\n  var j = tokenAfterNewline(p) - 1\n  if j >= 1 and p.tok[j].kind == tkIndent and\n      p.tok[j].ival > currInd(p) and p.tok[j - 1].symbol != \"::\":\n    var col = currentTok(p).col\n    result = newRstNodeA(p, rnDefList)\n    while true:\n      if isOptionList(p):\n        break  # option list has priority over def.list\n      j = p.idx\n      var a = newRstNode(rnDefName)\n      parseLine(p, a)\n      if currentTok(p).kind == tkIndent and\n          currentTok(p).ival > currInd(p) and\n          nextTok(p).symbol != \"::\" and\n          nextTok(p).kind notin {tkIndent, tkEof}:\n        pushInd(p, currentTok(p).ival)\n        var b = newRstNode(rnDefBody)\n        parseSection(p, b)\n        var c = newRstNode(rnDefItem)\n        c.add(a)\n        c.add(b)\n        result.add(c)\n        popInd(p)\n      else:\n        p.idx = j\n        break\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col:\n        inc p.idx\n        j = tokenAfterNewline(p) - 1\n        if j >= 1 and p.tok[j].kind == tkIndent and p.tok[j].ival > col and\n            p.tok[j-1].symbol != \"::\" and p.tok[j+1].kind != tkIndent:\n          discard\n        else:\n          break\n    if result.len == 0: result = nil\n\nproc parseEnumList(p: var RstParser): PRstNode =\n  const\n    wildcards: array[0..5, string] = [\"(n) \", \"n) \", \"n. \",\n                                      \"(x) \", \"x) \", \"x. \"]\n      # enumerator patterns, where 'x' means letter and 'n' means number\n    wildToken: array[0..5, int] = [4, 3, 3, 4, 3, 3]  # number of tokens\n    wildIndex: array[0..5, int] = [1, 0, 0, 1, 0, 0]\n      # position of enumeration sequence (number/letter) in enumerator\n  let col = currentTok(p).col\n  var w = 0\n  while w < wildcards.len:\n    if match(p, p.idx, wildcards[w]): break\n    inc w\n  assert w < wildcards.len\n\n  proc checkAfterNewline(p: RstParser, report: bool): bool =\n    ## If no indentation on the next line then parse as a normal paragraph\n    ## according to the RST spec. And report a warning with suggestions\n    let j = tokenAfterNewline(p, start=p.idx+1)\n    let requiredIndent = p.tok[p.idx+wildToken[w]].col\n    if p.tok[j].kind notin {tkIndent, tkEof} and\n        p.tok[j].col < requiredIndent and\n        (p.tok[j].col > col or\n          (p.tok[j].col == col and not match(p, j, wildcards[w]))):\n      if report:\n        let n = p.line + p.tok[j].line\n        let msg = \"\\n\" & \"\"\"\n          not enough indentation on line $2\n            (should be at column $3 if it's a continuation of enum. list),\n          or no blank line after line $1 (if it should be the next paragraph),\n          or no escaping \\ at the beginning of line $1\n            (if lines $1..$2 are a normal paragraph, not enum. list)\"\"\".dedent\n        let c = p.col + requiredIndent + ColRstOffset\n        rstMessage(p, mwRstStyle, msg % [$(n-1), $n, $c],\n                   p.tok[j].line, p.tok[j].col)\n      result = false\n    else:\n      result = true\n\n  if not checkAfterNewline(p, report = true):\n    return nil\n  result = newRstNodeA(p, rnEnumList)\n  let autoEnums = if roSupportMarkdown in p.s.options: @[\"#\", \"1\"] else: @[\"#\"]\n  var prevAE = \"\"  # so as not allow mixing auto-enumerators `1` and `#`\n  var curEnum = 1\n  for i in 0 ..< wildToken[w]-1:  # add first enumerator with (, ), and .\n    if p.tok[p.idx + i].symbol == \"#\":\n      prevAE = \"#\"\n      result.labelFmt.add \"1\"\n    else:\n      result.labelFmt.add p.tok[p.idx + i].symbol\n  var prevEnum = p.tok[p.idx + wildIndex[w]].symbol\n  inc p.idx, wildToken[w]\n  while true:\n    var item = newRstNode(rnEnumItem)\n    pushInd(p, currentTok(p).col)\n    parseSection(p, item)\n    popInd(p)\n    result.add(item)\n    if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n        match(p, p.idx+1, wildcards[w]):\n      # don't report to avoid duplication of warning since for\n      # subsequent enum. items parseEnumList will be called second time:\n      if not checkAfterNewline(p, report = false):\n        break\n      let enumerator = p.tok[p.idx + 1 + wildIndex[w]].symbol\n      # check that it's in sequence: enumerator == next(prevEnum)\n      if \"n\" in wildcards[w]:  # arabic numeral\n        let prevEnumI = try: parseInt(prevEnum) except: 1\n        if enumerator in autoEnums:\n          if prevAE != \"\" and enumerator != prevAE:\n            break\n          prevAE = enumerator\n          curEnum = prevEnumI + 1\n        else: curEnum = (try: parseInt(enumerator) except: 1)\n        if curEnum - prevEnumI != 1:\n          break\n        prevEnum = enumerator\n      else:  # a..z\n        let prevEnumI = ord(prevEnum[0])\n        if enumerator == \"#\": curEnum = prevEnumI + 1\n        else: curEnum = ord(enumerator[0])\n        if curEnum - prevEnumI != 1:\n          break\n        prevEnum = $chr(curEnum)\n      inc p.idx, 1 + wildToken[w]\n    else:\n      break\n\nproc sonKind(father: PRstNode, i: int): RstNodeKind =\n  result = rnLeaf\n  if i < father.len: result = father.sons[i].kind\n\nproc parseSection(p: var RstParser, result: PRstNode) =\n  ## parse top-level RST elements: sections, transitions and body elements.\n  while true:\n    var leave = false\n    assert(p.idx >= 0)\n    while currentTok(p).kind == tkIndent:\n      if currInd(p) == currentTok(p).ival:\n        inc p.idx\n      elif currentTok(p).ival > currInd(p):\n        pushInd(p, currentTok(p).ival)\n        var a = newRstNodeA(p, rnBlockQuote)\n        parseSection(p, a)\n        result.add(a)\n        popInd(p)\n      else:\n        while currentTok(p).kind != tkEof and nextTok(p).kind == tkIndent:\n          inc p.idx  # skip blank lines\n        leave = true\n        break\n    if leave or currentTok(p).kind == tkEof: break\n    var a: PRstNode = nil\n    var k = whichSection(p)\n    case k\n    of rnLiteralBlock:\n      inc p.idx              # skip '::'\n      a = parseLiteralBlock(p)\n    of rnBulletList: a = parseBulletList(p)\n    of rnLineBlock: a = parseLineBlock(p)\n    of rnMarkdownBlockQuote: a = parseMarkdownBlockQuote(p)\n    of rnDirective: a = parseDotDot(p)\n    of rnEnumList: a = parseEnumList(p)\n    of rnLeaf: rstMessage(p, meNewSectionExpected, \"(syntax error)\")\n    of rnParagraph: discard\n    of rnDefList: a = parseDefinitionList(p)\n    of rnFieldList:\n      if p.idx > 0: dec p.idx\n      a = parseFields(p)\n    of rnTransition: a = parseTransition(p)\n    of rnHeadline, rnMarkdownHeadline: a = parseHeadline(p)\n    of rnOverline: a = parseOverline(p)\n    of rnTable: a = parseSimpleTable(p)\n    of rnMarkdownTable: a = parseMarkdownTable(p)\n    of rnOptionList: a = parseOptionList(p)\n    else:\n      #InternalError(\"rst.parseSection()\")\n      discard\n    if a == nil and k != rnDirective:\n      a = newRstNodeA(p, rnParagraph)\n      parseParagraph(p, a)\n    result.addIfNotNil(a)\n  if sonKind(result, 0) == rnParagraph and sonKind(result, 1) != rnParagraph:\n    result.sons[0] = newRstNode(rnInner, result.sons[0].sons,\n                                anchor=result.sons[0].anchor)\n\nproc parseSectionWrapper(p: var RstParser): PRstNode =\n  result = newRstNode(rnInner)\n  parseSection(p, result)\n  while result.kind == rnInner and result.len == 1:\n    result = result.sons[0]\n\nproc `$`(t: Token): string =\n  result = $t.kind & ' ' & t.symbol\n\nproc parseDoc(p: var RstParser): PRstNode =\n  result = parseSectionWrapper(p)\n  if currentTok(p).kind != tkEof:\n    rstMessage(p, meGeneralParseError)\n\ntype\n  DirFlag = enum\n    hasArg, hasOptions, argIsFile, argIsWord\n  DirFlags = set[DirFlag]\n  SectionParser = proc (p: var RstParser): PRstNode {.nimcall, gcsafe.}\n\nproc parseDirective(p: var RstParser, k: RstNodeKind, flags: DirFlags): PRstNode =\n  ## Parses arguments and options for a directive block.\n  ##\n  ## A directive block will always have three sons: the arguments for the\n  ## directive (rnDirArg), the options (rnFieldList) and the directive\n  ## content block. This proc parses the two first nodes, the 3rd is left to\n  ## the outer `parseDirective` call.\n  ##\n  ## Both rnDirArg and rnFieldList children nodes might be nil, so you need to\n  ## check them before accessing.\n  result = newRstNodeA(p, k)\n  if k == rnCodeBlock: result.info = lineInfo(p)\n  var args: PRstNode = nil\n  var options: PRstNode = nil\n  if hasArg in flags:\n    args = newRstNode(rnDirArg)\n    if argIsFile in flags:\n      while true:\n        case currentTok(p).kind\n        of tkWord, tkOther, tkPunct, tkAdornment:\n          args.add(newLeaf(p))\n          inc p.idx\n        else: break\n    elif argIsWord in flags:\n      while currentTok(p).kind == tkWhite: inc p.idx\n      if currentTok(p).kind == tkWord:\n        args.add(newLeaf(p))\n        inc p.idx\n      else:\n        args = nil\n    else:\n      parseLine(p, args)\n  result.add(args)\n  if hasOptions in flags:\n    if currentTok(p).kind == tkIndent and currentTok(p).ival > currInd(p) and\n        nextTok(p).symbol == \":\":\n      pushInd(p, currentTok(p).ival)\n      options = parseFields(p)\n      popInd(p)\n  result.add(options)\n\nproc indFollows(p: RstParser): bool =\n  result = currentTok(p).kind == tkIndent and currentTok(p).ival > currInd(p)\n\nproc parseBlockContent(p: var RstParser, father: var PRstNode,\n                       contentParser: SectionParser): bool {.gcsafe.} =\n  ## parse the final content part of explicit markup blocks (directives,\n  ## footnotes, etc). Returns true if succeeded.\n  if currentTok(p).kind != tkIndent or indFollows(p):\n    let blockIndent = getWrappableIndent(p)\n    pushInd(p, blockIndent)\n    let content = contentParser(p)\n    popInd(p)\n    father.add content\n    result = true\n\nproc parseDirective(p: var RstParser, k: RstNodeKind, flags: DirFlags,\n                    contentParser: SectionParser): PRstNode =\n  ## A helper proc that does main work for specific directive procs.\n  ## Always returns a generic rnDirective tree with these 3 children:\n  ##\n  ## 1) rnDirArg\n  ## 2) rnFieldList\n  ## 3) a node returned by `contentParser`.\n  ##\n  ## .. warning:: Any of the 3 children may be nil.\n  result = parseDirective(p, k, flags)\n  if not isNil(contentParser) and\n      parseBlockContent(p, result, contentParser):\n    discard \"result is updated by parseBlockContent\"\n  else:\n    result.add(PRstNode(nil))\n\nproc parseDirBody(p: var RstParser, contentParser: SectionParser): PRstNode =\n  if indFollows(p):\n    pushInd(p, currentTok(p).ival)\n    result = contentParser(p)\n    popInd(p)\n\nproc dirInclude(p: var RstParser): PRstNode =\n  ##\n  ## The following options are recognized:\n  ##\n  ## :start-after: text to find in the external data file\n  ##\n  ##     Only the content after the first occurrence of the specified\n  ##     text will be included. If text is not found inclusion will\n  ##     start from beginning of the file\n  ##\n  ## :end-before: text to find in the external data file\n  ##\n  ##     Only the content before the first occurrence of the specified\n  ##     text (but after any after text) will be included. If text is\n  ##     not found inclusion will happen until the end of the file.\n  #literal : flag (empty)\n  #    The entire included text is inserted into the document as a single\n  #    literal block (useful for program listings).\n  #encoding : name of text encoding\n  #    The text encoding of the external data file. Defaults to the document's\n  #    encoding (if specified).\n  #\n  result = nil\n  var n = parseDirective(p, rnDirective, {hasArg, argIsFile, hasOptions}, nil)\n  var filename = strip(addNodes(n.sons[0]))\n  var path = p.findRelativeFile(filename)\n  if path == \"\":\n    rstMessage(p, meCannotOpenFile, filename)\n  else:\n    # XXX: error handling; recursive file inclusion!\n    if getFieldValue(n, \"literal\") != \"\":\n      result = newRstNode(rnLiteralBlock)\n      result.add newLeaf(readFile(path))\n    else:\n      let inputString = readFile(path)\n      let startPosition =\n        block:\n          let searchFor = n.getFieldValue(\"start-after\").strip()\n          if searchFor != \"\":\n            let pos = inputString.find(searchFor)\n            if pos != -1: pos + searchFor.len\n            else: 0\n          else:\n            0\n\n      let endPosition =\n        block:\n          let searchFor = n.getFieldValue(\"end-before\").strip()\n          if searchFor != \"\":\n            let pos = inputString.find(searchFor, start = startPosition)\n            if pos != -1: pos - 1\n            else: 0\n          else:\n            inputString.len - 1\n\n      var q: RstParser\n      initParser(q, p.s)\n      let saveFileIdx = p.s.currFileIdx\n      setCurrFilename(p.s, path)\n      getTokens(\n        inputString[startPosition..endPosition],\n        q.tok)\n      # workaround a GCC bug; more like the interior pointer bug?\n      #if find(q.tok[high(q.tok)].symbol, \"\\0\\x01\\x02\") > 0:\n      #  InternalError(\"Too many binary zeros in include file\")\n      result = parseDoc(q)\n      p.s.currFileIdx = saveFileIdx\n\nproc dirCodeBlock(p: var RstParser, nimExtension = false): PRstNode =\n  ## Parses a code block.\n  ##\n  ## Code blocks are rnDirective trees with a `kind` of rnCodeBlock. See the\n  ## description of ``parseDirective`` for further structure information.\n  ##\n  ## Code blocks can come in two forms, the standard `code directive\n  ## <http://docutils.sourceforge.net/docs/ref/rst/directives.html#code>`_ and\n  ## the nim extension ``.. code-block::``. If the block is an extension, we\n  ## want the default language syntax highlighting to be Nim, so we create a\n  ## fake internal field to communicate with the generator. The field is named\n  ## ``default-language``, which is unlikely to collide with a field specified\n  ## by any random rst input file.\n  ##\n  ## As an extension this proc will process the ``file`` extension field and if\n  ## present will replace the code block with the contents of the referenced\n  ## file.\n  result = parseDirective(p, rnCodeBlock, {hasArg, hasOptions}, parseLiteralBlock)\n  var filename = strip(getFieldValue(result, \"file\"))\n  if filename != \"\":\n    var path = p.findRelativeFile(filename)\n    if path == \"\": rstMessage(p, meCannotOpenFile, filename)\n    var n = newRstNode(rnLiteralBlock)\n    n.add newLeaf(readFile(path))\n    result.sons[2] = n\n\n  # Extend the field block if we are using our custom Nim extension.\n  if nimExtension:\n    # Create a field block if the input block didn't have any.\n    if result.sons[1].isNil: result.sons[1] = newRstNode(rnFieldList)\n    assert result.sons[1].kind == rnFieldList\n    # Hook the extra field and specify the Nim language as value.\n    var extraNode = newRstNode(rnField, info=lineInfo(p))\n    extraNode.add(newRstNode(rnFieldName))\n    extraNode.add(newRstNode(rnFieldBody))\n    extraNode.sons[0].add newLeaf(\"default-language\")\n    extraNode.sons[1].add newLeaf(\"Nim\")\n    result.sons[1].add(extraNode)\n\nproc dirContainer(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnContainer, {hasArg}, parseSectionWrapper)\n  assert(result.len == 3)\n\nproc dirImage(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnImage, {hasOptions, hasArg, argIsFile}, nil)\n\nproc dirFigure(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnFigure, {hasOptions, hasArg, argIsFile},\n                          parseSectionWrapper)\n\nproc dirTitle(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnTitle, {hasArg}, nil)\n\nproc dirContents(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnContents, {hasArg}, nil)\n\nproc dirIndex(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnIndex, {}, parseSectionWrapper)\n\nproc dirAdmonition(p: var RstParser, d: string): PRstNode =\n  result = parseDirective(p, rnAdmonition, {}, parseSectionWrapper)\n  result.adType = d\n\nproc dirDefaultRole(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnDefaultRole, {hasArg}, nil)\n  if result.sons[0].len == 0: p.s.currRole = defaultRole(p.s.options)\n  else:\n    assert result.sons[0].sons[0].kind == rnLeaf\n    p.s.currRole = result.sons[0].sons[0].text\n  p.s.currRoleKind = whichRole(p, p.s.currRole)\n\nproc dirRole(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnDirective, {hasArg, hasOptions}, nil)\n  # just check that language is supported, TODO: real role association\n  let lang = getFieldValue(result, \"language\").strip\n  if lang != \"\" and getSourceLanguage(lang) == langNone:\n    rstMessage(p, mwUnsupportedLanguage, lang)\n\nproc dirRawAux(p: var RstParser, result: var PRstNode, kind: RstNodeKind,\n               contentParser: SectionParser) =\n  var filename = getFieldValue(result, \"file\")\n  if filename.len > 0:\n    var path = p.findRelativeFile(filename)\n    if path.len == 0:\n      rstMessage(p, meCannotOpenFile, filename)\n    else:\n      var f = readFile(path)\n      result = newRstNode(kind)\n      result.add newLeaf(f)\n  else:\n    result = newRstNode(kind, result.sons)\n    result.add(parseDirBody(p, contentParser))\n\nproc dirRaw(p: var RstParser): PRstNode =\n  #\n  #The following options are recognized:\n  #\n  #file : string (newlines removed)\n  #    The local filesystem path of a raw data file to be included.\n  #\n  # html\n  # latex\n  result = parseDirective(p, rnDirective, {hasOptions, hasArg, argIsWord})\n  if result.sons[0] != nil:\n    if cmpIgnoreCase(result.sons[0].sons[0].text, \"html\") == 0:\n      dirRawAux(p, result, rnRawHtml, parseLiteralBlock)\n    elif cmpIgnoreCase(result.sons[0].sons[0].text, \"latex\") == 0:\n      dirRawAux(p, result, rnRawLatex, parseLiteralBlock)\n    else:\n      rstMessage(p, meInvalidDirective, result.sons[0].sons[0].text)\n  else:\n    dirRawAux(p, result, rnRaw, parseSectionWrapper)\n\nproc selectDir(p: var RstParser, d: string): PRstNode =\n  result = nil\n  case d\n  of \"admonition\", \"attention\", \"caution\": result = dirAdmonition(p, d)\n  of \"code\": result = dirCodeBlock(p)\n  of \"code-block\": result = dirCodeBlock(p, nimExtension = true)\n  of \"container\": result = dirContainer(p)\n  of \"contents\": result = dirContents(p)\n  of \"danger\": result = dirAdmonition(p, d)\n  of \"default-role\": result = dirDefaultRole(p)\n  of \"error\": result = dirAdmonition(p, d)\n  of \"figure\": result = dirFigure(p)\n  of \"hint\": result = dirAdmonition(p, d)\n  of \"image\": result = dirImage(p)\n  of \"important\": result = dirAdmonition(p, d)\n  of \"include\": result = dirInclude(p)\n  of \"index\": result = dirIndex(p)\n  of \"note\": result = dirAdmonition(p, d)\n  of \"raw\":\n    if roSupportRawDirective in p.s.options:\n      result = dirRaw(p)\n    else:\n      rstMessage(p, meInvalidDirective, d)\n  of \"role\": result = dirRole(p)\n  of \"tip\": result = dirAdmonition(p, d)\n  of \"title\": result = dirTitle(p)\n  of \"warning\": result = dirAdmonition(p, d)\n  else:\n    let tok = p.tok[p.idx-2]  # report on directive in \".. directive::\"\n    rstMessage(p, meInvalidDirective, d, tok.line, tok.col)\n\nproc prefix(ftnType: FootnoteType): string =\n  case ftnType\n  of fnManualNumber: result = \"footnote-\"\n  of fnAutoNumber: result = \"footnoteauto-\"\n  of fnAutoNumberLabel: result = \"footnote-\"\n  of fnAutoSymbol: result = \"footnotesym-\"\n  of fnCitation: result = \"citation-\"\n\nproc parseFootnote(p: var RstParser): PRstNode {.gcsafe.} =\n  ## Parses footnotes and citations, always returns 2 sons:\n  ##\n  ## 1) footnote label, always containing rnInner with 1 or more sons\n  ## 2) footnote body, which may be nil\n  inc p.idx\n  let label = parseFootnoteName(p, reference=false)\n  if label == nil:\n    dec p.idx\n    return nil\n  result = newRstNode(rnFootnote)\n  result.add label\n  let (fnType, i) = getFootnoteType(label)\n  var name = \"\"\n  var anchor = fnType.prefix\n  case fnType\n  of fnManualNumber:\n    addFootnoteNumManual(p, i)\n    anchor.add $i\n  of fnAutoNumber, fnAutoNumberLabel:\n    name = rstnodeToRefname(label)\n    addFootnoteNumAuto(p, name)\n    if fnType == fnAutoNumberLabel:\n      anchor.add name\n    else:  # fnAutoNumber\n      result.order = p.s.lineFootnoteNum.len\n      anchor.add $result.order\n  of fnAutoSymbol:\n    addFootnoteSymAuto(p)\n    result.order = p.s.lineFootnoteSym.len\n    anchor.add $p.s.lineFootnoteSym.len\n  of fnCitation:\n    anchor.add rstnodeToRefname(label)\n  addAnchorRst(p, anchor, anchor, reset=true, anchorType=footnoteAnchor)\n  result.anchor = anchor\n  if currentTok(p).kind == tkWhite: inc p.idx\n  discard parseBlockContent(p, result, parseSectionWrapper)\n  if result.len < 2:\n    result.add nil\n\nproc parseDotDot(p: var RstParser): PRstNode =\n  # parse \"explicit markup blocks\"\n  result = nil\n  var n: PRstNode  # to store result, workaround for bug 16855\n  var col = currentTok(p).col\n  inc p.idx\n  var d = getDirective(p)\n  if d != \"\":\n    pushInd(p, col)\n    result = selectDir(p, d)\n    popInd(p)\n  elif match(p, p.idx, \" _\"):\n    # hyperlink target:\n    inc p.idx, 2\n    var ending = \":\"\n    if currentTok(p).symbol == \"`\":\n      inc p.idx\n      ending = \"`\"\n    var a = getReferenceName(p, ending)\n    if ending == \"`\":\n      if currentTok(p).symbol == \":\":\n        inc p.idx\n      else:\n        rstMessage(p, meExpected, \":\")\n    if currentTok(p).kind == tkWhite: inc p.idx\n    var b = untilEol(p)\n    if len(b) == 0:  # set internal anchor\n      addAnchorRst(p, linkName(a), rstnodeToRefname(a), reset=false,\n                   anchorType=manualDirectiveAnchor)\n    else:  # external hyperlink\n      setRef(p, rstnodeToRefname(a), b, refType=hyperlinkAlias)\n  elif match(p, p.idx, \" |\"):\n    # substitution definitions:\n    inc p.idx, 2\n    var a = getReferenceName(p, \"|\")\n    var b: PRstNode\n    if currentTok(p).kind == tkWhite: inc p.idx\n    if cmpIgnoreStyle(currentTok(p).symbol, \"replace\") == 0:\n      inc p.idx\n      expect(p, \"::\")\n      b = untilEol(p)\n    elif cmpIgnoreStyle(currentTok(p).symbol, \"image\") == 0:\n      inc p.idx\n      b = dirImage(p)\n    else:\n      rstMessage(p, meInvalidDirective, currentTok(p).symbol)\n    setSub(p, addNodes(a), b)\n  elif match(p, p.idx, \" [\") and\n      (n = parseFootnote(p); n != nil):\n    result = n\n  else:\n    result = parseComment(p, col)\n\nproc rstParsePass1*(fragment: string,\n                    line, column: int,\n                    sharedState: PRstSharedState): PRstNode =\n  ## Parses an RST `fragment`.\n  ## The result should be further processed by\n  ## preparePass2_ and resolveSubs_ (which is pass 2).\n  var p: RstParser\n  initParser(p, sharedState)\n  p.line = line\n  p.col = column\n  getTokens(fragment, p.tok)\n  result = parseDoc(p)\n\nproc preparePass2*(s: PRstSharedState, mainNode: PRstNode) =\n  ## Records titles in node `mainNode` and orders footnotes.\n  countTitles(s, mainNode)\n  orderFootnotes(s)\n\nproc resolveLink(s: PRstSharedState, n: PRstNode) : PRstNode =\n    # Associate this link alias with its target and change node kind to\n    # rnHyperlink or rnInternalRef appropriately.\n    type LinkDef = object\n      ar: AnchorRule\n      priority: int\n      tooltip: string\n      target: PRstNode\n      info: TLineInfo\n    proc cmp(x, y: LinkDef): int =\n      result = cmp(x.priority, y.priority)\n      if result == 0:\n        result = cmp(x.target, y.target)\n    var foundLinks: seq[LinkDef]\n    let text = newRstNode(rnInner, n.sons)\n    let refn = rstnodeToRefname(n)\n    var hyperlinks = findRef(s, refn)\n    for y in hyperlinks:\n      foundLinks.add LinkDef(ar: arHyperlink, priority: refPriority(y.kind),\n                             target: y.value, info: y.info,\n                             tooltip: \"(\" & $y.kind & \")\")\n    let substRst = findMainAnchorRst(s, text.addNodes, n.info)\n    for subst in substRst:\n      foundLinks.add LinkDef(ar: arInternalRst, priority: subst.priority,\n                             target: newLeaf(subst.mainAnchor[]),\n                             info: subst.info,\n                             tooltip: \"(\" & $subst.anchorType & \")\")\n    if roNimFile in s.options:\n      let substNim = findMainAnchorNim(s, signature=text, n.info)\n      for subst in substNim:\n        foundLinks.add LinkDef(ar: arNim, priority: subst.priority,\n                               target: newLeaf(subst.mainAnchor[]),\n                               info: subst.info, tooltip: subst.tooltip)\n    foundLinks.sort(cmp = cmp, order = Descending)\n    let linkText = addNodes(n)\n    if foundLinks.len >= 1:\n      let kind = if foundLinks[0].ar == arHyperlink: rnHyperlink\n                 elif foundLinks[0].ar == arNim: rnNimdocRef\n                 else: rnInternalRef\n      result = newRstNode(kind)\n      result.sons = @[text, foundLinks[0].target]\n      if kind == rnNimdocRef: result.tooltip = foundLinks[0].tooltip\n      if foundLinks.len > 1:  # report ambiguous link\n        var targets = newSeq[string]()\n        for l in foundLinks:\n          var t = \"    \"\n          if s.filenames.len > 1:\n            t.add getFilename(s.filenames, l.info.fileIndex)\n          let n = l.info.line\n          let c = l.info.col + ColRstOffset\n          t.add \"($1, $2): $3\" % [$n, $c, l.tooltip]\n          targets.add t\n        rstMessage(s.filenames, s.msgHandler, n.info, mwAmbiguousLink,\n                   \"`$1`\\n  clash:\\n$2\" % [\n                     linkText, targets.join(\"\\n\")])\n    else:  # nothing found\n      result = n\n      rstMessage(s.filenames, s.msgHandler, n.info, mwBrokenLink, linkText)\n\nproc resolveSubs*(s: PRstSharedState, n: PRstNode): PRstNode =\n  ## Makes pass 2 of RST parsing.\n  ## Resolves substitutions and anchor aliases, groups footnotes.\n  ## Takes input node `n` and returns the same node with recursive\n  ## substitutions in `n.sons` to `result`.\n  result = n\n  if n == nil: return\n  case n.kind\n  of rnSubstitutionReferences:\n    var x = findSub(s, n)\n    if x >= 0:\n      result = s.subs[x].value\n    else:\n      var key = addNodes(n)\n      var e = getEnv(key)\n      if e != \"\": result = newLeaf(e)\n      else: rstMessage(s.filenames, s.msgHandler, n.info,\n                       mwUnknownSubstitution, key)\n  of rnHeadline, rnOverline:\n    # fix up section levels depending on presence of a title and subtitle\n    if s.hTitleCnt == 2:\n      if n.level == 1:    # it's the subtitle\n        n.level = 0\n      elif n.level >= 2:  # normal sections\n        n.level -= 1\n    elif s.hTitleCnt == 0:\n      n.level += 1\n  of rnRef:\n    result = resolveLink(s, n)\n  of rnFootnote:\n    var (fnType, num) = getFootnoteType(n.sons[0])\n    case fnType\n    of fnManualNumber, fnCitation:\n      discard \"no need to alter fixed text\"\n    of fnAutoNumberLabel, fnAutoNumber:\n      if fnType == fnAutoNumberLabel:\n        let labelR = rstnodeToRefname(n.sons[0])\n        num = getFootnoteNum(s, labelR)\n      else:\n        num = getFootnoteNum(s, n.order)\n      var nn = newRstNode(rnInner)\n      nn.add newLeaf($num)\n      result.sons[0] = nn\n    of fnAutoSymbol:\n      let sym = getAutoSymbol(s, n.order)\n      n.sons[0].sons[0].text = sym\n    n.sons[1] = resolveSubs(s, n.sons[1])\n  of rnFootnoteRef:\n    var (fnType, num) = getFootnoteType(n.sons[0])\n    template addLabel(number: int | string) =\n      var nn = newRstNode(rnInner)\n      nn.add newLeaf($number)\n      result.add(nn)\n    var refn = fnType.prefix\n    # create new rnFootnoteRef, add final label, and finalize target refn:\n    result = newRstNode(rnFootnoteRef, info = n.info)\n    case fnType\n    of fnManualNumber:\n      addLabel num\n      refn.add $num\n    of fnAutoNumber:\n      inc s.currFootnoteNumRef\n      addLabel getFootnoteNum(s, s.currFootnoteNumRef)\n      refn.add $s.currFootnoteNumRef\n    of fnAutoNumberLabel:\n      addLabel getFootnoteNum(s, rstnodeToRefname(n))\n      refn.add rstnodeToRefname(n)\n    of fnAutoSymbol:\n      inc s.currFootnoteSymRef\n      addLabel getAutoSymbol(s, s.currFootnoteSymRef)\n      refn.add $s.currFootnoteSymRef\n    of fnCitation:\n      result.add n.sons[0]\n      refn.add rstnodeToRefname(n)\n    # TODO: correctly report ambiguities\n    let anchorInfo = findMainAnchorRst(s, refn, n.info)\n    if anchorInfo.len != 0:\n      result.add newLeaf(anchorInfo[0].mainAnchor[])  # add link\n    else:\n      rstMessage(s.filenames, s.msgHandler, n.info, mwBrokenLink, refn)\n      result.add newLeaf(refn)  # add link\n  of rnLeaf:\n    discard\n  of rnContents:\n    s.hasToc = true\n  else:\n    var regroup = false\n    for i in 0 ..< n.len:\n      n.sons[i] = resolveSubs(s, n.sons[i])\n      if n.sons[i] != nil and n.sons[i].kind == rnFootnote:\n        regroup = true\n    if regroup:  # group footnotes together into rnFootnoteGroup\n      var newSons: seq[PRstNode]\n      var i = 0\n      while i < n.len:\n        if n.sons[i] != nil and n.sons[i].kind == rnFootnote:\n          var grp = newRstNode(rnFootnoteGroup)\n          while i < n.len and n.sons[i].kind == rnFootnote:\n            grp.sons.add n.sons[i]\n            inc i\n          newSons.add grp\n        else:\n          newSons.add n.sons[i]\n          inc i\n      result.sons = newSons\n\nproc rstParse*(text, filename: string,\n               line, column: int,\n               options: RstParseOptions,\n               findFile: FindFileHandler = nil,\n               msgHandler: MsgHandler = nil):\n              tuple[node: PRstNode, filenames: RstFileTable, hasToc: bool] =\n  ## Parses the whole `text`. The result is ready for `rstgen.renderRstToOut`,\n  ## note that 2nd tuple element should be fed to `initRstGenerator`\n  ## argument `filenames` (it is being filled here at least with `filename`\n  ## and possibly with other files from RST ``.. include::`` statement).\n  var sharedState = newRstSharedState(options, filename, findFile, msgHandler)\n  let unresolved = rstParsePass1(text, line, column, sharedState)\n  preparePass2(sharedState, unresolved)\n  result.node = resolveSubs(sharedState, unresolved)\n  result.filenames = sharedState.filenames\n  result.hasToc = sharedState.hasToc\n", "discard \"\"\"\noutputsub: \"\"\n\"\"\"\n\n# tests for rstgen module.\n\nimport ../../lib/packages/docutils/rstgen\nimport ../../lib/packages/docutils/rst\nimport unittest, strutils, strtabs\nimport std/private/miscdollars\n\nproc toHtml(input: string,\n            rstOptions: RstParseOptions = {roPreferMarkdown, roSupportMarkdown, roNimFile},\n            error: ref string = nil,\n            warnings: ref seq[string] = nil): string =\n  ## If `error` is nil then no errors should be generated.\n  ## The same goes for `warnings`.\n  proc testMsgHandler(filename: string, line, col: int, msgkind: MsgKind,\n                      arg: string) =\n    let mc = msgkind.whichMsgClass\n    let a = $msgkind % arg\n    var message: string\n    toLocation(message, filename, line, col + ColRstOffset)\n    message.add \" $1: $2\" % [$mc, a]\n    if mc == mcError:\n      if error == nil:\n        raise newException(EParseError, \"[unexpected error] \" & message)\n      error[] = message\n      # we check only first error because subsequent ones may be meaningless\n      raise newException(EParseError, \"\")\n    else:\n      doAssert warnings != nil, \"unexpected RST warning '\" & message & \"'\"\n      warnings[].add message\n  try:\n    result = rstToHtml(input, rstOptions, defaultConfig(),\n                       msgHandler=testMsgHandler)\n  except EParseError as e:\n    if e.msg != \"\":\n      result = e.msg\n\n# inline code tags (for parsing originated from highlite.nim)\nproc id(str: string): string = \"\"\"<span class=\"Identifier\">\"\"\"  & str & \"</span>\"\nproc op(str: string): string = \"\"\"<span class=\"Operator\">\"\"\"    & str & \"</span>\"\nproc pu(str: string): string = \"\"\"<span class=\"Punctuation\">\"\"\" & str & \"</span>\"\nproc optionListLabel(opt: string): string =\n  \"\"\"<div class=\"option-list-label\"><tt><span class=\"option\">\"\"\" &\n  opt &\n  \"</span></tt></div>\"\n\nsuite \"YAML syntax highlighting\":\n  test \"Basics\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    a string: string\n    a list:\n      - item 1\n      - item 2\n    a map:\n    ? key\n    : value\n    ...\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">a string</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">string</span>\n<span class=\"StringLit\">a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 1</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 2</span>\n<span class=\"StringLit\">a map</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">?</span> <span class=\"StringLit\">key</span>\n<span class=\"Punctuation\">:</span> <span class=\"StringLit\">value</span>\n<span class=\"Keyword\">...</span></pre>\"\"\"\n\n  test \"Block scalars\":\n    let input = \"\"\".. code-block:: yaml\n    a literal block scalar: |\n      some text\n      # not a comment\n     # a comment, since less indented\n      # another comment\n    a folded block scalar: >2\n       some text\n      # not a comment since indented as specified\n     # a comment\n    another literal block scalar:\n      |+ # comment after header\n     allowed, since more indented than parent\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"StringLit\">a literal block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">|</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n  some text\n  # not a comment\n </span><span class=\"Comment\"># a comment, since less indented</span>\n  <span class=\"Comment\"># another comment</span>\n<span class=\"StringLit\">a folded block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">&gt;2</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n   some text\n  # not a comment since indented as specified\n </span><span class=\"Comment\"># a comment</span>\n<span class=\"StringLit\">another literal block scalar</span><span class=\"Punctuation\">:</span>\n  <span class=\"Command\">|+</span> <span class=\"Comment\"># comment after header</span><span class=\"LongStringLit\">\n allowed, since more indented than parent</span></pre>\"\"\"\n\n  test \"Directives\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    %not a directive\n    ...\n    %a directive\n    ...\n    a string\n    % not a directive\n    ...\n    %TAG ! !foo:\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">%not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">a string</span>\n<span class=\"StringLit\">% not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%TAG ! !foo:</span></pre>\"\"\"\n\n  test \"Flow Style and Numbers\":\n    let input = \"\"\".. code-block:: yaml\n    {\n      \"quoted string\": 42,\n      'single quoted string': false,\n      [ list, \"with\", 'entries' ]: 73.32e-73,\n      more numbers: [-783, 11e78],\n      not numbers: [ 42e, 0023, +32.37, 8 ball]\n    }\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Punctuation\">{</span>\n  <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">quoted string&quot;</span><span class=\"Punctuation\">:</span> <span class=\"DecNumber\">42</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">'single quoted string'</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">false</span><span class=\"Punctuation\">,</span>\n  <span class=\"Punctuation\">[</span> <span class=\"StringLit\">list</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">with&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">'entries'</span> <span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span> <span class=\"FloatNumber\">73.32e-73</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">more numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span><span class=\"DecNumber\">-783</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">11e78</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">not numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span> <span class=\"StringLit\">42e</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">0023</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">+32.37</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">8 ball</span><span class=\"Punctuation\">]</span>\n<span class=\"Punctuation\">}</span></pre>\"\"\"\n\n  test \"Directives: warnings\":\n    let input = dedent\"\"\"\n      .. non-existent-warning: Paragraph.\n\n      .. another.wrong:warning::: Paragraph.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check output == \"\"\n    doAssert warnings[].len == 2\n    check \"(1, 24) Warning: RST style:\" in warnings[0]\n    check \"double colon :: may be missing at end of 'non-existent-warning'\" in warnings[0]\n    check \"(3, 25) Warning: RST style:\" in warnings[1]\n    check \"RST style: too many colons for a directive (should be ::)\" in warnings[1]\n\n  test \"not a directive\":\n    let input = \"..warning:: I am not a warning.\"\n    check input.toHtml == input\n\n  test \"Anchors, Aliases, Tags\":\n    let input = \"\"\".. code-block:: yaml\n    --- !!map\n    !!str string: !<tag:yaml.org,2002:int> 42\n    ? &anchor !!seq []:\n    : !localtag foo\n    alias: *anchor\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">---</span> <span class=\"TagStart\">!!map</span>\n<span class=\"TagStart\">!!str</span> <span class=\"StringLit\">string</span><span class=\"Punctuation\">:</span> <span class=\"TagStart\">!&lt;tag:yaml.org,2002:int&gt;</span> <span class=\"DecNumber\">42</span>\n<span class=\"Punctuation\">?</span> <span class=\"Label\">&amp;anchor</span> <span class=\"TagStart\">!!seq</span> <span class=\"Punctuation\">[</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">:</span> <span class=\"TagStart\">!localtag</span> <span class=\"StringLit\">foo</span>\n<span class=\"StringLit\">alias</span><span class=\"Punctuation\">:</span> <span class=\"Reference\">*anchor</span></pre>\"\"\"\n\n  test \"Edge cases\":\n    let input = \"\"\".. code-block:: yaml\n    ...\n     %a string:\n      a:string:not:a:map\n    ...\n    not a list:\n      -2\n      -3\n      -4\n    example.com/not/a#comment:\n      ?not a map key\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">...</span>\n <span class=\"StringLit\">%a string</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">a:string:not:a:map</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">not a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"DecNumber\">-2</span>\n  <span class=\"DecNumber\">-3</span>\n  <span class=\"DecNumber\">-4</span>\n<span class=\"StringLit\">example.com/not/a#comment</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">?not a map key</span></pre>\"\"\"\n\n\nsuite \"RST/Markdown general\":\n  test \"RST emphasis\":\n    doAssert rstToHtml(\"*Hello* **world**!\", {},\n      newStringTable(modeStyleInsensitive)) ==\n      \"<em>Hello</em> <strong>world</strong>!\"\n\n  test \"Markdown links\":\n    check(\"(( [Nim](https://nim-lang.org/) ))\".toHtml ==\n        \"\"\"(( <a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a> ))\"\"\")\n    check(\"(([Nim](https://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>))\"\"\")\n    check(\"[[Nim](https://nim-lang.org/)]\".toHtml ==\n        \"\"\"[<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>]\"\"\")\n\n  test \"Markdown tables\":\n    let input1 = \"\"\"\n| A1 header    | A2 \\| not fooled\n| :---         | ----:       |\n| C1           | C2 **bold** | ignored |\n| D1 `code \\|` | D2          | also ignored\n| E1 \\| text   |\n|              | F2 without pipe\nnot in table\"\"\"\n    let output1 = input1.toHtml\n    #[\n    TODO: `\\|` inside a table cell should render as `|`\n        `|` outside a table cell should render as `\\|`\n    consistently with markdown, see https://stackoverflow.com/a/66557930/1426932\n    ]#\n    check(output1 == \"\"\"\n<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2 | not fooled</th></tr>\n<tr><td>C1</td><td>C2 <strong>bold</strong></td></tr>\n<tr><td>D1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"code\" & \" \" & op\"\\|\" & \"\"\"</span></tt></td><td>D2</td></tr>\n<tr><td>E1 | text</td><td></td></tr>\n<tr><td></td><td>F2 without pipe</td></tr>\n</table><p>not in table</p>\"\"\")\n    let input2 = \"\"\"\n| A1 header | A2 |\n| --- | --- |\"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"\"\"<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2</th></tr>\n</table>\"\"\"\n\n  test \"RST tables\":\n    let input1 = \"\"\"\nTest 2 column/4 rows table:\n====   ===\nH0     H1\n====   ===\nA0     A1\n====   ===\nA2     A3\n====   ===\nA4     A5\n====   === \"\"\"\n    let output1 = rstToLatex(input1, {})\n    doAssert \"{LL}\" in output1  # 2 columns\n    doAssert count(output1, \"\\\\\\\\\") == 4  # 4 rows\n    for cell in [\"H0\", \"H1\", \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\"]:\n      doAssert cell in output1\n\n    let input2 = \"\"\"\nNow test 3 columns / 2 rows, and also borders containing 4 =, 3 =, 1 = signs:\n\n====   ===  =\nH0     H1   H\n====   ===  =\nA0     A1   X\n       Ax   Y\n====   ===  = \"\"\"\n    let output2 = rstToLatex(input2, {})\n    doAssert \"{LLL}\" in output2  # 3 columns\n    doAssert count(output2, \"\\\\\\\\\") == 2  # 2 rows\n    for cell in [\"H0\", \"H1\", \"H\", \"A0\", \"A1\", \"X\", \"Ax\", \"Y\"]:\n      doAssert cell in output2\n\n\n  test \"RST adornments\":\n    let input1 = \"\"\"\nCheck that a few punctuation symbols are not parsed as adornments:\n:word1: word2 .... word3 \"\"\"\n    let output1 = input1.toHtml\n    discard output1\n\n  test \"RST sections\":\n    let input1 = \"\"\"\nLong chapter name\n'''''''''''''''''''\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"Long chapter name\" in output1 and \"<h1\" in output1\n\n    let input2 = \"\"\"\nShort chapter name:\n\nChA\n===\n\"\"\"\n    let output2 = input2.toHtml\n    doAssert \"ChA\" in output2 and \"<h1\" in output2\n\n    let input3 = \"\"\"\nVery short chapter name:\n\nX\n~\n\"\"\"\n    let output3 = input3.toHtml\n    doAssert \"X\" in output3 and \"<h1\" in output3\n\n    let input4 = \"\"\"\nCheck that short underline is not enough to make section:\n\nWrong chapter\n------------\n\n\"\"\"\n    var error4 = new string\n    let output4 = input4.toHtml(error = error4)\n    check(error4[] == \"input(3, 1) Error: new section expected (underline \" &\n            \"\\'------------\\' is too short)\")\n\n    let input5 = \"\"\"\nCheck that punctuation after adornment and indent are not detected as adornment.\n\nSome chapter\n--------------\n\n  \"punctuation symbols\" \"\"\"\n    let output5 = input5.toHtml\n    doAssert \"&quot;punctuation symbols&quot;\" in output5 and \"<h1\" in output5\n\n    # check that EOF after adornment does not prevent it parsing as heading\n    let input6 = dedent \"\"\"\n      Some chapter\n      ------------\"\"\"\n    let output6 = input6.toHtml\n    doAssert \"<h1 id=\\\"some-chapter\\\">Some chapter</h1>\" in output6\n\n    # check that overline and underline match\n    let input7 = dedent \"\"\"\n      ------------\n      Some chapter\n      -----------\n      \"\"\"\n    var error7 = new string\n    let output7 = input7.toHtml(error=error7)\n    check(error7[] == \"input(1, 1) Error: new section expected (underline \" &\n            \"\\'-----------\\' does not match overline \\'------------\\')\")\n\n    let input8 = dedent \"\"\"\n      -----------\n          Overflow\n      -----------\n      \"\"\"\n    var error8 = new string\n    let output8 = input8.toHtml(error=error8)\n    check(error8[] == \"input(1, 1) Error: new section expected (overline \" &\n            \"\\'-----------\\' is too short)\")\n\n    # check that hierarchy of title styles works\n    let input9good = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n\n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      Another2\n      --------\n\n      More3\n      ~~~~~\n\n      \"\"\"\n    let output9good = input9good.toHtml\n    doAssert \"<h1 id=\\\"level1\\\">Level1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"level3\\\">Level3</h3>\" in output9good\n    doAssert \"<h1 id=\\\"l1\\\">L1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"more3\\\">More3</h3>\" in output9good\n\n    # check that swap causes an exception\n    let input9Bad = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n\n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      More\n      ~~~~\n\n      Another\n      -------\n\n      \"\"\"\n    var error9Bad = new string\n    let output9Bad = input9bad.toHtml(error=error9Bad)\n    check(error9Bad[] == \"input(15, 1) Error: new section expected (section \" &\n            \"level inconsistent: underline ~~~~~ unexpectedly found, while \" &\n            \"the following intermediate section level(s) are missing on \" &\n            \"lines 12..15: underline -----)\")\n\n  test \"RST sections overline\":\n    # the same as input9good but with overline headings\n    # first overline heading has a special meaning: document title\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n\n      ------\n      Level1\n      ------\n\n      Level2\n      ------\n\n      ~~~~~~\n      Level3\n      ~~~~~~\n\n      --\n      L1\n      --\n\n      Another2\n      --------\n\n      ~~~~~\n      More3\n      ~~~~~\n\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames = files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"SubTitle0\"\n    doAssert \"<h1 id=\\\"level1\\\"><center>Level1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output\n    doAssert \"<h3 id=\\\"level3\\\"><center>Level3</center></h3>\" in output\n    doAssert \"<h1 id=\\\"l1\\\"><center>L1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output\n    doAssert \"<h3 id=\\\"more3\\\"><center>More3</center></h3>\" in output\n\n  test \"RST sections overline 2\":\n    # check that a paragraph prevents interpreting overlines as document titles\n    let input = dedent \"\"\"\n      Paragraph\n\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert \"<h1 id=\\\"title0\\\"><center>Title0</center></h1>\" in output\n    doAssert \"<h2 id=\\\"subtitle0\\\"><center>SubTitle0</center></h2>\" in output\n\n  test \"RST+Markdown sections\":\n    # check that RST and Markdown headings don't interfere\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      MySection1a\n      +++++++++++\n\n      # MySection1b\n\n      MySection1c\n      +++++++++++\n\n      ##### MySection5a\n\n      MySection2a\n      -----------\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {roSupportMarkdown})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert output ==\n             \"\\n<h1 id=\\\"mysection1a\\\">MySection1a</h1>\" & # RST\n             \"\\n<h1 id=\\\"mysection1b\\\">MySection1b</h1>\" & # Markdown\n             \"\\n<h1 id=\\\"mysection1c\\\">MySection1c</h1>\" & # RST\n             \"\\n<h5 id=\\\"mysection5a\\\">MySection5a</h5>\" & # Markdown\n             \"\\n<h2 id=\\\"mysection2a\\\">MySection2a</h2>\"   # RST\n\n  test \"RST inline text\":\n    let input1 = \"GC_step\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"GC_step\"\n\n  test \"RST links\":\n    let input1 = \"\"\"\nWant to learn about `my favorite programming language`_?\n\n.. _my favorite programming language: https://nim-lang.org\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<a\" in output1 and \"href=\\\"https://nim-lang.org\\\"\" in output1\n\n  test \"RST transitions\":\n    let input1 = \"\"\"\ncontext1\n\n~~~~\n\ncontext2\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<hr\" in output1\n\n    let input2 = \"\"\"\nThis is too short to be a transition:\n\n---\n\ncontext2\n\"\"\"\n    var error2 = new string\n    let output2 = input2.toHtml(error=error2)\n    check(error2[] == \"input(3, 1) Error: new section expected (overline \" &\n            \"\\'---\\' is too short)\")\n\n  test \"RST literal block\":\n    let input1 = \"\"\"\nTest literal block\n\n::\n\n  check \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre>\" in output1\n\n  test \"Markdown code block\":\n    let input1 = \"\"\"\n```\nlet x = 1\n``` \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre\" in output1 and \"class=\\\"Keyword\\\"\" notin output1\n\n    let input2 = \"\"\"\nParse the block with language specifier:\n```Nim\nlet x = 1\n``` \"\"\"\n    let output2 = input2.toHtml\n    doAssert \"<pre\" in output2 and \"class=\\\"Keyword\\\"\" in output2\n\n  test \"interpreted text\":\n    check(\"\"\"`foo.bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & op\".\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`a\\b\\x\\\\ar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"a\" & op\"\"\"\\\"\"\" & id\"b\" & op\"\"\"\\\"\"\" & id\"x\" & op\"\"\"\\\\\"\"\" & id\"ar\" &\n      \"</span></tt>\")\n\n  test \"inline literal\":\n    check \"\"\"``foo.bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo.bar</span></tt>\"\"\"\n    check \"\"\"``foo\\bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo\\bar</span></tt>\"\"\"\n    check \"\"\"``f\\`o\\\\o\\b`ar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">f\\`o\\\\o\\b`ar</span></tt>\"\"\"\n\n  test \"default-role\":\n    # nim(default) -> literal -> nim -> code(=literal)\n    let input = dedent\"\"\"\n      Par1 `value1`.\n\n      .. default-role:: literal\n\n      Par2 `value2`.\n\n      .. default-role:: nim\n\n      Par3 `value3`.\n\n      .. default-role:: code\n\n      Par4 `value4`.\"\"\"\n    let p1 = \"\"\"Par1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value1\" & \"</span></tt>.\"\n    let p2 = \"\"\"<p>Par2 <tt class=\"docutils literal\"><span class=\"pre\">value2</span></tt>.</p>\"\"\"\n    let p3 = \"\"\"<p>Par3 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value3\" & \"</span></tt>.</p>\"\n    let p4 = \"\"\"<p>Par4 <tt class=\"docutils literal\"><span class=\"pre\">value4</span></tt>.</p>\"\"\"\n    let expected = p1 & p2 & \"\\n\" & p3 & \"\\n\" & p4\n    check(input.toHtml == expected)\n\n  test \"role directive\":\n    let input = dedent\"\"\"\n      .. role:: y(code)\n         :language: yaml\n\n      .. role:: brainhelp(code)\n         :language: brainhelp\n    \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check(warnings[].len == 1 and \"language 'brainhelp' not supported\" in warnings[0])\n\n  test \"RST comments\":\n    let input1 = \"\"\"\n\nCheck that comment disappears:\n\n..\n  some comment \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"Check that comment disappears:\"\n\n  test \"RST line blocks + headings\":\n    let input = \"\"\"\n=====\nTest1\n=====\n\n|\n|\n| line block\n| other line\n\n\"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Test1\"\n      # check that title was not overwritten to '|'\n    doAssert output == \"<p><br/><br/>line block<br/>other line<br/></p>\"\n    let output1l = rstToLatex(input, {})\n    doAssert \"line block\\n\\n\" in output1l\n    doAssert \"other line\\n\\n\" in output1l\n    doAssert output1l.count(\"\\\\vspace\") == 2 + 2  # +2 surrounding paddings\n\n  test \"RST line blocks\":\n    let input2 = dedent\"\"\"\n      Paragraph1\n\n      |\n\n      Paragraph2\"\"\"\n\n    let output2 = input2.toHtml\n    doAssert \"Paragraph1<p><br/></p> <p>Paragraph2</p>\" == output2\n\n    let input3 = dedent\"\"\"\n      | xxx\n      |   yyy\n      |     zzz\"\"\"\n\n    let output3 = input3.toHtml\n    doAssert \"xxx<br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 1.0em\\\">yyy</span><br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output3\n\n    # check that '|   ' with a few spaces is still parsed as new line\n    let input4 = dedent\"\"\"\n      | xxx\n      |\n      |     zzz\"\"\"\n\n    let output4 = input4.toHtml\n    doAssert \"xxx<br/><br/>\" in output4\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output4\n\n  test \"RST enumerated lists\":\n    let input1 = dedent \"\"\"\n      1. line1\n         1\n      2. line2\n         2\n\n      3. line3\n         3\n\n\n      4. line4\n         4\n\n\n\n      5. line5\n         5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n\n    let input2 = dedent \"\"\"\n      3. line3\n\n      4. line4\n\n\n      5. line5\n\n\n\n      7. line7\n\n\n\n\n      8. line8\n      \"\"\"\n    let output2 = input2.toHtml\n    for i in [3, 4, 5, 7, 8]:\n      doAssert ($i & \". line\" & $i) notin output2\n      doAssert (\"<li>line\" & $i & \"</li>\") in output2\n\n    # check that nested enumerated lists work\n    let input3 = dedent \"\"\"\n      1.  a) string1\n      2. string2\n      \"\"\"\n    let output3 = input3.toHtml\n    doAssert count(output3, \"<ol \") == 2\n    doAssert count(output3, \"</ol>\") == 2\n    doAssert \"<li>string1</li>\" in output3 and \"<li>string2</li>\" in output3\n\n    let input4 = dedent \"\"\"\n      Check that enumeration specifiers are respected\n\n      9. string1\n      10. string2\n      12. string3\n\n      b) string4\n      c) string5\n      e) string6\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert count(output4, \"<ol \") == 4\n    doAssert count(output4, \"</ol>\") == 4\n    for enumerator in [9, 12]:\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n    for enumerator in [2, 5]:  # 2=b, 5=e\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n\n    let input5 = dedent \"\"\"\n      Check that auto-numbered enumeration lists work.\n\n      #. string1\n\n      #. string2\n\n      #. string3\n\n      #) string5\n      #) string6\n      \"\"\"\n    let output5 = input5.toHtml\n    doAssert count(output5, \"<ol \") == 2\n    doAssert count(output5, \"</ol>\") == 2\n    doAssert count(output5, \"<li>\") == 5\n\n    let input5a = dedent \"\"\"\n      Auto-numbered RST list can start with 1 even when Markdown support is on.\n\n      1. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output5a = input5a.toHtml\n    doAssert count(output5a, \"<ol \") == 1\n    doAssert count(output5a, \"</ol>\") == 1\n    doAssert count(output5a, \"<li>\") == 3\n\n    let input6 = dedent \"\"\"\n      ... And for alphabetic enumerators too!\n\n      b. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output6 = input6.toHtml\n    doAssert count(output6, \"<ol \") == 1\n    doAssert count(output6, \"</ol>\") == 1\n    doAssert count(output6, \"<li>\") == 3\n    doAssert \"start=\\\"2\\\"\" in output6 and \"class=\\\"loweralpha simple\\\"\" in output6\n\n    let input7 = dedent \"\"\"\n      ... And for uppercase alphabetic enumerators.\n\n      C. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert count(output7, \"<ol \") == 1\n    doAssert count(output7, \"</ol>\") == 1\n    doAssert count(output7, \"<li>\") == 3\n    doAssert \"start=\\\"3\\\"\" in output7 and \"class=\\\"upperalpha simple\\\"\" in output7\n\n    # check that it's not recognized as enum.list without indentation on 2nd line\n    let input8 = dedent \"\"\"\n      Paragraph.\n\n      A. stringA\n      B. stringB\n      C. string1\n      string2\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings = warnings8)\n    check(warnings8[].len == 1)\n    check(\"input(6, 1) Warning: RST style: \\n\" &\n          \"not enough indentation on line 6\" in warnings8[0])\n    doAssert output8 == \"Paragraph.<ol class=\\\"upperalpha simple\\\">\" &\n        \"<li>stringA</li>\\n<li>stringB</li>\\n</ol>\\n<p>C. string1 string2 </p>\"\n\n  test \"Markdown enumerated lists\":\n    let input1 = dedent \"\"\"\n      Below are 2 enumerated lists: Markdown-style (5 items) and RST (1 item)\n      1. line1\n      1. line2\n      1. line3\n      1. line4\n\n      1. line5\n\n      #. lineA\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ol \") == 2\n    doAssert count(output1, \"</ol>\") == 2\n\n  test \"RST bullet lists\":\n    let input1 = dedent \"\"\"\n      * line1\n        1\n      * line2\n        2\n\n      * line3\n        3\n\n\n      * line4\n        4\n\n\n\n      * line5\n        5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ul \") == 1\n    doAssert count(output1, \"</ul>\") == 1\n\n  test \"Nim RST footnotes and citations\":\n    # check that auto-label footnote enumerated properly after a manual one\n    let input1 = dedent \"\"\"\n      .. [1] Body1.\n      .. [#note] Body2\n\n      Ref. [#note]_\n      \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1.count(\">[1]</a>\") == 1\n    doAssert output1.count(\">[2]</a>\") == 2\n    doAssert \"href=\\\"#footnote-note\\\"\" in output1\n    doAssert \">[-1]\" notin output1\n    doAssert \"Body1.\" in output1\n    doAssert \"Body2\" in output1\n\n    # check that there are NO footnotes/citations, only comments:\n    let input2 = dedent \"\"\"\n      .. [1 #] Body1.\n      .. [# note] Body2.\n      .. [wrong citation] That gives you a comment.\n\n      .. [not&allowed] That gives you a comment.\n\n      Not references[#note]_[1 #]_ [wrong citation]_ and [not&allowed]_.\n      \"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"Not references[#note]_[1 #]_ [wrong citation]_ and [not&amp;allowed]_.\"\n\n    # check that auto-symbol footnotes work:\n    let input3 = dedent \"\"\"\n      Ref. [*]_ and [*]_ and [*]_.\n\n      .. [*] Body1\n      .. [*] Body2.\n\n\n      .. [*] Body3.\n      .. [*] Body4\n\n      And [*]_.\n      \"\"\"\n    let output3 = input3.toHtml\n    # both references and footnotes. Footnotes have link to themselves.\n    doAssert output3.count(\"href=\\\"#footnotesym-1\\\">[*]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-2\\\">[**]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-3\\\">[***]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-4\\\">[^]</a>\") == 2\n    # footnote group\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    # footnotes\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-1\\\">[*]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-2\\\">[**]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-3\\\">[***]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-4\\\">[^]</a></strong></sup></div>\") == 1\n    for i in 1 .. 4: doAssert (\"Body\" & $i) in output3\n\n    # check manual, auto-number and auto-label footnote enumeration\n    let input4 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#mylabel] Auto-label1.\n      .. [#note] Auto-label2.\n      .. [#] Auto-number2.\n\n      Ref. [#note]_ and [#]_ and [#]_.\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert \">[-1]\" notin output1\n    let order = @[\n        \"footnote-3\", \"[3]\", \"Manual1.\",\n        \"footnoteauto-1\", \"[1]\", \"Auto-number1\",\n        \"footnote-mylabel\", \"[2]\", \"Auto-label1\",\n        \"footnote-note\", \"[4]\", \"Auto-label2\",\n        \"footnoteauto-2\", \"[5]\", \"Auto-number2\",\n        ]\n    for i in 0 .. order.len-2:\n      let pos1 = output4.find(order[i])\n      let pos2 = output4.find(order[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n    # forgot [#]_\n    let input5 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#note] Auto-label2.\n\n      Ref. [#note]_\n      \"\"\"\n    var error5 = new string\n    let output5 = input5.toHtml(error=error5)\n    check(error5[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 2) != 0 (lines ) for auto-numbered \" &\n            \"footnotes\")\n\n    # extra [*]_\n    let input6 = dedent \"\"\"\n      Ref. [*]_\n\n      .. [*] Auto-Symbol.\n\n      Ref. [*]_\n      \"\"\"\n    var error6 = new string\n    let output6 = input6.toHtml(error=error6)\n    check(error6[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 3) != 2 (lines 2, 6) for auto-symbol \" &\n            \"footnotes\")\n\n    let input7 = dedent \"\"\"\n      .. [Some:CITATION-2020] Citation.\n\n      Ref. [some:citation-2020]_.\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert output7.count(\"href=\\\"#citation-somecoloncitationminus2020\\\"\") == 2\n    doAssert output7.count(\"[Some:CITATION-2020]\") == 1\n    doAssert output7.count(\"[some:citation-2020]\") == 1\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n\n    let input8 = dedent \"\"\"\n      .. [Some] Citation.\n\n      Ref. [som]_.\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings=warnings8)\n    check(warnings8[] == @[\"input(3, 7) Warning: broken link 'citation-som'\"])\n\n    # check that footnote group does not break parsing of other directives:\n    let input9 = dedent \"\"\"\n      .. [Some] Citation.\n\n      .. _`internal anchor`:\n\n      .. [Another] Citation.\n      .. just comment.\n      .. [Third] Citation.\n\n      Paragraph1.\n\n      Paragraph2 ref `internal anchor`_.\n      \"\"\"\n    let output9 = input9.toHtml\n    # _`internal anchor` got erased:\n    check \"href=\\\"#internal-anchor\\\"\" notin output9\n    check \"href=\\\"#citation-another\\\"\" in output9\n    doAssert output9.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    doAssert output9.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"just comment\" notin output9\n\n    # check that nested citations/footnotes work\n    let input10 = dedent \"\"\"\n      Paragraph1 [#]_.\n\n      .. [First] Citation.\n\n         .. [#] Footnote.\n\n            .. [Third] Citation.\n      \"\"\"\n    let output10 = input10.toHtml\n    doAssert output10.count(\"<hr class=\\\"footnote\\\">\" &\n                            \"<div class=\\\"footnote-group\\\">\") == 3\n    doAssert output10.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"<a href=\\\"#citation-first\\\">[First]</a>\" in output10\n    doAssert \"<a href=\\\"#footnoteauto-1\\\">[1]</a>\" in output10\n    doAssert \"<a href=\\\"#citation-third\\\">[Third]</a>\" in output10\n\n    let input11 = \".. [note]\\n\"  # should not crash\n    let output11 = input11.toHtml\n    doAssert \"<a href=\\\"#citation-note\\\">[note]</a>\" in output11\n\n    # check that references to auto-numbered footnotes work\n    let input12 = dedent \"\"\"\n      Ref. [#]_ and [#]_ STOP.\n\n      .. [#] Body1.\n      .. [#] Body3\n      .. [2] Body2.\n      \"\"\"\n    let output12 = input12.toHtml\n    let orderAuto = @[\n        \"#footnoteauto-1\", \"[1]\",\n        \"#footnoteauto-2\", \"[3]\",\n        \"STOP.\",\n        \"Body1.\", \"Body3\", \"Body2.\"\n        ]\n    for i in 0 .. orderAuto.len-2:\n      let pos1 = output12.find(orderAuto[i])\n      let pos2 = output12.find(orderAuto[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n  test \"Nim (RST extension) code-block\":\n    # check that presence of fields doesn't consume the following text as\n    # its code (which is a literal block)\n    let input0 = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 0\n\n      Paragraph1\"\"\"\n    let output0 = input0.toHtml\n    doAssert \"<p>Paragraph1</p>\" in output0\n\n  test \"Nim code-block :number-lines:\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 55\n\n         x\n         y\n      \"\"\"\n    check \"<pre class=\\\"line-nums\\\">55\\n56\\n</pre>\" in input.toHtml\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n\n       x\n      \"\"\"\n    let output = input.toHtml\n    check \"<pre class=\\\"line-nums\\\">55\\n</pre>\" in output\n    check \"<span class=\\\"Identifier\\\">x</span>\" in output\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n         let a = 1\n      \"\"\"\n    var error = new string\n    let output = input.toHtml(error=error)\n    check(error[] == \"input(2, 3) Error: invalid field: \" &\n                     \"extra arguments were given to number-lines: ' let a = 1'\")\n    check \"\" == output\n\n  test \"code-block warning\":\n    let input = dedent \"\"\"\n      .. code:: Nim\n         :unsupportedField: anything\n\n      .. code:: unsupportedLang\n\n         anything\n\n      ```anotherLang\n      someCode\n      ```\n      \"\"\"\n    let warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check(warnings[] == @[\n        \"input(2, 4) Warning: field 'unsupportedField' not supported\",\n        \"input(4, 11) Warning: language 'unsupportedLang' not supported\",\n        \"input(8, 4) Warning: language 'anotherLang' not supported\"\n        ])\n    check(output == \"<pre class = \\\"listing\\\">anything</pre>\" &\n                    \"<p><pre class = \\\"listing\\\">\\nsomeCode\\n</pre> </p>\")\n\n  test \"RST admonitions\":\n    # check that all admonitions are implemented\n    let input0 = dedent \"\"\"\n      .. admonition:: endOf admonition\n      .. attention:: endOf attention\n      .. caution:: endOf caution\n      .. danger:: endOf danger\n      .. error:: endOf error\n      .. hint:: endOf hint\n      .. important:: endOf important\n      .. note:: endOf note\n      .. tip:: endOf tip\n      .. warning:: endOf warning\n    \"\"\"\n    let output0 = input0.toHtml\n    for a in [\"admonition\", \"attention\", \"caution\", \"danger\", \"error\", \"hint\",\n        \"important\", \"note\", \"tip\", \"warning\" ]:\n      doAssert \"endOf \" & a & \"</div>\" in output0\n\n    # Test that admonition does not swallow up the next paragraph.\n    let input1 = dedent \"\"\"\n      .. error:: endOfError\n\n      Test paragraph.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"endOfError</div>\" in output1\n    doAssert \"<p>Test paragraph. </p>\" in output1\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output1\n\n    # Test that second line is parsed as continuation of the first line.\n    let input2 = dedent \"\"\"\n      .. error:: endOfError\n        Test2p.\n\n      Test paragraph.\n    \"\"\"\n    let output2 = input2.toHtml\n    doAssert \"endOfError Test2p.</div>\" in output2\n    doAssert \"<p>Test paragraph. </p>\" in output2\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output2\n\n    let input3 = dedent \"\"\"\n      .. note:: endOfNote\n    \"\"\"\n    let output3 = input3.toHtml\n    doAssert \"endOfNote</div>\" in output3\n    doAssert \"class=\\\"admonition admonition-info\\\"\" in output3\n\n  test \"RST internal links\":\n    let input1 = dedent \"\"\"\n      Start.\n\n      .. _target000:\n\n      Paragraph.\n\n      .. _target001:\n\n      * bullet list\n      * Y\n\n      .. _target002:\n\n      1. enumeration list\n      2. Y\n\n      .. _target003:\n\n      term 1\n        Definition list 1.\n\n      .. _target004:\n\n      | line block\n\n      .. _target005:\n\n      :a: field list value\n\n      .. _target006:\n\n      -a  option description\n\n      .. _target007:\n\n      ::\n\n        Literal block\n\n      .. _target008:\n\n      Doctest blocks are not implemented.\n\n      .. _target009:\n\n          block quote\n\n      .. _target010:\n\n      =====  =====  =======\n        A      B    A and B\n      =====  =====  =======\n      False  False  False\n      =====  =====  =======\n\n      .. _target100:\n\n      .. CAUTION:: admonition\n\n      .. _target101:\n\n      .. code:: nim\n\n         const pi = 3.14\n\n      .. _target102:\n\n      .. code-block::\n\n         const pi = 3.14\n\n      Paragraph2.\n\n      .. _target202:\n\n      ----\n\n      That was a transition.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<p id=\\\"target000\\\"\"     in output1\n    doAssert \"<ul id=\\\"target001\\\"\"    in output1\n    doAssert \"<ol id=\\\"target002\\\"\"    in output1\n    doAssert \"<dl id=\\\"target003\\\"\"    in output1\n    doAssert \"<p id=\\\"target004\\\"\"     in output1\n    doAssert \"<table id=\\\"target005\\\"\" in output1  # field list\n    doAssert \"<div id=\\\"target006\\\"\"   in output1  # option list\n    doAssert \"<pre id=\\\"target007\\\"\"   in output1\n    doAssert \"<blockquote id=\\\"target009\\\"\" in output1\n    doAssert \"<table id=\\\"target010\\\"\" in output1  # just table\n    doAssert \"<span id=\\\"target100\\\"\"  in output1\n    doAssert \"<pre id=\\\"target101\\\"\"   in output1  # code\n    doAssert \"<pre id=\\\"target102\\\"\"   in output1  # code-block\n    doAssert \"<hr id=\\\"target202\\\"\"    in output1\n\n  test \"RST internal links for sections\":\n    let input1 = dedent \"\"\"\n      .. _target101:\n      .. _target102:\n\n      Section xyz\n      -----------\n\n      Ref. target101_\n    \"\"\"\n    let output1 = input1.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    check \"href=\\\"#target101\\\"\" notin output1\n    check \"id=\\\"target101\\\"\"    notin output1\n    check \"href=\\\"#target102\\\"\" notin output1\n    check \"id=\\\"target102\\\"\"    notin output1\n    check \"id=\\\"section-xyz\\\"\"     in output1\n    check \"href=\\\"#section-xyz\\\"\"  in output1\n\n    let input2 = dedent \"\"\"\n      .. _target300:\n\n      Section xyz\n      ===========\n\n      .. _target301:\n\n      SubsectionA\n      -----------\n\n      Ref. target300_ and target301_.\n\n      .. _target103:\n\n      .. [cit2020] note.\n\n      Ref. target103_.\n\n    \"\"\"\n    let output2 = input2.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    doAssert \"href=\\\"#target300\\\"\" notin output2\n    doAssert \"id=\\\"target300\\\"\"    notin output2\n    doAssert \"href=\\\"#target301\\\"\" notin output2\n    doAssert \"id=\\\"target301\\\"\"    notin output2\n    doAssert \"<h1 id=\\\"section-xyz\\\"\" in output2\n    doAssert \"<h2 id=\\\"subsectiona\\\"\" in output2\n    # links should preserve their original names but point to section labels:\n    doAssert \"href=\\\"#section-xyz\\\">target300\" in output2\n    doAssert \"href=\\\"#subsectiona\\\">target301\" in output2\n    doAssert \"href=\\\"#citation-cit2020\\\">target103\" in output2\n\n    let output2l = rstToLatex(input2, {})\n    doAssert \"\\\\label{section-xyz}\\\\hypertarget{section-xyz}{}\" in output2l\n    doAssert \"\\\\hyperlink{section-xyz}{target300}\"  in output2l\n    doAssert \"\\\\hyperlink{subsectiona}{target301}\"  in output2l\n\n  test \"RST internal links (inline)\":\n    let input1 = dedent \"\"\"\n      Paragraph with _`some definition`.\n\n      Ref. `some definition`_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<span class=\\\"target\\\" \" &\n        \"id=\\\"some-definition\\\">some definition</span>\" in output1\n    doAssert \"Ref. <a class=\\\"reference internal\\\" \" &\n        \"href=\\\"#some-definition\\\">some definition</a>\" in output1\n\n  test \"RST references (additional symbols)\":\n    # check that ., _, -, +, : are allowed symbols in references without ` `\n    let input1 = dedent \"\"\"\n      sec.1\n      -----\n\n      2-other:sec+c_2\n      ^^^^^^^^^^^^^^^\n\n      .. _link.1_2021:\n\n      Paragraph\n\n      Ref. sec.1_! and 2-other:sec+c_2_;and link.1_2021_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"id=\\\"secdot1\\\"\" in output1\n    doAssert \"id=\\\"Z2minusothercolonsecplusc-2\\\"\" in output1\n    check \"id=\\\"linkdot1-2021\\\"\" in output1\n    let ref1 = \"<a class=\\\"reference internal\\\" href=\\\"#secdot1\\\">sec.1</a>\"\n    let ref2 = \"<a class=\\\"reference internal\\\" href=\\\"#Z2minusothercolonsecplusc-2\\\">2-other:sec+c_2</a>\"\n    let ref3 = \"<a class=\\\"reference internal\\\" href=\\\"#linkdot1-2021\\\">link.1_2021</a>\"\n    let refline = \"Ref. \" & ref1 & \"! and \" & ref2 & \";and \" & ref3 & \".\"\n    doAssert refline in output1\n\n  test \"Option lists 1\":\n    # check that \"* b\" is not consumed by previous bullet item because of\n    # incorrect indentation handling in option lists\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      * b\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check(output.count(\"<li>\") == 2)\n    check(output.count(\"<div class=\\\"option-list\\\"\") == 1)\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n\n  test \"Option lists 2\":\n    # check that 2nd option list is not united with the 1st\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Option list 3 (double /)\":\n    let input = dedent \"\"\"\n      * a\n        //compile  compile1\n        //doc      doc1\n                   cont\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"compile\") &\n          \"\"\"<div class=\"option-list-description\">compile1</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"doc\") &\n          \"\"\"<div class=\"option-list-description\">doc1 cont</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Roles: subscript prefix/postfix\":\n    let expected = \"See <sub>some text</sub>.\"\n    check \"See :subscript:`some text`.\".toHtml == expected\n    check \"See `some text`:subscript:.\".toHtml == expected\n\n  test \"Roles: correct parsing from beginning of line\":\n    let expected = \"<sup>3</sup>He is an isotope of helium.\"\n    check \"\"\":superscript:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\":sup:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:sup:\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:superscript:\\ He is an isotope of helium.\"\"\".toHtml == expected\n\n  test \"Roles: warnings\":\n    let input = dedent\"\"\"\n      See function :py:func:`spam`.\n\n      See also `egg`:py:class:.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    doAssert warnings[].len == 2\n    check \"(1, 14) Warning: \" in warnings[0]\n    check \"language 'py:func' not supported\" in warnings[0]\n    check \"(3, 15) Warning: \" in warnings[1]\n    check \"language 'py:class' not supported\" in warnings[1]\n    check(\"\"\"<p>See function <span class=\"py:func\">spam</span>.</p>\"\"\" & \"\\n\" &\n          \"\"\"<p>See also <span class=\"py:class\">egg</span>. </p>\"\"\" ==\n          output)\n\n  test \"(not) Roles: check escaping 1\":\n    let expected = \"\"\"See :subscript:<tt class=\"docutils literal\">\"\"\" &\n                   \"\"\"<span class=\"pre\">\"\"\" & id\"some\" & \" \" & id\"text\" &\n                   \"</span></tt>.\"\n    check \"\"\"See \\:subscript:`some text`.\"\"\".toHtml == expected\n    check \"\"\"See :subscript\\:`some text`.\"\"\".toHtml == expected\n\n  test \"(not) Roles: check escaping 2\":\n    check(\"\"\"See :subscript:\\`some text\\`.\"\"\".toHtml ==\n          \"See :subscript:`some text`.\")\n\n  test \"Field list\":\n    check(\":field: text\".toHtml ==\n            \"\"\"<table class=\"docinfo\" frame=\"void\" rules=\"none\">\"\"\" &\n            \"\"\"<col class=\"docinfo-name\" /><col class=\"docinfo-content\" />\"\"\" &\n            \"\"\"<tbody valign=\"top\"><tr><th class=\"docinfo-name\">field:</th>\"\"\" &\n            \"\"\"<td>text</td></tr>\"\"\" & \"\\n</tbody></table>\")\n\n  test \"Field list: body after newline\":\n    let output = dedent \"\"\"\n      :field:\n        text1\"\"\".toHtml\n    check \"<table class=\\\"docinfo\\\"\" in output\n    check \">field:</th>\" in output\n    check \"<td>text1</td>\" in output\n\n  test \"Field list (incorrect)\":\n    check \":field:text\".toHtml == \":field:text\"\n\nsuite \"RST/Code highlight\":\n  test \"Basic Python code highlight\":\n    let pythonCode = \"\"\"\n    .. code-block:: python\n\n      def f_name(arg=42):\n          print(f\"{arg}\")\n\n    \"\"\"\n\n    let expected = \"\"\"<blockquote><p><span class=\"Keyword\">def</span> f_name<span class=\"Punctuation\">(</span><span class=\"Punctuation\">arg</span><span class=\"Operator\">=</span><span class=\"DecNumber\">42</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\n    print<span class=\"Punctuation\">(</span><span class=\"RawData\">f&quot;{arg}&quot;</span><span class=\"Punctuation\">)</span></p></blockquote>\"\"\"\n\n    check strip(rstToHtml(pythonCode, {}, newStringTable(modeCaseSensitive))) ==\n      strip(expected)\n\n\nsuite \"invalid targets\":\n  test \"invalid image target\":\n    let input1 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: https://bar.com\n      :alt: Alt text for the image\"\"\"\n    let output1 = input1.toHtml\n    check output1 == \"\"\"<a class=\"reference external\" href=\"https://bar.com\"><img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/></a>\"\"\"\n\n    let input2 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: javascript://bar.com\n      :alt: Alt text for the image\"\"\"\n    let output2 = input2.toHtml\n    check output2 == \"\"\"<img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/>\"\"\"\n\n    let input3 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: bar.com\n      :alt: Alt text for the image\"\"\"\n    let output3 = input3.toHtml\n    check output3 == \"\"\"<a class=\"reference external\" href=\"bar.com\"><img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/></a>\"\"\"\n\n  test \"invalid links\":\n    check(\"(([Nim](https://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>))\"\"\")\n    check(\"(([Nim](javascript://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"\">Nim</a>))\"\"\")\n"], "fixing_code": ["#\n#\n#           The Nim Compiler\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n# This is the documentation generator. Cross-references are generated\n# by knowing how the anchors are going to be named.\n\nimport\n  ast, strutils, strtabs, algorithm, sequtils, options, msgs, os, idents,\n  wordrecg, syntaxes, renderer, lexer,\n  packages/docutils/[rst, rstgen, dochelpers],\n  json, xmltree, trees, types,\n  typesrenderer, astalgo, lineinfos, intsets,\n  pathutils, tables, nimpaths, renderverbatim, osproc\nimport packages/docutils/rstast except FileIndex, TLineInfo\n\nfrom uri import encodeUrl\nfrom std/private/globs import nativeToUnixPath\nfrom nodejs import findNodeJs\n\nconst\n  exportSection = skField\n  docCmdSkip = \"skip\"\n  DocColOffset = \"## \".len  # assuming that a space was added after ##\n\ntype\n  ItemFragment = object  ## A fragment from each item will be eventually\n                         ## constructed by converting `rst` fields to strings.\n    case isRst: bool\n    of true:\n      rst: PRstNode\n    of false:            ## contains ready markup e.g. from runnableExamples\n      str: string\n  ItemPre = seq[ItemFragment]  ## A pre-processed item.\n  Item = object        ## Any item in documentation, e.g. symbol\n                       ## entry. Configuration variable ``doc.item``\n                       ## is used for its HTML rendering.\n    descRst: ItemPre     ## Description of the item (may contain\n                         ## runnableExamples).\n    substitutions: seq[string]    ## Variable names in `doc.item`...\n    sortName: string    ## The string used for sorting in output\n    info: rstast.TLineInfo  ## place where symbol was defined (for messages)\n    anchor: string  ## e.g. HTML anchor\n    name: string  ## short name of the symbol, not unique\n                  ## (includes backticks ` if present)\n    detailedName: string  ## longer name like `proc search(x: int): int`\n  ModSection = object  ## Section like Procs, Types, etc.\n    secItems: Table[string, seq[Item]]\n                         ## Map basic name -> pre-processed items.\n    finalMarkup: string  ## The items, after RST pass 2 and rendering.\n  ModSections = array[TSymKind, ModSection]\n  TocItem = object  ## HTML TOC item\n    content: string\n    sortName: string\n  TocSectionsFinal = array[TSymKind, string]\n  ExampleGroup = ref object\n    ## a group of runnableExamples with same rdoccmd\n    rdoccmd: string ## from 1st arg in `runnableExamples(rdoccmd): body`\n    docCmd: string ## from user config, e.g. --doccmd:-d:foo\n    code: string ## contains imports; each import contains `body`\n    index: int ## group index\n  JsonItem = object  # pre-processed item: `rst` should be finalized\n    json: JsonNode\n    rst: PRstNode\n    rstField: string\n  TDocumentor = object of rstgen.RstGenerator\n    modDescPre: ItemPre   # module description, not finalized\n    modDescFinal: string  # module description, after RST pass 2 and rendering\n    module: PSym\n    modDeprecationMsg: string\n    section: ModSections     # entries of ``.nim`` file (for `proc`s, etc)\n    tocSimple: array[TSymKind, seq[TocItem]]\n      # TOC entries for non-overloadable symbols (e.g. types, constants)...\n    tocTable:  array[TSymKind, Table[string, seq[TocItem]]]\n      # ...otherwise (e.g. procs)\n    toc2: TocSectionsFinal  # TOC `content`, which is probably wrapped\n                            # in `doc.section.toc2`\n    toc: TocSectionsFinal  # final TOC (wrapped in `doc.section.toc`)\n    indexValFilename: string\n    analytics: string  # Google Analytics javascript, \"\" if doesn't exist\n    seenSymbols: StringTableRef # avoids duplicate symbol generation for HTML.\n    jEntriesPre: seq[JsonItem] # pre-processed RST + JSON content\n    jEntriesFinal: JsonNode    # final JSON after RST pass 2 and rendering\n    types: TStrTable\n    sharedState: PRstSharedState\n    isPureRst: bool\n    conf*: ConfigRef\n    cache*: IdentCache\n    exampleCounter: int\n    emitted: IntSet # we need to track which symbols have been emitted\n                    # already. See bug #3655\n    thisDir*: AbsoluteDir\n    exampleGroups: OrderedTable[string, ExampleGroup]\n    wroteSupportFiles*: bool\n    nimToRstFid: Table[lineinfos.FileIndex, rstast.FileIndex]\n      ## map Nim FileIndex -> RST one, it's needed because we keep them separate\n\n  PDoc* = ref TDocumentor ## Alias to type less.\n\nproc add(dest: var ItemPre, rst: PRstNode) = dest.add ItemFragment(isRst: true, rst: rst)\nproc add(dest: var ItemPre, str: string) = dest.add ItemFragment(isRst: false, str: str)\n\nproc addRstFileIndex(d: PDoc, info: lineinfos.TLineInfo): rstast.FileIndex =\n  let invalid = rstast.FileIndex(-1)\n  result = d.nimToRstFid.getOrDefault(info.fileIndex, default = invalid)\n  if result == invalid:\n    let fname = toFullPath(d.conf, info)\n    result = addFilename(d.sharedState, fname)\n    d.nimToRstFid[info.fileIndex] = result\n\nproc cmpDecimalsIgnoreCase(a, b: string): int =\n  ## For sorting with correct handling of cases like 'uint8' and 'uint16'.\n  ## Also handles leading zeros well (however note that leading zeros are\n  ## significant when lengths of numbers mismatch, e.g. 'bar08' > 'bar8' !).\n  runnableExamples:\n    doAssert cmpDecimalsIgnoreCase(\"uint8\", \"uint16\") < 0\n    doAssert cmpDecimalsIgnoreCase(\"val00032\", \"val16suffix\") > 0\n    doAssert cmpDecimalsIgnoreCase(\"val16suffix\", \"val16\") > 0\n    doAssert cmpDecimalsIgnoreCase(\"val_08_32\", \"val_08_8\") > 0\n    doAssert cmpDecimalsIgnoreCase(\"val_07_32\", \"val_08_8\") < 0\n    doAssert cmpDecimalsIgnoreCase(\"ab8\", \"ab08\") < 0\n    doAssert cmpDecimalsIgnoreCase(\"ab8de\", \"ab08c\") < 0 # sanity check\n  let aLen = a.len\n  let bLen = b.len\n  var\n    iA = 0\n    iB = 0\n  while iA < aLen and iB < bLen:\n    if isDigit(a[iA]) and isDigit(b[iB]):\n      var\n        limitA = iA  # index after the last (least significant) digit\n        limitB = iB\n      while limitA < aLen and isDigit(a[limitA]): inc limitA\n      while limitB < bLen and isDigit(b[limitB]): inc limitB\n      var pos = max(limitA-iA, limitB-iA)\n      while pos > 0:\n        if limitA-pos < iA:  # digit in `a` is 0 effectively\n          result = ord('0') - ord(b[limitB-pos])\n        elif limitB-pos < iB:  # digit in `b` is 0 effectively\n          result = ord(a[limitA-pos]) - ord('0')\n        else:\n          result = ord(a[limitA-pos]) - ord(b[limitB-pos])\n        if result != 0: return\n        dec pos\n      result = (limitA - iA) - (limitB - iB)  # consider 'bar08' > 'bar8'\n      if result != 0: return\n      iA = limitA\n      iB = limitB\n    else:\n      result = ord(toLowerAscii(a[iA])) - ord(toLowerAscii(b[iB]))\n      if result != 0: return\n      inc iA\n      inc iB\n  result = (aLen - iA) - (bLen - iB)\n\nproc prettyString(a: object): string =\n  # xxx pending std/prettyprint refs https://github.com/nim-lang/RFCs/issues/203#issuecomment-602534906\n  for k, v in fieldPairs(a):\n    result.add k & \": \" & $v & \"\\n\"\n\nproc presentationPath*(conf: ConfigRef, file: AbsoluteFile): RelativeFile =\n  ## returns a relative file that will be appended to outDir\n  let file2 = $file\n  template bail() =\n    result = relativeTo(file, conf.projectPath)\n  proc nimbleDir(): AbsoluteDir =\n    getNimbleFile(conf, file2).parentDir.AbsoluteDir\n  case conf.docRoot:\n  of docRootDefault:\n    result = getRelativePathFromConfigPath(conf, file)\n    let dir = nimbleDir()\n    if not dir.isEmpty:\n      let result2 = relativeTo(file, dir)\n      if not result2.isEmpty and (result.isEmpty or result2.string.len < result.string.len):\n        result = result2\n    if result.isEmpty: bail()\n  of \"@pkg\":\n    let dir = nimbleDir()\n    if dir.isEmpty: bail()\n    else: result = relativeTo(file, dir)\n  of \"@path\":\n    result = getRelativePathFromConfigPath(conf, file)\n    if result.isEmpty: bail()\n  elif conf.docRoot.len > 0:\n    # we're (currently) requiring `isAbsolute` to avoid confusion when passing\n    # a relative path (would it be relative with regard to $PWD or to projectfile)\n    conf.globalAssert conf.docRoot.isAbsolute, arg=conf.docRoot\n    conf.globalAssert conf.docRoot.dirExists, arg=conf.docRoot\n    # needed because `canonicalizePath` called on `file`\n    result = file.relativeTo conf.docRoot.expandFilename.AbsoluteDir\n  else:\n    bail()\n  if isAbsolute(result.string):\n    result = file.string.splitPath()[1].RelativeFile\n  result = result.string.replace(\"..\", dotdotMangle).RelativeFile\n  doAssert not result.isEmpty\n  doAssert not isAbsolute(result.string)\n\nproc whichType(d: PDoc; n: PNode): PSym =\n  if n.kind == nkSym:\n    if d.types.strTableContains(n.sym):\n      result = n.sym\n  else:\n    for i in 0..<n.safeLen:\n      let x = whichType(d, n[i])\n      if x != nil: return x\n\nproc attachToType(d: PDoc; p: PSym): PSym =\n  let params = p.ast[paramsPos]\n  template check(i) =\n    result = whichType(d, params[i])\n    if result != nil: return result\n\n  # first check the first parameter, then the return type,\n  # then the other parameter:\n  if params.len > 1: check(1)\n  if params.len > 0: check(0)\n  for i in 2..<params.len: check(i)\n\ntemplate declareClosures =\n  proc compilerMsgHandler(filename: string, line, col: int,\n                          msgKind: rst.MsgKind, arg: string) {.gcsafe.} =\n    # translate msg kind:\n    var k: TMsgKind\n    case msgKind\n    of meCannotOpenFile: k = errCannotOpenFile\n    of meExpected: k = errXExpected\n    of meGridTableNotImplemented: k = errRstGridTableNotImplemented\n    of meMarkdownIllformedTable: k = errRstMarkdownIllformedTable\n    of meNewSectionExpected: k = errRstNewSectionExpected\n    of meGeneralParseError: k = errRstGeneralParseError\n    of meInvalidDirective: k = errRstInvalidDirectiveX\n    of meInvalidField: k = errRstInvalidField\n    of meFootnoteMismatch: k = errRstFootnoteMismatch\n    of mwRedefinitionOfLabel: k = warnRstRedefinitionOfLabel\n    of mwUnknownSubstitution: k = warnRstUnknownSubstitutionX\n    of mwAmbiguousLink: k = warnRstAmbiguousLink\n    of mwBrokenLink: k = warnRstBrokenLink\n    of mwUnsupportedLanguage: k = warnRstLanguageXNotSupported\n    of mwUnsupportedField: k = warnRstFieldXNotSupported\n    of mwRstStyle: k = warnRstStyle\n    {.gcsafe.}:\n      globalError(conf, newLineInfo(conf, AbsoluteFile filename, line, col), k, arg)\n\n  proc docgenFindFile(s: string): string {.gcsafe.} =\n    result = options.findFile(conf, s).string\n    if result.len == 0:\n      result = getCurrentDir() / s\n      if not fileExists(result): result = \"\"\n\nproc parseRst(text: string,\n              line, column: int,\n              conf: ConfigRef, sharedState: PRstSharedState): PRstNode =\n  declareClosures()\n  result = rstParsePass1(text, line, column, sharedState)\n\nproc getOutFile2(conf: ConfigRef; filename: RelativeFile,\n                 ext: string, guessTarget: bool): AbsoluteFile =\n  if optWholeProject in conf.globalOptions or guessTarget:\n    let d = conf.outDir\n    createDir(d)\n    result = d / changeFileExt(filename, ext)\n  elif not conf.outFile.isEmpty:\n    result = absOutFile(conf)\n  else:\n    result = getOutFile(conf, filename, ext)\n\nproc isLatexCmd(conf: ConfigRef): bool = conf.cmd in {cmdRst2tex, cmdDoc2tex}\n\nproc newDocumentor*(filename: AbsoluteFile; cache: IdentCache; conf: ConfigRef,\n                    outExt: string = HtmlExt, module: PSym = nil,\n                    isPureRst = false): PDoc =\n  declareClosures()\n  new(result)\n  result.module = module\n  result.conf = conf\n  result.cache = cache\n  result.outDir = conf.outDir.string\n  result.isPureRst = isPureRst\n  var options= {roSupportRawDirective, roSupportMarkdown, roPreferMarkdown, roSandboxDisabled}\n  if not isPureRst: options.incl roNimFile\n  result.sharedState = newRstSharedState(\n      options, filename.string,\n      docgenFindFile, compilerMsgHandler)\n  initRstGenerator(result[], (if conf.isLatexCmd: outLatex else: outHtml),\n                   conf.configVars, filename.string,\n                   docgenFindFile, compilerMsgHandler)\n\n  if conf.configVars.hasKey(\"doc.googleAnalytics\"):\n    result.analytics = \"\"\"\n<script>\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n  ga('create', '$1', 'auto');\n  ga('send', 'pageview');\n\n</script>\n    \"\"\" % [conf.configVars.getOrDefault\"doc.googleAnalytics\"]\n  else:\n    result.analytics = \"\"\n\n  result.seenSymbols = newStringTable(modeCaseInsensitive)\n  result.id = 100\n  result.jEntriesFinal = newJArray()\n  initStrTable result.types\n  result.onTestSnippet =\n    proc (gen: var RstGenerator; filename, cmd: string; status: int; content: string) =\n      if conf.docCmd == docCmdSkip: return\n      inc(gen.id)\n      var d = (ptr TDocumentor)(addr gen)\n      var outp: AbsoluteFile\n      if filename.len == 0:\n        let nameOnly = splitFile(d.filename).name\n        # \"snippets\" needed, refs bug #17183\n        outp = getNimcacheDir(conf) / \"snippets\".RelativeDir / RelativeDir(nameOnly) /\n               RelativeFile(nameOnly & \"_snippet_\" & $d.id & \".nim\")\n      elif isAbsolute(filename):\n        outp = AbsoluteFile(filename)\n      else:\n        # Nim's convention: every path is relative to the file it was written in:\n        let nameOnly = splitFile(d.filename).name\n        outp = AbsoluteDir(nameOnly) / RelativeFile(filename)\n      # Make sure the destination directory exists\n      createDir(outp.splitFile.dir)\n      # Include the current file if we're parsing a nim file\n      let importStmt = if d.isPureRst: \"\" else: \"import \\\"$1\\\"\\n\" % [d.filename.replace(\"\\\\\", \"/\")]\n      writeFile(outp, importStmt & content)\n\n      proc interpSnippetCmd(cmd: string): string =\n        # backward compatibility hacks; interpolation commands should explicitly use `$`\n        if cmd.startsWith \"nim \": result = \"$nim \" & cmd[4..^1]\n        else: result = cmd\n        # factor with D20210224T221756\n        result = result.replace(\"$1\", \"$options\") % [\n          \"nim\", os.getAppFilename().quoteShell,\n          \"libpath\", quoteShell(d.conf.libpath),\n          \"docCmd\", d.conf.docCmd,\n          \"backend\", $d.conf.backend,\n          \"options\", outp.quoteShell,\n            # xxx `quoteShell` seems buggy if user passes options = \"-d:foo somefile.nim\"\n        ]\n      let cmd = cmd.interpSnippetCmd\n      rawMessage(conf, hintExecuting, cmd)\n      let (output, gotten) = execCmdEx(cmd)\n      if gotten != status:\n        rawMessage(conf, errGenerated, \"snippet failed: cmd: '$1' status: $2 expected: $3 output: $4\" % [cmd, $gotten, $status, output])\n  result.emitted = initIntSet()\n  result.destFile = getOutFile2(conf, presentationPath(conf, filename), outExt, false).string\n  result.thisDir = result.destFile.AbsoluteFile.splitFile.dir\n\ntemplate dispA(conf: ConfigRef; dest: var string, xml, tex: string,\n               args: openArray[string]) =\n  if not conf.isLatexCmd: dest.addf(xml, args)\n  else: dest.addf(tex, args)\n\nproc getVarIdx(varnames: openArray[string], id: string): int =\n  for i in 0..high(varnames):\n    if cmpIgnoreStyle(varnames[i], id) == 0:\n      return i\n  result = -1\n\nproc genComment(d: PDoc, n: PNode): PRstNode =\n  if n.comment.len > 0:\n    d.sharedState.currFileIdx = addRstFileIndex(d, n.info)\n    result = parseRst(n.comment,\n                      toLinenumber(n.info),\n                      toColumn(n.info) + DocColOffset,\n                      d.conf, d.sharedState)\n\nproc genRecCommentAux(d: PDoc, n: PNode): PRstNode =\n  if n == nil: return nil\n  result = genComment(d, n)\n  if result == nil:\n    if n.kind in {nkStmtList, nkStmtListExpr, nkTypeDef, nkConstDef,\n                  nkObjectTy, nkRefTy, nkPtrTy, nkAsgn, nkFastAsgn, nkHiddenStdConv}:\n      # notin {nkEmpty..nkNilLit, nkEnumTy, nkTupleTy}:\n      for i in 0..<n.len:\n        result = genRecCommentAux(d, n[i])\n        if result != nil: return\n  else:\n    n.comment = \"\"\n\nproc genRecComment(d: PDoc, n: PNode): PRstNode =\n  if n == nil: return nil\n  result = genComment(d, n)\n  if result == nil:\n    if n.kind in {nkProcDef, nkFuncDef, nkMethodDef, nkIteratorDef,\n                  nkMacroDef, nkTemplateDef, nkConverterDef}:\n      result = genRecCommentAux(d, n[bodyPos])\n    else:\n      result = genRecCommentAux(d, n)\n\nproc getPlainDocstring(n: PNode): string =\n  ## Gets the plain text docstring of a node non destructively.\n  ##\n  ## You need to call this before genRecComment, whose side effects are removal\n  ## of comments from the tree. The proc will recursively scan and return all\n  ## the concatenated ``##`` comments of the node.\n  if n == nil: result = \"\"\n  elif startsWith(n.comment, \"##\"):\n    result = n.comment\n  else:\n    for i in 0..<n.safeLen:\n      result = getPlainDocstring(n[i])\n      if result.len > 0: return\n\nproc belongsToPackage(conf: ConfigRef; module: PSym): bool =\n  result = module.kind == skModule and module.getnimblePkgId == conf.mainPackageId\n\nproc externalDep(d: PDoc; module: PSym): string =\n  if optWholeProject in d.conf.globalOptions or d.conf.docRoot.len > 0:\n    let full = AbsoluteFile toFullPath(d.conf, FileIndex module.position)\n    let tmp = getOutFile2(d.conf, presentationPath(d.conf, full), HtmlExt, sfMainModule notin module.flags)\n    result = relativeTo(tmp, d.thisDir, '/').string\n  else:\n    result = extractFilename toFullPath(d.conf, FileIndex module.position)\n\nproc nodeToHighlightedHtml(d: PDoc; n: PNode; result: var string;\n                           renderFlags: TRenderFlags = {};\n                           procLink: string) =\n  var r: TSrcGen\n  var literal = \"\"\n  initTokRender(r, n, renderFlags)\n  var kind = tkEof\n  var tokenPos = 0\n  var procTokenPos = 0\n  template escLit(): untyped = esc(d.target, literal)\n  while true:\n    getNextTok(r, kind, literal)\n    inc tokenPos\n    case kind\n    of tkEof:\n      break\n    of tkComment:\n      dispA(d.conf, result, \"<span class=\\\"Comment\\\">$1</span>\", \"\\\\spanComment{$1}\",\n            [escLit])\n    of tokKeywordLow..tokKeywordHigh:\n      if kind in {tkProc, tkMethod, tkIterator, tkMacro, tkTemplate, tkFunc, tkConverter}:\n        procTokenPos = tokenPos\n      dispA(d.conf, result, \"<span class=\\\"Keyword\\\">$1</span>\", \"\\\\spanKeyword{$1}\",\n            [literal])\n    of tkOpr:\n      dispA(d.conf, result, \"<span class=\\\"Operator\\\">$1</span>\", \"\\\\spanOperator{$1}\",\n            [escLit])\n    of tkStrLit..tkTripleStrLit, tkCustomLit:\n      dispA(d.conf, result, \"<span class=\\\"StringLit\\\">$1</span>\",\n            \"\\\\spanStringLit{$1}\", [escLit])\n    of tkCharLit:\n      dispA(d.conf, result, \"<span class=\\\"CharLit\\\">$1</span>\", \"\\\\spanCharLit{$1}\",\n            [escLit])\n    of tkIntLit..tkUInt64Lit:\n      dispA(d.conf, result, \"<span class=\\\"DecNumber\\\">$1</span>\",\n            \"\\\\spanDecNumber{$1}\", [escLit])\n    of tkFloatLit..tkFloat128Lit:\n      dispA(d.conf, result, \"<span class=\\\"FloatNumber\\\">$1</span>\",\n            \"\\\\spanFloatNumber{$1}\", [escLit])\n    of tkSymbol:\n      let s = getTokSym(r)\n      # -2 because of the whitespace in between:\n      if procTokenPos == tokenPos-2 and procLink != \"\":\n        dispA(d.conf, result, \"<a href=\\\"#$2\\\"><span class=\\\"Identifier\\\">$1</span></a>\",\n              \"\\\\spanIdentifier{$1}\", [escLit, procLink])\n      elif s != nil and s.kind in {skType, skVar, skLet, skConst} and\n           sfExported in s.flags and s.owner != nil and\n           belongsToPackage(d.conf, s.owner) and d.target == outHtml:\n        let external = externalDep(d, s.owner)\n        result.addf \"<a href=\\\"$1#$2\\\"><span class=\\\"Identifier\\\">$3</span></a>\",\n          [changeFileExt(external, \"html\"), literal,\n           escLit]\n      else:\n        dispA(d.conf, result, \"<span class=\\\"Identifier\\\">$1</span>\",\n              \"\\\\spanIdentifier{$1}\", [escLit])\n    of tkSpaces, tkInvalid:\n      result.add(literal)\n    of tkHideableStart:\n      template fun(s) = dispA(d.conf, result, s, \"\\\\spanOther{$1}\", [escLit])\n      if renderRunnableExamples in renderFlags: fun \"$1\"\n      else:\n        # 1st span is required for the JS to work properly\n        fun \"\"\"\n<span>\n<span class=\"Other pragmadots\">...</span>\n</span>\n<span class=\"pragmawrap\">\"\"\".replace(\"\\n\", \"\")  # Must remove newlines because wrapped in a <pre>\n    of tkHideableEnd:\n      template fun(s) = dispA(d.conf, result, s, \"\\\\spanOther{$1}\", [escLit])\n      if renderRunnableExamples in renderFlags: fun \"$1\"\n      else: fun \"</span>\"\n    of tkCurlyDotLe: dispA(d.conf, result, \"$1\", \"\\\\spanOther{$1}\", [escLit])\n    of tkCurlyDotRi: dispA(d.conf, result, \"$1\", \"\\\\spanOther{$1}\", [escLit])\n    of tkParLe, tkParRi, tkBracketLe, tkBracketRi, tkCurlyLe, tkCurlyRi,\n       tkBracketDotLe, tkBracketDotRi, tkParDotLe,\n       tkParDotRi, tkComma, tkSemiColon, tkColon, tkEquals, tkDot, tkDotDot,\n       tkAccent, tkColonColon,\n       tkGStrLit, tkGTripleStrLit, tkInfixOpr, tkPrefixOpr, tkPostfixOpr,\n       tkBracketLeColon:\n      dispA(d.conf, result, \"<span class=\\\"Other\\\">$1</span>\", \"\\\\spanOther{$1}\",\n            [escLit])\n\nproc exampleOutputDir(d: PDoc): AbsoluteDir = d.conf.getNimcacheDir / RelativeDir\"runnableExamples\"\n\nproc runAllExamples(d: PDoc) =\n  # This used to be: `let backend = if isDefined(d.conf, \"js\"): \"js\"` (etc), however\n  # using `-d:js` (etc) cannot work properly, e.g. would fail with `importjs`\n  # since semantics are affected by `config.backend`, not by isDefined(d.conf, \"js\")\n  let outputDir = d.exampleOutputDir\n  for _, group in d.exampleGroups:\n    if group.docCmd == docCmdSkip: continue\n    let outp = outputDir / RelativeFile(\"$1_group$2_examples.nim\" % [d.filename.splitFile.name, $group.index])\n    group.code = \"# autogenerated by docgen\\n# source: $1\\n# rdoccmd: $2\\n$3\" % [d.filename, group.rdoccmd, group.code]\n    writeFile(outp, group.code)\n    # most useful semantics is that `docCmd` comes after `rdoccmd`, so that we can (temporarily) override\n    # via command line\n    # D20210224T221756:here\n    let cmd = \"$nim $backend -r --lib:$libpath --warning:UnusedImport:off --path:$path --nimcache:$nimcache $rdoccmd $docCmd $file\" % [\n      \"nim\", quoteShell(os.getAppFilename()),\n      \"backend\", $d.conf.backend,\n      \"path\", quoteShell(d.conf.projectPath),\n      \"libpath\", quoteShell(d.conf.libpath),\n      \"nimcache\", quoteShell(outputDir),\n      \"file\", quoteShell(outp),\n      \"rdoccmd\", group.rdoccmd,\n      \"docCmd\", group.docCmd,\n    ]\n    if d.conf.backend == backendJs and findNodeJs() == \"\":\n      discard \"ignore JS runnableExample\"\n    elif os.execShellCmd(cmd) != 0:\n      d.conf.quitOrRaise \"[runnableExamples] failed: generated file: '$1' group: '$2' cmd: $3\" % [outp.string, group[].prettyString, cmd]\n    else:\n      # keep generated source file `outp` to allow inspection.\n      rawMessage(d.conf, hintSuccess, [\"runnableExamples: \" & outp.string])\n      # removeFile(outp.changeFileExt(ExeExt)) # it's in nimcache, no need to remove\n\nproc quoted(a: string): string = result.addQuoted(a)\n\nproc toInstantiationInfo(conf: ConfigRef, info: TLineInfo): auto =\n  # xxx expose in compiler/lineinfos.nim\n  (conf.toMsgFilename(info), info.line.int, info.col.int + ColOffset)\n\nproc prepareExample(d: PDoc; n: PNode, topLevel: bool): tuple[rdoccmd: string, code: string] =\n  ## returns `rdoccmd` and source code for this runnableExamples\n  var rdoccmd = \"\"\n  if n.len < 2 or n.len > 3: globalError(d.conf, n.info, \"runnableExamples invalid\")\n  if n.len == 3:\n    let n1 = n[1]\n    # xxx this should be evaluated during sempass\n    if n1.kind notin nkStrKinds: globalError(d.conf, n1.info, \"string litteral expected\")\n    rdoccmd = n1.strVal\n\n  let useRenderModule = false\n  let loc = d.conf.toFileLineCol(n.info)\n  let code = extractRunnableExamplesSource(d.conf, n)\n  let codeIndent = extractRunnableExamplesSource(d.conf, n, indent = 2)\n\n  if d.conf.errorCounter > 0:\n    return (rdoccmd, code)\n\n  let comment = \"autogenerated by docgen\\nloc: $1\\nrdoccmd: $2\" % [loc, rdoccmd]\n  let outputDir = d.exampleOutputDir\n  createDir(outputDir)\n  inc d.exampleCounter\n  let outp = outputDir / RelativeFile(\"$#_examples_$#.nim\" % [d.filename.extractFilename.changeFileExt\"\", $d.exampleCounter])\n\n  if useRenderModule:\n    var docComment = newTree(nkCommentStmt)\n    docComment.comment = comment\n    var runnableExamples = newTree(nkStmtList,\n        docComment,\n        newTree(nkImportStmt, newStrNode(nkStrLit, d.filename)))\n    runnableExamples.info = n.info\n    for a in n.lastSon: runnableExamples.add a\n\n    # buggy, refs bug #17292\n    # still worth fixing as it can affect other code relying on `renderModule`,\n    # so we keep this code path here for now, which could still be useful in some\n    # other situations.\n    renderModule(runnableExamples, outp.string, conf = d.conf)\n\n  else:\n    var code2 = code\n    if code.len > 0 and \"codeReordering\" notin code:\n      # hacky but simplest solution, until we devise a way to make `{.line.}`\n      # work without introducing a scope\n      code2 = \"\"\"\n{.line: $#.}:\n$#\n\"\"\" % [$toInstantiationInfo(d.conf, n.info), codeIndent]\n    code2 = \"\"\"\n#[\n$#\n]#\nimport $#\n$#\n\"\"\" % [comment, d.filename.quoted, code2]\n    writeFile(outp.string, code2)\n\n  if rdoccmd notin d.exampleGroups:\n    d.exampleGroups[rdoccmd] = ExampleGroup(rdoccmd: rdoccmd, docCmd: d.conf.docCmd, index: d.exampleGroups.len)\n  d.exampleGroups[rdoccmd].code.add \"import $1\\n\" % outp.string.quoted\n\n  var codeShown: string\n  if topLevel: # refs https://github.com/nim-lang/RFCs/issues/352\n    let title = canonicalImport(d.conf, AbsoluteFile d.filename)\n    codeShown = \"import $#\\n$#\" % [title, code]\n  else:\n    codeShown = code\n  result = (rdoccmd, codeShown)\n  when false:\n    proc extractImports(n: PNode; result: PNode) =\n      if n.kind in {nkImportStmt, nkImportExceptStmt, nkFromStmt}:\n        result.add copyTree(n)\n        n.kind = nkEmpty\n        return\n      for i in 0..<n.safeLen: extractImports(n[i], result)\n    let imports = newTree(nkStmtList)\n    var savedLastSon = copyTree n.lastSon\n    extractImports(savedLastSon, imports)\n    for imp in imports: runnableExamples.add imp\n    runnableExamples.add newTree(nkBlockStmt, newNode(nkEmpty), copyTree savedLastSon)\n\ntype RunnableState = enum\n  rsStart\n  rsComment\n  rsRunnable\n  rsDone\n\nproc getAllRunnableExamplesImpl(d: PDoc; n: PNode, dest: var ItemPre,\n                                state: RunnableState, topLevel: bool):\n                               RunnableState =\n  ##[\n  Simple state machine to tell whether we render runnableExamples and doc comments.\n  This is to ensure that we can interleave runnableExamples and doc comments freely;\n  the logic is easy to change but currently a doc comment following another doc comment\n  will not render, to avoid rendering in following case:\n\n  proc fn* =\n    runnableExamples: discard\n    ## d1\n    runnableExamples: discard\n    ## d2\n\n    ## internal explanation  # <- this one should be out; it's part of rest of function body and would likey not make sense in doc comment\n    discard # some code\n  ]##\n\n  case n.kind\n  of nkCommentStmt:\n    if state in {rsStart, rsRunnable}:\n      dest.add genRecComment(d, n)\n      return rsComment\n  of nkCallKinds:\n    if isRunnableExamples(n[0]) and\n        n.len >= 2 and n.lastSon.kind == nkStmtList:\n      if state in {rsStart, rsComment, rsRunnable}:\n        let (rdoccmd, code) = prepareExample(d, n, topLevel)\n        var msg = \"Example:\"\n        if rdoccmd.len > 0: msg.add \" cmd: \" & rdoccmd\n        var s: string\n        dispA(d.conf, s, \"\\n<p><strong class=\\\"examples_text\\\">$1</strong></p>\\n\",\n            \"\\n\\n\\\\textbf{$1}\\n\", [msg])\n        dest.add s\n        inc d.listingCounter\n        let id = $d.listingCounter\n        dest.add(d.config.getOrDefault\"doc.listing_start\" % [id, \"langNim\", \"\"])\n        var dest2 = \"\"\n        renderNimCode(dest2, code, d.target)\n        dest.add dest2\n        dest.add(d.config.getOrDefault\"doc.listing_end\" % id)\n        return rsRunnable\n      else:\n        localError(d.conf, n.info, errUser, \"runnableExamples must appear before the first non-comment statement\")\n  else: discard\n  return rsDone\n    # change this to `rsStart` if you want to keep generating doc comments\n    # and runnableExamples that occur after some code in routine\n\nproc getRoutineBody(n: PNode): PNode =\n  ##[\n  nim transforms these quite differently:\n\n  proc someType*(): int =\n    ## foo\n    result = 3\n=>\n  result =\n    ## foo\n    3;\n\n  proc someType*(): int =\n    ## foo\n    3\n=>\n  ## foo\n  result = 3;\n\n  so we normalize the results to get to the statement list containing the\n  (0 or more) doc comments and runnableExamples.\n  ]##\n  result = n[bodyPos]\n\n  # This won't be transformed: result.id = 10. Namely result[0].kind != nkSym.\n  if result.kind == nkAsgn and result[0].kind == nkSym and\n                               n.len > bodyPos+1 and n[bodyPos+1].kind == nkSym:\n    doAssert result.len == 2\n    result = result[1]\n\nproc getAllRunnableExamples(d: PDoc, n: PNode, dest: var ItemPre) =\n  var n = n\n  var state = rsStart\n  template fn(n2, topLevel) =\n    state = getAllRunnableExamplesImpl(d, n2, dest, state, topLevel)\n  dest.add genComment(d, n)\n  case n.kind\n  of routineDefs:\n    n = n.getRoutineBody\n    case n.kind\n    of nkCommentStmt, nkCallKinds: fn(n, topLevel = false)\n    else:\n      for i in 0..<n.safeLen:\n        fn(n[i], topLevel = false)\n        if state == rsDone: discard # check all sons\n  else: fn(n, topLevel = true)\n\nproc isVisible(d: PDoc; n: PNode): bool =\n  result = false\n  if n.kind == nkPostfix:\n    if n.len == 2 and n[0].kind == nkIdent:\n      var v = n[0].ident\n      result = v.id == ord(wStar) or v.id == ord(wMinus)\n  elif n.kind == nkSym:\n    # we cannot generate code for forwarded symbols here as we have no\n    # exception tracking information here. Instead we copy over the comment\n    # from the proc header.\n    if optDocInternal in d.conf.globalOptions:\n      result = {sfFromGeneric, sfForward}*n.sym.flags == {}\n    else:\n      result = {sfExported, sfFromGeneric, sfForward}*n.sym.flags == {sfExported}\n    if result and containsOrIncl(d.emitted, n.sym.id):\n      result = false\n  elif n.kind == nkPragmaExpr:\n    result = isVisible(d, n[0])\n\nproc getName(d: PDoc, n: PNode, splitAfter = -1): string =\n  case n.kind\n  of nkPostfix: result = getName(d, n[1], splitAfter)\n  of nkPragmaExpr: result = getName(d, n[0], splitAfter)\n  of nkSym: result = esc(d.target, n.sym.renderDefinitionName, splitAfter)\n  of nkIdent: result = esc(d.target, n.ident.s, splitAfter)\n  of nkAccQuoted:\n    result = esc(d.target, \"`\")\n    for i in 0..<n.len: result.add(getName(d, n[i], splitAfter))\n    result.add esc(d.target, \"`\")\n  of nkOpenSymChoice, nkClosedSymChoice:\n    result = getName(d, n[0], splitAfter)\n  else:\n    result = \"\"\n\nproc getNameIdent(cache: IdentCache; n: PNode): PIdent =\n  case n.kind\n  of nkPostfix: result = getNameIdent(cache, n[1])\n  of nkPragmaExpr: result = getNameIdent(cache, n[0])\n  of nkSym: result = n.sym.name\n  of nkIdent: result = n.ident\n  of nkAccQuoted:\n    var r = \"\"\n    for i in 0..<n.len: r.add(getNameIdent(cache, n[i]).s)\n    result = getIdent(cache, r)\n  of nkOpenSymChoice, nkClosedSymChoice:\n    result = getNameIdent(cache, n[0])\n  else:\n    result = nil\n\nproc getRstName(n: PNode): PRstNode =\n  case n.kind\n  of nkPostfix: result = getRstName(n[1])\n  of nkPragmaExpr: result = getRstName(n[0])\n  of nkSym: result = newRstLeaf(n.sym.renderDefinitionName)\n  of nkIdent: result = newRstLeaf(n.ident.s)\n  of nkAccQuoted:\n    result = getRstName(n[0])\n    for i in 1..<n.len: result.text.add(getRstName(n[i]).text)\n  of nkOpenSymChoice, nkClosedSymChoice:\n    result = getRstName(n[0])\n  else:\n    result = nil\n\nproc newUniquePlainSymbol(d: PDoc, original: string): string =\n  ## Returns a new unique plain symbol made up from the original.\n  ##\n  ## When a collision is found in the seenSymbols table, new numerical variants\n  ## with underscore + number will be generated.\n  if not d.seenSymbols.hasKey(original):\n    result = original\n    d.seenSymbols[original] = \"\"\n    return\n  # Iterate over possible numeric variants of the original name.\n  var count = 2\n  while true:\n    result = original & \"_\" & $count\n    if not d.seenSymbols.hasKey(result):\n      d.seenSymbols[result] = \"\"\n      break\n    count += 1\n\nproc complexName(k: TSymKind, n: PNode, baseName: string): string =\n  ## Builds a complex unique href name for the node.\n  ##\n  ## Pass as ``baseName`` the plain symbol obtained from the nodeName. The\n  ## format of the returned symbol will be ``baseName(.callable type)?,(param\n  ## type)?(,param type)*``. The callable type part will be added only if the\n  ## node is not a proc, as those are the common ones. The suffix will be a dot\n  ## and a single letter representing the type of the callable. The parameter\n  ## types will be added with a preceding dash. Return types won't be added.\n  ##\n  ## If you modify the output of this proc, please update the anchor generation\n  ## section of ``doc/docgen.rst``.\n  result = baseName\n  case k\n  of skProc, skFunc: discard\n  of skMacro: result.add(\".m\")\n  of skMethod: result.add(\".e\")\n  of skIterator: result.add(\".i\")\n  of skTemplate: result.add(\".t\")\n  of skConverter: result.add(\".c\")\n  else: discard\n  if n.safeLen > paramsPos and n[paramsPos].kind == nkFormalParams:\n    let params = renderParamTypes(n[paramsPos])\n    if params.len > 0:\n      result.add(defaultParamSeparator)\n      result.add(params)\n\nproc docstringSummary(rstText: string): string =\n  ## Returns just the first line or a brief chunk of text from a rst string.\n  ##\n  ## Most docstrings will contain a one liner summary, so stripping at the\n  ## first newline is usually fine. If after that the content is still too big,\n  ## it is stripped at the first comma, colon or dot, usual English sentence\n  ## separators.\n  ##\n  ## No guarantees are made on the size of the output, but it should be small.\n  ## Also, we hope to not break the rst, but maybe we do. If there is any\n  ## trimming done, an ellipsis unicode char is added.\n  const maxDocstringChars = 100\n  assert(rstText.len < 2 or (rstText[0] == '#' and rstText[1] == '#'))\n  result = rstText.substr(2).strip\n  var pos = result.find('\\L')\n  if pos > 0:\n    result.setLen(pos - 1)\n    result.add(\"\u2026\")\n  if pos < maxDocstringChars:\n    return\n  # Try to keep trimming at other natural boundaries.\n  pos = result.find({'.', ',', ':'})\n  let last = result.len - 1\n  if pos > 0 and pos < last:\n    result.setLen(pos - 1)\n    result.add(\"\u2026\")\n\nproc genDeprecationMsg(d: PDoc, n: PNode): string =\n  ## Given a nkPragma wDeprecated node output a well-formatted section\n  if n == nil: return\n\n  case n.safeLen:\n  of 0: # Deprecated w/o any message\n    result = getConfigVar(d.conf, \"doc.deprecationmsg\") % [\n       \"label\" , \"Deprecated\", \"message\", \"\"]\n  of 2: # Deprecated w/ a message\n    if n[1].kind in {nkStrLit..nkTripleStrLit}:\n      result = getConfigVar(d.conf, \"doc.deprecationmsg\") % [\n          \"label\", \"Deprecated:\", \"message\", xmltree.escape(n[1].strVal)]\n  else:\n    doAssert false\n\ntype DocFlags = enum\n  kDefault\n  kForceExport\n\nproc genSeeSrc(d: PDoc, path: string, line: int): string =\n  let docItemSeeSrc = getConfigVar(d.conf, \"doc.item.seesrc\")\n  if docItemSeeSrc.len > 0:\n    let path = relativeTo(AbsoluteFile path, AbsoluteDir getCurrentDir(), '/')\n    when false:\n      let cwd = canonicalizePath(d.conf, getCurrentDir())\n      var path = path\n      if path.startsWith(cwd):\n        path = path[cwd.len+1..^1].replace('\\\\', '/')\n    let gitUrl = getConfigVar(d.conf, \"git.url\")\n    if gitUrl.len > 0:\n      let defaultBranch =\n        if NimPatch mod 2 == 1: \"devel\"\n        else: \"version-$1-$2\" % [$NimMajor, $NimMinor]\n      let commit = getConfigVar(d.conf, \"git.commit\", defaultBranch)\n      let develBranch = getConfigVar(d.conf, \"git.devel\", \"devel\")\n      dispA(d.conf, result, \"$1\", \"\", [docItemSeeSrc % [\n          \"path\", path.string, \"line\", $line, \"url\", gitUrl,\n          \"commit\", commit, \"devel\", develBranch]])\n\nproc symbolPriority(k: TSymKind): int =\n  result = case k\n    of skMacro: -3\n    of skTemplate: -2\n    of skIterator: -1\n    else: 0  # including skProc which have higher priority\n    # documentation itself has even higher priority 1\n\nproc toLangSymbol(k: TSymKind, n: PNode, baseName: string): LangSymbol =\n  ## Converts symbol info (names/types/parameters) in `n` into format\n  ## `LangSymbol` convenient for ``rst.nim``/``dochelpers.nim``.\n  result.name = baseName.nimIdentNormalize\n  result.symKind = k.toHumanStr\n  if k in routineKinds:\n    var\n      paramTypes: seq[string]\n    renderParamTypes(paramTypes, n[paramsPos], toNormalize=true)\n    let paramNames = renderParamNames(n[paramsPos], toNormalize=true)\n    # In some rare cases (system.typeof) parameter type is not set for default:\n    doAssert paramTypes.len <= paramNames.len\n    for i in 0 ..< paramNames.len:\n      if i < paramTypes.len:\n        result.parameters.add (paramNames[i], paramTypes[i])\n      else:\n        result.parameters.add (paramNames[i], \"\")\n    result.parametersProvided = true\n\n    result.outType = renderOutType(n[paramsPos], toNormalize=true)\n\n  if k in {skProc, skFunc, skType, skIterator}:\n    # Obtain `result.generics`\n    # Use `n[miscPos]` since n[genericParamsPos] does not contain constraints\n    var genNode: PNode = nil\n    if k == skType:\n      genNode = n[1]  # FIXME: what is index 1?\n    else:\n      if n[miscPos].kind != nkEmpty:\n        genNode = n[miscPos][1]   # FIXME: what is index 1?\n    if genNode != nil:\n      var literal = \"\"\n      var r: TSrcGen\n      initTokRender(r, genNode, {renderNoBody, renderNoComments,\n        renderNoPragmas, renderNoProcDefs})\n      var kind = tkEof\n      while true:\n        getNextTok(r, kind, literal)\n        if kind == tkEof:\n          break\n        if kind != tkSpaces:\n          result.generics.add(literal.nimIdentNormalize)\n\n  if k == skType:\n    case n[2].kind\n    of nkEnumTy: result.symTypeKind = \"enum\"\n    of nkObjectTy: result.symTypeKind = \"object\"\n    of nkTupleTy: result.symTypeKind = \"tuple\"\n    else: discard\n\nproc genItem(d: PDoc, n, nameNode: PNode, k: TSymKind, docFlags: DocFlags) =\n  if (docFlags != kForceExport) and not isVisible(d, nameNode): return\n  let\n    name = getName(d, nameNode)\n  var plainDocstring = getPlainDocstring(n) # call here before genRecComment!\n  var result = \"\"\n  var literal, plainName = \"\"\n  var kind = tkEof\n  var comm: ItemPre\n  if n.kind in routineDefs:\n    getAllRunnableExamples(d, n, comm)\n  else:\n    comm.add genRecComment(d, n)\n\n  var r: TSrcGen\n  # Obtain the plain rendered string for hyperlink titles.\n  initTokRender(r, n, {renderNoBody, renderNoComments, renderDocComments,\n    renderNoPragmas, renderNoProcDefs})\n  while true:\n    getNextTok(r, kind, literal)\n    if kind == tkEof:\n      break\n    plainName.add(literal)\n\n  var pragmaNode = getDeclPragma(n)\n  if pragmaNode != nil: pragmaNode = findPragma(pragmaNode, wDeprecated)\n\n  inc(d.id)\n  let\n    plainNameEsc = esc(d.target, plainName.strip)\n    detailedName = k.toHumanStr & \" \" & (\n        if k in routineKinds: plainName else: name)\n    uniqueName = if k in routineKinds: plainNameEsc else: name\n    sortName = if k in routineKinds: plainName.strip else: name\n    cleanPlainSymbol = renderPlainSymbolName(nameNode)\n    complexSymbol = complexName(k, n, cleanPlainSymbol)\n    plainSymbolEnc = encodeUrl(cleanPlainSymbol, usePlus = false)\n    symbolOrId = d.newUniquePlainSymbol(complexSymbol)\n    symbolOrIdEnc = encodeUrl(symbolOrId, usePlus = false)\n    deprecationMsg = genDeprecationMsg(d, pragmaNode)\n    rstLangSymbol = toLangSymbol(k, n, cleanPlainSymbol)\n\n  # we generate anchors automatically for subsequent use in doc comments\n  let lineinfo = rstast.TLineInfo(\n      line: nameNode.info.line, col: nameNode.info.col,\n      fileIndex: addRstFileIndex(d, nameNode.info))\n  addAnchorNim(d.sharedState, refn = symbolOrId, tooltip = detailedName,\n               rstLangSymbol, priority = symbolPriority(k), info = lineinfo)\n\n  nodeToHighlightedHtml(d, n, result, {renderNoBody, renderNoComments,\n    renderDocComments, renderSyms}, symbolOrIdEnc)\n\n  let seeSrc = genSeeSrc(d, toFullPath(d.conf, n.info), n.info.line.int)\n\n  d.section[k].secItems.mgetOrPut(cleanPlainSymbol, newSeq[Item]()).add Item(\n    descRst: comm,\n    sortName: sortName,\n    info: lineinfo,\n    anchor: symbolOrId,\n    detailedName: detailedName,\n    name: name,\n    substitutions: @[\n     \"uniqueName\", uniqueName,\n     \"header\", result, \"itemID\", $d.id,\n     \"header_plain\", plainNameEsc, \"itemSym\", cleanPlainSymbol,\n     \"itemSymEnc\", plainSymbolEnc,\n     \"itemSymOrIDEnc\", symbolOrIdEnc, \"seeSrc\", seeSrc,\n     \"deprecationMsg\", deprecationMsg])\n\n  let external = d.destFile.AbsoluteFile.relativeTo(d.conf.outDir, '/').changeFileExt(HtmlExt).string\n\n  var attype = \"\"\n  if k in routineKinds and nameNode.kind == nkSym:\n    let att = attachToType(d, nameNode.sym)\n    if att != nil:\n      attype = esc(d.target, att.name.s)\n  elif k == skType and nameNode.kind == nkSym and nameNode.sym.typ.kind in {tyEnum, tyBool}:\n    let etyp = nameNode.sym.typ\n    for e in etyp.n:\n      if e.sym.kind != skEnumField: continue\n      let plain = renderPlainSymbolName(e)\n      let symbolOrId = d.newUniquePlainSymbol(plain)\n      setIndexTerm(d[], external, symbolOrId, plain, nameNode.sym.name.s & '.' & plain,\n        xmltree.escape(getPlainDocstring(e).docstringSummary))\n\n  d.tocSimple[k].add TocItem(\n    sortName: sortName,\n    content: getConfigVar(d.conf, \"doc.item.toc\") % [\n      \"name\", name, \"header_plain\", plainNameEsc,\n      \"itemSymOrIDEnc\", symbolOrIdEnc])\n\n  d.tocTable[k].mgetOrPut(cleanPlainSymbol, newSeq[TocItem]()).add TocItem(\n    sortName: sortName,\n    content: getConfigVar(d.conf, \"doc.item.tocTable\") % [\n      \"name\", name, \"header_plain\", plainNameEsc,\n      \"itemSymOrID\", symbolOrId.replace(\",\", \",<wbr>\"),\n      \"itemSymOrIDEnc\", symbolOrIdEnc])\n\n  # Ironically for types the complexSymbol is *cleaner* than the plainName\n  # because it doesn't include object fields or documentation comments. So we\n  # use the plain one for callable elements, and the complex for the rest.\n  var linkTitle = changeFileExt(extractFilename(d.filename), \"\") & \": \"\n  if n.kind in routineDefs: linkTitle.add(xmltree.escape(plainName.strip))\n  else: linkTitle.add(xmltree.escape(complexSymbol.strip))\n\n  setIndexTerm(d[], external, symbolOrId, name, linkTitle,\n    xmltree.escape(plainDocstring.docstringSummary))\n  if k == skType and nameNode.kind == nkSym:\n    d.types.strTableAdd nameNode.sym\n\nproc genJsonItem(d: PDoc, n, nameNode: PNode, k: TSymKind): JsonItem =\n  if not isVisible(d, nameNode): return\n  var\n    name = getName(d, nameNode)\n    comm = genRecComment(d, n)\n    r: TSrcGen\n  initTokRender(r, n, {renderNoBody, renderNoComments, renderDocComments})\n  result.json = %{ \"name\": %name, \"type\": %($k), \"line\": %n.info.line.int,\n                   \"col\": %n.info.col}\n  if comm != nil:\n    result.rst = comm\n    result.rstField = \"description\"\n  if r.buf.len > 0:\n    result.json[\"code\"] = %r.buf\n  if k in routineKinds:\n    result.json[\"signature\"] = newJObject()\n    if n[paramsPos][0].kind != nkEmpty:\n      result.json[\"signature\"][\"return\"] = %($n[paramsPos][0])\n    if n[paramsPos].len > 1:\n      result.json[\"signature\"][\"arguments\"] = newJArray()\n    for paramIdx in 1 ..< n[paramsPos].len:\n      for identIdx in 0 ..< n[paramsPos][paramIdx].len - 2:\n        let\n          paramName = $n[paramsPos][paramIdx][identIdx]\n          paramType = $n[paramsPos][paramIdx][^2]\n        if n[paramsPos][paramIdx][^1].kind != nkEmpty:\n          let paramDefault = $n[paramsPos][paramIdx][^1]\n          result.json[\"signature\"][\"arguments\"].add %{\"name\": %paramName, \"type\": %paramType, \"default\": %paramDefault}\n        else:\n          result.json[\"signature\"][\"arguments\"].add %{\"name\": %paramName, \"type\": %paramType}\n    if n[pragmasPos].kind != nkEmpty:\n      result.json[\"signature\"][\"pragmas\"] = newJArray()\n      for pragma in n[pragmasPos]:\n        result.json[\"signature\"][\"pragmas\"].add %($pragma)\n    if n[genericParamsPos].kind != nkEmpty:\n      result.json[\"signature\"][\"genericParams\"] = newJArray()\n      for genericParam in n[genericParamsPos]:\n        var param = %{\"name\": %($genericParam)}\n        if genericParam.sym.typ.sons.len > 0:\n          param[\"types\"] = newJArray()\n        for kind in genericParam.sym.typ.sons:\n          param[\"types\"].add %($kind)\n        result.json[\"signature\"][\"genericParams\"].add param\n\nproc checkForFalse(n: PNode): bool =\n  result = n.kind == nkIdent and cmpIgnoreStyle(n.ident.s, \"false\") == 0\n\nproc traceDeps(d: PDoc, it: PNode) =\n  const k = skModule\n  if it.kind == nkInfix and it.len == 3 and it[2].kind == nkBracket:\n    let sep = it[0]\n    let dir = it[1]\n    let a = newNodeI(nkInfix, it.info)\n    a.add sep\n    a.add dir\n    a.add sep # dummy entry, replaced in the loop\n    for x in it[2]:\n      a[2] = x\n      traceDeps(d, a)\n  elif it.kind == nkSym and belongsToPackage(d.conf, it.sym):\n    let external = externalDep(d, it.sym)\n    if d.section[k].finalMarkup != \"\": d.section[k].finalMarkup.add(\", \")\n    dispA(d.conf, d.section[k].finalMarkup,\n          \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n          \"$1\", [esc(d.target, external.prettyLink),\n                 changeFileExt(external, \"html\")])\n\nproc exportSym(d: PDoc; s: PSym) =\n  const k = exportSection\n  if s.kind == skModule and belongsToPackage(d.conf, s):\n    let external = externalDep(d, s)\n    if d.section[k].finalMarkup != \"\": d.section[k].finalMarkup.add(\", \")\n    dispA(d.conf, d.section[k].finalMarkup,\n          \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n          \"$1\", [esc(d.target, external.prettyLink),\n                 changeFileExt(external, \"html\")])\n  elif s.kind != skModule and s.owner != nil:\n    let module = originatingModule(s)\n    if belongsToPackage(d.conf, module):\n      let\n        complexSymbol = complexName(s.kind, s.ast, s.name.s)\n        symbolOrId = d.newUniquePlainSymbol(complexSymbol)\n        external = externalDep(d, module)\n      if d.section[k].finalMarkup != \"\": d.section[k].finalMarkup.add(\", \")\n      # XXX proper anchor generation here\n      dispA(d.conf, d.section[k].finalMarkup,\n            \"<a href=\\\"$2#$3\\\"><span class=\\\"Identifier\\\">$1</span></a>\",\n            \"$1\", [esc(d.target, s.name.s),\n                   changeFileExt(external, \"html\"),\n                   symbolOrId])\n\nproc documentNewEffect(cache: IdentCache; n: PNode): PNode =\n  let s = n[namePos].sym\n  if tfReturnsNew in s.typ.flags:\n    result = newIdentNode(getIdent(cache, \"new\"), n.info)\n\nproc documentEffect(cache: IdentCache; n, x: PNode, effectType: TSpecialWord, idx: int): PNode =\n  let spec = effectSpec(x, effectType)\n  if isNil(spec):\n    let s = n[namePos].sym\n\n    let actual = s.typ.n[0]\n    if actual.len != effectListLen: return\n    let real = actual[idx]\n    if real == nil: return\n    let realLen = real.len\n    # warning: hack ahead:\n    var effects = newNodeI(nkBracket, n.info, realLen)\n    for i in 0..<realLen:\n      var t = typeToString(real[i].typ)\n      if t.startsWith(\"ref \"): t = substr(t, 4)\n      effects[i] = newIdentNode(getIdent(cache, t), n.info)\n      # set the type so that the following analysis doesn't screw up:\n      effects[i].typ = real[i].typ\n\n    result = newTreeI(nkExprColonExpr, n.info,\n      newIdentNode(getIdent(cache, $effectType), n.info), effects)\n\nproc documentWriteEffect(cache: IdentCache; n: PNode; flag: TSymFlag; pragmaName: string): PNode =\n  let s = n[namePos].sym\n  let params = s.typ.n\n\n  var effects = newNodeI(nkBracket, n.info)\n  for i in 1..<params.len:\n    if params[i].kind == nkSym and flag in params[i].sym.flags:\n      effects.add params[i]\n\n  if effects.len > 0:\n    result = newTreeI(nkExprColonExpr, n.info,\n      newIdentNode(getIdent(cache, pragmaName), n.info), effects)\n\nproc documentRaises*(cache: IdentCache; n: PNode) =\n  if n[namePos].kind != nkSym: return\n  let pragmas = n[pragmasPos]\n  let p1 = documentEffect(cache, n, pragmas, wRaises, exceptionEffects)\n  let p2 = documentEffect(cache, n, pragmas, wTags, tagEffects)\n  let p3 = documentWriteEffect(cache, n, sfWrittenTo, \"writes\")\n  let p4 = documentNewEffect(cache, n)\n  let p5 = documentWriteEffect(cache, n, sfEscapes, \"escapes\")\n\n  if p1 != nil or p2 != nil or p3 != nil or p4 != nil or p5 != nil:\n    if pragmas.kind == nkEmpty:\n      n[pragmasPos] = newNodeI(nkPragma, n.info)\n    if p1 != nil: n[pragmasPos].add p1\n    if p2 != nil: n[pragmasPos].add p2\n    if p3 != nil: n[pragmasPos].add p3\n    if p4 != nil: n[pragmasPos].add p4\n    if p5 != nil: n[pragmasPos].add p5\n\nproc generateDoc*(d: PDoc, n, orig: PNode, docFlags: DocFlags = kDefault) =\n  ## Goes through nim nodes recursively and collects doc comments.\n  ## Main function for `doc`:option: command,\n  ## which is implemented in ``docgen2.nim``.\n  template genItemAux(skind) =\n    genItem(d, n, n[namePos], skind, docFlags)\n  case n.kind\n  of nkPragma:\n    let pragmaNode = findPragma(n, wDeprecated)\n    d.modDeprecationMsg.add(genDeprecationMsg(d, pragmaNode))\n  of nkCommentStmt: d.modDescPre.add(genComment(d, n))\n  of nkProcDef, nkFuncDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skProc)\n  of nkMethodDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skMethod)\n  of nkIteratorDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skIterator)\n  of nkMacroDef: genItemAux(skMacro)\n  of nkTemplateDef: genItemAux(skTemplate)\n  of nkConverterDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    genItemAux(skConverter)\n  of nkTypeSection, nkVarSection, nkLetSection, nkConstSection:\n    for i in 0..<n.len:\n      if n[i].kind != nkCommentStmt:\n        # order is always 'type var let const':\n        genItem(d, n[i], n[i][0],\n                succ(skType, ord(n.kind)-ord(nkTypeSection)), docFlags)\n  of nkStmtList:\n    for i in 0..<n.len: generateDoc(d, n[i], orig)\n  of nkWhenStmt:\n    # generate documentation for the first branch only:\n    if not checkForFalse(n[0][0]):\n      generateDoc(d, lastSon(n[0]), orig)\n  of nkImportStmt:\n    for it in n: traceDeps(d, it)\n  of nkExportStmt:\n    for it in n:\n      if it.kind == nkSym:\n        if d.module != nil and d.module == it.sym.owner:\n          generateDoc(d, it.sym.ast, orig, kForceExport)\n        elif it.sym.ast != nil:\n          exportSym(d, it.sym)\n  of nkExportExceptStmt: discard \"transformed into nkExportStmt by semExportExcept\"\n  of nkFromStmt, nkImportExceptStmt: traceDeps(d, n[0])\n  of nkCallKinds:\n    var comm: ItemPre\n    getAllRunnableExamples(d, n, comm)\n    if comm.len != 0: d.modDescPre.add(comm)\n  else: discard\n\nproc overloadGroupName(s: string, k: TSymKind): string =\n  ## Turns a name like `f` into anchor `f-procs-all`\n  #s & \" \" & k.toHumanStr & \"s all\"\n  s & \"-\" & k.toHumanStr & \"s-all\"\n\nproc finishGenerateDoc*(d: var PDoc) =\n  ## Perform 2nd RST pass for resolution of links/footnotes/headings...\n  # copy file map `filenames` to ``rstgen.nim`` for its warnings\n  d.filenames = d.sharedState.filenames\n\n  # Main title/subtitle are allowed only in the first RST fragment of document\n  var firstRst = PRstNode(nil)\n  for fragment in d.modDescPre:\n    if fragment.isRst:\n      firstRst = fragment.rst\n      break\n  preparePass2(d.sharedState, firstRst)\n\n  # add anchors to overload groups before RST resolution\n  for k in TSymKind:\n    if k in routineKinds:\n      for plainName, overloadChoices in d.section[k].secItems:\n        if overloadChoices.len > 1:\n          let refn = overloadGroupName(plainName, k)\n          let tooltip = \"$1 ($2 overloads)\" % [\n                      k.toHumanStr & \" \" & plainName, $overloadChoices.len]\n          addAnchorNim(d.sharedState, refn, tooltip,\n                       LangSymbol(symKind: k.toHumanStr,\n                                  name: nimIdentBackticksNormalize(plainName),\n                                  isGroup: true),\n                       priority = symbolPriority(k),\n                       # select index `0` just to have any meaningful warning:\n                       info = overloadChoices[0].info)\n\n  # Finalize fragments of ``.nim`` or ``.rst`` file\n  proc renderItemPre(d: PDoc, fragments: ItemPre, result: var string) =\n    for f in fragments:\n      case f.isRst:\n      of true:\n        var resolved = resolveSubs(d.sharedState, f.rst)\n        renderRstToOut(d[], resolved, result)\n      of false: result &= f.str\n  proc cmp(x, y: Item): int = cmpDecimalsIgnoreCase(x.sortName, y.sortName)\n  for k in TSymKind:\n    # add symbols to section for each `k`, while optionally wrapping\n    # overloadable items with the same basic name by ``doc.item2``\n    let overloadableNames = toSeq(keys(d.section[k].secItems))\n    for plainName in overloadableNames.sorted(cmpDecimalsIgnoreCase):\n      var overloadChoices = d.section[k].secItems[plainName]\n      overloadChoices.sort(cmp)\n      var nameContent = \"\"\n      for item in overloadChoices:\n        var itemDesc: string\n        renderItemPre(d, item.descRst, itemDesc)\n        nameContent.add(\n          getConfigVar(d.conf, \"doc.item\") % (\n              item.substitutions & @[\n                \"desc\", itemDesc,\n                \"name\", item.name,\n                \"itemSymOrID\", item.anchor]))\n      if k in routineKinds:\n        let plainNameEsc1 = esc(d.target, plainName.strip)\n        let plainNameEsc2 = esc(d.target, plainName.strip, escMode=emUrl)\n        d.section[k].finalMarkup.add(\n          getConfigVar(d.conf, \"doc.item2\") % (\n            @[\"header_plain\", plainNameEsc1,\n              \"overloadGroupName\", overloadGroupName(plainNameEsc2, k),\n              \"content\", nameContent]))\n      else:\n        d.section[k].finalMarkup.add(nameContent)\n    d.section[k].secItems.clear\n  renderItemPre(d, d.modDescPre, d.modDescFinal)\n  d.modDescPre.setLen 0\n  d.hasToc = d.hasToc or d.sharedState.hasToc\n\n  # Finalize fragments of ``.json`` file\n  for i, entry in d.jEntriesPre:\n    if entry.rst != nil:\n      let resolved = resolveSubs(d.sharedState, entry.rst)\n      var str: string\n      renderRstToOut(d[], resolved, str)\n      entry.json[entry.rstField] = %str\n      d.jEntriesFinal.add entry.json\n      d.jEntriesPre[i].rst = nil\n\nproc add(d: PDoc; j: JsonItem) =\n  if j.json != nil or j.rst != nil: d.jEntriesPre.add j\n\nproc generateJson*(d: PDoc, n: PNode, includeComments: bool = true) =\n  case n.kind\n  of nkCommentStmt:\n    if includeComments:\n      d.add JsonItem(rst: genComment(d, n), rstField: \"comment\",\n                     json: %Table[string, string]())\n    else:\n      d.modDescPre.add(genComment(d, n))\n  of nkProcDef, nkFuncDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skProc)\n  of nkMethodDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skMethod)\n  of nkIteratorDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skIterator)\n  of nkMacroDef:\n    d.add genJsonItem(d, n, n[namePos], skMacro)\n  of nkTemplateDef:\n    d.add genJsonItem(d, n, n[namePos], skTemplate)\n  of nkConverterDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    d.add genJsonItem(d, n, n[namePos], skConverter)\n  of nkTypeSection, nkVarSection, nkLetSection, nkConstSection:\n    for i in 0..<n.len:\n      if n[i].kind != nkCommentStmt:\n        # order is always 'type var let const':\n        d.add genJsonItem(d, n[i], n[i][0],\n                succ(skType, ord(n.kind)-ord(nkTypeSection)))\n  of nkStmtList:\n    for i in 0..<n.len:\n      generateJson(d, n[i], includeComments)\n  of nkWhenStmt:\n    # generate documentation for the first branch only:\n    if not checkForFalse(n[0][0]):\n      generateJson(d, lastSon(n[0]), includeComments)\n  else: discard\n\nproc genTagsItem(d: PDoc, n, nameNode: PNode, k: TSymKind): string =\n  result = getName(d, nameNode) & \"\\n\"\n\nproc generateTags*(d: PDoc, n: PNode, r: var string) =\n  case n.kind\n  of nkCommentStmt:\n    if startsWith(n.comment, \"##\"):\n      let stripped = n.comment.substr(2).strip\n      r.add stripped\n  of nkProcDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skProc)\n  of nkFuncDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skFunc)\n  of nkMethodDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skMethod)\n  of nkIteratorDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skIterator)\n  of nkMacroDef:\n    r.add genTagsItem(d, n, n[namePos], skMacro)\n  of nkTemplateDef:\n    r.add genTagsItem(d, n, n[namePos], skTemplate)\n  of nkConverterDef:\n    when useEffectSystem: documentRaises(d.cache, n)\n    r.add genTagsItem(d, n, n[namePos], skConverter)\n  of nkTypeSection, nkVarSection, nkLetSection, nkConstSection:\n    for i in 0..<n.len:\n      if n[i].kind != nkCommentStmt:\n        # order is always 'type var let const':\n        r.add genTagsItem(d, n[i], n[i][0],\n                succ(skType, ord(n.kind)-ord(nkTypeSection)))\n  of nkStmtList:\n    for i in 0..<n.len:\n      generateTags(d, n[i], r)\n  of nkWhenStmt:\n    # generate documentation for the first branch only:\n    if not checkForFalse(n[0][0]):\n      generateTags(d, lastSon(n[0]), r)\n  else: discard\n\nproc genSection(d: PDoc, kind: TSymKind, groupedToc = false) =\n  const sectionNames: array[skModule..skField, string] = [\n    \"Imports\", \"Types\", \"Vars\", \"Lets\", \"Consts\", \"Vars\", \"Procs\", \"Funcs\",\n    \"Methods\", \"Iterators\", \"Converters\", \"Macros\", \"Templates\", \"Exports\"\n  ]\n  if d.section[kind].finalMarkup == \"\": return\n  var title = sectionNames[kind]\n  d.section[kind].finalMarkup = getConfigVar(d.conf, \"doc.section\") % [\n      \"sectionid\", $ord(kind), \"sectionTitle\", title,\n      \"sectionTitleID\", $(ord(kind) + 50), \"content\", d.section[kind].finalMarkup]\n\n  proc cmp(x, y: TocItem): int = cmpDecimalsIgnoreCase(x.sortName, y.sortName)\n  if groupedToc:\n    let overloadableNames = toSeq(keys(d.tocTable[kind]))\n    for plainName in overloadableNames.sorted(cmpDecimalsIgnoreCase):\n      var overloadChoices = d.tocTable[kind][plainName]\n      overloadChoices.sort(cmp)\n      var content: string\n      for item in overloadChoices:\n        content.add item.content\n      d.toc2[kind].add getConfigVar(d.conf, \"doc.section.toc2\") % [\n          \"sectionid\", $ord(kind), \"sectionTitle\", title,\n          \"sectionTitleID\", $(ord(kind) + 50),\n          \"content\", content, \"plainName\", plainName]\n  else:\n    for item in d.tocSimple[kind].sorted(cmp):\n      d.toc2[kind].add item.content\n\n  d.toc[kind] = getConfigVar(d.conf, \"doc.section.toc\") % [\n      \"sectionid\", $ord(kind), \"sectionTitle\", title,\n      \"sectionTitleID\", $(ord(kind) + 50), \"content\", d.toc2[kind]]\n\nproc relLink(outDir: AbsoluteDir, destFile: AbsoluteFile, linkto: RelativeFile): string =\n  $relativeTo(outDir / linkto, destFile.splitFile().dir, '/')\n\nproc genOutFile(d: PDoc, groupedToc = false): string =\n  var\n    code, content: string\n    title = \"\"\n  var j = 0\n  var toc = \"\"\n  renderTocEntries(d[], j, 1, toc)\n  for i in TSymKind:\n    var shouldSort = i in routineKinds and groupedToc\n    genSection(d, i, shouldSort)\n    toc.add(d.toc[i])\n  if toc != \"\" or d.target == outLatex:\n    # for Latex $doc.toc will automatically generate TOC if `d.hasToc` is set\n    toc = getConfigVar(d.conf, \"doc.toc\") % [\"content\", toc]\n  for i in TSymKind: code.add(d.section[i].finalMarkup)\n\n  # Extract the title. Non API modules generate an entry in the index table.\n  if d.meta[metaTitle].len != 0:\n    title = d.meta[metaTitle]\n    let external = presentationPath(d.conf, AbsoluteFile d.filename).changeFileExt(HtmlExt).string.nativeToUnixPath\n    setIndexTerm(d[], external, \"\", title)\n  else:\n    # Modules get an automatic title for the HTML, but no entry in the index.\n    title = canonicalImport(d.conf, AbsoluteFile d.filename)\n  title = esc(d.target, title)\n  var subtitle = \"\"\n  if d.meta[metaSubtitle] != \"\":\n    dispA(d.conf, subtitle, \"<h2 class=\\\"subtitle\\\">$1</h2>\",\n        \"\\\\\\\\\\\\vspace{0.5em}\\\\large $1\", [esc(d.target, d.meta[metaSubtitle])])\n\n  var groupsection = getConfigVar(d.conf, \"doc.body_toc_groupsection\")\n  let bodyname = if d.hasToc and not d.isPureRst and not d.conf.isLatexCmd:\n                   groupsection.setLen 0\n                   \"doc.body_toc_group\"\n                 elif d.hasToc: \"doc.body_toc\"\n                 else: \"doc.body_no_toc\"\n  let seeSrc = genSeeSrc(d, d.filename, 1)\n  content = getConfigVar(d.conf, bodyname) % [\n      \"title\", title, \"subtitle\", subtitle,\n      \"tableofcontents\", toc, \"moduledesc\", d.modDescFinal, \"date\", getDateStr(),\n      \"time\", getClockStr(), \"content\", code,\n      \"deprecationMsg\", d.modDeprecationMsg,\n      \"theindexhref\", relLink(d.conf.outDir, d.destFile.AbsoluteFile,\n                              theindexFname.RelativeFile),\n      \"body_toc_groupsection\", groupsection, \"seeSrc\", seeSrc]\n  if optCompileOnly notin d.conf.globalOptions:\n    # XXX what is this hack doing here? 'optCompileOnly' means raw output!?\n    code = getConfigVar(d.conf, \"doc.file\") % [\n        \"nimdoccss\", relLink(d.conf.outDir, d.destFile.AbsoluteFile,\n                             nimdocOutCss.RelativeFile),\n        \"dochackjs\", relLink(d.conf.outDir, d.destFile.AbsoluteFile,\n                             docHackJsFname.RelativeFile),\n        \"title\", title, \"subtitle\", subtitle, \"tableofcontents\", toc,\n        \"moduledesc\", d.modDescFinal, \"date\", getDateStr(), \"time\", getClockStr(),\n        \"content\", content, \"author\", d.meta[metaAuthor],\n        \"version\", esc(d.target, d.meta[metaVersion]), \"analytics\", d.analytics,\n        \"deprecationMsg\", d.modDeprecationMsg]\n  else:\n    code = content\n  result = code\n\nproc generateIndex*(d: PDoc) =\n  if optGenIndex in d.conf.globalOptions:\n    let dir = d.conf.outDir\n    createDir(dir)\n    let dest = dir / changeFileExt(presentationPath(d.conf, AbsoluteFile d.filename), IndexExt)\n    writeIndexFile(d[], dest.string)\n\nproc updateOutfile(d: PDoc, outfile: AbsoluteFile) =\n  if d.module == nil or sfMainModule in d.module.flags: # nil for e.g. for commandRst2Html\n    if d.conf.outFile.isEmpty:\n      d.conf.outFile = outfile.relativeTo(d.conf.outDir)\n      if isAbsolute(d.conf.outFile.string):\n        d.conf.outFile = splitPath(d.conf.outFile.string)[1].RelativeFile\n\nproc writeOutput*(d: PDoc, useWarning = false, groupedToc = false) =\n  runAllExamples(d)\n  var content = genOutFile(d, groupedToc)\n  if optStdout in d.conf.globalOptions:\n    write(stdout, content)\n  else:\n    template outfile: untyped = d.destFile.AbsoluteFile\n    #let outfile = getOutFile2(d.conf, shortenDir(d.conf, filename), outExt)\n    let dir = outfile.splitFile.dir\n    createDir(dir)\n    updateOutfile(d, outfile)\n    try:\n      writeFile(outfile, content)\n    except IOError:\n      rawMessage(d.conf, if useWarning: warnCannotOpenFile else: errCannotOpenFile,\n        outfile.string)\n    if not d.wroteSupportFiles: # nimdoc.css + dochack.js\n      let nimr = $d.conf.getPrefixDir()\n      copyFile(docCss.interp(nimr = nimr), $d.conf.outDir / nimdocOutCss)\n      if optGenIndex in d.conf.globalOptions:\n        let docHackJs2 = getDocHacksJs(nimr, nim = getAppFilename())\n        copyFile(docHackJs2, $d.conf.outDir / docHackJs2.lastPathPart)\n      d.wroteSupportFiles = true\n\nproc writeOutputJson*(d: PDoc, useWarning = false) =\n  runAllExamples(d)\n  var modDesc: string\n  for desc in d.modDescFinal:\n    modDesc &= desc\n  let content = %*{\"orig\": d.filename,\n    \"nimble\": getPackageName(d.conf, d.filename),\n    \"moduleDescription\": modDesc,\n    \"entries\": d.jEntriesFinal}\n  if optStdout in d.conf.globalOptions:\n    write(stdout, $content)\n  else:\n    var f: File\n    if open(f, d.destFile, fmWrite):\n      write(f, $content)\n      close(f)\n      updateOutfile(d, d.destFile.AbsoluteFile)\n    else:\n      localError(d.conf, newLineInfo(d.conf, AbsoluteFile d.filename, -1, -1),\n                 warnUser, \"unable to open file \\\"\" & d.destFile &\n                 \"\\\" for writing\")\n\nproc handleDocOutputOptions*(conf: ConfigRef) =\n  if optWholeProject in conf.globalOptions:\n    # Backward compatibility with previous versions\n    # xxx this is buggy when user provides `nim doc --project -o:sub/bar.html main`,\n    # it'd write to `sub/bar.html/main.html`\n    conf.outDir = AbsoluteDir(conf.outDir / conf.outFile)\n\nproc commandDoc*(cache: IdentCache, conf: ConfigRef) =\n  ## implementation of deprecated ``doc0`` command (without semantic checking)\n  handleDocOutputOptions conf\n  var ast = parseFile(conf.projectMainIdx, cache, conf)\n  if ast == nil: return\n  var d = newDocumentor(conf.projectFull, cache, conf)\n  d.hasToc = true\n  generateDoc(d, ast, ast)\n  finishGenerateDoc(d)\n  writeOutput(d)\n  generateIndex(d)\n\nproc commandRstAux(cache: IdentCache, conf: ConfigRef;\n                   filename: AbsoluteFile, outExt: string) =\n  var filen = addFileExt(filename, \"txt\")\n  var d = newDocumentor(filen, cache, conf, outExt, isPureRst = true)\n  let rst = parseRst(readFile(filen.string),\n                     line=LineRstInit, column=ColRstInit,\n                     conf, d.sharedState)\n  d.modDescPre = @[ItemFragment(isRst: true, rst: rst)]\n  finishGenerateDoc(d)\n  writeOutput(d)\n  generateIndex(d)\n\nproc commandRst2Html*(cache: IdentCache, conf: ConfigRef) =\n  commandRstAux(cache, conf, conf.projectFull, HtmlExt)\n\nproc commandRst2TeX*(cache: IdentCache, conf: ConfigRef) =\n  commandRstAux(cache, conf, conf.projectFull, TexExt)\n\nproc commandJson*(cache: IdentCache, conf: ConfigRef) =\n  ## implementation of a deprecated jsondoc0 command\n  var ast = parseFile(conf.projectMainIdx, cache, conf)\n  if ast == nil: return\n  var d = newDocumentor(conf.projectFull, cache, conf)\n  d.onTestSnippet = proc (d: var RstGenerator; filename, cmd: string;\n                          status: int; content: string) =\n    localError(conf, newLineInfo(conf, AbsoluteFile d.filename, -1, -1),\n               warnUser, \"the ':test:' attribute is not supported by this backend\")\n  d.hasToc = true\n  generateJson(d, ast)\n  finishGenerateDoc(d)\n  let json = d.jEntriesFinal\n  let content = pretty(json)\n\n  if optStdout in d.conf.globalOptions:\n    write(stdout, content)\n  else:\n    #echo getOutFile(gProjectFull, JsonExt)\n    let filename = getOutFile(conf, RelativeFile conf.projectName, JsonExt)\n    try:\n      writeFile(filename, content)\n    except:\n      rawMessage(conf, errCannotOpenFile, filename.string)\n\nproc commandTags*(cache: IdentCache, conf: ConfigRef) =\n  var ast = parseFile(conf.projectMainIdx, cache, conf)\n  if ast == nil: return\n  var d = newDocumentor(conf.projectFull, cache, conf)\n  d.onTestSnippet = proc (d: var RstGenerator; filename, cmd: string;\n                          status: int; content: string) =\n    localError(conf, newLineInfo(conf, AbsoluteFile d.filename, -1, -1),\n               warnUser, \"the ':test:' attribute is not supported by this backend\")\n  d.hasToc = true\n  var\n    content = \"\"\n  generateTags(d, ast, content)\n\n  if optStdout in d.conf.globalOptions:\n    write(stdout, content)\n  else:\n    #echo getOutFile(gProjectFull, TagsExt)\n    let filename = getOutFile(conf, RelativeFile conf.projectName, TagsExt)\n    try:\n      writeFile(filename, content)\n    except:\n      rawMessage(conf, errCannotOpenFile, filename.string)\n\nproc commandBuildIndex*(conf: ConfigRef, dir: string, outFile = RelativeFile\"\") =\n  var content = mergeIndexes(dir)\n\n  var outFile = outFile\n  if outFile.isEmpty: outFile = theindexFname.RelativeFile.changeFileExt(\"\")\n  let filename = getOutFile(conf, outFile, HtmlExt)\n\n  let code = getConfigVar(conf, \"doc.file\") % [\n      \"nimdoccss\", relLink(conf.outDir, filename, nimdocOutCss.RelativeFile),\n      \"dochackjs\", relLink(conf.outDir, filename, docHackJsFname.RelativeFile),\n      \"title\", \"Index\",\n      \"subtitle\", \"\", \"tableofcontents\", \"\", \"moduledesc\", \"\",\n      \"date\", getDateStr(), \"time\", getClockStr(),\n      \"content\", content, \"author\", \"\", \"version\", \"\", \"analytics\", \"\"]\n  # no analytics because context is not available\n\n  try:\n    writeFile(filename, code)\n  except:\n    rawMessage(conf, errCannotOpenFile, filename.string)\n", "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## ==================================\n##                rst\n## ==================================\n##\n## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n## Nim-flavored reStructuredText and Markdown\n## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n##\n## This module implements a `reStructuredText`:idx: (RST) parser.\n## A large subset is implemented with some limitations_ and\n## `Nim-specific features`_.\n## A few `extra features`_ of the `Markdown`:idx: syntax are\n## also supported.\n##\n## Nim can output the result to HTML [#html]_ or Latex [#latex]_.\n##\n## .. [#html] commands `nim doc`:cmd: for ``*.nim`` files and\n##    `nim rst2html`:cmd: for ``*.rst`` files\n##\n## .. [#latex] commands `nim doc2tex`:cmd: for ``*.nim`` and\n##    `nim rst2tex`:cmd: for ``*.rst``.\n##\n## If you are new to RST please consider reading the following:\n##\n## 1) a short `quick introduction`_\n## 2) an `RST reference`_: a comprehensive cheatsheet for RST\n## 3) a more formal 50-page `RST specification`_.\n##\n## Features\n## --------\n##\n## Supported standard RST features:\n##\n## * body elements\n##   + sections\n##   + transitions\n##   + paragraphs\n##   + bullet lists using \\+, \\*, \\-\n##   + enumerated lists using arabic numerals or alphabet\n##     characters:  1. ... 2. ... *or* a. ... b. ... *or* A. ... B. ...\n##   + footnotes (including manually numbered, auto-numbered, auto-numbered\n##     with label, and auto-symbol footnotes) and citations\n##   + definition lists\n##   + field lists\n##   + option lists\n##   + indented literal blocks\n##   + quoted literal blocks\n##   + line blocks\n##   + simple tables\n##   + directives (see official documentation in `RST directives list`_):\n##     - ``image``, ``figure`` for including images and videos\n##     - ``code``\n##     - ``contents`` (table of contents), ``container``, ``raw``\n##     - ``include``\n##     - admonitions: \"attention\", \"caution\", \"danger\", \"error\", \"hint\",\n##       \"important\", \"note\", \"tip\", \"warning\", \"admonition\"\n##     - substitution definitions: `replace` and `image`\n##   + comments\n## * inline markup\n##   + *emphasis*, **strong emphasis**,\n##     ``inline literals``, hyperlink references (including embedded URI),\n##     substitution references, standalone hyperlinks,\n##     internal links (inline and outline)\n##   + \\`interpreted text\\` with roles ``:literal:``, ``:strong:``,\n##     ``emphasis``, ``:sub:``/``:subscript:``, ``:sup:``/``:superscript:``\n##     (see `RST roles list`_ for description).\n##   + inline internal targets\n##\n## .. _`Nim-specific features`:\n##\n## Additional Nim-specific features:\n##\n## * directives: ``code-block`` [cmp:Sphinx]_, ``title``,\n##   ``index`` [cmp:Sphinx]_\n## * predefined roles\n##   - ``:nim:`` (default), ``:c:`` (C programming language),\n##     ``:python:``, ``:yaml:``, ``:java:``, ``:cpp:`` (C++), ``:csharp`` (C#).\n##     That is every language that `highlite <highlite.html>`_ supports.\n##     They turn on appropriate syntax highlighting in inline code.\n##\n##     .. Note:: default role for Nim files is ``:nim:``,\n##               for ``*.rst`` it's currently ``:literal:``.\n##\n##   - generic command line highlighting roles:\n##     - ``:cmd:`` for commands and common shells syntax\n##     - ``:console:`` the same  for interactive sessions\n##       (commands should be prepended by ``$``)\n##     - ``:program:`` for executable names [cmp:Sphinx]_\n##       (one can just use ``:cmd:`` on single word)\n##     - ``:option:`` for command line options [cmp:Sphinx]_\n##   - ``:tok:``, a role for highlighting of programming language tokens\n## * ***triple emphasis*** (bold and italic) using \\*\\*\\*\n## * ``:idx:`` role for \\`interpreted text\\` to include the link to this\n##   text into an index (example: `Nim index`_).\n## * double slash `//` in option lists serves as a prefix for any option that\n##   starts from a word (without any leading symbols like `-`, `--`, `/`)::\n##\n##     //compile   compile the project\n##     //doc       generate documentation\n##\n##   Here the dummy `//` will disappear, while options `compile`:option:\n##   and `doc`:option: will be left in the final document.\n##\n## .. [cmp:Sphinx] similar but different from the directives of\n##    Python `Sphinx directives`_ and `Sphinx roles`_ extensions\n##\n## .. _`extra features`:\n##\n## Optional additional features, turned on by ``options: RstParseOption`` in\n## `proc rstParse`_:\n##\n## * emoji / smiley symbols\n## * Markdown tables\n## * Markdown code blocks\n## * Markdown links\n## * Markdown headlines\n## * Markdown block quotes\n## * using ``1`` as auto-enumerator in enumerated lists like RST ``#``\n##   (auto-enumerator ``1`` can not be used with ``#`` in the same list)\n##\n## .. Note:: By default Nim has ``roSupportMarkdown`` and\n##    ``roSupportRawDirective`` turned **on**.\n##\n## .. warning:: Using Nim-specific features can cause other RST implementations\n##   to fail on your document.\n##\n## Idiosyncrasies\n## --------------\n##\n## Currently we do **not** aim at 100% Markdown or RST compatibility in inline\n## markup recognition rules because that would provide very little user value.\n## This parser has 2 modes for inline markup:\n##\n## 1) Markdown-like mode which is enabled by `roPreferMarkdown` option\n##    (turned **on** by default).\n##\n##    .. Note:: RST features like directives are still turned **on**\n##\n## 2) Compatibility mode which is RST rules.\n##\n## .. Note:: in both modes the parser interpretes text between single\n##      backticks (code) identically:\n##      backslash does not escape; the only exception: ``\\`` folowed by `\n##      does escape so that we can always input a single backtick ` in\n##      inline code. However that makes impossible to input code with\n##      ``\\`` at the end in *single* backticks, one must use *double*\n##      backticks::\n##\n##        `\\`   -- WRONG\n##        ``\\`` -- GOOD\n##        So single backticks can always be input: `\\`` will turn to ` code\n##\n## .. Attention::\n##    We don't support some obviously poor design choices of Markdown (or RST).\n##\n##    - no support for the rule of 2 spaces causing a line break in Markdown\n##      (use RST \"line blocks\" syntax for making line breaks)\n##\n##    - interpretation of Markdown block quotes is also slightly different,\n##      e.g. case\n##\n##      ::\n##\n##        >>> foo\n##        > bar\n##        >>baz\n##\n##      is a single 3rd-level quote `foo bar baz` in original Markdown, while\n##      in Nim we naturally see it as 3rd-level quote `foo` + 1st level `bar` +\n##      2nd level `baz`:\n##\n##      >>> foo\n##      > bar\n##      >>baz\n##\n## Limitations\n## -----------\n##\n## * no Unicode support in character width calculations\n## * body elements\n##   - no roman numerals in enumerated lists\n##   - no doctest blocks\n##   - no grid tables\n##   - some directives are missing (check official `RST directives list`_):\n##     ``parsed-literal``, ``sidebar``, ``topic``, ``math``, ``rubric``,\n##     ``epigraph``, ``highlights``, ``pull-quote``, ``compound``,\n##     ``table``, ``csv-table``, ``list-table``, ``section-numbering``,\n##     ``header``, ``footer``, ``meta``, ``class``\n##     - no ``role`` directives and no custom interpreted text roles\n##     - some standard roles are not supported (check `RST roles list`_)\n##     - no generic admonition support\n## * inline markup\n##   - no simple-inline-markup\n##   - no embedded aliases\n##\n## Usage\n## -----\n##\n## See `Nim DocGen Tools Guide <docgen.html>`_ for the details about\n## `nim doc`:cmd:, `nim rst2html`:cmd: and `nim rst2tex`:cmd: commands.\n##\n## See `packages/docutils/rstgen module <rstgen.html>`_ to know how to\n## generate HTML or Latex strings to embed them into your documents.\n##\n## .. _quick introduction: https://docutils.sourceforge.io/docs/user/rst/quickstart.html\n## .. _RST reference: https://docutils.sourceforge.io/docs/user/rst/quickref.html\n## .. _RST specification: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html\n## .. _RST directives list: https://docutils.sourceforge.io/docs/ref/rst/directives.html\n## .. _RST roles list: https://docutils.sourceforge.io/docs/ref/rst/roles.html\n## .. _Nim index: https://nim-lang.org/docs/theindex.html\n## .. _Sphinx directives: https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html\n## .. _Sphinx roles: https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html\n\nimport\n  os, strutils, rstast, dochelpers, std/enumutils, algorithm, lists, sequtils,\n  std/private/miscdollars, tables\nfrom highlite import SourceLanguage, getSourceLanguage\n\ntype\n  RstParseOption* = enum     ## options for the RST parser\n    roSupportSmilies,         ## make the RST parser support smilies like ``:)``\n    roSupportRawDirective,    ## support the ``raw`` directive (don't support\n                              ## it for sandboxing)\n    roSupportMarkdown,        ## support additional features of Markdown\n    roPreferMarkdown,         ## parse as Markdown (keeping RST as \"extension\"\n                              ## to Markdown) -- implies `roSupportMarkdown`\n    roNimFile                 ## set for Nim files where default interpreted\n                              ## text role should be :nim:\n    roSandboxDisabled         ## this option enables certain options\n                              ## (e.g. raw, include)\n                              ## which are disabled by default as they can\n                              ## enable users to read arbitrary data and\n                              ## perform XSS if the parser is used in a web\n                              ## app.\n\n  RstParseOptions* = set[RstParseOption]\n\n  MsgClass* = enum\n    mcHint = \"Hint\",\n    mcWarning = \"Warning\",\n    mcError = \"Error\"\n\n  # keep the order in sync with compiler/docgen.nim and compiler/lineinfos.nim:\n  MsgKind* = enum          ## the possible messages\n    meCannotOpenFile = \"cannot open '$1'\",\n    meExpected = \"'$1' expected\",\n    meGridTableNotImplemented = \"grid table is not implemented\",\n    meMarkdownIllformedTable = \"illformed delimiter row of a Markdown table\",\n    meNewSectionExpected = \"new section expected $1\",\n    meGeneralParseError = \"general parse error\",\n    meInvalidDirective = \"invalid directive: '$1'\",\n    meInvalidField = \"invalid field: $1\",\n    meFootnoteMismatch = \"mismatch in number of footnotes and their refs: $1\",\n    mwRedefinitionOfLabel = \"redefinition of label '$1'\",\n    mwUnknownSubstitution = \"unknown substitution '$1'\",\n    mwAmbiguousLink = \"ambiguous doc link $1\",\n    mwBrokenLink = \"broken link '$1'\",\n    mwUnsupportedLanguage = \"language '$1' not supported\",\n    mwUnsupportedField = \"field '$1' not supported\",\n    mwRstStyle = \"RST style: $1\",\n    meSandboxedDirective = \"disabled directive: '$1'\",\n\n  MsgHandler* = proc (filename: string, line, col: int, msgKind: MsgKind,\n                       arg: string) {.closure, gcsafe.} ## what to do in case of an error\n  FindFileHandler* = proc (filename: string): string {.closure, gcsafe.}\n\nproc rstnodeToRefname*(n: PRstNode): string\nproc addNodes*(n: PRstNode): string\nproc getFieldValue*(n: PRstNode, fieldname: string): string\nproc getArgument*(n: PRstNode): string\n\n# ----------------------------- scanner part --------------------------------\n\nconst\n  SymChars: set[char] = {'a'..'z', 'A'..'Z', '0'..'9', '\\x80'..'\\xFF'}\n  SmileyStartChars: set[char] = {':', ';', '8'}\n  Smilies = {\n    \":D\": \"icon_e_biggrin\",\n    \":-D\": \"icon_e_biggrin\",\n    \":)\": \"icon_e_smile\",\n    \":-)\": \"icon_e_smile\",\n    \";)\": \"icon_e_wink\",\n    \";-)\": \"icon_e_wink\",\n    \":(\": \"icon_e_sad\",\n    \":-(\": \"icon_e_sad\",\n    \":o\": \"icon_e_surprised\",\n    \":-o\": \"icon_e_surprised\",\n    \":shock:\": \"icon_eek\",\n    \":?\": \"icon_e_confused\",\n    \":-?\": \"icon_e_confused\",\n    \":-/\": \"icon_e_confused\",\n\n    \"8-)\": \"icon_cool\",\n\n    \":lol:\": \"icon_lol\",\n    \":x\": \"icon_mad\",\n    \":-x\": \"icon_mad\",\n    \":P\": \"icon_razz\",\n    \":-P\": \"icon_razz\",\n    \":oops:\": \"icon_redface\",\n    \":cry:\": \"icon_cry\",\n    \":evil:\": \"icon_evil\",\n    \":twisted:\": \"icon_twisted\",\n    \":roll:\": \"icon_rolleyes\",\n    \":!:\": \"icon_exclaim\",\n\n    \":?:\": \"icon_question\",\n    \":idea:\": \"icon_idea\",\n    \":arrow:\": \"icon_arrow\",\n    \":|\": \"icon_neutral\",\n    \":-|\": \"icon_neutral\",\n    \":mrgreen:\": \"icon_mrgreen\",\n    \":geek:\": \"icon_e_geek\",\n    \":ugeek:\": \"icon_e_ugeek\"\n  }\n  SandboxDirAllowlist = [\"image\", \"code\", \"code-block\"]\n\ntype\n  TokType = enum\n    tkEof, tkIndent,\n    tkWhite, tkWord,\n    tkAdornment,              # used for chapter adornment, transitions and\n                              # horizontal table borders\n    tkPunct,                  # one or many punctuation characters\n    tkOther\n  Token = object              # a RST token\n    kind*: TokType            # the type of the token\n    ival*: int                # the indentation or parsed integer value\n    symbol*: string           # the parsed symbol as string\n    line*, col*: int          # line and column of the token\n\n  TokenSeq = seq[Token]\n  Lexer = object of RootObj\n    buf*: cstring\n    bufpos*: int\n    line*, col*, baseIndent*: int\n    adornmentLine*: bool\n    escapeNext*: bool\n\nproc getThing(L: var Lexer, tok: var Token, s: set[char]) =\n  tok.kind = tkWord\n  tok.line = L.line\n  tok.col = L.col\n  var pos = L.bufpos\n  while true:\n    tok.symbol.add(L.buf[pos])\n    inc pos\n    if L.buf[pos] notin s: break\n  inc L.col, pos - L.bufpos\n  L.bufpos = pos\n\nproc isCurrentLineAdornment(L: var Lexer): bool =\n  var pos = L.bufpos\n  let c = L.buf[pos]\n  while true:\n    inc pos\n    if L.buf[pos] in {'\\c', '\\l', '\\0'}:\n      break\n    if c == '+':  # grid table\n      if L.buf[pos] notin {'-', '=', '+'}:\n        return false\n    else:  # section adornment or table horizontal border\n      if L.buf[pos] notin {c, ' ', '\\t', '\\v', '\\f'}:\n        return false\n  result = true\n\nproc getPunctAdornment(L: var Lexer, tok: var Token) =\n  if L.adornmentLine:\n    tok.kind = tkAdornment\n  else:\n    tok.kind = tkPunct\n  tok.line = L.line\n  tok.col = L.col\n  var pos = L.bufpos\n  let c = L.buf[pos]\n  if not L.escapeNext and (c != '\\\\' or L.adornmentLine):\n    while true:\n      tok.symbol.add(L.buf[pos])\n      inc pos\n      if L.buf[pos] != c: break\n  elif L.escapeNext:\n    tok.symbol.add(L.buf[pos])\n    inc pos\n  else:  # not L.escapeNext and c == '\\\\' and not L.adornmentLine\n    tok.symbol.add '\\\\'\n    inc pos\n    L.escapeNext = true\n  inc L.col, pos - L.bufpos\n  L.bufpos = pos\n  if tok.symbol == \"\\\\\": tok.kind = tkPunct\n    # nim extension: standalone \\ can not be adornment\n\nproc getBracket(L: var Lexer, tok: var Token) =\n  tok.kind = tkPunct\n  tok.line = L.line\n  tok.col = L.col\n  tok.symbol.add(L.buf[L.bufpos])\n  inc L.col\n  inc L.bufpos\n\nproc getIndentAux(L: var Lexer, start: int): int =\n  var pos = start\n  # skip the newline (but include it in the token!)\n  if L.buf[pos] == '\\r':\n    if L.buf[pos + 1] == '\\n': inc pos, 2\n    else: inc pos\n  elif L.buf[pos] == '\\n':\n    inc pos\n  while true:\n    case L.buf[pos]\n    of ' ', '\\v', '\\f':\n      inc pos\n      inc result\n    of '\\t':\n      inc pos\n      result = result - (result mod 8) + 8\n    else:\n      break                   # EndOfFile also leaves the loop\n  if L.buf[pos] == '\\0':\n    result = 0\n  elif L.buf[pos] == '\\n' or L.buf[pos] == '\\r':\n    # look at the next line for proper indentation:\n    result = getIndentAux(L, pos)\n  L.bufpos = pos              # no need to set back buf\n\nproc getIndent(L: var Lexer, tok: var Token) =\n  tok.col = 0\n  tok.kind = tkIndent         # skip the newline (but include it in the token!)\n  tok.ival = getIndentAux(L, L.bufpos)\n  inc L.line\n  tok.line = L.line\n  L.col = tok.ival\n  tok.ival = max(tok.ival - L.baseIndent, 0)\n  tok.symbol = \"\\n\" & spaces(tok.ival)\n\nproc rawGetTok(L: var Lexer, tok: var Token) =\n  tok.symbol = \"\"\n  tok.ival = 0\n  if L.col == 0:\n    L.adornmentLine = false\n  var c = L.buf[L.bufpos]\n  case c\n  of 'a'..'z', 'A'..'Z', '\\x80'..'\\xFF', '0'..'9':\n    getThing(L, tok, SymChars)\n  of ' ', '\\t', '\\v', '\\f':\n    getThing(L, tok, {' ', '\\t'})\n    tok.kind = tkWhite\n    if L.buf[L.bufpos] in {'\\r', '\\n'}:\n      rawGetTok(L, tok)       # ignore spaces before \\n\n  of '\\r', '\\n':\n    getIndent(L, tok)\n    L.adornmentLine = false\n  of '!', '\\\"', '#', '$', '%', '&', '\\'',  '*', '+', ',', '-', '.',\n     '/', ':', ';', '<', '=', '>', '?', '@', '\\\\', '^', '_', '`',\n     '|', '~':\n    if L.col == 0:\n      L.adornmentLine = L.isCurrentLineAdornment()\n    getPunctAdornment(L, tok)\n  of '(', ')', '[', ']', '{', '}':\n    getBracket(L, tok)\n  else:\n    tok.line = L.line\n    tok.col = L.col\n    if c == '\\0':\n      tok.kind = tkEof\n    else:\n      tok.kind = tkOther\n      tok.symbol.add(c)\n      inc L.bufpos\n      inc L.col\n  tok.col = max(tok.col - L.baseIndent, 0)\n\nproc getTokens(buffer: string, tokens: var TokenSeq) =\n  var L: Lexer\n  var length = tokens.len\n  L.buf = cstring(buffer)\n  L.line = 0                  # skip UTF-8 BOM\n  if L.buf[0] == '\\xEF' and L.buf[1] == '\\xBB' and L.buf[2] == '\\xBF':\n    inc L.bufpos, 3\n  while true:\n    inc length\n    setLen(tokens, length)\n    let toEscape = L.escapeNext\n    rawGetTok(L, tokens[length - 1])\n    if toEscape: L.escapeNext = false\n    if tokens[length - 1].kind == tkEof: break\n  if tokens[0].kind == tkWhite:\n    # BUGFIX\n    tokens[0].ival = tokens[0].symbol.len\n    tokens[0].kind = tkIndent\n\ntype\n  LevelInfo = object\n    symbol: char         # adornment character\n    hasOverline: bool    # has also overline (besides underline)?\n    line: int            # the last line of this style occurrence\n                         # (for error message)\n    hasPeers: bool       # has headings on the same level of hierarchy?\n  LiteralBlockKind = enum  # RST-style literal blocks after `::`\n    lbNone,\n    lbIndentedLiteralBlock,\n    lbQuotedLiteralBlock\n  LevelMap = seq[LevelInfo]   # Saves for each possible title adornment\n                              # style its level in the current document.\n  SubstitutionKind = enum\n    rstSubstitution = \"substitution\",\n    hyperlinkAlias = \"hyperlink alias\",\n    implicitHyperlinkAlias = \"implicitly-generated hyperlink alias\"\n  Substitution = object\n    kind*: SubstitutionKind\n    key*: string\n    value*: PRstNode\n    info*: TLineInfo   # place where the substitution was defined\n  AnchorRule = enum\n    arInternalRst,  ## For automatically generated RST anchors (from\n                    ## headings, footnotes, inline internal targets):\n                    ## case-insensitive, 1-space-significant (by RST spec)\n    arNim   ## For anchors generated by ``docgen.rst``: Nim-style case\n            ## sensitivity, etc. (see `proc normalizeNimName`_ for details)\n    arHyperlink,  ## For links with manually set anchors in\n                  ## form `text <pagename.html#anchor>`_\n  RstAnchorKind = enum\n    manualDirectiveAnchor = \"manual directive anchor\",\n    manualInlineAnchor = \"manual inline anchor\",\n    footnoteAnchor = \"footnote anchor\",\n    headlineAnchor = \"implicitly-generated headline anchor\"\n  AnchorSubst = object\n    mainAnchor: ref string  # A reference name that will be inserted directly\n                            # into HTML/Latex. It's declared as `ref` because\n                            # it can be shared between aliases.\n    info: TLineInfo         # where the anchor was defined\n    priority: int\n    case kind: range[arInternalRst .. arNim]\n    of arInternalRst:\n      anchorType: RstAnchorKind\n    of arNim:\n      tooltip: string       # displayed tooltip for Nim-generated anchors\n      langSym: LangSymbol\n  AnchorSubstTable = Table[string, seq[AnchorSubst]]\n                         # use `seq` to account for duplicate anchors\n  FootnoteType = enum\n    fnManualNumber,     # manually numbered footnote like [3]\n    fnAutoNumber,       # auto-numbered footnote [#]\n    fnAutoNumberLabel,  # auto-numbered with label [#label]\n    fnAutoSymbol,       # auto-symbol footnote [*]\n    fnCitation          # simple text label like [citation2021]\n  FootnoteSubst = tuple\n    kind: FootnoteType  # discriminator\n    number: int         # valid for fnManualNumber (always) and fnAutoNumber,\n                        # fnAutoNumberLabel after resolveSubs is called\n    autoNumIdx: int     # order of occurence: fnAutoNumber, fnAutoNumberLabel\n    autoSymIdx: int     # order of occurence: fnAutoSymbol\n    label: string       # valid for fnAutoNumberLabel\n  RstFileTable* = object\n    filenameToIdx*: Table[string, FileIndex]\n    idxToFilename*: seq[string]\n  RstSharedState = object\n    options: RstParseOptions    # parsing options\n    hLevels: LevelMap           # hierarchy of heading styles\n    hTitleCnt: int              # =0 if no title, =1 if only main title,\n                                # =2 if both title and subtitle are present\n    hCurLevel: int              # current section level\n    currRole: string            # current interpreted text role\n    currRoleKind: RstNodeKind   # ... and its node kind\n    subs: seq[Substitution]     # substitutions\n    refs*: seq[Substitution]    # references\n    anchors*: AnchorSubstTable\n                                # internal target substitutions\n    lineFootnoteNum: seq[TLineInfo]     # footnote line, auto numbers .. [#]\n    lineFootnoteNumRef: seq[TLineInfo]  # footnote line, their reference [#]_\n    currFootnoteNumRef: int             # ... their counter for `resolveSubs`\n    lineFootnoteSym: seq[TLineInfo]     # footnote line, auto symbols .. [*]\n    lineFootnoteSymRef: seq[TLineInfo]  # footnote line, their reference [*]_\n    currFootnoteSymRef: int             # ... their counter for `resolveSubs`\n    footnotes: seq[FootnoteSubst] # correspondence b/w footnote label,\n                                  # number, order of occurrence\n    msgHandler: MsgHandler      # How to handle errors.\n    findFile: FindFileHandler   # How to find files.\n    filenames*: RstFileTable    # map file name <-> FileIndex (for storing\n                                # file names for warnings after 1st stage)\n    currFileIdx*: FileIndex     # current index in `filenames`\n    hasToc*: bool\n\n  PRstSharedState* = ref RstSharedState\n  RstParser = object of RootObj\n    idx*: int\n    tok*: TokenSeq\n    s*: PRstSharedState\n    indentStack*: seq[int]\n    line*, col*: int            ## initial line/column of whole text or\n                                ## documenation fragment that will be added\n                                ## in case of error/warning reporting to\n                                ## (relative) line/column of the token.\n    curAnchor*: string          # variable to track latest anchor in s.anchors\n    curAnchorName*: string      # corresponding name in human-readable format\n\n  EParseError* = object of ValueError\n\nconst\n  LineRstInit* = 1  ## Initial line number for standalone RST text\n  ColRstInit* = 0   ## Initial column number for standalone RST text\n                    ## (Nim global reporting adds ColOffset=1)\n  ColRstOffset* = 1 ## 1: a replica of ColOffset for internal use\n\ntemplate currentTok(p: RstParser): Token = p.tok[p.idx]\ntemplate prevTok(p: RstParser): Token = p.tok[p.idx - 1]\ntemplate nextTok(p: RstParser): Token = p.tok[p.idx + 1]\n\nproc whichMsgClass*(k: MsgKind): MsgClass =\n  ## returns which message class `k` belongs to.\n  case k.symbolName[1]\n  of 'e', 'E': result = mcError\n  of 'w', 'W': result = mcWarning\n  of 'h', 'H': result = mcHint\n  else: assert false, \"msgkind does not fit naming scheme\"\n\nproc defaultMsgHandler*(filename: string, line, col: int, msgkind: MsgKind,\n                        arg: string) =\n  let mc = msgkind.whichMsgClass\n  let a = $msgkind % arg\n  var message: string\n  toLocation(message, filename, line, col + ColRstOffset)\n  message.add \" $1: $2\" % [$mc, a]\n  if mc == mcError: raise newException(EParseError, message)\n  else: writeLine(stdout, message)\n\nproc defaultFindFile*(filename: string): string =\n  if fileExists(filename): result = filename\n  else: result = \"\"\n\nproc defaultRole(options: RstParseOptions): string =\n  if roNimFile in options: \"nim\" else: \"literal\"\n\nproc whichRoleAux(sym: string): RstNodeKind =\n  let r = sym.toLowerAscii\n  case r\n  of \"idx\": result = rnIdx\n  of \"literal\": result = rnInlineLiteral\n  of \"strong\": result = rnStrongEmphasis\n  of \"emphasis\": result = rnEmphasis\n  of \"sub\", \"subscript\": result = rnSub\n  of \"sup\", \"superscript\": result = rnSup\n  # literal and code are the same in our implementation\n  of \"code\": result = rnInlineLiteral\n  of \"program\", \"option\", \"tok\": result = rnCodeFragment\n  # c++ currently can be spelled only as cpp, c# only as csharp\n  elif getSourceLanguage(r) != langNone:\n    result = rnInlineCode\n  else:  # unknown role\n    result = rnUnknownRole\n\nproc len(filenames: RstFileTable): int = filenames.idxToFilename.len\n\nproc addFilename*(s: PRstSharedState, file1: string): FileIndex =\n  ## Returns index of filename, adding it if it has not been used before\n  let nextIdx = s.filenames.len.FileIndex\n  result = getOrDefault(s.filenames.filenameToIdx, file1, default = nextIdx)\n  if result == nextIdx:\n    s.filenames.filenameToIdx[file1] = result\n    s.filenames.idxToFilename.add file1\n\nproc setCurrFilename*(s: PRstSharedState, file1: string) =\n  s.currFileIdx = addFilename(s, file1)\n\nproc getFilename(filenames: RstFileTable, fid: FileIndex): string =\n  doAssert(0 <= fid.int and fid.int < filenames.len,\n      \"incorrect FileIndex $1 (range 0..$2)\" % [\n        $fid.int, $(filenames.len - 1)])\n  result = filenames.idxToFilename[fid.int]\n\nproc currFilename(s: PRstSharedState): string =\n  getFilename(s.filenames, s.currFileIdx)\n\nproc newRstSharedState*(options: RstParseOptions,\n                        filename: string,\n                        findFile: FindFileHandler,\n                        msgHandler: MsgHandler): PRstSharedState =\n  let r = defaultRole(options)\n  result = PRstSharedState(\n      currRole: r,\n      currRoleKind: whichRoleAux(r),\n      options: options,\n      msgHandler: if not isNil(msgHandler): msgHandler else: defaultMsgHandler,\n      findFile: if not isNil(findFile): findFile else: defaultFindFile\n  )\n  setCurrFilename(result, filename)\n\nproc curLine(p: RstParser): int = p.line + currentTok(p).line\n\nproc findRelativeFile(p: RstParser; filename: string): string =\n  result = p.s.currFilename.splitFile.dir / filename\n  if not fileExists(result):\n    result = p.s.findFile(filename)\n\nproc rstMessage(p: RstParser, msgKind: MsgKind, arg: string) =\n  p.s.msgHandler(p.s.currFilename, curLine(p),\n                             p.col + currentTok(p).col, msgKind, arg)\n\nproc rstMessage(s: PRstSharedState, msgKind: MsgKind, arg: string) =\n  s.msgHandler(s.currFilename, LineRstInit, ColRstInit, msgKind, arg)\n\nproc rstMessage*(filenames: RstFileTable, f: MsgHandler,\n                 info: TLineInfo, msgKind: MsgKind, arg: string) =\n  ## Print warnings using `info`, i.e. in 2nd-pass warnings for\n  ## footnotes/substitutions/references or from ``rstgen.nim``.\n  let file = getFilename(filenames, info.fileIndex)\n  f(file, info.line.int, info.col.int, msgKind, arg)\n\nproc rstMessage(p: RstParser, msgKind: MsgKind, arg: string, line, col: int) =\n  p.s.msgHandler(p.s.currFilename, p.line + line,\n                             p.col + col, msgKind, arg)\n\nproc rstMessage(p: RstParser, msgKind: MsgKind) =\n  p.s.msgHandler(p.s.currFilename, curLine(p),\n                             p.col + currentTok(p).col, msgKind,\n                             currentTok(p).symbol)\n\nproc currInd(p: RstParser): int =\n  result = p.indentStack[high(p.indentStack)]\n\nproc pushInd(p: var RstParser, ind: int) =\n  p.indentStack.add(ind)\n\nproc popInd(p: var RstParser) =\n  if p.indentStack.len > 1: setLen(p.indentStack, p.indentStack.len - 1)\n\n# Working with indentation in rst.nim\n# -----------------------------------\n#\n# Every line break has an associated tkIndent.\n# The tokenizer writes back the first column of next non-blank line\n# in all preceeding tkIndent tokens to the `ival` field of tkIndent.\n#\n# RST document is separated into body elements (B.E.), every of which\n# has a dedicated handler proc (or block of logic when B.E. is a block quote)\n# that should follow the next rule:\n#   Every B.E. handler proc should finish at tkIndent (newline)\n#   after its B.E. finishes.\n#   Then its callers (which is `parseSection` or another B.E. handler)\n#   check for tkIndent ival (without necessity to advance `p.idx`)\n#   and decide themselves whether they continue processing or also stop.\n#\n# An example::\n#\n#   L    RST text fragment                  indentation\n#     +--------------------+\n#   1 |                    | <- (empty line at the start of file) no tokens\n#   2 |First paragraph.    | <- tkIndent has ival=0, and next tkWord has col=0\n#   3 |                    | <- tkIndent has ival=0\n#   4 |* bullet item and   | <- tkIndent has ival=0, and next tkPunct has col=0\n#   5 |  its continuation  | <- tkIndent has ival=2, and next tkWord has col=2\n#   6 |                    | <- tkIndent has ival=4\n#   7 |    Block quote     | <- tkIndent has ival=4, and next tkWord has col=4\n#   8 |                    | <- tkIndent has ival=0\n#   9 |                    | <- tkIndent has ival=0\n#   10|Final paragraph     | <- tkIndent has ival=0, and tkWord has col=0\n#     +--------------------+\n#    C:01234\n#\n# Here parser starts with initial `indentStack=[0]` and then calls the\n# 1st `parseSection`:\n#\n#   - `parseSection` calls `parseParagraph` and \"First paragraph\" is parsed\n#   - bullet list handler is started at reaching ``*`` (L4 C0), it\n#     starts bullet item logic (L4 C2), which calls `pushInd(p, ind=2)`,\n#     then calls `parseSection` (2nd call, nested) which parses\n#     paragraph \"bullet list and its continuation\" and then starts\n#     a block quote logic (L7 C4).\n#     The block quote logic calls calls `pushInd(p, ind=4)` and\n#     calls `parseSection` again, so a (simplified) sequence of calls now is::\n#\n#       parseSection -> parseBulletList ->\n#         parseSection (+block quote logic) -> parseSection\n#\n#     3rd `parseSection` finishes, block quote logic calls `popInd(p)`,\n#     it returns to bullet item logic, which sees that next tkIndent has\n#     ival=0 and stops there since the required indentation for a bullet item\n#     is 2 and 0<2; the bullet item logic calls `popInd(p)`.\n#     Then bullet list handler checks that next tkWord (L10 C0) has the\n#     right indentation but does not have ``*`` so stops at tkIndent (L10).\n#   - 1st `parseSection` invocation calls `parseParagraph` and the\n#     \"Final paragraph\" is parsed.\n#\n# If a B.E. handler has advanced `p.idx` past tkIndent to check\n# whether it should continue its processing or not, and decided not to,\n# then this B.E. handler should step back (e.g. do `dec p.idx`).\n\nproc initParser(p: var RstParser, sharedState: PRstSharedState) =\n  p.indentStack = @[0]\n  p.tok = @[]\n  p.idx = 0\n  p.col = ColRstInit\n  p.line = LineRstInit\n  p.s = sharedState\n\nproc addNodesAux(n: PRstNode, result: var string) =\n  if n == nil:\n    return\n  if n.kind == rnLeaf:\n    result.add(n.text)\n  else:\n    for i in 0 ..< n.len: addNodesAux(n.sons[i], result)\n\nproc addNodes(n: PRstNode): string =\n  n.addNodesAux(result)\n\nproc linkName(n: PRstNode): string =\n  ## Returns a normalized reference name, see:\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#reference-names\n  n.addNodes.toLowerAscii\n\nproc rstnodeToRefnameAux(n: PRstNode, r: var string, b: var bool) =\n  template special(s) =\n    if b:\n      r.add('-')\n      b = false\n    r.add(s)\n\n  if n == nil: return\n  if n.kind == rnLeaf:\n    for i in 0 ..< n.text.len:\n      case n.text[i]\n      of '0'..'9':\n        if b:\n          r.add('-')\n          b = false\n        if r.len == 0: r.add('Z')\n        r.add(n.text[i])\n      of 'a'..'z', '\\128'..'\\255':\n        if b:\n          r.add('-')\n          b = false\n        r.add(n.text[i])\n      of 'A'..'Z':\n        if b:\n          r.add('-')\n          b = false\n        r.add(chr(ord(n.text[i]) - ord('A') + ord('a')))\n      of '$': special \"dollar\"\n      of '%': special \"percent\"\n      of '&': special \"amp\"\n      of '^': special \"roof\"\n      of '!': special \"emark\"\n      of '?': special \"qmark\"\n      of '*': special \"star\"\n      of '+': special \"plus\"\n      of '-': special \"minus\"\n      of '/': special \"slash\"\n      of '\\\\': special \"backslash\"\n      of '=': special \"eq\"\n      of '<': special \"lt\"\n      of '>': special \"gt\"\n      of '~': special \"tilde\"\n      of ':': special \"colon\"\n      of '.': special \"dot\"\n      of '@': special \"at\"\n      of '|': special \"bar\"\n      else:\n        if r.len > 0: b = true\n  else:\n    for i in 0 ..< n.len: rstnodeToRefnameAux(n.sons[i], r, b)\n\nproc rstnodeToRefname(n: PRstNode): string =\n  var b = false\n  rstnodeToRefnameAux(n, result, b)\n\nproc findSub(s: PRstSharedState, n: PRstNode): int =\n  var key = addNodes(n)\n  # the spec says: if no exact match, try one without case distinction:\n  for i in countup(0, high(s.subs)):\n    if key == s.subs[i].key:\n      return i\n  for i in countup(0, high(s.subs)):\n    if cmpIgnoreStyle(key, s.subs[i].key) == 0:\n      return i\n  result = -1\n\nproc lineInfo(p: RstParser, iTok: int): TLineInfo =\n  result.col = int16(p.col + p.tok[iTok].col)\n  result.line = uint16(p.line + p.tok[iTok].line)\n  result.fileIndex = p.s.currFileIdx\n\nproc lineInfo(p: RstParser): TLineInfo = lineInfo(p, p.idx)\n# TODO: we need this simplification because we don't preserve exact starting\n# token of currently parsed element:\nproc prevLineInfo(p: RstParser): TLineInfo = lineInfo(p, p.idx-1)\n\nproc setSub(p: var RstParser, key: string, value: PRstNode) =\n  var length = p.s.subs.len\n  for i in 0 ..< length:\n    if key == p.s.subs[i].key:\n      p.s.subs[i].value = value\n      return\n  p.s.subs.add(Substitution(key: key, value: value, info: prevLineInfo(p)))\n\nproc setRef(p: var RstParser, key: string, value: PRstNode,\n            refType: SubstitutionKind) =\n  var length = p.s.refs.len\n  for i in 0 ..< length:\n    if key == p.s.refs[i].key:\n      if p.s.refs[i].value.addNodes != value.addNodes:\n        rstMessage(p, mwRedefinitionOfLabel, key)\n      p.s.refs[i].value = value\n      return\n  p.s.refs.add(Substitution(kind: refType, key: key, value: value,\n                            info: prevLineInfo(p)))\n\nproc findRef(s: PRstSharedState, key: string): seq[Substitution] =\n  for i in countup(0, high(s.refs)):\n    if key == s.refs[i].key:\n      result.add s.refs[i]\n\n# Ambiguity in links: we don't follow procedure of removing implicit targets\n# defined in https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#implicit-hyperlink-targets\n# Instead we just give explicit links a higher priority than to implicit ones\n# and report ambiguities as warnings. Hopefully it is easy to remove\n# ambiguities manually. Nim auto-generated links from ``docgen.nim``\n# have lowest priority: 1 (for procs) and below for other symbol types.\n\nproc refPriority(k: SubstitutionKind): int =\n  case k\n  of rstSubstitution: result = 8\n  of hyperlinkAlias: result = 7\n  of implicitHyperlinkAlias: result = 2\n\nproc internalRefPriority(k: RstAnchorKind): int =\n  case k\n  of manualDirectiveAnchor: result = 6\n  of manualInlineAnchor: result = 5\n  of footnoteAnchor: result = 4\n  of headlineAnchor: result = 3\n\nproc addAnchorRst(p: var RstParser, name: string, refn: string, reset: bool,\n                  anchorType: RstAnchorKind) =\n  ## Adds anchor `refn` with an alias `name` and\n  ## updates the corresponding `curAnchor` / `curAnchorName`.\n  let prio = internalRefPriority(anchorType)\n  if p.curAnchorName == \"\":\n    var anchRef = new string\n    anchRef[] = refn\n    p.s.anchors.mgetOrPut(name, newSeq[AnchorSubst]()).add(\n        AnchorSubst(kind: arInternalRst, mainAnchor: anchRef, priority: prio,\n                    info: prevLineInfo(p), anchorType: anchorType))\n  else:\n    # override previous mainAnchor by `ref` in all aliases\n    var anchRef = p.s.anchors[p.curAnchorName][0].mainAnchor\n    anchRef[] = refn\n    p.s.anchors.mgetOrPut(name, newSeq[AnchorSubst]()).add(\n        AnchorSubst(kind: arInternalRst, mainAnchor: anchRef, priority: prio,\n                    info: prevLineInfo(p), anchorType: anchorType))\n  if reset:\n    p.curAnchor = \"\"\n    p.curAnchorName = \"\"\n  else:\n    p.curAnchor = refn\n    p.curAnchorName = name\n\nproc addAnchorNim*(s: var PRstSharedState, refn: string, tooltip: string,\n                   langSym: LangSymbol, priority: int,\n                   info: TLineInfo) =\n  ## Adds an anchor `refn` (`mainAnchor`), which follows\n  ## the rule `arNim` (i.e. a symbol in ``*.nim`` file)\n  var anchRef = new string\n  anchRef[] = refn\n  s.anchors.mgetOrPut(langSym.name, newSeq[AnchorSubst]()).add(\n      AnchorSubst(kind: arNim, mainAnchor: anchRef, langSym: langSym,\n                  tooltip: tooltip, priority: priority,\n                  info: info))\n\nproc findMainAnchorNim(s: PRstSharedState, signature: PRstNode,\n                       info: TLineInfo):\n                      seq[AnchorSubst] =\n  let langSym = toLangSymbol(signature)\n  let substitutions = s.anchors.getOrDefault(langSym.name,\n                                             newSeq[AnchorSubst]())\n  if substitutions.len == 0:\n    return\n  # map symKind (like \"proc\") -> found symbols/groups:\n  var found: Table[string, seq[AnchorSubst]]\n  for s in substitutions:\n    if s.kind == arNim:\n      if match(s.langSym, langSym):\n        found.mgetOrPut(s.langSym.symKind, newSeq[AnchorSubst]()).add s\n  for symKind, sList in found:\n    if sList.len == 1:\n      result.add sList[0]\n    else:  # > 1, there are overloads, potential ambiguity in this `symKind`\n      if langSym.parametersProvided:\n        # there are non-group signatures, select only them\n        for s in sList:\n          if not s.langSym.isGroup:\n            result.add s\n      else:  # when there are many overloads a link like foo_ points to all\n             # of them, so selecting the group\n        var foundGroup = false\n        for s in sList:\n          if s.langSym.isGroup:\n            result.add s\n            foundGroup = true\n            break\n        doAssert foundGroup, \"docgen has not generated the group\"\n\nproc findMainAnchorRst(s: PRstSharedState, linkText: string, info: TLineInfo):\n                      seq[AnchorSubst] =\n  let name = linkText.toLowerAscii\n  let substitutions = s.anchors.getOrDefault(name, newSeq[AnchorSubst]())\n  for s in substitutions:\n    if s.kind == arInternalRst:\n      result.add s\n\nproc addFootnoteNumManual(p: var RstParser, num: int) =\n  ## add manually-numbered footnote\n  for fnote in p.s.footnotes:\n    if fnote.number == num:\n      rstMessage(p, mwRedefinitionOfLabel, $num)\n      return\n  p.s.footnotes.add((fnManualNumber, num, -1, -1, $num))\n\nproc addFootnoteNumAuto(p: var RstParser, label: string) =\n  ## add auto-numbered footnote.\n  ## Empty label [#] means it'll be resolved by the occurrence.\n  if label == \"\":  # simple auto-numbered [#]\n    p.s.lineFootnoteNum.add lineInfo(p)\n    p.s.footnotes.add((fnAutoNumber, -1, p.s.lineFootnoteNum.len, -1, label))\n  else:           # auto-numbered with label [#label]\n    for fnote in p.s.footnotes:\n      if fnote.label == label:\n        rstMessage(p, mwRedefinitionOfLabel, label)\n        return\n    p.s.footnotes.add((fnAutoNumberLabel, -1, -1, -1, label))\n\nproc addFootnoteSymAuto(p: var RstParser) =\n  p.s.lineFootnoteSym.add lineInfo(p)\n  p.s.footnotes.add((fnAutoSymbol, -1, -1, p.s.lineFootnoteSym.len, \"\"))\n\nproc orderFootnotes(s: PRstSharedState) =\n  ## numerate auto-numbered footnotes taking into account that all\n  ## manually numbered ones always have preference.\n  ## Save the result back to `s.footnotes`.\n\n  # Report an error if found any mismatch in number of automatic footnotes\n  proc listFootnotes(locations: seq[TLineInfo]): string =\n    var lines: seq[string]\n    for info in locations:\n      if s.filenames.len > 1:\n        let file = getFilename(s.filenames, info.fileIndex)\n        lines.add file & \":\"\n      else:  # no need to add file name here if there is only 1\n        lines.add \"\"\n      lines[^1].add $info.line\n    result.add $lines.len & \" (lines \" & join(lines, \", \") & \")\"\n  if s.lineFootnoteNum.len != s.lineFootnoteNumRef.len:\n    rstMessage(s, meFootnoteMismatch,\n      \"$1 != $2\" % [listFootnotes(s.lineFootnoteNum),\n                    listFootnotes(s.lineFootnoteNumRef)] &\n        \" for auto-numbered footnotes\")\n  if s.lineFootnoteSym.len != s.lineFootnoteSymRef.len:\n    rstMessage(s, meFootnoteMismatch,\n      \"$1 != $2\" % [listFootnotes(s.lineFootnoteSym),\n                    listFootnotes(s.lineFootnoteSymRef)] &\n        \" for auto-symbol footnotes\")\n\n  var result: seq[FootnoteSubst]\n  var manuallyN, autoN, autoSymbol: seq[FootnoteSubst]\n  for fs in s.footnotes:\n    if fs.kind == fnManualNumber: manuallyN.add fs\n    elif fs.kind in {fnAutoNumber, fnAutoNumberLabel}: autoN.add fs\n    else: autoSymbol.add fs\n\n  if autoN.len == 0:\n    result = manuallyN\n  else:\n    # fill gaps between manually numbered footnotes in ascending order\n    manuallyN.sort()  # sort by number - its first field\n    var lst = initSinglyLinkedList[FootnoteSubst]()\n    for elem in manuallyN: lst.append(elem)\n    var firstAuto = 0\n    if lst.head == nil or lst.head.value.number != 1:\n      # no manual footnote [1], start numeration from 1 for auto-numbered\n      lst.prepend (autoN[0].kind, 1, autoN[0].autoNumIdx, -1, autoN[0].label)\n      firstAuto = 1\n    var curNode = lst.head\n    var nextNode: SinglyLinkedNode[FootnoteSubst]\n    # go simultaneously through `autoN` and `lst` looking for gaps\n    for (kind, x, autoNumIdx, y, label) in autoN[firstAuto .. ^1]:\n      while (nextNode = curNode.next; nextNode != nil):\n        if nextNode.value.number - curNode.value.number > 1:\n          # gap found, insert new node `n` between curNode and nextNode:\n          var n = newSinglyLinkedNode((kind, curNode.value.number + 1,\n                                       autoNumIdx, -1, label))\n          curNode.next = n\n          n.next = nextNode\n          curNode = n\n          break\n        else:\n          curNode = nextNode\n      if nextNode == nil:  # no gap found, just append\n        lst.append (kind, curNode.value.number + 1, autoNumIdx, -1, label)\n        curNode = lst.tail\n    result = lst.toSeq\n\n  # we use ASCII symbols instead of those recommended in RST specification:\n  const footnoteAutoSymbols = [\"*\", \"^\", \"+\", \"=\", \"~\", \"$\", \"@\", \"%\", \"&\"]\n  for fs in autoSymbol:\n    # assignment order: *, **, ***, ^, ^^, ^^^, ... &&&, ****, *****, ...\n    let i = fs.autoSymIdx - 1\n    let symbolNum = (i div 3) mod footnoteAutoSymbols.len\n    let nSymbols = (1 + i mod 3) + 3 * (i div (3 * footnoteAutoSymbols.len))\n    let label = footnoteAutoSymbols[symbolNum].repeat(nSymbols)\n    result.add((fs.kind, -1, -1, fs.autoSymIdx, label))\n\n  s.footnotes = result\n\nproc getFootnoteNum(s: PRstSharedState, label: string): int =\n  ## get number from label. Must be called after `orderFootnotes`.\n  result = -1\n  for fnote in s.footnotes:\n    if fnote.label == label:\n      return fnote.number\n\nproc getFootnoteNum(s: PRstSharedState, order: int): int =\n  ## get number from occurrence. Must be called after `orderFootnotes`.\n  result = -1\n  for fnote in s.footnotes:\n    if fnote.autoNumIdx == order:\n      return fnote.number\n\nproc getAutoSymbol(s: PRstSharedState, order: int): string =\n  ## get symbol from occurrence of auto-symbol footnote.\n  result = \"???\"\n  for fnote in s.footnotes:\n    if fnote.autoSymIdx == order:\n      return fnote.label\n\nproc newRstNodeA(p: var RstParser, kind: RstNodeKind): PRstNode =\n  ## create node and consume the current anchor\n  result = newRstNode(kind)\n  if p.curAnchor != \"\":\n    result.anchor = p.curAnchor\n    p.curAnchor = \"\"\n    p.curAnchorName = \"\"\n\ntemplate newLeaf(s: string): PRstNode = newRstLeaf(s)\n\nproc newLeaf(p: var RstParser): PRstNode =\n  result = newLeaf(currentTok(p).symbol)\n\nproc validRefnamePunct(x: string): bool =\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#reference-names\n  x.len == 1 and x[0] in {'-', '_', '.', ':', '+'}\n\nfunc getRefnameIdx(p: RstParser, startIdx: int): int =\n  ## Gets last token index of a refname (\"word\" in RST terminology):\n  ##\n  ##   reference names are single words consisting of alphanumerics plus\n  ##   isolated (no two adjacent) internal hyphens, underscores, periods,\n  ##   colons and plus signs; no whitespace or other characters are allowed.\n  ##\n  ## Refnames are used for:\n  ## - reference names\n  ## - role names\n  ## - directive names\n  ## - footnote labels\n  ##\n  # TODO: use this func in all other relevant places\n  var j = startIdx\n  if p.tok[j].kind == tkWord:\n    inc j\n    while p.tok[j].kind == tkPunct and validRefnamePunct(p.tok[j].symbol) and\n        p.tok[j+1].kind == tkWord:\n      inc j, 2\n  result = j - 1\n\nfunc getRefname(p: RstParser, startIdx: int): (string, int) =\n  let lastIdx = getRefnameIdx(p, startIdx)\n  result[1] = lastIdx\n  for j in startIdx..lastIdx:\n    result[0].add p.tok[j].symbol\n\nproc getReferenceName(p: var RstParser, endStr: string): PRstNode =\n  var res = newRstNode(rnInner)\n  while true:\n    case currentTok(p).kind\n    of tkWord, tkOther, tkWhite:\n      res.add(newLeaf(p))\n    of tkPunct:\n      if currentTok(p).symbol == endStr:\n        inc p.idx\n        break\n      else:\n        res.add(newLeaf(p))\n    else:\n      rstMessage(p, meExpected, endStr)\n      break\n    inc p.idx\n  result = res\n\nproc untilEol(p: var RstParser): PRstNode =\n  result = newRstNode(rnInner)\n  while currentTok(p).kind notin {tkIndent, tkEof}:\n    result.add(newLeaf(p))\n    inc p.idx\n\nproc expect(p: var RstParser, tok: string) =\n  if currentTok(p).symbol == tok: inc p.idx\n  else: rstMessage(p, meExpected, tok)\n\nproc inlineMarkdownEnd(p: RstParser): bool =\n  result = prevTok(p).kind notin {tkIndent, tkWhite}\n  ## (For a special case of ` we don't allow spaces surrounding it\n  ## unlike original Markdown because this behavior confusing/useless)\n\nproc inlineRstEnd(p: RstParser): bool =\n  # rst rules: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules\n  # Rule 2:\n  result = prevTok(p).kind notin {tkIndent, tkWhite}\n  if not result: return\n  # Rule 7:\n  result = nextTok(p).kind in {tkIndent, tkWhite, tkEof} or\n      nextTok(p).symbol[0] in\n      {'\\'', '\\\"', ')', ']', '}', '>', '-', '/', '\\\\', ':', '.', ',', ';', '!', '?', '_'}\n\nproc isInlineMarkupEnd(p: RstParser, markup: string, exact: bool): bool =\n  if exact:\n    result = currentTok(p).symbol == markup\n  else:\n    result = currentTok(p).symbol.endsWith markup\n    if (not result) and markup == \"``\":\n      # check that escaping may have splitted `` to 2 tokens ` and `\n      result = currentTok(p).symbol == \"`\" and prevTok(p).symbol == \"`\"\n  if not result: return\n  # surroundings check\n  if markup in [\"_\", \"__\"]:\n    result = inlineRstEnd(p)\n  else:\n    if roPreferMarkdown in p.s.options: result = inlineMarkdownEnd(p)\n    else: result = inlineRstEnd(p)\n\nproc rstRuleSurround(p: RstParser): bool =\n  result = true\n  # Rules 4 & 5:\n  if p.idx > 0:\n    var d: char\n    var c = prevTok(p).symbol[0]\n    case c\n    of '\\'', '\\\"': d = c\n    of '(': d = ')'\n    of '[': d = ']'\n    of '{': d = '}'\n    of '<': d = '>'\n    else: d = '\\0'\n    if d != '\\0': result = nextTok(p).symbol[0] != d\n\nproc inlineMarkdownStart(p: RstParser): bool =\n  result = nextTok(p).kind notin {tkIndent, tkWhite, tkEof}\n  if not result: return\n  # this rst rule is really nice, let us use it in Markdown mode too.\n  result = rstRuleSurround(p)\n\nproc inlineRstStart(p: RstParser): bool =\n  ## rst rules: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules\n  # Rule 6\n  result = p.idx == 0 or prevTok(p).kind in {tkIndent, tkWhite} or\n      prevTok(p).symbol[0] in {'\\'', '\\\"', '(', '[', '{', '<', '-', '/', ':', '_'}\n  if not result: return\n  # Rule 1:\n  result = nextTok(p).kind notin {tkIndent, tkWhite, tkEof}\n  if not result: return\n  result = rstRuleSurround(p)\n\nproc isInlineMarkupStart(p: RstParser, markup: string): bool =\n  if markup != \"_`\":\n    result = currentTok(p).symbol == markup\n  else:  # _` is a 2 token case\n    result = currentTok(p).symbol == \"_\" and nextTok(p).symbol == \"`\"\n  if not result: return\n  # surroundings check\n  if markup in [\"_\", \"__\", \"[\", \"|\"]:\n    # Note: we require space/punctuation even before [markdown link](...)\n    result = inlineRstStart(p)\n  else:\n    if roPreferMarkdown in p.s.options: result = inlineMarkdownStart(p)\n    else: result = inlineRstStart(p)\n\nproc match(p: RstParser, start: int, expr: string): bool =\n  # regular expressions are:\n  # special char     exact match\n  # 'w'              tkWord\n  # ' '              tkWhite\n  # 'a'              tkAdornment\n  # 'i'              tkIndent\n  # 'I'              tkIndent or tkEof\n  # 'p'              tkPunct\n  # 'T'              always true\n  # 'E'              whitespace, indent or eof\n  # 'e'              any enumeration sequence or '#' (for enumeration lists)\n  # 'x'              a..z or '#' (for enumeration lists)\n  # 'n'              0..9 or '#' (for enumeration lists)\n  var i = 0\n  var j = start\n  var last = expr.len - 1\n  while i <= last:\n    case expr[i]\n    of 'w':\n      let lastIdx = getRefnameIdx(p, j)\n      result = lastIdx >= j\n      if result: j = lastIdx\n    of ' ': result = p.tok[j].kind == tkWhite\n    of 'i': result = p.tok[j].kind == tkIndent\n    of 'I': result = p.tok[j].kind in {tkIndent, tkEof}\n    of 'p': result = p.tok[j].kind == tkPunct\n    of 'a': result = p.tok[j].kind == tkAdornment\n    of 'o': result = p.tok[j].kind == tkOther\n    of 'T': result = true\n    of 'E': result = p.tok[j].kind in {tkEof, tkWhite, tkIndent}\n    of 'e', 'x', 'n':\n      result = p.tok[j].kind == tkWord or p.tok[j].symbol == \"#\"\n      if result:\n        case p.tok[j].symbol[0]\n        of '#': result = true\n        of 'a'..'z', 'A'..'Z':\n          result = expr[i] in {'e', 'x'} and p.tok[j].symbol.len == 1\n        of '0'..'9':\n          result = expr[i] in {'e', 'n'} and\n                     allCharsInSet(p.tok[j].symbol, {'0'..'9'})\n        else: result = false\n    else:\n      var c = expr[i]\n      var length = 0\n      while i <= last and expr[i] == c:\n        inc i\n        inc length\n      dec i\n      result = p.tok[j].kind in {tkPunct, tkAdornment} and\n          p.tok[j].symbol.len == length and p.tok[j].symbol[0] == c\n    if not result: return\n    inc j\n    inc i\n  result = true\n\nproc fixupEmbeddedRef(n, a, b: PRstNode) =\n  var sep = - 1\n  for i in countdown(n.len - 2, 0):\n    if n.sons[i].text == \"<\":\n      sep = i\n      break\n  var incr = if sep > 0 and n.sons[sep - 1].text[0] == ' ': 2 else: 1\n  for i in countup(0, sep - incr): a.add(n.sons[i])\n  for i in countup(sep + 1, n.len - 2): b.add(n.sons[i])\n\nproc whichRole(p: RstParser, sym: string): RstNodeKind =\n  result = whichRoleAux(sym)\n  if result == rnUnknownRole:\n    rstMessage(p, mwUnsupportedLanguage, sym)\n\nproc toInlineCode(n: PRstNode, language: string): PRstNode =\n  ## Creates rnInlineCode and attaches `n` contents as code (in 3rd son).\n  result = newRstNode(rnInlineCode, info=n.info)\n  let args = newRstNode(rnDirArg)\n  var lang = language\n  if language == \"cpp\": lang = \"c++\"\n  elif language == \"csharp\": lang = \"c#\"\n  args.add newLeaf(lang)\n  result.add args\n  result.add PRstNode(nil)\n  var lb = newRstNode(rnLiteralBlock)\n  var s: string\n  for i in n.sons:\n    assert i.kind == rnLeaf\n    s.add i.text\n  lb.add newLeaf(s)\n  result.add lb\n\nproc toOtherRole(n: PRstNode, kind: RstNodeKind, roleName: string): PRstNode =\n  let newN = newRstNode(rnInner, n.sons)\n  let newSons = @[newN, newLeaf(roleName)]\n  result = newRstNode(kind, newSons)\n\nproc parsePostfix(p: var RstParser, n: PRstNode): PRstNode =\n  ## Finalizes node `n` that was tentatively determined as interpreted text.\n  var newKind = n.kind\n  var newSons = n.sons\n\n  proc finalizeInterpreted(node: PRstNode, newKind: RstNodeKind,\n                           newSons: seq[PRstNode], roleName: string):\n                          PRstNode {.nimcall.} =\n    # fixes interpreted text (`x` or `y`:role:) to proper internal AST format\n    if newKind in {rnUnknownRole, rnCodeFragment}:\n      result = node.toOtherRole(newKind, roleName)\n    elif newKind == rnInlineCode:\n      result = node.toInlineCode(language=roleName)\n    else:\n      result = newRstNode(newKind, newSons)\n\n  if isInlineMarkupEnd(p, \"_\", exact=true) or\n      isInlineMarkupEnd(p, \"__\", exact=true):\n    inc p.idx\n    if p.tok[p.idx-2].symbol == \"`\" and p.tok[p.idx-3].symbol == \">\":\n      var a = newRstNode(rnInner)\n      var b = newRstNode(rnInner)\n      fixupEmbeddedRef(n, a, b)\n      if a.len == 0:\n        newKind = rnStandaloneHyperlink\n        newSons = @[b]\n      else:\n        newKind = rnHyperlink\n        newSons = @[a, b]\n        setRef(p, rstnodeToRefname(a), b, implicitHyperlinkAlias)\n      result = newRstNode(newKind, newSons)\n    else:  # some link that will be resolved in `resolveSubs`\n      newKind = rnRef\n      result = newRstNode(newKind, sons=newSons, info=n.info)\n  elif match(p, p.idx, \":w:\"):\n    # a role:\n    let (roleName, lastIdx) = getRefname(p, p.idx+1)\n    newKind = whichRole(p, roleName)\n    result = n.finalizeInterpreted(newKind, newSons, roleName)\n    p.idx = lastIdx + 2\n  else:\n    result = n.finalizeInterpreted(p.s.currRoleKind, newSons, p.s.currRole)\n\nproc matchVerbatim(p: RstParser, start: int, expr: string): int =\n  result = start\n  var j = 0\n  while j < expr.len and result < p.tok.len and\n        continuesWith(expr, p.tok[result].symbol, j):\n    inc j, p.tok[result].symbol.len\n    inc result\n  if j < expr.len: result = 0\n\nproc parseSmiley(p: var RstParser): PRstNode =\n  if currentTok(p).symbol[0] notin SmileyStartChars: return\n  for key, val in items(Smilies):\n    let m = matchVerbatim(p, p.idx, key)\n    if m > 0:\n      p.idx = m\n      result = newRstNode(rnSmiley)\n      result.text = val\n      return\n\nproc isUrl(p: RstParser, i: int): bool =\n  result = p.tok[i+1].symbol == \":\" and p.tok[i+2].symbol == \"//\" and\n    p.tok[i+3].kind == tkWord and\n    p.tok[i].symbol in [\"http\", \"https\", \"ftp\", \"telnet\", \"file\"]\n\nproc checkParen(token: Token, parensStack: var seq[char]): bool {.inline.} =\n  ## Returns `true` iff `token` is a closing parenthesis for some\n  ## previous opening parenthesis saved in `parensStack`.\n  ## This is according Markdown balanced parentheses rule\n  ## (https://spec.commonmark.org/0.29/#link-destination)\n  ## to allow links like\n  ## https://en.wikipedia.org/wiki/APL_(programming_language),\n  ## we use it for RST also.\n  result = false\n  if token.kind == tkPunct:\n    let c = token.symbol[0]\n    if c in {'(', '[', '{'}:  # push\n      parensStack.add c\n    elif c in {')', ']', '}'}:  # try pop\n      # a case like ([) inside a link is allowed and [ is also `pop`ed:\n      for i in countdown(parensStack.len - 1, 0):\n        if (parensStack[i] == '(' and c == ')' or\n            parensStack[i] == '[' and c == ']' or\n            parensStack[i] == '{' and c == '}'):\n          parensStack.setLen i\n          result = true\n          break\n\nproc parseUrl(p: var RstParser): PRstNode =\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#standalone-hyperlinks\n  result = newRstNode(rnStandaloneHyperlink)\n  var lastIdx = p.idx\n  var closedParenIdx = p.idx - 1  # for balanced parens rule\n  var parensStack: seq[char]\n  while p.tok[lastIdx].kind in {tkWord, tkPunct, tkOther}:\n    let isClosing = checkParen(p.tok[lastIdx], parensStack)\n    if isClosing:\n      closedParenIdx = lastIdx\n    inc lastIdx\n  dec lastIdx\n  # standalone URL can not end with punctuation in RST\n  while lastIdx > closedParenIdx and p.tok[lastIdx].kind == tkPunct and\n      p.tok[lastIdx].symbol != \"/\":\n    dec lastIdx\n  var s = \"\"\n  for i in p.idx .. lastIdx: s.add p.tok[i].symbol\n  result.add s\n  p.idx = lastIdx + 1\n\nproc parseWordOrRef(p: var RstParser, father: PRstNode) =\n  ## Parses a normal word or may be a reference or URL.\n  if nextTok(p).kind != tkPunct:  # <- main path, a normal word\n    father.add newLeaf(p)\n    inc p.idx\n  elif isUrl(p, p.idx):           # URL http://something\n    father.add parseUrl(p)\n  else:\n    # check for reference (probably, long one like some.ref.with.dots_ )\n    var saveIdx = p.idx\n    var reference: PRstNode = nil\n    inc p.idx\n    while currentTok(p).kind in {tkWord, tkPunct}:\n      if currentTok(p).kind == tkPunct:\n        if isInlineMarkupEnd(p, \"_\", exact=true):\n          reference = newRstNode(rnRef, info=lineInfo(p, saveIdx))\n          break\n        if not validRefnamePunct(currentTok(p).symbol):\n          break\n      inc p.idx\n    if reference != nil:\n      for i in saveIdx..p.idx-1: reference.add newLeaf(p.tok[i].symbol)\n      father.add reference\n      inc p.idx  # skip final _\n    else:  # 1 normal word\n      father.add newLeaf(p.tok[saveIdx].symbol)\n      p.idx = saveIdx + 1\n\nproc parseBackslash(p: var RstParser, father: PRstNode) =\n  assert(currentTok(p).kind == tkPunct)\n  if currentTok(p).symbol == \"\\\\\":\n    # XXX: Unicode?\n    inc p.idx\n    if currentTok(p).kind != tkWhite: father.add(newLeaf(p))\n    if currentTok(p).kind != tkEof: inc p.idx\n  else:\n    father.add(newLeaf(p))\n    inc p.idx\n\nproc parseUntil(p: var RstParser, father: PRstNode, postfix: string,\n                interpretBackslash: bool) =\n  let\n    line = currentTok(p).line\n    col = currentTok(p).col\n  inc p.idx\n  while true:\n    case currentTok(p).kind\n    of tkPunct:\n      if isInlineMarkupEnd(p, postfix, exact=false):\n        let l = currentTok(p).symbol.len\n        if l > postfix.len:\n          # handle cases like *emphasis with stars****. (It's valid RST!)\n          father.add newLeaf(currentTok(p).symbol[0 ..< l - postfix.len])\n        elif postfix == \"``\" and currentTok(p).symbol == \"`\" and\n            prevTok(p).symbol == \"`\":\n          # handle cases like ``literal\\`` - delete ` already added after \\\n          father.sons.setLen(father.sons.len - 1)\n        inc p.idx\n        break\n      else:\n        if postfix == \"`\":\n          if currentTok(p).symbol == \"\\\\\":\n            if nextTok(p).symbol == \"\\\\\":\n              father.add newLeaf(\"\\\\\")\n              father.add newLeaf(\"\\\\\")\n              inc p.idx, 2\n            elif nextTok(p).symbol == \"`\":  # escape `\n              father.add newLeaf(\"`\")\n              inc p.idx, 2\n            else:\n              father.add newLeaf(\"\\\\\")\n              inc p.idx\n          else:\n            father.add(newLeaf(p))\n            inc p.idx\n        else:\n          if interpretBackslash:\n            parseBackslash(p, father)\n          else:\n            father.add(newLeaf(p))\n            inc p.idx\n    of tkAdornment, tkWord, tkOther:\n      father.add(newLeaf(p))\n      inc p.idx\n    of tkIndent:\n      father.add newLeaf(\" \")\n      inc p.idx\n      if currentTok(p).kind == tkIndent:\n        rstMessage(p, meExpected, postfix, line, col)\n        break\n    of tkWhite:\n      father.add newLeaf(\" \")\n      inc p.idx\n    else: rstMessage(p, meExpected, postfix, line, col)\n\nproc parseMarkdownCodeblock(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnCodeBlock)\n  result.info = lineInfo(p)\n  var args = newRstNode(rnDirArg)\n  if currentTok(p).kind == tkWord:\n    args.add(newLeaf(p))\n    inc p.idx\n  else:\n    args = nil\n  var n = newLeaf(\"\")\n  while true:\n    case currentTok(p).kind\n    of tkEof:\n      rstMessage(p, meExpected, \"```\")\n      break\n    of tkPunct, tkAdornment:\n      if currentTok(p).symbol == \"```\":\n        inc p.idx\n        break\n      else:\n        n.text.add(currentTok(p).symbol)\n        inc p.idx\n    else:\n      n.text.add(currentTok(p).symbol)\n      inc p.idx\n  var lb = newRstNode(rnLiteralBlock)\n  lb.add(n)\n  result.add(args)\n  result.add(PRstNode(nil))\n  result.add(lb)\n\nproc parseMarkdownLink(p: var RstParser; father: PRstNode): bool =\n  result = true\n  var desc, link = \"\"\n  var i = p.idx\n\n  var parensStack: seq[char]\n  template parse(endToken, dest) =\n    parensStack.setLen 0\n    inc i # skip begin token\n    while true:\n      if p.tok[i].kind in {tkEof, tkIndent}: return false\n      let isClosing = checkParen(p.tok[i], parensStack)\n      if p.tok[i].symbol == endToken and not isClosing:\n        break\n      dest.add p.tok[i].symbol\n      inc i\n    inc i # skip end token\n\n  parse(\"]\", desc)\n  if p.tok[i].symbol != \"(\": return false\n  parse(\")\", link)\n  let child = newRstNode(rnHyperlink)\n  child.add desc\n  child.add link\n  # only commit if we detected no syntax error:\n  father.add child\n  p.idx = i\n  result = true\n\nproc getFootnoteType(label: PRstNode): (FootnoteType, int) =\n  if label.sons.len >= 1 and label.sons[0].kind == rnLeaf and\n      label.sons[0].text == \"#\":\n    if label.sons.len == 1:\n      result = (fnAutoNumber, -1)\n    else:\n      result = (fnAutoNumberLabel, -1)\n  elif label.len == 1 and label.sons[0].kind == rnLeaf and\n       label.sons[0].text == \"*\":\n    result = (fnAutoSymbol, -1)\n  elif label.len == 1 and label.sons[0].kind == rnLeaf:\n    try:\n      result = (fnManualNumber, parseInt(label.sons[0].text))\n    except:\n      result = (fnCitation, -1)\n  else:\n    result = (fnCitation, -1)\n\nproc parseFootnoteName(p: var RstParser, reference: bool): PRstNode =\n  ## parse footnote/citation label. Precondition: start at `[`.\n  ## Label text should be valid ref. name symbol, otherwise nil is returned.\n  var i = p.idx + 1\n  result = newRstNode(rnInner)\n  while true:\n    if p.tok[i].kind in {tkEof, tkIndent, tkWhite}:\n      return nil\n    if p.tok[i].kind == tkPunct:\n      case p.tok[i].symbol:\n      of \"]\":\n        if i > p.idx + 1 and (not reference or (p.tok[i+1].kind == tkPunct and p.tok[i+1].symbol == \"_\")):\n          inc i                # skip ]\n          if reference: inc i  # skip _\n          break  # to succeed, it's a footnote/citation indeed\n        else:\n          return nil\n      of \"#\":\n        if i != p.idx + 1:\n          return nil\n      of \"*\":\n        if i != p.idx + 1 and p.tok[i].kind != tkPunct and p.tok[i+1].symbol != \"]\":\n          return nil\n      else:\n        if not validRefnamePunct(p.tok[i].symbol):\n          return nil\n    result.add newLeaf(p.tok[i].symbol)\n    inc i\n  p.idx = i\n\nproc parseInline(p: var RstParser, father: PRstNode) =\n  var n: PRstNode  # to be used in `if` condition\n  let saveIdx = p.idx\n  case currentTok(p).kind\n  of tkPunct:\n    if isInlineMarkupStart(p, \"***\"):\n      var n = newRstNode(rnTripleEmphasis)\n      parseUntil(p, n, \"***\", true)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"**\"):\n      var n = newRstNode(rnStrongEmphasis)\n      parseUntil(p, n, \"**\", true)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"*\"):\n      var n = newRstNode(rnEmphasis)\n      parseUntil(p, n, \"*\", true)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"_`\"):\n      var n = newRstNode(rnInlineTarget)\n      inc p.idx\n      parseUntil(p, n, \"`\", false)\n      let refn = rstnodeToRefname(n)\n      addAnchorRst(p, name = linkName(n), refn = refn, reset = true,\n                   anchorType=manualInlineAnchor)\n      father.add(n)\n    elif roSupportMarkdown in p.s.options and currentTok(p).symbol == \"```\":\n      inc p.idx\n      father.add(parseMarkdownCodeblock(p))\n    elif isInlineMarkupStart(p, \"``\"):\n      var n = newRstNode(rnInlineLiteral)\n      parseUntil(p, n, \"``\", false)\n      father.add(n)\n    elif match(p, p.idx, \":w:\") and\n        (var lastIdx = getRefnameIdx(p, p.idx + 1);\n         p.tok[lastIdx+2].symbol == \"`\"):\n      let (roleName, _) = getRefname(p, p.idx+1)\n      let k = whichRole(p, roleName)\n      var n = newRstNode(k)\n      p.idx = lastIdx + 2\n      if k == rnInlineCode:\n        n = n.toInlineCode(language=roleName)\n      parseUntil(p, n, \"`\", false) # bug #17260\n      if k in {rnUnknownRole, rnCodeFragment}:\n        n = n.toOtherRole(k, roleName)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"`\"):\n      var n = newRstNode(rnInterpretedText, info=lineInfo(p, p.idx+1))\n      parseUntil(p, n, \"`\", false) # bug #17260\n      n = parsePostfix(p, n)\n      father.add(n)\n    elif isInlineMarkupStart(p, \"|\"):\n      var n = newRstNode(rnSubstitutionReferences, info=lineInfo(p, p.idx+1))\n      parseUntil(p, n, \"|\", false)\n      father.add(n)\n    elif roSupportMarkdown in p.s.options and\n        currentTok(p).symbol == \"[\" and nextTok(p).symbol != \"[\" and\n        parseMarkdownLink(p, father):\n      discard \"parseMarkdownLink already processed it\"\n    elif isInlineMarkupStart(p, \"[\") and nextTok(p).symbol != \"[\" and\n         (n = parseFootnoteName(p, reference=true); n != nil):\n      var nn = newRstNode(rnFootnoteRef)\n      nn.info = lineInfo(p, saveIdx+1)\n      nn.add n\n      let (fnType, _) = getFootnoteType(n)\n      case fnType\n      of fnAutoSymbol:\n        p.s.lineFootnoteSymRef.add lineInfo(p)\n      of fnAutoNumber:\n        p.s.lineFootnoteNumRef.add lineInfo(p)\n      else: discard\n      father.add(nn)\n    else:\n      if roSupportSmilies in p.s.options:\n        let n = parseSmiley(p)\n        if n != nil:\n          father.add(n)\n          return\n      parseBackslash(p, father)\n  of tkWord:\n    if roSupportSmilies in p.s.options:\n      let n = parseSmiley(p)\n      if n != nil:\n        father.add(n)\n        return\n    parseWordOrRef(p, father)\n  of tkAdornment, tkOther, tkWhite:\n    if roSupportMarkdown in p.s.options and currentTok(p).symbol == \"```\":\n      inc p.idx\n      father.add(parseMarkdownCodeblock(p))\n      return\n    if roSupportSmilies in p.s.options:\n      let n = parseSmiley(p)\n      if n != nil:\n        father.add(n)\n        return\n    father.add(newLeaf(p))\n    inc p.idx\n  else: discard\n\nproc getDirective(p: var RstParser): string =\n  result = \"\"\n  if currentTok(p).kind == tkWhite:\n    let (name, lastIdx) = getRefname(p, p.idx + 1)\n    let afterIdx = lastIdx + 1\n    if name.len > 0:\n      if p.tok[afterIdx].symbol == \"::\":\n        result = name\n        p.idx = afterIdx + 1\n        if currentTok(p).kind == tkWhite:\n          inc p.idx\n        elif currentTok(p).kind != tkIndent:\n          rstMessage(p, mwRstStyle,\n              \"whitespace or newline expected after directive \" & name)\n        result = result.toLowerAscii()\n      elif p.tok[afterIdx].symbol == \":\":\n        rstMessage(p, mwRstStyle,\n            \"double colon :: may be missing at end of '\" & name & \"'\",\n            p.tok[afterIdx].line, p.tok[afterIdx].col)\n      elif p.tok[afterIdx].kind == tkPunct and p.tok[afterIdx].symbol[0] == ':':\n        rstMessage(p, mwRstStyle,\n            \"too many colons for a directive (should be ::)\",\n            p.tok[afterIdx].line, p.tok[afterIdx].col)\n\nproc parseComment(p: var RstParser, col: int): PRstNode =\n  if currentTok(p).kind != tkEof and nextTok(p).kind == tkIndent:\n    inc p.idx              # empty comment\n  else:\n    while currentTok(p).kind != tkEof:\n      if currentTok(p).kind == tkIndent and currentTok(p).ival > col or\n         currentTok(p).kind != tkIndent and currentTok(p).col > col:\n        inc p.idx\n      else:\n        break\n  result = nil\n\nproc parseLine(p: var RstParser, father: PRstNode) =\n  while true:\n    case currentTok(p).kind\n    of tkWhite, tkWord, tkOther, tkPunct: parseInline(p, father)\n    else: break\n\nproc parseUntilNewline(p: var RstParser, father: PRstNode) =\n  while true:\n    case currentTok(p).kind\n    of tkWhite, tkWord, tkAdornment, tkOther, tkPunct: parseInline(p, father)\n    of tkEof, tkIndent: break\n\nproc parseSection(p: var RstParser, result: PRstNode) {.gcsafe.}\n\nproc tokenAfterNewline(p: RstParser, start: int): int =\n  result = start\n  while true:\n    case p.tok[result].kind\n    of tkEof:\n      break\n    of tkIndent:\n      inc result\n      break\n    else: inc result\n\nproc tokenAfterNewline(p: RstParser): int {.inline.} =\n  result = tokenAfterNewline(p, p.idx)\n\nproc getWrappableIndent(p: RstParser): int =\n  ## Gets baseline indentation for bodies of field lists and directives.\n  ## Handles situations like this (with possible de-indent in [case.3])::\n  ##\n  ##   :field:   definition                                          [case.1]\n  ##\n  ##   currInd   currentTok(p).col\n  ##   |         |\n  ##   v         v\n  ##\n  ##   .. Note:: defItem:                                            [case.2]\n  ##                 definition\n  ##\n  ##                 ^\n  ##                 |\n  ##                 nextIndent\n  ##\n  ##   .. Note:: - point1                                            [case.3]\n  ##       - point 2\n  ##\n  ##       ^\n  ##       |\n  ##       nextIndent\n  if currentTok(p).kind == tkIndent:\n    result = currentTok(p).ival\n  else:\n    var nextIndent = p.tok[tokenAfterNewline(p)-1].ival\n    if nextIndent <= currInd(p):          # parse only this line     [case.1]\n      result = currentTok(p).col\n    elif nextIndent >= currentTok(p).col: # may be a definition list [case.2]\n      result = currentTok(p).col\n    else:\n      result = nextIndent                 #                          [case.3]\n\nproc parseField(p: var RstParser): PRstNode =\n  ## Returns a parsed rnField node.\n  ##\n  ## rnField nodes have two children nodes, a rnFieldName and a rnFieldBody.\n  result = newRstNode(rnField, info=lineInfo(p))\n  var col = currentTok(p).col\n  var fieldname = newRstNode(rnFieldName)\n  parseUntil(p, fieldname, \":\", false)\n  var fieldbody = newRstNode(rnFieldBody)\n  if currentTok(p).kind == tkWhite: inc p.idx\n  let indent = getWrappableIndent(p)\n  if indent > col:\n    pushInd(p, indent)\n    parseSection(p, fieldbody)\n    popInd(p)\n  result.add(fieldname)\n  result.add(fieldbody)\n\nproc parseFields(p: var RstParser): PRstNode =\n  ## Parses fields for a section or directive block.\n  ##\n  ## This proc may return nil if the parsing doesn't find anything of value,\n  ## otherwise it will return a node of rnFieldList type with children.\n  result = nil\n  var atStart = p.idx == 0 and p.tok[0].symbol == \":\"\n  if currentTok(p).kind == tkIndent and nextTok(p).symbol == \":\" or\n      atStart:\n    var col = if atStart: currentTok(p).col else: currentTok(p).ival\n    result = newRstNodeA(p, rnFieldList)\n    if not atStart: inc p.idx\n    while true:\n      result.add(parseField(p))\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n          nextTok(p).symbol == \":\":\n        inc p.idx\n      else:\n        break\n\nproc getFieldValue*(n: PRstNode): string =\n  ## Returns the value of a specific ``rnField`` node.\n  ##\n  ## This proc will assert if the node is not of the expected type. The empty\n  ## string will be returned as a minimum. Any value in the rst will be\n  ## stripped form leading/trailing whitespace.\n  assert n.kind == rnField\n  assert n.len == 2\n  assert n.sons[0].kind == rnFieldName\n  assert n.sons[1].kind == rnFieldBody\n  result = addNodes(n.sons[1]).strip\n\nproc getFieldValue(n: PRstNode, fieldname: string): string =\n  if n.sons[1] == nil: return\n  if n.sons[1].kind != rnFieldList:\n    #InternalError(\"getFieldValue (2): \" & $n.sons[1].kind)\n    # We don't like internal errors here anymore as that would break the forum!\n    return\n  for i in 0 ..< n.sons[1].len:\n    var f = n.sons[1].sons[i]\n    if cmpIgnoreStyle(addNodes(f.sons[0]), fieldname) == 0:\n      result = addNodes(f.sons[1])\n      if result == \"\": result = \"\\x01\\x01\" # indicates that the field exists\n      return\n\nproc getArgument(n: PRstNode): string =\n  if n.sons[0] == nil: result = \"\"\n  else: result = addNodes(n.sons[0])\n\nproc parseDotDot(p: var RstParser): PRstNode {.gcsafe.}\nproc parseLiteralBlock(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnLiteralBlock)\n  var n = newLeaf(\"\")\n  if currentTok(p).kind == tkIndent:\n    var indent = currentTok(p).ival\n    while currentTok(p).kind == tkIndent: inc p.idx  # skip blank lines\n    while true:\n      case currentTok(p).kind\n      of tkEof:\n        break\n      of tkIndent:\n        if currentTok(p).ival < indent:\n          break\n        else:\n          n.text.add(\"\\n\")\n          n.text.add(spaces(currentTok(p).ival - indent))\n          inc p.idx\n      else:\n        n.text.add(currentTok(p).symbol)\n        inc p.idx\n  else:\n    while currentTok(p).kind notin {tkIndent, tkEof}:\n      n.text.add(currentTok(p).symbol)\n      inc p.idx\n  result.add(n)\n\nproc parseQuotedLiteralBlock(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnLiteralBlock)\n  var n = newLeaf(\"\")\n  if currentTok(p).kind == tkIndent:\n    var indent = currInd(p)\n    while currentTok(p).kind == tkIndent: inc p.idx  # skip blank lines\n    var quoteSym = currentTok(p).symbol[0]\n    while true:\n      case currentTok(p).kind\n      of tkEof:\n        break\n      of tkIndent:\n        if currentTok(p).ival < indent:\n          break\n        elif currentTok(p).ival == indent:\n          if nextTok(p).kind == tkPunct and nextTok(p).symbol[0] == quoteSym:\n            n.text.add(\"\\n\")\n            inc p.idx\n          elif nextTok(p).kind == tkIndent:\n            break\n          else:\n            rstMessage(p, mwRstStyle, \"no newline after quoted literal block\")\n            break\n        else:\n          rstMessage(p, mwRstStyle,\n                     \"unexpected indentation in quoted literal block\")\n          break\n      else:\n        n.text.add(currentTok(p).symbol)\n        inc p.idx\n  result.add(n)\n\nproc parseRstLiteralBlock(p: var RstParser, kind: LiteralBlockKind): PRstNode =\n  if kind == lbIndentedLiteralBlock:\n    result = parseLiteralBlock(p)\n  else:\n    result = parseQuotedLiteralBlock(p)\n\nproc getLevel(p: var RstParser, c: char, hasOverline: bool): int =\n  ## Returns (preliminary) heading level corresponding to `c` and\n  ## `hasOverline`. If level does not exist, add it first.\n  for i, hType in p.s.hLevels:\n    if hType.symbol == c and hType.hasOverline == hasOverline:\n      p.s.hLevels[i].line = curLine(p)\n      p.s.hLevels[i].hasPeers = true\n      return i\n  p.s.hLevels.add LevelInfo(symbol: c, hasOverline: hasOverline,\n                            line: curLine(p), hasPeers: false)\n  result = p.s.hLevels.len - 1\n\nproc countTitles(s: PRstSharedState, n: PRstNode) =\n  ## Fill `s.hTitleCnt`\n  if n == nil: return\n  for node in n.sons:\n    if node != nil:\n      if node.kind notin {rnOverline, rnSubstitutionDef, rnDefaultRole}:\n        break\n      if node.kind == rnOverline:\n        if s.hLevels[s.hTitleCnt].hasPeers:\n          break\n        inc s.hTitleCnt\n        if s.hTitleCnt >= 2:\n          break\n\nproc isAdornmentHeadline(p: RstParser, adornmentIdx: int): bool =\n  ## check that underline/overline length is enough for the heading.\n  ## No support for Unicode.\n  if p.tok[adornmentIdx].symbol in [\"::\", \"..\", \"|\"]:\n    return false\n  var headlineLen = 0\n  var failure = \"\"\n  if p.idx < adornmentIdx:  # check for underline\n    if p.idx > 0:\n      headlineLen = currentTok(p).col - p.tok[adornmentIdx].col\n    if headlineLen > 0:\n      rstMessage(p, mwRstStyle, \"indentation of heading text allowed\" &\n          \" only for overline titles\")\n    for i in p.idx ..< adornmentIdx-1:  # adornmentIdx-1 is a linebreak\n      headlineLen += p.tok[i].symbol.len\n    result = p.tok[adornmentIdx].symbol.len >= headlineLen and headlineLen != 0\n    if not result:\n      failure = \"(underline '\" & p.tok[adornmentIdx].symbol & \"' is too short)\"\n  else:  # p.idx == adornmentIdx, at overline. Check overline and underline\n    var i = p.idx + 2\n    headlineLen = p.tok[i].col - p.tok[adornmentIdx].col\n    while p.tok[i].kind notin {tkEof, tkIndent}:\n      headlineLen += p.tok[i].symbol.len\n      inc i\n    result = p.tok[adornmentIdx].symbol.len >= headlineLen and\n         headlineLen != 0\n    if result:\n      result = result and p.tok[i].kind == tkIndent and\n         p.tok[i+1].kind == tkAdornment and\n         p.tok[i+1].symbol == p.tok[adornmentIdx].symbol\n      if not result:\n        failure = \"(underline '\" & p.tok[i+1].symbol & \"' does not match \" &\n            \"overline '\" & p.tok[adornmentIdx].symbol & \"')\"\n    else:\n      failure = \"(overline '\" & p.tok[adornmentIdx].symbol & \"' is too short)\"\n  if not result:\n    rstMessage(p, meNewSectionExpected, failure)\n\nproc isLineBlock(p: RstParser): bool =\n  var j = tokenAfterNewline(p)\n  result = currentTok(p).col == p.tok[j].col and p.tok[j].symbol == \"|\" or\n      p.tok[j].col > currentTok(p).col or\n      p.tok[j].symbol == \"\\n\"\n\nproc isMarkdownBlockQuote(p: RstParser): bool =\n  result = currentTok(p).symbol[0] == '>'\n\nproc whichRstLiteralBlock(p: RstParser): LiteralBlockKind =\n  ## Checks that the following tokens are either Indented Literal Block or\n  ## Quoted Literal Block (which is not quite the same as Markdown quote block).\n  ## https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#quoted-literal-blocks\n  if currentTok(p).symbol == \"::\" and nextTok(p).kind == tkIndent:\n    if currInd(p) > nextTok(p).ival:\n      result = lbNone\n    if currInd(p) < nextTok(p).ival:\n      result = lbIndentedLiteralBlock\n    elif currInd(p) == nextTok(p).ival:\n      var i = p.idx + 1\n      while p.tok[i].kind == tkIndent: inc i\n      const validQuotingCharacters = {\n          '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-',\n          '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^',\n          '_', '`', '{', '|', '}', '~'}\n      if p.tok[i].kind in {tkPunct, tkAdornment} and\n          p.tok[i].symbol[0] in validQuotingCharacters:\n        result = lbQuotedLiteralBlock\n      else:\n        result = lbNone\n  else:\n    result = lbNone\n\nproc predNL(p: RstParser): bool =\n  result = true\n  if p.idx > 0:\n    result = prevTok(p).kind == tkIndent and\n        prevTok(p).ival == currInd(p)\n\nproc isDefList(p: RstParser): bool =\n  var j = tokenAfterNewline(p)\n  result = currentTok(p).col < p.tok[j].col and\n      p.tok[j].kind in {tkWord, tkOther, tkPunct} and\n      p.tok[j - 2].symbol != \"::\"\n\nproc isOptionList(p: RstParser): bool =\n  result = match(p, p.idx, \"-w\") or match(p, p.idx, \"--w\") or\n           match(p, p.idx, \"/w\") or match(p, p.idx, \"//w\")\n\nproc isMarkdownHeadlinePattern(s: string): bool =\n  if s.len >= 1 and s.len <= 6:\n    for c in s:\n      if c != '#': return false\n    result = true\n\nproc isMarkdownHeadline(p: RstParser): bool =\n  if roSupportMarkdown in p.s.options:\n    if isMarkdownHeadlinePattern(currentTok(p).symbol) and nextTok(p).kind == tkWhite:\n      if p.tok[p.idx+2].kind in {tkWord, tkOther, tkPunct}:\n        result = true\n\nproc findPipe(p: RstParser, start: int): bool =\n  var i = start\n  while true:\n    if p.tok[i].symbol == \"|\": return true\n    if p.tok[i].kind in {tkIndent, tkEof}: return false\n    inc i\n\nproc whichSection(p: RstParser): RstNodeKind =\n  if currentTok(p).kind in {tkAdornment, tkPunct}:\n    # for punctuation sequences that can be both tkAdornment and tkPunct\n    if roSupportMarkdown in p.s.options and currentTok(p).symbol == \"```\":\n      return rnCodeBlock\n    elif currentTok(p).symbol == \"::\":\n      return rnLiteralBlock\n    elif currentTok(p).symbol == \"..\"  and\n       nextTok(p).kind in {tkWhite, tkIndent}:\n     return rnDirective\n  case currentTok(p).kind\n  of tkAdornment:\n    if match(p, p.idx + 1, \"iI\") and currentTok(p).symbol.len >= 4:\n      result = rnTransition\n    elif match(p, p.idx, \"+a+\"):\n      result = rnGridTable\n      rstMessage(p, meGridTableNotImplemented)\n    elif match(p, p.idx + 1, \" a\"): result = rnTable\n    elif currentTok(p).symbol == \"|\" and isLineBlock(p):\n      result = rnLineBlock\n    elif roSupportMarkdown in p.s.options and isMarkdownBlockQuote(p):\n      result = rnMarkdownBlockQuote\n    elif match(p, p.idx + 1, \"i\") and isAdornmentHeadline(p, p.idx):\n      result = rnOverline\n    else:\n      result = rnLeaf\n  of tkPunct:\n    if isMarkdownHeadline(p):\n      result = rnMarkdownHeadline\n    elif roSupportMarkdown in p.s.options and predNL(p) and\n        match(p, p.idx, \"| w\") and findPipe(p, p.idx+3):\n      result = rnMarkdownTable\n    elif currentTok(p).symbol == \"|\" and isLineBlock(p):\n      result = rnLineBlock\n    elif roSupportMarkdown in p.s.options and isMarkdownBlockQuote(p):\n      result = rnMarkdownBlockQuote\n    elif match(p, tokenAfterNewline(p), \"aI\") and\n        isAdornmentHeadline(p, tokenAfterNewline(p)):\n      result = rnHeadline\n    elif currentTok(p).symbol in [\"+\", \"*\", \"-\"] and nextTok(p).kind == tkWhite:\n      result = rnBulletList\n    elif match(p, p.idx, \":w:E\"):\n      # (currentTok(p).symbol == \":\")\n      result = rnFieldList\n    elif match(p, p.idx, \"(e) \") or match(p, p.idx, \"e) \") or\n         match(p, p.idx, \"e. \"):\n      result = rnEnumList\n    elif isOptionList(p):\n      result = rnOptionList\n    elif isDefList(p):\n      result = rnDefList\n    else:\n      result = rnParagraph\n  of tkWord, tkOther, tkWhite:\n    let tokIdx = tokenAfterNewline(p)\n    if match(p, tokIdx, \"aI\"):\n      if isAdornmentHeadline(p, tokIdx): result = rnHeadline\n      else: result = rnParagraph\n    elif match(p, p.idx, \"e) \") or match(p, p.idx, \"e. \"): result = rnEnumList\n    elif isDefList(p): result = rnDefList\n    else: result = rnParagraph\n  else: result = rnLeaf\n\nproc parseLineBlock(p: var RstParser): PRstNode =\n  ## Returns rnLineBlock with all sons of type rnLineBlockItem\n  result = nil\n  if nextTok(p).kind in {tkWhite, tkIndent}:\n    var col = currentTok(p).col\n    result = newRstNodeA(p, rnLineBlock)\n    while true:\n      var item = newRstNode(rnLineBlockItem)\n      if nextTok(p).kind == tkWhite:\n        if nextTok(p).symbol.len > 1:  # pass additional indentation after '| '\n          item.lineIndent = nextTok(p).symbol\n        inc p.idx, 2\n        pushInd(p, p.tok[p.idx].col)\n        parseSection(p, item)\n        popInd(p)\n      else:  # tkIndent => add an empty line\n        item.lineIndent = \"\\n\"\n        inc p.idx, 1\n      result.add(item)\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n          nextTok(p).symbol == \"|\" and\n          p.tok[p.idx + 2].kind in {tkWhite, tkIndent}:\n        inc p.idx, 1\n      else:\n        break\n\nproc parseDoc(p: var RstParser): PRstNode {.gcsafe.}\n\nproc getQuoteSymbol(p: RstParser, idx: int): tuple[sym: string, depth: int, tokens: int] =\n  result = (\"\", 0, 0)\n  var i = idx\n  result.sym &= p.tok[i].symbol\n  result.depth += p.tok[i].symbol.len\n  inc result.tokens\n  inc i\n  while p.tok[i].kind == tkWhite and i+1 < p.tok.len and\n        p.tok[i+1].kind == tkPunct and p.tok[i+1].symbol[0] == '>':\n    result.sym &= p.tok[i].symbol\n    result.sym &= p.tok[i+1].symbol\n    result.depth += p.tok[i+1].symbol.len\n    inc result.tokens, 2\n    inc i, 2\n\nproc parseMarkdownQuoteSegment(p: var RstParser, curSym: string, col: int):\n                              PRstNode =\n  ## We define *segment* as a group of lines that starts with exactly the\n  ## same quote symbol. If the following lines don't contain any `>` (*lazy*\n  ## continuation) they considered as continuation of the current segment.\n  var q: RstParser  # to delete `>` at a start of line and then parse normally\n  initParser(q, p.s)\n  q.col = p.col\n  q.line = p.line\n  var minCol = int.high  # minimum colum num in the segment\n  while true:  # move tokens of segment from `p` to `q` skipping `curSym`\n    case currentTok(p).kind\n    of tkEof:\n      break\n    of tkIndent:\n      if nextTok(p).kind in {tkIndent, tkEof}:\n        break\n      else:\n        if nextTok(p).symbol[0] == '>':\n          var (quoteSym, _, quoteTokens) = getQuoteSymbol(p, p.idx + 1)\n          if quoteSym == curSym:  # the segment continues\n            var iTok = tokenAfterNewline(p, p.idx+1)\n            if p.tok[iTok].kind notin {tkEof, tkIndent} and\n                p.tok[iTok].symbol[0] != '>':\n              rstMessage(p, mwRstStyle,\n                  \"two or more quoted lines are followed by unquoted line \" &\n                  $(curLine(p) + 1))\n              break\n            q.tok.add currentTok(p)\n            var ival = currentTok(p).ival + quoteSym.len\n            inc p.idx, (1 + quoteTokens)  # skip newline and > > >\n            if currentTok(p).kind == tkWhite:\n              ival += currentTok(p).symbol.len\n              inc p.idx\n            # fix up previous `tkIndent`s to ival (as if >>> were not there)\n            var j = q.tok.len - 1\n            while j >= 0 and q.tok[j].kind == tkIndent:\n              q.tok[j].ival = ival\n              dec j\n          else:  # next segment started\n            break\n        elif currentTok(p).ival < col:\n          break\n        else:  # the segment continues, a case like:\n               # > beginning\n               # continuation\n          q.tok.add currentTok(p)\n          inc p.idx\n    else:\n      if currentTok(p).col < minCol: minCol = currentTok(p).col\n      q.tok.add currentTok(p)\n      inc p.idx\n  q.indentStack = @[minCol]\n  # if initial indentation `minCol` is > 0 then final newlines\n  # should be omitted so that parseDoc could advance to the end of tokens:\n  var j = q.tok.len - 1\n  while q.tok[j].kind == tkIndent: dec j\n  q.tok.setLen (j+1)\n  q.tok.add Token(kind: tkEof, line: currentTok(p).line)\n  result = parseDoc(q)\n\nproc parseMarkdownBlockQuote(p: var RstParser): PRstNode =\n  var (curSym, quotationDepth, quoteTokens) = getQuoteSymbol(p, p.idx)\n  let col = currentTok(p).col\n  result = newRstNodeA(p, rnMarkdownBlockQuote)\n  inc p.idx, quoteTokens  # skip first >\n  while true:\n    var item = newRstNode(rnMarkdownBlockQuoteItem)\n    item.quotationDepth = quotationDepth\n    if currentTok(p).kind == tkWhite: inc p.idx\n    item.add parseMarkdownQuoteSegment(p, curSym, col)\n    result.add(item)\n    if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n        nextTok(p).kind != tkEof and nextTok(p).symbol[0] == '>':\n      (curSym, quotationDepth, quoteTokens) = getQuoteSymbol(p, p.idx + 1)\n      inc p.idx, (1 + quoteTokens)  # skip newline and > > >\n    else:\n      break\n\nproc parseParagraph(p: var RstParser, result: PRstNode) =\n  while true:\n    case currentTok(p).kind\n    of tkIndent:\n      if nextTok(p).kind == tkIndent:\n        inc p.idx\n        break\n      elif currentTok(p).ival == currInd(p):\n        inc p.idx\n        case whichSection(p)\n        of rnParagraph, rnLeaf, rnHeadline, rnMarkdownHeadline,\n            rnOverline, rnDirective:\n          result.add newLeaf(\" \")\n        of rnLineBlock:\n          result.addIfNotNil(parseLineBlock(p))\n        of rnMarkdownBlockQuote:\n          result.addIfNotNil(parseMarkdownBlockQuote(p))\n        else: break\n      else:\n        break\n    of tkPunct:\n      if (let literalBlockKind = whichRstLiteralBlock(p);\n          literalBlockKind != lbNone):\n        result.add newLeaf(\":\")\n        inc p.idx            # skip '::'\n        result.add(parseRstLiteralBlock(p, literalBlockKind))\n        break\n      else:\n        parseInline(p, result)\n    of tkWhite, tkWord, tkAdornment, tkOther:\n      parseInline(p, result)\n    else: break\n\nproc checkHeadingHierarchy(p: RstParser, lvl: int) =\n  if lvl - p.s.hCurLevel > 1:  # broken hierarchy!\n    proc descr(l: int): string =\n      (if p.s.hLevels[l].hasOverline: \"overline \" else: \"underline \") &\n      repeat(p.s.hLevels[l].symbol, 5)\n    var msg = \"(section level inconsistent: \"\n    msg.add descr(lvl) & \" unexpectedly found, \" &\n      \"while the following intermediate section level(s) are missing on lines \"\n    msg.add $p.s.hLevels[p.s.hCurLevel].line & \"..\" & $curLine(p) & \":\"\n    for l in p.s.hCurLevel+1 .. lvl-1:\n      msg.add \" \" & descr(l)\n      if l != lvl-1: msg.add \",\"\n    rstMessage(p, meNewSectionExpected, msg & \")\")\n\nproc parseHeadline(p: var RstParser): PRstNode =\n  if isMarkdownHeadline(p):\n    result = newRstNode(rnMarkdownHeadline)\n    # Note that level hierarchy is not checked for markdown headings\n    result.level = currentTok(p).symbol.len\n    assert(nextTok(p).kind == tkWhite)\n    inc p.idx, 2\n    parseUntilNewline(p, result)\n  else:\n    result = newRstNode(rnHeadline)\n    parseUntilNewline(p, result)\n    assert(currentTok(p).kind == tkIndent)\n    assert(nextTok(p).kind == tkAdornment)\n    var c = nextTok(p).symbol[0]\n    inc p.idx, 2\n    result.level = getLevel(p, c, hasOverline=false)\n    checkHeadingHierarchy(p, result.level)\n    p.s.hCurLevel = result.level\n  addAnchorRst(p, linkName(result), rstnodeToRefname(result), reset=true,\n               anchorType=headlineAnchor)\n\nproc parseOverline(p: var RstParser): PRstNode =\n  var c = currentTok(p).symbol[0]\n  inc p.idx, 2\n  result = newRstNode(rnOverline)\n  while true:\n    parseUntilNewline(p, result)\n    if currentTok(p).kind == tkIndent:\n      inc p.idx\n      if prevTok(p).ival > currInd(p):\n        result.add newLeaf(\" \")\n      else:\n        break\n    else:\n      break\n  result.level = getLevel(p, c, hasOverline=true)\n  checkHeadingHierarchy(p, result.level)\n  p.s.hCurLevel = result.level\n  if currentTok(p).kind == tkAdornment:\n    inc p.idx\n    if currentTok(p).kind == tkIndent: inc p.idx\n  addAnchorRst(p, linkName(result), rstnodeToRefname(result), reset=true,\n               anchorType=headlineAnchor)\n\ntype\n  IntSeq = seq[int]\n  ColumnLimits = tuple\n    first, last: int\n  ColSeq = seq[ColumnLimits]\n\nproc tokEnd(p: RstParser): int =\n  result = currentTok(p).col + currentTok(p).symbol.len - 1\n\nproc getColumns(p: var RstParser, cols: var IntSeq) =\n  var L = 0\n  while true:\n    inc L\n    setLen(cols, L)\n    cols[L - 1] = tokEnd(p)\n    assert(currentTok(p).kind == tkAdornment)\n    inc p.idx\n    if currentTok(p).kind != tkWhite: break\n    inc p.idx\n    if currentTok(p).kind != tkAdornment: break\n  if currentTok(p).kind == tkIndent: inc p.idx\n  # last column has no limit:\n  cols[L - 1] = 32000\n\nproc parseSimpleTable(p: var RstParser): PRstNode =\n  var\n    cols: IntSeq\n    row: seq[string]\n    i, last, line: int\n    c: char\n    q: RstParser\n    a, b: PRstNode\n  result = newRstNodeA(p, rnTable)\n  cols = @[]\n  row = @[]\n  a = nil\n  c = currentTok(p).symbol[0]\n  while true:\n    if currentTok(p).kind == tkAdornment:\n      last = tokenAfterNewline(p)\n      if p.tok[last].kind in {tkEof, tkIndent}:\n        # skip last adornment line:\n        p.idx = last\n        break\n      getColumns(p, cols)\n      setLen(row, cols.len)\n      if a != nil:\n        for j in 0 ..< a.len:  # fix rnTableDataCell -> rnTableHeaderCell\n          a.sons[j] = newRstNode(rnTableHeaderCell, a.sons[j].sons)\n    if currentTok(p).kind == tkEof: break\n    for j in countup(0, high(row)): row[j] = \"\"\n    # the following while loop iterates over the lines a single cell may span:\n    line = currentTok(p).line\n    while true:\n      i = 0\n      while currentTok(p).kind notin {tkIndent, tkEof}:\n        if tokEnd(p) <= cols[i]:\n          row[i].add(currentTok(p).symbol)\n          inc p.idx\n        else:\n          if currentTok(p).kind == tkWhite: inc p.idx\n          inc i\n      if currentTok(p).kind == tkIndent: inc p.idx\n      if tokEnd(p) <= cols[0]: break\n      if currentTok(p).kind in {tkEof, tkAdornment}: break\n      for j in countup(1, high(row)): row[j].add('\\n')\n    a = newRstNode(rnTableRow)\n    for j in countup(0, high(row)):\n      initParser(q, p.s)\n      q.col = cols[j]\n      q.line = line - 1\n      getTokens(row[j], q.tok)\n      b = newRstNode(rnTableDataCell)\n      b.add(parseDoc(q))\n      a.add(b)\n    result.add(a)\n\nproc readTableRow(p: var RstParser): ColSeq =\n  if currentTok(p).symbol == \"|\": inc p.idx\n  while currentTok(p).kind notin {tkIndent, tkEof}:\n    var limits: ColumnLimits\n    limits.first = p.idx\n    while currentTok(p).kind notin {tkIndent, tkEof}:\n      if currentTok(p).symbol == \"|\" and prevTok(p).symbol != \"\\\\\": break\n      inc p.idx\n    limits.last = p.idx\n    result.add(limits)\n    if currentTok(p).kind in {tkIndent, tkEof}: break\n    inc p.idx\n  p.idx = tokenAfterNewline(p)\n\nproc getColContents(p: var RstParser, colLim: ColumnLimits): string =\n  for i in colLim.first ..< colLim.last:\n    result.add(p.tok[i].symbol)\n  result.strip\n\nproc isValidDelimiterRow(p: var RstParser, colNum: int): bool =\n  let row = readTableRow(p)\n  if row.len != colNum: return false\n  for limits in row:\n    let content = getColContents(p, limits)\n    if content.len < 3 or not (content.startsWith(\"--\") or content.startsWith(\":-\")):\n      return false\n  return true\n\nproc parseMarkdownTable(p: var RstParser): PRstNode =\n  var\n    row: ColSeq\n    colNum: int\n    a, b: PRstNode\n    q: RstParser\n  result = newRstNodeA(p, rnMarkdownTable)\n\n  proc parseRow(p: var RstParser, cellKind: RstNodeKind, result: PRstNode) =\n    row = readTableRow(p)\n    if colNum == 0: colNum = row.len # table header\n    elif row.len < colNum: row.setLen(colNum)\n    a = newRstNode(rnTableRow)\n    for j in 0 ..< colNum:\n      b = newRstNode(cellKind)\n      initParser(q, p.s)\n      q.col = p.col\n      q.line = currentTok(p).line - 1\n      getTokens(getColContents(p, row[j]), q.tok)\n      b.add(parseDoc(q))\n      a.add(b)\n    result.add(a)\n\n  parseRow(p, rnTableHeaderCell, result)\n  if not isValidDelimiterRow(p, colNum): rstMessage(p, meMarkdownIllformedTable)\n  while predNL(p) and currentTok(p).symbol == \"|\":\n    parseRow(p, rnTableDataCell, result)\n\nproc parseTransition(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnTransition)\n  inc p.idx\n  if currentTok(p).kind == tkIndent: inc p.idx\n  if currentTok(p).kind == tkIndent: inc p.idx\n\nproc parseBulletList(p: var RstParser): PRstNode =\n  result = nil\n  if nextTok(p).kind == tkWhite:\n    var bullet = currentTok(p).symbol\n    var col = currentTok(p).col\n    result = newRstNodeA(p, rnBulletList)\n    pushInd(p, p.tok[p.idx + 2].col)\n    inc p.idx, 2\n    while true:\n      var item = newRstNode(rnBulletItem)\n      parseSection(p, item)\n      result.add(item)\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n          nextTok(p).symbol == bullet and\n          p.tok[p.idx + 2].kind == tkWhite:\n        inc p.idx, 3\n      else:\n        break\n    popInd(p)\n\nproc parseOptionList(p: var RstParser): PRstNode =\n  result = newRstNodeA(p, rnOptionList)\n  let col = currentTok(p).col\n  var order = 1\n  while true:\n    if currentTok(p).col == col and isOptionList(p):\n      var a = newRstNode(rnOptionGroup)\n      var b = newRstNode(rnDescription)\n      var c = newRstNode(rnOptionListItem)\n      if match(p, p.idx, \"//w\"): inc p.idx\n      while currentTok(p).kind notin {tkIndent, tkEof}:\n        if currentTok(p).kind == tkWhite and currentTok(p).symbol.len > 1:\n          inc p.idx\n          break\n        a.add(newLeaf(p))\n        inc p.idx\n      var j = tokenAfterNewline(p)\n      if j > 0 and p.tok[j - 1].kind == tkIndent and p.tok[j - 1].ival > currInd(p):\n        pushInd(p, p.tok[j - 1].ival)\n        parseSection(p, b)\n        popInd(p)\n      else:\n        parseLine(p, b)\n      while currentTok(p).kind == tkIndent: inc p.idx\n      c.add(a)\n      c.add(b)\n      c.order = order; inc order\n      result.add(c)\n    else:\n      if currentTok(p).kind != tkEof: dec p.idx  # back to tkIndent\n      break\n\nproc parseDefinitionList(p: var RstParser): PRstNode =\n  result = nil\n  var j = tokenAfterNewline(p) - 1\n  if j >= 1 and p.tok[j].kind == tkIndent and\n      p.tok[j].ival > currInd(p) and p.tok[j - 1].symbol != \"::\":\n    var col = currentTok(p).col\n    result = newRstNodeA(p, rnDefList)\n    while true:\n      if isOptionList(p):\n        break  # option list has priority over def.list\n      j = p.idx\n      var a = newRstNode(rnDefName)\n      parseLine(p, a)\n      if currentTok(p).kind == tkIndent and\n          currentTok(p).ival > currInd(p) and\n          nextTok(p).symbol != \"::\" and\n          nextTok(p).kind notin {tkIndent, tkEof}:\n        pushInd(p, currentTok(p).ival)\n        var b = newRstNode(rnDefBody)\n        parseSection(p, b)\n        var c = newRstNode(rnDefItem)\n        c.add(a)\n        c.add(b)\n        result.add(c)\n        popInd(p)\n      else:\n        p.idx = j\n        break\n      if currentTok(p).kind == tkIndent and currentTok(p).ival == col:\n        inc p.idx\n        j = tokenAfterNewline(p) - 1\n        if j >= 1 and p.tok[j].kind == tkIndent and p.tok[j].ival > col and\n            p.tok[j-1].symbol != \"::\" and p.tok[j+1].kind != tkIndent:\n          discard\n        else:\n          break\n    if result.len == 0: result = nil\n\nproc parseEnumList(p: var RstParser): PRstNode =\n  const\n    wildcards: array[0..5, string] = [\"(n) \", \"n) \", \"n. \",\n                                      \"(x) \", \"x) \", \"x. \"]\n      # enumerator patterns, where 'x' means letter and 'n' means number\n    wildToken: array[0..5, int] = [4, 3, 3, 4, 3, 3]  # number of tokens\n    wildIndex: array[0..5, int] = [1, 0, 0, 1, 0, 0]\n      # position of enumeration sequence (number/letter) in enumerator\n  let col = currentTok(p).col\n  var w = 0\n  while w < wildcards.len:\n    if match(p, p.idx, wildcards[w]): break\n    inc w\n  assert w < wildcards.len\n\n  proc checkAfterNewline(p: RstParser, report: bool): bool =\n    ## If no indentation on the next line then parse as a normal paragraph\n    ## according to the RST spec. And report a warning with suggestions\n    let j = tokenAfterNewline(p, start=p.idx+1)\n    let requiredIndent = p.tok[p.idx+wildToken[w]].col\n    if p.tok[j].kind notin {tkIndent, tkEof} and\n        p.tok[j].col < requiredIndent and\n        (p.tok[j].col > col or\n          (p.tok[j].col == col and not match(p, j, wildcards[w]))):\n      if report:\n        let n = p.line + p.tok[j].line\n        let msg = \"\\n\" & \"\"\"\n          not enough indentation on line $2\n            (should be at column $3 if it's a continuation of enum. list),\n          or no blank line after line $1 (if it should be the next paragraph),\n          or no escaping \\ at the beginning of line $1\n            (if lines $1..$2 are a normal paragraph, not enum. list)\"\"\".dedent\n        let c = p.col + requiredIndent + ColRstOffset\n        rstMessage(p, mwRstStyle, msg % [$(n-1), $n, $c],\n                   p.tok[j].line, p.tok[j].col)\n      result = false\n    else:\n      result = true\n\n  if not checkAfterNewline(p, report = true):\n    return nil\n  result = newRstNodeA(p, rnEnumList)\n  let autoEnums = if roSupportMarkdown in p.s.options: @[\"#\", \"1\"] else: @[\"#\"]\n  var prevAE = \"\"  # so as not allow mixing auto-enumerators `1` and `#`\n  var curEnum = 1\n  for i in 0 ..< wildToken[w]-1:  # add first enumerator with (, ), and .\n    if p.tok[p.idx + i].symbol == \"#\":\n      prevAE = \"#\"\n      result.labelFmt.add \"1\"\n    else:\n      result.labelFmt.add p.tok[p.idx + i].symbol\n  var prevEnum = p.tok[p.idx + wildIndex[w]].symbol\n  inc p.idx, wildToken[w]\n  while true:\n    var item = newRstNode(rnEnumItem)\n    pushInd(p, currentTok(p).col)\n    parseSection(p, item)\n    popInd(p)\n    result.add(item)\n    if currentTok(p).kind == tkIndent and currentTok(p).ival == col and\n        match(p, p.idx+1, wildcards[w]):\n      # don't report to avoid duplication of warning since for\n      # subsequent enum. items parseEnumList will be called second time:\n      if not checkAfterNewline(p, report = false):\n        break\n      let enumerator = p.tok[p.idx + 1 + wildIndex[w]].symbol\n      # check that it's in sequence: enumerator == next(prevEnum)\n      if \"n\" in wildcards[w]:  # arabic numeral\n        let prevEnumI = try: parseInt(prevEnum) except: 1\n        if enumerator in autoEnums:\n          if prevAE != \"\" and enumerator != prevAE:\n            break\n          prevAE = enumerator\n          curEnum = prevEnumI + 1\n        else: curEnum = (try: parseInt(enumerator) except: 1)\n        if curEnum - prevEnumI != 1:\n          break\n        prevEnum = enumerator\n      else:  # a..z\n        let prevEnumI = ord(prevEnum[0])\n        if enumerator == \"#\": curEnum = prevEnumI + 1\n        else: curEnum = ord(enumerator[0])\n        if curEnum - prevEnumI != 1:\n          break\n        prevEnum = $chr(curEnum)\n      inc p.idx, 1 + wildToken[w]\n    else:\n      break\n\nproc sonKind(father: PRstNode, i: int): RstNodeKind =\n  result = rnLeaf\n  if i < father.len: result = father.sons[i].kind\n\nproc parseSection(p: var RstParser, result: PRstNode) =\n  ## parse top-level RST elements: sections, transitions and body elements.\n  while true:\n    var leave = false\n    assert(p.idx >= 0)\n    while currentTok(p).kind == tkIndent:\n      if currInd(p) == currentTok(p).ival:\n        inc p.idx\n      elif currentTok(p).ival > currInd(p):\n        pushInd(p, currentTok(p).ival)\n        var a = newRstNodeA(p, rnBlockQuote)\n        parseSection(p, a)\n        result.add(a)\n        popInd(p)\n      else:\n        while currentTok(p).kind != tkEof and nextTok(p).kind == tkIndent:\n          inc p.idx  # skip blank lines\n        leave = true\n        break\n    if leave or currentTok(p).kind == tkEof: break\n    var a: PRstNode = nil\n    var k = whichSection(p)\n    case k\n    of rnLiteralBlock:\n      inc p.idx              # skip '::'\n      a = parseLiteralBlock(p)\n    of rnBulletList: a = parseBulletList(p)\n    of rnLineBlock: a = parseLineBlock(p)\n    of rnMarkdownBlockQuote: a = parseMarkdownBlockQuote(p)\n    of rnDirective: a = parseDotDot(p)\n    of rnEnumList: a = parseEnumList(p)\n    of rnLeaf: rstMessage(p, meNewSectionExpected, \"(syntax error)\")\n    of rnParagraph: discard\n    of rnDefList: a = parseDefinitionList(p)\n    of rnFieldList:\n      if p.idx > 0: dec p.idx\n      a = parseFields(p)\n    of rnTransition: a = parseTransition(p)\n    of rnHeadline, rnMarkdownHeadline: a = parseHeadline(p)\n    of rnOverline: a = parseOverline(p)\n    of rnTable: a = parseSimpleTable(p)\n    of rnMarkdownTable: a = parseMarkdownTable(p)\n    of rnOptionList: a = parseOptionList(p)\n    else:\n      #InternalError(\"rst.parseSection()\")\n      discard\n    if a == nil and k != rnDirective:\n      a = newRstNodeA(p, rnParagraph)\n      parseParagraph(p, a)\n    result.addIfNotNil(a)\n  if sonKind(result, 0) == rnParagraph and sonKind(result, 1) != rnParagraph:\n    result.sons[0] = newRstNode(rnInner, result.sons[0].sons,\n                                anchor=result.sons[0].anchor)\n\nproc parseSectionWrapper(p: var RstParser): PRstNode =\n  result = newRstNode(rnInner)\n  parseSection(p, result)\n  while result.kind == rnInner and result.len == 1:\n    result = result.sons[0]\n\nproc `$`(t: Token): string =\n  result = $t.kind & ' ' & t.symbol\n\nproc parseDoc(p: var RstParser): PRstNode =\n  result = parseSectionWrapper(p)\n  if currentTok(p).kind != tkEof:\n    rstMessage(p, meGeneralParseError)\n\ntype\n  DirFlag = enum\n    hasArg, hasOptions, argIsFile, argIsWord\n  DirFlags = set[DirFlag]\n  SectionParser = proc (p: var RstParser): PRstNode {.nimcall, gcsafe.}\n\nproc parseDirective(p: var RstParser, k: RstNodeKind, flags: DirFlags): PRstNode =\n  ## Parses arguments and options for a directive block.\n  ##\n  ## A directive block will always have three sons: the arguments for the\n  ## directive (rnDirArg), the options (rnFieldList) and the directive\n  ## content block. This proc parses the two first nodes, the 3rd is left to\n  ## the outer `parseDirective` call.\n  ##\n  ## Both rnDirArg and rnFieldList children nodes might be nil, so you need to\n  ## check them before accessing.\n  result = newRstNodeA(p, k)\n  if k == rnCodeBlock: result.info = lineInfo(p)\n  var args: PRstNode = nil\n  var options: PRstNode = nil\n  if hasArg in flags:\n    args = newRstNode(rnDirArg)\n    if argIsFile in flags:\n      while true:\n        case currentTok(p).kind\n        of tkWord, tkOther, tkPunct, tkAdornment:\n          args.add(newLeaf(p))\n          inc p.idx\n        else: break\n    elif argIsWord in flags:\n      while currentTok(p).kind == tkWhite: inc p.idx\n      if currentTok(p).kind == tkWord:\n        args.add(newLeaf(p))\n        inc p.idx\n      else:\n        args = nil\n    else:\n      parseLine(p, args)\n  result.add(args)\n  if hasOptions in flags:\n    if currentTok(p).kind == tkIndent and currentTok(p).ival > currInd(p) and\n        nextTok(p).symbol == \":\":\n      pushInd(p, currentTok(p).ival)\n      options = parseFields(p)\n      popInd(p)\n  result.add(options)\n\nproc indFollows(p: RstParser): bool =\n  result = currentTok(p).kind == tkIndent and currentTok(p).ival > currInd(p)\n\nproc parseBlockContent(p: var RstParser, father: var PRstNode,\n                       contentParser: SectionParser): bool {.gcsafe.} =\n  ## parse the final content part of explicit markup blocks (directives,\n  ## footnotes, etc). Returns true if succeeded.\n  if currentTok(p).kind != tkIndent or indFollows(p):\n    let blockIndent = getWrappableIndent(p)\n    pushInd(p, blockIndent)\n    let content = contentParser(p)\n    popInd(p)\n    father.add content\n    result = true\n\nproc parseDirective(p: var RstParser, k: RstNodeKind, flags: DirFlags,\n                    contentParser: SectionParser): PRstNode =\n  ## A helper proc that does main work for specific directive procs.\n  ## Always returns a generic rnDirective tree with these 3 children:\n  ##\n  ## 1) rnDirArg\n  ## 2) rnFieldList\n  ## 3) a node returned by `contentParser`.\n  ##\n  ## .. warning:: Any of the 3 children may be nil.\n  result = parseDirective(p, k, flags)\n  if not isNil(contentParser) and\n      parseBlockContent(p, result, contentParser):\n    discard \"result is updated by parseBlockContent\"\n  else:\n    result.add(PRstNode(nil))\n\nproc parseDirBody(p: var RstParser, contentParser: SectionParser): PRstNode =\n  if indFollows(p):\n    pushInd(p, currentTok(p).ival)\n    result = contentParser(p)\n    popInd(p)\n\nproc dirInclude(p: var RstParser): PRstNode =\n  ##\n  ## The following options are recognized:\n  ##\n  ## :start-after: text to find in the external data file\n  ##\n  ##     Only the content after the first occurrence of the specified\n  ##     text will be included. If text is not found inclusion will\n  ##     start from beginning of the file\n  ##\n  ## :end-before: text to find in the external data file\n  ##\n  ##     Only the content before the first occurrence of the specified\n  ##     text (but after any after text) will be included. If text is\n  ##     not found inclusion will happen until the end of the file.\n  #literal : flag (empty)\n  #    The entire included text is inserted into the document as a single\n  #    literal block (useful for program listings).\n  #encoding : name of text encoding\n  #    The text encoding of the external data file. Defaults to the document's\n  #    encoding (if specified).\n  #\n  result = nil\n  var n = parseDirective(p, rnDirective, {hasArg, argIsFile, hasOptions}, nil)\n  var filename = strip(addNodes(n.sons[0]))\n  var path = p.findRelativeFile(filename)\n  if path == \"\":\n    rstMessage(p, meCannotOpenFile, filename)\n  else:\n    # XXX: error handling; recursive file inclusion!\n    if getFieldValue(n, \"literal\") != \"\":\n      result = newRstNode(rnLiteralBlock)\n      result.add newLeaf(readFile(path))\n    else:\n      let inputString = readFile(path)\n      let startPosition =\n        block:\n          let searchFor = n.getFieldValue(\"start-after\").strip()\n          if searchFor != \"\":\n            let pos = inputString.find(searchFor)\n            if pos != -1: pos + searchFor.len\n            else: 0\n          else:\n            0\n\n      let endPosition =\n        block:\n          let searchFor = n.getFieldValue(\"end-before\").strip()\n          if searchFor != \"\":\n            let pos = inputString.find(searchFor, start = startPosition)\n            if pos != -1: pos - 1\n            else: 0\n          else:\n            inputString.len - 1\n\n      var q: RstParser\n      initParser(q, p.s)\n      let saveFileIdx = p.s.currFileIdx\n      setCurrFilename(p.s, path)\n      getTokens(\n        inputString[startPosition..endPosition],\n        q.tok)\n      # workaround a GCC bug; more like the interior pointer bug?\n      #if find(q.tok[high(q.tok)].symbol, \"\\0\\x01\\x02\") > 0:\n      #  InternalError(\"Too many binary zeros in include file\")\n      result = parseDoc(q)\n      p.s.currFileIdx = saveFileIdx\n\nproc dirCodeBlock(p: var RstParser, nimExtension = false): PRstNode =\n  ## Parses a code block.\n  ##\n  ## Code blocks are rnDirective trees with a `kind` of rnCodeBlock. See the\n  ## description of ``parseDirective`` for further structure information.\n  ##\n  ## Code blocks can come in two forms, the standard `code directive\n  ## <http://docutils.sourceforge.net/docs/ref/rst/directives.html#code>`_ and\n  ## the nim extension ``.. code-block::``. If the block is an extension, we\n  ## want the default language syntax highlighting to be Nim, so we create a\n  ## fake internal field to communicate with the generator. The field is named\n  ## ``default-language``, which is unlikely to collide with a field specified\n  ## by any random rst input file.\n  ##\n  ## As an extension this proc will process the ``file`` extension field and if\n  ## present will replace the code block with the contents of the referenced\n  ## file. This behaviour is disabled in sandboxed mode and can be re-enabled\n  ## with the `roSandboxDisabled` flag.\n  result = parseDirective(p, rnCodeBlock, {hasArg, hasOptions}, parseLiteralBlock)\n  var filename = strip(getFieldValue(result, \"file\"))\n  if filename != \"\":\n    if roSandboxDisabled notin p.s.options:\n      let tok = p.tok[p.idx-2]\n      rstMessage(p, meSandboxedDirective, \"file\", tok.line, tok.col)\n    var path = p.findRelativeFile(filename)\n    if path == \"\": rstMessage(p, meCannotOpenFile, filename)\n    var n = newRstNode(rnLiteralBlock)\n    n.add newLeaf(readFile(path))\n    result.sons[2] = n\n\n  # Extend the field block if we are using our custom Nim extension.\n  if nimExtension:\n    # Create a field block if the input block didn't have any.\n    if result.sons[1].isNil: result.sons[1] = newRstNode(rnFieldList)\n    assert result.sons[1].kind == rnFieldList\n    # Hook the extra field and specify the Nim language as value.\n    var extraNode = newRstNode(rnField, info=lineInfo(p))\n    extraNode.add(newRstNode(rnFieldName))\n    extraNode.add(newRstNode(rnFieldBody))\n    extraNode.sons[0].add newLeaf(\"default-language\")\n    extraNode.sons[1].add newLeaf(\"Nim\")\n    result.sons[1].add(extraNode)\n\nproc dirContainer(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnContainer, {hasArg}, parseSectionWrapper)\n  assert(result.len == 3)\n\nproc dirImage(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnImage, {hasOptions, hasArg, argIsFile}, nil)\n\nproc dirFigure(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnFigure, {hasOptions, hasArg, argIsFile},\n                          parseSectionWrapper)\n\nproc dirTitle(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnTitle, {hasArg}, nil)\n\nproc dirContents(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnContents, {hasArg}, nil)\n\nproc dirIndex(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnIndex, {}, parseSectionWrapper)\n\nproc dirAdmonition(p: var RstParser, d: string): PRstNode =\n  result = parseDirective(p, rnAdmonition, {}, parseSectionWrapper)\n  result.adType = d\n\nproc dirDefaultRole(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnDefaultRole, {hasArg}, nil)\n  if result.sons[0].len == 0: p.s.currRole = defaultRole(p.s.options)\n  else:\n    assert result.sons[0].sons[0].kind == rnLeaf\n    p.s.currRole = result.sons[0].sons[0].text\n  p.s.currRoleKind = whichRole(p, p.s.currRole)\n\nproc dirRole(p: var RstParser): PRstNode =\n  result = parseDirective(p, rnDirective, {hasArg, hasOptions}, nil)\n  # just check that language is supported, TODO: real role association\n  let lang = getFieldValue(result, \"language\").strip\n  if lang != \"\" and getSourceLanguage(lang) == langNone:\n    rstMessage(p, mwUnsupportedLanguage, lang)\n\nproc dirRawAux(p: var RstParser, result: var PRstNode, kind: RstNodeKind,\n               contentParser: SectionParser) =\n  var filename = getFieldValue(result, \"file\")\n  if filename.len > 0:\n    var path = p.findRelativeFile(filename)\n    if path.len == 0:\n      rstMessage(p, meCannotOpenFile, filename)\n    else:\n      var f = readFile(path)\n      result = newRstNode(kind)\n      result.add newLeaf(f)\n  else:\n    result = newRstNode(kind, result.sons)\n    result.add(parseDirBody(p, contentParser))\n\nproc dirRaw(p: var RstParser): PRstNode =\n  #\n  #The following options are recognized:\n  #\n  #file : string (newlines removed)\n  #    The local filesystem path of a raw data file to be included.\n  #\n  # html\n  # latex\n  result = parseDirective(p, rnDirective, {hasOptions, hasArg, argIsWord})\n  if result.sons[0] != nil:\n    if cmpIgnoreCase(result.sons[0].sons[0].text, \"html\") == 0:\n      dirRawAux(p, result, rnRawHtml, parseLiteralBlock)\n    elif cmpIgnoreCase(result.sons[0].sons[0].text, \"latex\") == 0:\n      dirRawAux(p, result, rnRawLatex, parseLiteralBlock)\n    else:\n      rstMessage(p, meInvalidDirective, result.sons[0].sons[0].text)\n  else:\n    dirRawAux(p, result, rnRaw, parseSectionWrapper)\n\nproc selectDir(p: var RstParser, d: string): PRstNode =\n  result = nil\n  let tok = p.tok[p.idx-2] # report on directive in \".. directive::\"\n  if roSandboxDisabled notin p.s.options:\n    if d notin SandboxDirAllowlist:\n      rstMessage(p, meSandboxedDirective, d, tok.line, tok.col)\n\n  case d\n  of \"admonition\", \"attention\", \"caution\": result = dirAdmonition(p, d)\n  of \"code\": result = dirCodeBlock(p)\n  of \"code-block\": result = dirCodeBlock(p, nimExtension = true)\n  of \"container\": result = dirContainer(p)\n  of \"contents\": result = dirContents(p)\n  of \"danger\": result = dirAdmonition(p, d)\n  of \"default-role\": result = dirDefaultRole(p)\n  of \"error\": result = dirAdmonition(p, d)\n  of \"figure\": result = dirFigure(p)\n  of \"hint\": result = dirAdmonition(p, d)\n  of \"image\": result = dirImage(p)\n  of \"important\": result = dirAdmonition(p, d)\n  of \"include\": result = dirInclude(p)\n  of \"index\": result = dirIndex(p)\n  of \"note\": result = dirAdmonition(p, d)\n  of \"raw\":\n    if roSupportRawDirective in p.s.options:\n      result = dirRaw(p)\n    else:\n      rstMessage(p, meInvalidDirective, d)\n  of \"role\": result = dirRole(p)\n  of \"tip\": result = dirAdmonition(p, d)\n  of \"title\": result = dirTitle(p)\n  of \"warning\": result = dirAdmonition(p, d)\n  else:\n    rstMessage(p, meInvalidDirective, d, tok.line, tok.col)\n\nproc prefix(ftnType: FootnoteType): string =\n  case ftnType\n  of fnManualNumber: result = \"footnote-\"\n  of fnAutoNumber: result = \"footnoteauto-\"\n  of fnAutoNumberLabel: result = \"footnote-\"\n  of fnAutoSymbol: result = \"footnotesym-\"\n  of fnCitation: result = \"citation-\"\n\nproc parseFootnote(p: var RstParser): PRstNode {.gcsafe.} =\n  ## Parses footnotes and citations, always returns 2 sons:\n  ##\n  ## 1) footnote label, always containing rnInner with 1 or more sons\n  ## 2) footnote body, which may be nil\n  inc p.idx\n  let label = parseFootnoteName(p, reference=false)\n  if label == nil:\n    dec p.idx\n    return nil\n  result = newRstNode(rnFootnote)\n  result.add label\n  let (fnType, i) = getFootnoteType(label)\n  var name = \"\"\n  var anchor = fnType.prefix\n  case fnType\n  of fnManualNumber:\n    addFootnoteNumManual(p, i)\n    anchor.add $i\n  of fnAutoNumber, fnAutoNumberLabel:\n    name = rstnodeToRefname(label)\n    addFootnoteNumAuto(p, name)\n    if fnType == fnAutoNumberLabel:\n      anchor.add name\n    else:  # fnAutoNumber\n      result.order = p.s.lineFootnoteNum.len\n      anchor.add $result.order\n  of fnAutoSymbol:\n    addFootnoteSymAuto(p)\n    result.order = p.s.lineFootnoteSym.len\n    anchor.add $p.s.lineFootnoteSym.len\n  of fnCitation:\n    anchor.add rstnodeToRefname(label)\n  addAnchorRst(p, anchor, anchor, reset=true, anchorType=footnoteAnchor)\n  result.anchor = anchor\n  if currentTok(p).kind == tkWhite: inc p.idx\n  discard parseBlockContent(p, result, parseSectionWrapper)\n  if result.len < 2:\n    result.add nil\n\nproc parseDotDot(p: var RstParser): PRstNode =\n  # parse \"explicit markup blocks\"\n  result = nil\n  var n: PRstNode  # to store result, workaround for bug 16855\n  var col = currentTok(p).col\n  inc p.idx\n  var d = getDirective(p)\n  if d != \"\":\n    pushInd(p, col)\n    result = selectDir(p, d)\n    popInd(p)\n  elif match(p, p.idx, \" _\"):\n    # hyperlink target:\n    inc p.idx, 2\n    var ending = \":\"\n    if currentTok(p).symbol == \"`\":\n      inc p.idx\n      ending = \"`\"\n    var a = getReferenceName(p, ending)\n    if ending == \"`\":\n      if currentTok(p).symbol == \":\":\n        inc p.idx\n      else:\n        rstMessage(p, meExpected, \":\")\n    if currentTok(p).kind == tkWhite: inc p.idx\n    var b = untilEol(p)\n    if len(b) == 0:  # set internal anchor\n      addAnchorRst(p, linkName(a), rstnodeToRefname(a), reset=false,\n                   anchorType=manualDirectiveAnchor)\n    else:  # external hyperlink\n      setRef(p, rstnodeToRefname(a), b, refType=hyperlinkAlias)\n  elif match(p, p.idx, \" |\"):\n    # substitution definitions:\n    inc p.idx, 2\n    var a = getReferenceName(p, \"|\")\n    var b: PRstNode\n    if currentTok(p).kind == tkWhite: inc p.idx\n    if cmpIgnoreStyle(currentTok(p).symbol, \"replace\") == 0:\n      inc p.idx\n      expect(p, \"::\")\n      b = untilEol(p)\n    elif cmpIgnoreStyle(currentTok(p).symbol, \"image\") == 0:\n      inc p.idx\n      b = dirImage(p)\n    else:\n      rstMessage(p, meInvalidDirective, currentTok(p).symbol)\n    setSub(p, addNodes(a), b)\n  elif match(p, p.idx, \" [\") and\n      (n = parseFootnote(p); n != nil):\n    result = n\n  else:\n    result = parseComment(p, col)\n\nproc rstParsePass1*(fragment: string,\n                    line, column: int,\n                    sharedState: PRstSharedState): PRstNode =\n  ## Parses an RST `fragment`.\n  ## The result should be further processed by\n  ## preparePass2_ and resolveSubs_ (which is pass 2).\n  var p: RstParser\n  initParser(p, sharedState)\n  p.line = line\n  p.col = column\n  getTokens(fragment, p.tok)\n  result = parseDoc(p)\n\nproc preparePass2*(s: PRstSharedState, mainNode: PRstNode) =\n  ## Records titles in node `mainNode` and orders footnotes.\n  countTitles(s, mainNode)\n  orderFootnotes(s)\n\nproc resolveLink(s: PRstSharedState, n: PRstNode) : PRstNode =\n    # Associate this link alias with its target and change node kind to\n    # rnHyperlink or rnInternalRef appropriately.\n    type LinkDef = object\n      ar: AnchorRule\n      priority: int\n      tooltip: string\n      target: PRstNode\n      info: TLineInfo\n    proc cmp(x, y: LinkDef): int =\n      result = cmp(x.priority, y.priority)\n      if result == 0:\n        result = cmp(x.target, y.target)\n    var foundLinks: seq[LinkDef]\n    let text = newRstNode(rnInner, n.sons)\n    let refn = rstnodeToRefname(n)\n    var hyperlinks = findRef(s, refn)\n    for y in hyperlinks:\n      foundLinks.add LinkDef(ar: arHyperlink, priority: refPriority(y.kind),\n                             target: y.value, info: y.info,\n                             tooltip: \"(\" & $y.kind & \")\")\n    let substRst = findMainAnchorRst(s, text.addNodes, n.info)\n    for subst in substRst:\n      foundLinks.add LinkDef(ar: arInternalRst, priority: subst.priority,\n                             target: newLeaf(subst.mainAnchor[]),\n                             info: subst.info,\n                             tooltip: \"(\" & $subst.anchorType & \")\")\n    if roNimFile in s.options:\n      let substNim = findMainAnchorNim(s, signature=text, n.info)\n      for subst in substNim:\n        foundLinks.add LinkDef(ar: arNim, priority: subst.priority,\n                               target: newLeaf(subst.mainAnchor[]),\n                               info: subst.info, tooltip: subst.tooltip)\n    foundLinks.sort(cmp = cmp, order = Descending)\n    let linkText = addNodes(n)\n    if foundLinks.len >= 1:\n      let kind = if foundLinks[0].ar == arHyperlink: rnHyperlink\n                 elif foundLinks[0].ar == arNim: rnNimdocRef\n                 else: rnInternalRef\n      result = newRstNode(kind)\n      result.sons = @[text, foundLinks[0].target]\n      if kind == rnNimdocRef: result.tooltip = foundLinks[0].tooltip\n      if foundLinks.len > 1:  # report ambiguous link\n        var targets = newSeq[string]()\n        for l in foundLinks:\n          var t = \"    \"\n          if s.filenames.len > 1:\n            t.add getFilename(s.filenames, l.info.fileIndex)\n          let n = l.info.line\n          let c = l.info.col + ColRstOffset\n          t.add \"($1, $2): $3\" % [$n, $c, l.tooltip]\n          targets.add t\n        rstMessage(s.filenames, s.msgHandler, n.info, mwAmbiguousLink,\n                   \"`$1`\\n  clash:\\n$2\" % [\n                     linkText, targets.join(\"\\n\")])\n    else:  # nothing found\n      result = n\n      rstMessage(s.filenames, s.msgHandler, n.info, mwBrokenLink, linkText)\n\nproc resolveSubs*(s: PRstSharedState, n: PRstNode): PRstNode =\n  ## Makes pass 2 of RST parsing.\n  ## Resolves substitutions and anchor aliases, groups footnotes.\n  ## Takes input node `n` and returns the same node with recursive\n  ## substitutions in `n.sons` to `result`.\n  result = n\n  if n == nil: return\n  case n.kind\n  of rnSubstitutionReferences:\n    var x = findSub(s, n)\n    if x >= 0:\n      result = s.subs[x].value\n    else:\n      var key = addNodes(n)\n      var e = getEnv(key)\n      if e != \"\": result = newLeaf(e)\n      else: rstMessage(s.filenames, s.msgHandler, n.info,\n                       mwUnknownSubstitution, key)\n  of rnHeadline, rnOverline:\n    # fix up section levels depending on presence of a title and subtitle\n    if s.hTitleCnt == 2:\n      if n.level == 1:    # it's the subtitle\n        n.level = 0\n      elif n.level >= 2:  # normal sections\n        n.level -= 1\n    elif s.hTitleCnt == 0:\n      n.level += 1\n  of rnRef:\n    result = resolveLink(s, n)\n  of rnFootnote:\n    var (fnType, num) = getFootnoteType(n.sons[0])\n    case fnType\n    of fnManualNumber, fnCitation:\n      discard \"no need to alter fixed text\"\n    of fnAutoNumberLabel, fnAutoNumber:\n      if fnType == fnAutoNumberLabel:\n        let labelR = rstnodeToRefname(n.sons[0])\n        num = getFootnoteNum(s, labelR)\n      else:\n        num = getFootnoteNum(s, n.order)\n      var nn = newRstNode(rnInner)\n      nn.add newLeaf($num)\n      result.sons[0] = nn\n    of fnAutoSymbol:\n      let sym = getAutoSymbol(s, n.order)\n      n.sons[0].sons[0].text = sym\n    n.sons[1] = resolveSubs(s, n.sons[1])\n  of rnFootnoteRef:\n    var (fnType, num) = getFootnoteType(n.sons[0])\n    template addLabel(number: int | string) =\n      var nn = newRstNode(rnInner)\n      nn.add newLeaf($number)\n      result.add(nn)\n    var refn = fnType.prefix\n    # create new rnFootnoteRef, add final label, and finalize target refn:\n    result = newRstNode(rnFootnoteRef, info = n.info)\n    case fnType\n    of fnManualNumber:\n      addLabel num\n      refn.add $num\n    of fnAutoNumber:\n      inc s.currFootnoteNumRef\n      addLabel getFootnoteNum(s, s.currFootnoteNumRef)\n      refn.add $s.currFootnoteNumRef\n    of fnAutoNumberLabel:\n      addLabel getFootnoteNum(s, rstnodeToRefname(n))\n      refn.add rstnodeToRefname(n)\n    of fnAutoSymbol:\n      inc s.currFootnoteSymRef\n      addLabel getAutoSymbol(s, s.currFootnoteSymRef)\n      refn.add $s.currFootnoteSymRef\n    of fnCitation:\n      result.add n.sons[0]\n      refn.add rstnodeToRefname(n)\n    # TODO: correctly report ambiguities\n    let anchorInfo = findMainAnchorRst(s, refn, n.info)\n    if anchorInfo.len != 0:\n      result.add newLeaf(anchorInfo[0].mainAnchor[])  # add link\n    else:\n      rstMessage(s.filenames, s.msgHandler, n.info, mwBrokenLink, refn)\n      result.add newLeaf(refn)  # add link\n  of rnLeaf:\n    discard\n  of rnContents:\n    s.hasToc = true\n  else:\n    var regroup = false\n    for i in 0 ..< n.len:\n      n.sons[i] = resolveSubs(s, n.sons[i])\n      if n.sons[i] != nil and n.sons[i].kind == rnFootnote:\n        regroup = true\n    if regroup:  # group footnotes together into rnFootnoteGroup\n      var newSons: seq[PRstNode]\n      var i = 0\n      while i < n.len:\n        if n.sons[i] != nil and n.sons[i].kind == rnFootnote:\n          var grp = newRstNode(rnFootnoteGroup)\n          while i < n.len and n.sons[i].kind == rnFootnote:\n            grp.sons.add n.sons[i]\n            inc i\n          newSons.add grp\n        else:\n          newSons.add n.sons[i]\n          inc i\n      result.sons = newSons\n\nproc rstParse*(text, filename: string,\n               line, column: int,\n               options: RstParseOptions,\n               findFile: FindFileHandler = nil,\n               msgHandler: MsgHandler = nil):\n              tuple[node: PRstNode, filenames: RstFileTable, hasToc: bool] =\n  ## Parses the whole `text`. The result is ready for `rstgen.renderRstToOut`,\n  ## note that 2nd tuple element should be fed to `initRstGenerator`\n  ## argument `filenames` (it is being filled here at least with `filename`\n  ## and possibly with other files from RST ``.. include::`` statement).\n  var sharedState = newRstSharedState(options, filename, findFile, msgHandler)\n  let unresolved = rstParsePass1(text, line, column, sharedState)\n  preparePass2(sharedState, unresolved)\n  result.node = resolveSubs(sharedState, unresolved)\n  result.filenames = sharedState.filenames\n  result.hasToc = sharedState.hasToc\n", "discard \"\"\"\noutputsub: \"\"\n\"\"\"\n\n# tests for rstgen module.\n\nimport ../../lib/packages/docutils/rstgen\nimport ../../lib/packages/docutils/rst\nimport unittest, strutils, strtabs\nimport std/private/miscdollars\n\nproc toHtml(input: string,\n            rstOptions: RstParseOptions = {roPreferMarkdown, roSupportMarkdown, roNimFile},\n            error: ref string = nil,\n            warnings: ref seq[string] = nil): string =\n  ## If `error` is nil then no errors should be generated.\n  ## The same goes for `warnings`.\n  proc testMsgHandler(filename: string, line, col: int, msgkind: MsgKind,\n                      arg: string) =\n    let mc = msgkind.whichMsgClass\n    let a = $msgkind % arg\n    var message: string\n    toLocation(message, filename, line, col + ColRstOffset)\n    message.add \" $1: $2\" % [$mc, a]\n    if mc == mcError:\n      if error == nil:\n        raise newException(EParseError, \"[unexpected error] \" & message)\n      error[] = message\n      # we check only first error because subsequent ones may be meaningless\n      raise newException(EParseError, \"\")\n    else:\n      doAssert warnings != nil, \"unexpected RST warning '\" & message & \"'\"\n      warnings[].add message\n  try:\n    result = rstToHtml(input, rstOptions, defaultConfig(),\n                       msgHandler=testMsgHandler)\n  except EParseError as e:\n    if e.msg != \"\":\n      result = e.msg\n\n# inline code tags (for parsing originated from highlite.nim)\nproc id(str: string): string = \"\"\"<span class=\"Identifier\">\"\"\"  & str & \"</span>\"\nproc op(str: string): string = \"\"\"<span class=\"Operator\">\"\"\"    & str & \"</span>\"\nproc pu(str: string): string = \"\"\"<span class=\"Punctuation\">\"\"\" & str & \"</span>\"\nproc optionListLabel(opt: string): string =\n  \"\"\"<div class=\"option-list-label\"><tt><span class=\"option\">\"\"\" &\n  opt &\n  \"</span></tt></div>\"\n\nconst\n  NoSandboxOpts = {roPreferMarkdown, roSupportMarkdown, roNimFile, roSandboxDisabled}\n\n\nsuite \"YAML syntax highlighting\":\n  test \"Basics\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    a string: string\n    a list:\n      - item 1\n      - item 2\n    a map:\n    ? key\n    : value\n    ...\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">a string</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">string</span>\n<span class=\"StringLit\">a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 1</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 2</span>\n<span class=\"StringLit\">a map</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">?</span> <span class=\"StringLit\">key</span>\n<span class=\"Punctuation\">:</span> <span class=\"StringLit\">value</span>\n<span class=\"Keyword\">...</span></pre>\"\"\"\n\n  test \"Block scalars\":\n    let input = \"\"\".. code-block:: yaml\n    a literal block scalar: |\n      some text\n      # not a comment\n     # a comment, since less indented\n      # another comment\n    a folded block scalar: >2\n       some text\n      # not a comment since indented as specified\n     # a comment\n    another literal block scalar:\n      |+ # comment after header\n     allowed, since more indented than parent\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"StringLit\">a literal block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">|</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n  some text\n  # not a comment\n </span><span class=\"Comment\"># a comment, since less indented</span>\n  <span class=\"Comment\"># another comment</span>\n<span class=\"StringLit\">a folded block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">&gt;2</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n   some text\n  # not a comment since indented as specified\n </span><span class=\"Comment\"># a comment</span>\n<span class=\"StringLit\">another literal block scalar</span><span class=\"Punctuation\">:</span>\n  <span class=\"Command\">|+</span> <span class=\"Comment\"># comment after header</span><span class=\"LongStringLit\">\n allowed, since more indented than parent</span></pre>\"\"\"\n\n  test \"Directives\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    %not a directive\n    ...\n    %a directive\n    ...\n    a string\n    % not a directive\n    ...\n    %TAG ! !foo:\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">%not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">a string</span>\n<span class=\"StringLit\">% not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%TAG ! !foo:</span></pre>\"\"\"\n\n  test \"Flow Style and Numbers\":\n    let input = \"\"\".. code-block:: yaml\n    {\n      \"quoted string\": 42,\n      'single quoted string': false,\n      [ list, \"with\", 'entries' ]: 73.32e-73,\n      more numbers: [-783, 11e78],\n      not numbers: [ 42e, 0023, +32.37, 8 ball]\n    }\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Punctuation\">{</span>\n  <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">quoted string&quot;</span><span class=\"Punctuation\">:</span> <span class=\"DecNumber\">42</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">'single quoted string'</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">false</span><span class=\"Punctuation\">,</span>\n  <span class=\"Punctuation\">[</span> <span class=\"StringLit\">list</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">with&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">'entries'</span> <span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span> <span class=\"FloatNumber\">73.32e-73</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">more numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span><span class=\"DecNumber\">-783</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">11e78</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">not numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span> <span class=\"StringLit\">42e</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">0023</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">+32.37</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">8 ball</span><span class=\"Punctuation\">]</span>\n<span class=\"Punctuation\">}</span></pre>\"\"\"\n\n  test \"Directives: warnings\":\n    let input = dedent\"\"\"\n      .. non-existent-warning: Paragraph.\n\n      .. another.wrong:warning::: Paragraph.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check output == \"\"\n    doAssert warnings[].len == 2\n    check \"(1, 24) Warning: RST style:\" in warnings[0]\n    check \"double colon :: may be missing at end of 'non-existent-warning'\" in warnings[0]\n    check \"(3, 25) Warning: RST style:\" in warnings[1]\n    check \"RST style: too many colons for a directive (should be ::)\" in warnings[1]\n\n  test \"not a directive\":\n    let input = \"..warning:: I am not a warning.\"\n    check input.toHtml == input\n\n  test \"Anchors, Aliases, Tags\":\n    let input = \"\"\".. code-block:: yaml\n    --- !!map\n    !!str string: !<tag:yaml.org,2002:int> 42\n    ? &anchor !!seq []:\n    : !localtag foo\n    alias: *anchor\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">---</span> <span class=\"TagStart\">!!map</span>\n<span class=\"TagStart\">!!str</span> <span class=\"StringLit\">string</span><span class=\"Punctuation\">:</span> <span class=\"TagStart\">!&lt;tag:yaml.org,2002:int&gt;</span> <span class=\"DecNumber\">42</span>\n<span class=\"Punctuation\">?</span> <span class=\"Label\">&amp;anchor</span> <span class=\"TagStart\">!!seq</span> <span class=\"Punctuation\">[</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">:</span> <span class=\"TagStart\">!localtag</span> <span class=\"StringLit\">foo</span>\n<span class=\"StringLit\">alias</span><span class=\"Punctuation\">:</span> <span class=\"Reference\">*anchor</span></pre>\"\"\"\n\n  test \"Edge cases\":\n    let input = \"\"\".. code-block:: yaml\n    ...\n     %a string:\n      a:string:not:a:map\n    ...\n    not a list:\n      -2\n      -3\n      -4\n    example.com/not/a#comment:\n      ?not a map key\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">...</span>\n <span class=\"StringLit\">%a string</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">a:string:not:a:map</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">not a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"DecNumber\">-2</span>\n  <span class=\"DecNumber\">-3</span>\n  <span class=\"DecNumber\">-4</span>\n<span class=\"StringLit\">example.com/not/a#comment</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">?not a map key</span></pre>\"\"\"\n\n\nsuite \"RST/Markdown general\":\n  test \"RST emphasis\":\n    doAssert rstToHtml(\"*Hello* **world**!\", {},\n      newStringTable(modeStyleInsensitive)) ==\n      \"<em>Hello</em> <strong>world</strong>!\"\n\n  test \"Markdown links\":\n    check(\"(( [Nim](https://nim-lang.org/) ))\".toHtml ==\n        \"\"\"(( <a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a> ))\"\"\")\n    check(\"(([Nim](https://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>))\"\"\")\n    check(\"[[Nim](https://nim-lang.org/)]\".toHtml ==\n        \"\"\"[<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>]\"\"\")\n\n  test \"Markdown tables\":\n    let input1 = \"\"\"\n| A1 header    | A2 \\| not fooled\n| :---         | ----:       |\n| C1           | C2 **bold** | ignored |\n| D1 `code \\|` | D2          | also ignored\n| E1 \\| text   |\n|              | F2 without pipe\nnot in table\"\"\"\n    let output1 = input1.toHtml\n    #[\n    TODO: `\\|` inside a table cell should render as `|`\n        `|` outside a table cell should render as `\\|`\n    consistently with markdown, see https://stackoverflow.com/a/66557930/1426932\n    ]#\n    check(output1 == \"\"\"\n<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2 | not fooled</th></tr>\n<tr><td>C1</td><td>C2 <strong>bold</strong></td></tr>\n<tr><td>D1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"code\" & \" \" & op\"\\|\" & \"\"\"</span></tt></td><td>D2</td></tr>\n<tr><td>E1 | text</td><td></td></tr>\n<tr><td></td><td>F2 without pipe</td></tr>\n</table><p>not in table</p>\"\"\")\n    let input2 = \"\"\"\n| A1 header | A2 |\n| --- | --- |\"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"\"\"<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2</th></tr>\n</table>\"\"\"\n\n  test \"RST tables\":\n    let input1 = \"\"\"\nTest 2 column/4 rows table:\n====   ===\nH0     H1\n====   ===\nA0     A1\n====   ===\nA2     A3\n====   ===\nA4     A5\n====   === \"\"\"\n    let output1 = rstToLatex(input1, {})\n    doAssert \"{LL}\" in output1  # 2 columns\n    doAssert count(output1, \"\\\\\\\\\") == 4  # 4 rows\n    for cell in [\"H0\", \"H1\", \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\"]:\n      doAssert cell in output1\n\n    let input2 = \"\"\"\nNow test 3 columns / 2 rows, and also borders containing 4 =, 3 =, 1 = signs:\n\n====   ===  =\nH0     H1   H\n====   ===  =\nA0     A1   X\n       Ax   Y\n====   ===  = \"\"\"\n    let output2 = rstToLatex(input2, {})\n    doAssert \"{LLL}\" in output2  # 3 columns\n    doAssert count(output2, \"\\\\\\\\\") == 2  # 2 rows\n    for cell in [\"H0\", \"H1\", \"H\", \"A0\", \"A1\", \"X\", \"Ax\", \"Y\"]:\n      doAssert cell in output2\n\n\n  test \"RST adornments\":\n    let input1 = \"\"\"\nCheck that a few punctuation symbols are not parsed as adornments:\n:word1: word2 .... word3 \"\"\"\n    let output1 = input1.toHtml\n    discard output1\n\n  test \"RST sections\":\n    let input1 = \"\"\"\nLong chapter name\n'''''''''''''''''''\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"Long chapter name\" in output1 and \"<h1\" in output1\n\n    let input2 = \"\"\"\nShort chapter name:\n\nChA\n===\n\"\"\"\n    let output2 = input2.toHtml\n    doAssert \"ChA\" in output2 and \"<h1\" in output2\n\n    let input3 = \"\"\"\nVery short chapter name:\n\nX\n~\n\"\"\"\n    let output3 = input3.toHtml\n    doAssert \"X\" in output3 and \"<h1\" in output3\n\n    let input4 = \"\"\"\nCheck that short underline is not enough to make section:\n\nWrong chapter\n------------\n\n\"\"\"\n    var error4 = new string\n    let output4 = input4.toHtml(error = error4)\n    check(error4[] == \"input(3, 1) Error: new section expected (underline \" &\n            \"\\'------------\\' is too short)\")\n\n    let input5 = \"\"\"\nCheck that punctuation after adornment and indent are not detected as adornment.\n\nSome chapter\n--------------\n\n  \"punctuation symbols\" \"\"\"\n    let output5 = input5.toHtml\n    doAssert \"&quot;punctuation symbols&quot;\" in output5 and \"<h1\" in output5\n\n    # check that EOF after adornment does not prevent it parsing as heading\n    let input6 = dedent \"\"\"\n      Some chapter\n      ------------\"\"\"\n    let output6 = input6.toHtml\n    doAssert \"<h1 id=\\\"some-chapter\\\">Some chapter</h1>\" in output6\n\n    # check that overline and underline match\n    let input7 = dedent \"\"\"\n      ------------\n      Some chapter\n      -----------\n      \"\"\"\n    var error7 = new string\n    let output7 = input7.toHtml(error=error7)\n    check(error7[] == \"input(1, 1) Error: new section expected (underline \" &\n            \"\\'-----------\\' does not match overline \\'------------\\')\")\n\n    let input8 = dedent \"\"\"\n      -----------\n          Overflow\n      -----------\n      \"\"\"\n    var error8 = new string\n    let output8 = input8.toHtml(error=error8)\n    check(error8[] == \"input(1, 1) Error: new section expected (overline \" &\n            \"\\'-----------\\' is too short)\")\n\n    # check that hierarchy of title styles works\n    let input9good = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n\n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      Another2\n      --------\n\n      More3\n      ~~~~~\n\n      \"\"\"\n    let output9good = input9good.toHtml\n    doAssert \"<h1 id=\\\"level1\\\">Level1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"level3\\\">Level3</h3>\" in output9good\n    doAssert \"<h1 id=\\\"l1\\\">L1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"more3\\\">More3</h3>\" in output9good\n\n    # check that swap causes an exception\n    let input9Bad = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n\n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      More\n      ~~~~\n\n      Another\n      -------\n\n      \"\"\"\n    var error9Bad = new string\n    let output9Bad = input9bad.toHtml(error=error9Bad)\n    check(error9Bad[] == \"input(15, 1) Error: new section expected (section \" &\n            \"level inconsistent: underline ~~~~~ unexpectedly found, while \" &\n            \"the following intermediate section level(s) are missing on \" &\n            \"lines 12..15: underline -----)\")\n\n  test \"RST sections overline\":\n    # the same as input9good but with overline headings\n    # first overline heading has a special meaning: document title\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n\n      ------\n      Level1\n      ------\n\n      Level2\n      ------\n\n      ~~~~~~\n      Level3\n      ~~~~~~\n\n      --\n      L1\n      --\n\n      Another2\n      --------\n\n      ~~~~~\n      More3\n      ~~~~~\n\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames = files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"SubTitle0\"\n    doAssert \"<h1 id=\\\"level1\\\"><center>Level1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output\n    doAssert \"<h3 id=\\\"level3\\\"><center>Level3</center></h3>\" in output\n    doAssert \"<h1 id=\\\"l1\\\"><center>L1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output\n    doAssert \"<h3 id=\\\"more3\\\"><center>More3</center></h3>\" in output\n\n  test \"RST sections overline 2\":\n    # check that a paragraph prevents interpreting overlines as document titles\n    let input = dedent \"\"\"\n      Paragraph\n\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert \"<h1 id=\\\"title0\\\"><center>Title0</center></h1>\" in output\n    doAssert \"<h2 id=\\\"subtitle0\\\"><center>SubTitle0</center></h2>\" in output\n\n  test \"RST+Markdown sections\":\n    # check that RST and Markdown headings don't interfere\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      MySection1a\n      +++++++++++\n\n      # MySection1b\n\n      MySection1c\n      +++++++++++\n\n      ##### MySection5a\n\n      MySection2a\n      -----------\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {roSupportMarkdown})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert output ==\n             \"\\n<h1 id=\\\"mysection1a\\\">MySection1a</h1>\" & # RST\n             \"\\n<h1 id=\\\"mysection1b\\\">MySection1b</h1>\" & # Markdown\n             \"\\n<h1 id=\\\"mysection1c\\\">MySection1c</h1>\" & # RST\n             \"\\n<h5 id=\\\"mysection5a\\\">MySection5a</h5>\" & # Markdown\n             \"\\n<h2 id=\\\"mysection2a\\\">MySection2a</h2>\"   # RST\n\n  test \"RST inline text\":\n    let input1 = \"GC_step\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"GC_step\"\n\n  test \"RST links\":\n    let input1 = \"\"\"\nWant to learn about `my favorite programming language`_?\n\n.. _my favorite programming language: https://nim-lang.org\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<a\" in output1 and \"href=\\\"https://nim-lang.org\\\"\" in output1\n\n  test \"RST transitions\":\n    let input1 = \"\"\"\ncontext1\n\n~~~~\n\ncontext2\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<hr\" in output1\n\n    let input2 = \"\"\"\nThis is too short to be a transition:\n\n---\n\ncontext2\n\"\"\"\n    var error2 = new string\n    let output2 = input2.toHtml(error=error2)\n    check(error2[] == \"input(3, 1) Error: new section expected (overline \" &\n            \"\\'---\\' is too short)\")\n\n  test \"RST literal block\":\n    let input1 = \"\"\"\nTest literal block\n\n::\n\n  check \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre>\" in output1\n\n  test \"Markdown code block\":\n    let input1 = \"\"\"\n```\nlet x = 1\n``` \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre\" in output1 and \"class=\\\"Keyword\\\"\" notin output1\n\n    let input2 = \"\"\"\nParse the block with language specifier:\n```Nim\nlet x = 1\n``` \"\"\"\n    let output2 = input2.toHtml\n    doAssert \"<pre\" in output2 and \"class=\\\"Keyword\\\"\" in output2\n\n  test \"interpreted text\":\n    check(\"\"\"`foo.bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & op\".\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`a\\b\\x\\\\ar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"a\" & op\"\"\"\\\"\"\" & id\"b\" & op\"\"\"\\\"\"\" & id\"x\" & op\"\"\"\\\\\"\"\" & id\"ar\" &\n      \"</span></tt>\")\n\n  test \"inline literal\":\n    check \"\"\"``foo.bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo.bar</span></tt>\"\"\"\n    check \"\"\"``foo\\bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo\\bar</span></tt>\"\"\"\n    check \"\"\"``f\\`o\\\\o\\b`ar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">f\\`o\\\\o\\b`ar</span></tt>\"\"\"\n\n  test \"default-role\":\n    # nim(default) -> literal -> nim -> code(=literal)\n    let input = dedent\"\"\"\n      Par1 `value1`.\n\n      .. default-role:: literal\n\n      Par2 `value2`.\n\n      .. default-role:: nim\n\n      Par3 `value3`.\n\n      .. default-role:: code\n\n      Par4 `value4`.\"\"\"\n    let p1 = \"\"\"Par1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value1\" & \"</span></tt>.\"\n    let p2 = \"\"\"<p>Par2 <tt class=\"docutils literal\"><span class=\"pre\">value2</span></tt>.</p>\"\"\"\n    let p3 = \"\"\"<p>Par3 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value3\" & \"</span></tt>.</p>\"\n    let p4 = \"\"\"<p>Par4 <tt class=\"docutils literal\"><span class=\"pre\">value4</span></tt>.</p>\"\"\"\n    let expected = p1 & p2 & \"\\n\" & p3 & \"\\n\" & p4\n    check(\n      input.toHtml(NoSandboxOpts) == expected\n    )\n\n  test \"role directive\":\n    let input = dedent\"\"\"\n      .. role:: y(code)\n         :language: yaml\n\n      .. role:: brainhelp(code)\n         :language: brainhelp\n    \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(\n      NoSandboxOpts,\n      warnings=warnings\n    )\n    check(warnings[].len == 1 and \"language 'brainhelp' not supported\" in warnings[0])\n\n  test \"RST comments\":\n    let input1 = \"\"\"\n\nCheck that comment disappears:\n\n..\n  some comment \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"Check that comment disappears:\"\n\n  test \"RST line blocks + headings\":\n    let input = \"\"\"\n=====\nTest1\n=====\n\n|\n|\n| line block\n| other line\n\n\"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Test1\"\n      # check that title was not overwritten to '|'\n    doAssert output == \"<p><br/><br/>line block<br/>other line<br/></p>\"\n    let output1l = rstToLatex(input, {})\n    doAssert \"line block\\n\\n\" in output1l\n    doAssert \"other line\\n\\n\" in output1l\n    doAssert output1l.count(\"\\\\vspace\") == 2 + 2  # +2 surrounding paddings\n\n  test \"RST line blocks\":\n    let input2 = dedent\"\"\"\n      Paragraph1\n\n      |\n\n      Paragraph2\"\"\"\n\n    let output2 = input2.toHtml\n    doAssert \"Paragraph1<p><br/></p> <p>Paragraph2</p>\" == output2\n\n    let input3 = dedent\"\"\"\n      | xxx\n      |   yyy\n      |     zzz\"\"\"\n\n    let output3 = input3.toHtml\n    doAssert \"xxx<br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 1.0em\\\">yyy</span><br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output3\n\n    # check that '|   ' with a few spaces is still parsed as new line\n    let input4 = dedent\"\"\"\n      | xxx\n      |\n      |     zzz\"\"\"\n\n    let output4 = input4.toHtml\n    doAssert \"xxx<br/><br/>\" in output4\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output4\n\n  test \"RST enumerated lists\":\n    let input1 = dedent \"\"\"\n      1. line1\n         1\n      2. line2\n         2\n\n      3. line3\n         3\n\n\n      4. line4\n         4\n\n\n\n      5. line5\n         5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n\n    let input2 = dedent \"\"\"\n      3. line3\n\n      4. line4\n\n\n      5. line5\n\n\n\n      7. line7\n\n\n\n\n      8. line8\n      \"\"\"\n    let output2 = input2.toHtml\n    for i in [3, 4, 5, 7, 8]:\n      doAssert ($i & \". line\" & $i) notin output2\n      doAssert (\"<li>line\" & $i & \"</li>\") in output2\n\n    # check that nested enumerated lists work\n    let input3 = dedent \"\"\"\n      1.  a) string1\n      2. string2\n      \"\"\"\n    let output3 = input3.toHtml\n    doAssert count(output3, \"<ol \") == 2\n    doAssert count(output3, \"</ol>\") == 2\n    doAssert \"<li>string1</li>\" in output3 and \"<li>string2</li>\" in output3\n\n    let input4 = dedent \"\"\"\n      Check that enumeration specifiers are respected\n\n      9. string1\n      10. string2\n      12. string3\n\n      b) string4\n      c) string5\n      e) string6\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert count(output4, \"<ol \") == 4\n    doAssert count(output4, \"</ol>\") == 4\n    for enumerator in [9, 12]:\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n    for enumerator in [2, 5]:  # 2=b, 5=e\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n\n    let input5 = dedent \"\"\"\n      Check that auto-numbered enumeration lists work.\n\n      #. string1\n\n      #. string2\n\n      #. string3\n\n      #) string5\n      #) string6\n      \"\"\"\n    let output5 = input5.toHtml\n    doAssert count(output5, \"<ol \") == 2\n    doAssert count(output5, \"</ol>\") == 2\n    doAssert count(output5, \"<li>\") == 5\n\n    let input5a = dedent \"\"\"\n      Auto-numbered RST list can start with 1 even when Markdown support is on.\n\n      1. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output5a = input5a.toHtml\n    doAssert count(output5a, \"<ol \") == 1\n    doAssert count(output5a, \"</ol>\") == 1\n    doAssert count(output5a, \"<li>\") == 3\n\n    let input6 = dedent \"\"\"\n      ... And for alphabetic enumerators too!\n\n      b. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output6 = input6.toHtml\n    doAssert count(output6, \"<ol \") == 1\n    doAssert count(output6, \"</ol>\") == 1\n    doAssert count(output6, \"<li>\") == 3\n    doAssert \"start=\\\"2\\\"\" in output6 and \"class=\\\"loweralpha simple\\\"\" in output6\n\n    let input7 = dedent \"\"\"\n      ... And for uppercase alphabetic enumerators.\n\n      C. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert count(output7, \"<ol \") == 1\n    doAssert count(output7, \"</ol>\") == 1\n    doAssert count(output7, \"<li>\") == 3\n    doAssert \"start=\\\"3\\\"\" in output7 and \"class=\\\"upperalpha simple\\\"\" in output7\n\n    # check that it's not recognized as enum.list without indentation on 2nd line\n    let input8 = dedent \"\"\"\n      Paragraph.\n\n      A. stringA\n      B. stringB\n      C. string1\n      string2\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings = warnings8)\n    check(warnings8[].len == 1)\n    check(\"input(6, 1) Warning: RST style: \\n\" &\n          \"not enough indentation on line 6\" in warnings8[0])\n    doAssert output8 == \"Paragraph.<ol class=\\\"upperalpha simple\\\">\" &\n        \"<li>stringA</li>\\n<li>stringB</li>\\n</ol>\\n<p>C. string1 string2 </p>\"\n\n  test \"Markdown enumerated lists\":\n    let input1 = dedent \"\"\"\n      Below are 2 enumerated lists: Markdown-style (5 items) and RST (1 item)\n      1. line1\n      1. line2\n      1. line3\n      1. line4\n\n      1. line5\n\n      #. lineA\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ol \") == 2\n    doAssert count(output1, \"</ol>\") == 2\n\n  test \"RST bullet lists\":\n    let input1 = dedent \"\"\"\n      * line1\n        1\n      * line2\n        2\n\n      * line3\n        3\n\n\n      * line4\n        4\n\n\n\n      * line5\n        5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ul \") == 1\n    doAssert count(output1, \"</ul>\") == 1\n\n  test \"Nim RST footnotes and citations\":\n    # check that auto-label footnote enumerated properly after a manual one\n    let input1 = dedent \"\"\"\n      .. [1] Body1.\n      .. [#note] Body2\n\n      Ref. [#note]_\n      \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1.count(\">[1]</a>\") == 1\n    doAssert output1.count(\">[2]</a>\") == 2\n    doAssert \"href=\\\"#footnote-note\\\"\" in output1\n    doAssert \">[-1]\" notin output1\n    doAssert \"Body1.\" in output1\n    doAssert \"Body2\" in output1\n\n    # check that there are NO footnotes/citations, only comments:\n    let input2 = dedent \"\"\"\n      .. [1 #] Body1.\n      .. [# note] Body2.\n      .. [wrong citation] That gives you a comment.\n\n      .. [not&allowed] That gives you a comment.\n\n      Not references[#note]_[1 #]_ [wrong citation]_ and [not&allowed]_.\n      \"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"Not references[#note]_[1 #]_ [wrong citation]_ and [not&amp;allowed]_.\"\n\n    # check that auto-symbol footnotes work:\n    let input3 = dedent \"\"\"\n      Ref. [*]_ and [*]_ and [*]_.\n\n      .. [*] Body1\n      .. [*] Body2.\n\n\n      .. [*] Body3.\n      .. [*] Body4\n\n      And [*]_.\n      \"\"\"\n    let output3 = input3.toHtml\n    # both references and footnotes. Footnotes have link to themselves.\n    doAssert output3.count(\"href=\\\"#footnotesym-1\\\">[*]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-2\\\">[**]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-3\\\">[***]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-4\\\">[^]</a>\") == 2\n    # footnote group\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    # footnotes\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-1\\\">[*]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-2\\\">[**]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-3\\\">[***]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-4\\\">[^]</a></strong></sup></div>\") == 1\n    for i in 1 .. 4: doAssert (\"Body\" & $i) in output3\n\n    # check manual, auto-number and auto-label footnote enumeration\n    let input4 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#mylabel] Auto-label1.\n      .. [#note] Auto-label2.\n      .. [#] Auto-number2.\n\n      Ref. [#note]_ and [#]_ and [#]_.\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert \">[-1]\" notin output1\n    let order = @[\n        \"footnote-3\", \"[3]\", \"Manual1.\",\n        \"footnoteauto-1\", \"[1]\", \"Auto-number1\",\n        \"footnote-mylabel\", \"[2]\", \"Auto-label1\",\n        \"footnote-note\", \"[4]\", \"Auto-label2\",\n        \"footnoteauto-2\", \"[5]\", \"Auto-number2\",\n        ]\n    for i in 0 .. order.len-2:\n      let pos1 = output4.find(order[i])\n      let pos2 = output4.find(order[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n    # forgot [#]_\n    let input5 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#note] Auto-label2.\n\n      Ref. [#note]_\n      \"\"\"\n    var error5 = new string\n    let output5 = input5.toHtml(error=error5)\n    check(error5[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 2) != 0 (lines ) for auto-numbered \" &\n            \"footnotes\")\n\n    # extra [*]_\n    let input6 = dedent \"\"\"\n      Ref. [*]_\n\n      .. [*] Auto-Symbol.\n\n      Ref. [*]_\n      \"\"\"\n    var error6 = new string\n    let output6 = input6.toHtml(error=error6)\n    check(error6[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 3) != 2 (lines 2, 6) for auto-symbol \" &\n            \"footnotes\")\n\n    let input7 = dedent \"\"\"\n      .. [Some:CITATION-2020] Citation.\n\n      Ref. [some:citation-2020]_.\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert output7.count(\"href=\\\"#citation-somecoloncitationminus2020\\\"\") == 2\n    doAssert output7.count(\"[Some:CITATION-2020]\") == 1\n    doAssert output7.count(\"[some:citation-2020]\") == 1\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n\n    let input8 = dedent \"\"\"\n      .. [Some] Citation.\n\n      Ref. [som]_.\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings=warnings8)\n    check(warnings8[] == @[\"input(3, 7) Warning: broken link 'citation-som'\"])\n\n    # check that footnote group does not break parsing of other directives:\n    let input9 = dedent \"\"\"\n      .. [Some] Citation.\n\n      .. _`internal anchor`:\n\n      .. [Another] Citation.\n      .. just comment.\n      .. [Third] Citation.\n\n      Paragraph1.\n\n      Paragraph2 ref `internal anchor`_.\n      \"\"\"\n    let output9 = input9.toHtml\n    # _`internal anchor` got erased:\n    check \"href=\\\"#internal-anchor\\\"\" notin output9\n    check \"href=\\\"#citation-another\\\"\" in output9\n    doAssert output9.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    doAssert output9.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"just comment\" notin output9\n\n    # check that nested citations/footnotes work\n    let input10 = dedent \"\"\"\n      Paragraph1 [#]_.\n\n      .. [First] Citation.\n\n         .. [#] Footnote.\n\n            .. [Third] Citation.\n      \"\"\"\n    let output10 = input10.toHtml\n    doAssert output10.count(\"<hr class=\\\"footnote\\\">\" &\n                            \"<div class=\\\"footnote-group\\\">\") == 3\n    doAssert output10.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"<a href=\\\"#citation-first\\\">[First]</a>\" in output10\n    doAssert \"<a href=\\\"#footnoteauto-1\\\">[1]</a>\" in output10\n    doAssert \"<a href=\\\"#citation-third\\\">[Third]</a>\" in output10\n\n    let input11 = \".. [note]\\n\"  # should not crash\n    let output11 = input11.toHtml\n    doAssert \"<a href=\\\"#citation-note\\\">[note]</a>\" in output11\n\n    # check that references to auto-numbered footnotes work\n    let input12 = dedent \"\"\"\n      Ref. [#]_ and [#]_ STOP.\n\n      .. [#] Body1.\n      .. [#] Body3\n      .. [2] Body2.\n      \"\"\"\n    let output12 = input12.toHtml\n    let orderAuto = @[\n        \"#footnoteauto-1\", \"[1]\",\n        \"#footnoteauto-2\", \"[3]\",\n        \"STOP.\",\n        \"Body1.\", \"Body3\", \"Body2.\"\n        ]\n    for i in 0 .. orderAuto.len-2:\n      let pos1 = output12.find(orderAuto[i])\n      let pos2 = output12.find(orderAuto[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n  test \"Nim (RST extension) code-block\":\n    # check that presence of fields doesn't consume the following text as\n    # its code (which is a literal block)\n    let input0 = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 0\n\n      Paragraph1\"\"\"\n    let output0 = input0.toHtml\n    doAssert \"<p>Paragraph1</p>\" in output0\n\n  test \"Nim code-block :number-lines:\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 55\n\n         x\n         y\n      \"\"\"\n    check \"<pre class=\\\"line-nums\\\">55\\n56\\n</pre>\" in input.toHtml\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n\n       x\n      \"\"\"\n    let output = input.toHtml\n    check \"<pre class=\\\"line-nums\\\">55\\n</pre>\" in output\n    check \"<span class=\\\"Identifier\\\">x</span>\" in output\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n         let a = 1\n      \"\"\"\n    var error = new string\n    let output = input.toHtml(error=error)\n    check(error[] == \"input(2, 3) Error: invalid field: \" &\n                     \"extra arguments were given to number-lines: ' let a = 1'\")\n    check \"\" == output\n\n  test \"code-block warning\":\n    let input = dedent \"\"\"\n      .. code:: Nim\n         :unsupportedField: anything\n\n      .. code:: unsupportedLang\n\n         anything\n\n      ```anotherLang\n      someCode\n      ```\n      \"\"\"\n    let warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check(warnings[] == @[\n        \"input(2, 4) Warning: field 'unsupportedField' not supported\",\n        \"input(4, 11) Warning: language 'unsupportedLang' not supported\",\n        \"input(8, 4) Warning: language 'anotherLang' not supported\"\n        ])\n    check(output == \"<pre class = \\\"listing\\\">anything</pre>\" &\n                    \"<p><pre class = \\\"listing\\\">\\nsomeCode\\n</pre> </p>\")\n\n  test \"RST admonitions\":\n    # check that all admonitions are implemented\n    let input0 = dedent \"\"\"\n      .. admonition:: endOf admonition\n      .. attention:: endOf attention\n      .. caution:: endOf caution\n      .. danger:: endOf danger\n      .. error:: endOf error\n      .. hint:: endOf hint\n      .. important:: endOf important\n      .. note:: endOf note\n      .. tip:: endOf tip\n      .. warning:: endOf warning\n    \"\"\"\n    let output0 = input0.toHtml(\n      NoSandboxOpts\n    )\n    for a in [\"admonition\", \"attention\", \"caution\", \"danger\", \"error\", \"hint\",\n        \"important\", \"note\", \"tip\", \"warning\" ]:\n      doAssert \"endOf \" & a & \"</div>\" in output0\n\n    # Test that admonition does not swallow up the next paragraph.\n    let input1 = dedent \"\"\"\n      .. error:: endOfError\n\n      Test paragraph.\n    \"\"\"\n    let output1 = input1.toHtml(\n      NoSandboxOpts\n    )\n    doAssert \"endOfError</div>\" in output1\n    doAssert \"<p>Test paragraph. </p>\" in output1\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output1\n\n    # Test that second line is parsed as continuation of the first line.\n    let input2 = dedent \"\"\"\n      .. error:: endOfError\n        Test2p.\n\n      Test paragraph.\n    \"\"\"\n    let output2 = input2.toHtml(\n      NoSandboxOpts\n    )\n    doAssert \"endOfError Test2p.</div>\" in output2\n    doAssert \"<p>Test paragraph. </p>\" in output2\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output2\n\n    let input3 = dedent \"\"\"\n      .. note:: endOfNote\n    \"\"\"\n    let output3 = input3.toHtml(\n      NoSandboxOpts\n    )\n    doAssert \"endOfNote</div>\" in output3\n    doAssert \"class=\\\"admonition admonition-info\\\"\" in output3\n\n  test \"RST internal links\":\n    let input1 = dedent \"\"\"\n      Start.\n\n      .. _target000:\n\n      Paragraph.\n\n      .. _target001:\n\n      * bullet list\n      * Y\n\n      .. _target002:\n\n      1. enumeration list\n      2. Y\n\n      .. _target003:\n\n      term 1\n        Definition list 1.\n\n      .. _target004:\n\n      | line block\n\n      .. _target005:\n\n      :a: field list value\n\n      .. _target006:\n\n      -a  option description\n\n      .. _target007:\n\n      ::\n\n        Literal block\n\n      .. _target008:\n\n      Doctest blocks are not implemented.\n\n      .. _target009:\n\n          block quote\n\n      .. _target010:\n\n      =====  =====  =======\n        A      B    A and B\n      =====  =====  =======\n      False  False  False\n      =====  =====  =======\n\n      .. _target100:\n\n      .. CAUTION:: admonition\n\n      .. _target101:\n\n      .. code:: nim\n\n         const pi = 3.14\n\n      .. _target102:\n\n      .. code-block::\n\n         const pi = 3.14\n\n      Paragraph2.\n\n      .. _target202:\n\n      ----\n\n      That was a transition.\n    \"\"\"\n    let output1 = input1.toHtml(\n      NoSandboxOpts\n    )\n    doAssert \"<p id=\\\"target000\\\"\"     in output1\n    doAssert \"<ul id=\\\"target001\\\"\"    in output1\n    doAssert \"<ol id=\\\"target002\\\"\"    in output1\n    doAssert \"<dl id=\\\"target003\\\"\"    in output1\n    doAssert \"<p id=\\\"target004\\\"\"     in output1\n    doAssert \"<table id=\\\"target005\\\"\" in output1  # field list\n    doAssert \"<div id=\\\"target006\\\"\"   in output1  # option list\n    doAssert \"<pre id=\\\"target007\\\"\"   in output1\n    doAssert \"<blockquote id=\\\"target009\\\"\" in output1\n    doAssert \"<table id=\\\"target010\\\"\" in output1  # just table\n    doAssert \"<span id=\\\"target100\\\"\"  in output1\n    doAssert \"<pre id=\\\"target101\\\"\"   in output1  # code\n    doAssert \"<pre id=\\\"target102\\\"\"   in output1  # code-block\n    doAssert \"<hr id=\\\"target202\\\"\"    in output1\n\n  test \"RST internal links for sections\":\n    let input1 = dedent \"\"\"\n      .. _target101:\n      .. _target102:\n\n      Section xyz\n      -----------\n\n      Ref. target101_\n    \"\"\"\n    let output1 = input1.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    check \"href=\\\"#target101\\\"\" notin output1\n    check \"id=\\\"target101\\\"\"    notin output1\n    check \"href=\\\"#target102\\\"\" notin output1\n    check \"id=\\\"target102\\\"\"    notin output1\n    check \"id=\\\"section-xyz\\\"\"     in output1\n    check \"href=\\\"#section-xyz\\\"\"  in output1\n\n    let input2 = dedent \"\"\"\n      .. _target300:\n\n      Section xyz\n      ===========\n\n      .. _target301:\n\n      SubsectionA\n      -----------\n\n      Ref. target300_ and target301_.\n\n      .. _target103:\n\n      .. [cit2020] note.\n\n      Ref. target103_.\n\n    \"\"\"\n    let output2 = input2.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    doAssert \"href=\\\"#target300\\\"\" notin output2\n    doAssert \"id=\\\"target300\\\"\"    notin output2\n    doAssert \"href=\\\"#target301\\\"\" notin output2\n    doAssert \"id=\\\"target301\\\"\"    notin output2\n    doAssert \"<h1 id=\\\"section-xyz\\\"\" in output2\n    doAssert \"<h2 id=\\\"subsectiona\\\"\" in output2\n    # links should preserve their original names but point to section labels:\n    doAssert \"href=\\\"#section-xyz\\\">target300\" in output2\n    doAssert \"href=\\\"#subsectiona\\\">target301\" in output2\n    doAssert \"href=\\\"#citation-cit2020\\\">target103\" in output2\n\n    let output2l = rstToLatex(input2, {})\n    doAssert \"\\\\label{section-xyz}\\\\hypertarget{section-xyz}{}\" in output2l\n    doAssert \"\\\\hyperlink{section-xyz}{target300}\"  in output2l\n    doAssert \"\\\\hyperlink{subsectiona}{target301}\"  in output2l\n\n  test \"RST internal links (inline)\":\n    let input1 = dedent \"\"\"\n      Paragraph with _`some definition`.\n\n      Ref. `some definition`_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<span class=\\\"target\\\" \" &\n        \"id=\\\"some-definition\\\">some definition</span>\" in output1\n    doAssert \"Ref. <a class=\\\"reference internal\\\" \" &\n        \"href=\\\"#some-definition\\\">some definition</a>\" in output1\n\n  test \"RST references (additional symbols)\":\n    # check that ., _, -, +, : are allowed symbols in references without ` `\n    let input1 = dedent \"\"\"\n      sec.1\n      -----\n\n      2-other:sec+c_2\n      ^^^^^^^^^^^^^^^\n\n      .. _link.1_2021:\n\n      Paragraph\n\n      Ref. sec.1_! and 2-other:sec+c_2_;and link.1_2021_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"id=\\\"secdot1\\\"\" in output1\n    doAssert \"id=\\\"Z2minusothercolonsecplusc-2\\\"\" in output1\n    check \"id=\\\"linkdot1-2021\\\"\" in output1\n    let ref1 = \"<a class=\\\"reference internal\\\" href=\\\"#secdot1\\\">sec.1</a>\"\n    let ref2 = \"<a class=\\\"reference internal\\\" href=\\\"#Z2minusothercolonsecplusc-2\\\">2-other:sec+c_2</a>\"\n    let ref3 = \"<a class=\\\"reference internal\\\" href=\\\"#linkdot1-2021\\\">link.1_2021</a>\"\n    let refline = \"Ref. \" & ref1 & \"! and \" & ref2 & \";and \" & ref3 & \".\"\n    doAssert refline in output1\n\n  test \"Option lists 1\":\n    # check that \"* b\" is not consumed by previous bullet item because of\n    # incorrect indentation handling in option lists\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      * b\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check(output.count(\"<li>\") == 2)\n    check(output.count(\"<div class=\\\"option-list\\\"\") == 1)\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n\n  test \"Option lists 2\":\n    # check that 2nd option list is not united with the 1st\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Option list 3 (double /)\":\n    let input = dedent \"\"\"\n      * a\n        //compile  compile1\n        //doc      doc1\n                   cont\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"compile\") &\n          \"\"\"<div class=\"option-list-description\">compile1</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"doc\") &\n          \"\"\"<div class=\"option-list-description\">doc1 cont</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Roles: subscript prefix/postfix\":\n    let expected = \"See <sub>some text</sub>.\"\n    check \"See :subscript:`some text`.\".toHtml == expected\n    check \"See `some text`:subscript:.\".toHtml == expected\n\n  test \"Roles: correct parsing from beginning of line\":\n    let expected = \"<sup>3</sup>He is an isotope of helium.\"\n    check \"\"\":superscript:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\":sup:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:sup:\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:superscript:\\ He is an isotope of helium.\"\"\".toHtml == expected\n\n  test \"Roles: warnings\":\n    let input = dedent\"\"\"\n      See function :py:func:`spam`.\n\n      See also `egg`:py:class:.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    doAssert warnings[].len == 2\n    check \"(1, 14) Warning: \" in warnings[0]\n    check \"language 'py:func' not supported\" in warnings[0]\n    check \"(3, 15) Warning: \" in warnings[1]\n    check \"language 'py:class' not supported\" in warnings[1]\n    check(\"\"\"<p>See function <span class=\"py:func\">spam</span>.</p>\"\"\" & \"\\n\" &\n          \"\"\"<p>See also <span class=\"py:class\">egg</span>. </p>\"\"\" ==\n          output)\n\n  test \"(not) Roles: check escaping 1\":\n    let expected = \"\"\"See :subscript:<tt class=\"docutils literal\">\"\"\" &\n                   \"\"\"<span class=\"pre\">\"\"\" & id\"some\" & \" \" & id\"text\" &\n                   \"</span></tt>.\"\n    check \"\"\"See \\:subscript:`some text`.\"\"\".toHtml == expected\n    check \"\"\"See :subscript\\:`some text`.\"\"\".toHtml == expected\n\n  test \"(not) Roles: check escaping 2\":\n    check(\"\"\"See :subscript:\\`some text\\`.\"\"\".toHtml ==\n          \"See :subscript:`some text`.\")\n\n  test \"Field list\":\n    check(\":field: text\".toHtml ==\n            \"\"\"<table class=\"docinfo\" frame=\"void\" rules=\"none\">\"\"\" &\n            \"\"\"<col class=\"docinfo-name\" /><col class=\"docinfo-content\" />\"\"\" &\n            \"\"\"<tbody valign=\"top\"><tr><th class=\"docinfo-name\">field:</th>\"\"\" &\n            \"\"\"<td>text</td></tr>\"\"\" & \"\\n</tbody></table>\")\n\n  test \"Field list: body after newline\":\n    let output = dedent \"\"\"\n      :field:\n        text1\"\"\".toHtml\n    check \"<table class=\\\"docinfo\\\"\" in output\n    check \">field:</th>\" in output\n    check \"<td>text1</td>\" in output\n\n  test \"Field list (incorrect)\":\n    check \":field:text\".toHtml == \":field:text\"\n\nsuite \"RST/Code highlight\":\n  test \"Basic Python code highlight\":\n    let pythonCode = \"\"\"\n    .. code-block:: python\n\n      def f_name(arg=42):\n          print(f\"{arg}\")\n\n    \"\"\"\n\n    let expected = \"\"\"<blockquote><p><span class=\"Keyword\">def</span> f_name<span class=\"Punctuation\">(</span><span class=\"Punctuation\">arg</span><span class=\"Operator\">=</span><span class=\"DecNumber\">42</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\n    print<span class=\"Punctuation\">(</span><span class=\"RawData\">f&quot;{arg}&quot;</span><span class=\"Punctuation\">)</span></p></blockquote>\"\"\"\n\n    check strip(rstToHtml(pythonCode, {}, newStringTable(modeCaseSensitive))) ==\n      strip(expected)\n\n\nsuite \"invalid targets\":\n  test \"invalid image target\":\n    let input1 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: https://bar.com\n      :alt: Alt text for the image\"\"\"\n    let output1 = input1.toHtml\n    check output1 == \"\"\"<a class=\"reference external\" href=\"https://bar.com\"><img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/></a>\"\"\"\n\n    let input2 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: javascript://bar.com\n      :alt: Alt text for the image\"\"\"\n    let output2 = input2.toHtml\n    check output2 == \"\"\"<img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/>\"\"\"\n\n    let input3 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: bar.com\n      :alt: Alt text for the image\"\"\"\n    let output3 = input3.toHtml\n    check output3 == \"\"\"<a class=\"reference external\" href=\"bar.com\"><img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/></a>\"\"\"\n\n  test \"invalid links\":\n    check(\"(([Nim](https://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>))\"\"\")\n    check(\"(([Nim](javascript://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"\">Nim</a>))\"\"\")\n\nsuite \"local file inclusion\":\n  test \"cannot include files in sandboxed mode\":\n    var error = new string\n    discard \".. include:: ./readme.md\".toHtml(error=error)\n    check(error[] == \"input(1, 11) Error: disabled directive: 'include'\")\n\n  test \"code-block file directive is disabled\":\n    var error = new string\n    discard \".. code-block:: nim\\n    :file: ./readme.md\".toHtml(error=error)\n    check(error[] == \"input(2, 20) Error: disabled directive: 'file'\")\n\n"], "buggy_code_start_loc": [285, 237, 49], "buggy_code_end_loc": [286, 3116, 1578], "fixing_code_start_loc": [285, 238, 50], "fixing_code_end_loc": [286, 3131, 1610], "type": "CWE-287", "message": "Nimforum is a lightweight alternative to Discourse written in Nim. In versions prior to 2.2.0 any forum user can create a new thread/post with an include referencing a file local to the host operating system. Nimforum will render the file if able. This can also be done silently by using NimForum's post \"preview\" endpoint. Even if NimForum is running as a non-critical user, the forum.json secrets can be stolen. Version 2.2.0 of NimForum includes patches for this vulnerability. Users are advised to upgrade as soon as is possible. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-23602", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-01T11:15:11.427", "lastModified": "2022-02-04T16:38:05.740", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nimforum is a lightweight alternative to Discourse written in Nim. In versions prior to 2.2.0 any forum user can create a new thread/post with an include referencing a file local to the host operating system. Nimforum will render the file if able. This can also be done silently by using NimForum's post \"preview\" endpoint. Even if NimForum is running as a non-critical user, the forum.json secrets can be stolen. Version 2.2.0 of NimForum includes patches for this vulnerability. Users are advised to upgrade as soon as is possible. There are no known workarounds for this issue."}, {"lang": "es", "value": "Nimforum es una alternativa ligera a Discourse escrita en Nim. En versiones anteriores a 2.2.0, cualquier usuario del foro puede crear un nuevo hilo/post con un include que haga referencia a un archivo local del sistema operativo anfitri\u00f3n. Nimforum renderizar\u00e1 el archivo si es posible. Esto tambi\u00e9n puede hacerse de forma silenciosa usando el endpoint de la \"preview\" del post de NimForum. Incluso si NimForum se ejecuta como un usuario no cr\u00edtico, los secretos de forum.json pueden ser robados. La versi\u00f3n 2.2.0 de NimForum incluye parches para esta vulnerabilidad. Se recomienda a usuarios que actualicen lo antes posible. No se conocen medidas de mitigaci\u00f3n adicionales para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nim-lang:docutils:*:*:*:*:*:nim:*:*", "versionEndExcluding": "1.6.2", "matchCriteriaId": "AD8B274D-0B29-4813-A498-CC63903A1C2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nim-lang:nimforum:*:*:*:*:*:nim:*:*", "versionEndExcluding": "2.2.0", "matchCriteriaId": "FE0421BD-56F6-4822-B2F4-B7B31071BC57"}]}]}], "references": [{"url": "https://github.com/nim-lang/Nim/commit/cb894c7094fb49014f85815a9dafc38b5dda743e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nim-lang/nimforum/security/advisories/GHSA-q3vh-x957-wr75", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nim-lang/Nim/commit/cb894c7094fb49014f85815a9dafc38b5dda743e"}}