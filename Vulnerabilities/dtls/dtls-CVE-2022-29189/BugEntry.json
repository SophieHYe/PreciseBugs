{"buggy_code": ["package dtls\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/pion/dtls/v2/pkg/protocol\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/alert\"\n)\n\n// Typed errors\nvar (\n\tErrConnClosed = &FatalError{Err: errors.New(\"conn is closed\")} //nolint:goerr113\n\n\terrDeadlineExceeded   = &TimeoutError{Err: fmt.Errorf(\"read/write timeout: %w\", context.DeadlineExceeded)}\n\terrInvalidContentType = &TemporaryError{Err: errors.New(\"invalid content type\")} //nolint:goerr113\n\n\terrBufferTooSmall               = &TemporaryError{Err: errors.New(\"buffer is too small\")}                                        //nolint:goerr113\n\terrContextUnsupported           = &TemporaryError{Err: errors.New(\"context is not supported for ExportKeyingMaterial\")}          //nolint:goerr113\n\terrHandshakeInProgress          = &TemporaryError{Err: errors.New(\"handshake is in progress\")}                                   //nolint:goerr113\n\terrReservedExportKeyingMaterial = &TemporaryError{Err: errors.New(\"ExportKeyingMaterial can not be used with a reserved label\")} //nolint:goerr113\n\terrApplicationDataEpochZero     = &TemporaryError{Err: errors.New(\"ApplicationData with epoch of 0\")}                            //nolint:goerr113\n\terrUnhandledContextType         = &TemporaryError{Err: errors.New(\"unhandled contentType\")}                                      //nolint:goerr113\n\n\terrCertificateVerifyNoCertificate    = &FatalError{Err: errors.New(\"client sent certificate verify but we have no certificate to verify\")}                      //nolint:goerr113\n\terrCipherSuiteNoIntersection         = &FatalError{Err: errors.New(\"client+server do not support any shared cipher suites\")}                                    //nolint:goerr113\n\terrClientCertificateNotVerified      = &FatalError{Err: errors.New(\"client sent certificate but did not verify it\")}                                            //nolint:goerr113\n\terrClientCertificateRequired         = &FatalError{Err: errors.New(\"server required client verification, but got none\")}                                        //nolint:goerr113\n\terrClientNoMatchingSRTPProfile       = &FatalError{Err: errors.New(\"server responded with SRTP Profile we do not support\")}                                     //nolint:goerr113\n\terrClientRequiredButNoServerEMS      = &FatalError{Err: errors.New(\"client required Extended Master Secret extension, but server does not support it\")}         //nolint:goerr113\n\terrCookieMismatch                    = &FatalError{Err: errors.New(\"client+server cookie does not match\")}                                                      //nolint:goerr113\n\terrIdentityNoPSK                     = &FatalError{Err: errors.New(\"PSK Identity Hint provided but PSK is nil\")}                                                //nolint:goerr113\n\terrInvalidCertificate                = &FatalError{Err: errors.New(\"no certificate provided\")}                                                                  //nolint:goerr113\n\terrInvalidCipherSuite                = &FatalError{Err: errors.New(\"invalid or unknown cipher suite\")}                                                          //nolint:goerr113\n\terrInvalidECDSASignature             = &FatalError{Err: errors.New(\"ECDSA signature contained zero or negative values\")}                                        //nolint:goerr113\n\terrInvalidPrivateKey                 = &FatalError{Err: errors.New(\"invalid private key type\")}                                                                 //nolint:goerr113\n\terrInvalidSignatureAlgorithm         = &FatalError{Err: errors.New(\"invalid signature algorithm\")}                                                              //nolint:goerr113\n\terrKeySignatureMismatch              = &FatalError{Err: errors.New(\"expected and actual key signature do not match\")}                                           //nolint:goerr113\n\terrNilNextConn                       = &FatalError{Err: errors.New(\"Conn can not be created with a nil nextConn\")}                                              //nolint:goerr113\n\terrNoAvailableCipherSuites           = &FatalError{Err: errors.New(\"connection can not be created, no CipherSuites satisfy this Config\")}                       //nolint:goerr113\n\terrNoAvailablePSKCipherSuite         = &FatalError{Err: errors.New(\"connection can not be created, pre-shared key present but no compatible CipherSuite\")}      //nolint:goerr113\n\terrNoAvailableCertificateCipherSuite = &FatalError{Err: errors.New(\"connection can not be created, certificate present but no compatible CipherSuite\")}         //nolint:goerr113\n\terrNoAvailableSignatureSchemes       = &FatalError{Err: errors.New(\"connection can not be created, no SignatureScheme satisfy this Config\")}                    //nolint:goerr113\n\terrNoCertificates                    = &FatalError{Err: errors.New(\"no certificates configured\")}                                                               //nolint:goerr113\n\terrNoConfigProvided                  = &FatalError{Err: errors.New(\"no config provided\")}                                                                       //nolint:goerr113\n\terrNoSupportedEllipticCurves         = &FatalError{Err: errors.New(\"client requested zero or more elliptic curves that are not supported by the server\")}       //nolint:goerr113\n\terrUnsupportedProtocolVersion        = &FatalError{Err: errors.New(\"unsupported protocol version\")}                                                             //nolint:goerr113\n\terrPSKAndIdentityMustBeSetForClient  = &FatalError{Err: errors.New(\"PSK and PSK Identity Hint must both be set for client\")}                                    //nolint:goerr113\n\terrRequestedButNoSRTPExtension       = &FatalError{Err: errors.New(\"SRTP support was requested but server did not respond with use_srtp extension\")}            //nolint:goerr113\n\terrServerNoMatchingSRTPProfile       = &FatalError{Err: errors.New(\"client requested SRTP but we have no matching profiles\")}                                   //nolint:goerr113\n\terrServerRequiredButNoClientEMS      = &FatalError{Err: errors.New(\"server requires the Extended Master Secret extension, but the client does not support it\")} //nolint:goerr113\n\terrVerifyDataMismatch                = &FatalError{Err: errors.New(\"expected and actual verify data does not match\")}                                           //nolint:goerr113\n\n\terrInvalidFlight                     = &InternalError{Err: errors.New(\"invalid flight number\")}                           //nolint:goerr113\n\terrKeySignatureGenerateUnimplemented = &InternalError{Err: errors.New(\"unable to generate key signature, unimplemented\")} //nolint:goerr113\n\terrKeySignatureVerifyUnimplemented   = &InternalError{Err: errors.New(\"unable to verify key signature, unimplemented\")}   //nolint:goerr113\n\terrLengthMismatch                    = &InternalError{Err: errors.New(\"data length and declared length do not match\")}    //nolint:goerr113\n\terrSequenceNumberOverflow            = &InternalError{Err: errors.New(\"sequence number overflow\")}                        //nolint:goerr113\n\terrInvalidFSMTransition              = &InternalError{Err: errors.New(\"invalid state machine transition\")}                //nolint:goerr113\n\terrFailedToAccessPoolReadBuffer      = &InternalError{Err: errors.New(\"failed to access pool read buffer\")}               //nolint:goerr113\n)\n\n// FatalError indicates that the DTLS connection is no longer available.\n// It is mainly caused by wrong configuration of server or client.\ntype FatalError = protocol.FatalError\n\n// InternalError indicates and internal error caused by the implementation, and the DTLS connection is no longer available.\n// It is mainly caused by bugs or tried to use unimplemented features.\ntype InternalError = protocol.InternalError\n\n// TemporaryError indicates that the DTLS connection is still available, but the request was failed temporary.\ntype TemporaryError = protocol.TemporaryError\n\n// TimeoutError indicates that the request was timed out.\ntype TimeoutError = protocol.TimeoutError\n\n// HandshakeError indicates that the handshake failed.\ntype HandshakeError = protocol.HandshakeError\n\n// errInvalidCipherSuite indicates an attempt at using an unsupported cipher suite.\ntype invalidCipherSuiteError struct {\n\tid CipherSuiteID\n}\n\nfunc (e *invalidCipherSuiteError) Error() string {\n\treturn fmt.Sprintf(\"CipherSuite with id(%d) is not valid\", e.id)\n}\n\nfunc (e *invalidCipherSuiteError) Is(err error) bool {\n\tvar other *invalidCipherSuiteError\n\tif errors.As(err, &other) {\n\t\treturn e.id == other.id\n\t}\n\treturn false\n}\n\n// errAlert wraps DTLS alert notification as an error\ntype alertError struct {\n\t*alert.Alert\n}\n\nfunc (e *alertError) Error() string {\n\treturn fmt.Sprintf(\"alert: %s\", e.Alert.String())\n}\n\nfunc (e *alertError) IsFatalOrCloseNotify() bool {\n\treturn e.Level == alert.Fatal || e.Description == alert.CloseNotify\n}\n\nfunc (e *alertError) Is(err error) bool {\n\tvar other *alertError\n\tif errors.As(err, &other) {\n\t\treturn e.Level == other.Level && e.Description == other.Description\n\t}\n\treturn false\n}\n\n// netError translates an error from underlying Conn to corresponding net.Error.\nfunc netError(err error) error {\n\tswitch {\n\tcase errors.Is(err, io.EOF), errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):\n\t\t// Return io.EOF and context errors as is.\n\t\treturn err\n\t}\n\n\tvar (\n\t\tne      net.Error\n\t\topError *net.OpError\n\t\tse      *os.SyscallError\n\t)\n\n\tif errors.As(err, &opError) {\n\t\tif errors.As(opError, &se) {\n\t\t\tif se.Timeout() {\n\t\t\t\treturn &TimeoutError{Err: err}\n\t\t\t}\n\t\t\tif isOpErrorTemporary(se) {\n\t\t\t\treturn &TemporaryError{Err: err}\n\t\t\t}\n\t\t}\n\t}\n\n\tif errors.As(err, &ne) {\n\t\treturn err\n\t}\n\n\treturn &FatalError{Err: err}\n}\n", "package dtls\n\nimport (\n\t\"github.com/pion/dtls/v2/pkg/protocol\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/handshake\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/recordlayer\"\n)\n\ntype fragment struct {\n\trecordLayerHeader recordlayer.Header\n\thandshakeHeader   handshake.Header\n\tdata              []byte\n}\n\ntype fragmentBuffer struct {\n\t// map of MessageSequenceNumbers that hold slices of fragments\n\tcache map[uint16][]*fragment\n\n\tcurrentMessageSequenceNumber uint16\n}\n\nfunc newFragmentBuffer() *fragmentBuffer {\n\treturn &fragmentBuffer{cache: map[uint16][]*fragment{}}\n}\n\n// Attempts to push a DTLS packet to the fragmentBuffer\n// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled\n// when an error returns it is fatal, and the DTLS connection should be stopped\nfunc (f *fragmentBuffer) push(buf []byte) (bool, error) {\n\tfrag := new(fragment)\n\tif err := frag.recordLayerHeader.Unmarshal(buf); err != nil {\n\t\treturn false, err\n\t}\n\n\t// fragment isn't a handshake, we don't need to handle it\n\tif frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {\n\t\treturn false, nil\n\t}\n\n\tfor buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {\n\t\tif err := frag.handshakeHeader.Unmarshal(buf); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {\n\t\t\tf.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}\n\t\t}\n\n\t\t// end index should be the length of handshake header but if the handshake\n\t\t// was fragmented, we should keep them all\n\t\tend := int(handshake.HeaderLength + frag.handshakeHeader.Length)\n\t\tif size := len(buf); end > size {\n\t\t\tend = size\n\t\t}\n\n\t\t// Discard all headers, when rebuilding the packet we will re-build\n\t\tfrag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)\n\t\tf.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)\n\t\tbuf = buf[end:]\n\t}\n\n\treturn true, nil\n}\n\nfunc (f *fragmentBuffer) pop() (content []byte, epoch uint16) {\n\tfrags, ok := f.cache[f.currentMessageSequenceNumber]\n\tif !ok {\n\t\treturn nil, 0\n\t}\n\n\t// Go doesn't support recursive lambdas\n\tvar appendMessage func(targetOffset uint32) bool\n\n\trawMessage := []byte{}\n\tappendMessage = func(targetOffset uint32) bool {\n\t\tfor _, f := range frags {\n\t\t\tif f.handshakeHeader.FragmentOffset == targetOffset {\n\t\t\t\tfragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)\n\t\t\t\tif fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {\n\t\t\t\t\tif !appendMessage(fragmentEnd) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trawMessage = append(f.data, rawMessage...)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\t// Recursively collect up\n\tif !appendMessage(0) {\n\t\treturn nil, 0\n\t}\n\n\tfirstHeader := frags[0].handshakeHeader\n\tfirstHeader.FragmentOffset = 0\n\tfirstHeader.FragmentLength = firstHeader.Length\n\n\trawHeader, err := firstHeader.Marshal()\n\tif err != nil {\n\t\treturn nil, 0\n\t}\n\n\tmessageEpoch := frags[0].recordLayerHeader.Epoch\n\n\tdelete(f.cache, f.currentMessageSequenceNumber)\n\tf.currentMessageSequenceNumber++\n\treturn append(rawHeader, rawMessage...), messageEpoch\n}\n", "package dtls\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFragmentBuffer(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tName     string\n\t\tIn       [][]byte\n\t\tExpected [][]byte\n\t\tEpoch    uint16\n\t}{\n\t\t{\n\t\t\tName: \"Single Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Single Fragment Epoch 3\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 3,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Unordered Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Handshakes in Signle Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{\n\t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t// Assert that a zero length fragment doesn't cause the fragmentBuffer to enter an infinite loop\n\t\t{\n\t\t\tName: \"Zero Length Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{\n\t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t} {\n\t\tfragmentBuffer := newFragmentBuffer()\n\t\tfor _, frag := range test.In {\n\t\t\tstatus, err := fragmentBuffer.push(frag)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t} else if !status {\n\t\t\t\tt.Errorf(\"fragmentBuffer didn't accept fragments for '%s'\", test.Name)\n\t\t\t}\n\t\t}\n\n\t\tfor _, expected := range test.Expected {\n\t\t\tout, epoch := fragmentBuffer.pop()\n\t\t\tif !reflect.DeepEqual(out, expected) {\n\t\t\t\tt.Errorf(\"fragmentBuffer '%s' push/pop: got % 02x, want % 02x\", test.Name, out, expected)\n\t\t\t}\n\t\t\tif epoch != test.Epoch {\n\t\t\t\tt.Errorf(\"fragmentBuffer returned wrong epoch: got %d, want %d\", epoch, test.Epoch)\n\t\t\t}\n\t\t}\n\n\t\tif frag, _ := fragmentBuffer.pop(); frag != nil {\n\t\t\tt.Errorf(\"fragmentBuffer popped single buffer multiple times for '%s'\", test.Name)\n\t\t}\n\t}\n}\n"], "fixing_code": ["package dtls\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/pion/dtls/v2/pkg/protocol\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/alert\"\n)\n\n// Typed errors\nvar (\n\tErrConnClosed = &FatalError{Err: errors.New(\"conn is closed\")} //nolint:goerr113\n\n\terrDeadlineExceeded   = &TimeoutError{Err: fmt.Errorf(\"read/write timeout: %w\", context.DeadlineExceeded)}\n\terrInvalidContentType = &TemporaryError{Err: errors.New(\"invalid content type\")} //nolint:goerr113\n\n\terrBufferTooSmall               = &TemporaryError{Err: errors.New(\"buffer is too small\")}                                        //nolint:goerr113\n\terrContextUnsupported           = &TemporaryError{Err: errors.New(\"context is not supported for ExportKeyingMaterial\")}          //nolint:goerr113\n\terrHandshakeInProgress          = &TemporaryError{Err: errors.New(\"handshake is in progress\")}                                   //nolint:goerr113\n\terrReservedExportKeyingMaterial = &TemporaryError{Err: errors.New(\"ExportKeyingMaterial can not be used with a reserved label\")} //nolint:goerr113\n\terrApplicationDataEpochZero     = &TemporaryError{Err: errors.New(\"ApplicationData with epoch of 0\")}                            //nolint:goerr113\n\terrUnhandledContextType         = &TemporaryError{Err: errors.New(\"unhandled contentType\")}                                      //nolint:goerr113\n\n\terrCertificateVerifyNoCertificate    = &FatalError{Err: errors.New(\"client sent certificate verify but we have no certificate to verify\")}                      //nolint:goerr113\n\terrCipherSuiteNoIntersection         = &FatalError{Err: errors.New(\"client+server do not support any shared cipher suites\")}                                    //nolint:goerr113\n\terrClientCertificateNotVerified      = &FatalError{Err: errors.New(\"client sent certificate but did not verify it\")}                                            //nolint:goerr113\n\terrClientCertificateRequired         = &FatalError{Err: errors.New(\"server required client verification, but got none\")}                                        //nolint:goerr113\n\terrClientNoMatchingSRTPProfile       = &FatalError{Err: errors.New(\"server responded with SRTP Profile we do not support\")}                                     //nolint:goerr113\n\terrClientRequiredButNoServerEMS      = &FatalError{Err: errors.New(\"client required Extended Master Secret extension, but server does not support it\")}         //nolint:goerr113\n\terrCookieMismatch                    = &FatalError{Err: errors.New(\"client+server cookie does not match\")}                                                      //nolint:goerr113\n\terrIdentityNoPSK                     = &FatalError{Err: errors.New(\"PSK Identity Hint provided but PSK is nil\")}                                                //nolint:goerr113\n\terrInvalidCertificate                = &FatalError{Err: errors.New(\"no certificate provided\")}                                                                  //nolint:goerr113\n\terrInvalidCipherSuite                = &FatalError{Err: errors.New(\"invalid or unknown cipher suite\")}                                                          //nolint:goerr113\n\terrInvalidECDSASignature             = &FatalError{Err: errors.New(\"ECDSA signature contained zero or negative values\")}                                        //nolint:goerr113\n\terrInvalidPrivateKey                 = &FatalError{Err: errors.New(\"invalid private key type\")}                                                                 //nolint:goerr113\n\terrInvalidSignatureAlgorithm         = &FatalError{Err: errors.New(\"invalid signature algorithm\")}                                                              //nolint:goerr113\n\terrKeySignatureMismatch              = &FatalError{Err: errors.New(\"expected and actual key signature do not match\")}                                           //nolint:goerr113\n\terrNilNextConn                       = &FatalError{Err: errors.New(\"Conn can not be created with a nil nextConn\")}                                              //nolint:goerr113\n\terrNoAvailableCipherSuites           = &FatalError{Err: errors.New(\"connection can not be created, no CipherSuites satisfy this Config\")}                       //nolint:goerr113\n\terrNoAvailablePSKCipherSuite         = &FatalError{Err: errors.New(\"connection can not be created, pre-shared key present but no compatible CipherSuite\")}      //nolint:goerr113\n\terrNoAvailableCertificateCipherSuite = &FatalError{Err: errors.New(\"connection can not be created, certificate present but no compatible CipherSuite\")}         //nolint:goerr113\n\terrNoAvailableSignatureSchemes       = &FatalError{Err: errors.New(\"connection can not be created, no SignatureScheme satisfy this Config\")}                    //nolint:goerr113\n\terrNoCertificates                    = &FatalError{Err: errors.New(\"no certificates configured\")}                                                               //nolint:goerr113\n\terrNoConfigProvided                  = &FatalError{Err: errors.New(\"no config provided\")}                                                                       //nolint:goerr113\n\terrNoSupportedEllipticCurves         = &FatalError{Err: errors.New(\"client requested zero or more elliptic curves that are not supported by the server\")}       //nolint:goerr113\n\terrUnsupportedProtocolVersion        = &FatalError{Err: errors.New(\"unsupported protocol version\")}                                                             //nolint:goerr113\n\terrPSKAndIdentityMustBeSetForClient  = &FatalError{Err: errors.New(\"PSK and PSK Identity Hint must both be set for client\")}                                    //nolint:goerr113\n\terrRequestedButNoSRTPExtension       = &FatalError{Err: errors.New(\"SRTP support was requested but server did not respond with use_srtp extension\")}            //nolint:goerr113\n\terrServerNoMatchingSRTPProfile       = &FatalError{Err: errors.New(\"client requested SRTP but we have no matching profiles\")}                                   //nolint:goerr113\n\terrServerRequiredButNoClientEMS      = &FatalError{Err: errors.New(\"server requires the Extended Master Secret extension, but the client does not support it\")} //nolint:goerr113\n\terrVerifyDataMismatch                = &FatalError{Err: errors.New(\"expected and actual verify data does not match\")}                                           //nolint:goerr113\n\n\terrInvalidFlight                     = &InternalError{Err: errors.New(\"invalid flight number\")}                           //nolint:goerr113\n\terrKeySignatureGenerateUnimplemented = &InternalError{Err: errors.New(\"unable to generate key signature, unimplemented\")} //nolint:goerr113\n\terrKeySignatureVerifyUnimplemented   = &InternalError{Err: errors.New(\"unable to verify key signature, unimplemented\")}   //nolint:goerr113\n\terrLengthMismatch                    = &InternalError{Err: errors.New(\"data length and declared length do not match\")}    //nolint:goerr113\n\terrSequenceNumberOverflow            = &InternalError{Err: errors.New(\"sequence number overflow\")}                        //nolint:goerr113\n\terrInvalidFSMTransition              = &InternalError{Err: errors.New(\"invalid state machine transition\")}                //nolint:goerr113\n\terrFailedToAccessPoolReadBuffer      = &InternalError{Err: errors.New(\"failed to access pool read buffer\")}               //nolint:goerr113\n\terrFragmentBufferOverflow            = &InternalError{Err: errors.New(\"fragment buffer overflow\")}                        //nolint:goerr113\n)\n\n// FatalError indicates that the DTLS connection is no longer available.\n// It is mainly caused by wrong configuration of server or client.\ntype FatalError = protocol.FatalError\n\n// InternalError indicates and internal error caused by the implementation, and the DTLS connection is no longer available.\n// It is mainly caused by bugs or tried to use unimplemented features.\ntype InternalError = protocol.InternalError\n\n// TemporaryError indicates that the DTLS connection is still available, but the request was failed temporary.\ntype TemporaryError = protocol.TemporaryError\n\n// TimeoutError indicates that the request was timed out.\ntype TimeoutError = protocol.TimeoutError\n\n// HandshakeError indicates that the handshake failed.\ntype HandshakeError = protocol.HandshakeError\n\n// errInvalidCipherSuite indicates an attempt at using an unsupported cipher suite.\ntype invalidCipherSuiteError struct {\n\tid CipherSuiteID\n}\n\nfunc (e *invalidCipherSuiteError) Error() string {\n\treturn fmt.Sprintf(\"CipherSuite with id(%d) is not valid\", e.id)\n}\n\nfunc (e *invalidCipherSuiteError) Is(err error) bool {\n\tvar other *invalidCipherSuiteError\n\tif errors.As(err, &other) {\n\t\treturn e.id == other.id\n\t}\n\treturn false\n}\n\n// errAlert wraps DTLS alert notification as an error\ntype alertError struct {\n\t*alert.Alert\n}\n\nfunc (e *alertError) Error() string {\n\treturn fmt.Sprintf(\"alert: %s\", e.Alert.String())\n}\n\nfunc (e *alertError) IsFatalOrCloseNotify() bool {\n\treturn e.Level == alert.Fatal || e.Description == alert.CloseNotify\n}\n\nfunc (e *alertError) Is(err error) bool {\n\tvar other *alertError\n\tif errors.As(err, &other) {\n\t\treturn e.Level == other.Level && e.Description == other.Description\n\t}\n\treturn false\n}\n\n// netError translates an error from underlying Conn to corresponding net.Error.\nfunc netError(err error) error {\n\tswitch {\n\tcase errors.Is(err, io.EOF), errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):\n\t\t// Return io.EOF and context errors as is.\n\t\treturn err\n\t}\n\n\tvar (\n\t\tne      net.Error\n\t\topError *net.OpError\n\t\tse      *os.SyscallError\n\t)\n\n\tif errors.As(err, &opError) {\n\t\tif errors.As(opError, &se) {\n\t\t\tif se.Timeout() {\n\t\t\t\treturn &TimeoutError{Err: err}\n\t\t\t}\n\t\t\tif isOpErrorTemporary(se) {\n\t\t\t\treturn &TemporaryError{Err: err}\n\t\t\t}\n\t\t}\n\t}\n\n\tif errors.As(err, &ne) {\n\t\treturn err\n\t}\n\n\treturn &FatalError{Err: err}\n}\n", "package dtls\n\nimport (\n\t\"github.com/pion/dtls/v2/pkg/protocol\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/handshake\"\n\t\"github.com/pion/dtls/v2/pkg/protocol/recordlayer\"\n)\n\n// 2 megabytes\nconst fragmentBufferMaxSize = 2000000\n\ntype fragment struct {\n\trecordLayerHeader recordlayer.Header\n\thandshakeHeader   handshake.Header\n\tdata              []byte\n}\n\ntype fragmentBuffer struct {\n\t// map of MessageSequenceNumbers that hold slices of fragments\n\tcache map[uint16][]*fragment\n\n\tcurrentMessageSequenceNumber uint16\n}\n\nfunc newFragmentBuffer() *fragmentBuffer {\n\treturn &fragmentBuffer{cache: map[uint16][]*fragment{}}\n}\n\n// current total size of buffer\nfunc (f *fragmentBuffer) size() int {\n\tsize := 0\n\tfor i := range f.cache {\n\t\tfor j := range f.cache[i] {\n\t\t\tsize += len(f.cache[i][j].data)\n\t\t}\n\t}\n\treturn size\n}\n\n// Attempts to push a DTLS packet to the fragmentBuffer\n// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled\n// when an error returns it is fatal, and the DTLS connection should be stopped\nfunc (f *fragmentBuffer) push(buf []byte) (bool, error) {\n\tif f.size()+len(buf) >= fragmentBufferMaxSize {\n\t\treturn false, errFragmentBufferOverflow\n\t}\n\n\tfrag := new(fragment)\n\tif err := frag.recordLayerHeader.Unmarshal(buf); err != nil {\n\t\treturn false, err\n\t}\n\n\t// fragment isn't a handshake, we don't need to handle it\n\tif frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {\n\t\treturn false, nil\n\t}\n\n\tfor buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {\n\t\tif err := frag.handshakeHeader.Unmarshal(buf); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {\n\t\t\tf.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}\n\t\t}\n\n\t\t// end index should be the length of handshake header but if the handshake\n\t\t// was fragmented, we should keep them all\n\t\tend := int(handshake.HeaderLength + frag.handshakeHeader.Length)\n\t\tif size := len(buf); end > size {\n\t\t\tend = size\n\t\t}\n\n\t\t// Discard all headers, when rebuilding the packet we will re-build\n\t\tfrag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)\n\t\tf.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)\n\t\tbuf = buf[end:]\n\t}\n\n\treturn true, nil\n}\n\nfunc (f *fragmentBuffer) pop() (content []byte, epoch uint16) {\n\tfrags, ok := f.cache[f.currentMessageSequenceNumber]\n\tif !ok {\n\t\treturn nil, 0\n\t}\n\n\t// Go doesn't support recursive lambdas\n\tvar appendMessage func(targetOffset uint32) bool\n\n\trawMessage := []byte{}\n\tappendMessage = func(targetOffset uint32) bool {\n\t\tfor _, f := range frags {\n\t\t\tif f.handshakeHeader.FragmentOffset == targetOffset {\n\t\t\t\tfragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)\n\t\t\t\tif fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {\n\t\t\t\t\tif !appendMessage(fragmentEnd) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trawMessage = append(f.data, rawMessage...)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\t// Recursively collect up\n\tif !appendMessage(0) {\n\t\treturn nil, 0\n\t}\n\n\tfirstHeader := frags[0].handshakeHeader\n\tfirstHeader.FragmentOffset = 0\n\tfirstHeader.FragmentLength = firstHeader.Length\n\n\trawHeader, err := firstHeader.Marshal()\n\tif err != nil {\n\t\treturn nil, 0\n\t}\n\n\tmessageEpoch := frags[0].recordLayerHeader.Epoch\n\n\tdelete(f.cache, f.currentMessageSequenceNumber)\n\tf.currentMessageSequenceNumber++\n\treturn append(rawHeader, rawMessage...), messageEpoch\n}\n", "package dtls\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFragmentBuffer(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tName     string\n\t\tIn       [][]byte\n\t\tExpected [][]byte\n\t\tEpoch    uint16\n\t}{\n\t\t{\n\t\t\tName: \"Single Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Single Fragment Epoch 3\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},\n\t\t\t},\n\t\t\tEpoch: 3,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Unordered Fragments\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},\n\t\t\t\t{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t{\n\t\t\tName: \"Multiple Handshakes in Single Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{\n\t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/\n\t\t\t\t\t0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t\t{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t\t// Assert that a zero length fragment doesn't cause the fragmentBuffer to enter an infinite loop\n\t\t{\n\t\t\tName: \"Zero Length Fragment\",\n\t\t\tIn: [][]byte{\n\t\t\t\t{\n\t\t\t\t\t0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: [][]byte{\n\t\t\t\t{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},\n\t\t\t},\n\t\t\tEpoch: 0,\n\t\t},\n\t} {\n\t\tfragmentBuffer := newFragmentBuffer()\n\t\tfor _, frag := range test.In {\n\t\t\tstatus, err := fragmentBuffer.push(frag)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t} else if !status {\n\t\t\t\tt.Errorf(\"fragmentBuffer didn't accept fragments for '%s'\", test.Name)\n\t\t\t}\n\t\t}\n\n\t\tfor _, expected := range test.Expected {\n\t\t\tout, epoch := fragmentBuffer.pop()\n\t\t\tif !reflect.DeepEqual(out, expected) {\n\t\t\t\tt.Errorf(\"fragmentBuffer '%s' push/pop: got % 02x, want % 02x\", test.Name, out, expected)\n\t\t\t}\n\t\t\tif epoch != test.Epoch {\n\t\t\t\tt.Errorf(\"fragmentBuffer returned wrong epoch: got %d, want %d\", epoch, test.Epoch)\n\t\t\t}\n\t\t}\n\n\t\tif frag, _ := fragmentBuffer.pop(); frag != nil {\n\t\t\tt.Errorf(\"fragmentBuffer popped single buffer multiple times for '%s'\", test.Name)\n\t\t}\n\t}\n}\n\nfunc TestFragmentBuffer_Overflow(t *testing.T) {\n\tfragmentBuffer := newFragmentBuffer()\n\n\t// Push a buffer that doesn't exceed size limits\n\tif _, err := fragmentBuffer.push([]byte{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Allocate a buffer that exceeds cache size\n\tlargeBuffer := make([]byte, fragmentBufferMaxSize)\n\tif _, err := fragmentBuffer.push(largeBuffer); !errors.Is(err, errFragmentBufferOverflow) {\n\t\tt.Fatalf(\"Pushing a large buffer returned (%s) expected(%s)\", err, errFragmentBufferOverflow)\n\t}\n}\n"], "buggy_code_start_loc": [64, 7, 3], "buggy_code_end_loc": [64, 29, 115], "fixing_code_start_loc": [65, 8, 4], "fixing_code_end_loc": [66, 48, 132], "type": "CWE-120", "message": "Pion DTLS is a Go implementation of Datagram Transport Layer Security. Prior to version 2.1.4, a buffer that was used for inbound network traffic had no upper limit. Pion DTLS would buffer all network traffic from the remote user until the handshake completes or timed out. An attacker could exploit this to cause excessive memory usage. Version 2.1.4 contains a patch for this issue. There are currently no known workarounds available.", "other": {"cve": {"id": "CVE-2022-29189", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-21T00:15:11.387", "lastModified": "2022-06-03T01:59:05.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pion DTLS is a Go implementation of Datagram Transport Layer Security. Prior to version 2.1.4, a buffer that was used for inbound network traffic had no upper limit. Pion DTLS would buffer all network traffic from the remote user until the handshake completes or timed out. An attacker could exploit this to cause excessive memory usage. Version 2.1.4 contains a patch for this issue. There are currently no known workarounds available."}, {"lang": "es", "value": "Pion DTLS es una implementaci\u00f3n Go de la Seguridad de la Capa de Transporte de Datagramas. En versiones anteriores a 2.1.4, un b\u00fafer que era usado para el tr\u00e1fico de red entrante no ten\u00eda l\u00edmite superior. Pion DTLS almacenaba en el b\u00fafer todo el tr\u00e1fico de red procedente del usuario remoto hasta que era completado el handshake o era agotado el tiempo. Un atacante podr\u00eda aprovechar esto para causar un uso excesivo de la memoria. La versi\u00f3n 2.1.4 contiene un parche para este problema. Actualmente no se conocen mitigaciones disponibles"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pion:dtls:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "465946B5-0540-41EB-91CB-571B2E842EB4"}]}]}], "references": [{"url": "https://github.com/pion/dtls/commit/a6397ff7282bc56dc37a68ea9211702edb4de1de", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pion/dtls/releases/tag/v2.1.4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/pion/dtls/security/advisories/GHSA-cx94-mrg9-rq4j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pion/dtls/commit/a6397ff7282bc56dc37a68ea9211702edb4de1de"}}