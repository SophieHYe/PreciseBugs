{"buggy_code": ["<?php\n/**\n * AttachmentHelper.php\n * Copyright (c) 2019 james@firefly-iii.org\n *\n * This file is part of Firefly III (https://github.com/firefly-iii).\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\ndeclare(strict_types=1);\n\nnamespace FireflyIII\\Helpers\\Attachments;\n\nuse Crypt;\nuse FireflyIII\\Exceptions\\FireflyException;\nuse FireflyIII\\Models\\Attachment;\nuse FireflyIII\\Models\\PiggyBank;\nuse Illuminate\\Contracts\\Encryption\\DecryptException;\nuse Illuminate\\Contracts\\Encryption\\EncryptException;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Illuminate\\Support\\MessageBag;\nuse Log;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\n/**\n * Class AttachmentHelper.\n */\nclass AttachmentHelper implements AttachmentHelperInterface\n{\n    public Collection $attachments;\n    public MessageBag $errors;\n    public MessageBag $messages;\n    protected array   $allowedMimes  = [];\n    protected int     $maxUploadSize = 0;\n\n    /** @var Filesystem The disk where attachments are stored. */\n    protected $uploadDisk;\n\n    /**\n     * AttachmentHelper constructor.\n     *\n     * @codeCoverageIgnore\n     */\n    public function __construct()\n    {\n        $this->maxUploadSize = (int)config('firefly.maxUploadSize');\n        $this->allowedMimes  = (array)config('firefly.allowedMimes');\n        $this->errors        = new MessageBag;\n        $this->messages      = new MessageBag;\n        $this->attachments   = new Collection;\n        $this->uploadDisk    = Storage::disk('upload');\n    }\n\n    /**\n     * Returns the content of an attachment.\n     *\n     * @codeCoverageIgnore\n     *\n     * @param Attachment $attachment\n     *\n     * @return string\n     */\n    public function getAttachmentContent(Attachment $attachment): string\n    {\n        $encryptedData = '';\n        try {\n            $encryptedData = $this->uploadDisk->get(sprintf('at-%d.data', $attachment->id));\n        } catch (FileNotFoundException $e) {\n            Log::error($e->getMessage());\n        }\n        try {\n            $unencryptedData = Crypt::decrypt($encryptedData); // verified\n        } catch (DecryptException | FileNotFoundException $e) {\n            Log::error(sprintf('Could not decrypt data of attachment #%d: %s', $attachment->id, $e->getMessage()));\n            $unencryptedData = $encryptedData;\n        }\n\n        return $unencryptedData;\n    }\n\n    /**\n     * Returns the file path relative to upload disk for an attachment,\n     *\n     * @param Attachment $attachment\n     *\n     * @codeCoverageIgnore\n     * @return string\n     */\n    public function getAttachmentLocation(Attachment $attachment): string\n    {\n        return sprintf('%sat-%d.data', DIRECTORY_SEPARATOR, (int)$attachment->id);\n    }\n\n    /**\n     * Get all attachments.\n     *\n     * @codeCoverageIgnore\n     * @return Collection\n     */\n    public function getAttachments(): Collection\n    {\n        return $this->attachments;\n    }\n\n    /**\n     * Get all errors.\n     *\n     * @return MessageBag\n     * @codeCoverageIgnore\n     */\n    public function getErrors(): MessageBag\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get all messages.\n     *\n     * @return MessageBag\n     * @codeCoverageIgnore\n     */\n    public function getMessages(): MessageBag\n    {\n        return $this->messages;\n    }\n\n    /**\n     * Uploads a file as a string.\n     *\n     * @param Attachment $attachment\n     * @param string     $content\n     *\n     * @return bool\n     */\n    public function saveAttachmentFromApi(Attachment $attachment, string $content): bool\n    {\n        $resource = tmpfile();\n        if (false === $resource) {\n\n            Log::error('Cannot create temp-file for file upload.');\n\n            return false;\n\n        }\n\n        if ('' === $content) {\n            Log::error('Cannot upload empty file.');\n\n            return false;\n        }\n\n        $path = stream_get_meta_data($resource)['uri'];\n        fwrite($resource, $content);\n        $finfo       = finfo_open(FILEINFO_MIME_TYPE);\n        $mime        = finfo_file($finfo, $path);\n        $allowedMime = config('firefly.allowedMimes');\n        if (!in_array($mime, $allowedMime, true)) {\n            Log::error(sprintf('Mime type %s is not allowed for API file upload.', $mime));\n\n            return false;\n        }\n        // is allowed? Save the file, without encryption.\n        $this->uploadDisk->put($attachment->fileName(), $content);\n\n        // update attachment.\n        $attachment->md5      = md5_file($path);\n        $attachment->mime     = $mime;\n        $attachment->size     = strlen($content);\n        $attachment->uploaded = true;\n        $attachment->save();\n\n        return true;\n    }\n\n    /**\n     * Save attachments that get uploaded with models, through the app.\n     *\n     * @param object     $model\n     * @param array|null $files\n     *\n     * @return bool\n     * @throws FireflyException\n     */\n    public function saveAttachmentsForModel(object $model, ?array $files): bool\n    {\n        if (!($model instanceof Model)) {\n            return false;\n        }\n\n        Log::debug(sprintf('Now in saveAttachmentsForModel for model %s', get_class($model)));\n        if (is_array($files)) {\n            Log::debug('$files is an array.');\n            /** @var UploadedFile $entry */\n            foreach ($files as $entry) {\n                if (null !== $entry) {\n                    $this->processFile($entry, $model);\n                }\n            }\n            Log::debug('Done processing uploads.');\n        }\n        if (!is_array($files)) {\n            Log::debug('Array of files is not an array. Probably nothing uploaded. Will not store attachments.');\n        }\n\n        return true;\n    }\n\n    /**\n     * Process the upload of a file.\n     *\n     * @param UploadedFile $file\n     * @param Model        $model\n     *\n     * @return Attachment|null\n     * @throws FireflyException\n     * @throws EncryptException\n     */\n    protected function processFile(UploadedFile $file, Model $model): ?Attachment\n    {\n        Log::debug('Now in processFile()');\n        $validation = $this->validateUpload($file, $model);\n        $attachment = null;\n        if (false !== $validation) {\n            $class = get_class($model);\n            $user  = $model->user;\n            if (PiggyBank::class === $class) {\n                $user = $model->account->user;\n            }\n\n            $attachment = new Attachment; // create Attachment object.\n            $attachment->user()->associate($user);\n            $attachment->attachable()->associate($model);\n            $attachment->md5      = md5_file($file->getRealPath());\n            $attachment->filename = $file->getClientOriginalName();\n            $attachment->mime     = $file->getMimeType();\n            $attachment->size     = $file->getSize();\n            $attachment->uploaded = false;\n            $attachment->save();\n            Log::debug('Created attachment:', $attachment->toArray());\n\n            $fileObject = $file->openFile();\n            $fileObject->rewind();\n\n            if (0 === $file->getSize()) {\n                throw new FireflyException('Cannot upload empty or non-existent file.');\n            }\n\n            $content = $fileObject->fread($file->getSize());\n            Log::debug(sprintf('Full file length is %d and upload size is %d.', strlen($content), $file->getSize()));\n\n            // store it without encryption.\n            $this->uploadDisk->put($attachment->fileName(), $content);\n            $attachment->uploaded = true; // update attachment\n            $attachment->save();\n            $this->attachments->push($attachment);\n\n            $name = e($file->getClientOriginalName()); // add message:\n            $msg  = (string)trans('validation.file_attached', ['name' => $name]);\n            $this->messages->add('attachments', $msg);\n        }\n\n        return $attachment;\n    }\n\n    /**\n     * Verify if the file was uploaded correctly.\n     *\n     * @param UploadedFile $file\n     * @param Model        $model\n     *\n     * @return bool\n     */\n    protected function validateUpload(UploadedFile $file, Model $model): bool\n    {\n        Log::debug('Now in validateUpload()');\n        $result = true;\n        if (!$this->validMime($file)) {\n            $result = false;\n        }\n        if (0 === $file->getSize()) {\n            Log::error('Cannot upload empty file.');\n            $result = false;\n        }\n\n\n        // can't seem to reach this point.\n        if (true === $result && !$this->validSize($file)) {\n            $result = false;\n        }\n\n        if (true === $result && $this->hasFile($file, $model)) {\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Verify if the mime of a file is valid.\n     *\n     * @param UploadedFile $file\n     *\n     * @return bool\n     */\n    protected function validMime(UploadedFile $file): bool\n    {\n        Log::debug('Now in validMime()');\n        $mime = e($file->getMimeType());\n        $name = e($file->getClientOriginalName());\n        Log::debug(sprintf('Name is %s, and mime is %s', $name, $mime));\n        Log::debug('Valid mimes are', $this->allowedMimes);\n        $result = true;\n\n        if (!in_array($mime, $this->allowedMimes, true)) {\n            $msg = (string)trans('validation.file_invalid_mime', ['name' => $name, 'mime' => $mime]);\n            $this->errors->add('attachments', $msg);\n            Log::error($msg);\n\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Verify if the size of a file is valid.\n     *\n     * @codeCoverageIgnore\n     *\n     * @param UploadedFile $file\n     *\n     * @return bool\n     */\n    protected function validSize(UploadedFile $file): bool\n    {\n        $size   = $file->getSize();\n        $name   = e($file->getClientOriginalName());\n        $result = true;\n        if ($size > $this->maxUploadSize) {\n            $msg = (string)trans('validation.file_too_large', ['name' => $name]);\n            $this->errors->add('attachments', $msg);\n            Log::error($msg);\n\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Check if a model already has this file attached.\n     *\n     * @param UploadedFile $file\n     * @param Model        $model\n     *\n     * @return bool\n     */\n    protected function hasFile(UploadedFile $file, Model $model): bool\n    {\n        $md5   = md5_file($file->getRealPath());\n        $name  = $file->getClientOriginalName();\n        $class = get_class($model);\n        $count = 0;\n        if (PiggyBank::class === $class) {\n            $count = $model->account->user->attachments()->where('md5', $md5)->where('attachable_id', $model->id)->where('attachable_type', $class)->count();\n        }\n        if (PiggyBank::class !== $class) {\n            $count = $model->user->attachments()->where('md5', $md5)->where('attachable_id', $model->id)->where('attachable_type', $class)->count();\n        }\n        $result = false;\n        if ($count > 0) {\n            $msg = (string)trans('validation.file_already_attached', ['name' => $name]);\n            $this->errors->add('attachments', $msg);\n            Log::error($msg);\n            $result = true;\n        }\n\n        return $result;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * AttachmentHelper.php\n * Copyright (c) 2019 james@firefly-iii.org\n *\n * This file is part of Firefly III (https://github.com/firefly-iii).\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\ndeclare(strict_types=1);\n\nnamespace FireflyIII\\Helpers\\Attachments;\n\nuse Crypt;\nuse FireflyIII\\Exceptions\\FireflyException;\nuse FireflyIII\\Models\\Attachment;\nuse FireflyIII\\Models\\PiggyBank;\nuse Illuminate\\Contracts\\Encryption\\DecryptException;\nuse Illuminate\\Contracts\\Encryption\\EncryptException;\nuse Illuminate\\Contracts\\Filesystem\\FileNotFoundException;\nuse Illuminate\\Contracts\\Filesystem\\Filesystem;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Illuminate\\Support\\MessageBag;\nuse Log;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\n/**\n * Class AttachmentHelper.\n */\nclass AttachmentHelper implements AttachmentHelperInterface\n{\n    public Collection $attachments;\n    public MessageBag $errors;\n    public MessageBag $messages;\n    protected array   $allowedMimes  = [];\n    protected int     $maxUploadSize = 0;\n\n    /** @var Filesystem The disk where attachments are stored. */\n    protected $uploadDisk;\n\n    /**\n     * AttachmentHelper constructor.\n     *\n     * @codeCoverageIgnore\n     */\n    public function __construct()\n    {\n        $this->maxUploadSize = (int)config('firefly.maxUploadSize');\n        $this->allowedMimes  = (array)config('firefly.allowedMimes');\n        $this->errors        = new MessageBag;\n        $this->messages      = new MessageBag;\n        $this->attachments   = new Collection;\n        $this->uploadDisk    = Storage::disk('upload');\n    }\n\n    /**\n     * Returns the content of an attachment.\n     *\n     * @codeCoverageIgnore\n     *\n     * @param Attachment $attachment\n     *\n     * @return string\n     */\n    public function getAttachmentContent(Attachment $attachment): string\n    {\n        $encryptedData = '';\n        try {\n            $encryptedData = $this->uploadDisk->get(sprintf('at-%d.data', $attachment->id));\n        } catch (FileNotFoundException $e) {\n            Log::error($e->getMessage());\n        }\n        try {\n            $unencryptedData = Crypt::decrypt($encryptedData); // verified\n        } catch (DecryptException | FileNotFoundException $e) {\n            Log::error(sprintf('Could not decrypt data of attachment #%d: %s', $attachment->id, $e->getMessage()));\n            $unencryptedData = $encryptedData;\n        }\n\n        return $unencryptedData;\n    }\n\n    /**\n     * Returns the file path relative to upload disk for an attachment,\n     *\n     * @param Attachment $attachment\n     *\n     * @codeCoverageIgnore\n     * @return string\n     */\n    public function getAttachmentLocation(Attachment $attachment): string\n    {\n        return sprintf('%sat-%d.data', DIRECTORY_SEPARATOR, (int)$attachment->id);\n    }\n\n    /**\n     * Get all attachments.\n     *\n     * @codeCoverageIgnore\n     * @return Collection\n     */\n    public function getAttachments(): Collection\n    {\n        return $this->attachments;\n    }\n\n    /**\n     * Get all errors.\n     *\n     * @return MessageBag\n     * @codeCoverageIgnore\n     */\n    public function getErrors(): MessageBag\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get all messages.\n     *\n     * @return MessageBag\n     * @codeCoverageIgnore\n     */\n    public function getMessages(): MessageBag\n    {\n        return $this->messages;\n    }\n\n    /**\n     * Uploads a file as a string.\n     *\n     * @param Attachment $attachment\n     * @param string     $content\n     *\n     * @return bool\n     */\n    public function saveAttachmentFromApi(Attachment $attachment, string $content): bool\n    {\n        $resource = tmpfile();\n        if (false === $resource) {\n\n            Log::error('Cannot create temp-file for file upload.');\n\n            return false;\n\n        }\n\n        if ('' === $content) {\n            Log::error('Cannot upload empty file.');\n\n            return false;\n        }\n\n        $path = stream_get_meta_data($resource)['uri'];\n        fwrite($resource, $content);\n        $finfo       = finfo_open(FILEINFO_MIME_TYPE);\n        $mime        = finfo_file($finfo, $path);\n        $allowedMime = config('firefly.allowedMimes');\n        if (!in_array($mime, $allowedMime, true)) {\n            Log::error(sprintf('Mime type %s is not allowed for API file upload.', $mime));\n            fclose($resource);\n\n            return false;\n        }\n        // is allowed? Save the file, without encryption.\n        $this->uploadDisk->put($attachment->fileName(), $content);\n\n        // update attachment.\n        $attachment->md5      = md5_file($path);\n        $attachment->mime     = $mime;\n        $attachment->size     = strlen($content);\n        $attachment->uploaded = true;\n        $attachment->save();\n\n        return true;\n    }\n\n    /**\n     * Save attachments that get uploaded with models, through the app.\n     *\n     * @param object     $model\n     * @param array|null $files\n     *\n     * @return bool\n     * @throws FireflyException\n     */\n    public function saveAttachmentsForModel(object $model, ?array $files): bool\n    {\n        if (!($model instanceof Model)) {\n            return false;\n        }\n\n        Log::debug(sprintf('Now in saveAttachmentsForModel for model %s', get_class($model)));\n        if (is_array($files)) {\n            Log::debug('$files is an array.');\n            /** @var UploadedFile $entry */\n            foreach ($files as $entry) {\n                if (null !== $entry) {\n                    $this->processFile($entry, $model);\n                }\n            }\n            Log::debug('Done processing uploads.');\n        }\n        if (!is_array($files)) {\n            Log::debug('Array of files is not an array. Probably nothing uploaded. Will not store attachments.');\n        }\n\n        return true;\n    }\n\n    /**\n     * Process the upload of a file.\n     *\n     * @param UploadedFile $file\n     * @param Model        $model\n     *\n     * @return Attachment|null\n     * @throws FireflyException\n     * @throws EncryptException\n     */\n    protected function processFile(UploadedFile $file, Model $model): ?Attachment\n    {\n        Log::debug('Now in processFile()');\n        $validation = $this->validateUpload($file, $model);\n        $attachment = null;\n        if (false !== $validation) {\n            $class = get_class($model);\n            $user  = $model->user;\n            if (PiggyBank::class === $class) {\n                $user = $model->account->user;\n            }\n\n            $attachment = new Attachment; // create Attachment object.\n            $attachment->user()->associate($user);\n            $attachment->attachable()->associate($model);\n            $attachment->md5      = md5_file($file->getRealPath());\n            $attachment->filename = $file->getClientOriginalName();\n            $attachment->mime     = $file->getMimeType();\n            $attachment->size     = $file->getSize();\n            $attachment->uploaded = false;\n            $attachment->save();\n            Log::debug('Created attachment:', $attachment->toArray());\n\n            $fileObject = $file->openFile();\n            $fileObject->rewind();\n\n            if (0 === $file->getSize()) {\n                throw new FireflyException('Cannot upload empty or non-existent file.');\n            }\n\n            $content = $fileObject->fread($file->getSize());\n            Log::debug(sprintf('Full file length is %d and upload size is %d.', strlen($content), $file->getSize()));\n\n            // store it without encryption.\n            $this->uploadDisk->put($attachment->fileName(), $content);\n            $attachment->uploaded = true; // update attachment\n            $attachment->save();\n            $this->attachments->push($attachment);\n\n            $name = e($file->getClientOriginalName()); // add message:\n            $msg  = (string)trans('validation.file_attached', ['name' => $name]);\n            $this->messages->add('attachments', $msg);\n        }\n\n        return $attachment;\n    }\n\n    /**\n     * Verify if the file was uploaded correctly.\n     *\n     * @param UploadedFile $file\n     * @param Model        $model\n     *\n     * @return bool\n     */\n    protected function validateUpload(UploadedFile $file, Model $model): bool\n    {\n        Log::debug('Now in validateUpload()');\n        $result = true;\n        if (!$this->validMime($file)) {\n            $result = false;\n        }\n        if (0 === $file->getSize()) {\n            Log::error('Cannot upload empty file.');\n            $result = false;\n        }\n\n\n        // can't seem to reach this point.\n        if (true === $result && !$this->validSize($file)) {\n            $result = false;\n        }\n\n        if (true === $result && $this->hasFile($file, $model)) {\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Verify if the mime of a file is valid.\n     *\n     * @param UploadedFile $file\n     *\n     * @return bool\n     */\n    protected function validMime(UploadedFile $file): bool\n    {\n        Log::debug('Now in validMime()');\n        $mime = e($file->getMimeType());\n        $name = e($file->getClientOriginalName());\n        Log::debug(sprintf('Name is %s, and mime is %s', $name, $mime));\n        Log::debug('Valid mimes are', $this->allowedMimes);\n        $result = true;\n\n        if (!in_array($mime, $this->allowedMimes, true)) {\n            $msg = (string)trans('validation.file_invalid_mime', ['name' => $name, 'mime' => $mime]);\n            $this->errors->add('attachments', $msg);\n            Log::error($msg);\n\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Verify if the size of a file is valid.\n     *\n     * @codeCoverageIgnore\n     *\n     * @param UploadedFile $file\n     *\n     * @return bool\n     */\n    protected function validSize(UploadedFile $file): bool\n    {\n        $size   = $file->getSize();\n        $name   = e($file->getClientOriginalName());\n        $result = true;\n        if ($size > $this->maxUploadSize) {\n            $msg = (string)trans('validation.file_too_large', ['name' => $name]);\n            $this->errors->add('attachments', $msg);\n            Log::error($msg);\n\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Check if a model already has this file attached.\n     *\n     * @param UploadedFile $file\n     * @param Model        $model\n     *\n     * @return bool\n     */\n    protected function hasFile(UploadedFile $file, Model $model): bool\n    {\n        $md5   = md5_file($file->getRealPath());\n        $name  = $file->getClientOriginalName();\n        $class = get_class($model);\n        $count = 0;\n        if (PiggyBank::class === $class) {\n            $count = $model->account->user->attachments()->where('md5', $md5)->where('attachable_id', $model->id)->where('attachable_type', $class)->count();\n        }\n        if (PiggyBank::class !== $class) {\n            $count = $model->user->attachments()->where('md5', $md5)->where('attachable_id', $model->id)->where('attachable_type', $class)->count();\n        }\n        $result = false;\n        if ($count > 0) {\n            $msg = (string)trans('validation.file_already_attached', ['name' => $name]);\n            $this->errors->add('attachments', $msg);\n            Log::error($msg);\n            $result = true;\n        }\n\n        return $result;\n    }\n}\n"], "buggy_code_start_loc": [173], "buggy_code_end_loc": [173], "fixing_code_start_loc": [174], "fixing_code_end_loc": [175], "type": "CWE-434", "message": "firefly-iii is vulnerable to Unrestricted Upload of File with Dangerous Type", "other": {"cve": {"id": "CVE-2021-3846", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-19T13:15:11.567", "lastModified": "2021-10-22T00:00:25.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "firefly-iii is vulnerable to Unrestricted Upload of File with Dangerous Type"}, {"lang": "es", "value": "firefly-iii es vulnerable a una Carga no Restringida de Archivos de Tipo Peligrosos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.3, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:firefly-iii:firefly_iii:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.2", "matchCriteriaId": "AB91CA1A-2671-4BDE-888A-D1C6B87067EA"}]}]}], "references": [{"url": "https://github.com/firefly-iii/firefly-iii/commit/a85b6420c19ace35134f896e094e1971d8c7954b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/5267ec1c-d204-40d2-bd4f-6c2dd495ee18", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/firefly-iii/firefly-iii/commit/a85b6420c19ace35134f896e094e1971d8c7954b"}}