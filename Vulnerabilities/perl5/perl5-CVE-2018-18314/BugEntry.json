{"buggy_code": ["=head1 NAME\n\nperldiag - various Perl diagnostics\n\n=head1 DESCRIPTION\n\nThese messages are classified as follows (listed in increasing order of\ndesperation):\n\n    (W) A warning (optional).\n    (D) A deprecation (enabled by default).\n    (S) A severe warning (enabled by default).\n    (F) A fatal error (trappable).\n    (P) An internal error you should never see (trappable).\n    (X) A very fatal error (nontrappable).\n    (A) An alien error message (not generated by Perl).\n\nThe majority of messages from the first three classifications above\n(W, D & S) can be controlled using the C<warnings> pragma.\n\nIf a message can be controlled by the C<warnings> pragma, its warning\ncategory is included with the classification letter in the description\nbelow.  E.g. C<(W closed)> means a warning in the C<closed> category.\n\nOptional warnings are enabled by using the C<warnings> pragma or the B<-w>\nand B<-W> switches.  Warnings may be captured by setting C<$SIG{__WARN__}>\nto a reference to a routine that will be called on each warning instead\nof printing it.  See L<perlvar>.\n\nSevere warnings are always enabled, unless they are explicitly disabled\nwith the C<warnings> pragma or the B<-X> switch.\n\nTrappable errors may be trapped using the eval operator.  See\nL<perlfunc/eval>.  In almost all cases, warnings may be selectively\ndisabled or promoted to fatal errors using the C<warnings> pragma.\nSee L<warnings>.\n\nThe messages are in alphabetical order, without regard to upper or\nlower-case.  Some of these messages are generic.  Spots that vary are\ndenoted with a %s or other printf-style escape.  These escapes are\nignored by the alphabetical order, as are all characters other than\nletters.  To look up your message, just ignore anything that is not a\nletter.\n\n=over 4\n\n=item accept() on closed socket %s\n\n(W closed) You tried to do an accept on a closed socket.  Did you forget\nto check the return value of your socket() call?  See\nL<perlfunc/accept>.\n\n=item Aliasing via reference is experimental\n\n(S experimental::refaliasing) This warning is emitted if you use\na reference constructor on the left-hand side of an assignment to\nalias one variable to another.  Simply suppress the warning if you\nwant to use the feature, but know that in doing so you are taking\nthe risk of using an experimental feature which may change or be\nremoved in a future Perl version:\n\n    no warnings \"experimental::refaliasing\";\n    use feature \"refaliasing\";\n    \\$x = \\$y;\n\n=item Allocation too large: %x\n\n(X) You can't allocate more than 64K on an MS-DOS machine.\n\n=item '%c' allowed only after types %s in %s\n\n(F) The modifiers '!', '<' and '>' are allowed in pack() or unpack() only\nafter certain types.  See L<perlfunc/pack>.\n\n=item alpha->numify() is lossy\n\n(W numeric) An alpha version can not be numified without losing\ninformation.\n\n=item Ambiguous call resolved as CORE::%s(), qualify as such or use &\n\n(W ambiguous) A subroutine you have declared has the same name as a Perl\nkeyword, and you have used the name without qualification for calling\none or the other.  Perl decided to call the builtin because the\nsubroutine is not imported.\n\nTo force interpretation as a subroutine call, either put an ampersand\nbefore the subroutine name, or qualify the name with its package.\nAlternatively, you can import the subroutine (or pretend that it's\nimported with the C<use subs> pragma).\n\nTo silently interpret it as the Perl operator, use the C<CORE::> prefix\non the operator (e.g. C<CORE::log($x)>) or declare the subroutine\nto be an object method (see L<perlsub/\"Subroutine Attributes\"> or\nL<attributes>).\n\n=item Ambiguous range in transliteration operator\n\n(F) You wrote something like C<tr/a-z-0//> which doesn't mean anything at\nall.  To include a C<-> character in a transliteration, put it either\nfirst or last.  (In the past, C<tr/a-z-0//> was synonymous with\nC<tr/a-y//>, which was probably not what you would have expected.)\n\n=item Ambiguous use of %s resolved as %s\n\n(S ambiguous) You said something that may not be interpreted the way\nyou thought.  Normally it's pretty easy to disambiguate it by supplying\na missing quote, operator, parenthesis pair or declaration.\n\n=item Ambiguous use of -%s resolved as -&%s()\n\n(S ambiguous) You wrote something like C<-foo>, which might be the\nstring C<\"-foo\">, or a call to the function C<foo>, negated.  If you meant\nthe string, just write C<\"-foo\">.  If you meant the function call,\nwrite C<-foo()>.\n\n=item Ambiguous use of %c resolved as operator %c\n\n(S ambiguous) C<%>, C<&>, and C<*> are both infix operators (modulus,\nbitwise and, and multiplication) I<and> initial special characters\n(denoting hashes, subroutines and typeglobs), and you said something\nlike C<*foo * foo> that might be interpreted as either of them.  We\nassumed you meant the infix operator, but please try to make it more\nclear -- in the example given, you might write C<*foo * foo()> if you\nreally meant to multiply a glob by the result of calling a function.\n\n=item Ambiguous use of %c{%s} resolved to %c%s\n\n(W ambiguous) You wrote something like C<@{foo}>, which might be\nasking for the variable C<@foo>, or it might be calling a function\nnamed foo, and dereferencing it as an array reference.  If you wanted\nthe variable, you can just write C<@foo>.  If you wanted to call the\nfunction, write C<@{foo()}> ... or you could just not have a variable\nand a function with the same name, and save yourself a lot of trouble.\n\n=item Ambiguous use of %c{%s[...]} resolved to %c%s[...]\n\n=item Ambiguous use of %c{%s{...}} resolved to %c%s{...}\n\n(W ambiguous) You wrote something like C<${foo[2]}> (where foo represents\nthe name of a Perl keyword), which might be looking for element number\n2 of the array named C<@foo>, in which case please write C<$foo[2]>, or you\nmight have meant to pass an anonymous arrayref to the function named\nfoo, and then do a scalar deref on the value it returns.  If you meant\nthat, write C<${foo([2])}>.\n\nIn regular expressions, the C<${foo[2]}> syntax is sometimes necessary\nto disambiguate between array subscripts and character classes.\nC</$length[2345]/>, for instance, will be interpreted as C<$length> followed\nby the character class C<[2345]>.  If an array subscript is what you\nwant, you can avoid the warning by changing C</${length[2345]}/> to the\nunsightly C</${\\$length[2345]}/>, by renaming your array to something\nthat does not coincide with a built-in keyword, or by simply turning\noff warnings with C<no warnings 'ambiguous';>.\n\n=item '|' and '<' may not both be specified on command line\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and found that STDIN was a pipe, and that you also tried to\nredirect STDIN using '<'.  Only one STDIN stream to a customer, please.\n\n=item '|' and '>' may not both be specified on command line\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and thinks you tried to redirect stdout both to a file and\ninto a pipe to another command.  You need to choose one or the other,\nthough nothing's stopping you from piping into a program or Perl script\nwhich 'splits' output into two streams, such as\n\n    open(OUT,\">$ARGV[0]\") or die \"Can't write to $ARGV[0]: $!\";\n    while (<STDIN>) {\n        print;\n        print OUT;\n    }\n    close OUT;\n\n=item Applying %s to %s will act on scalar(%s)\n\n(W misc) The pattern match (C<//>), substitution (C<s///>), and\ntransliteration (C<tr///>) operators work on scalar values.  If you apply\none of them to an array or a hash, it will convert the array or hash to\na scalar value (the length of an array, or the population info of a\nhash) and then work on that scalar value.  This is probably not what\nyou meant to do.  See L<perlfunc/grep> and L<perlfunc/map> for\nalternatives.\n\n=item Arg too short for msgsnd\n\n(F) msgsnd() requires a string at least as long as sizeof(long).\n\n=item Argument \"%s\" isn't numeric%s\n\n(W numeric) The indicated string was fed as an argument to an operator\nthat expected a numeric value instead.  If you're fortunate the message\nwill identify which operator was so unfortunate.\n\nNote that for the C<Inf> and C<NaN> (infinity and not-a-number) the\ndefinition of \"numeric\" is somewhat unusual: the strings themselves\n(like \"Inf\") are considered numeric, and anything following them is\nconsidered non-numeric.\n\n=item Argument list not closed for PerlIO layer \"%s\"\n\n(W layer) When pushing a layer with arguments onto the Perl I/O\nsystem you forgot the ) that closes the argument list.  (Layers\ntake care of transforming data between external and internal\nrepresentations.)  Perl stopped parsing the layer list at this\npoint and did not attempt to push this layer.  If your program\ndidn't explicitly request the failing operation, it may be the\nresult of the value of the environment variable PERLIO.\n\n=item Argument \"%s\" treated as 0 in increment (++)\n\n(W numeric) The indicated string was fed as an argument to the C<++>\noperator which expects either a number or a string matching\nC</^[a-zA-Z]*[0-9]*\\z/>.  See L<perlop/Auto-increment and\nAuto-decrement> for details.\n\n=item Array passed to stat will be coerced to a scalar%s\n\n(W syntax) You called stat() on an array, but the array will be\ncoerced to a scalar - the number of elements in the array.\n\n=item A signature parameter must start with '$', '@' or '%'\n\n(F) Each subroutine signature parameter declaration must start with a valid\nsigil; for example:\n\n    sub foo ($a, $, $b = 1, @c) {}\n\n=item A slurpy parameter may not have a default value\n\n(F) Only scalar subroutine signature parameters may have a default value;\nfor example:\n\n    sub foo ($a = 1)        {} # legal\n    sub foo (@a = (1))      {} # invalid\n    sub foo (%a = (a => b)) {} # invalid\n\n=item assertion botched: %s\n\n(X) The malloc package that comes with Perl had an internal failure.\n\n=item Assertion %s failed: file \"%s\", line %d\n\n(X) A general assertion failed.  The file in question must be examined.\n\n=item Assigned value is not a reference\n\n(F) You tried to assign something that was not a reference to an lvalue\nreference (e.g., C<\\$x = $y>).  If you meant to make $x an alias to $y, use\nC<\\$x = \\$y>.\n\n=item Assigned value is not %s reference\n\n(F) You tried to assign a reference to a reference constructor, but the\ntwo references were not of the same type.  You cannot alias a scalar to\nan array, or an array to a hash; the two types must match.\n\n    \\$x = \\@y;  # error\n    \\@x = \\%y;  # error\n     $y = [];\n    \\$x = $y;   # error; did you mean \\$y?\n\n=item Assigning non-zero to $[ is no longer possible\n\n(F) When the \"array_base\" feature is disabled (e.g., under C<use v5.16;>)\nthe special variable C<$[>, which is deprecated, is now a fixed zero value.\n\n=item Assignment to both a list and a scalar\n\n(F) If you assign to a conditional operator, the 2nd and 3rd arguments\nmust either both be scalars or both be lists.  Otherwise Perl won't\nknow which context to supply to the right side.\n\n=item Assuming NOT a POSIX class since %s in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) You had something like these:\n\n [[:alnum]]\n [[:digit:xyz]\n\nThey look like they might have been meant to be the POSIX classes\nC<[:alnum:]> or C<[:digit:]>.  If so, they should be written:\n\n [[:alnum:]]\n [[:digit:]xyz]\n\nSince these aren't legal POSIX class specifications, but are legal\nbracketed character classes, Perl treats them as the latter.  In the\nfirst example, it matches the characters C<\":\">, C<\"[\">, C<\"a\">, C<\"l\">,\nC<\"m\">, C<\"n\">, and C<\"u\">.\n\nIf these weren't meant to be POSIX classes, this warning message is\nspurious, and can be suppressed by reordering things, such as\n\n [[al:num]]\n\nor\n\n [[:munla]]\n\n=item <> at require-statement should be quotes\n\n(F) You wrote C<< require <file> >> when you should have written\nC<require 'file'>.\n\n=item Attempt to access disallowed key '%s' in a restricted hash\n\n(F) The failing code has attempted to get or set a key which is not in\nthe current set of allowed keys of a restricted hash.\n\n=item Attempt to bless into a freed package\n\n(F) You wrote C<bless $foo> with one argument after somehow causing\nthe current package to be freed.  Perl cannot figure out what to\ndo, so it throws up in hands in despair.\n\n=item Attempt to bless into a reference\n\n(F) The CLASSNAME argument to the bless() operator is expected to be\nthe name of the package to bless the resulting object into.  You've\nsupplied instead a reference to something: perhaps you wrote\n\n    bless $self, $proto;\n\nwhen you intended\n\n    bless $self, ref($proto) || $proto;\n\nIf you actually want to bless into the stringified version\nof the reference supplied, you need to stringify it yourself, for\nexample by:\n\n    bless $self, \"$proto\";\n\n=item Attempt to clear deleted array\n\n(S debugging) An array was assigned to when it was being freed.\nFreed values are not supposed to be visible to Perl code.  This\ncan also happen if XS code calls C<av_clear> from a custom magic\ncallback on the array.\n\n=item Attempt to delete disallowed key '%s' from a restricted hash\n\n(F) The failing code attempted to delete from a restricted hash a key\nwhich is not in its key set.\n\n=item Attempt to delete readonly key '%s' from a restricted hash\n\n(F) The failing code attempted to delete a key whose value has been\ndeclared readonly from a restricted hash.\n\n=item Attempt to free non-arena SV: 0x%x\n\n(S internal) All SV objects are supposed to be allocated from arenas\nthat will be garbage collected on exit.  An SV was discovered to be\noutside any of those arenas.\n\n=item Attempt to free nonexistent shared string '%s'%s\n\n(S internal) Perl maintains a reference-counted internal table of\nstrings to optimize the storage and access of hash keys and other\nstrings.  This indicates someone tried to decrement the reference count\nof a string that can no longer be found in the table.\n\n=item Attempt to free temp prematurely: SV 0x%x\n\n(S debugging) Mortalized values are supposed to be freed by the\nfree_tmps() routine.  This indicates that something else is freeing the\nSV before the free_tmps() routine gets a chance, which means that the\nfree_tmps() routine will be freeing an unreferenced scalar when it does\ntry to free it.\n\n=item Attempt to free unreferenced glob pointers\n\n(S internal) The reference counts got screwed up on symbol aliases.\n\n=item Attempt to free unreferenced scalar: SV 0x%x\n\n(S internal) Perl went to decrement the reference count of a scalar to\nsee if it would go to 0, and discovered that it had already gone to 0\nearlier, and should have been freed, and in fact, probably was freed.\nThis could indicate that SvREFCNT_dec() was called too many times, or\nthat SvREFCNT_inc() was called too few times, or that the SV was\nmortalized when it shouldn't have been, or that memory has been\ncorrupted.\n\n=item Attempt to pack pointer to temporary value\n\n(W pack) You tried to pass a temporary value (like the result of a\nfunction, or a computed expression) to the \"p\" pack() template.  This\nmeans the result contains a pointer to a location that could become\ninvalid anytime, even before the end of the current statement.  Use\nliterals or global values as arguments to the \"p\" pack() template to\navoid this warning.\n\n=item Attempt to reload %s aborted.\n\n(F) You tried to load a file with C<use> or C<require> that failed to\ncompile once already.  Perl will not try to compile this file again\nunless you delete its entry from %INC.  See L<perlfunc/require> and\nL<perlvar/%INC>.\n\n=item Attempt to set length of freed array\n\n(W misc) You tried to set the length of an array which has\nbeen freed.  You can do this by storing a reference to the\nscalar representing the last index of an array and later\nassigning through that reference.  For example\n\n    $r = do {my @a; \\$#a};\n    $$r = 503\n\n=item Attempt to use reference as lvalue in substr\n\n(W substr) You supplied a reference as the first argument to substr()\nused as an lvalue, which is pretty strange.  Perhaps you forgot to\ndereference it first.  See L<perlfunc/substr>.\n\n=item Attribute prototype(%s) discards earlier prototype attribute in same sub\n\n(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for\nexample.  Since each sub can only have one prototype, the earlier\ndeclaration(s) are discarded while the last one is applied.\n\n=item av_reify called on tied array\n\n(S debugging) This indicates that something went wrong and Perl got I<very>\nconfused about C<@_> or C<@DB::args> being tied.\n\n=item Bad arg length for %s, is %u, should be %d\n\n(F) You passed a buffer of the wrong size to one of msgctl(), semctl()\nor shmctl().  In C parlance, the correct sizes are, respectively,\nS<sizeof(struct msqid_ds *)>, S<sizeof(struct semid_ds *)>, and\nS<sizeof(struct shmid_ds *)>.\n\n=item Bad evalled substitution pattern\n\n(F) You've used the C</e> switch to evaluate the replacement for a\nsubstitution, but perl found a syntax error in the code to evaluate,\nmost likely an unexpected right brace '}'.\n\n=item Bad filehandle: %s\n\n(F) A symbol was passed to something wanting a filehandle, but the\nsymbol has no filehandle associated with it.  Perhaps you didn't do an\nopen(), or did it in another package.\n\n=item Bad free() ignored\n\n(S malloc) An internal routine called free() on something that had never\nbeen malloc()ed in the first place.  Mandatory, but can be disabled by\nsetting environment variable C<PERL_BADFREE> to 0.\n\nThis message can be seen quite often with DB_File on systems with \"hard\"\ndynamic linking, like C<AIX> and C<OS/2>.  It is a bug of C<Berkeley DB>\nwhich is left unnoticed if C<DB> uses I<forgiving> system malloc().\n\n=item Bad hash\n\n(P) One of the internal hash routines was passed a null HV pointer.\n\n=item Badly placed ()'s\n\n(A) You've accidentally run your script through B<csh> instead\nof Perl.  Check the #! line, or manually feed your script into\nPerl yourself.\n\n=item Bad name after %s\n\n(F) You started to name a symbol by using a package prefix, and then\ndidn't finish the symbol.  In particular, you can't interpolate outside\nof quotes, so\n\n    $var = 'myvar';\n    $sym = mypack::$var;\n\nis not the same as\n\n    $var = 'myvar';\n    $sym = \"mypack::$var\";\n\n=item Bad plugin affecting keyword '%s'\n\n(F) An extension using the keyword plugin mechanism violated the\nplugin API.\n\n=item Bad realloc() ignored\n\n(S malloc) An internal routine called realloc() on something that\nhad never been malloc()ed in the first place.  Mandatory, but can\nbe disabled by setting the environment variable C<PERL_BADFREE> to 1.\n\n=item Bad symbol for array\n\n(P) An internal request asked to add an array entry to something that\nwasn't a symbol table entry.\n\n=item Bad symbol for dirhandle\n\n(P) An internal request asked to add a dirhandle entry to something\nthat wasn't a symbol table entry.\n\n=item Bad symbol for filehandle\n\n(P) An internal request asked to add a filehandle entry to something\nthat wasn't a symbol table entry.\n\n=item Bad symbol for hash\n\n(P) An internal request asked to add a hash entry to something that\nwasn't a symbol table entry.\n\n=item Bad symbol for scalar\n\n(P) An internal request asked to add a scalar entry to something that\nwasn't a symbol table entry.\n\n=item Bareword found in conditional\n\n(W bareword) The compiler found a bareword where it expected a\nconditional, which often indicates that an || or && was parsed as part\nof the last argument of the previous construct, for example:\n\n    open FOO || die;\n\nIt may also indicate a misspelled constant that has been interpreted as\na bareword:\n\n    use constant TYPO => 1;\n    if (TYOP) { print \"foo\" }\n\nThe C<strict> pragma is useful in avoiding such errors.\n\n=item Bareword in require contains \"%s\"\n\n=item Bareword in require maps to disallowed filename \"%s\"\n\n=item Bareword in require maps to empty filename\n\n(F) The bareword form of require has been invoked with a filename which could\nnot have been generated by a valid bareword permitted by the parser.  You\nshouldn't be able to get this error from Perl code, but XS code may throw it\nif it passes an invalid module name to C<Perl_load_module>.\n\n=item Bareword in require must not start with a double-colon: \"%s\"\n\n(F) In C<require Bare::Word>, the bareword is not allowed to start with a\ndouble-colon.  Write C<require ::Foo::Bar> as  C<require Foo::Bar> instead.\n\n=item Bareword \"%s\" not allowed while \"strict subs\" in use\n\n(F) With \"strict subs\" in use, a bareword is only allowed as a\nsubroutine identifier, in curly brackets or to the left of the \"=>\"\nsymbol.  Perhaps you need to predeclare a subroutine?\n\n=item Bareword \"%s\" refers to nonexistent package\n\n(W bareword) You used a qualified bareword of the form C<Foo::>, but the\ncompiler saw no other uses of that namespace before that point.  Perhaps\nyou need to predeclare a package?\n\n=item BEGIN failed--compilation aborted\n\n(F) An untrapped exception was raised while executing a BEGIN\nsubroutine.  Compilation stops immediately and the interpreter is\nexited.\n\n=item BEGIN not safe after errors--compilation aborted\n\n(F) Perl found a C<BEGIN {}> subroutine (or a C<use> directive, which\nimplies a C<BEGIN {}>) after one or more compilation errors had already\noccurred.  Since the intended environment for the C<BEGIN {}> could not\nbe guaranteed (due to the errors), and since subsequent code likely\ndepends on its correct operation, Perl just gave up.\n\n=item \\%d better written as $%d\n\n(W syntax) Outside of patterns, backreferences live on as variables.\nThe use of backslashes is grandfathered on the right-hand side of a\nsubstitution, but stylistically it's better to use the variable form\nbecause other Perl programmers will expect it, and it works better if\nthere are more than 9 backreferences.\n\n=item Binary number > 0b11111111111111111111111111111111 non-portable\n\n(W portable) The binary number you specified is larger than 2**32-1\n(4294967295) and therefore non-portable between systems.  See\nL<perlport> for more on portability concerns.\n\n=item bind() on closed socket %s\n\n(W closed) You tried to do a bind on a closed socket.  Did you forget to\ncheck the return value of your socket() call?  See L<perlfunc/bind>.\n\n=item binmode() on closed filehandle %s\n\n(W unopened) You tried binmode() on a filehandle that was never opened.\nCheck your control flow and number of arguments.\n\n=item Bit vector size > 32 non-portable\n\n(W portable) Using bit vector sizes larger than 32 is non-portable.\n\n=item Bizarre copy of %s\n\n(P) Perl detected an attempt to copy an internal value that is not\ncopiable.\n\n=item Bizarre SvTYPE [%d]\n\n(P) When starting a new thread or returning values from a thread, Perl\nencountered an invalid data type.\n\n=item Both or neither range ends should be Unicode in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nIn a bracketed character class in a regular expression pattern, you\nhad a range which has exactly one end of it specified using C<\\N{}>, and\nthe other end is specified using a non-portable mechanism.  Perl treats\nthe range as a Unicode range, that is, all the characters in it are\nconsidered to be the Unicode characters, and which may be different code\npoints on some platforms Perl runs on.  For example, C<[\\N{U+06}-\\x08]>\nis treated as if you had instead said C<[\\N{U+06}-\\N{U+08}]>, that is it\nmatches the characters whose code points in Unicode are 6, 7, and 8.\nBut that C<\\x08> might indicate that you meant something different, so\nthe warning gets raised.\n\n=item Buffer overflow in prime_env_iter: %s\n\n(W internal) A warning peculiar to VMS.  While Perl was preparing to\niterate over %ENV, it encountered a logical name or symbol definition\nwhich was too long, so it was truncated to the string shown.\n\n=item Callback called exit\n\n(F) A subroutine invoked from an external package via call_sv()\nexited by calling exit.\n\n=item %s() called too early to check prototype\n\n(W prototype) You've called a function that has a prototype before the\nparser saw a definition or declaration for it, and Perl could not check\nthat the call conforms to the prototype.  You need to either add an\nearly prototype declaration for the subroutine in question, or move the\nsubroutine definition ahead of the call to get proper prototype\nchecking.  Alternatively, if you are certain that you're calling the\nfunction correctly, you may put an ampersand before the name to avoid\nthe warning.  See L<perlsub>.\n\n=item Cannot chr %f\n\n(F) You passed an invalid number (like an infinity or not-a-number) to C<chr>.\n\n=item Cannot complete in-place edit of %s: %s\n\n(F) Your perl script appears to have changed directory while\nperforming an in-place edit of a file specified by a relative path,\nand your system doesn't include the directory relative POSIX functions\nneeded to handle that.\n\n=item Cannot compress %f in pack\n\n(F) You tried compressing an infinity or not-a-number as an unsigned\ninteger with BER, which makes no sense.\n\n=item Cannot compress integer in pack\n\n(F) An argument to pack(\"w\",...) was too large to compress.\nThe BER compressed integer format can only be used with positive\nintegers, and you attempted to compress a very large number (> 1e308).\nSee L<perlfunc/pack>.\n\n=item Cannot compress negative numbers in pack\n\n(F) An argument to pack(\"w\",...) was negative.  The BER compressed integer\nformat can only be used with positive integers.  See L<perlfunc/pack>.\n\n=item Cannot convert a reference to %s to typeglob\n\n(F) You manipulated Perl's symbol table directly, stored a reference\nin it, then tried to access that symbol via conventional Perl syntax.\nThe access triggers Perl to autovivify that typeglob, but it there is\nno legal conversion from that type of reference to a typeglob.\n\n=item Cannot copy to %s\n\n(P) Perl detected an attempt to copy a value to an internal type that cannot\nbe directly assigned to.\n\n=item Cannot find encoding \"%s\"\n\n(S io) You tried to apply an encoding that did not exist to a filehandle,\neither with open() or binmode().\n\n=item Cannot open %s as a dirhandle: it is already open as a filehandle\n\n(F) You tried to use opendir() to associate a dirhandle to a symbol (glob\nor scalar) that already holds a filehandle.  Since this idiom might render\nyour code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it\nis a fatal error.\n\n=item Cannot open %s as a filehandle: it is already open as a dirhandle\n\n(F) You tried to use open() to associate a filehandle to a symbol (glob\nor scalar) that already holds a dirhandle.  Since this idiom might render\nyour code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it\nis a fatal error.\n\n=item Cannot pack %f with '%c'\n\n(F) You tried converting an infinity or not-a-number to an integer,\nwhich makes no sense.\n\n=item Cannot printf %f with '%c'\n\n(F) You tried printing an infinity or not-a-number as a character (%c),\nwhich makes no sense.  Maybe you meant '%s', or just stringifying it?\n\n=item Cannot set tied @DB::args\n\n(F) C<caller> tried to set C<@DB::args>, but found it tied.  Tying C<@DB::args>\nis not supported.  (Before this error was added, it used to crash.)\n\n=item Cannot tie unreifiable array\n\n(P) You somehow managed to call C<tie> on an array that does not\nkeep a reference count on its arguments and cannot be made to\ndo so.  Such arrays are not even supposed to be accessible to\nPerl code, but are only used internally.\n\n=item Cannot yet reorder sv_catpvfn() arguments from va_list\n\n(F) Some XS code tried to use C<sv_catpvfn()> or a related function with a\nformat string that specifies explicit indexes for some of the elements, and\nusing a C-style variable-argument list (a C<va_list>).  This is not currently\nsupported.  XS authors wanting to do this must instead construct a C array\nof C<SV*> scalars containing the arguments.\n\n=item Can only compress unsigned integers in pack\n\n(F) An argument to pack(\"w\",...) was not an integer.  The BER compressed\ninteger format can only be used with positive integers, and you attempted\nto compress something else.  See L<perlfunc/pack>.\n\n=item Can't bless non-reference value\n\n(F) Only hard references may be blessed.  This is how Perl \"enforces\"\nencapsulation of objects.  See L<perlobj>.\n\n=item Can't \"break\" in a loop topicalizer\n\n(F) You called C<break>, but you're in a C<foreach> block rather than\na C<given> block.  You probably meant to use C<next> or C<last>.\n\n=item Can't \"break\" outside a given block\n\n(F) You called C<break>, but you're not inside a C<given> block.\n\n=item Can't call method \"%s\" on an undefined value\n\n(F) You used the syntax of a method call, but the slot filled by the\nobject reference or package name contains an undefined value.  Something\nlike this will reproduce the error:\n\n    $BADREF = undef;\n    process $BADREF 1,2,3;\n    $BADREF->process(1,2,3);\n\n=item Can't call method \"%s\" on unblessed reference\n\n(F) A method call must know in what package it's supposed to run.  It\nordinarily finds this out from the object reference you supply, but you\ndidn't supply an object reference in this case.  A reference isn't an\nobject reference until it has been blessed.  See L<perlobj>.\n\n=item Can't call method \"%s\" without a package or object reference\n\n(F) You used the syntax of a method call, but the slot filled by the\nobject reference or package name contains an expression that returns a\ndefined value which is neither an object reference nor a package name.\nSomething like this will reproduce the error:\n\n    $BADREF = 42;\n    process $BADREF 1,2,3;\n    $BADREF->process(1,2,3);\n\n=item Can't call mro_isa_changed_in() on anonymous symbol table\n\n(P) Perl got confused as to whether a hash was a plain hash or a\nsymbol table hash when trying to update @ISA caches.\n\n=item Can't call mro_method_changed_in() on anonymous symbol table\n\n(F) An XS module tried to call C<mro_method_changed_in> on a hash that was\nnot attached to the symbol table.\n\n=item Can't chdir to %s\n\n(F) You called C<perl -x/foo/bar>, but F</foo/bar> is not a directory\nthat you can chdir to, possibly because it doesn't exist.\n\n=item Can't check filesystem of script \"%s\" for nosuid\n\n(P) For some reason you can't check the filesystem of the script for\nnosuid.\n\n=item Can't coerce %s to %s in %s\n\n(F) Certain types of SVs, in particular real symbol table entries\n(typeglobs), can't be forced to stop being what they are.  So you can't\nsay things like:\n\n    *foo += 1;\n\nYou CAN say\n\n    $foo = *foo;\n    $foo += 1;\n\nbut then $foo no longer contains a glob.\n\n=item Can't \"continue\" outside a when block\n\n(F) You called C<continue>, but you're not inside a C<when>\nor C<default> block.\n\n=item Can't create pipe mailbox\n\n(P) An error peculiar to VMS.  The process is suffering from exhausted\nquotas or other plumbing problems.\n\n=item Can't declare %s in \"%s\"\n\n(F) Only scalar, array, and hash variables may be declared as \"my\", \"our\" or\n\"state\" variables.  They must have ordinary identifiers as names.\n\n=item Can't \"default\" outside a topicalizer\n\n(F) You have used a C<default> block that is neither inside a\nC<foreach> loop nor a C<given> block.  (Note that this error is\nissued on exit from the C<default> block, so you won't get the\nerror if you use an explicit C<continue>.)\n\n=item Can't determine class of operator %s, assuming BASEOP\n\n(S) This warning indicates something wrong in the internals of perl.\nPerl was trying to find the class (e.g. LISTOP) of a particular OP,\nand was unable to do so. This is likely to be due to a bug in the perl\ninternals, or due to a bug in XS code which manipulates perl optrees.\n\n=item Can't do inplace edit: %s is not a regular file\n\n(S inplace) You tried to use the B<-i> switch on a special file, such as\na file in /dev, a FIFO or an uneditable directory.  The file was ignored.\n\n=item Can't do inplace edit on %s: %s\n\n(S inplace) The creation of the new file failed for the indicated\nreason.\n\n=item Can't do inplace edit without backup\n\n(F) You're on a system such as MS-DOS that gets confused if you try\nreading from a deleted (but still opened) file.  You have to say\nC<-i.bak>, or some such.\n\n=item Can't do inplace edit: %s would not be unique\n\n(S inplace) Your filesystem does not support filenames longer than 14\ncharacters and Perl was unable to create a unique filename during\ninplace editing with the B<-i> switch.  The file was ignored.\n\n=item Can't do %s(\"%s\") on non-UTF-8 locale; resolved to \"%s\".\n\n(W locale) You are 1) running under \"C<use locale>\"; 2) the current\nlocale is not a UTF-8 one; 3) you tried to do the designated case-change\noperation on the specified Unicode character; and 4) the result of this\noperation would mix Unicode and locale rules, which likely conflict.\nMixing of different rule types is forbidden, so the operation was not\ndone; instead the result is the indicated value, which is the best\navailable that uses entirely Unicode rules.  That turns out to almost\nalways be the original character, unchanged.\n\nIt is generally a bad idea to mix non-UTF-8 locales and Unicode, and\nthis issue is one of the reasons why.  This warning is raised when\nUnicode rules would normally cause the result of this operation to\ncontain a character that is in the range specified by the locale,\n0..255, and hence is subject to the locale's rules, not Unicode's.\n\nIf you are using locale purely for its characteristics related to things\nlike its numeric and time formatting (and not C<LC_CTYPE>), consider\nusing a restricted form of the locale pragma (see L<perllocale/The \"use\nlocale\" pragma>) like \"S<C<use locale ':not_characters'>>\".\n\nNote that failed case-changing operations done as a result of\ncase-insensitive C</i> regular expression matching will show up in this\nwarning as having the C<fc> operation (as that is what the regular\nexpression engine calls behind the scenes.)\n\n=item Can't do waitpid with flags\n\n(F) This machine doesn't have either waitpid() or wait4(), so only\nwaitpid() without flags is emulated.\n\n=item Can't emulate -%s on #! line\n\n(F) The #! line specifies a switch that doesn't make sense at this\npoint.  For example, it'd be kind of silly to put a B<-x> on the #!\nline.\n\n=item Can't %s %s-endian %ss on this platform\n\n(F) Your platform's byte-order is neither big-endian nor little-endian,\nor it has a very strange pointer size.  Packing and unpacking big- or\nlittle-endian floating point values and pointers may not be possible.\nSee L<perlfunc/pack>.\n\n=item Can't exec \"%s\": %s\n\n(W exec) A system(), exec(), or piped open call could not execute the\nnamed program for the indicated reason.  Typical reasons include: the\npermissions were wrong on the file, the file wasn't found in\nC<$ENV{PATH}>, the executable in question was compiled for another\narchitecture, or the #! line in a script points to an interpreter that\ncan't be run for similar reasons.  (Or maybe your system doesn't support\n#! at all.)\n\n=item Can't exec %s\n\n(F) Perl was trying to execute the indicated program for you because\nthat's what the #! line said.  If that's not what you wanted, you may\nneed to mention \"perl\" on the #! line somewhere.\n\n=item Can't execute %s\n\n(F) You used the B<-S> switch, but the copies of the script to execute\nfound in the PATH did not have correct permissions.\n\n=item Can't find an opnumber for \"%s\"\n\n(F) A string of a form C<CORE::word> was given to prototype(), but there\nis no builtin with the name C<word>.\n\n=item Can't find label %s\n\n(F) You said to goto a label that isn't mentioned anywhere that it's\npossible for us to go to.  See L<perlfunc/goto>.\n\n=item Can't find %s on PATH\n\n(F) You used the B<-S> switch, but the script to execute could not be\nfound in the PATH.\n\n=item Can't find %s on PATH, '.' not in PATH\n\n(F) You used the B<-S> switch, but the script to execute could not be\nfound in the PATH, or at least not with the correct permissions.  The\nscript exists in the current directory, but PATH prohibits running it.\n\n=item Can't find string terminator %s anywhere before EOF\n\n(F) Perl strings can stretch over multiple lines.  This message means\nthat the closing delimiter was omitted.  Because bracketed quotes count\nnesting levels, the following is missing its final parenthesis:\n\n    print q(The character '(' starts a side comment.);\n\nIf you're getting this error from a here-document, you may have\nincluded unseen whitespace before or after your closing tag or there\nmay not be a linebreak after it.  A good programmer's editor will have\na way to help you find these characters (or lack of characters).  See\nL<perlop> for the full details on here-documents.\n\n=item Can't find Unicode property definition \"%s\"\n\n=item Can't find Unicode property definition \"%s\" in regex; marked by <-- HERE in m/%s/\n\n(F) The named property which you specified via C<\\p> or C<\\P> is not one\nknown to Perl.  Perhaps you misspelled the name?  See\nL<perluniprops/Properties accessible through \\p{} and \\P{}>\nfor a complete list of available official\nproperties.  If it is a\nL<user-defined property|perlunicode/User-Defined Character Properties>\nit must have been defined by the time the regular expression is\nmatched.\n\nIf you didn't mean to use a Unicode property, escape the C<\\p>, either\nby C<\\\\p> (just the C<\\p>) or by C<\\Q\\p> (the rest of the string, or\nuntil C<\\E>).\n\n=item Can't fork: %s\n\n(F) A fatal error occurred while trying to fork while opening a\npipeline.\n\n=item Can't fork, trying again in 5 seconds\n\n(W pipe) A fork in a piped open failed with EAGAIN and will be retried\nafter five seconds.\n\n=item Can't get filespec - stale stat buffer?\n\n(S) A warning peculiar to VMS.  This arises because of the difference\nbetween access checks under VMS and under the Unix model Perl assumes.\nUnder VMS, access checks are done by filename, rather than by bits in\nthe stat buffer, so that ACLs and other protections can be taken into\naccount.  Unfortunately, Perl assumes that the stat buffer contains all\nthe necessary information, and passes it, instead of the filespec, to\nthe access-checking routine.  It will try to retrieve the filespec using\nthe device name and FID present in the stat buffer, but this works only\nif you haven't made a subsequent call to the CRTL stat() routine,\nbecause the device name is overwritten with each call.  If this warning\nappears, the name lookup failed, and the access-checking routine gave up\nand returned FALSE, just to be conservative.  (Note: The access-checking\nroutine knows about the Perl C<stat> operator and file tests, so you\nshouldn't ever see this warning in response to a Perl command; it arises\nonly if some internal code takes stat buffers lightly.)\n\n=item Can't get pipe mailbox device name\n\n(P) An error peculiar to VMS.  After creating a mailbox to act as a\npipe, Perl can't retrieve its name for later use.\n\n=item Can't get SYSGEN parameter value for MAXBUF\n\n(P) An error peculiar to VMS.  Perl asked $GETSYI how big you want your\nmailbox buffers to be, and didn't get an answer.\n\n=item Can't \"goto\" into the middle of a foreach loop\n\n(F) A \"goto\" statement was executed to jump into the middle of a foreach\nloop.  You can't get there from here.  See L<perlfunc/goto>.\n\n=item Can't \"goto\" out of a pseudo block\n\n(F) A \"goto\" statement was executed to jump out of what might look like\na block, except that it isn't a proper block.  This usually occurs if\nyou tried to jump out of a sort() block or subroutine, which is a no-no.\nSee L<perlfunc/goto>.\n\n=item Can't goto subroutine from an eval-%s\n\n(F) The \"goto subroutine\" call can't be used to jump out of an eval\n\"string\" or block.\n\n=item Can't goto subroutine from a sort sub (or similar callback)\n\n(F) The \"goto subroutine\" call can't be used to jump out of the\ncomparison sub for a sort(), or from a similar callback (such\nas the reduce() function in List::Util).\n\n=item Can't goto subroutine outside a subroutine\n\n(F) The deeply magical \"goto subroutine\" call can only replace one\nsubroutine call for another.  It can't manufacture one out of whole\ncloth.  In general you should be calling it out of only an AUTOLOAD\nroutine anyway.  See L<perlfunc/goto>.\n\n=item Can't ignore signal CHLD, forcing to default\n\n(W signal) Perl has detected that it is being run with the SIGCHLD\nsignal (sometimes known as SIGCLD) disabled.  Since disabling this\nsignal will interfere with proper determination of exit status of child\nprocesses, Perl has reset the signal to its default value.  This\nsituation typically indicates that the parent program under which Perl\nmay be running (e.g. cron) is being very careless.\n\n=item Can't kill a non-numeric process ID\n\n(F) Process identifiers must be (signed) integers.  It is a fatal error to\nattempt to kill() an undefined, empty-string or otherwise non-numeric\nprocess identifier.\n\n=item Can't \"last\" outside a loop block\n\n(F) A \"last\" statement was executed to break out of the current block,\nexcept that there's this itty bitty problem called there isn't a current\nblock.  Note that an \"if\" or \"else\" block doesn't count as a \"loopish\"\nblock, as doesn't a block given to sort(), map() or grep().  You can\nusually double the curlies to get the same effect though, because the\ninner curlies will be considered a block that loops once.  See\nL<perlfunc/last>.\n\n=item Can't linearize anonymous symbol table\n\n(F) Perl tried to calculate the method resolution order (MRO) of a\npackage, but failed because the package stash has no name.\n\n=item Can't load '%s' for module %s\n\n(F) The module you tried to load failed to load a dynamic extension.\nThis may either mean that you upgraded your version of perl to one\nthat is incompatible with your old dynamic extensions (which is known\nto happen between major versions of perl), or (more likely) that your\ndynamic extension was built against an older version of the library\nthat is installed on your system.  You may need to rebuild your old\ndynamic extensions.\n\n=item Can't localize lexical variable %s\n\n(F) You used local on a variable name that was previously declared as a\nlexical variable using \"my\" or \"state\".  This is not allowed.  If you\nwant to localize a package variable of the same name, qualify it with\nthe package name.\n\n=item Can't localize through a reference\n\n(F) You said something like C<local $$ref>, which Perl can't currently\nhandle, because when it goes to restore the old value of whatever $ref\npointed to after the scope of the local() is finished, it can't be sure\nthat $ref will still be a reference.\n\n=item Can't locate %s\n\n(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be found.\nPerl looks for the file in all the locations mentioned in @INC, unless\nthe file name included the full path to the file.  Perhaps you need\nto set the PERL5LIB or PERL5OPT environment variable to say where the\nextra library is, or maybe the script needs to add the library name\nto @INC.  Or maybe you just misspelled the name of the file.  See\nL<perlfunc/require> and L<lib>.\n\n=item Can't locate auto/%s.al in @INC\n\n(F) A function (or method) was called in a package which allows\nautoload, but there is no function to autoload.  Most probable causes\nare a misprint in a function/method name or a failure to C<AutoSplit>\nthe file, say, by doing C<make install>.\n\n=item Can't locate loadable object for module %s in @INC\n\n(F) The module you loaded is trying to load an external library, like\nfor example, F<foo.so> or F<bar.dll>, but the L<DynaLoader> module was\nunable to locate this library.  See L<DynaLoader>.\n\n=item Can't locate object method \"%s\" via package \"%s\"\n\n(F) You called a method correctly, and it correctly indicated a package\nfunctioning as a class, but that package doesn't define that particular\nmethod, nor does any of its base classes.  See L<perlobj>.\n\n=item Can't locate object method \"%s\" via package \"%s\" (perhaps you forgot\nto load \"%s\"?)\n\n(F) You called a method on a class that did not exist, and the method\ncould not be found in UNIVERSAL.  This often means that a method\nrequires a package that has not been loaded.\n\n=item Can't locate package %s for @%s::ISA\n\n(W syntax) The @ISA array contained the name of another package that\ndoesn't seem to exist.\n\n=item Can't locate PerlIO%s\n\n(F) You tried to use in open() a PerlIO layer that does not exist,\ne.g. open(FH, \">:nosuchlayer\", \"somefile\").\n\n=item Can't make list assignment to %ENV on this system\n\n(F) List assignment to %ENV is not supported on some systems, notably\nVMS.\n\n=item Can't make loaded symbols global on this platform while loading %s\n\n(S) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request\nthat symbols from the stated file are made available globally within the\nprocess, but that functionality is not available on this platform.  Whilst\nthe module likely will still work, this may prevent the perl interpreter\nfrom loading other XS-based extensions which need to link directly to\nfunctions defined in the C or XS code in the stated file.\n\n=item Can't modify %s in %s\n\n(F) You aren't allowed to assign to the item indicated, or otherwise try\nto change it, such as with an auto-increment.\n\n=item Can't modify nonexistent substring\n\n(P) The internal routine that does assignment to a substr() was handed\na NULL.\n\n=item Can't modify non-lvalue subroutine call of &%s\n\n=item Can't modify non-lvalue subroutine call of &%s in %s\n\n(F) Subroutines meant to be used in lvalue context should be declared as\nsuch.  See L<perlsub/\"Lvalue subroutines\">.\n\n=item Can't modify reference to %s in %s assignment\n\n(F) Only a limited number of constructs can be used as the argument to a\nreference constructor on the left-hand side of an assignment, and what\nyou used was not one of them.  See L<perlref/Assigning to References>.\n\n=item Can't modify reference to localized parenthesized array in list\nassignment\n\n(F) Assigning to C<\\local(@array)> or C<\\(local @array)> is not supported, as\nit is not clear exactly what it should do.  If you meant to make @array\nrefer to some other array, use C<\\@array = \\@other_array>.  If you want to\nmake the elements of @array aliases of the scalars referenced on the\nright-hand side, use C<\\(@array) = @scalar_refs>.\n\n=item Can't modify reference to parenthesized hash in list assignment\n\n(F) Assigning to C<\\(%hash)> is not supported.  If you meant to make %hash\nrefer to some other hash, use C<\\%hash = \\%other_hash>.  If you want to\nmake the elements of %hash into aliases of the scalars referenced on the\nright-hand side, use a hash slice: C<\\@hash{@keys} = @those_scalar_refs>.\n\n=item Can't msgrcv to read-only var\n\n(F) The target of a msgrcv must be modifiable to be used as a receive\nbuffer.\n\n=item Can't \"next\" outside a loop block\n\n(F) A \"next\" statement was executed to reiterate the current block, but\nthere isn't a current block.  Note that an \"if\" or \"else\" block doesn't\ncount as a \"loopish\" block, as doesn't a block given to sort(), map() or\ngrep().  You can usually double the curlies to get the same effect\nthough, because the inner curlies will be considered a block that loops\nonce.  See L<perlfunc/next>.\n\n=item Can't open %s: %s\n\n(S inplace) The implicit opening of a file through use of the C<< <> >>\nfilehandle, either implicitly under the C<-n> or C<-p> command-line\nswitches, or explicitly, failed for the indicated reason.  Usually\nthis is because you don't have read permission for a file which\nyou named on the command line.\n\n(F) You tried to call perl with the B<-e> switch, but F</dev/null> (or\nyour operating system's equivalent) could not be opened.\n\n=item Can't open a reference\n\n(W io) You tried to open a scalar reference for reading or writing,\nusing the 3-arg open() syntax:\n\n    open FH, '>', $ref;\n\nbut your version of perl is compiled without perlio, and this form of\nopen is not supported.\n\n=item Can't open bidirectional pipe\n\n(W pipe) You tried to say C<open(CMD, \"|cmd|\")>, which is not supported.\nYou can try any of several modules in the Perl library to do this, such\nas IPC::Open2.  Alternately, direct the pipe's output to a file using\n\">\", and then read it in under a different file handle.\n\n=item Can't open error file %s as stderr\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the file specified after '2>' or '2>>' on\nthe command line for writing.\n\n=item Can't open input file %s as stdin\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the file specified after '<' on the\ncommand line for reading.\n\n=item Can't open output file %s as stdout\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the file specified after '>' or '>>' on\nthe command line for writing.\n\n=item Can't open output pipe (name: %s)\n\n(P) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the pipe into which to send data destined\nfor stdout.\n\n=item Can't open perl script \"%s\": %s\n\n(F) The script you specified can't be opened for the indicated reason.\n\nIf you're debugging a script that uses #!, and normally relies on the\nshell's $PATH search, the -S option causes perl to do that search, so\nyou don't have to type the path or C<`which $scriptname`>.\n\n=item Can't read CRTL environ\n\n(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV\nfrom the CRTL's internal environment array and discovered the array was\nmissing.  You need to figure out where your CRTL misplaced its environ\nor define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not\nsearched.\n\n=item Can't redeclare \"%s\" in \"%s\"\n\n(F) A \"my\", \"our\" or \"state\" declaration was found within another declaration,\nsuch as C<my ($x, my($y), $z)> or C<our (my $x)>.\n\n=item Can't \"redo\" outside a loop block\n\n(F) A \"redo\" statement was executed to restart the current block, but\nthere isn't a current block.  Note that an \"if\" or \"else\" block doesn't\ncount as a \"loopish\" block, as doesn't a block given to sort(), map()\nor grep().  You can usually double the curlies to get the same effect\nthough, because the inner curlies will be considered a block that\nloops once.  See L<perlfunc/redo>.\n\n=item Can't remove %s: %s, skipping file\n\n(S inplace) You requested an inplace edit without creating a backup\nfile.  Perl was unable to remove the original file to replace it with\nthe modified file.  The file was left unmodified.\n\n=item Can't rename in-place work file '%s' to '%s': %s\n\n(F) When closed implicitly, the temporary file for in-place editing\ncouldn't be renamed to the original filename.\n\n=item Can't rename %s to %s: %s, skipping file\n\n(F) The rename done by the B<-i> switch failed for some reason,\nprobably because you don't have write permission to the directory.\n\n=item Can't reopen input pipe (name: %s) in binary mode\n\n(P) An error peculiar to VMS.  Perl thought stdin was a pipe, and tried\nto reopen it to accept binary data.  Alas, it failed.\n\n=item Can't represent character for Ox%X on this platform\n\n(F) There is a hard limit to how big a character code point can be due\nto the fundamental properties of UTF-8, especially on EBCDIC\nplatforms.  The given code point exceeds that.  The only work-around is\nto not use such a large code point.\n\n=item Can't reset %ENV on this system\n\n(F) You called C<reset('E')> or similar, which tried to reset\nall variables in the current package beginning with \"E\".  In\nthe main package, that includes %ENV.  Resetting %ENV is not\nsupported on some systems, notably VMS.\n\n=item Can't resolve method \"%s\" overloading \"%s\" in package \"%s\"\n\n(F)(P) Error resolving overloading specified by a method name (as\nopposed to a subroutine reference): no such method callable via the\npackage.  If the method name is C<???>, this is an internal error.\n\n=item Can't return %s from lvalue subroutine\n\n(F) Perl detected an attempt to return illegal lvalues (such as\ntemporary or readonly values) from a subroutine used as an lvalue.  This\nis not allowed.\n\n=item Can't return outside a subroutine\n\n(F) The return statement was executed in mainline code, that is, where\nthere was no subroutine call to return out of.  See L<perlsub>.\n\n=item Can't return %s to lvalue scalar context\n\n(F) You tried to return a complete array or hash from an lvalue\nsubroutine, but you called the subroutine in a way that made Perl\nthink you meant to return only one value.  You probably meant to\nwrite parentheses around the call to the subroutine, which tell\nPerl that the call should be in list context.\n\n=item Can't stat script \"%s\"\n\n(P) For some reason you can't fstat() the script even though you have it\nopen already.  Bizarre.\n\n=item Can't take log of %g\n\n(F) For ordinary real numbers, you can't take the logarithm of a\nnegative number or zero.  There's a Math::Complex package that comes\nstandard with Perl, though, if you really want to do that for the\nnegative numbers.\n\n=item Can't take sqrt of %g\n\n(F) For ordinary real numbers, you can't take the square root of a\nnegative number.  There's a Math::Complex package that comes standard\nwith Perl, though, if you really want to do that.\n\n=item Can't undef active subroutine\n\n(F) You can't undefine a routine that's currently running.  You can,\nhowever, redefine it while it's running, and you can even undef the\nredefined subroutine while the old routine is running.  Go figure.\n\n=item Can't unweaken a nonreference\n\n(F) You attempted to unweaken something that was not a reference.  Only\nreferences can be unweakened.\n\n=item Can't upgrade %s (%d) to %d\n\n(P) The internal sv_upgrade routine adds \"members\" to an SV, making it\ninto a more specialized kind of SV.  The top several SV types are so\nspecialized, however, that they cannot be interconverted.  This message\nindicates that such a conversion was attempted.\n\n=item Can't use '%c' after -mname\n\n(F) You tried to call perl with the B<-m> switch, but you put something\nother than \"=\" after the module name.\n\n=item Can't use a hash as a reference\n\n(F) You tried to use a hash as a reference, as in\nC<< %foo->{\"bar\"} >> or C<< %$ref->{\"hello\"} >>.  Versions of perl\n<= 5.22.0 used to allow this syntax, but shouldn't\nhave.  This was deprecated in perl 5.6.1.\n\n=item Can't use an array as a reference\n\n(F) You tried to use an array as a reference, as in\nC<< @foo->[23] >> or C<< @$ref->[99] >>.  Versions of perl <= 5.22.0\nused to allow this syntax, but shouldn't have.  This\nwas deprecated in perl 5.6.1.\n\n=item Can't use anonymous symbol table for method lookup\n\n(F) The internal routine that does method lookup was handed a symbol\ntable that doesn't have a name.  Symbol tables can become anonymous\nfor example by undefining stashes: C<undef %Some::Package::>.\n\n=item Can't use an undefined value as %s reference\n\n(F) A value used as either a hard reference or a symbolic reference must\nbe a defined value.  This helps to delurk some insidious errors.\n\n=item Can't use bareword (\"%s\") as %s ref while \"strict refs\" in use\n\n(F) Only hard references are allowed by \"strict refs\".  Symbolic\nreferences are disallowed.  See L<perlref>.\n\n=item Can't use %! because Errno.pm is not available\n\n(F) The first time the C<%!> hash is used, perl automatically loads the\nErrno.pm module.  The Errno module is expected to tie the %! hash to\nprovide symbolic names for C<$!> errno values.\n\n=item Can't use both '<' and '>' after type '%c' in %s\n\n(F) A type cannot be forced to have both big-endian and little-endian\nbyte-order at the same time, so this combination of modifiers is not\nallowed.  See L<perlfunc/pack>.\n\n=item Can't use 'defined(@array)' (Maybe you should just omit the defined()?)\n\n(F) defined() is not useful on arrays because it\nchecks for an undefined I<scalar> value.  If you want to see if the\narray is empty, just use C<if (@array) { # not empty }> for example.\n\n=item Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)\n\n(F) C<defined()> is not usually right on hashes.\n\nAlthough C<defined %hash> is false on a plain not-yet-used hash, it\nbecomes true in several non-obvious circumstances, including iterators,\nweak references, stash names, even remaining true after C<undef %hash>.\nThese things make C<defined %hash> fairly useless in practice, so it now\ngenerates a fatal error.\n\nIf a check for non-empty is what you wanted then just put it in boolean\ncontext (see L<perldata/Scalar values>):\n\n    if (%hash) {\n       # not empty\n    }\n\nIf you had C<defined %Foo::Bar::QUUX> to check whether such a package\nvariable exists then that's never really been reliable, and isn't\na good way to enquire about the features of a package, or whether\nit's loaded, etc.\n\n=item Can't use %s for loop variable\n\n(P) The parser got confused when trying to parse a C<foreach> loop.\n\n=item Can't use global %s in \"%s\"\n\n(F) You tried to declare a magical variable as a lexical variable.  This\nis not allowed, because the magic can be tied to only one location\n(namely the global variable) and it would be incredibly confusing to\nhave variables in your program that looked like magical variables but\nweren't.\n\n=item Can't use '%c' in a group with different byte-order in %s\n\n(F) You attempted to force a different byte-order on a type\nthat is already inside a group with a byte-order modifier.\nFor example you cannot force little-endianness on a type that\nis inside a big-endian group.\n\n=item Can't use \"my %s\" in sort comparison\n\n(F) The global variables $a and $b are reserved for sort comparisons.\nYou mentioned $a or $b in the same line as the <=> or cmp operator,\nand the variable had earlier been declared as a lexical variable.\nEither qualify the sort variable with the package name, or rename the\nlexical variable.\n\n=item Can't use %s ref as %s ref\n\n(F) You've mixed up your reference types.  You have to dereference a\nreference of the type needed.  You can use the ref() function to\ntest the type of the reference, if need be.\n\n=item Can't use string (\"%s\") as %s ref while \"strict refs\" in use\n\n=item Can't use string (\"%s\"...) as %s ref while \"strict refs\" in use\n\n(F) You've told Perl to dereference a string, something which\nC<use strict> blocks to prevent it happening accidentally.  See\nL<perlref/\"Symbolic references\">.  This can be triggered by an C<@> or C<$>\nin a double-quoted string immediately before interpolating a variable,\nfor example in C<\"user @$twitter_id\">, which says to treat the contents\nof C<$twitter_id> as an array reference; use a C<\\> to have a literal C<@>\nsymbol followed by the contents of C<$twitter_id>: C<\"user \\@$twitter_id\">.\n\n=item Can't use subscript on %s\n\n(F) The compiler tried to interpret a bracketed expression as a\nsubscript.  But to the left of the brackets was an expression that\ndidn't look like a hash or array reference, or anything else subscriptable.\n\n=item Can't use \\%c to mean $%c in expression\n\n(W syntax) In an ordinary expression, backslash is a unary operator that\ncreates a reference to its argument.  The use of backslash to indicate a\nbackreference to a matched substring is valid only as part of a regular\nexpression pattern.  Trying to do this in ordinary Perl code produces a\nvalue that prints out looking like SCALAR(0xdecaf).  Use the $1 form\ninstead.\n\n=item Can't weaken a nonreference\n\n(F) You attempted to weaken something that was not a reference.  Only\nreferences can be weakened.\n\n=item Can't \"when\" outside a topicalizer\n\n(F) You have used a when() block that is neither inside a C<foreach>\nloop nor a C<given> block.  (Note that this error is issued on exit\nfrom the C<when> block, so you won't get the error if the match fails,\nor if you use an explicit C<continue>.)\n\n=item Can't x= to read-only value\n\n(F) You tried to repeat a constant value (often the undefined value)\nwith an assignment operator, which implies modifying the value itself.\nPerhaps you need to copy the value to a temporary, and repeat that.\n\n=item Character following \"\\c\" must be printable ASCII\n\n(F) In C<\\cI<X>>, I<X> must be a printable (non-control) ASCII character.\n\nNote that ASCII characters that don't map to control characters are\ndiscouraged, and will generate the warning (when enabled)\nL</\"\"\\c%c\" is more clearly written simply as \"%s\"\">.\n\n=item Character following \\%c must be '{' or a single-character Unicode property name in regex; marked by <-- HERE in m/%s/\n\n(F) (In the above the C<%c> is replaced by either C<p> or C<P>.)  You\nspecified something that isn't a legal Unicode property name.  Most\nUnicode properties are specified by C<\\p{...}>.  But if the name is a\nsingle character one, the braces may be omitted.\n\n=item Character in 'C' format wrapped in pack\n\n(W pack) You said\n\n    pack(\"C\", $x)\n\nwhere $x is either less than 0 or more than 255; the C<\"C\"> format is\nonly for encoding native operating system characters (ASCII, EBCDIC,\nand so on) and not for Unicode characters, so Perl behaved as if you meant\n\n    pack(\"C\", $x & 255)\n\nIf you actually want to pack Unicode codepoints, use the C<\"U\"> format\ninstead.\n\n=item Character in 'c' format wrapped in pack\n\n(W pack) You said\n\n    pack(\"c\", $x)\n\nwhere $x is either less than -128 or more than 127; the C<\"c\"> format\nis only for encoding native operating system characters (ASCII, EBCDIC,\nand so on) and not for Unicode characters, so Perl behaved as if you meant\n\n    pack(\"c\", $x & 255);\n\nIf you actually want to pack Unicode codepoints, use the C<\"U\"> format\ninstead.\n\n=item Character in '%c' format wrapped in unpack\n\n(W unpack) You tried something like\n\n   unpack(\"H\", \"\\x{2a1}\")\n\nwhere the format expects to process a byte (a character with a value\nbelow 256), but a higher value was provided instead.  Perl uses the\nvalue modulus 256 instead, as if you had provided:\n\n   unpack(\"H\", \"\\x{a1}\")\n\n=item Character in 'W' format wrapped in pack\n\n(W pack) You said\n\n    pack(\"U0W\", $x)\n\nwhere $x is either less than 0 or more than 255.  However, C<U0>-mode\nexpects all values to fall in the interval [0, 255], so Perl behaved\nas if you meant:\n\n    pack(\"U0W\", $x & 255)\n\n=item Character(s) in '%c' format wrapped in pack\n\n(W pack) You tried something like\n\n   pack(\"u\", \"\\x{1f3}b\")\n\nwhere the format expects to process a sequence of bytes (character with a\nvalue below 256), but some of the characters had a higher value.  Perl\nuses the character values modulus 256 instead, as if you had provided:\n\n   pack(\"u\", \"\\x{f3}b\")\n\n=item Character(s) in '%c' format wrapped in unpack\n\n(W unpack) You tried something like\n\n   unpack(\"s\", \"\\x{1f3}b\")\n\nwhere the format expects to process a sequence of bytes (character with a\nvalue below 256), but some of the characters had a higher value.  Perl\nuses the character values modulus 256 instead, as if you had provided:\n\n   unpack(\"s\", \"\\x{f3}b\")\n\n=item charnames alias definitions may not contain a sequence of multiple\nspaces; marked by S<<-- HERE> in %s\n\n(F) You defined a character name which had multiple space characters\nin a row.  Change them to single spaces.  Usually these names are\ndefined in the C<:alias> import argument to C<use charnames>, but they\ncould be defined by a translator installed into C<$^H{charnames}>.  See\nL<charnames/CUSTOM ALIASES>.\n\n=item charnames alias definitions may not contain trailing white-space;\nmarked by S<<-- HERE> in %s\n\n(F) You defined a character name which ended in a space\ncharacter.  Remove the trailing space(s).  Usually these names are\ndefined in the C<:alias> import argument to C<use charnames>, but they\ncould be defined by a translator installed into C<$^H{charnames}>.\nSee L<charnames/CUSTOM ALIASES>.\n\n=item chdir() on unopened filehandle %s\n\n(W unopened) You tried chdir() on a filehandle that was never opened.\n\n=item \"\\c%c\" is more clearly written simply as \"%s\"\n\n(W syntax) The C<\\cI<X>> construct is intended to be a way to specify\nnon-printable characters.  You used it for a printable one, which\nis better written as simply itself, perhaps preceded by a backslash\nfor non-word characters.  Doing it the way you did is not portable\nbetween ASCII and EBCDIC platforms.\n\n=item Cloning substitution context is unimplemented\n\n(F) Creating a new thread inside the C<s///> operator is not supported.\n\n=item closedir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you tried to close is either closed or not really\na dirhandle.  Check your control flow.\n\n=item close() on unopened filehandle %s\n\n(W unopened) You tried to close a filehandle that was never opened.\n\n=item Closure prototype called\n\n(F) If a closure has attributes, the subroutine passed to an attribute\nhandler is the prototype that is cloned when a new closure is created.\nThis subroutine cannot be called.\n\n=item \\C no longer supported in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The \\C character class used to allow a match of single byte\nwithin a multi-byte utf-8 character, but was removed in v5.24 as\nit broke encapsulation and its implementation was extremely buggy.\nIf you really need to process the individual bytes, you probably\nwant to convert your string to one where each underlying byte is\nstored as a character, with utf8::encode().\n\n=item Code missing after '/'\n\n(F) You had a (sub-)template that ends with a '/'.  There must be\nanother template code following the slash.  See L<perlfunc/pack>.\n\n=item Code point 0x%X is not Unicode, and not portable\n\n(S non_unicode) You had a code point that has never been in any\nstandard, so it is likely that languages other than Perl will NOT\nunderstand it.  At one time, it was legal in some standards to have code\npoints up to 0x7FFF_FFFF, but not higher, and this code point is higher.\n\nAcceptance of these code points is a Perl extension, and you should\nexpect that nothing other than Perl can handle them; Perl itself on\nEBCDIC platforms before v5.24 does not handle them.\n\nCode points above 0xFFFF_FFFF require larger than a 32 bit word.\n\nPerl also makes no guarantees that the representation of these code\npoints won't change at some point in the future, say when machines\nbecome available that have larger than a 64-bit word.  At that time,\nfiles written by an older Perl would require conversion before being\nreadable by a newer Perl.\n\n=item Code point 0x%X is not Unicode, may not be portable\n\n(S non_unicode) You had a code point above the Unicode maximum\nof U+10FFFF.\n\nPerl allows strings to contain a superset of Unicode code points, but\nthese may not be accepted by other languages/systems.  Further, even if\nthese languages/systems accept these large code points, they may have\nchosen a different representation for them than the UTF-8-like one that\nPerl has, which would mean files are not exchangeable between them and\nPerl.\n\nOn EBCDIC platforms, code points above 0x3FFF_FFFF have a different\nrepresentation in Perl v5.24 than before, so any file containing these\nthat was written before that version will require conversion before\nbeing readable by a later Perl.\n\n=item %s: Command not found\n\n(A) You've accidentally run your script through B<csh> or another shell\ninstead of Perl.  Check the #! line, or manually feed your script into\nPerl yourself.  The #! line at the top of your file could look like\n\n  #!/usr/bin/perl\n\n=item %s: command not found\n\n(A) You've accidentally run your script through B<bash> or another shell\ninstead of Perl.  Check the #! line, or manually feed your script into\nPerl yourself.  The #! line at the top of your file could look like\n\n  #!/usr/bin/perl\n\n=item %s: command not found: %s\n\n(A) You've accidentally run your script through B<zsh> or another shell\ninstead of Perl.  Check the #! line, or manually feed your script into\nPerl yourself.  The #! line at the top of your file could look like\n\n  #!/usr/bin/perl\n\n=item Compilation failed in require\n\n(F) Perl could not compile a file specified in a C<require> statement.\nPerl uses this generic message when none of the errors that it\nencountered were severe enough to halt compilation immediately.\n\n=item Complex regular subexpression recursion limit (%d) exceeded\n\n(W regexp) The regular expression engine uses recursion in complex\nsituations where back-tracking is required.  Recursion depth is limited\nto 32766, or perhaps less in architectures where the stack cannot grow\narbitrarily.  (\"Simple\" and \"medium\" situations are handled without\nrecursion and are not subject to a limit.)  Try shortening the string\nunder examination; looping in Perl code (e.g. with C<while>) rather than\nin the regular expression engine; or rewriting the regular expression so\nthat it is simpler or backtracks less.  (See L<perlfaq2> for information\non I<Mastering Regular Expressions>.)\n\n=item connect() on closed socket %s\n\n(W closed) You tried to do a connect on a closed socket.  Did you forget\nto check the return value of your socket() call?  See\nL<perlfunc/connect>.\n\n=item Constant(%s): Call to &{$^H{%s}} did not return a defined value\n\n(F) The subroutine registered to handle constant overloading\n(see L<overload>) or a custom charnames handler (see\nL<charnames/CUSTOM TRANSLATORS>) returned an undefined value.\n\n=item Constant(%s): $^H{%s} is not defined\n\n(F) The parser found inconsistencies while attempting to define an\noverloaded constant.  Perhaps you forgot to load the corresponding\nL<overload> pragma?\n\n=item Constant is not %s reference\n\n(F) A constant value (perhaps declared using the C<use constant> pragma)\nis being dereferenced, but it amounts to the wrong type of reference.\nThe message indicates the type of reference that was expected.  This\nusually indicates a syntax error in dereferencing the constant value.\nSee L<perlsub/\"Constant Functions\"> and L<constant>.\n\n=item Constants from lexical variables potentially modified elsewhere are\ndeprecated. This will not be allowed in Perl 5.32\n\n(D deprecated) You wrote something like\n\n    my $var;\n    $sub = sub () { $var };\n\nbut $var is referenced elsewhere and could be modified after the C<sub>\nexpression is evaluated.  Either it is explicitly modified elsewhere\n(C<$var = 3>) or it is passed to a subroutine or to an operator like\nC<printf> or C<map>, which may or may not modify the variable.\n\nTraditionally, Perl has captured the value of the variable at that\npoint and turned the subroutine into a constant eligible for inlining.\nIn those cases where the variable can be modified elsewhere, this\nbreaks the behavior of closures, in which the subroutine captures\nthe variable itself, rather than its value, so future changes to the\nvariable are reflected in the subroutine's return value.\n\nThis usage is deprecated, and will no longer be allowed in Perl 5.32,\nmaking it possible to change the behavior in the future.\n\nIf you intended for the subroutine to be eligible for inlining, then\nmake sure the variable is not referenced elsewhere, possibly by\ncopying it:\n\n    my $var2 = $var;\n    $sub = sub () { $var2 };\n\nIf you do want this subroutine to be a closure that reflects future\nchanges to the variable that it closes over, add an explicit C<return>:\n\n    my $var;\n    $sub = sub () { return $var };\n\n=item Constant subroutine %s redefined\n\n(W redefine)(S) You redefined a subroutine which had previously\nbeen eligible for inlining.  See L<perlsub/\"Constant Functions\">\nfor commentary and workarounds.\n\n=item Constant subroutine %s undefined\n\n(W misc) You undefined a subroutine which had previously been eligible\nfor inlining.  See L<perlsub/\"Constant Functions\"> for commentary and\nworkarounds.\n\n=item Constant(%s) unknown\n\n(F) The parser found inconsistencies either while attempting\nto define an overloaded constant, or when trying to find the\ncharacter name specified in the C<\\N{...}> escape.  Perhaps you\nforgot to load the corresponding L<overload> pragma?\n\n=item :const is experimental\n\n(S experimental::const_attr) The \"const\" attribute is experimental.\nIf you want to use the feature, disable the warning with C<no warnings\n'experimental::const_attr'>, but know that in doing so you are taking\nthe risk that your code may break in a future Perl version.\n\n=item :const is not permitted on named subroutines\n\n(F) The \"const\" attribute causes an anonymous subroutine to be run and\nits value captured at the time that it is cloned.  Named subroutines are\nnot cloned like this, so the attribute does not make sense on them.\n\n=item Copy method did not return a reference\n\n(F) The method which overloads \"=\" is buggy.  See\nL<overload/Copy Constructor>.\n\n=item &CORE::%s cannot be called directly\n\n(F) You tried to call a subroutine in the C<CORE::> namespace\nwith C<&foo> syntax or through a reference.  Some subroutines\nin this package cannot yet be called that way, but must be\ncalled as barewords.  Something like this will work:\n\n    BEGIN { *shove = \\&CORE::push; }\n    shove @array, 1,2,3; # pushes on to @array\n\n=item CORE::%s is not a keyword\n\n(F) The CORE:: namespace is reserved for Perl keywords.\n\n=item Corrupted regexp opcode %d > %d\n\n(P) This is either an error in Perl, or, if you're using\none, your L<custom regular expression engine|perlreapi>.  If not the\nlatter, report the problem through the L<perlbug> utility.\n\n=item corrupted regexp pointers\n\n(P) The regular expression engine got confused by what the regular\nexpression compiler gave it.\n\n=item corrupted regexp program\n\n(P) The regular expression engine got passed a regexp program without a\nvalid magic number.\n\n=item Corrupt malloc ptr 0x%x at 0x%x\n\n(P) The malloc package that comes with Perl had an internal failure.\n\n=item Count after length/code in unpack\n\n(F) You had an unpack template indicating a counted-length string, but\nyou have also specified an explicit size for the string.  See\nL<perlfunc/pack>.\n\n=item Declaring references is experimental\n\n(S experimental::declared_refs) This warning is emitted if you use\na reference constructor on the right-hand side of C<my>, C<state>, C<our>, or\nC<local>.  Simply suppress the warning if you want to use the feature, but\nknow that in doing so you are taking the risk of using an experimental\nfeature which may change or be removed in a future Perl version:\n\n    no warnings \"experimental::declared_refs\";\n    use feature \"declared_refs\";\n    $fooref = my \\$foo;\n\n=for comment\nThe following are used in lib/diagnostics.t for testing two =items that\nshare the same description.  Changes here need to be propagated to there\n\n=item Deep recursion on anonymous subroutine\n\n=item Deep recursion on subroutine \"%s\"\n\n(W recursion) This subroutine has called itself (directly or indirectly)\n100 times more than it has returned.  This probably indicates an\ninfinite recursion, unless you're writing strange benchmark programs, in\nwhich case it indicates something else.\n\nThis threshold can be changed from 100, by recompiling the F<perl> binary,\nsetting the C pre-processor macro C<PERL_SUB_DEPTH_WARN> to the desired value.\n\n=item (?(DEFINE)....) does not allow branches in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used something like C<(?(DEFINE)...|..)> which is illegal.  The\nmost likely cause of this error is that you left out a parenthesis inside\nof the C<....> part.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item %s defines neither package nor VERSION--version check failed\n\n(F) You said something like \"use Module 42\" but in the Module file\nthere are neither package declarations nor a C<$VERSION>.\n\n=item delete argument is not a HASH or ARRAY element or slice\n\n(F) The argument to C<delete> must be either a hash or array element,\nsuch as:\n\n    $foo{$bar}\n    $ref->{\"susie\"}[12]\n\nor a hash or array slice, such as:\n\n    @foo[$bar, $baz, $xyzzy]\n    @{$ref->[12]}{\"susie\", \"queue\"}\n\nor a hash key/value or array index/value slice, such as:\n\n    %foo[$bar, $baz, $xyzzy]\n    %{$ref->[12]}{\"susie\", \"queue\"}\n\n=item Delimiter for here document is too long\n\n(F) In a here document construct like C<<<FOO>, the label C<FOO> is too\nlong for Perl to handle.  You have to be seriously twisted to write code\nthat triggers this error.\n\n=item Deprecated use of my() in false conditional. This will be a fatal error in Perl 5.30\n\n(D deprecated) You used a declaration similar to C<my $x if 0>.  There\nhas been a long-standing bug in Perl that causes a lexical variable\nnot to be cleared at scope exit when its declaration includes a false\nconditional.  Some people have exploited this bug to achieve a kind of\nstatic variable.  Since we intend to fix this bug, we don't want people\nrelying on this behavior.  You can achieve a similar static effect by\ndeclaring the variable in a separate block outside the function, eg\n\n    sub f { my $x if 0; return $x++ }\n\nbecomes\n\n    { my $x; sub f { return $x++ } }\n\nBeginning with perl 5.10.0, you can also use C<state> variables to have\nlexicals that are initialized only once (see L<feature>):\n\n    sub f { state $x; return $x++ }\n\nThis use of C<my()> in a false conditional has been deprecated since\nPerl 5.10, and it will become a fatal error in Perl 5.30.\n\n=item DESTROY created new reference to dead object '%s'\n\n(F) A DESTROY() method created a new reference to the object which is\njust being DESTROYed.  Perl is confused, and prefers to abort rather\nthan to create a dangling reference.\n\n=item Did not produce a valid header\n\nSee L</500 Server error>.\n\n=item %s did not return a true value\n\n(F) A required (or used) file must return a true value to indicate that\nit compiled correctly and ran its initialization code correctly.  It's\ntraditional to end such a file with a \"1;\", though any true value would\ndo.  See L<perlfunc/require>.\n\n=item (Did you mean &%s instead?)\n\n(W misc) You probably referred to an imported subroutine &FOO as $FOO or\nsome such.\n\n=item (Did you mean \"local\" instead of \"our\"?)\n\n(W shadow) Remember that \"our\" does not localize the declared global\nvariable.  You have declared it again in the same lexical scope, which\nseems superfluous.\n\n=item (Did you mean $ or @ instead of %?)\n\n(W) You probably said %hash{$key} when you meant $hash{$key} or\n@hash{@keys}.  On the other hand, maybe you just meant %hash and got\ncarried away.\n\n=item Died\n\n(F) You passed die() an empty string (the equivalent of C<die \"\">) or\nyou called it with no args and C<$@> was empty.\n\n=item Document contains no data\n\nSee L</500 Server error>.\n\n=item %s does not define %s::VERSION--version check failed\n\n(F) You said something like \"use Module 42\" but the Module did not\ndefine a C<$VERSION>.\n\n=item '/' does not take a repeat count\n\n(F) You cannot put a repeat count of any kind right after the '/' code.\nSee L<perlfunc/pack>.\n\n=item do \"%s\" failed, '.' is no longer in @INC; did you mean do \"./%s\"?\n\n(D deprecated) Previously C< do \"somefile\"; > would search the current\ndirectory for the specified file.  Since perl v5.26.0, F<.> has been\nremoved from C<@INC> by default, so this is no longer true.  To search the\ncurrent directory (and only the current directory) you can write\nC< do \"./somefile\"; >.\n\n=item Don't know how to get file name\n\n(P) C<PerlIO_getname>, a perl internal I/O function specific to VMS, was\nsomehow called on another platform.  This should not happen.\n\n=item Don't know how to handle magic of type \\%o\n\n(P) The internal handling of magical variables has been cursed.\n\n=item do_study: out of memory\n\n(P) This should have been caught by safemalloc() instead.\n\n=item (Do you need to predeclare %s?)\n\n(S syntax) This is an educated guess made in conjunction with the message\n\"%s found where operator expected\".  It often means a subroutine or module\nname is being referenced that hasn't been declared yet.  This may be\nbecause of ordering problems in your file, or because of a missing\n\"sub\", \"package\", \"require\", or \"use\" statement.  If you're referencing\nsomething that isn't defined yet, you don't actually have to define the\nsubroutine or package before the current location.  You can use an empty\n\"sub foo;\" or \"package FOO;\" to enter a \"forward\" declaration.\n\n=item dump() better written as CORE::dump(). dump() will no longer be available in Perl 5.30\n\n(D deprecated, misc) You used the obsolescent C<dump()> built-in function,\nwithout fully qualifying it as C<CORE::dump()>. Maybe it's a typo.\n\nUse of a unqualified C<dump()> was deprecated in Perl 5.8.0, and this\nwill not be available in Perl 5.30.\n\nSee L<perlfunc/dump>.\n\n=item dump is not supported\n\n(F) Your machine doesn't support dump/undump.\n\n=item Duplicate free() ignored\n\n(S malloc) An internal routine called free() on something that had\nalready been freed.\n\n=item Duplicate modifier '%c' after '%c' in %s\n\n(W unpack) You have applied the same modifier more than once after a\ntype in a pack template.  See L<perlfunc/pack>.\n\n=item elseif should be elsif\n\n(S syntax) There is no keyword \"elseif\" in Perl because Larry thinks\nit's ugly.  Your code will be interpreted as an attempt to call a method\nnamed \"elseif\" for the class returned by the following block.  This is\nunlikely to be what you want.\n\n=item Empty \\%c in regex; marked by S<<-- HERE> in m/%s/\n\n=item Empty \\%c{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) C<\\p> and C<\\P> are used to introduce a named Unicode property, as\ndescribed in L<perlunicode> and L<perlre>.  You used C<\\p> or C<\\P> in\na regular expression without specifying the property name.\n\n=item ${^ENCODING} is no longer supported\n\n(F) The special variable C<${^ENCODING}>, formerly used to implement\nthe C<encoding> pragma, is no longer supported as of Perl 5.26.0.\n\nSetting it to anything other than C<undef> is a fatal error as of Perl\n5.28.\n\n=item entering effective %s failed\n\n(F) While under the C<use filetest> pragma, switching the real and\neffective uids or gids failed.\n\n=item %ENV is aliased to %s\n\n(F) You're running under taint mode, and the C<%ENV> variable has been\naliased to another hash, so it doesn't reflect anymore the state of the\nprogram's environment.  This is potentially insecure.\n\n=item Error converting file specification %s\n\n(F) An error peculiar to VMS.  Because Perl may have to deal with file\nspecifications in either VMS or Unix syntax, it converts them to a\nsingle form when it must operate on them directly.  Either you've passed\nan invalid file specification to Perl, or you've found a case the\nconversion routines don't handle.  Drat.\n\n=item Eval-group in insecure regular expression\n\n(F) Perl detected tainted data when trying to compile a regular\nexpression that contains the C<(?{ ... })> zero-width assertion, which\nis unsafe.  See L<perlre/(?{ code })>, and L<perlsec>.\n\n=item Eval-group not allowed at runtime, use re 'eval' in regex m/%s/\n\n(F) Perl tried to compile a regular expression containing the\nC<(?{ ... })> zero-width assertion at run time, as it would when the\npattern contains interpolated values.  Since that is a security risk,\nit is not allowed.  If you insist, you may still do this by using the\nC<re 'eval'> pragma or by explicitly building the pattern from an\ninterpolated string at run time and using that in an eval().  See\nL<perlre/(?{ code })>.\n\n=item Eval-group not allowed, use re 'eval' in regex m/%s/\n\n(F) A regular expression contained the C<(?{ ... })> zero-width\nassertion, but that construct is only allowed when the C<use re 'eval'>\npragma is in effect.  See L<perlre/(?{ code })>.\n\n=item EVAL without pos change exceeded limit in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used a pattern that nested too many EVAL calls without consuming\nany text.  Restructure the pattern so that text is consumed.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Excessively long <> operator\n\n(F) The contents of a <> operator may not exceed the maximum size of a\nPerl identifier.  If you're just trying to glob a long list of\nfilenames, try using the glob() operator, or put the filenames into a\nvariable and glob that.\n\n=item exec? I'm not *that* kind of operating system\n\n(F) The C<exec> function is not implemented on some systems, e.g., Symbian\nOS.  See L<perlport>.\n\n=item %sExecution of %s aborted due to compilation errors.\n\n(F) The final summary message when a Perl compilation fails.\n\n=item exists argument is not a HASH or ARRAY element or a subroutine\n\n(F) The argument to C<exists> must be a hash or array element or a\nsubroutine with an ampersand, such as:\n\n    $foo{$bar}\n    $ref->{\"susie\"}[12]\n    &do_something\n\n=item exists argument is not a subroutine name\n\n(F) The argument to C<exists> for C<exists &sub> must be a subroutine name,\nand not a subroutine call.  C<exists &sub()> will generate this error.\n\n=item Exiting eval via %s\n\n(W exiting) You are exiting an eval by unconventional means, such as a\ngoto, or a loop control statement.\n\n=item Exiting format via %s\n\n(W exiting) You are exiting a format by unconventional means, such as a\ngoto, or a loop control statement.\n\n=item Exiting pseudo-block via %s\n\n(W exiting) You are exiting a rather special block construct (like a\nsort block or subroutine) by unconventional means, such as a goto, or a\nloop control statement.  See L<perlfunc/sort>.\n\n=item Exiting subroutine via %s\n\n(W exiting) You are exiting a subroutine by unconventional means, such\nas a goto, or a loop control statement.\n\n=item Exiting substitution via %s\n\n(W exiting) You are exiting a substitution by unconventional means, such\nas a return, a goto, or a loop control statement.\n\n=item Expecting close bracket in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You wrote something like\n\n (?13\n\nto denote a capturing group of the form\nL<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>,\nbut omitted the C<\")\">.\n\n=item Expecting '(?flags:(?[...' in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The C<(?[...])> extended character class regular expression construct\nonly allows character classes (including character class escapes like\nC<\\d>), operators, and parentheses.  The one exception is C<(?flags:...)>\ncontaining at least one flag and exactly one C<(?[...])> construct.\nThis allows a regular expression containing just C<(?[...])> to be\ninterpolated.  If you see this error message, then you probably\nhave some other C<(?...)> construct inside your character class.  See\nL<perlrecharclass/Extended Bracketed Character Classes>.\n\n=item Experimental aliasing via reference not enabled\n\n(F) To do aliasing via references, you must first enable the feature:\n\n    no warnings \"experimental::refaliasing\";\n    use feature \"refaliasing\";\n    \\$x = \\$y;\n\n=item Experimental %s on scalar is now forbidden\n\n(F) An experimental feature added in Perl 5.14 allowed C<each>, C<keys>,\nC<push>, C<pop>, C<shift>, C<splice>, C<unshift>, and C<values> to be called with a\nscalar argument.  This experiment is considered unsuccessful, and\nhas been removed.  The C<postderef> feature may meet your needs better.\n\n=item Experimental subroutine signatures not enabled\n\n(F) To use subroutine signatures, you must first enable them:\n\n    no warnings \"experimental::signatures\";\n    use feature \"signatures\";\n    sub foo ($left, $right) { ... }\n\n=item Explicit blessing to '' (assuming package main)\n\n(W misc) You are blessing a reference to a zero length string.  This has\nthe effect of blessing the reference into the package main.  This is\nusually not what you want.  Consider providing a default target package,\ne.g. bless($ref, $p || 'MyPackage');\n\n=item %s: Expression syntax\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item %s failed--call queue aborted\n\n(F) An untrapped exception was raised while executing a UNITCHECK,\nCHECK, INIT, or END subroutine.  Processing of the remainder of the\nqueue of such routines has been prematurely ended.\n\n=item Failed to close in-place work file %s: %s\n\n(F) Closing an output file from in-place editing, as with the C<-i>\ncommand-line switch, failed.\n\n=item False [] range \"%s\" in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp)(F) A character class range must start and end at a literal\ncharacter, not another character class like C<\\d> or C<[:alpha:]>.  The \"-\"\nin your false range is interpreted as a literal \"-\".  In a C<(?[...])>\nconstruct, this is an error, rather than a warning.  Consider quoting\nthe \"-\", \"\\-\".  The S<<-- HERE> shows whereabouts in the regular expression\nthe problem was discovered.  See L<perlre>.\n\n=item Fatal VMS error (status=%d) at %s, line %d\n\n(P) An error peculiar to VMS.  Something untoward happened in a VMS\nsystem service or RTL routine; Perl's exit status should provide more\ndetails.  The filename in \"at %s\" and the line number in \"line %d\" tell\nyou which section of the Perl source code is distressed.\n\n=item fcntl is not implemented\n\n(F) Your machine apparently doesn't implement fcntl().  What is this, a\nPDP-11 or something?\n\n=item FETCHSIZE returned a negative value\n\n(F) A tied array claimed to have a negative number of elements, which\nis not possible.\n\n=item Field too wide in 'u' format in pack\n\n(W pack) Each line in an uuencoded string starts with a length indicator\nwhich can't encode values above 63.  So there is no point in asking for\na line length bigger than that.  Perl will behave as if you specified\nC<u63> as the format.\n\n=item File::Glob::glob() will disappear in perl 5.30. Use File::Glob::bsd_glob() instead.\n\n(D deprecated) C<< File::Glob >> has a function called C<< glob >>, which\njust calls C<< bsd_glob >>. However, its prototype is different from the\nprototype of C<< CORE::glob >>, and hence, C<< File::Glob::glob >> should\nnot be used.\n\nC<< File::Glob::glob() >> was deprecated in perl 5.8.0. A deprecation\nmessage was issued from perl 5.26.0 onwards, and the function will\ndisappear in perl 5.30.0.\n\nCode using C<< File::Glob::glob() >> should call\nC<< File::Glob::bsd_glob() >> instead.\n\n=item Filehandle %s opened only for input\n\n(W io) You tried to write on a read-only filehandle.  If you intended\nit to be a read-write filehandle, you needed to open it with \"+<\" or\n\"+>\" or \"+>>\" instead of with \"<\" or nothing.  If you intended only to\nwrite the file, use \">\" or \">>\".  See L<perlfunc/open>.\n\n=item Filehandle %s opened only for output\n\n(W io) You tried to read from a filehandle opened only for writing, If\nyou intended it to be a read/write filehandle, you needed to open it\nwith \"+<\" or \"+>\" or \"+>>\" instead of with \">\".  If you intended only to\nread from the file, use \"<\".  See L<perlfunc/open>.  Another possibility\nis that you attempted to open filedescriptor 0 (also known as STDIN) for\noutput (maybe you closed STDIN earlier?).\n\n=item Filehandle %s reopened as %s only for input\n\n(W io) You opened for reading a filehandle that got the same filehandle id\nas STDOUT or STDERR.  This occurred because you closed STDOUT or STDERR\npreviously.\n\n=item Filehandle STDIN reopened as %s only for output\n\n(W io) You opened for writing a filehandle that got the same filehandle id\nas STDIN.  This occurred because you closed STDIN previously.\n\n=item Final $ should be \\$ or $name\n\n(F) You must now decide whether the final $ in a string was meant to be\na literal dollar sign, or was meant to introduce a variable name that\nhappens to be missing.  So you have to put either the backslash or the\nname.\n\n=item flock() on closed filehandle %s\n\n(W closed) The filehandle you're attempting to flock() got itself closed\nsome time before now.  Check your control flow.  flock() operates on\nfilehandles.  Are you attempting to call flock() on a dirhandle by the\nsame name?\n\n=item Format not terminated\n\n(F) A format must be terminated by a line with a solitary dot.  Perl got\nto the end of your file without finding such a line.\n\n=item Format %s redefined\n\n(W redefine) You redefined a format.  To suppress this warning, say\n\n    {\n\tno warnings 'redefine';\n\teval \"format NAME =...\";\n    }\n\n=item Found = in conditional, should be ==\n\n(W syntax) You said\n\n    if ($foo = 123)\n\nwhen you meant\n\n    if ($foo == 123)\n\n(or something like that).\n\n=item %s found where operator expected\n\n(S syntax) The Perl lexer knows whether to expect a term or an operator.\nIf it sees what it knows to be a term when it was expecting to see an\noperator, it gives you this warning.  Usually it indicates that an\noperator or delimiter was omitted, such as a semicolon.\n\n=item gdbm store returned %d, errno %d, key \"%s\"\n\n(S) A warning from the GDBM_File extension that a store failed.\n\n=item gethostent not implemented\n\n(F) Your C library apparently doesn't implement gethostent(), probably\nbecause if it did, it'd feel morally obligated to return every hostname\non the Internet.\n\n=item get%sname() on closed socket %s\n\n(W closed) You tried to get a socket or peer socket name on a closed\nsocket.  Did you forget to check the return value of your socket() call?\n\n=item getpwnam returned invalid UIC %#o for user \"%s\"\n\n(S) A warning peculiar to VMS.  The call to C<sys$getuai> underlying the\nC<getpwnam> operator returned an invalid UIC.\n\n=item getsockopt() on closed socket %s\n\n(W closed) You tried to get a socket option on a closed socket.  Did you\nforget to check the return value of your socket() call?  See\nL<perlfunc/getsockopt>.\n\n=item given is experimental\n\n(S experimental::smartmatch) C<given> depends on smartmatch, which\nis experimental, so its behavior may change or even be removed\nin any future release of perl.  See the explanation under\nL<perlsyn/Experimental Details on given and when>.\n\n=item Global symbol \"%s\" requires explicit package name (did you forget to\ndeclare \"my %s\"?)\n\n(F) You've said \"use strict\" or \"use strict vars\", which indicates \nthat all variables must either be lexically scoped (using \"my\" or \"state\"), \ndeclared beforehand using \"our\", or explicitly qualified to say \nwhich package the global variable is in (using \"::\").\n\n=item glob failed (%s)\n\n(S glob) Something went wrong with the external program(s) used\nfor C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a C<glob>\npattern that caused the external program to fail and exit with a\nnonzero status.  If the message indicates that the abnormal exit\nresulted in a coredump, this may also mean that your csh (C shell)\nis broken.  If so, you should change all of the csh-related variables\nin config.sh:  If you have tcsh, make the variables refer to it as\nif it were csh (e.g. C<full_csh='/usr/bin/tcsh'>); otherwise, make them\nall empty (except that C<d_csh> should be C<'undef'>) so that Perl will\nthink csh is missing.  In either case, after editing config.sh, run\nC<./Configure -S> and rebuild Perl.\n\n=item Glob not terminated\n\n(F) The lexer saw a left angle bracket in a place where it was expecting\na term, so it's looking for the corresponding right angle bracket, and\nnot finding it.  Chances are you left some needed parentheses out\nearlier in the line, and you really meant a \"less than\".\n\n=item gmtime(%f) failed\n\n(W overflow) You called C<gmtime> with a number that it could not handle:\ntoo large, too small, or NaN.  The returned value is C<undef>.\n\n=item gmtime(%f) too large\n\n(W overflow) You called C<gmtime> with a number that was larger than\nit can reliably handle and C<gmtime> probably returned the wrong\ndate.  This warning is also triggered with NaN (the special\nnot-a-number value).\n\n=item gmtime(%f) too small\n\n(W overflow) You called C<gmtime> with a number that was smaller than\nit can reliably handle and C<gmtime> probably returned the wrong date.\n\n=item Got an error from DosAllocMem\n\n(P) An error peculiar to OS/2.  Most probably you're using an obsolete\nversion of Perl, and this should not happen anyway.\n\n=item goto must have label\n\n(F) Unlike with \"next\" or \"last\", you're not allowed to goto an\nunspecified destination.  See L<perlfunc/goto>.\n\n=item Goto undefined subroutine%s\n\n(F) You tried to call a subroutine with C<goto &sub> syntax, but\nthe indicated subroutine hasn't been defined, or if it was, it\nhas since been undefined.\n\n=item Group name must start with a non-digit word character in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) Group names must follow the rules for perl identifiers, meaning\nthey must start with a non-digit word character.  A common cause of\nthis error is using (?&0) instead of (?0).  See L<perlre>.\n\n=item ()-group starts with a count\n\n(F) A ()-group started with a count.  A count is supposed to follow\nsomething: a template character or a ()-group.  See L<perlfunc/pack>.\n\n=item %s had compilation errors.\n\n(F) The final summary message when a C<perl -c> fails.\n\n=item Had to create %s unexpectedly\n\n(S internal) A routine asked for a symbol from a symbol table that ought\nto have existed already, but for some reason it didn't, and had to be\ncreated on an emergency basis to prevent a core dump.\n\n=item %s has too many errors\n\n(F) The parser has given up trying to parse the program after 10 errors.\nFurther error messages would likely be uninformative.\n\n=item Hexadecimal float: exponent overflow\n\n(W overflow) The hexadecimal floating point has a larger exponent\nthan the floating point supports.\n\n=item Hexadecimal float: exponent underflow\n\n(W overflow) The hexadecimal floating point has a smaller exponent\nthan the floating point supports.  With the IEEE 754 floating point,\nthis may also mean that the subnormals (formerly known as denormals)\nare being used, which may or may not be an error.\n\n=item Hexadecimal float: internal error (%s)\n\n(F) Something went horribly bad in hexadecimal float handling.\n\n=item Hexadecimal float: mantissa overflow\n\n(W overflow) The hexadecimal floating point literal had more bits in\nthe mantissa (the part between the 0x and the exponent, also known as\nthe fraction or the significand) than the floating point supports.\n\n=item Hexadecimal float: precision loss\n\n(W overflow) The hexadecimal floating point had internally more\ndigits than could be output.  This can be caused by unsupported\nlong double formats, or by 64-bit integers not being available\n(needed to retrieve the digits under some configurations).\n\n=item Hexadecimal float: unsupported long double format\n\n(F) You have configured Perl to use long doubles but\nthe internals of the long double format are unknown;\ntherefore the hexadecimal float output is impossible.\n\n=item Hexadecimal number > 0xffffffff non-portable\n\n(W portable) The hexadecimal number you specified is larger than 2**32-1\n(4294967295) and therefore non-portable between systems.  See\nL<perlport> for more on portability concerns.\n\n=item Identifier too long\n\n(F) Perl limits identifiers (names for variables, functions, etc.) to\nabout 250 characters for simple names, and somewhat more for compound\nnames (like C<$A::B>).  You've exceeded Perl's limits.  Future versions\nof Perl are likely to eliminate these arbitrary limitations.\n\n=item Ignoring zero length \\N{} in character class in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) Named Unicode character escapes (C<\\N{...}>) may return a\nzero-length sequence.  When such an escape is used in a character\nclass its behavior is not well defined.  Check that the correct\nescape has been used, and the correct charname handler is in scope.\n\n=item Illegal binary digit '%c'\n\n(F) You used a digit other than 0 or 1 in a binary number.\n\n=item Illegal binary digit %s ignored\n\n(W digit) You may have tried to use a digit other than 0 or 1 in a\nbinary number.  Interpretation of the binary number stopped before the\noffending digit.\n\n=item Illegal character after '_' in prototype for %s : %s\n\n(W illegalproto) An illegal character was found in a prototype\ndeclaration.  The '_' in a prototype must be followed by a ';',\nindicating the rest of the parameters are optional, or one of '@'\nor '%', since those two will accept 0 or more final parameters.\n\n=item Illegal character \\%o (carriage return)\n\n(F) Perl normally treats carriage returns in the program text as\nit would any other whitespace, which means you should never see\nthis error when Perl was built using standard options.  For some\nreason, your version of Perl appears to have been built without\nthis support.  Talk to your Perl administrator.\n\n=item Illegal character following sigil in a subroutine signature\n\n(F) A parameter in a subroutine signature contained an unexpected character\nfollowing the C<$>, C<@> or C<%> sigil character.  Normally the sigil\nshould be followed by the variable name or C<=> etc.  Perhaps you are\ntrying use a prototype while in the scope of C<use feature 'signatures'>?\nFor example:\n\n    sub foo ($$) {}            # legal - a prototype\n\n    use feature 'signatures;\n    sub foo ($$) {}            # illegal - was expecting a signature\n    sub foo ($a, $b)\n            :prototype($$) {}  # legal\n\n\n=item Illegal character in prototype for %s : %s\n\n(W illegalproto) An illegal character was found in a prototype declaration.\nLegal characters in prototypes are $, @, %, *, ;, [, ], &, \\, and +.\nPerhaps you were trying to write a subroutine signature but didn't enable\nthat feature first (C<use feature 'signatures'>), so your signature was\ninstead interpreted as a bad prototype.\n\n=item Illegal declaration of anonymous subroutine\n\n(F) When using the C<sub> keyword to construct an anonymous subroutine,\nyou must always specify a block of code.  See L<perlsub>.\n\n=item Illegal declaration of subroutine %s\n\n(F) A subroutine was not declared correctly.  See L<perlsub>.\n\n=item Illegal division by zero\n\n(F) You tried to divide a number by 0.  Either something was wrong in\nyour logic, or you need to put a conditional in to guard against\nmeaningless input.\n\n=item Illegal hexadecimal digit %s ignored\n\n(W digit) You may have tried to use a character other than 0 - 9 or\nA - F, a - f in a hexadecimal number.  Interpretation of the hexadecimal\nnumber stopped before the illegal character.\n\n=item Illegal modulus zero\n\n(F) You tried to divide a number by 0 to get the remainder.  Most\nnumbers don't take to this kindly.\n\n=item Illegal number of bits in vec\n\n(F) The number of bits in vec() (the third argument) must be a power of\ntwo from 1 to 32 (or 64, if your platform supports that).\n\n=item Illegal octal digit '%c'\n\n(F) You used an 8 or 9 in an octal number.\n\n=item Illegal octal digit %s ignored\n\n(W digit) You may have tried to use an 8 or 9 in an octal number.\nInterpretation of the octal number stopped before the 8 or 9.\n\n=item Illegal operator following parameter in a subroutine signature\n\n(F) A parameter in a subroutine signature, was followed by something\nother than C<=> introducing a default, C<,> or C<)>.\n\n    use feature 'signatures';\n    sub foo ($=1) {}           # legal\n    sub foo ($a = 1) {}        # legal\n    sub foo ($a += 1) {}       # illegal\n    sub foo ($a == 1) {}       # illegal\n\n=item Illegal pattern in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You wrote something like\n\n (?+foo)\n\nThe C<\"+\"> is valid only when followed by digits, indicating a\ncapturing group.  See\nL<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>.\n\n=item Illegal suidscript\n\n(F) The script run under suidperl was somehow illegal.\n\n=item Illegal switch in PERL5OPT: -%c\n\n(X) The PERL5OPT environment variable may only be used to set the\nfollowing switches: B<-[CDIMUdmtw]>.\n\n=item Illegal user-defined property name\n\n(F) You specified a Unicode-like property name in a regular expression\npattern (using C<\\p{}> or C<\\P{}>) that Perl knows isn't an official\nUnicode property, and was likely meant to be a user-defined property\nname, but it can't be one of those, as they must begin with either C<In>\nor C<Is>.  Check the spelling.  See also\nL</Can't find Unicode property definition \"%s\">.\n\n=item Ill-formed CRTL environ value \"%s\"\n\n(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's\ninternal environ array, and encountered an element without the C<=>\ndelimiter used to separate keys from values.  The element is ignored.\n\n=item Ill-formed message in prime_env_iter: |%s|\n\n(W internal) A warning peculiar to VMS.  Perl tried to read a logical\nname or CLI symbol definition when preparing to iterate over %ENV, and\ndidn't see the expected delimiter between key and value, so the line was\nignored.\n\n=item (in cleanup) %s\n\n(W misc) This prefix usually indicates that a DESTROY() method raised\nthe indicated exception.  Since destructors are usually called by the\nsystem at arbitrary points during execution, and often a vast number of\ntimes, the warning is issued only once for any number of failures that\nwould otherwise result in the same message being repeated.\n\nFailure of user callbacks dispatched using the C<G_KEEPERR> flag could\nalso result in this warning.  See L<perlcall/G_KEEPERR>.\n\n=item Incomplete expression within '(?[ ])' in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) There was a syntax error within the C<(?[ ])>.  This can happen if the\nexpression inside the construct was completely empty, or if there are\ntoo many or few operands for the number of operators.  Perl is not smart\nenough to give you a more precise indication as to what is wrong.\n\n=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on \nparent '%s'\n\n(F) The method resolution order (MRO) of the given class is not\nC3-consistent, and you have enabled the C3 MRO for this class.  See the C3\ndocumentation in L<mro> for more information.\n\n=item Indentation on line %d of here-doc doesn't match delimiter\n\n(F) You have an indented here-document where one or more of its lines\nhave whitespace at the beginning that does not match the closing\ndelimiter.\n\nFor example, line 2 below is wrong because it does not have at least\n2 spaces, but lines 1 and 3 are fine because they have at least 2:\n\n    if ($something) {\n      print <<~EOF;\n        Line 1\n       Line 2 not\n          Line 3\n        EOF\n    }\n\nNote that tabs and spaces are compared strictly, meaning 1 tab will\nnot match 8 spaces.\n\n=item Infinite recursion in regex\n\n(F) You used a pattern that references itself without consuming any input\ntext.  You should check the pattern to ensure that recursive patterns\neither consume text or fail.\n\n=item Infinite recursion via empty pattern\n\n(F) You tried to use the empty pattern inside of a regex code block,\nfor instance C</(?{ s!!! })/>, which resulted in re-executing\nthe same pattern, which is an infinite loop which is broken by\nthrowing an exception.\n\n=item Initialization of state variables in list currently forbidden\n\n(F) C<state> only permits initializing a single variable, specified\nwithout parentheses.  So C<state $a = 42> and C<state @a = qw(a b c)> are\nallowed, but not C<state ($a) = 42> or C<(state $a) = 42>.  To initialize\nmore than one C<state> variable, initialize them one at a time.\n\n=item %%s[%s] in scalar context better written as $%s[%s]\n\n(W syntax) In scalar context, you've used an array index/value slice\n(indicated by %) to select a single element of an array.  Generally\nit's better to ask for a scalar value (indicated by $).  The difference\nis that C<$foo[&bar]> always behaves like a scalar, both in the value it\nreturns and when evaluating its argument, while C<%foo[&bar]> provides\na list context to its subscript, which can do weird things if you're\nexpecting only one subscript.  When called in list context, it also\nreturns the index (what C<&bar> returns) in addition to the value.\n\n=item %%s{%s} in scalar context better written as $%s{%s}\n\n(W syntax) In scalar context, you've used a hash key/value slice\n(indicated by %) to select a single element of a hash.  Generally it's\nbetter to ask for a scalar value (indicated by $).  The difference\nis that C<$foo{&bar}> always behaves like a scalar, both in the value\nit returns and when evaluating its argument, while C<@foo{&bar}> and\nprovides a list context to its subscript, which can do weird things\nif you're expecting only one subscript.  When called in list context,\nit also returns the key in addition to the value.\n\n=item Insecure dependency in %s\n\n(F) You tried to do something that the tainting mechanism didn't like.\nThe tainting mechanism is turned on when you're running setuid or\nsetgid, or when you specify B<-T> to turn it on explicitly.  The\ntainting mechanism labels all data that's derived directly or indirectly\nfrom the user, who is considered to be unworthy of your trust.  If any\nsuch data is used in a \"dangerous\" operation, you get this error.  See\nL<perlsec> for more information.\n\n=item Insecure directory in %s\n\n(F) You can't use system(), exec(), or a piped open in a setuid or\nsetgid script if C<$ENV{PATH}> contains a directory that is writable by\nthe world.  Also, the PATH must not contain any relative directory.\nSee L<perlsec>.\n\n=item Insecure $ENV{%s} while running %s\n\n(F) You can't use system(), exec(), or a piped open in a setuid or\nsetgid script if any of C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>,\nC<$ENV{ENV}>, C<$ENV{BASH_ENV}> or C<$ENV{TERM}> are derived from data\nsupplied (or potentially supplied) by the user.  The script must set\nthe path to a known value, using trustworthy data.  See L<perlsec>.\n\n=item Insecure user-defined property %s\n\n(F) Perl detected tainted data when trying to compile a regular\nexpression that contains a call to a user-defined character property\nfunction, i.e. C<\\p{IsFoo}> or C<\\p{InFoo}>.\nSee L<perlunicode/User-Defined Character Properties> and L<perlsec>.\n\n=item Integer overflow in format string for %s\n\n(F) The indexes and widths specified in the format string of C<printf()>\nor C<sprintf()> are too large.  The numbers must not overflow the size of\nintegers for your architecture.\n\n=item Integer overflow in %s number\n\n(S overflow) The hexadecimal, octal or binary number you have specified\neither as a literal or as an argument to hex() or oct() is too big for\nyour architecture, and has been converted to a floating point number.\nOn a 32-bit architecture the largest hexadecimal, octal or binary number\nrepresentable without overflow is 0xFFFFFFFF, 037777777777, or\n0b11111111111111111111111111111111 respectively.  Note that Perl\ntransparently promotes all numbers to a floating point representation\ninternally--subject to loss of precision errors in subsequent\noperations.\n\n=item Integer overflow in srand\n\n(S overflow) The number you have passed to srand is too big to fit\nin your architecture's integer representation.  The number has been\nreplaced with the largest integer supported (0xFFFFFFFF on 32-bit\narchitectures).  This means you may be getting less randomness than\nyou expect, because different random seeds above the maximum will\nreturn the same sequence of random numbers.\n\n=item Integer overflow in version\n\n=item Integer overflow in version %d\n\n(W overflow) Some portion of a version initialization is too large for\nthe size of integers for your architecture.  This is not a warning\nbecause there is no rational reason for a version to try and use an\nelement larger than typically 2**32.  This is usually caused by trying\nto use some odd mathematical operation as a version, like 100/9.\n\n=item Internal disaster in regex; marked by S<<-- HERE> in m/%s/\n\n(P) Something went badly wrong in the regular expression parser.\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Internal inconsistency in tracking vforks\n\n(S) A warning peculiar to VMS.  Perl keeps track of the number of times\nyou've called C<fork> and C<exec>, to determine whether the current call\nto C<exec> should affect the current script or a subprocess (see\nL<perlvms/\"exec LIST\">).  Somehow, this count has become scrambled, so\nPerl is making a guess and treating this C<exec> as a request to\nterminate the Perl script and execute the specified command.\n\n=item internal %<num>p might conflict with future printf extensions\n\n(S internal) Perl's internal routine that handles C<printf> and C<sprintf>\nformatting follows a slightly different set of rules when called from\nC or XS code.  Specifically, formats consisting of digits followed\nby \"p\" (e.g., \"%7p\") are reserved for future use.  If you see this\nmessage, then an XS module tried to call that routine with one such\nreserved format.\n\n=item Internal urp in regex; marked by S<<-- HERE> in m/%s/\n\n(P) Something went badly awry in the regular expression parser.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item %s (...) interpreted as function\n\n(W syntax) You've run afoul of the rule that says that any list operator\nfollowed by parentheses turns into a function, with all the list\noperators arguments found inside the parentheses.  See\nL<perlop/Terms and List Operators (Leftward)>.\n\n=item In '(?...)', the '(' and '?' must be adjacent in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The two-character sequence C<\"(?\"> in this context in a regular\nexpression pattern should be an indivisible token, with nothing\nintervening between the C<\"(\"> and the C<\"?\">, but you separated them\nwith whitespace.\n\n=item Invalid %s attribute: %s\n\n(F) The indicated attribute for a subroutine or variable was not recognized\nby Perl or by a user-supplied handler.  See L<attributes>.\n\n=item Invalid %s attributes: %s\n\n(F) The indicated attributes for a subroutine or variable were not\nrecognized by Perl or by a user-supplied handler.  See L<attributes>.\n\n=item Invalid character in charnames alias definition; marked by\nS<<-- HERE> in '%s\n\n(F) You tried to create a custom alias for a character name, with\nthe C<:alias> option to C<use charnames> and the specified character in\nthe indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.\n\n=item Invalid \\0 character in %s for %s: %s\\0%s\n\n(W syscalls) Embedded \\0 characters in pathnames or other system call\narguments produce a warning as of 5.20.  The parts after the \\0 were\nformerly ignored by system calls.\n\n=item Invalid character in \\N{...}; marked by S<<-- HERE> in \\N{%s}\n\n(F) Only certain characters are valid for character names.  The\nindicated one isn't.  See L<charnames/CUSTOM ALIASES>.\n\n=item Invalid conversion in %s: \"%s\"\n\n(W printf) Perl does not understand the given format conversion.  See\nL<perlfunc/sprintf>.\n\n=item Invalid escape in the specified encoding in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp)(F) The numeric escape (for example C<\\xHH>) of value < 256\ndidn't correspond to a single character through the conversion\nfrom the encoding specified by the encoding pragma.\nThe escape was replaced with REPLACEMENT CHARACTER (U+FFFD)\ninstead, except within S<C<(?[   ])>>, where it is a fatal error.\nThe S<<-- HERE> shows whereabouts in the regular expression the\nescape was discovered.\n\n=item Invalid hexadecimal number in \\N{U+...}\n\n=item Invalid hexadecimal number in \\N{U+...} in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) The character constant represented by C<...> is not a valid hexadecimal\nnumber.  Either it is empty, or you tried to use a character other than\n0 - 9 or A - F, a - f in a hexadecimal number.\n\n=item Invalid module name %s with -%c option: contains single ':'\n\n(F) The module argument to perl's B<-m> and B<-M> command-line options\ncannot contain single colons in the module name, but only in the\narguments after \"=\".  In other words, B<-MFoo::Bar=:baz> is ok, but\nB<-MFoo:Bar=baz> is not.\n\n=item Invalid mro name: '%s'\n\n(F) You tried to C<mro::set_mro(\"classname\", \"foo\")> or C<use mro 'foo'>,\nwhere C<foo> is not a valid method resolution order (MRO).  Currently,\nthe only valid ones supported are C<dfs> and C<c3>, unless you have loaded\na module that is a MRO plugin.  See L<mro> and L<perlmroapi>.\n\n=item Invalid negative number (%s) in chr\n\n(W utf8) You passed a negative number to C<chr>.  Negative numbers are\nnot valid character numbers, so it returns the Unicode replacement\ncharacter (U+FFFD).\n\n=item Invalid number '%s' for -C option.\n\n(F) You supplied a number to the -C option that either has extra leading\nzeroes or overflows perl's unsigned integer representation.\n\n=item invalid option -D%c, use -D'' to see choices\n\n(S debugging) Perl was called with invalid debugger flags.  Call perl\nwith the B<-D> option with no flags to see the list of acceptable values.\nSee also L<perlrun/-Dletters>.\n\n=item Invalid quantifier in {,} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The pattern looks like a {min,max} quantifier, but the min or max\ncould not be parsed as a valid number - either it has leading zeroes,\nor it represents too big a number to cope with.  The S<<-- HERE> shows\nwhere in the regular expression the problem was discovered.  See L<perlre>.\n\n=item Invalid [] range \"%s\" in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The range specified in a character class had a minimum character\ngreater than the maximum character.  One possibility is that you forgot the\nC<{}> from your ending C<\\x{}> - C<\\x> without the curly braces can go only\nup to C<ff>.  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item Invalid range \"%s\" in transliteration operator\n\n(F) The range specified in the tr/// or y/// operator had a minimum\ncharacter greater than the maximum character.  See L<perlop>.\n\n=item Invalid separator character %s in attribute list\n\n(F) Something other than a colon or whitespace was seen between the\nelements of an attribute list.  If the previous attribute had a\nparenthesised parameter list, perhaps that list was terminated too soon.\nSee L<attributes>.\n\n=item Invalid separator character %s in PerlIO layer specification %s\n\n(W layer) When pushing layers onto the Perl I/O system, something other\nthan a colon or whitespace was seen between the elements of a layer list.\nIf the previous attribute had a parenthesised parameter list, perhaps that\nlist was terminated too soon.\n\n=item Invalid strict version format (%s)\n\n(F) A version number did not meet the \"strict\" criteria for versions.\nA \"strict\" version number is a positive decimal number (integer or\ndecimal-fraction) without exponentiation or else a dotted-decimal\nv-string with a leading 'v' character and at least three components.\nThe parenthesized text indicates which criteria were not met.\nSee the L<version> module for more details on allowed version formats.\n\n=item Invalid type '%s' in %s\n\n(F) The given character is not a valid pack or unpack type.\nSee L<perlfunc/pack>.\n\n(W) The given character is not a valid pack or unpack type but used to be\nsilently ignored.\n\n=item Invalid version format (%s)\n\n(F) A version number did not meet the \"lax\" criteria for versions.\nA \"lax\" version number is a positive decimal number (integer or\ndecimal-fraction) without exponentiation or else a dotted-decimal\nv-string.  If the v-string has fewer than three components, it\nmust have a leading 'v' character.  Otherwise, the leading 'v' is\noptional.  Both decimal and dotted-decimal versions may have a\ntrailing \"alpha\" component separated by an underscore character\nafter a fractional or dotted-decimal component.  The parenthesized\ntext indicates which criteria were not met.  See the L<version> module\nfor more details on allowed version formats.\n\n=item Invalid version object\n\n(F) The internal structure of the version object was invalid.\nPerhaps the internals were modified directly in some way or\nan arbitrary reference was blessed into the \"version\" class.\n\n=item In '(*VERB...)', the '(' and '*' must be adjacent in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The two-character sequence C<\"(*\"> in\nthis context in a regular expression pattern should be an\nindivisible token, with nothing intervening between the C<\"(\">\nand the C<\"*\">, but you separated them.\n\n=item ioctl is not implemented\n\n(F) Your machine apparently doesn't implement ioctl(), which is pretty\nstrange for a machine that supports C.\n\n=item ioctl() on unopened %s\n\n(W unopened) You tried ioctl() on a filehandle that was never opened.\nCheck your control flow and number of arguments.\n\n=item IO layers (like '%s') unavailable\n\n(F) Your Perl has not been configured to have PerlIO, and therefore\nyou cannot use IO layers.  To have PerlIO, Perl must be configured\nwith 'useperlio'.\n\n=item IO::Socket::atmark not implemented on this architecture\n\n(F) Your machine doesn't implement the sockatmark() functionality,\nneither as a system call nor an ioctl call (SIOCATMARK).\n\n=item '%s' is an unknown bound type in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You used C<\\b{...}> or C<\\B{...}> and the C<...> is not known to\nPerl.  The current valid ones are given in\nL<perlrebackslash/\\b{}, \\b, \\B{}, \\B>.\n\n=item %s() is deprecated on :utf8 handles. This will be a fatal error in Perl 5.30\n\n(D deprecated) The sysread(), recv(), syswrite() and send() operators are\ndeprecated on handles that have the C<:utf8> layer, either explicitly, or\nimplicitly, eg., with the C<:encoding(UTF-16LE)> layer.\n\nBoth sysread() and recv() currently use only the C<:utf8> flag for the stream,\nignoring the actual layers.  Since sysread() and recv() do no UTF-8\nvalidation they can end up creating invalidly encoded scalars.\n\nSimilarly, syswrite() and send() use only the C<:utf8> flag, otherwise ignoring\nany layers.  If the flag is set, both write the value UTF-8 encoded, even if\nthe layer is some different encoding, such as the example above.\n\nIdeally, all of these operators would completely ignore the C<:utf8> state,\nworking only with bytes, but this would result in silently breaking existing\ncode.\n\nIn Perl 5.30, it will no longer be possible to use sysread(), recv(),\nsyswrite() or send() to read or send bytes from/to :utf8 handles.\n\n=item \"%s\" is more clearly written simply as \"%s\" in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nYou specified a character that has the given plainer way of writing it, and\nwhich is also portable to platforms running with different character sets.\n\n=item $* is no longer supported. Its use will be fatal in Perl 5.30\n\n(D deprecated, syntax) The special variable C<$*>, deprecated in older\nperls, has been removed as of 5.10.0 and is no longer supported.  In\nprevious versions of perl the use of C<$*> enabled or disabled multi-line\nmatching within a string.\n\nInstead of using C<$*> you should use the C</m> (and maybe C</s>) regexp\nmodifiers.  You can enable C</m> for a lexical scope (even a whole file)\nwith C<use re '/m'>.  (In older versions: when C<$*> was set to a true value\nthen all regular expressions behaved as if they were written using C</m>.)\n\nUse of this variable will be a fatal error in Perl 5.30.\n\n=item $# is no longer supported. Its use will be fatal in Perl 5.30\n\n(D deprecated, syntax) The special variable C<$#>, deprecated in older\nperls, has been removed as of 5.10.0 and is no longer supported.  You\nshould use the printf/sprintf functions instead.\n\nUse of this variable will be a fatal error in Perl 5.30.\n\n=item '%s' is not a code reference\n\n(W overload) The second (fourth, sixth, ...) argument of\noverload::constant needs to be a code reference.  Either\nan anonymous subroutine, or a reference to a subroutine.\n\n=item '%s' is not an overloadable type\n\n(W overload) You tried to overload a constant type the overload package is\nunaware of.\n\n=item -i used with no filenames on the command line, reading from STDIN\n\n(S inplace) The C<-i> option was passed on the command line, indicating\nthat the script is intended to edit files in place, but no files were\ngiven.  This is usually a mistake, since editing STDIN in place doesn't\nmake sense, and can be confusing because it can make perl look like\nit is hanging when it is really just trying to read from STDIN.  You\nshould either pass a filename to edit, or remove C<-i> from the command\nline.  See L<perlrun> for more details.\n\n=item Junk on end of regexp in regex m/%s/\n\n(P) The regular expression parser is confused.\n\n=item Label not found for \"last %s\"\n\n(F) You named a loop to break out of, but you're not currently in a loop\nof that name, not even if you count where you were called from.  See\nL<perlfunc/last>.\n\n=item Label not found for \"next %s\"\n\n(F) You named a loop to continue, but you're not currently in a loop of\nthat name, not even if you count where you were called from.  See\nL<perlfunc/last>.\n\n=item Label not found for \"redo %s\"\n\n(F) You named a loop to restart, but you're not currently in a loop of\nthat name, not even if you count where you were called from.  See\nL<perlfunc/last>.\n\n=item leaving effective %s failed\n\n(F) While under the C<use filetest> pragma, switching the real and\neffective uids or gids failed.\n\n=item length/code after end of string in unpack\n\n(F) While unpacking, the string buffer was already used up when an unpack\nlength/code combination tried to obtain more data.  This results in\nan undefined value for the length.  See L<perlfunc/pack>.\n\n=item length() used on %s (did you mean \"scalar(%s)\"?)\n\n(W syntax) You used length() on either an array or a hash when you\nprobably wanted a count of the items.\n\nArray size can be obtained by doing:\n\n    scalar(@array);\n\nThe number of items in a hash can be obtained by doing:\n\n    scalar(keys %hash);\n\n=item Lexing code attempted to stuff non-Latin-1 character into Latin-1 input\n\n(F) An extension is attempting to insert text into the current parse\n(using L<lex_stuff_pvn|perlapi/lex_stuff_pvn> or similar), but tried to insert a character that\ncouldn't be part of the current input.  This is an inherent pitfall\nof the stuffing mechanism, and one of the reasons to avoid it.  Where\nit is necessary to stuff, stuffing only plain ASCII is recommended.\n\n=item Lexing code internal error (%s)\n\n(F) Lexing code supplied by an extension violated the lexer's API in a\ndetectable way.\n\n=item listen() on closed socket %s\n\n(W closed) You tried to do a listen on a closed socket.  Did you forget\nto check the return value of your socket() call?  See\nL<perlfunc/listen>.\n\n=item List form of piped open not implemented\n\n(F) On some platforms, notably Windows, the three-or-more-arguments\nform of C<open> does not support pipes, such as C<open($pipe, '|-', @args)>.\nUse the two-argument C<open($pipe, '|prog arg1 arg2...')> form instead.\n\n=item %s: loadable library and perl binaries are mismatched (got handshake key %p, needed %p)\n\n(P) A dynamic loading library C<.so> or C<.dll> was being loaded into the\nprocess that was built against a different build of perl than the\nsaid library was compiled against.  Reinstalling the XS module will\nlikely fix this error.\n\n=item Locale '%s' may not work well.%s\n\n(W locale) You are using the named locale, which is a non-UTF-8 one, and\nwhich perl has determined is not fully compatible with what it can\nhandle.  The second C<%s> gives a reason.\n\nBy far the most common reason is that the locale has characters in it\nthat are represented by more than one byte.  The only such locales that\nPerl can handle are the UTF-8 locales.  Most likely the specified locale\nis a non-UTF-8 one for an East Asian language such as Chinese or\nJapanese.  If the locale is a superset of ASCII, the ASCII portion of it\nmay work in Perl.\n\nSome essentially obsolete locales that aren't supersets of ASCII, mainly\nthose in ISO 646 or other 7-bit locales, such as ASMO 449, can also have\nproblems, depending on what portions of the ASCII character set get\nchanged by the locale and are also used by the program.\nThe warning message lists the determinable conflicting characters.\n\nNote that not all incompatibilities are found.\n\nIf this happens to you, there's not much you can do except switch to use a\ndifferent locale or use L<Encode> to translate from the locale into\nUTF-8; if that's impracticable, you have been warned that some things\nmay break.\n\nThis message is output once each time a bad locale is switched into\nwithin the scope of C<S<use locale>>, or on the first possibly-affected\noperation if the C<S<use locale>> inherits a bad one.  It is not raised\nfor any operations from the L<POSIX> module.\n\n=item localtime(%f) failed\n\n(W overflow) You called C<localtime> with a number that it could not handle:\ntoo large, too small, or NaN.  The returned value is C<undef>.\n\n=item localtime(%f) too large\n\n(W overflow) You called C<localtime> with a number that was larger\nthan it can reliably handle and C<localtime> probably returned the\nwrong date.  This warning is also triggered with NaN (the special\nnot-a-number value).\n\n=item localtime(%f) too small\n\n(W overflow) You called C<localtime> with a number that was smaller\nthan it can reliably handle and C<localtime> probably returned the\nwrong date.\n\n=item Lookbehind longer than %d not implemented in regex m/%s/\n\n(F) There is currently a limit on the length of string which lookbehind can\nhandle.  This restriction may be eased in a future release. \n\n=item Lost precision when %s %f by 1\n\n(W imprecision) The value you attempted to increment or decrement by one\nis too large for the underlying floating point representation to store\naccurately, hence the target of C<++> or C<--> is unchanged.  Perl issues this\nwarning because it has already switched from integers to floating point\nwhen values are too large for integers, and now even floating point is\ninsufficient.  You may wish to switch to using L<Math::BigInt> explicitly.\n\n=item lstat() on filehandle%s\n\n(W io) You tried to do an lstat on a filehandle.  What did you mean\nby that?  lstat() makes sense only on filenames.  (Perl did a fstat()\ninstead on the filehandle.)\n\n=item lvalue attribute %s already-defined subroutine\n\n(W misc) Although L<attributes.pm|attributes> allows this, turning the lvalue\nattribute on or off on a Perl subroutine that is already defined\ndoes not always work properly.  It may or may not do what you\nwant, depending on what code is inside the subroutine, with exact\ndetails subject to change between Perl versions.  Only do this\nif you really know what you are doing.\n\n=item lvalue attribute ignored after the subroutine has been defined\n\n(W misc) Using the C<:lvalue> declarative syntax to make a Perl\nsubroutine an lvalue subroutine after it has been defined is\nnot permitted.  To make the subroutine an lvalue subroutine,\nadd the lvalue attribute to the definition, or put the C<sub\nfoo :lvalue;> declaration before the definition.\n\nSee also L<attributes.pm|attributes>.\n\n=item Magical list constants are not supported\n\n(F) You assigned a magical array to a stash element, and then tried\nto use the subroutine from the same slot.  You are asking Perl to do\nsomething it cannot do, details subject to change between Perl versions.\n\n=item Malformed integer in [] in pack\n\n(F) Between the brackets enclosing a numeric repeat count only digits\nare permitted.  See L<perlfunc/pack>.\n\n=item Malformed integer in [] in unpack\n\n(F) Between the brackets enclosing a numeric repeat count only digits\nare permitted.  See L<perlfunc/pack>.\n\n=item Malformed PERLLIB_PREFIX\n\n(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form\n\n    prefix1;prefix2\n\nor\n    prefix1 prefix2\n\nwith nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix of\na builtin library search path, prefix2 is substituted.  The error may\nappear if components are not found, or are too long.  See\n\"PERLLIB_PREFIX\" in L<perlos2>.\n\n=item Malformed prototype for %s: %s\n\n(F) You tried to use a function with a malformed prototype.  The\nsyntax of function prototypes is given a brief compile-time check for\nobvious errors like invalid characters.  A more rigorous check is run\nwhen the function is called.\nPerhaps the function's author was trying to write a subroutine signature\nbut didn't enable that feature first (C<use feature 'signatures'>),\nso the signature was instead interpreted as a bad prototype.\n\n=item Malformed UTF-8 character%s\n\n(S utf8)(F) Perl detected a string that should be UTF-8, but didn't\ncomply with UTF-8 encoding rules, or represents a code point whose\nordinal integer value doesn't fit into the word size of the current\nplatform (overflows).  Details as to the exact malformation are given in\nthe variable, C<%s>, part of the message.\n\nOne possible cause is that you set the UTF8 flag yourself for data that\nyou thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit\ndata).  To guard against this, you can use C<Encode::decode('UTF-8', ...)>.\n\nIf you use the C<:encoding(UTF-8)> PerlIO layer for input, invalid byte\nsequences are handled gracefully, but if you use C<:utf8>, the flag is set\nwithout validating the data, possibly resulting in this error message.\n\nSee also L<Encode/\"Handling Malformed Data\">.\n\n=item Malformed UTF-8 returned by \\N{%s} immediately after '%s'\n\n(F) The charnames handler returned malformed UTF-8.\n\n=item Malformed UTF-8 string in \"%s\"\n\n(F) This message indicates a bug either in the Perl core or in XS\ncode. Such code was trying to find out if a character, allegedly\nstored internally encoded as UTF-8, was of a given type, such as\nbeing punctuation or a digit.  But the character was not encoded\nin legal UTF-8.  The C<%s> is replaced by a string that can be used\nby knowledgeable people to determine what the type being checked\nagainst was.\n\nPassing malformed strings was deprecated in Perl 5.18, and\nbecame fatal in Perl 5.26.\n\n=item Malformed UTF-8 string in '%c' format in unpack\n\n(F) You tried to unpack something that didn't comply with UTF-8 encoding\nrules and perl was unable to guess how to make more progress.\n\n=item Malformed UTF-8 string in pack\n\n(F) You tried to pack something that didn't comply with UTF-8 encoding\nrules and perl was unable to guess how to make more progress.\n\n=item Malformed UTF-8 string in unpack\n\n(F) You tried to unpack something that didn't comply with UTF-8 encoding\nrules and perl was unable to guess how to make more progress.\n\n=item Malformed UTF-16 surrogate\n\n(F) Perl thought it was reading UTF-16 encoded character data but while\ndoing it Perl met a malformed Unicode surrogate.\n\n=item Mandatory parameter follows optional parameter\n\n(F) In a subroutine signature, you wrote something like \"$a = undef,\n$b\", making an earlier parameter optional and a later one mandatory.\nParameters are filled from left to right, so it's impossible for the\ncaller to omit an earlier one and pass a later one.  If you want to act\nas if the parameters are filled from right to left, declare the rightmost\noptional and then shuffle the parameters around in the subroutine's body.\n\n=item Matched non-Unicode code point 0x%X against Unicode property; may\nnot be portable\n\n(S non_unicode) Perl allows strings to contain a superset of\nUnicode code points; each code point may be as large as what is storable\nin an unsigned integer on your system, but these may not be accepted by\nother languages/systems.  This message occurs when you matched a string\ncontaining such a code point against a regular expression pattern, and\nthe code point was matched against a Unicode property, C<\\p{...}> or\nC<\\P{...}>.  Unicode properties are only defined on Unicode code points,\nso the result of this match is undefined by Unicode, but Perl (starting\nin v5.20) treats non-Unicode code points as if they were typical\nunassigned Unicode ones, and matched this one accordingly.  Whether a\ngiven property matches these code points or not is specified in\nL<perluniprops/Properties accessible through \\p{} and \\P{}>.\n\nThis message is suppressed (unless it has been made fatal) if it is\nimmaterial to the results of the match if the code point is Unicode or\nnot.  For example, the property C<\\p{ASCII_Hex_Digit}> only can match\nthe 22 characters C<[0-9A-Fa-f]>, so obviously all other code points,\nUnicode or not, won't match it.  (And C<\\P{ASCII_Hex_Digit}> will match\nevery code point except these 22.)\n\nGetting this message indicates that the outcome of the match arguably\nshould have been the opposite of what actually happened.  If you think\nthat is the case, you may wish to make the C<non_unicode> warnings\ncategory fatal; if you agree with Perl's decision, you may wish to turn\noff this category.\n\nSee L<perlunicode/Beyond Unicode code points> for more information.\n\n=item %s matches null string many times in regex; marked by S<<-- HERE> in\nm/%s/\n\n(W regexp) The pattern you've specified would be an infinite loop if the\nregular expression engine didn't specifically check for that.  The S<<-- HERE>\nshows whereabouts in the regular expression the problem was discovered.\nSee L<perlre>.\n\n=item Maximal count of pending signals (%u) exceeded\n\n(F) Perl aborted due to too high a number of signals pending.  This\nusually indicates that your operating system tried to deliver signals\ntoo fast (with a very high priority), starving the perl process from\nresources it would need to reach a point where it can process signals\nsafely.  (See L<perlipc/\"Deferred Signals (Safe Signals)\">.)\n\n=item \"%s\" may clash with future reserved word\n\n(W) This warning may be due to running a perl5 script through a perl4\ninterpreter, especially if the word that is being warned about is\n\"use\" or \"my\".\n\n=item '%' may not be used in pack\n\n(F) You can't pack a string by supplying a checksum, because the\nchecksumming process loses information, and you can't go the other way.\nSee L<perlfunc/unpack>.\n\n=item Method for operation %s not found in package %s during blessing\n\n(F) An attempt was made to specify an entry in an overloading table that\ndoesn't resolve to a valid subroutine.  See L<overload>.\n\n=item Method %s not permitted\n\nSee L</500 Server error>.\n\n=item Might be a runaway multi-line %s string starting on line %d\n\n(S) An advisory indicating that the previous error may have been caused\nby a missing delimiter on a string or pattern, because it eventually\nended earlier on the current line.\n\n=item Misplaced _ in number\n\n(W syntax) An underscore (underbar) in a numeric constant did not\nseparate two digits.\n\n=item Missing argument for %n in %s\n\n(F) A C<%n> was used in a format string with no corresponding argument for\nperl to write the current string length to.\n\n=item Missing argument in %s\n\n(W missing) You called a function with fewer arguments than other\narguments you supplied indicated would be needed.\n\nCurrently only emitted when a printf-type format required more\narguments than were supplied, but might be used in the future for\nother cases where we can statically determine that arguments to\nfunctions are missing, e.g. for the L<perlfunc/pack> function.\n\n=item Missing argument to -%c\n\n(F) The argument to the indicated command line switch must follow\nimmediately after the switch, without intervening spaces.\n\n=item Missing braces on \\N{}\n\n=item Missing braces on \\N{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Wrong syntax of character name literal C<\\N{charname}> within\ndouble-quotish context.  This can also happen when there is a space\n(or comment) between the C<\\N> and the C<{> in a regex with the C</x> modifier.\nThis modifier does not change the requirement that the brace immediately\nfollow the C<\\N>.\n\n=item Missing braces on \\o{}\n\n(F) A C<\\o> must be followed immediately by a C<{> in double-quotish context.\n\n=item Missing comma after first argument to %s function\n\n(F) While certain functions allow you to specify a filehandle or an\n\"indirect object\" before the argument list, this ain't one of them.\n\n=item Missing command in piped open\n\n(W pipe) You used the C<open(FH, \"| command\")> or\nC<open(FH, \"command |\")> construction, but the command was missing or\nblank.\n\n=item Missing control char name in \\c\n\n(F) A double-quoted string ended with \"\\c\", without the required control\ncharacter name.\n\n=item Missing ']' in prototype for %s : %s\n\n(W illegalproto) A grouping was started with C<[> but never closed with C<]>.\n\n=item Missing name in \"%s sub\"\n\n(F) The syntax for lexically scoped subroutines requires that\nthey have a name with which they can be found.\n\n=item Missing $ on loop variable\n\n(F) Apparently you've been programming in B<csh> too much.  Variables\nare always mentioned with the $ in Perl, unlike in the shells, where it\ncan vary from one line to the next.\n\n=item (Missing operator before %s?)\n\n(S syntax) This is an educated guess made in conjunction with the message\n\"%s found where operator expected\".  Often the missing operator is a comma.\n\n=item Missing or undefined argument to %s\n\n(F) You tried to call require or do with no argument or with an undefined\nvalue as an argument.  Require expects either a package name or a\nfile-specification as an argument; do expects a filename.  See\nL<perlfunc/require EXPR> and L<perlfunc/do EXPR>.\n\n=item Missing right brace on \\%c{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Missing right brace in C<\\x{...}>, C<\\p{...}>, C<\\P{...}>, or C<\\N{...}>.\n\n=item Missing right brace on \\N{}\n\n=item Missing right brace on \\N{} or unescaped left brace after \\N\n\n(F) C<\\N> has two meanings.\n\nThe traditional one has it followed by a name enclosed in braces,\nmeaning the character (or sequence of characters) given by that\nname.  Thus C<\\N{ASTERISK}> is another way of writing C<*>, valid in both\ndouble-quoted strings and regular expression patterns.  In patterns,\nit doesn't have the meaning an unescaped C<*> does.\n\nStarting in Perl 5.12.0, C<\\N> also can have an additional meaning (only)\nin patterns, namely to match a non-newline character.  (This is short\nfor C<[^\\n]>, and like C<.> but is not affected by the C</s> regex modifier.)\n\nThis can lead to some ambiguities.  When C<\\N> is not followed immediately\nby a left brace, Perl assumes the C<[^\\n]> meaning.  Also, if the braces\nform a valid quantifier such as C<\\N{3}> or C<\\N{5,}>, Perl assumes that this\nmeans to match the given quantity of non-newlines (in these examples,\n3; and 5 or more, respectively).  In all other case, where there is a\nC<\\N{> and a matching C<}>, Perl assumes that a character name is desired.\n\nHowever, if there is no matching C<}>, Perl doesn't know if it was\nmistakenly omitted, or if C<[^\\n]{> was desired, and raises this error.\nIf you meant the former, add the right brace; if you meant the latter,\nescape the brace with a backslash, like so: C<\\N\\{>\n\n=item Missing right curly or square bracket\n\n(F) The lexer counted more opening curly or square brackets than closing\nones.  As a general rule, you'll find it's missing near the place you\nwere last editing.\n\n=item (Missing semicolon on previous line?)\n\n(S syntax) This is an educated guess made in conjunction with the message\n\"%s found where operator expected\".  Don't automatically put a semicolon on\nthe previous line just because you saw this message.\n\n=item Modification of a read-only value attempted\n\n(F) You tried, directly or indirectly, to change the value of a\nconstant.  You didn't, of course, try \"2 = 1\", because the compiler\ncatches that.  But an easy way to do the same thing is:\n\n    sub mod { $_[0] = 1 }\n    mod(2);\n\nAnother way is to assign to a substr() that's off the end of the string.\n\nYet another way is to assign to a C<foreach> loop I<VAR> when I<VAR>\nis aliased to a constant in the look I<LIST>:\n\n    $x = 1;\n    foreach my $n ($x, 2) {\n        $n *= 2; # modifies the $x, but fails on attempt to\n    }            # modify the 2\n\n=item Modification of non-creatable array value attempted, %s\n\n(F) You tried to make an array value spring into existence, and the\nsubscript was probably negative, even counting from end of the array\nbackwards.\n\n=item Modification of non-creatable hash value attempted, %s\n\n(P) You tried to make a hash value spring into existence, and it\ncouldn't be created for some peculiar reason.\n\n=item Module name must be constant\n\n(F) Only a bare module name is allowed as the first argument to a \"use\".\n\n=item Module name required with -%c option\n\n(F) The C<-M> or C<-m> options say that Perl should load some module, but\nyou omitted the name of the module.  Consult L<perlrun> for full details\nabout C<-M> and C<-m>.\n\n=item More than one argument to '%s' open\n\n(F) The C<open> function has been asked to open multiple files.  This\ncan happen if you are trying to open a pipe to a command that takes a\nlist of arguments, but have forgotten to specify a piped open mode.\nSee L<perlfunc/open> for details.\n\n=item mprotect for COW string %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see\nL<perlguts/\"Copy on Write\">), but a shared string buffer\ncould not be made read-only.\n\n=item mprotect for %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see L<perlhacktips>),\nbut an op tree could not be made read-only.\n\n=item mprotect RW for COW string %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see\nL<perlguts/\"Copy on Write\">), but a read-only shared string\nbuffer could not be made mutable.\n\n=item mprotect RW for %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see\nL<perlhacktips>), but a read-only op tree could not be made\nmutable before freeing the ops.\n\n=item msg%s not implemented\n\n(F) You don't have System V message IPC on your system.\n\n=item Multidimensional syntax %s not supported\n\n(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.\nThey're written like C<$foo[1][2][3]>, as in C.\n\n=item Multiple slurpy parameters not allowed\n\n(F) In subroutine signatures, a slurpy parameter (C<@> or C<%>) must be\nthe last parameter, and there must not be more than one of them; for\nexample:\n\n    sub foo ($a, @b)    {} # legal\n    sub foo ($a, @b, %) {} # invalid\n\n=item '/' must follow a numeric type in unpack\n\n(F) You had an unpack template that contained a '/', but this did not\nfollow some unpack specification producing a numeric value.\nSee L<perlfunc/pack>.\n\n=item %s must not be a named sequence in transliteration operator\n\n(F) Transliteration (C<tr///> and C<y///>) transliterates individual\ncharacters.  But a named sequence by definition is more than an\nindividual charater, and hence doing this operation on it doesn't make\nsense.\n\n=item \"my sub\" not yet implemented\n\n(F) Lexically scoped subroutines are not yet implemented.  Don't try\nthat yet.\n\n=item \"my\" subroutine %s can't be in a package\n\n(F) Lexically scoped subroutines aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.\n\n=item \"my %s\" used in sort comparison\n\n(W syntax) The package variables $a and $b are used for sort comparisons.\nYou used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a\nsort comparison block, and the variable had earlier been declared as a\nlexical variable.  Either qualify the sort variable with the package\nname, or rename the lexical variable.\n\n=item \"my\" variable %s can't be in a package\n\n(F) Lexically scoped variables aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.  Use\nlocal() if you want to localize a package variable.\n\n=item Name \"%s::%s\" used only once: possible typo\n\n(W once) Typographical errors often show up as unique variable\nnames.  If you had a good reason for having a unique name, then\njust mention it again somehow to suppress the message.  The C<our>\ndeclaration is also provided for this purpose.\n\nNOTE: This warning detects package symbols that have been used\nonly once.  This means lexical variables will never trigger this\nwarning.  It also means that all of the package variables $c, @c,\n%c, as well as *c, &c, sub c{}, c(), and c (the filehandle or\nformat) are considered the same; if a program uses $c only once\nbut also uses any of the others it will not trigger this warning.\nSymbols beginning with an underscore and symbols using special\nidentifiers (q.v. L<perldata>) are exempt from this warning.\n\n=item Need exactly 3 octal digits in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Within S<C<(?[   ])>>, all constants interpreted as octal need to be\nexactly 3 digits long.  This helps catch some ambiguities.  If your\nconstant is too short, add leading zeros, like\n\n (?[ [ \\078 ] ])     # Syntax error!\n (?[ [ \\0078 ] ])    # Works\n (?[ [ \\007 8 ] ])   # Clearer\n\nThe maximum number this construct can express is C<\\777>.  If you\nneed a larger one, you need to use L<\\o{}|perlrebackslash/Octal escapes> instead.  If you meant\ntwo separate things, you need to separate them:\n\n (?[ [ \\7776 ] ])        # Syntax error!\n (?[ [ \\o{7776} ] ])     # One meaning\n (?[ [ \\777 6 ] ])       # Another meaning\n (?[ [ \\777 \\006 ] ])    # Still another\n\n=item Negative '/' count in unpack\n\n(F) The length count obtained from a length/code unpack operation was\nnegative.  See L<perlfunc/pack>.\n\n=item Negative length\n\n(F) You tried to do a read/write/send/recv operation with a buffer\nlength that is less than 0.  This is difficult to imagine.\n\n=item Negative offset to vec in lvalue context\n\n(F) When C<vec> is called in an lvalue context, the second argument must be\ngreater than or equal to zero.\n\n=item Negative repeat count does nothing\n\n(W numeric) You tried to execute the\nL<C<x>|perlop/Multiplicative Operators> repetition operator fewer than 0\ntimes, which doesn't make sense.\n\n=item Nested quantifiers in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You can't quantify a quantifier without intervening parentheses.\nSo things like ** or +* or ?* are illegal.  The S<<-- HERE> shows\nwhereabouts in the regular expression the problem was discovered.\n\nNote that the minimal matching quantifiers, C<*?>, C<+?>, and\nC<??> appear to be nested quantifiers, but aren't.  See L<perlre>.\n\n=item %s never introduced\n\n(S internal) The symbol in question was declared but somehow went out of\nscope before it could possibly have been used.\n\n=item next::method/next::can/maybe::next::method cannot find enclosing method\n\n(F) C<next::method> needs to be called within the context of a\nreal method in a real package, and it could not find such a context.\nSee L<mro>.\n\n=item \\N in a character class must be a named character: \\N{...} in regex; \nmarked by S<<-- HERE> in m/%s/\n\n(F) The new (as of Perl 5.12) meaning of C<\\N> as C<[^\\n]> is not valid in a\nbracketed character class, for the same reason that C<.> in a character\nclass loses its specialness: it matches almost everything, which is\nprobably not what you want.\n\n=item \\N{} in inverted character class or as a range end-point is restricted to one character in regex; marked by <-- HERE in m/%s/\n\n(F) Named Unicode character escapes (C<\\N{...}>) may return a\nmulti-character sequence.  Even though a character class is\nsupposed to match just one character of input, perl will match the\nwhole thing correctly, except when the class is inverted (C<[^...]>),\nor the escape is the beginning or final end point of a range.  The\nmathematically logical behavior for what matches when inverting\nis very different from what people expect, so we have decided to\nforbid it.  Similarly unclear is what should be generated when the\nC<\\N{...}> is used as one of the end points of the range, such as in\n\n [\\x{41}-\\N{ARABIC SEQUENCE YEH WITH HAMZA ABOVE WITH AE}]\n\nWhat is meant here is unclear, as the C<\\N{...}> escape is a sequence\nof code points, so this is made an error.\n\n=item \\N{NAME} must be resolved by the lexer in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) When compiling a regex pattern, an unresolved named character or\nsequence was encountered.  This can happen in any of several ways that\nbypass the lexer, such as using single-quotish context, or an extra\nbackslash in double-quotish:\n\n    $re = '\\N{SPACE}';\t# Wrong!\n    $re = \"\\\\N{SPACE}\";\t# Wrong!\n    /$re/;\n\nInstead, use double-quotes with a single backslash:\n\n    $re = \"\\N{SPACE}\";\t# ok\n    /$re/;\n\nThe lexer can be bypassed as well by creating the pattern from smaller\ncomponents:\n\n    $re = '\\N';\n    /${re}{SPACE}/;\t# Wrong!\n\nIt's not a good idea to split a construct in the middle like this, and\nit doesn't work here.  Instead use the solution above.\n\nFinally, the message also can happen under the C</x> regex modifier when the\nC<\\N> is separated by spaces from the C<{>, in which case, remove the spaces.\n\n    /\\N {SPACE}/x;\t# Wrong!\n    /\\N{SPACE}/x;\t# ok\n\n=item No %s allowed while running setuid\n\n(F) Certain operations are deemed to be too insecure for a setuid or\nsetgid script to even be allowed to attempt.  Generally speaking there\nwill be another way to do what you want that is, if not secure, at least\nsecurable.  See L<perlsec>.\n\n=item No code specified for -%c\n\n(F) Perl's B<-e> and B<-E> command-line options require an argument.  If\nyou want to run an empty program, pass the empty string as a separate\nargument or run a program consisting of a single 0 or 1:\n\n    perl -e \"\"\n    perl -e0\n    perl -e1\n\n=item No comma allowed after %s\n\n(F) A list operator that has a filehandle or \"indirect object\" is\nnot allowed to have a comma between that and the following arguments.\nOtherwise it'd be just another one of the arguments.\n\nOne possible cause for this is that you expected to have imported\na constant to your name space with B<use> or B<import> while no such\nimporting took place, it may for example be that your operating\nsystem does not support that particular constant.  Hopefully you did\nuse an explicit import list for the constants you expect to see;\nplease see L<perlfunc/use> and L<perlfunc/import>.  While an\nexplicit import list would probably have caught this error earlier\nit naturally does not remedy the fact that your operating system\nstill does not support that constant.  Maybe you have a typo in\nthe constants of the symbol import list of B<use> or B<import> or in the\nconstant name at the line where this error was triggered?\n\n=item No command into which to pipe on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '|' at the end of the command line, so it\ndoesn't know where you want to pipe the output from this command.\n\n=item No DB::DB routine defined\n\n(F) The currently executing code was compiled with the B<-d> switch, but\nfor some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>\nmodule) didn't define a routine to be called at the beginning of each\nstatement.\n\n=item No dbm on this machine\n\n(P) This is counted as an internal error, because every machine should\nsupply dbm nowadays, because Perl comes with SDBM.  See L<SDBM_File>.\n\n=item No DB::sub routine defined\n\n(F) The currently executing code was compiled with the B<-d> switch, but\nfor some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>\nmodule) didn't define a C<DB::sub> routine to be called at the beginning\nof each ordinary subroutine call.\n\n=item No directory specified for -I\n\n(F) The B<-I> command-line switch requires a directory name as part of the\nI<same> argument.  Use B<-Ilib>, for instance.  B<-I lib> won't work.\n\n=item No error file after 2> or 2>> on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '2>' or a '2>>' on the command line, but can't\nfind the name of the file to which to write data destined for stderr.\n\n=item No group ending character '%c' found in template\n\n(F) A pack or unpack template has an opening '(' or '[' without its\nmatching counterpart.  See L<perlfunc/pack>.\n\n=item No input file after < on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '<' on the command line, but can't find the\nname of the file from which to read data for stdin.\n\n=item No next::method '%s' found for %s\n\n(F) C<next::method> found no further instances of this method name\nin the remaining packages of the MRO of this class.  If you don't want\nit throwing an exception, use C<maybe::next::method>\nor C<next::can>.  See L<mro>.\n\n=item Non-finite repeat count does nothing\n\n(W numeric) You tried to execute the\nL<C<x>|perlop/Multiplicative Operators> repetition operator C<Inf> (or\nC<-Inf>) or C<NaN> times, which doesn't make sense.\n\n=item Non-hex character in regex; marked by S<<-- HERE> in m/%s/\n\n(F) In a regular expression, there was a non-hexadecimal character where\na hex one was expected, like\n\n (?[ [ \\xDG ] ])\n (?[ [ \\x{DEKA} ] ])\n\n=item Non-octal character in regex; marked by S<<-- HERE> in m/%s/\n\n(F) In a regular expression, there was a non-octal character where\nan octal one was expected, like\n\n (?[ [ \\o{1278} ] ])\n\n=item Non-octal character '%c'.  Resolved as \"%s\"\n\n(W digit) In parsing an octal numeric constant, a character was\nunexpectedly encountered that isn't octal.  The resulting value\nis as indicated.\n\n=item \"no\" not allowed in expression\n\n(F) The \"no\" keyword is recognized and executed at compile time, and\nreturns no useful value.  See L<perlmod>.\n\n=item Non-string passed as bitmask\n\n(W misc) A number has been passed as a bitmask argument to select().\nUse the vec() function to construct the file descriptor bitmasks for\nselect.  See L<perlfunc/select>.\n\n=item No output file after > on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a lone '>' at the end of the command line, so it\ndoesn't know where you wanted to redirect stdout.\n\n=item No output file after > or >> on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '>' or a '>>' on the command line, but can't\nfind the name of the file to which to write data destined for stdout.\n\n=item No package name allowed for subroutine %s in \"our\"\n\n=item No package name allowed for variable %s in \"our\"\n\n(F) Fully qualified subroutine and variable names are not allowed in \"our\"\ndeclarations, because that doesn't make much sense under existing rules.\nSuch syntax is reserved for future extensions.\n\n=item No Perl script found in input\n\n(F) You called C<perl -x>, but no line was found in the file beginning\nwith #! and containing the word \"perl\".\n\n=item No setregid available\n\n(F) Configure didn't find anything resembling the setregid() call for\nyour system.\n\n=item No setreuid available\n\n(F) Configure didn't find anything resembling the setreuid() call for\nyour system.\n\n=item No such class %s\n\n(F) You provided a class qualifier in a \"my\", \"our\" or \"state\"\ndeclaration, but this class doesn't exist at this point in your program.\n\n=item No such class field \"%s\" in variable %s of type %s\n\n(F) You tried to access a key from a hash through the indicated typed\nvariable but that key is not allowed by the package of the same type.\nThe indicated package has restricted the set of allowed keys using the\nL<fields> pragma.\n\n=item No such hook: %s\n\n(F) You specified a signal hook that was not recognized by Perl.\nCurrently, Perl accepts C<__DIE__> and C<__WARN__> as valid signal hooks.\n\n=item No such pipe open\n\n(P) An error peculiar to VMS.  The internal routine my_pclose() tried to\nclose a pipe which hadn't been opened.  This should have been caught\nearlier as an attempt to close an unopened filehandle.\n\n=item No such signal: SIG%s\n\n(W signal) You specified a signal name as a subscript to %SIG that was\nnot recognized.  Say C<kill -l> in your shell to see the valid signal\nnames on your system.\n\n=item Not a CODE reference\n\n(F) Perl was trying to evaluate a reference to a code value (that is, a\nsubroutine), but found a reference to something else instead.  You can\nuse the ref() function to find out what kind of ref it really was.  See\nalso L<perlref>.\n\n=item Not a GLOB reference\n\n(F) Perl was trying to evaluate a reference to a \"typeglob\" (that is, a\nsymbol table entry that looks like C<*foo>), but found a reference to\nsomething else instead.  You can use the ref() function to find out what\nkind of ref it really was.  See L<perlref>.\n\n=item Not a HASH reference\n\n(F) Perl was trying to evaluate a reference to a hash value, but found a\nreference to something else instead.  You can use the ref() function to\nfind out what kind of ref it really was.  See L<perlref>.\n\n=item '#' not allowed immediately following a sigil in a subroutine signature\n\n(F) In a subroutine signature definition, a comment following a sigil\n(C<$>, C<@> or C<%>), needs to be separated by whitespace or a commma etc., in\nparticular to avoid confusion with the C<$#> variable.  For example:\n\n    # bad\n    sub f ($# ignore first arg\n           , $b) {}\n    # good\n    sub f ($, # ignore first arg\n           $b) {}\n\n=item Not an ARRAY reference\n\n(F) Perl was trying to evaluate a reference to an array value, but found\na reference to something else instead.  You can use the ref() function\nto find out what kind of ref it really was.  See L<perlref>.\n\n=item Not a SCALAR reference\n\n(F) Perl was trying to evaluate a reference to a scalar value, but found\na reference to something else instead.  You can use the ref() function\nto find out what kind of ref it really was.  See L<perlref>.\n\n=item Not a subroutine reference\n\n(F) Perl was trying to evaluate a reference to a code value (that is, a\nsubroutine), but found a reference to something else instead.  You can\nuse the ref() function to find out what kind of ref it really was.  See\nalso L<perlref>.\n\n=item Not a subroutine reference in overload table\n\n(F) An attempt was made to specify an entry in an overloading table that\ndoesn't somehow point to a valid subroutine.  See L<overload>.\n\n=item Not enough arguments for %s\n\n(F) The function requires more arguments than you specified.\n\n=item Not enough format arguments\n\n(W syntax) A format specified more picture fields than the next line\nsupplied.  See L<perlform>.\n\n=item %s: not found\n\n(A) You've accidentally run your script through the Bourne shell instead\nof Perl.  Check the #! line, or manually feed your script into Perl\nyourself.\n\n=item (?[...]) not valid in locale in regex; marked by S<<-- HERE> in m/%s/\n\n(F) C<(?[...])> cannot be used within the scope of a C<S<use locale>> or with\nan C</l> regular expression modifier, as that would require deferring\nto run-time the calculation of what it should evaluate to, and it is\nregex compile-time only.\n\n=item no UTC offset information; assuming local time is UTC\n\n(S) A warning peculiar to VMS.  Perl was unable to find the local\ntimezone offset, so it's assuming that local system time is equivalent\nto UTC.  If it's not, define the logical name\nF<SYS$TIMEZONE_DIFFERENTIAL> to translate to the number of seconds which\nneed to be added to UTC to get local time.\n\n=item NULL OP IN RUN\n\n(S debugging) Some internal routine called run() with a null opcode\npointer.\n\n=item Null picture in formline\n\n(F) The first argument to formline must be a valid format picture\nspecification.  It was found to be empty, which probably means you\nsupplied it an uninitialized value.  See L<perlform>.\n\n=item Null realloc\n\n(P) An attempt was made to realloc NULL.\n\n=item NULL regexp argument\n\n(P) The internal pattern matching routines blew it big time.\n\n=item NULL regexp parameter\n\n(P) The internal pattern matching routines are out of their gourd.\n\n=item Number too long\n\n(F) Perl limits the representation of decimal numbers in programs to\nabout 250 characters.  You've exceeded that length.  Future\nversions of Perl are likely to eliminate this arbitrary limitation.  In\nthe meantime, try using scientific notation (e.g. \"1e6\" instead of\n\"1_000_000\").\n\n=item Number with no digits\n\n(F) Perl was looking for a number but found nothing that looked like\na number.  This happens, for example with C<\\o{}>, with no number between\nthe braces.\n\n=item Octal number > 037777777777 non-portable\n\n(W portable) The octal number you specified is larger than 2**32-1\n(4294967295) and therefore non-portable between systems.  See\nL<perlport> for more on portability concerns.\n\n=item Odd name/value argument for subroutine '%s'\n\n(F) A subroutine using a slurpy hash parameter in its signature\nreceived an odd number of arguments to populate the hash.  It requires\nthe arguments to be paired, with the same number of keys as values.\nThe caller of the subroutine is presumably at fault.\n\nThe message attempts to include the name of the called subroutine. If the\nsubroutine has been aliased, the subroutine's original name will be shown,\nregardless of what name the caller used.\n\n=item Odd number of arguments for overload::constant\n\n(W overload) The call to overload::constant contained an odd number of\narguments.  The arguments should come in pairs.\n\n=item Odd number of elements in anonymous hash\n\n(W misc) You specified an odd number of elements to initialize a hash,\nwhich is odd, because hashes come in key/value pairs.\n\n=item Odd number of elements in hash assignment\n\n(W misc) You specified an odd number of elements to initialize a hash,\nwhich is odd, because hashes come in key/value pairs.\n\n=item Offset outside string\n\n(F)(W layer) You tried to do a read/write/send/recv/seek operation\nwith an offset pointing outside the buffer.  This is difficult to\nimagine.  The sole exceptions to this are that zero padding will\ntake place when going past the end of the string when either\nC<sysread()>ing a file, or when seeking past the end of a scalar opened\nfor I/O (in anticipation of future reads and to imitate the behavior\nwith real files).\n\n=item Old package separator used in string\n\n(W syntax) You used the old package separator, \"'\", in a variable\nnamed inside a double-quoted string; e.g., C<\"In $name's house\">.  This\nis equivalent to C<\"In $name::s house\">.  If you meant the former, put\na backslash before the apostrophe (C<\"In $name\\'s house\">).\n\n=item %s() on unopened %s\n\n(W unopened) An I/O operation was attempted on a filehandle that was\nnever initialized.  You need to do an open(), a sysopen(), or a socket()\ncall, or call a constructor from the FileHandle package.\n\n=item -%s on unopened filehandle %s\n\n(W unopened) You tried to invoke a file test operator on a filehandle\nthat isn't open.  Check your control flow.  See also L<perlfunc/-X>.\n\n=item oops: oopsAV\n\n(S internal) An internal warning that the grammar is screwed up.\n\n=item oops: oopsHV\n\n(S internal) An internal warning that the grammar is screwed up.\n\n=item Operand with no preceding operator in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You wrote something like\n\n (?[ \\p{Digit} \\p{Thai} ])\n\nThere are two operands, but no operator giving how you want to combine\nthem.\n\n=item Operation \"%s\": no method found, %s\n\n(F) An attempt was made to perform an overloaded operation for which no\nhandler was defined.  While some handlers can be autogenerated in terms\nof other handlers, there is no default handler for any operation, unless\nthe C<fallback> overloading key is specified to be true.  See L<overload>.\n\n=item Operation \"%s\" returns its argument for non-Unicode code point 0x%X\n\n(S non_unicode) You performed an operation requiring Unicode rules\non a code point that is not in Unicode, so what it should do is not\ndefined.  Perl has chosen to have it do nothing, and warn you.\n\nIf the operation shown is \"ToFold\", it means that case-insensitive\nmatching in a regular expression was done on the code point.\n\nIf you know what you are doing you can turn off this warning by\nC<no warnings 'non_unicode';>.\n\n=item Operation \"%s\" returns its argument for UTF-16 surrogate U+%X\n\n(S surrogate) You performed an operation requiring Unicode\nrules on a Unicode surrogate.  Unicode frowns upon the use\nof surrogates for anything but storing strings in UTF-16, but\nrules are (reluctantly) defined for the surrogates, and\nthey are to do nothing for this operation.  Because the use of\nsurrogates can be dangerous, Perl warns.\n\nIf the operation shown is \"ToFold\", it means that case-insensitive\nmatching in a regular expression was done on the code point.\n\nIf you know what you are doing you can turn off this warning by\nC<no warnings 'surrogate';>.\n\n=item Operator or semicolon missing before %s\n\n(S ambiguous) You used a variable or subroutine call where the parser\nwas expecting an operator.  The parser has assumed you really meant to\nuse an operator, but this is highly likely to be incorrect.  For\nexample, if you say \"*foo *foo\" it will be interpreted as if you said\n\"*foo * 'foo'\".\n\n=item Optional parameter lacks default expression\n\n(F) In a subroutine signature, you wrote something like \"$a =\", making a\nnamed optional parameter without a default value.  A nameless optional\nparameter is permitted to have no default value, but a named one must\nhave a specific default.  You probably want \"$a = undef\".\n\n=item \"our\" variable %s redeclared\n\n(W shadow) You seem to have already declared the same global once before\nin the current lexical scope.\n\n=item Out of memory!\n\n(X) The malloc() function returned 0, indicating there was insufficient\nremaining memory (or virtual memory) to satisfy the request.  Perl has\nno option but to exit immediately.\n\nAt least in Unix you may be able to get past this by increasing your\nprocess datasize limits: in csh/tcsh use C<limit> and\nC<limit datasize n> (where C<n> is the number of kilobytes) to check\nthe current limits and change them, and in ksh/bash/zsh use C<ulimit -a>\nand C<ulimit -d n>, respectively.\n\n=item Out of memory during %s extend\n\n(X) An attempt was made to extend an array, a list, or a string beyond\nthe largest possible memory allocation.\n\n=item Out of memory during \"large\" request for %s\n\n(F) The malloc() function returned 0, indicating there was insufficient\nremaining memory (or virtual memory) to satisfy the request.  However,\nthe request was judged large enough (compile-time default is 64K), so a\npossibility to shut down by trapping this error is granted.\n\n=item Out of memory during request for %s\n\n(X)(F) The malloc() function returned 0, indicating there was\ninsufficient remaining memory (or virtual memory) to satisfy the\nrequest.\n\nThe request was judged to be small, so the possibility to trap it\ndepends on the way perl was compiled.  By default it is not trappable.\nHowever, if compiled for this, Perl may use the contents of C<$^M> as an\nemergency pool after die()ing with this message.  In this case the error\nis trappable I<once>, and the error message will include the line and file\nwhere the failed request happened.\n\n=item Out of memory during ridiculously large request\n\n(F) You can't allocate more than 2^31+\"small amount\" bytes.  This error\nis most likely to be caused by a typo in the Perl program. e.g.,\nC<$arr[time]> instead of C<$arr[$time]>.\n\n=item Out of memory for yacc stack\n\n(F) The yacc parser wanted to grow its stack so it could continue\nparsing, but realloc() wouldn't give it more memory, virtual or\notherwise.\n\n=item '.' outside of string in pack\n\n(F) The argument to a '.' in your template tried to move the working\nposition to before the start of the packed string being built.\n\n=item '@' outside of string in unpack\n\n(F) You had a template that specified an absolute position outside\nthe string being unpacked.  See L<perlfunc/pack>.\n\n=item '@' outside of string with malformed UTF-8 in unpack\n\n(F) You had a template that specified an absolute position outside\nthe string being unpacked.  The string being unpacked was also invalid\nUTF-8.  See L<perlfunc/pack>.\n\n=item overload arg '%s' is invalid\n\n(W overload) The L<overload> pragma was passed an argument it did not\nrecognize.  Did you mistype an operator?\n\n=item Overloaded dereference did not return a reference\n\n(F) An object with an overloaded dereference operator was dereferenced,\nbut the overloaded operation did not return a reference.  See\nL<overload>.\n\n=item Overloaded qr did not return a REGEXP\n\n(F) An object with a C<qr> overload was used as part of a match, but the\noverloaded operation didn't return a compiled regexp.  See L<overload>.\n\n=item %s package attribute may clash with future reserved word: %s\n\n(W reserved) A lowercase attribute name was used that had a\npackage-specific handler.  That name might have a meaning to Perl itself\nsome day, even though it doesn't yet.  Perhaps you should use a\nmixed-case attribute name, instead.  See L<attributes>.\n\n=item pack/unpack repeat count overflow\n\n(F) You can't specify a repeat count so large that it overflows your\nsigned integers.  See L<perlfunc/pack>.\n\n=item page overflow\n\n(W io) A single call to write() produced more lines than can fit on a\npage.  See L<perlform>.\n\n=item panic: %s\n\n(P) An internal error.\n\n=item panic: attempt to call %s in %s\n\n(P) One of the file test operators entered a code branch that calls\nan ACL related-function, but that function is not available on this\nplatform.  Earlier checks mean that it should not be possible to\nenter this branch on this platform.\n\n=item panic: child pseudo-process was never scheduled\n\n(P) A child pseudo-process in the ithreads implementation on Windows\nwas not scheduled within the time period allowed and therefore was not\nable to initialize properly.\n\n=item panic: ck_grep, type=%u\n\n(P) Failed an internal consistency check trying to compile a grep.\n\n=item panic: corrupt saved stack index %ld\n\n(P) The savestack was requested to restore more localized values than\nthere are in the savestack.\n\n=item panic: del_backref\n\n(P) Failed an internal consistency check while trying to reset a weak\nreference.\n\n=item panic: do_subst\n\n(P) The internal pp_subst() routine was called with invalid operational\ndata.\n\n=item panic: do_trans_%s\n\n(P) The internal do_trans routines were called with invalid operational\ndata.\n\n=item panic: fold_constants JMPENV_PUSH returned %d\n\n(P) While attempting folding constants an exception other than an C<eval>\nfailure was caught.\n\n=item panic: frexp: %f\n\n(P) The library function frexp() failed, making printf(\"%f\") impossible.\n\n=item panic: goto, type=%u, ix=%ld\n\n(P) We popped the context stack to a context with the specified label,\nand then discovered it wasn't a context we know how to do a goto in.\n\n=item panic: gp_free failed to free glob pointer\n\n(P) The internal routine used to clear a typeglob's entries tried\nrepeatedly, but each time something re-created entries in the glob.\nMost likely the glob contains an object with a reference back to\nthe glob and a destructor that adds a new object to the glob.\n\n=item panic: INTERPCASEMOD, %s\n\n(P) The lexer got into a bad state at a case modifier.\n\n=item panic: INTERPCONCAT, %s\n\n(P) The lexer got into a bad state parsing a string with brackets.\n\n=item panic: kid popen errno read\n\n(F) A forked child returned an incomprehensible message about its errno.\n\n=item panic: last, type=%u\n\n(P) We popped the context stack to a block context, and then discovered\nit wasn't a block context.\n\n=item panic: leave_scope clearsv\n\n(P) A writable lexical variable became read-only somehow within the\nscope.\n\n=item panic: leave_scope inconsistency %u\n\n(P) The savestack probably got out of sync.  At least, there was an\ninvalid enum on the top of it.\n\n=item panic: magic_killbackrefs\n\n(P) Failed an internal consistency check while trying to reset all weak\nreferences to an object.\n\n=item panic: malloc, %s\n\n(P) Something requested a negative number of bytes of malloc.\n\n=item panic: memory wrap\n\n(P) Something tried to allocate either more memory than possible or a\nnegative amount.\n\n=item panic: pad_alloc, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_free curpad, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_free po\n\n(P) A zero scratch pad offset was detected internally.  An attempt was\nmade to free a target that had not been allocated to begin with.\n\n=item panic: pad_reset curpad, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_sv po\n\n(P) A zero scratch pad offset was detected internally.  Most likely\nan operator needed a target but that target had not been allocated\nfor whatever reason.\n\n=item panic: pad_swipe curpad, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_swipe po\n\n(P) An invalid scratch pad offset was detected internally.\n\n=item panic: pp_iter, type=%u\n\n(P) The foreach iterator got called in a non-loop context frame.\n\n=item panic: pp_match%s\n\n(P) The internal pp_match() routine was called with invalid operational\ndata.\n\n=item panic: realloc, %s\n\n(P) Something requested a negative number of bytes of realloc.\n\n=item panic: reference miscount on nsv in sv_replace() (%d != 1)\n\n(P) The internal sv_replace() function was handed a new SV with a\nreference count other than 1.\n\n=item panic: restartop in %s\n\n(P) Some internal routine requested a goto (or something like it), and\ndidn't supply the destination.\n\n=item panic: return, type=%u\n\n(P) We popped the context stack to a subroutine or eval context, and\nthen discovered it wasn't a subroutine or eval context.\n\n=item panic: scan_num, %s\n\n(P) scan_num() got called on something that wasn't a number.\n\n=item panic: Sequence (?{...}): no code block found in regex m/%s/\n\n(P) While compiling a pattern that has embedded (?{}) or (??{}) code\nblocks, perl couldn't locate the code block that should have already been\nseen and compiled by perl before control passed to the regex compiler.\n\n=item panic: strxfrm() gets absurd - a => %u, ab => %u\n\n(P) The interpreter's sanity check of the C function strxfrm() failed.\nIn your current locale the returned transformation of the string \"ab\"\nis shorter than that of the string \"a\", which makes no sense.\n\n=item panic: sv_chop %s\n\n(P) The sv_chop() routine was passed a position that is not within the\nscalar's string buffer.\n\n=item panic: sv_insert, midend=%p, bigend=%p\n\n(P) The sv_insert() routine was told to remove more string than there\nwas string.\n\n=item panic: top_env\n\n(P) The compiler attempted to do a goto, or something weird like that.\n\n=item panic: unimplemented op %s (#%d) called\n\n(P) The compiler is screwed up and attempted to use an op that isn't\npermitted at run time.\n\n=item panic: unknown OA_*: %x\n\n(P) The internal routine that handles arguments to C<&CORE::foo()>\nsubroutine calls was unable to determine what type of arguments\nwere expected.\n\n=item panic: utf16_to_utf8: odd bytelen\n\n(P) Something tried to call utf16_to_utf8 with an odd (as opposed\nto even) byte length.\n\n=item panic: utf16_to_utf8_reversed: odd bytelen\n\n(P) Something tried to call utf16_to_utf8_reversed with an odd (as opposed\nto even) byte length.\n\n=item panic: yylex, %s\n\n(P) The lexer got into a bad state while processing a case modifier.\n\n=item Parentheses missing around \"%s\" list\n\n(W parenthesis) You said something like\n\n    my $foo, $bar = @_;\n\nwhen you meant\n\n    my ($foo, $bar) = @_;\n\nRemember that \"my\", \"our\", \"local\" and \"state\" bind tighter than comma.\n\n=item Parsing code internal error (%s)\n\n(F) Parsing code supplied by an extension violated the parser's API in\na detectable way.\n\n=item Pattern subroutine nesting without pos change exceeded limit in regex\n\n(F) You used a pattern that uses too many nested subpattern calls without\nconsuming any text.  Restructure the pattern so text is consumed before\nthe nesting limit is exceeded.\n\n=item C<-p> destination: %s\n\n(F) An error occurred during the implicit output invoked by the C<-p>\ncommand-line switch.  (This output goes to STDOUT unless you've\nredirected it with select().)\n\n=item Perl API version %s of %s does not match %s\n\n(F) The XS module in question was compiled against a different incompatible\nversion of Perl than the one that has loaded the XS module.\n\n=item Perl folding rules are not up-to-date for 0x%X; please use the perlbug\nutility to report; in regex; marked by S<<-- HERE> in m/%s/\n\n(S regexp) You used a regular expression with case-insensitive matching,\nand there is a bug in Perl in which the built-in regular expression\nfolding rules are not accurate.  This may lead to incorrect results.\nPlease report this as a bug using the L<perlbug> utility.\n\n=item PerlIO layer ':win32' is experimental\n\n(S experimental::win32_perlio) The C<:win32> PerlIO layer is\nexperimental.  If you want to take the risk of using this layer,\nsimply disable this warning:\n\n    no warnings \"experimental::win32_perlio\";\n\n=item Perl_my_%s() not available\n\n(F) Your platform has very uncommon byte-order and integer size,\nso it was not possible to set up some or all fixed-width byte-order\nconversion functions.  This is only a problem when you're using the\n'<' or '>' modifiers in (un)pack templates.  See L<perlfunc/pack>.\n\n=item Perl %s required (did you mean %s?)--this is only %s, stopped\n\n(F) The code you are trying to run has asked for a newer version of\nPerl than you are running.  Perhaps C<use 5.10> was written instead\nof C<use 5.010> or C<use v5.10>.  Without the leading C<v>, the number is\ninterpreted as a decimal, with every three digits after the\ndecimal point representing a part of the version number.  So 5.10\nis equivalent to v5.100.\n\n=item Perl %s required--this is only %s, stopped\n\n(F) The module in question uses features of a version of Perl more\nrecent than the currently running version.  How long has it been since\nyou upgraded, anyway?  See L<perlfunc/require>.\n\n=item PERL_SH_DIR too long\n\n(F) An error peculiar to OS/2.  PERL_SH_DIR is the directory to find the\nC<sh>-shell in.  See \"PERL_SH_DIR\" in L<perlos2>.\n\n=item PERL_SIGNALS illegal: \"%s\"\n\n(X) See L<perlrun/PERL_SIGNALS> for legal values.\n\n=item Perls since %s too modern--this is %s, stopped\n\n(F) The code you are trying to run claims it will not run\non the version of Perl you are using because it is too new.\nMaybe the code needs to be updated, or maybe it is simply\nwrong and the version check should just be removed.\n\n=item perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set\n\n(S) PERL_HASH_SEED should match /^\\s*(?:0x)?[0-9a-fA-F]+\\s*\\z/ but it\ncontained a non hex character.  This could mean you are not using the\nhash seed you think you are.\n\n=item perl: warning: Setting locale failed.\n\n(S) The whole warning message will look something like:\n\n\tperl: warning: Setting locale failed.\n\tperl: warning: Please check that your locale settings:\n\t        LC_ALL = \"En_US\",\n\t        LANG = (unset)\n\t    are supported and installed on your system.\n\tperl: warning: Falling back to the standard locale (\"C\").\n\nExactly what were the failed locale settings varies.  In the above the\nsettings were that the LC_ALL was \"En_US\" and the LANG had no value.\nThis error means that Perl detected that you and/or your operating\nsystem supplier and/or system administrator have set up the so-called\nlocale system but Perl could not use those settings.  This was not\ndead serious, fortunately: there is a \"default locale\" called \"C\" that\nPerl can and will use, and the script will be run.  Before you really\nfix the problem, however, you will get the same error message each\ntime you run Perl.  How to really fix the problem can be found in\nL<perllocale> section B<LOCALE PROBLEMS>.\n\n=item perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'\n\n(S) Perl was run with the environment variable PERL_PERTURB_KEYS defined\nbut containing an unexpected value.  The legal values of this setting\nare as follows.\n\n  Numeric | String        | Result\n  --------+---------------+-----------------------------------------\n  0       | NO            | Disables key traversal randomization\n  1       | RANDOM        | Enables full key traversal randomization\n  2       | DETERMINISTIC | Enables repeatable key traversal\n          |               | randomization\n\nBoth numeric and string values are accepted, but note that string values are\ncase sensitive.  The default for this setting is \"RANDOM\" or 1.\n\n=item pid %x not a child\n\n(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a\nprocess which isn't a subprocess of the current process.  While this is\nfine from VMS' perspective, it's probably not what you intended.\n\n=item 'P' must have an explicit size in unpack\n\n(F) The unpack format P must have an explicit size, not \"*\".\n\n=item POSIX class [:%s:] unknown in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The class in the character class [: :] syntax is unknown.  The S<<-- HERE>\nshows whereabouts in the regular expression the problem was discovered.\nNote that the POSIX character classes do B<not> have the C<is> prefix\nthe corresponding C interfaces have: in other words, it's C<[[:print:]]>,\nnot C<isprint>.  See L<perlre>.\n\n=item POSIX getpgrp can't take an argument\n\n(F) Your system has POSIX getpgrp(), which takes no argument, unlike\nthe BSD version, which takes a pid.\n\n=item POSIX syntax [%c %c] belongs inside character classes%s in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) Perl thinks that you intended to write a POSIX character\nclass, but didn't use enough brackets.  These POSIX class constructs [:\n:], [= =], and [. .]  go I<inside> character classes, the [] are part of\nthe construct, for example: C<qr/[012[:alpha:]345]/>.  What the regular\nexpression pattern compiled to is probably not what you were intending.\nFor example, C<qr/[:alpha:]/> compiles to a regular bracketed character\nclass consisting of the four characters C<\":\">,  C<\"a\">,  C<\"l\">,\nC<\"h\">, and C<\"p\">.  To specify the POSIX class, it should have been\nwritten C<qr/[[:alpha:]]/>.\n\nNote that [= =] and [. .] are not currently\nimplemented; they are simply placeholders for future extensions and\nwill cause fatal errors.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.  See L<perlre>.\n\nIf the specification of the class was not completely valid, the message\nindicates that.\n\n=item POSIX syntax [. .] is reserved for future extensions in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) Within regular expression character classes ([]) the syntax beginning\nwith \"[.\" and ending with \".]\" is reserved for future extensions.  If you\nneed to represent those character sequences inside a regular expression\ncharacter class, just quote the square brackets with the backslash: \"\\[.\"\nand \".\\]\".  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item POSIX syntax [= =] is reserved for future extensions in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) Within regular expression character classes ([]) the syntax beginning\nwith \"[=\" and ending with \"=]\" is reserved for future extensions.  If you\nneed to represent those character sequences inside a regular expression\ncharacter class, just quote the square brackets with the backslash: \"\\[=\"\nand \"=\\]\".  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item Possible attempt to put comments in qw() list\n\n(W qw) qw() lists contain items separated by whitespace; as with literal\nstrings, comment characters are not ignored, but are instead treated as\nliteral data.  (You may have used different delimiters than the\nparentheses shown here; braces are also frequently used.)\n\nYou probably wrote something like this:\n\n    @list = qw(\n\ta # a comment\n        b # another comment\n    );\n\nwhen you should have written this:\n\n    @list = qw(\n\ta\n        b\n    );\n\nIf you really want comments, build your list the\nold-fashioned way, with quotes and commas:\n\n    @list = (\n        'a',    # a comment\n        'b',    # another comment\n    );\n\n=item Possible attempt to separate words with commas\n\n(W qw) qw() lists contain items separated by whitespace; therefore\ncommas aren't needed to separate the items.  (You may have used\ndifferent delimiters than the parentheses shown here; braces are also\nfrequently used.)\n\nYou probably wrote something like this:\n\n    qw! a, b, c !;\n\nwhich puts literal commas into some of the list items.  Write it without\ncommas if you don't want them to appear in your data:\n\n    qw! a b c !;\n\n=item Possible memory corruption: %s overflowed 3rd argument\n\n(F) An ioctl() or fcntl() returned more than Perl was bargaining for.\nPerl guesses a reasonable buffer size, but puts a sentinel byte at the\nend of the buffer just in case.  This sentinel byte got clobbered, and\nPerl assumes that memory is now corrupted.  See L<perlfunc/ioctl>.\n\n=item Possible precedence issue with control flow operator\n\n(W syntax) There is a possible problem with the mixing of a control\nflow operator (e.g. C<return>) and a low-precedence operator like\nC<or>.  Consider:\n\n    sub { return $a or $b; }\n\nThis is parsed as:\n\n    sub { (return $a) or $b; }\n\nWhich is effectively just:\n\n    sub { return $a; }\n\nEither use parentheses or the high-precedence variant of the operator.\n\nNote this may be also triggered for constructs like:\n\n    sub { 1 if die; }\n\n=item Possible precedence problem on bitwise %s operator\n\n(W precedence) Your program uses a bitwise logical operator in conjunction\nwith a numeric comparison operator, like this :\n\n    if ($x & $y == 0) { ... }\n\nThis expression is actually equivalent to C<$x & ($y == 0)>, due to the\nhigher precedence of C<==>.  This is probably not what you want.  (If you\nreally meant to write this, disable the warning, or, better, put the\nparentheses explicitly and write C<$x & ($y == 0)>).\n\n=item Possible unintended interpolation of $\\ in regex\n\n(W ambiguous) You said something like C<m/$\\/> in a regex.\nThe regex C<m/foo$\\s+bar/m> translates to: match the word 'foo', the output\nrecord separator (see L<perlvar/$\\>) and the letter 's' (one time or more)\nfollowed by the word 'bar'.\n\nIf this is what you intended then you can silence the warning by using \nC<m/${\\}/> (for example: C<m/foo${\\}s+bar/>).\n\nIf instead you intended to match the word 'foo' at the end of the line\nfollowed by whitespace and the word 'bar' on the next line then you can use\nC<m/$(?)\\/> (for example: C<m/foo$(?)\\s+bar/>).\n\n=item Possible unintended interpolation of %s in string\n\n(W ambiguous) You said something like '@foo' in a double-quoted string\nbut there was no array C<@foo> in scope at the time.  If you wanted a\nliteral @foo, then write it as \\@foo; otherwise find out what happened\nto the array you apparently lost track of.\n\n=item Precedence problem: open %s should be open(%s)\n\n(S precedence) The old irregular construct\n\n    open FOO || die;\n\nis now misinterpreted as\n\n    open(FOO || die);\n\nbecause of the strict regularization of Perl 5's grammar into unary and\nlist operators.  (The old open was a little of both.)  You must put\nparentheses around the filehandle, or use the new \"or\" operator instead\nof \"||\".\n\n=item Premature end of script headers\n\nSee L</500 Server error>.\n\n=item printf() on closed filehandle %s\n\n(W closed) The filehandle you're writing to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item print() on closed filehandle %s\n\n(W closed) The filehandle you're printing on got itself closed sometime\nbefore now.  Check your control flow.\n\n=item Process terminated by SIG%s\n\n(W) This is a standard message issued by OS/2 applications, while *nix\napplications die in silence.  It is considered a feature of the OS/2\nport.  One can easily disable this by appropriate sighandlers, see\nL<perlipc/\"Signals\">.  See also \"Process terminated by SIGTERM/SIGINT\"\nin L<perlos2>.\n\n=item Prototype after '%c' for %s : %s\n\n(W illegalproto) A character follows % or @ in a prototype.  This is\nuseless, since % and @ gobble the rest of the subroutine arguments.\n\n=item Prototype mismatch: %s vs %s\n\n(S prototype) The subroutine being declared or defined had previously been\ndeclared or defined with a different function prototype.\n\n=item Prototype not terminated\n\n(F) You've omitted the closing parenthesis in a function prototype\ndefinition.\n\n=item Prototype '%s' overridden by attribute 'prototype(%s)' in %s\n\n(W prototype) A prototype was declared in both the parentheses after\nthe sub name and via the prototype attribute.  The prototype in\nparentheses is useless, since it will be replaced by the prototype\nfrom the attribute before it's ever used.\n\n=item Quantifier follows nothing in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You started a regular expression with a quantifier.  Backslash it if\nyou meant it literally.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.  See L<perlre>.\n\n=item Quantifier in {,} bigger than %d in regex; marked by S<<-- HERE> in m/%s/\n\n(F) There is currently a limit to the size of the min and max values of\nthe {min,max} construct.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.  See L<perlre>.\n\n=item Quantifier {n,m} with n > m can't match in regex\n\n=item Quantifier {n,m} with n > m can't match in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) Minima should be less than or equal to maxima.  If you really\nwant your regexp to match something 0 times, just put {0}.\n\n=item Quantifier unexpected on zero-length expression in regex m/%s/\n\n(W regexp) You applied a regular expression quantifier in a place where\nit makes no sense, such as on a zero-width assertion.  Try putting the\nquantifier inside the assertion instead.  For example, the way to match\n\"abc\" provided that it is followed by three repetitions of \"xyz\" is\nC</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.\n\n=item Range iterator outside integer range\n\n(F) One (or both) of the numeric arguments to the range operator \"..\"\nare outside the range which can be represented by integers internally.\nOne possible workaround is to force Perl to use magical string increment\nby prepending \"0\" to your numbers.\n\n=item Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or\n\"a-z\" in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nStricter rules help to find typos and other errors.  Perhaps you didn't\neven intend a range here, if the C<\"-\"> was meant to be some other\ncharacter, or should have been escaped (like C<\"\\-\">).  If you did\nintend a range, the one that was used is not portable between ASCII and\nEBCDIC platforms, and doesn't have an obvious meaning to a casual\nreader.\n\n [3-7]    # OK; Obvious and portable\n [d-g]    # OK; Obvious and portable\n [A-Y]    # OK; Obvious and portable\n [A-z]    # WRONG; Not portable; not clear what is meant\n [a-Z]    # WRONG; Not portable; not clear what is meant\n [%-.]    # WRONG; Not portable; not clear what is meant\n [\\x41-Z] # WRONG; Not portable; not obvious to non-geek\n\n(You can force portability by specifying a Unicode range, which means that\nthe endpoints are specified by\nL<C<\\N{...}>|perlrecharclass/Character Ranges>, but the meaning may\nstill not be obvious.)\nThe stricter rules require that ranges that start or stop with an ASCII\ncharacter that is not a control have all their endpoints be the literal\ncharacter, and not some escape sequence (like C<\"\\x41\">), and the ranges\nmust be all digits, or all uppercase letters, or all lowercase letters.\n\n=item Ranges of digits should be from the same group in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nStricter rules help to find typos and other errors.  You included a\nrange, and at least one of the end points is a decimal digit.  Under the\nstricter rules, when this happens, both end points should be digits in\nthe same group of 10 consecutive digits.\n\n=item readdir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you're reading from is either closed or not really\na dirhandle.  Check your control flow.\n\n=item readline() on closed filehandle %s\n\n(W closed) The filehandle you're reading from got itself closed sometime\nbefore now.  Check your control flow.\n\n=item read() on closed filehandle %s\n\n(W closed) You tried to read from a closed filehandle.\n\n=item read() on unopened filehandle %s\n\n(W unopened) You tried to read from a filehandle that was never opened.\n\n=item Reallocation too large: %x\n\n(F) You can't allocate more than 64K on an MS-DOS machine.\n\n=item realloc() of freed memory ignored\n\n(S malloc) An internal routine called realloc() on something that had\nalready been freed.\n\n=item Recompile perl with B<-D>DEBUGGING to use B<-D> switch\n\n(S debugging) You can't use the B<-D> option unless the code to produce\nthe desired output is compiled into Perl, which entails some overhead,\nwhich is why it's currently left out of your copy.\n\n=item Recursive call to Perl_load_module in PerlIO_find_layer\n\n(P) It is currently not permitted to load modules when creating\na filehandle inside an %INC hook.  This can happen with C<open my\n$fh, '<', \\$scalar>, which implicitly loads PerlIO::scalar.  Try\nloading PerlIO::scalar explicitly first.\n\n=item Recursive inheritance detected in package '%s'\n\n(F) While calculating the method resolution order (MRO) of a package, Perl\nbelieves it found an infinite loop in the C<@ISA> hierarchy.  This is a\ncrude check that bails out after 100 levels of C<@ISA> depth.\n\n=item Redundant argument in %s\n\n(W redundant) You called a function with more arguments than other\narguments you supplied indicated would be needed.  Currently only\nemitted when a printf-type format required fewer arguments than were\nsupplied, but might be used in the future for e.g. L<perlfunc/pack>.\n\n=item refcnt_dec: fd %d%s\n\n=item refcnt: fd %d%s\n\n=item refcnt_inc: fd %d%s\n\n(P) Perl's I/O implementation failed an internal consistency check.  If\nyou see this message, something is very wrong.\n\n=item Reference found where even-sized list expected\n\n(W misc) You gave a single reference where Perl was expecting a list\nwith an even number of elements (for assignment to a hash).  This\nusually means that you used the anon hash constructor when you meant\nto use parens.  In any case, a hash requires key/value B<pairs>.\n\n    %hash = { one => 1, two => 2, };\t# WRONG\n    %hash = [ qw/ an anon array / ];\t# WRONG\n    %hash = ( one => 1, two => 2, );\t# right\n    %hash = qw( one 1 two 2 );\t\t\t# also fine\n\n=item Reference is already weak\n\n(W misc) You have attempted to weaken a reference that is already weak.\nDoing so has no effect.\n\n=item Reference is not weak\n\n(W misc) You have attempted to unweaken a reference that is not weak.\nDoing so has no effect.\n\n=item Reference to invalid group 0 in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You used C<\\g0> or similar in a regular expression.  You may refer\nto capturing parentheses only with strictly positive integers\n(normal backreferences) or with strictly negative integers (relative\nbackreferences).  Using 0 does not make sense.\n\n=item Reference to nonexistent group in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You used something like C<\\7> in your regular expression, but there are\nnot at least seven sets of capturing parentheses in the expression.  If\nyou wanted to have the character with ordinal 7 inserted into the regular\nexpression, prepend zeroes to make it three digits long: C<\\007>\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Reference to nonexistent named group in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) You used something like C<\\k'NAME'> or C<< \\k<NAME> >> in your regular\nexpression, but there is no corresponding named capturing parentheses\nsuch as C<(?'NAME'...)> or C<< (?<NAME>...) >>.  Check if the name has been\nspelled correctly both in the backreference and the declaration.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Reference to nonexistent or unclosed group in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used something like C<\\g{-7}> in your regular expression, but there\nare not at least seven sets of closed capturing parentheses in the\nexpression before where the C<\\g{-7}> was located.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item regexp memory corruption\n\n(P) The regular expression engine got confused by what the regular\nexpression compiler gave it.\n\n=item Regexp modifier \"/%c\" may appear a maximum of twice\n\n=item Regexp modifier \"%c\" may appear a maximum of twice in regex; marked\nby S<<-- HERE> in m/%s/\n\n(F) The regular expression pattern had too many occurrences\nof the specified modifier.  Remove the extraneous ones.\n\n=item Regexp modifier \"%c\" may not appear after the \"-\" in regex; marked by <-- \nHERE in m/%s/\n\n(F) Turning off the given modifier has the side effect of turning on\nanother one.  Perl currently doesn't allow this.  Reword the regular\nexpression to use the modifier you want to turn on (and place it before\nthe minus), instead of the one you want to turn off.\n\n=item Regexp modifier \"/%c\" may not appear twice\n\n=item Regexp modifier \"%c\" may not appear twice in regex; marked by <--\nHERE in m/%s/\n\n(F) The regular expression pattern had too many occurrences\nof the specified modifier.  Remove the extraneous ones.\n\n=item Regexp modifiers \"/%c\" and \"/%c\" are mutually exclusive\n\n=item Regexp modifiers \"%c\" and \"%c\" are mutually exclusive in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The regular expression pattern had more than one of these\nmutually exclusive modifiers.  Retain only the modifier that is\nsupposed to be there.\n\n=item Regexp out of space in regex m/%s/\n\n(P) A \"can't happen\" error, because safemalloc() should have caught it\nearlier.\n\n=item Repeated format line will never terminate (~~ and @#)\n\n(F) Your format contains the ~~ repeat-until-blank sequence and a\nnumeric field that will never go blank so that the repetition never\nterminates.  You might use ^# instead.  See L<perlform>.\n\n=item Replacement list is longer than search list\n\n(W misc) You have used a replacement list that is longer than the\nsearch list.  So the additional elements in the replacement list\nare meaningless.\n\n=item '%s' resolved to '\\o{%s}%d'\n\n(W misc, regexp)  You wrote something like C<\\08>, or C<\\179> in a\ndouble-quotish string.  All but the last digit is treated as a single\ncharacter, specified in octal.  The last digit is the next character in\nthe string.  To tell Perl that this is indeed what you want, you can use\nthe C<\\o{ }> syntax, or use exactly three digits to specify the octal\nfor the character.\n\n=item Reversed %s= operator\n\n(W syntax) You wrote your assignment operator backwards.  The = must\nalways come last, to avoid ambiguity with subsequent unary operators.\n\n=item rewinddir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you tried to do a rewinddir() on is either closed\nor not really a dirhandle.  Check your control flow.\n\n=item Scalars leaked: %d\n\n(S internal) Something went wrong in Perl's internal bookkeeping\nof scalars: not all scalar variables were deallocated by the time\nPerl exited.  What this usually indicates is a memory leak, which\nis of course bad, especially if the Perl program is intended to be\nlong-running.\n\n=item Scalar value @%s[%s] better written as $%s[%s]\n\n(W syntax) You've used an array slice (indicated by @) to select a\nsingle element of an array.  Generally it's better to ask for a scalar\nvalue (indicated by $).  The difference is that C<$foo[&bar]> always\nbehaves like a scalar, both when assigning to it and when evaluating its\nargument, while C<@foo[&bar]> behaves like a list when you assign to it,\nand provides a list context to its subscript, which can do weird things\nif you're expecting only one subscript.\n\nOn the other hand, if you were actually hoping to treat the array\nelement as a list, you need to look into how references work, because\nPerl will not magically convert between scalars and lists for you.  See\nL<perlref>.\n\n=item Scalar value @%s{%s} better written as $%s{%s}\n\n(W syntax) You've used a hash slice (indicated by @) to select a single\nelement of a hash.  Generally it's better to ask for a scalar value\n(indicated by $).  The difference is that C<$foo{&bar}> always behaves\nlike a scalar, both when assigning to it and when evaluating its\nargument, while C<@foo{&bar}> behaves like a list when you assign to it,\nand provides a list context to its subscript, which can do weird things\nif you're expecting only one subscript.\n\nOn the other hand, if you were actually hoping to treat the hash element\nas a list, you need to look into how references work, because Perl will\nnot magically convert between scalars and lists for you.  See\nL<perlref>.\n\n=item Search pattern not terminated\n\n(F) The lexer couldn't find the final delimiter of a // or m{}\nconstruct.  Remember that bracketing delimiters count nesting level.\nMissing the leading C<$> from a variable C<$m> may cause this error.\n\nNote that since Perl 5.10.0 a // can also be the I<defined-or>\nconstruct, not just the empty search pattern.  Therefore code written\nin Perl 5.10.0 or later that uses the // as the I<defined-or> can be\nmisparsed by pre-5.10.0 Perls as a non-terminated search pattern.\n\n=item seekdir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you are doing a seekdir() on is either closed or not\nreally a dirhandle.  Check your control flow.\n\n=item %sseek() on unopened filehandle\n\n(W unopened) You tried to use the seek() or sysseek() function on a\nfilehandle that was either never opened or has since been closed.\n\n=item select not implemented\n\n(F) This machine doesn't implement the select() system call.\n\n=item Self-ties of arrays and hashes are not supported\n\n(F) Self-ties are of arrays and hashes are not supported in\nthe current implementation.\n\n=item Semicolon seems to be missing\n\n(W semicolon) A nearby syntax error was probably caused by a missing\nsemicolon, or possibly some other missing operator, such as a comma.\n\n=item semi-panic: attempt to dup freed string\n\n(S internal) The internal newSVsv() routine was called to duplicate a\nscalar that had previously been marked as free.\n\n=item sem%s not implemented\n\n(F) You don't have System V semaphore IPC on your system.\n\n=item send() on closed socket %s\n\n(W closed) The socket you're sending to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item Sequence \"\\c{\" invalid\n\n(F) These three characters may not appear in sequence in a\ndouble-quotish context.  This message is raised only on non-ASCII\nplatforms (a different error message is output on ASCII ones).  If you\nwere intending to specify a control character with this sequence, you'll\nhave to use a different way to specify it.\n\n=item Sequence (? incomplete in regex; marked by S<<-- HERE> in m/%s/\n\n(F) A regular expression ended with an incomplete extension (?.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Sequence (?%c...) not implemented in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) A proposed regular expression extension has the character reserved\nbut has not yet been written.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.  See L<perlre>.\n\n=item Sequence (?%s...) not recognized in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You used a regular expression extension that doesn't make sense.\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  This may happen when using the C<(?^...)> construct to tell\nPerl to use the default regular expression modifiers, and you\nredundantly specify a default modifier.  For other\ncauses, see L<perlre>.\n\n=item Sequence (?#... not terminated in regex m/%s/\n\n(F) A regular expression comment must be terminated by a closing\nparenthesis.  Embedded parentheses aren't allowed.  See\nL<perlre>.\n\n=item Sequence (?&... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) A named reference of the form C<(?&...)> was missing the final\nclosing parenthesis after the name.  The S<<-- HERE> shows whereabouts\nin the regular expression the problem was discovered.\n\n=item Sequence (?%c... not terminated in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) A named group of the form C<(?'...')> or C<< (?<...>) >> was missing the final\nclosing quote or angle bracket.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.\n\n=item Sequence (?(%c... not terminated in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) A named reference of the form C<(?('...')...)> or C<< (?(<...>)...) >> was\nmissing the final closing quote or angle bracket after the name.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Sequence (?... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) There was no matching closing parenthesis for the '('.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Sequence \\%s... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) The regular expression expects a mandatory argument following the escape\nsequence and this has been omitted or incorrectly written.\n\n=item Sequence (?{...}) not terminated with ')'\n\n(F) The end of the perl code contained within the {...} must be\nfollowed immediately by a ')'.\n\n=item Sequence (?PE<gt>... not terminated in regex; marked by S<<-- HERE> in m/%s/\n\n(F) A named reference of the form C<(?PE<gt>...)> was missing the final\nclosing parenthesis after the name.  The S<<-- HERE> shows whereabouts\nin the regular expression the problem was discovered.\n\n=item Sequence (?PE<lt>... not terminated in regex; marked by S<<-- HERE> in m/%s/\n\n(F) A named group of the form C<(?PE<lt>...E<gt>')> was missing the final\nclosing angle bracket.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.\n\n=item Sequence ?P=... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) A named reference of the form C<(?P=...)> was missing the final\nclosing parenthesis after the name.  The S<<-- HERE> shows whereabouts\nin the regular expression the problem was discovered.\n\n=item Sequence (?R) not terminated in regex m/%s/\n\n(F) An C<(?R)> or C<(?0)> sequence in a regular expression was missing the\nfinal parenthesis.\n\n=item Z<>500 Server error\n\n(A) This is the error message generally seen in a browser window\nwhen trying to run a CGI program (including SSI) over the web.  The\nactual error text varies widely from server to server.  The most\nfrequently-seen variants are \"500 Server error\", \"Method (something)\nnot permitted\", \"Document contains no data\", \"Premature end of script\nheaders\", and \"Did not produce a valid header\".\n\nB<This is a CGI error, not a Perl error>.\n\nYou need to make sure your script is executable, is accessible by\nthe user CGI is running the script under (which is probably not the\nuser account you tested it under), does not rely on any environment\nvariables (like PATH) from the user it isn't running under, and isn't\nin a location where the CGI server can't find it, basically, more or\nless.  Please see the following for more information:\n\n\thttp://www.perl.org/CGI_MetaFAQ.html\n\thttp://www.htmlhelp.org/faq/cgifaq.html\n\thttp://www.w3.org/Security/Faq/\n\nYou should also look at L<perlfaq9>.\n\n=item setegid() not implemented\n\n(F) You tried to assign to C<$)>, and your operating system doesn't\nsupport the setegid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item seteuid() not implemented\n\n(F) You tried to assign to C<< $> >>, and your operating system doesn't\nsupport the seteuid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item setpgrp can't take arguments\n\n(F) Your system has the setpgrp() from BSD 4.2, which takes no\narguments, unlike POSIX setpgid(), which takes a process ID and process\ngroup ID.\n\n=item setrgid() not implemented\n\n(F) You tried to assign to C<$(>, and your operating system doesn't\nsupport the setrgid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item setruid() not implemented\n\n(F) You tried to assign to C<$<>, and your operating system doesn't\nsupport the setruid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item setsockopt() on closed socket %s\n\n(W closed) You tried to set a socket option on a closed socket.  Did you\nforget to check the return value of your socket() call?  See\nL<perlfunc/setsockopt>.\n\n=item Setting $/ to a reference to %s is forbidden\n\n(F) You assigned a reference to a scalar to C<$/> where the referenced item is\nnot a positive integer.  In older perls this B<appeared> to work the same as\nsetting it to C<undef> but was in fact internally different, less efficient\nand with very bad luck could have resulted in your file being split by a\nstringified form of the reference.\n\nIn Perl 5.20.0 this was changed so that it would be B<exactly> the same as\nsetting C<$/> to undef, with the exception that this warning would be thrown.\n\nYou are recommended to change your code to set C<$/> to C<undef> explicitly if\nyou wish to slurp the file.  As of Perl 5.28 assigning C<$/> to a reference\nto an integer which isn't positive is a fatal error.\n\n=item Setting $/ to %s reference is forbidden\n\n(F) You tried to assign a reference to a non integer to C<$/>.  In older\nPerls this would have behaved similarly to setting it to a reference to\na positive integer, where the integer was the address of the reference.\nAs of Perl 5.20.0 this is a fatal error, to allow future versions of Perl\nto use non-integer refs for more interesting purposes.\n\n=item shm%s not implemented\n\n(F) You don't have System V shared memory IPC on your system.\n\n=item !=~ should be !~\n\n(W syntax) The non-matching operator is !~, not !=~.  !=~ will be\ninterpreted as the != (numeric not equal) and ~ (1's complement)\noperators: probably not what you intended.\n\n=item /%s/ should probably be written as \"%s\"\n\n(W syntax) You have used a pattern where Perl expected to find a string,\nas in the first argument to C<join>.  Perl will treat the true or false\nresult of matching the pattern against $_ as the string, which is\nprobably not what you had in mind.\n\n=item shutdown() on closed socket %s\n\n(W closed) You tried to do a shutdown on a closed socket.  Seems a bit\nsuperfluous.\n\n=item SIG%s handler \"%s\" not defined\n\n(W signal) The signal handler named in %SIG doesn't, in fact, exist.\nPerhaps you put it into the wrong package?\n\n=item Slab leaked from cv %p\n\n(S) If you see this message, then something is seriously wrong with the\ninternal bookkeeping of op trees.  An op tree needed to be freed after\na compilation error, but could not be found, so it was leaked instead.\n\n=item sleep(%u) too large\n\n(W overflow) You called C<sleep> with a number that was larger than\nit can reliably handle and C<sleep> probably slept for less time than\nrequested.\n\n=item Slurpy parameter not last\n\n(F) In a subroutine signature, you put something after a slurpy (array or\nhash) parameter.  The slurpy parameter takes all the available arguments,\nso there can't be any left to fill later parameters.\n\n=item Smart matching a non-overloaded object breaks encapsulation\n\n(F) You should not use the C<~~> operator on an object that does not\noverload it: Perl refuses to use the object's underlying structure\nfor the smart match.\n\n=item Smartmatch is experimental\n\n(S experimental::smartmatch) This warning is emitted if you\nuse the smartmatch (C<~~>) operator.  This is currently an experimental\nfeature, and its details are subject to change in future releases of\nPerl.  Particularly, its current behavior is noticed for being\nunnecessarily complex and unintuitive, and is very likely to be\noverhauled.\n\n=item Sorry, hash keys must be smaller than 2**31 bytes\n\n(F) You tried to create a hash containing a very large key, where \"very\nlarge\" means that it needs at least 2 gigabytes to store. Unfortunately,\nPerl doesn't yet handle such large hash keys. You should\nreconsider your design to avoid hashing such a long string directly.\n\n=item sort is now a reserved word\n\n(F) An ancient error message that almost nobody ever runs into anymore.\nBut before sort was a keyword, people sometimes used it as a filehandle.\n\n=item Source filters apply only to byte streams\n\n(F) You tried to activate a source filter (usually by loading a\nsource filter module) within a string passed to C<eval>.  This is\nnot permitted under the C<unicode_eval> feature.  Consider using\nC<evalbytes> instead.  See L<feature>.\n\n=item splice() offset past end of array\n\n(W misc) You attempted to specify an offset that was past the end of\nthe array passed to splice().  Splicing will instead commence at the\nend of the array, rather than past it.  If this isn't what you want,\ntry explicitly pre-extending the array by assigning $#array = $offset.\nSee L<perlfunc/splice>.\n\n=item Split loop\n\n(P) The split was looping infinitely.  (Obviously, a split shouldn't\niterate more times than there are characters of input, which is what\nhappened.)  See L<perlfunc/split>.\n\n=item Statement unlikely to be reached\n\n(W exec) You did an exec() with some statement after it other than a\ndie().  This is almost always an error, because exec() never returns\nunless there was a failure.  You probably wanted to use system()\ninstead, which does return.  To suppress this warning, put the exec() in\na block by itself.\n\n=item \"state\" subroutine %s can't be in a package\n\n(F) Lexically scoped subroutines aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.\n\n=item \"state %s\" used in sort comparison\n\n(W syntax) The package variables $a and $b are used for sort comparisons.\nYou used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a\nsort comparison block, and the variable had earlier been declared as a\nlexical variable.  Either qualify the sort variable with the package\nname, or rename the lexical variable.\n\n=item \"state\" variable %s can't be in a package\n\n(F) Lexically scoped variables aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.  Use\nlocal() if you want to localize a package variable.\n\n=item stat() on unopened filehandle %s\n\n(W unopened) You tried to use the stat() function on a filehandle that\nwas either never opened or has since been closed.\n\n=item Strings with code points over 0xFF may not be mapped into in-memory file handles\n\n(W utf8) You tried to open a reference to a scalar for read or append\nwhere the scalar contained code points over 0xFF.  In-memory files\nmodel on-disk files and can only contain bytes.\n\n=item Stub found while resolving method \"%s\" overloading \"%s\" in package \"%s\"\n\n(P) Overloading resolution over @ISA tree may be broken by importation\nstubs.  Stubs should never be implicitly created, but explicit calls to\nC<can> may break this.\n\n=item Subroutine \"&%s\" is not available\n\n(W closure) During compilation, an inner named subroutine or eval is\nattempting to capture an outer lexical subroutine that is not currently\navailable.  This can happen for one of two reasons.  First, the lexical\nsubroutine may be declared in an outer anonymous subroutine that has\nnot yet been created.  (Remember that named subs are created at compile\ntime, while anonymous subs are created at run-time.)  For example,\n\n    sub { my sub a {...} sub f { \\&a } }\n\nAt the time that f is created, it can't capture the current \"a\" sub,\nsince the anonymous subroutine hasn't been created yet.  Conversely, the\nfollowing won't give a warning since the anonymous subroutine has by now\nbeen created and is live:\n\n    sub { my sub a {...} eval 'sub f { \\&a }' }->();\n\nThe second situation is caused by an eval accessing a lexical subroutine\nthat has gone out of scope, for example,\n\n    sub f {\n\tmy sub a {...}\n\tsub { eval '\\&a' }\n    }\n    f()->();\n\nHere, when the '\\&a' in the eval is being compiled, f() is not currently\nbeing executed, so its &a is not available for capture.\n\n=item \"%s\" subroutine &%s masks earlier declaration in same %s\n\n(W shadow) A \"my\" or \"state\" subroutine has been redeclared in the\ncurrent scope or statement, effectively eliminating all access to\nthe previous instance.  This is almost always a typographical error.\nNote that the earlier subroutine will still exist until the end of\nthe scope or until all closure references to it are destroyed.\n\n=item Subroutine %s redefined\n\n(W redefine) You redefined a subroutine.  To suppress this warning, say\n\n    {\n\tno warnings 'redefine';\n\teval \"sub name { ... }\";\n    }\n\n=item Subroutine \"%s\" will not stay shared\n\n(W closure) An inner (nested) I<named> subroutine is referencing a \"my\"\nsubroutine defined in an outer named subroutine.\n\nWhen the inner subroutine is called, it will see the value of the outer\nsubroutine's lexical subroutine as it was before and during the *first*\ncall to the outer subroutine; in this case, after the first call to the\nouter subroutine is complete, the inner and outer subroutines will no\nlonger share a common value for the lexical subroutine.  In other words,\nit will no longer be shared.  This will especially make a difference\nif the lexical subroutines accesses lexical variables declared in its\nsurrounding scope.\n\nThis problem can usually be solved by making the inner subroutine\nanonymous, using the C<sub {}> syntax.  When inner anonymous subs that\nreference lexical subroutines in outer subroutines are created, they\nare automatically rebound to the current values of such lexical subs.\n\n=item Substitution loop\n\n(P) The substitution was looping infinitely.  (Obviously, a substitution\nshouldn't iterate more times than there are characters of input, which\nis what happened.)  See the discussion of substitution in\nL<perlop/\"Regexp Quote-Like Operators\">.\n\n=item Substitution pattern not terminated\n\n(F) The lexer couldn't find the interior delimiter of an s/// or s{}{}\nconstruct.  Remember that bracketing delimiters count nesting level.\nMissing the leading C<$> from variable C<$s> may cause this error.\n\n=item Substitution replacement not terminated\n\n(F) The lexer couldn't find the final delimiter of an s/// or s{}{}\nconstruct.  Remember that bracketing delimiters count nesting level.\nMissing the leading C<$> from variable C<$s> may cause this error.\n\n=item substr outside of string\n\n(W substr)(F) You tried to reference a substr() that pointed outside of\na string.  That is, the absolute value of the offset was larger than the\nlength of the string.  See L<perlfunc/substr>.  This warning is fatal if\nsubstr is used in an lvalue context (as the left hand side of an\nassignment or as a subroutine argument for example).\n\n=item sv_upgrade from type %d down to type %d\n\n(P) Perl tried to force the upgrade of an SV to a type which was actually\ninferior to its current type.\n\n=item SWASHNEW didn't return an HV ref\n\n(P) Something went wrong internally when Perl was trying to look up\nUnicode characters.\n\n=item Switch (?(condition)... contains too many branches in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) A (?(condition)if-clause|else-clause) construct can have at most\ntwo branches (the if-clause and the else-clause).  If you want one or\nboth to contain alternation, such as using C<this|that|other>, enclose\nit in clustering parentheses:\n\n    (?(condition)(?:this|that|other)|else-clause)\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem\nwas discovered.  See L<perlre>.\n\n=item Switch condition not recognized in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) The condition part of a (?(condition)if-clause|else-clause) construct\nis not known.  The condition must be one of the following:\n\n (1) (2) ...        true if 1st, 2nd, etc., capture matched\n (<NAME>) ('NAME')  true if named capture matched\n (?=...) (?<=...)   true if subpattern matches\n (?!...) (?<!...)   true if subpattern fails to match\n (?{ CODE })        true if code returns a true value\n (R)                true if evaluating inside recursion\n (R1) (R2) ...      true if directly inside capture group 1, 2, etc.\n (R&NAME)           true if directly inside named capture\n (DEFINE)           always false; for defining named subpatterns\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Switch (?(condition)... not terminated in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You omitted to close a (?(condition)...) block somewhere\nin the pattern.  Add a closing parenthesis in the appropriate\nposition.  See L<perlre>.\n\n=item switching effective %s is not implemented\n\n(F) While under the C<use filetest> pragma, we cannot switch the real\nand effective uids or gids.\n\n=item syntax error\n\n(F) Probably means you had a syntax error.  Common reasons include:\n\n    A keyword is misspelled.\n    A semicolon is missing.\n    A comma is missing.\n    An opening or closing parenthesis is missing.\n    An opening or closing brace is missing.\n    A closing quote is missing.\n\nOften there will be another error message associated with the syntax\nerror giving more information.  (Sometimes it helps to turn on B<-w>.)\nThe error message itself often tells you where it was in the line when\nit decided to give up.  Sometimes the actual error is several tokens\nbefore this, because Perl is good at understanding random input.\nOccasionally the line number may be misleading, and once in a blue moon\nthe only way to figure out what's triggering the error is to call\nC<perl -c> repeatedly, chopping away half the program each time to see\nif the error went away.  Sort of the cybernetic version of S<20 questions>.\n\n=item syntax error at line %d: '%s' unexpected\n\n(A) You've accidentally run your script through the Bourne shell instead\nof Perl.  Check the #! line, or manually feed your script into Perl\nyourself.\n\n=item syntax error in file %s at line %d, next 2 tokens \"%s\"\n\n(F) This error is likely to occur if you run a perl5 script through\na perl4 interpreter, especially if the next 2 tokens are \"use strict\"\nor \"my $var\" or \"our $var\".\n\n=item Syntax error in (?[...]) in regex m/%s/\n\n(F) Perl could not figure out what you meant inside this construct; this\nnotifies you that it is giving up trying.\n\n=item %s syntax OK\n\n(F) The final summary message when a C<perl -c> succeeds.\n\n=item sysread() on closed filehandle %s\n\n(W closed) You tried to read from a closed filehandle.\n\n=item sysread() on unopened filehandle %s\n\n(W unopened) You tried to read from a filehandle that was never opened.\n\n=item System V %s is not implemented on this machine\n\n(F) You tried to do something with a function beginning with \"sem\",\n\"shm\", or \"msg\" but that System V IPC is not implemented in your\nmachine.  In some machines the functionality can exist but be\nunconfigured.  Consult your system support.\n\n=item syswrite() on closed filehandle %s\n\n(W closed) The filehandle you're writing to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item C<-T> and C<-B> not implemented on filehandles\n\n(F) Perl can't peek at the stdio buffer of filehandles when it doesn't\nknow about your kind of stdio.  You'll have to use a filename instead.\n\n=item Target of goto is too deeply nested\n\n(F) You tried to use C<goto> to reach a label that was too deeply nested\nfor Perl to reach.  Perl is doing you a favor by refusing.\n\n=item telldir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you tried to telldir() is either closed or not really\na dirhandle.  Check your control flow.\n\n=item tell() on unopened filehandle\n\n(W unopened) You tried to use the tell() function on a filehandle that\nwas either never opened or has since been closed.\n\n=item That use of $[ is unsupported\n\n(F) Assignment to C<$[> is now strictly circumscribed, and interpreted\nas a compiler directive.  You may say only one of\n\n    $[ = 0;\n    $[ = 1;\n    ...\n    local $[ = 0;\n    local $[ = 1;\n    ...\n\nThis is to prevent the problem of one module changing the array base out\nfrom under another module inadvertently.  See L<perlvar/$[> and L<arybase>.\n\n=item The bitwise feature is experimental\n\n(S experimental::bitwise) This warning is emitted if you use bitwise\noperators (C<& | ^ ~ &. |. ^. ~.>) with the \"bitwise\" feature enabled.\nSimply suppress the warning if you want to use the feature, but know\nthat in doing so you are taking the risk of using an experimental\nfeature which may change or be removed in a future Perl version:\n\n    no warnings \"experimental::bitwise\";\n    use feature \"bitwise\";\n    $x |.= $y;\n\n=item The crypt() function is unimplemented due to excessive paranoia.\n\n(F) Configure couldn't find the crypt() function on your machine,\nprobably because your vendor didn't supply it, probably because they\nthink the U.S. Government thinks it's a secret, or at least that they\nwill continue to pretend that it is.  And if you quote me on that, I\nwill deny it.\n\n=item The experimental declared_refs feature is not enabled\n\n(F) To declare references to variables, as in C<my \\%x>, you must first enable\nthe feature:\n\n    no warnings \"experimental::declared_refs\";\n    use feature \"declared_refs\";\n\n=item The %s function is unimplemented\n\n(F) The function indicated isn't implemented on this architecture,\naccording to the probings of Configure.\n\n=item The regex_sets feature is experimental\n\n(S experimental::regex_sets) This warning is emitted if you\nuse the syntax S<C<(?[   ])>> in a regular expression.\nThe details of this feature are subject to change.\nif you want to use it, but know that in doing so you\nare taking the risk of using an experimental feature which may\nchange in a future Perl version, you can do this to silence the\nwarning:\n\n    no warnings \"experimental::regex_sets\";\n\n=item The signatures feature is experimental\n\n(S experimental::signatures) This warning is emitted if you unwrap a\nsubroutine's arguments using a signature.  Simply suppress the warning\nif you want to use the feature, but know that in doing so you are taking\nthe risk of using an experimental feature which may change or be removed\nin a future Perl version:\n\n    no warnings \"experimental::signatures\";\n    use feature \"signatures\";\n    sub foo ($left, $right) { ... }\n\n=item The stat preceding %s wasn't an lstat\n\n(F) It makes no sense to test the current stat buffer for symbolic\nlinkhood if the last stat that wrote to the stat buffer already went\npast the symlink to get to the real file.  Use an actual filename\ninstead.\n\n=item The 'unique' attribute may only be applied to 'our' variables\n\n(F) This attribute was never supported on C<my> or C<sub> declarations.\n\n=item This Perl can't reset CRTL environ elements (%s)\n\n=item This Perl can't set CRTL environ elements (%s=%s)\n\n(W internal) Warnings peculiar to VMS.  You tried to change or delete an\nelement of the CRTL's internal environ array, but your copy of Perl\nwasn't built with a CRTL that contained the setenv() function.  You'll\nneed to rebuild Perl with a CRTL that does, or redefine\nF<PERL_ENV_TABLES> (see L<perlvms>) so that the environ array isn't the\ntarget of the change to\n%ENV which produced the warning.\n\n=item This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().\n\n(F) Something has attempted to use an internal API call which\ndepends on Perl being compiled with the default support for randomized hash\nkey traversal, but this Perl has been compiled without it.  You should\nreport this warning to the relevant upstream party, or recompile perl\nwith default options.\n\n=item times not implemented\n\n(F) Your version of the C library apparently doesn't do times().  I\nsuspect you're not running on Unix.\n\n=item \"-T\" is on the #! line, it must also be used on the command line\n\n(X) The #! line (or local equivalent) in a Perl script contains\nthe B<-T> option (or the B<-t> option), but Perl was not invoked with\nB<-T> in its command line.  This is an error because, by the time\nPerl discovers a B<-T> in a script, it's too late to properly taint\neverything from the environment.  So Perl gives up.\n\nIf the Perl script is being executed as a command using the #!\nmechanism (or its local equivalent), this error can usually be\nfixed by editing the #! line so that the B<-%c> option is a part of\nPerl's first argument: e.g. change C<perl -n -%c> to C<perl -%c -n>.\n\nIf the Perl script is being executed as C<perl scriptname>, then the\nB<-%c> option must appear on the command line: C<perl -%c scriptname>.\n\n=item To%s: illegal mapping '%s'\n\n(F) You tried to define a customized To-mapping for lc(), lcfirst,\nuc(), or ucfirst() (or their string-inlined versions), but you\nspecified an illegal mapping.\nSee L<perlunicode/\"User-Defined Character Properties\">.\n\n=item Too deeply nested ()-groups\n\n(F) Your template contains ()-groups with a ridiculously deep nesting level.\n\n=item Too few args to syscall\n\n(F) There has to be at least one argument to syscall() to specify the\nsystem call to call, silly dilly.\n\n=item Too few arguments for subroutine '%s'\n\n(F) A subroutine using a signature fewer arguments than required by the\nsignature.  The caller of the subroutine is presumably at fault.\n\nThe message attempts to include the name of the called subroutine.  If\nthe subroutine has been aliased, the subroutine's original name will be\nshown, regardless of what name the caller used.\n\n=item Too late for \"-%s\" option\n\n(X) The #! line (or local equivalent) in a Perl script contains the\nB<-M>, B<-m> or B<-C> option.\n\nIn the case of B<-M> and B<-m>, this is an error because those options\nare not intended for use inside scripts.  Use the C<use> pragma instead.\n\nThe B<-C> option only works if it is specified on the command line as\nwell (with the same sequence of letters or numbers following).  Either\nspecify this option on the command line, or, if your system supports\nit, make your script executable and run it directly instead of passing\nit to perl.\n\n=item Too late to run %s block\n\n(W void) A CHECK or INIT block is being defined during run time proper,\nwhen the opportunity to run them has already passed.  Perhaps you are\nloading a file with C<require> or C<do> when you should be using C<use>\ninstead.  Or perhaps you should put the C<require> or C<do> inside a\nBEGIN block.\n\n=item Too many args to syscall\n\n(F) Perl supports a maximum of only 14 args to syscall().\n\n=item Too many arguments for %s\n\n(F) The function requires fewer arguments than you specified.\n\n=item Too many arguments for subroutine '%s'\n\n(F) A subroutine using a signature received more arguments than permitted\nby the signature.  The caller of the subroutine is presumably at fault.\n\nThe message attempts to include the name of the called subroutine. If the\nsubroutine has been aliased, the subroutine's original name will be shown,\nregardless of what name the caller used.\n\n=item Too many )'s\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item Too many ('s\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item Trailing \\ in regex m/%s/\n\n(F) The regular expression ends with an unbackslashed backslash.\nBackslash it.   See L<perlre>.\n\n=item Transliteration pattern not terminated\n\n(F) The lexer couldn't find the interior delimiter of a tr/// or tr[][]\nor y/// or y[][] construct.  Missing the leading C<$> from variables\nC<$tr> or C<$y> may cause this error.\n\n=item Transliteration replacement not terminated\n\n(F) The lexer couldn't find the final delimiter of a tr///, tr[][],\ny/// or y[][] construct.\n\n=item '%s' trapped by operation mask\n\n(F) You tried to use an operator from a Safe compartment in which it's\ndisallowed.  See L<Safe>.\n\n=item truncate not implemented\n\n(F) Your machine doesn't implement a file truncation mechanism that\nConfigure knows about.\n\n=item Type of arg %d to &CORE::%s must be %s\n\n(F) The subroutine in question in the CORE package requires its argument\nto be a hard reference to data of the specified type.  Overloading is\nignored, so a reference to an object that is not the specified type, but\nnonetheless has overloading to handle it, will still not be accepted.\n\n=item Type of arg %d to %s must be %s (not %s)\n\n(F) This function requires the argument in that position to be of a\ncertain type.  Arrays must be @NAME or C<@{EXPR}>.  Hashes must be\n%NAME or C<%{EXPR}>.  No implicit dereferencing is allowed--use the\n{EXPR} forms as an explicit dereference.  See L<perlref>.\n\n=item umask not implemented\n\n(F) Your machine doesn't implement the umask function and you tried to\nuse it to restrict permissions for yourself (EXPR & 0700).\n\n=item Unbalanced context: %d more PUSHes than POPs\n\n(S internal) The exit code detected an internal inconsistency in how\nmany execution contexts were entered and left.\n\n=item Unbalanced saves: %d more saves than restores\n\n(S internal) The exit code detected an internal inconsistency in how\nmany values were temporarily localized.\n\n=item Unbalanced scopes: %d more ENTERs than LEAVEs\n\n(S internal) The exit code detected an internal inconsistency in how\nmany blocks were entered and left.\n\n=item Unbalanced string table refcount: (%d) for \"%s\"\n\n(S internal) On exit, Perl found some strings remaining in the shared\nstring table used for copy on write and for hash keys.  The entries\nshould have been freed, so this indicates a bug somewhere.\n\n=item Unbalanced tmps: %d more allocs than frees\n\n(S internal) The exit code detected an internal inconsistency in how\nmany mortal scalars were allocated and freed.\n\n=item Undefined format \"%s\" called\n\n(F) The format indicated doesn't seem to exist.  Perhaps it's really in\nanother package?  See L<perlform>.\n\n=item Undefined sort subroutine \"%s\" called\n\n(F) The sort comparison routine specified doesn't seem to exist.\nPerhaps it's in a different package?  See L<perlfunc/sort>.\n\n=item Undefined subroutine &%s called\n\n(F) The subroutine indicated hasn't been defined, or if it was, it has\nsince been undefined.\n\n=item Undefined subroutine called\n\n(F) The anonymous subroutine you're trying to call hasn't been defined,\nor if it was, it has since been undefined.\n\n=item Undefined subroutine in sort\n\n(F) The sort comparison routine specified is declared but doesn't seem\nto have been defined yet.  See L<perlfunc/sort>.\n\n=item Undefined top format \"%s\" called\n\n(F) The format indicated doesn't seem to exist.  Perhaps it's really in\nanother package?  See L<perlform>.\n\n=item Undefined value assigned to typeglob\n\n(W misc) An undefined value was assigned to a typeglob, a la\nC<*foo = undef>.  This does nothing.  It's possible that you really mean\nC<undef *foo>.\n\n=item %s: Undefined variable\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through in regex; marked by S<<-- HERE> in m/%s/\n\n(D deprecated, regexp)  The simple rule to remember, if you want to\nmatch a literal C<{> character (U+007B C<LEFT CURLY BRACKET>) in a\nregular expression pattern, is to escape each literal instance of it in\nsome way.  Generally easiest is to precede it with a backslash, like\nC<\\{> or enclose it in square brackets (C<[{]>).  If the pattern\ndelimiters are also braces, any matching right brace (C<}>) should\nalso be escaped to avoid confusing the parser, for example,\n\n qr{abc\\{def\\}ghi}\n\nForcing literal C<{> characters to be escaped will enable the Perl\nlanguage to be extended in various ways in future releases.  To avoid\nneedlessly breaking existing code, the restriction is is not enforced in\ncontexts where there are unlikely to ever be extensions that could\nconflict with the use there of C<{> as a literal.\n\nIn this release of Perl, some literal uses of C<{> are fatal, and some\nstill just deprecated.  This is because of an oversight:  some uses of a\nliteral C<{> that should have raised a deprecation warning starting in\nv5.20 did not warn until v5.26.  By making the already-warned uses fatal\nnow, some of the planned extensions can be made to the language sooner.\nThe cases which are still allowed will be fatal in Perl 5.30.\n\nThe contexts where no warnings or errors are raised are:\n\n=over 4\n\n=item *\n\nas the first character in a pattern, or following C<^> indicating to\nanchor the match to the beginning of a line.\n\n=item *\n\nas the first character following a C<|> indicating alternation.\n\n=item *\n\nas the first character in a parenthesized grouping like\n\n /foo({bar)/\n /foo(?:{bar)/\n\n=item *\n\nas the first character following a quantifier\n\n /\\s*{/\n\n=back\n\n=for comment\nThe text of the message above is duplicated below to allow splain (and\n'use diagnostics') to work.  Since one is fatal, and one not, they can't\nbe combined as one message.  And since the non-fatal one is temporary,\nthere's no real need to enhance perldiag to handle this transient case.\n\n=item Unescaped left brace in regex is illegal here in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The simple rule to remember, if you want to\nmatch a literal C<\"{\"> character (U+007B C<LEFT CURLY BRACKET>) in a\nregular expression pattern, is to escape each literal instance of it in\nsome way.  Generally easiest is to precede it with a backslash, like\nC<\"\\{\"> or enclose it in square brackets (C<\"[{]\">).  If the pattern\ndelimiters are also braces, any matching right brace (C<\"}\">) should\nalso be escaped to avoid confusing the parser, for example,\n\n qr{abc\\{def\\}ghi}\n\nForcing literal C<\"{\"> characters to be escaped will enable the Perl\nlanguage to be extended in various ways in future releases.  To avoid\nneedlessly breaking existing code, the restriction is is not enforced in\ncontexts where there are unlikely to ever be extensions that could\nconflict with the use there of C<\"{\"> as a literal.\n\nIn this release of Perl, some literal uses of C<\"{\"> are fatal, and some\nstill just deprecated.  This is because of an oversight:  some uses of a\nliteral C<\"{\"> that should have raised a deprecation warning starting in\nv5.20 did not warn until v5.26.  By making the already-warned uses fatal\nnow, some of the planned extensions can be made to the language sooner.\n\nThe contexts where no warnings or errors are raised are:\n\n=over 4\n\n=item *\n\nas the first character in a pattern, or following C<\"^\"> indicating to\nanchor the match to the beginning of a line.\n\n=item *\n\nas the first character following a C<\"|\"> indicating alternation.\n\n=item *\n\nas the first character in a parenthesized grouping like\n\n /foo({bar)/\n /foo(?:{bar)/\n\n=item *\n\nas the first character following a quantifier\n\n /\\s*{/\n\n=back\n\n=item Unescaped literal '%c' in regex; marked by <-- HERE in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>>)\n\nWithin the scope of C<S<use re 'strict'>> in a regular expression\npattern, you included an unescaped C<}> or C<]> which was interpreted\nliterally.  These two characters are sometimes metacharacters, and\nsometimes literals, depending on what precedes them in the\npattern.  This is unlike the similar C<)> which is always a\nmetacharacter unless escaped.\n\nThis action at a distance, perhaps a large distance, can lead to Perl\nsilently misinterpreting what you meant, so when you specify that you\nwant extra checking by C<S<use re 'strict'>>, this warning is generated.\nIf you meant the character as a literal, simply confirm that to Perl by\npreceding the character with a backslash, or make it into a bracketed\ncharacter class (like C<[}]>).  If you meant it as closing a\ncorresponding C<[> or C<{>, you'll need to look back through the pattern\nto find out why that isn't happening.\n\n=item unexec of %s into %s failed!\n\n(F) The unexec() routine failed for some reason.  See your local FSF\nrepresentative, who probably put it there in the first place.\n\n=item Unexpected binary operator '%c' with no preceding operand in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ | \\p{Digit} ])\n\nwhere the C<\"|\"> is a binary operator with an operand on the right, but\nno operand on the left.\n\n=item Unexpected character in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ z ])\n\nWithin C<(?[ ])>, no literal characters are allowed unless they are\nwithin an inner pair of square brackets, like\n\n (?[ [ z ] ])\n\nAnother possibility is that you forgot a backslash.  Perl isn't smart\nenough to figure out what you really meant.\n\n=item Unexpected constant lvalue entersub entry via type/targ %d:%d\n\n(P) When compiling a subroutine call in lvalue context, Perl failed an\ninternal consistency check.  It encountered a malformed op tree.\n\n=item Unexpected exit %u\n\n(S) exit() was called or the script otherwise finished gracefully when\nC<PERL_EXIT_WARN> was set in C<PL_exit_flags>.\n\n=item Unexpected exit failure %d\n\n(S) An uncaught die() was called when C<PERL_EXIT_WARN> was set in\nC<PL_exit_flags>.\n\n=item Unexpected ')' in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ ( \\p{Digit} + ) ])\n\nThe C<\")\"> is out-of-place.  Something apparently was supposed to\nbe combined with the digits, or the C<\"+\"> shouldn't be there, or\nsomething like that.  Perl can't figure out what was intended.\n\n=item Unexpected '(' with no preceding operator in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ \\p{Digit} ( \\p{Lao} + \\p{Thai} ) ])\n\nThere should be an operator before the C<\"(\">, as there's\nno indication as to how the digits are to be combined\nwith the characters in the Lao and Thai scripts.\n\n=item Unicode non-character U+%X is not recommended for open interchange\n\n(S nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are\ndefined by the Unicode standard to be non-characters.  Those\nare legal codepoints, but are reserved for internal use; so,\napplications shouldn't attempt to exchange them.  An application\nmay not be expecting any of these characters at all, and receiving\nthem may lead to bugs.  If you know what you are doing you can\nturn off this warning by C<no warnings 'nonchar';>.\n\nThis is not really a \"severe\" error, but it is supposed to be\nraised by default even if warnings are not enabled, and currently\nthe only way to do that in Perl is to mark it as serious.\n\n=item Unicode surrogate U+%X is illegal in UTF-8\n\n(S surrogate) You had a UTF-16 surrogate in a context where they are\nnot considered acceptable.  These code points, between U+D800 and\nU+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl\ninternally allows all unsigned integer code points (up to the size limit\navailable on your platform), including surrogates.  But these can cause\nproblems when being input or output, which is likely where this message\ncame from.  If you really really know what you are doing you can turn\noff this warning by C<no warnings 'surrogate';>.\n\n=item Unknown charname '%s'\n\n(F) The name you used inside C<\\N{}> is unknown to Perl.  Check the\nspelling.  You can say C<use charnames \":loose\"> to not have to be\nso precise about spaces, hyphens, and capitalization on standard Unicode\nnames.  (Any custom aliases that have been created must be specified\nexactly, regardless of whether C<:loose> is used or not.)  This error may\nalso happen if the C<\\N{}> is not in the scope of the corresponding\nC<S<use charnames>>.\n\n=item Unknown error\n\n(P) Perl was about to print an error message in C<$@>, but the C<$@> variable\ndid not exist, even after an attempt to create it.\n\n=item Unknown open() mode '%s'\n\n(F) The second argument of 3-argument open() is not among the list\nof valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,\nC<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.\n\n=item Unknown PerlIO layer \"%s\"\n\n(W layer) An attempt was made to push an unknown layer onto the Perl I/O\nsystem.  (Layers take care of transforming data between external and\ninternal representations.)  Note that some layers, such as C<mmap>,\nare not supported in all environments.  If your program didn't\nexplicitly request the failing operation, it may be the result of the\nvalue of the environment variable PERLIO.\n\n=item Unknown process %x sent message to prime_env_iter: %s\n\n(P) An error peculiar to VMS.  Perl was reading values for %ENV before\niterating over it, and someone else stuck a message in the stream of\ndata Perl expected.  Someone's very confused, or perhaps trying to\nsubvert Perl's population of %ENV for nefarious purposes.\n\n=item Unknown regexp modifier \"/%s\"\n\n(F) Alphanumerics immediately following the closing delimiter\nof a regular expression pattern are interpreted by Perl as modifier\nflags for the regex.  One of the ones you specified is invalid.  One way\nthis can happen is if you didn't put in white space between the end of\nthe regex and a following alphanumeric operator:\n\n if ($a =~ /foo/and $bar == 3) { ... }\n\nThe C<\"a\"> is a valid modifier flag, but the C<\"n\"> is not, and raises\nthis error.  Likely what was meant instead was:\n\n if ($a =~ /foo/ and $bar == 3) { ... }\n\n=item Unknown \"re\" subpragma '%s' (known ones are: %s)\n\n(W) You tried to use an unknown subpragma of the \"re\" pragma.\n\n=item Unknown switch condition (?(...)) in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) The condition part of a (?(condition)if-clause|else-clause) construct\nis not known.  The condition must be one of the following:\n\n (1) (2) ...        true if 1st, 2nd, etc., capture matched\n (<NAME>) ('NAME')  true if named capture matched\n (?=...) (?<=...)   true if subpattern matches\n (?!...) (?<!...)   true if subpattern fails to match\n (?{ CODE })        true if code returns a true value\n (R)                true if evaluating inside recursion\n (R1) (R2) ...      true if directly inside capture group 1, 2, etc.\n (R&NAME)           true if directly inside named capture\n (DEFINE)           always false; for defining named subpatterns\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Unknown Unicode option letter '%c'\n\n(F) You specified an unknown Unicode option.  See L<perlrun> documentation\nof the C<-C> switch for the list of known options.\n\n=item Unknown Unicode option value %d\n\n(F) You specified an unknown Unicode option.  See L<perlrun> documentation\nof the C<-C> switch for the list of known options.\n\n=item Unknown verb pattern '%s' in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You either made a typo or have incorrectly put a C<*> quantifier\nafter an open brace in your pattern.  Check the pattern and review\nL<perlre> for details on legal verb patterns.\n\n=item Unknown warnings category '%s'\n\n(F) An error issued by the C<warnings> pragma.  You specified a warnings\ncategory that is unknown to perl at this point.\n\nNote that if you want to enable a warnings category registered by a\nmodule (e.g. C<use warnings 'File::Find'>), you must have loaded this\nmodule first.\n\n=item Unmatched [ in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The brackets around a character class must match.  If you wish to\ninclude a closing bracket in a character class, backslash it or put it\nfirst.  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item Unmatched ( in regex; marked by S<<-- HERE> in m/%s/\n\n=item Unmatched ) in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Unbackslashed parentheses must always be balanced in regular\nexpressions.  If you're a vi user, the % key is valuable for finding\nthe matching parenthesis.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.  See L<perlre>.\n\n=item Unmatched right %s bracket\n\n(F) The lexer counted more closing curly or square brackets than opening\nones, so you're probably missing a matching opening bracket.  As a\ngeneral rule, you'll find the missing one (so to speak) near the place\nyou were last editing.\n\n=item Unquoted string \"%s\" may clash with future reserved word\n\n(W reserved) You used a bareword that might someday be claimed as a\nreserved word.  It's best to put such a word in quotes, or capitalize it\nsomehow, or insert an underbar into it.  You might also declare it as a\nsubroutine.\n\n=item Unrecognized character %s; marked by S<<-- HERE> after %s near column\n%d\n\n(F) The Perl parser has no idea what to do with the specified character\nin your Perl script (or eval) near the specified column.  Perhaps you\ntried  to run a compressed script, a binary program, or a directory as\na Perl program.\n\n=item Unrecognized escape \\%c in character class in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used a backslash-character combination which is not\nrecognized by Perl inside character classes.  This is a fatal\nerror when the character class is used within C<(?[ ])>.\n\n=item Unrecognized escape \\%c in character class passed through in regex; \nmarked by S<<-- HERE> in m/%s/\n\n(W regexp) You used a backslash-character combination which is not\nrecognized by Perl inside character classes.  The character was\nunderstood literally, but this may change in a future version of Perl.\nThe S<<-- HERE> shows whereabouts in the regular expression the\nescape was discovered.\n\n=item Unrecognized escape \\%c passed through\n\n(W misc) You used a backslash-character combination which is not\nrecognized by Perl.  The character was understood literally, but this may\nchange in a future version of Perl.\n\n=item Unrecognized escape \\%s passed through in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) You used a backslash-character combination which is not\nrecognized by Perl.  The character(s) were understood literally, but\nthis may change in a future version of Perl.  The S<<-- HERE> shows\nwhereabouts in the regular expression the escape was discovered.\n\n=item Unrecognized signal name \"%s\"\n\n(F) You specified a signal name to the kill() function that was not\nrecognized.  Say C<kill -l> in your shell to see the valid signal names\non your system.\n\n=item Unrecognized switch: -%s  (-h will show valid options)\n\n(F) You specified an illegal option to Perl.  Don't do that.  (If you\nthink you didn't do that, check the #! line to see if it's supplying the\nbad switch on your behalf.)\n\n=item Unsuccessful %s on filename containing newline\n\n(W newline) A file operation was attempted on a filename, and that\noperation failed, PROBABLY because the filename contained a newline,\nPROBABLY because you forgot to chomp() it off.  See L<perlfunc/chomp>.\n\n=item Unsupported directory function \"%s\" called\n\n(F) Your machine doesn't support opendir() and readdir().\n\n=item Unsupported function %s\n\n(F) This machine doesn't implement the indicated function, apparently.\nAt least, Configure doesn't think so.\n\n=item Unsupported function fork\n\n(F) Your version of executable does not support forking.\n\nNote that under some systems, like OS/2, there may be different flavors\nof Perl executables, some of which may support fork, some not.  Try\nchanging the name you call Perl by to C<perl_>, C<perl__>, and so on.\n\n=item Unsupported script encoding %s\n\n(F) Your program file begins with a Unicode Byte Order Mark (BOM) which\ndeclares it to be in a Unicode encoding that Perl cannot read.\n\n=item Unsupported socket function \"%s\" called\n\n(F) Your machine doesn't support the Berkeley socket mechanism, or at\nleast that's what Configure thought.\n\n=item Unterminated attribute list\n\n(F) The lexer found something other than a simple identifier at the\nstart of an attribute, and it wasn't a semicolon or the start of a\nblock.  Perhaps you terminated the parameter list of the previous\nattribute too soon.  See L<attributes>.\n\n=item Unterminated attribute parameter in attribute list\n\n(F) The lexer saw an opening (left) parenthesis character while parsing\nan attribute list, but the matching closing (right) parenthesis\ncharacter was not found.  You may need to add (or remove) a backslash\ncharacter to get your parentheses to balance.  See L<attributes>.\n\n=item Unterminated compressed integer\n\n(F) An argument to unpack(\"w\",...) was incompatible with the BER\ncompressed integer format and could not be converted to an integer.\nSee L<perlfunc/pack>.\n\n=item Unterminated delimiter for here document\n\n(F) This message occurs when a here document label has an initial\nquotation mark but the final quotation mark is missing.  Perhaps\nyou wrote:\n\n    <<\"foo\n\ninstead of:\n\n    <<\"foo\"\n\n=item Unterminated \\g... pattern in regex; marked by S<<-- HERE> in m/%s/\n\n=item Unterminated \\g{...} pattern in regex; marked by S<<-- HERE> in m/%s/\n\n(F) In a regular expression, you had a C<\\g> that wasn't followed by a\nproper group reference.  In the case of C<\\g{>, the closing brace is\nmissing; otherwise the C<\\g> must be followed by an integer.  Fix the\npattern and retry.\n\n=item Unterminated <> operator\n\n(F) The lexer saw a left angle bracket in a place where it was expecting\na term, so it's looking for the corresponding right angle bracket, and\nnot finding it.  Chances are you left some needed parentheses out\nearlier in the line, and you really meant a \"less than\".\n\n=item Unterminated verb pattern argument in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You used a pattern of the form C<(*VERB:ARG)> but did not terminate\nthe pattern with a C<)>.  Fix the pattern and retry.\n\n=item Unterminated verb pattern in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You used a pattern of the form C<(*VERB)> but did not terminate\nthe pattern with a C<)>.  Fix the pattern and retry.\n\n=item untie attempted while %d inner references still exist\n\n(W untie) A copy of the object returned from C<tie> (or C<tied>) was\nstill valid when C<untie> was called.\n\n=item Usage: POSIX::%s(%s)\n\n(F) You called a POSIX function with incorrect arguments.\nSee L<POSIX/FUNCTIONS> for more information.\n\n=item Usage: Win32::%s(%s)\n\n(F) You called a Win32 function with incorrect arguments.\nSee L<Win32> for more information.\n\n=item $[ used in %s (did you mean $] ?)\n\n(W syntax) You used C<$[> in a comparison, such as:\n\n    if ($[ > 5.006) {\n\t...\n    }\n\nYou probably meant to use C<$]> instead.  C<$[> is the base for indexing\narrays.  C<$]> is the Perl version number in decimal.\n\n=item Use \"%s\" instead of \"%s\"\n\n(F) The second listed construct is no longer legal.  Use the first one\ninstead.\n\n=item Useless assignment to a temporary\n\n(W misc) You assigned to an lvalue subroutine, but what\nthe subroutine returned was a temporary scalar about to\nbe discarded, so the assignment had no effect.\n\n=item Useless (?-%s) - don't use /%s modifier in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) You have used an internal modifier such as (?-o) that has no\nmeaning unless removed from the entire regexp:\n\n    if ($string =~ /(?-o)$pattern/o) { ... }\n\nmust be written as\n\n    if ($string =~ /$pattern/) { ... }\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Useless localization of %s\n\n(W syntax) The localization of lvalues such as C<local($x=10)> is legal,\nbut in fact the local() currently has no effect.  This may change at\nsome point in the future, but in the meantime such code is discouraged.\n\n=item Useless (?%s) - use /%s modifier in regex; marked by S<<-- HERE> in\nm/%s/\n\n(W regexp) You have used an internal modifier such as (?o) that has no\nmeaning unless applied to the entire regexp:\n\n    if ($string =~ /(?o)$pattern/) { ... }\n\nmust be written as\n\n    if ($string =~ /$pattern/o) { ... }\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Useless use of attribute \"const\"\n\n(W misc) The C<const> attribute has no effect except\non anonymous closure prototypes.  You applied it to\na subroutine via L<attributes.pm|attributes>.  This is only useful\ninside an attribute handler for an anonymous subroutine.\n\n=item Useless use of /d modifier in transliteration operator\n\n(W misc) You have used the /d modifier where the searchlist has the\nsame length as the replacelist.  See L<perlop> for more information\nabout the /d modifier.\n\n=item Useless use of \\E\n\n(W misc) You have a \\E in a double-quotish string without a C<\\U>,\nC<\\L> or C<\\Q> preceding it.\n\n=item Useless use of greediness modifier '%c' in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) You specified something like these:\n\n qr/a{3}?/\n qr/b{1,1}+/\n\nThe C<\"?\"> and C<\"+\"> don't have any effect, as they modify whether to\nmatch more or fewer when there is a choice, and by specifying to match\nexactly a given numer, there is no room left for a choice.\n\n=item Useless use of %s in void context\n\n(W void) You did something without a side effect in a context that does\nnothing with the return value, such as a statement that doesn't return a\nvalue from a block, or the left side of a scalar comma operator.  Very\noften this points not to stupidity on your part, but a failure of Perl\nto parse your program the way you thought it would.  For example, you'd\nget this if you mixed up your C precedence with Python precedence and\nsaid\n\n    $one, $two = 1, 2;\n\nwhen you meant to say\n\n    ($one, $two) = (1, 2);\n\nAnother common error is to use ordinary parentheses to construct a list\nreference when you should be using square or curly brackets, for\nexample, if you say\n\n    $array = (1,2);\n\nwhen you should have said\n\n    $array = [1,2];\n\nThe square brackets explicitly turn a list value into a scalar value,\nwhile parentheses do not.  So when a parenthesized list is evaluated in\na scalar context, the comma is treated like C's comma operator, which\nthrows away the left argument, which is not what you want.  See\nL<perlref> for more on this.\n\nThis warning will not be issued for numerical constants equal to 0 or 1\nsince they are often used in statements like\n\n    1 while sub_with_side_effects();\n\nString constants that would normally evaluate to 0 or 1 are warned\nabout.\n\n=item Useless use of (?-p) in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) The C<p> modifier cannot be turned off once set.  Trying to do\nso is futile.\n\n=item Useless use of \"re\" pragma\n\n(W) You did C<use re;> without any arguments.  That isn't very useful.\n\n=item Useless use of sort in scalar context\n\n(W void) You used sort in scalar context, as in :\n\n    my $x = sort @y;\n\nThis is not very useful, and perl currently optimizes this away.\n\n=item Useless use of %s with no values\n\n(W syntax) You used the push() or unshift() function with no arguments\napart from the array, like C<push(@x)> or C<unshift(@foo)>.  That won't\nusually have any effect on the array, so is completely useless.  It's\npossible in principle that push(@tied_array) could have some effect\nif the array is tied to a class which implements a PUSH method.  If so,\nyou can write it as C<push(@tied_array,())> to avoid this warning.\n\n=item \"use\" not allowed in expression\n\n(F) The \"use\" keyword is recognized and executed at compile time, and\nreturns no useful value.  See L<perlmod>.\n\n=item Use of assignment to $[ is deprecated, and will be fatal in 5.30\n\n(D deprecated) The C<$[> variable (index of the first element in an array)\nis deprecated since Perl 5.12, and setting it to a non-zero value will be\nfatal as of Perl 5.30.\nSee L<perlvar/\"$[\">.\n\n=item Use of bare << to mean <<\"\" is forbidden\n\n(F) You are now required to use the explicitly quoted form if you wish\nto use an empty line as the terminator of the here-document.\n\nUse of a bare terminator was deprecated in Perl 5.000, and is a fatal\nerror as of Perl 5.28.\n\n=item Use of /c modifier is meaningless in s///\n\n(W regexp) You used the /c modifier in a substitution.  The /c\nmodifier is not presently meaningful in substitutions.\n\n=item Use of /c modifier is meaningless without /g\n\n(W regexp) You used the /c modifier with a regex operand, but didn't\nuse the /g modifier.  Currently, /c is meaningful only when /g is\nused.  (This may change in the future.)\n\n=item Use of code point 0x%s is not allowed; the permissible max is 0x%s.\n\n(F) You used a code point that is not allowed, because it is too large.\nUnicode only allows code points up to 0x10FFFF, but Perl allows much\nlarger ones. Earlier versions of Perl allowed code points above IV_MAX\n(0x7FFFFFF on 32-bit platforms, 0x7FFFFFFFFFFFFFFF on 64-bit platforms),\nhowever, this could possibly break the perl interpreter in some constructs,\nincluding causing it to hang in a few cases.\n\nIf your code is to run on various platforms, keep in mind that the upper\nlimit depends on the platform.  It is much larger on 64-bit word sizes\nthan 32-bit ones.\n\nThe use of out of range code points was deprecated in Perl 5.24, and\nbecame a fatal error in Perl 5.28.\n\n=item Use of each() on hash after insertion without resetting hash iterator results in undefined behavior\n\n(S internal) The behavior of C<each()> after insertion is undefined;\nit may skip items, or visit items more than once.  Consider using\nC<keys()> instead of C<each()>.\n\n=item Use of := for an empty attribute list is not allowed\n\n(F) The construction C<my $x := 42> used to parse as equivalent to\nC<my $x : = 42> (applying an empty attribute list to C<$x>).\nThis construct was deprecated in 5.12.0, and has now been made a syntax\nerror, so C<:=> can be reclaimed as a new operator in the future.\n\nIf you need an empty attribute list, for example in a code generator, add\na space before the C<=>.\n\n=item Use of %s for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale\n\n(W locale)  You are matching a regular expression using locale rules,\nand the specified construct was encountered.  This construct is only\nvalid for UTF-8 locales, which the current locale isn't.  This doesn't\nmake sense.  Perl will continue, assuming a Unicode (UTF-8) locale, but\nthe results are likely to be wrong.\n\n=item Use of freed value in iteration\n\n(F) Perhaps you modified the iterated array within the loop?\nThis error is typically caused by code like the following:\n\n    @a = (3,4);\n    @a = () for (1,2,@a);\n\nYou are not supposed to modify arrays while they are being iterated over.\nFor speed and efficiency reasons, Perl internally does not do full\nreference-counting of iterated items, hence deleting such an item in the\nmiddle of an iteration causes Perl to see a freed value.\n\n=item Use of /g modifier is meaningless in split\n\n(W regexp) You used the /g modifier on the pattern for a C<split>\noperator.  Since C<split> always tries to match the pattern\nrepeatedly, the C</g> has no effect.\n\n=item Use of \"goto\" to jump into a construct is deprecated\n\n(D deprecated) Using C<goto> to jump from an outer scope into an inner\nscope is deprecated and should be avoided.\n\nThis was deprecated in Perl 5.12.\n\n=item Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed\n\n(F) As an accidental feature, C<AUTOLOAD> subroutines were looked up as\nmethods (using the C<@ISA> hierarchy), even when the subroutines to be\nautoloaded were called as plain functions (e.g. C<Foo::bar()>), not as\nmethods (e.g. C<< Foo->bar() >> or C<< $obj->bar() >>).\n\nThis was deprecated in Perl 5.004, and was made fatal in Perl 5.28.\n\n=item Use of %s in printf format not supported\n\n(F) You attempted to use a feature of printf that is accessible from\nonly C.  This usually means there's a better way to do it in Perl.\n\n=item Use of -l on filehandle%s\n\n(W io) A filehandle represents an opened file, and when you opened the file\nit already went past any symlink you are presumably trying to look for.\nThe operation returned C<undef>.  Use a filename instead.\n\n=item Use of reference \"%s\" as array index\n\n(W misc) You tried to use a reference as an array index; this probably\nisn't what you mean, because references in numerical context tend\nto be huge numbers, and so usually indicates programmer error.\n\nIf you really do mean it, explicitly numify your reference, like so:\nC<$array[0+$ref]>.  This warning is not given for overloaded objects,\nhowever, because you can overload the numification and stringification\noperators and then you presumably know what you are doing.\n\n=item Use of strings with code points over 0xFF as arguments to %s\noperator is not allowed\n\n(F) You tried to use one of the string bitwise operators (C<&> or C<|> or C<^> or\nC<~>) on a string containing a code point over 0xFF.  The string bitwise\noperators treat their operands as strings of bytes, and values beyond\n0xFF are nonsensical in this context.\n\nThis became fatal in Perl 5.28.\n\n=item Use of strings with code points over 0xFF as arguments to C<vec>\nis deprecated. This will be a fatal error in Perl 5.32\n\n(D deprecated) You tried to use L<C<vec>|perlfunc/vec EXPR,OFFSET,BITS>\non a string containing a code point over 0xFF, which is nonsensical here.\n\nSuch usage will be a fatal error in Perl 5.32.\n\n=item Use of tainted arguments in %s is deprecated\n\n(W taint, deprecated) You have supplied C<system()> or C<exec()> with multiple\narguments and at least one of them is tainted.  This used to be allowed\nbut will become a fatal error in a future version of perl.  Untaint your\narguments.  See L<perlsec>.\n\n=item Use of unassigned code point or non-standalone grapheme for a\ndelimiter will be a fatal error starting in Perl 5.30\n\n(D deprecated)\nA grapheme is what appears to a native-speaker of a language to be a\ncharacter.  In Unicode (and hence Perl) a grapheme may actually be\nseveral adjacent characters that together form a complete grapheme.  For\nexample, there can be a base character, like \"R\" and an accent, like a\ncircumflex \"^\", that appear when displayed to be a single character with\nthe circumflex hovering over the \"R\".  Perl currently allows things like\nthat circumflex to be delimiters of strings, patterns, I<etc>.  When\ndisplayed, the circumflex would look like it belongs to the character\njust to the left of it.  In order to move the language to be able to\naccept graphemes as delimiters, we have to deprecate the use of\ndelimiters which aren't graphemes by themselves.  Also, a delimiter must\nalready be assigned (or known to be never going to be assigned) to try\nto future-proof code, for otherwise code that works today would fail to\ncompile if the currently unassigned delimiter ends up being something\nthat isn't a stand-alone grapheme.  Because Unicode is never going to\nassign\nL<non-character code points|perlunicode/Noncharacter code points>, nor\nL<code points that are above the legal Unicode maximum|\nperlunicode/Beyond Unicode code points>, those can be delimiters, and\ntheir use won't raise this warning.\n\n=item Use of uninitialized value%s\n\n(W uninitialized) An undefined value was used as if it were already\ndefined.  It was interpreted as a \"\" or a 0, but maybe it was a mistake.\nTo suppress this warning assign a defined value to your variables.\n\nTo help you figure out what was undefined, perl will try to tell you\nthe name of the variable (if any) that was undefined.  In some cases\nit cannot do this, so it also tells you what operation you used the\nundefined value in.  Note, however, that perl optimizes your program\nand the operation displayed in the warning may not necessarily appear\nliterally in your program.  For example, C<\"that $foo\"> is usually\noptimized into C<\"that \" . $foo>, and the warning will refer to the\nC<concatenation (.)> operator, even though there is no C<.> in\nyour program.\n\n=item \"use re 'strict'\" is experimental\n\n(S experimental::re_strict) The things that are different when a regular\nexpression pattern is compiled under C<'strict'> are subject to change\nin future Perl releases in incompatible ways.  This means that a pattern\nthat compiles today may not in a future Perl release.  This warning is\nto alert you to that risk.\n\n=item Use \\x{...} for more than two hex characters in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) In a regular expression, you said something like\n\n (?[ [ \\xBEEF ] ])\n\nPerl isn't sure if you meant this\n\n (?[ [ \\x{BEEF} ] ])\n\nor if you meant this\n\n (?[ [ \\x{BE} E F ] ])\n\nYou need to add either braces or blanks to disambiguate.\n\n=item Using just the first character returned by \\N{} in character class in \nregex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) Named Unicode character escapes C<(\\N{...})> may return\na multi-character sequence.  Even though a character class is\nsupposed to match just one character of input, perl will match\nthe whole thing correctly, except when the class is inverted\n(C<[^...]>), or the escape is the beginning or final end point of\na range.  For these, what should happen isn't clear at all.  In\nthese circumstances, Perl discards all but the first character\nof the returned sequence, which is not likely what you want.\n\n=item Using /u for '%s' instead of /%s in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) You used a Unicode boundary (C<\\b{...}> or C<\\B{...}>) in a\nportion of a regular expression where the character set modifiers C</a>\nor C</aa> are in effect.  These two modifiers indicate an ASCII\ninterpretation, and this doesn't make sense for a Unicode defintion.\nThe generated regular expression will compile so that the boundary uses\nall of Unicode.  No other portion of the regular expression is affected.\n\n=item Using !~ with %s doesn't make sense\n\n(F) Using the C<!~> operator with C<s///r>, C<tr///r> or C<y///r> is\ncurrently reserved for future use, as the exact behavior has not\nbeen decided.  (Simply returning the boolean opposite of the\nmodified string is usually not particularly useful.)\n\n=item UTF-16 surrogate U+%X\n\n(S surrogate) You had a UTF-16 surrogate in a context where they are\nnot considered acceptable.  These code points, between U+D800 and\nU+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl\ninternally allows all unsigned integer code points (up to the size limit\navailable on your platform), including surrogates.  But these can cause\nproblems when being input or output, which is likely where this message\ncame from.  If you really really know what you are doing you can turn\noff this warning by C<no warnings 'surrogate';>.\n\n=item Value of %s can be \"0\"; test with defined()\n\n(W misc) In a conditional expression, you used <HANDLE>, <*> (glob),\nC<each()>, or C<readdir()> as a boolean value.  Each of these constructs\ncan return a value of \"0\"; that would make the conditional expression\nfalse, which is probably not what you intended.  When using these\nconstructs in conditional expressions, test their values with the\nC<defined> operator.\n\n=item Value of CLI symbol \"%s\" too long\n\n(W misc) A warning peculiar to VMS.  Perl tried to read the value of an\n%ENV element from a CLI symbol table, and found a resultant string\nlonger than 1024 characters.  The return value has been truncated to\n1024 characters.\n\n=item Variable \"%s\" is not available\n\n(W closure) During compilation, an inner named subroutine or eval is\nattempting to capture an outer lexical that is not currently available.\nThis can happen for one of two reasons.  First, the outer lexical may be\ndeclared in an outer anonymous subroutine that has not yet been created.\n(Remember that named subs are created at compile time, while anonymous\nsubs are created at run-time.)  For example,\n\n    sub { my $a; sub f { $a } }\n\nAt the time that f is created, it can't capture the current value of $a,\nsince the anonymous subroutine hasn't been created yet.  Conversely,\nthe following won't give a warning since the anonymous subroutine has by\nnow been created and is live:\n\n    sub { my $a; eval 'sub f { $a }' }->();\n\nThe second situation is caused by an eval accessing a variable that has\ngone out of scope, for example,\n\n    sub f {\n\tmy $a;\n\tsub { eval '$a' }\n    }\n    f()->();\n\nHere, when the '$a' in the eval is being compiled, f() is not currently\nbeing executed, so its $a is not available for capture.\n\n=item Variable \"%s\" is not imported%s\n\n(S misc) With \"use strict\" in effect, you referred to a global variable\nthat you apparently thought was imported from another module, because\nsomething else of the same name (usually a subroutine) is exported by\nthat module.  It usually means you put the wrong funny character on the\nfront of your variable.\n\n=item Variable length lookbehind not implemented in regex m/%s/\n\n(F) Lookbehind is allowed only for subexpressions whose length is fixed and\nknown at compile time.  For positive lookbehind, you can use the C<\\K>\nregex construct as a way to get the equivalent functionality.  See\nL<(?<=pattern) and \\K in perlre|perlre/\\K>.\n\nStarting in Perl 5.18, there are non-obvious Unicode rules under C</i>\nthat can match variably, but which you might not think could.  For\nexample, the substring C<\"ss\"> can match the single character LATIN\nSMALL LETTER SHARP S.  Here's a complete list of the current ones\naffecting ASCII characters:\n\n   ASCII\n  sequence      Matches single letter under /i\n    FF          U+FB00 LATIN SMALL LIGATURE FF\n    FFI         U+FB03 LATIN SMALL LIGATURE FFI\n    FFL         U+FB04 LATIN SMALL LIGATURE FFL\n    FI          U+FB01 LATIN SMALL LIGATURE FI\n    FL          U+FB02 LATIN SMALL LIGATURE FL\n    SS          U+00DF LATIN SMALL LETTER SHARP S\n                U+1E9E LATIN CAPITAL LETTER SHARP S\n    ST          U+FB06 LATIN SMALL LIGATURE ST\n                U+FB05 LATIN SMALL LIGATURE LONG S T\n\nThis list is subject to change, but is quite unlikely to.\nEach ASCII sequence can be any combination of upper- and lowercase.\n\nYou can avoid this by using a bracketed character class in the\nlookbehind assertion, like\n\n (?<![sS]t)\n (?<![fF]f[iI])\n\nThis fools Perl into not matching the ligatures.\n\nAnother option for Perls starting with 5.16, if you only care about\nASCII matches, is to add the C</aa> modifier to the regex.  This will\nexclude all these non-obvious matches, thus getting rid of this message.\nYou can also say\n\n use if $] ge 5.016, re => '/aa';\n\nto apply C</aa> to all regular expressions compiled within its scope.\nSee L<re>.\n\n=item \"%s\" variable %s masks earlier declaration in same %s\n\n(W shadow) A \"my\", \"our\" or \"state\" variable has been redeclared in the\ncurrent scope or statement, effectively eliminating all access to the\nprevious instance.  This is almost always a typographical error.  Note\nthat the earlier variable will still exist until the end of the scope\nor until all closure references to it are destroyed.\n\n=item Variable syntax\n\n(A) You've accidentally run your script through B<csh> instead\nof Perl.  Check the #! line, or manually feed your script into\nPerl yourself.\n\n=item Variable \"%s\" will not stay shared\n\n(W closure) An inner (nested) I<named> subroutine is referencing a\nlexical variable defined in an outer named subroutine.\n\nWhen the inner subroutine is called, it will see the value of\nthe outer subroutine's variable as it was before and during the *first*\ncall to the outer subroutine; in this case, after the first call to the\nouter subroutine is complete, the inner and outer subroutines will no\nlonger share a common value for the variable.  In other words, the\nvariable will no longer be shared.\n\nThis problem can usually be solved by making the inner subroutine\nanonymous, using the C<sub {}> syntax.  When inner anonymous subs that\nreference variables in outer subroutines are created, they\nare automatically rebound to the current values of such variables.\n\n=item vector argument not supported with alpha versions\n\n(S printf) The %vd (s)printf format does not support version objects\nwith alpha parts.\n\n=item Verb pattern '%s' has a mandatory argument in regex; marked by\nS<<-- HERE> in m/%s/ \n\n(F) You used a verb pattern that requires an argument.  Supply an\nargument or check that you are using the right verb.\n\n=item Verb pattern '%s' may not have an argument in regex; marked by\nS<<-- HERE> in m/%s/ \n\n(F) You used a verb pattern that is not allowed an argument.  Remove the \nargument or check that you are using the right verb.\n\n=item Version control conflict marker\n\n(F) The parser found a line starting with C<E<lt><<<<<<>,\nC<E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>>, or C<=======>.  These may be left by a\nversion control system to mark conflicts after a failed merge operation.\n\n=item Version number must be a constant number\n\n(P) The attempt to translate a C<use Module n.n LIST> statement into\nits equivalent C<BEGIN> block found an internal inconsistency with\nthe version number.\n\n=item Version string '%s' contains invalid data; ignoring: '%s'\n\n(W misc) The version string contains invalid characters at the end, which\nare being ignored.\n\n=item Warning: something's wrong\n\n(W) You passed warn() an empty string (the equivalent of C<warn \"\">) or\nyou called it with no args and C<$@> was empty.\n\n=item Warning: unable to close filehandle %s properly\n\n(S) The implicit close() done by an open() got an error indication on\nthe close().  This usually indicates your file system ran out of disk\nspace.\n\n=item Warning: unable to close filehandle properly: %s\n\n=item Warning: unable to close filehandle %s properly: %s\n\n(S io) There were errors during the implicit close() done on a filehandle\nwhen its reference count reached zero while it was still open, e.g.:\n\n    {\n        open my $fh, '>', $file  or die \"open: '$file': $!\\n\";\n        print $fh $data or die \"print: $!\";\n    } # implicit close here\n\nBecause various errors may only be detected by close() (e.g. buffering could\nallow the C<print> in this example to return true even when the disk is full),\nit is dangerous to ignore its result.  So when it happens implicitly, perl\nwill signal errors by warning.\n\nB<Prior to version 5.22.0, perl ignored such errors>, so the common idiom shown\nabove was liable to cause B<silent data loss>.\n\n=item Warning: Use of \"%s\" without parentheses is ambiguous\n\n(S ambiguous) You wrote a unary operator followed by something that\nlooks like a binary operator that could also have been interpreted as a\nterm or unary operator.  For instance, if you know that the rand\nfunction has a default argument of 1.0, and you write\n\n    rand + 5;\n\nyou may THINK you wrote the same thing as\n\n    rand() + 5;\n\nbut in actual fact, you got\n\n    rand(+5);\n\nSo put in parentheses to say what you really mean.\n\n=item when is experimental\n\n(S experimental::smartmatch) C<when> depends on smartmatch, which is\nexperimental.  Additionally, it has several special cases that may\nnot be immediately obvious, and their behavior may change or\neven be removed in any future release of perl.  See the explanation\nunder L<perlsyn/Experimental Details on given and when>.\n\n=item Wide character in %s\n\n(S utf8) Perl met a wide character (>255) when it wasn't expecting\none.  This warning is by default on for I/O (like print).  The easiest\nway to quiet this warning is simply to add the C<:utf8> layer to the\noutput, e.g. C<binmode STDOUT, ':utf8'>.  Another way to turn off the\nwarning is to add C<no warnings 'utf8';> but that is often closer to\ncheating.  In general, you are supposed to explicitly mark the\nfilehandle with an encoding, see L<open> and L<perlfunc/binmode>.\n\n=item Wide character (U+%X) in %s\n\n(W locale) While in a single-byte locale (I<i.e.>, a non-UTF-8\none), a multi-byte character was encountered.   Perl considers this\ncharacter to be the specified Unicode code point.  Combining non-UTF-8\nlocales and Unicode is dangerous.  Almost certainly some characters\nwill have two different representations.  For example, in the ISO 8859-7\n(Greek) locale, the code point 0xC3 represents a Capital Gamma.  But so\nalso does 0x393.  This will make string comparisons unreliable.\n\nYou likely need to figure out how this multi-byte character got mixed up\nwith your single-byte locale (or perhaps you thought you had a UTF-8\nlocale, but Perl disagrees).\n\n=item Within []-length '%c' not allowed\n\n(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]>\nonly if C<TEMPLATE> always matches the same amount of packed bytes that\ncan be determined from the template alone.  This is not possible if\nit contains any of the codes @, /, U, u, w or a *-length.  Redesign\nthe template.\n\n=item %s() with negative argument\n\n(S misc) Certain operations make no sense with negative arguments.\nWarning is given and the operation is not done.\n\n=item write() on closed filehandle %s\n\n(W closed) The filehandle you're writing to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item %s \"\\x%X\" does not map to Unicode\n\n(S utf8) When reading in different encodings, Perl tries to\nmap everything into Unicode characters.  The bytes you read\nin are not legal in this encoding.  For example\n\n    utf8 \"\\xE4\" does not map to Unicode\n\nif you try to read in the a-diaereses Latin-1 as UTF-8.\n\n=item 'X' outside of string\n\n(F) You had a (un)pack template that specified a relative position before\nthe beginning of the string being (un)packed.  See L<perlfunc/pack>.\n\n=item 'x' outside of string in unpack\n\n(F) You had a pack template that specified a relative position after\nthe end of the string being unpacked.  See L<perlfunc/pack>.\n\n=item YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\n(F) And you probably never will, because you probably don't have the\nsources to your kernel, and your vendor probably doesn't give a rip\nabout what you want.  Your best bet is to put a setuid C wrapper around\nyour script.\n\n=item You need to quote \"%s\"\n\n(W syntax) You assigned a bareword as a signal handler name.\nUnfortunately, you already have a subroutine of that name declared,\nwhich means that Perl 5 will try to call the subroutine when the\nassignment is executed, which is probably not what you want.  (If it IS\nwhat you want, put an & in front.)\n\n=item Your random numbers are not that random\n\n(F) When trying to initialize the random seed for hashes, Perl could\nnot get any randomness out of your system.  This usually indicates\nSomething Very Wrong.\n\n=item Zero length \\N{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Named Unicode character escapes (C<\\N{...}>) may return a zero-length\nsequence.  Such an escape was used in an extended character class, i.e.\nC<(?[...])>, or under C<use re 'strict'>, which is not permitted.  Check\nthat the correct escape has been used, and the correct charnames handler\nis in scope.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.\n\n=back\n\n=head1 SEE ALSO\n\nL<warnings>, L<diagnostics>.\n\n=cut\n", "=head1 NAME\nX<character class>\n\nperlrecharclass - Perl Regular Expression Character Classes\n\n=head1 DESCRIPTION\n\nThe top level documentation about Perl regular expressions\nis found in L<perlre>.\n\nThis manual page discusses the syntax and use of character\nclasses in Perl regular expressions.\n\nA character class is a way of denoting a set of characters\nin such a way that one character of the set is matched.\nIt's important to remember that: matching a character class\nconsumes exactly one character in the source string. (The source\nstring is the string the regular expression is matched against.)\n\nThere are three types of character classes in Perl regular\nexpressions: the dot, backslash sequences, and the form enclosed in square\nbrackets.  Keep in mind, though, that often the term \"character class\" is used\nto mean just the bracketed form.  Certainly, most Perl documentation does that.\n\n=head2 The dot\n\nThe dot (or period), C<.> is probably the most used, and certainly\nthe most well-known character class. By default, a dot matches any\ncharacter, except for the newline. That default can be changed to\nadd matching the newline by using the I<single line> modifier:\nfor the entire regular expression with the C</s> modifier, or\nlocally with C<(?s)>  (and even globally within the scope of\nL<C<use re '/s'>|re/'E<sol>flags' mode>).  (The C<L</\\N>> backslash\nsequence, described\nbelow, matches any character except newline without regard to the\nI<single line> modifier.)\n\nHere are some examples:\n\n \"a\"  =~  /./       # Match\n \".\"  =~  /./       # Match\n \"\"   =~  /./       # No match (dot has to match a character)\n \"\\n\" =~  /./       # No match (dot does not match a newline)\n \"\\n\" =~  /./s      # Match (global 'single line' modifier)\n \"\\n\" =~  /(?s:.)/  # Match (local 'single line' modifier)\n \"ab\" =~  /^.$/     # No match (dot matches one character)\n\n=head2 Backslash sequences\nX<\\w> X<\\W> X<\\s> X<\\S> X<\\d> X<\\D> X<\\p> X<\\P>\nX<\\N> X<\\v> X<\\V> X<\\h> X<\\H>\nX<word> X<whitespace>\n\nA backslash sequence is a sequence of characters, the first one of which is a\nbackslash.  Perl ascribes special meaning to many such sequences, and some of\nthese are character classes.  That is, they match a single character each,\nprovided that the character belongs to the specific set of characters defined\nby the sequence.\n\nHere's a list of the backslash sequences that are character classes.  They\nare discussed in more detail below.  (For the backslash sequences that aren't\ncharacter classes, see L<perlrebackslash>.)\n\n \\d             Match a decimal digit character.\n \\D             Match a non-decimal-digit character.\n \\w             Match a \"word\" character.\n \\W             Match a non-\"word\" character.\n \\s             Match a whitespace character.\n \\S             Match a non-whitespace character.\n \\h             Match a horizontal whitespace character.\n \\H             Match a character that isn't horizontal whitespace.\n \\v             Match a vertical whitespace character.\n \\V             Match a character that isn't vertical whitespace.\n \\N             Match a character that isn't a newline.\n \\pP, \\p{Prop}  Match a character that has the given Unicode property.\n \\PP, \\P{Prop}  Match a character that doesn't have the Unicode property\n\n=head3 \\N\n\nC<\\N>, available starting in v5.12, like the dot, matches any\ncharacter that is not a newline. The difference is that C<\\N> is not influenced\nby the I<single line> regular expression modifier (see L</The dot> above).  Note\nthat the form C<\\N{...}> may mean something completely different.  When the\nC<{...}> is a L<quantifier|perlre/Quantifiers>, it means to match a non-newline\ncharacter that many times.  For example, C<\\N{3}> means to match 3\nnon-newlines; C<\\N{5,}> means to match 5 or more non-newlines.  But if C<{...}>\nis not a legal quantifier, it is presumed to be a named character.  See\nL<charnames> for those.  For example, none of C<\\N{COLON}>, C<\\N{4F}>, and\nC<\\N{F4}> contain legal quantifiers, so Perl will try to find characters whose\nnames are respectively C<COLON>, C<4F>, and C<F4>.\n\n=head3 Digits\n\nC<\\d> matches a single character considered to be a decimal I<digit>.\nIf the C</a> regular expression modifier is in effect, it matches [0-9].\nOtherwise, it\nmatches anything that is matched by C<\\p{Digit}>, which includes [0-9].\n(An unlikely possible exception is that under locale matching rules, the\ncurrent locale might not have C<[0-9]> matched by C<\\d>, and/or might match\nother characters whose code point is less than 256.  The only such locale\ndefinitions that are legal would be to match C<[0-9]> plus another set of\n10 consecutive digit characters;  anything else would be in violation of\nthe C language standard, but Perl doesn't currently assume anything in\nregard to this.)\n\nWhat this means is that unless the C</a> modifier is in effect C<\\d> not\nonly matches the digits '0' - '9', but also Arabic, Devanagari, and\ndigits from other languages.  This may cause some confusion, and some\nsecurity issues.\n\nSome digits that C<\\d> matches look like some of the [0-9] ones, but\nhave different values.  For example, BENGALI DIGIT FOUR (U+09EA) looks\nvery much like an ASCII DIGIT EIGHT (U+0038).  An application that\nis expecting only the ASCII digits might be misled, or if the match is\nC<\\d+>, the matched string might contain a mixture of digits from\ndifferent writing systems that look like they signify a number different\nthan they actually do.  L<Unicode::UCD/num()> can\nbe used to safely\ncalculate the value, returning C<undef> if the input string contains\nsuch a mixture.\n\nWhat C<\\p{Digit}> means (and hence C<\\d> except under the C</a>\nmodifier) is C<\\p{General_Category=Decimal_Number}>, or synonymously,\nC<\\p{General_Category=Digit}>.  Starting with Unicode version 4.1, this\nis the same set of characters matched by C<\\p{Numeric_Type=Decimal}>.\nBut Unicode also has a different property with a similar name,\nC<\\p{Numeric_Type=Digit}>, which matches a completely different set of\ncharacters.  These characters are things such as C<CIRCLED DIGIT ONE>\nor subscripts, or are from writing systems that lack all ten digits.\n\nThe design intent is for C<\\d> to exactly match the set of characters\nthat can safely be used with \"normal\" big-endian positional decimal\nsyntax, where, for example 123 means one 'hundred', plus two 'tens',\nplus three 'ones'.  This positional notation does not necessarily apply\nto characters that match the other type of \"digit\",\nC<\\p{Numeric_Type=Digit}>, and so C<\\d> doesn't match them.\n\nThe Tamil digits (U+0BE6 - U+0BEF) can also legally be\nused in old-style Tamil numbers in which they would appear no more than\none in a row, separated by characters that mean \"times 10\", \"times 100\",\netc.  (See L<http://www.unicode.org/notes/tn21>.)\n\nAny character not matched by C<\\d> is matched by C<\\D>.\n\n=head3 Word characters\n\nA C<\\w> matches a single alphanumeric character (an alphabetic character, or a\ndecimal digit); or a connecting punctuation character, such as an\nunderscore (\"_\"); or a \"mark\" character (like some sort of accent) that\nattaches to one of those.  It does not match a whole word.  To match a\nwhole word, use C<\\w+>.  This isn't the same thing as matching an\nEnglish word, but in the ASCII range it is the same as a string of\nPerl-identifier characters.\n\n=over\n\n=item If the C</a> modifier is in effect ...\n\nC<\\w> matches the 63 characters [a-zA-Z0-9_].\n\n=item otherwise ...\n\n=over\n\n=item For code points above 255 ...\n\nC<\\w> matches the same as C<\\p{Word}> matches in this range.  That is,\nit matches Thai letters, Greek letters, etc.  This includes connector\npunctuation (like the underscore) which connect two words together, or\ndiacritics, such as a C<COMBINING TILDE> and the modifier letters, which\nare generally used to add auxiliary markings to letters.\n\n=item For code points below 256 ...\n\n=over\n\n=item if locale rules are in effect ...\n\nC<\\w> matches the platform's native underscore character plus whatever\nthe locale considers to be alphanumeric.\n\n=item if, instead, Unicode rules are in effect ...\n\nC<\\w> matches exactly what C<\\p{Word}> matches.\n\n=item otherwise ...\n\nC<\\w> matches [a-zA-Z0-9_].\n\n=back\n\n=back\n\n=back\n\nWhich rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.\n\nThere are a number of security issues with the full Unicode list of word\ncharacters.  See L<http://unicode.org/reports/tr36>.\n\nAlso, for a somewhat finer-grained set of characters that are in programming\nlanguage identifiers beyond the ASCII range, you may wish to instead use the\nmore customized L</Unicode Properties>, C<\\p{ID_Start}>,\nC<\\p{ID_Continue}>, C<\\p{XID_Start}>, and C<\\p{XID_Continue}>.  See\nL<http://unicode.org/reports/tr31>.\n\nAny character not matched by C<\\w> is matched by C<\\W>.\n\n=head3 Whitespace\n\nC<\\s> matches any single character considered whitespace.\n\n=over\n\n=item If the C</a> modifier is in effect ...\n\nIn all Perl versions, C<\\s> matches the 5 characters [\\t\\n\\f\\r ]; that\nis, the horizontal tab,\nthe newline, the form feed, the carriage return, and the space.\nStarting in Perl v5.18, it also matches the vertical tab, C<\\cK>.\nSee note C<[1]> below for a discussion of this.\n\n=item otherwise ...\n\n=over\n\n=item For code points above 255 ...\n\nC<\\s> matches exactly the code points above 255 shown with an \"s\" column\nin the table below.\n\n=item For code points below 256 ...\n\n=over\n\n=item if locale rules are in effect ...\n\nC<\\s> matches whatever the locale considers to be whitespace.\n\n=item if, instead, Unicode rules are in effect ...\n\nC<\\s> matches exactly the characters shown with an \"s\" column in the\ntable below.\n\n=item otherwise ...\n\nC<\\s> matches [\\t\\n\\f\\r ] and, starting in Perl\nv5.18, the vertical tab, C<\\cK>.\n(See note C<[1]> below for a discussion of this.)\nNote that this list doesn't include the non-breaking space.\n\n=back\n\n=back\n\n=back\n\nWhich rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.\n\nAny character not matched by C<\\s> is matched by C<\\S>.\n\nC<\\h> matches any character considered horizontal whitespace;\nthis includes the platform's space and tab characters and several others\nlisted in the table below.  C<\\H> matches any character\nnot considered horizontal whitespace.  They use the platform's native\ncharacter set, and do not consider any locale that may otherwise be in\nuse.\n\nC<\\v> matches any character considered vertical whitespace;\nthis includes the platform's carriage return and line feed characters (newline)\nplus several other characters, all listed in the table below.\nC<\\V> matches any character not considered vertical whitespace.\nThey use the platform's native character set, and do not consider any\nlocale that may otherwise be in use.\n\nC<\\R> matches anything that can be considered a newline under Unicode\nrules. It can match a multi-character sequence. It cannot be used inside\na bracketed character class; use C<\\v> instead (vertical whitespace).\nIt uses the platform's\nnative character set, and does not consider any locale that may\notherwise be in use.\nDetails are discussed in L<perlrebackslash>.\n\nNote that unlike C<\\s> (and C<\\d> and C<\\w>), C<\\h> and C<\\v> always match\nthe same characters, without regard to other factors, such as the active\nlocale or whether the source string is in UTF-8 format.\n\nOne might think that C<\\s> is equivalent to C<[\\h\\v]>. This is indeed true\nstarting in Perl v5.18, but prior to that, the sole difference was that the\nvertical tab (C<\"\\cK\">) was not matched by C<\\s>.\n\nThe following table is a complete listing of characters matched by\nC<\\s>, C<\\h> and C<\\v> as of Unicode 6.3.\n\nThe first column gives the Unicode code point of the character (in hex format),\nthe second column gives the (Unicode) name. The third column indicates\nby which class(es) the character is matched (assuming no locale is in\neffect that changes the C<\\s> matching).\n\n 0x0009        CHARACTER TABULATION   h s\n 0x000a              LINE FEED (LF)    vs\n 0x000b             LINE TABULATION    vs  [1]\n 0x000c              FORM FEED (FF)    vs\n 0x000d        CARRIAGE RETURN (CR)    vs\n 0x0020                       SPACE   h s\n 0x0085             NEXT LINE (NEL)    vs  [2]\n 0x00a0              NO-BREAK SPACE   h s  [2]\n 0x1680            OGHAM SPACE MARK   h s\n 0x2000                     EN QUAD   h s\n 0x2001                     EM QUAD   h s\n 0x2002                    EN SPACE   h s\n 0x2003                    EM SPACE   h s\n 0x2004          THREE-PER-EM SPACE   h s\n 0x2005           FOUR-PER-EM SPACE   h s\n 0x2006            SIX-PER-EM SPACE   h s\n 0x2007                FIGURE SPACE   h s\n 0x2008           PUNCTUATION SPACE   h s\n 0x2009                  THIN SPACE   h s\n 0x200a                  HAIR SPACE   h s\n 0x2028              LINE SEPARATOR    vs\n 0x2029         PARAGRAPH SEPARATOR    vs\n 0x202f       NARROW NO-BREAK SPACE   h s\n 0x205f   MEDIUM MATHEMATICAL SPACE   h s\n 0x3000           IDEOGRAPHIC SPACE   h s\n\n=over 4\n\n=item [1]\n\nPrior to Perl v5.18, C<\\s> did not match the vertical tab.\nC<[^\\S\\cK]> (obscurely) matches what C<\\s> traditionally did.\n\n=item [2]\n\nNEXT LINE and NO-BREAK SPACE may or may not match C<\\s> depending\non the rules in effect.  See\nL<the beginning of this section|/Whitespace>.\n\n=back\n\n=head3 Unicode Properties\n\nC<\\pP> and C<\\p{Prop}> are character classes to match characters that fit given\nUnicode properties.  One letter property names can be used in the C<\\pP> form,\nwith the property name following the C<\\p>, otherwise, braces are required.\nWhen using braces, there is a single form, which is just the property name\nenclosed in the braces, and a compound form which looks like C<\\p{name=value}>,\nwhich means to match if the property \"name\" for the character has that particular\n\"value\".\nFor instance, a match for a number can be written as C</\\pN/> or as\nC</\\p{Number}/>, or as C</\\p{Number=True}/>.\nLowercase letters are matched by the property I<Lowercase_Letter> which\nhas the short form I<Ll>. They need the braces, so are written as C</\\p{Ll}/> or\nC</\\p{Lowercase_Letter}/>, or C</\\p{General_Category=Lowercase_Letter}/>\n(the underscores are optional).\nC</\\pLl/> is valid, but means something different.\nIt matches a two character string: a letter (Unicode property C<\\pL>),\nfollowed by a lowercase C<l>.\n\nIf locale rules are not in effect, the use of\na Unicode property will force the regular expression into using Unicode\nrules, if it isn't already.\n\nNote that almost all properties are immune to case-insensitive matching.\nThat is, adding a C</i> regular expression modifier does not change what\nthey match.  There are two sets that are affected.  The first set is\nC<Uppercase_Letter>,\nC<Lowercase_Letter>,\nand C<Titlecase_Letter>,\nall of which match C<Cased_Letter> under C</i> matching.\nThe second set is\nC<Uppercase>,\nC<Lowercase>,\nand C<Titlecase>,\nall of which match C<Cased> under C</i> matching.\n(The difference between these sets is that some things, such as Roman\nnumerals, come in both upper and lower case, so they are C<Cased>, but\naren't considered to be letters, so they aren't C<Cased_Letter>s. They're\nactually C<Letter_Number>s.)\nThis set also includes its subsets C<PosixUpper> and C<PosixLower>, both\nof which under C</i> match C<PosixAlpha>.\n\nFor more details on Unicode properties, see L<perlunicode/Unicode\nCharacter Properties>; for a\ncomplete list of possible properties, see\nL<perluniprops/Properties accessible through \\p{} and \\P{}>,\nwhich notes all forms that have C</i> differences.\nIt is also possible to define your own properties. This is discussed in\nL<perlunicode/User-Defined Character Properties>.\n\nUnicode properties are defined (surprise!) only on Unicode code points.\nStarting in v5.20, when matching against C<\\p> and C<\\P>, Perl treats\nnon-Unicode code points (those above the legal Unicode maximum of\n0x10FFFF) as if they were typical unassigned Unicode code points.\n\nPrior to v5.20, Perl raised a warning and made all matches fail on\nnon-Unicode code points.  This could be somewhat surprising:\n\n chr(0x110000) =~ \\p{ASCII_Hex_Digit=True}     # Fails on Perls < v5.20.\n chr(0x110000) =~ \\p{ASCII_Hex_Digit=False}    # Also fails on Perls\n                                               # < v5.20\n\nEven though these two matches might be thought of as complements, until\nv5.20 they were so only on Unicode code points.\n\n=head4 Examples\n\n \"a\"  =~  /\\w/      # Match, \"a\" is a 'word' character.\n \"7\"  =~  /\\w/      # Match, \"7\" is a 'word' character as well.\n \"a\"  =~  /\\d/      # No match, \"a\" isn't a digit.\n \"7\"  =~  /\\d/      # Match, \"7\" is a digit.\n \" \"  =~  /\\s/      # Match, a space is whitespace.\n \"a\"  =~  /\\D/      # Match, \"a\" is a non-digit.\n \"7\"  =~  /\\D/      # No match, \"7\" is not a non-digit.\n \" \"  =~  /\\S/      # No match, a space is not non-whitespace.\n\n \" \"  =~  /\\h/      # Match, space is horizontal whitespace.\n \" \"  =~  /\\v/      # No match, space is not vertical whitespace.\n \"\\r\" =~  /\\v/      # Match, a return is vertical whitespace.\n\n \"a\"  =~  /\\pL/     # Match, \"a\" is a letter.\n \"a\"  =~  /\\p{Lu}/  # No match, /\\p{Lu}/ matches upper case letters.\n\n \"\\x{0e0b}\" =~ /\\p{Thai}/  # Match, \\x{0e0b} is the character\n                           # 'THAI CHARACTER SO SO', and that's in\n                           # Thai Unicode class.\n \"a\"  =~  /\\P{Lao}/ # Match, as \"a\" is not a Laotian character.\n\nIt is worth emphasizing that C<\\d>, C<\\w>, etc, match single characters, not\ncomplete numbers or words. To match a number (that consists of digits),\nuse C<\\d+>; to match a word, use C<\\w+>.  But be aware of the security\nconsiderations in doing so, as mentioned above.\n\n=head2 Bracketed Character Classes\n\nThe third form of character class you can use in Perl regular expressions\nis the bracketed character class.  In its simplest form, it lists the characters\nthat may be matched, surrounded by square brackets, like this: C<[aeiou]>.\nThis matches one of C<a>, C<e>, C<i>, C<o> or C<u>.  Like the other\ncharacter classes, exactly one character is matched.* To match\na longer string consisting of characters mentioned in the character\nclass, follow the character class with a L<quantifier|perlre/Quantifiers>.  For\ninstance, C<[aeiou]+> matches one or more lowercase English vowels.\n\nRepeating a character in a character class has no\neffect; it's considered to be in the set only once.\n\nExamples:\n\n \"e\"  =~  /[aeiou]/        # Match, as \"e\" is listed in the class.\n \"p\"  =~  /[aeiou]/        # No match, \"p\" is not listed in the class.\n \"ae\" =~  /^[aeiou]$/      # No match, a character class only matches\n                           # a single character.\n \"ae\" =~  /^[aeiou]+$/     # Match, due to the quantifier.\n\n -------\n\n* There are two exceptions to a bracketed character class matching a\nsingle character only.  Each requires special handling by Perl to make\nthings work:\n\n=over\n\n=item *\n\nWhen the class is to match caselessly under C</i> matching rules, and a\ncharacter that is explicitly mentioned inside the class matches a\nmultiple-character sequence caselessly under Unicode rules, the class\nwill also match that sequence.  For example, Unicode says that the\nletter C<LATIN SMALL LETTER SHARP S> should match the sequence C<ss>\nunder C</i> rules.  Thus,\n\n 'ss' =~ /\\A\\N{LATIN SMALL LETTER SHARP S}\\z/i             # Matches\n 'ss' =~ /\\A[aeioust\\N{LATIN SMALL LETTER SHARP S}]\\z/i    # Matches\n\nFor this to happen, the class must not be inverted (see L</Negation>)\nand the character must be explicitly specified, and not be part of a\nmulti-character range (not even as one of its endpoints).  (L</Character\nRanges> will be explained shortly.) Therefore,\n\n 'ss' =~ /\\A[\\0-\\x{ff}]\\z/ui       # Doesn't match\n 'ss' =~ /\\A[\\0-\\N{LATIN SMALL LETTER SHARP S}]\\z/ui   # No match\n 'ss' =~ /\\A[\\xDF-\\xDF]\\z/ui   # Matches on ASCII platforms, since\n                               # \\xDF is LATIN SMALL LETTER SHARP S,\n                               # and the range is just a single\n                               # element\n\nNote that it isn't a good idea to specify these types of ranges anyway.\n\n=item *\n\nSome names known to C<\\N{...}> refer to a sequence of multiple characters,\ninstead of the usual single character.  When one of these is included in\nthe class, the entire sequence is matched.  For example,\n\n  \"\\N{TAMIL LETTER KA}\\N{TAMIL VOWEL SIGN AU}\"\n                              =~ / ^ [\\N{TAMIL SYLLABLE KAU}]  $ /x;\n\nmatches, because C<\\N{TAMIL SYLLABLE KAU}> is a named sequence\nconsisting of the two characters matched against.  Like the other\ninstance where a bracketed class can match multiple characters, and for\nsimilar reasons, the class must not be inverted, and the named sequence\nmay not appear in a range, even one where it is both endpoints.  If\nthese happen, it is a fatal error if the character class is within the\nscope of L<C<use re 'strict>|re/'strict' mode>, or within an extended\nL<C<(?[...])>|/Extended Bracketed Character Classes> class; otherwise\nonly the first code point is used (with a C<regexp>-type warning\nraised).\n\n=back\n\n=head3 Special Characters Inside a Bracketed Character Class\n\nMost characters that are meta characters in regular expressions (that\nis, characters that carry a special meaning like C<.>, C<*>, or C<(>) lose\ntheir special meaning and can be used inside a character class without\nthe need to escape them. For instance, C<[()]> matches either an opening\nparenthesis, or a closing parenthesis, and the parens inside the character\nclass don't group or capture.  Be aware that, unless the pattern is\nevaluated in single-quotish context, variable interpolation will take\nplace before the bracketed class is parsed:\n\n $, = \"\\t| \";\n $a =~ m'[$,]';        # single-quotish: matches '$' or ','\n $a =~ q{[$,]}'        # same\n $a =~ m/[$,]/;        # double-quotish: matches \"\\t\", \"|\", or \" \"\n\nCharacters that may carry a special meaning inside a character class are:\nC<\\>, C<^>, C<->, C<[> and C<]>, and are discussed below. They can be\nescaped with a backslash, although this is sometimes not needed, in which\ncase the backslash may be omitted.\n\nThe sequence C<\\b> is special inside a bracketed character class. While\noutside the character class, C<\\b> is an assertion indicating a point\nthat does not have either two word characters or two non-word characters\non either side, inside a bracketed character class, C<\\b> matches a\nbackspace character.\n\nThe sequences\nC<\\a>,\nC<\\c>,\nC<\\e>,\nC<\\f>,\nC<\\n>,\nC<\\N{I<NAME>}>,\nC<\\N{U+I<hex char>}>,\nC<\\r>,\nC<\\t>,\nand\nC<\\x>\nare also special and have the same meanings as they do outside a\nbracketed character class.\n\nAlso, a backslash followed by two or three octal digits is considered an octal\nnumber.\n\nA C<[> is not special inside a character class, unless it's the start of a\nPOSIX character class (see L</POSIX Character Classes> below). It normally does\nnot need escaping.\n\nA C<]> is normally either the end of a POSIX character class (see\nL</POSIX Character Classes> below), or it signals the end of the bracketed\ncharacter class.  If you want to include a C<]> in the set of characters, you\nmust generally escape it.\n\nHowever, if the C<]> is the I<first> (or the second if the first\ncharacter is a caret) character of a bracketed character class, it\ndoes not denote the end of the class (as you cannot have an empty class)\nand is considered part of the set of characters that can be matched without\nescaping.\n\nExamples:\n\n \"+\"   =~ /[+?*]/     #  Match, \"+\" in a character class is not special.\n \"\\cH\" =~ /[\\b]/      #  Match, \\b inside in a character class\n                      #  is equivalent to a backspace.\n \"]\"   =~ /[][]/      #  Match, as the character class contains\n                      #  both [ and ].\n \"[]\"  =~ /[[]]/      #  Match, the pattern contains a character class\n                      #  containing just [, and the character class is\n                      #  followed by a ].\n\n=head3 Bracketed Character Classes and the C</xx> pattern modifier\n\nNormally SPACE and TAB characters have no special meaning inside a\nbracketed character class; they are just added to the list of characters\nmatched by the class.  But if the L<C</xx>|perlre/E<sol>x and E<sol>xx>\npattern modifier is in effect, they are generally ignored and can be\nadded to improve readability.  They can't be added in the middle of a\nsingle construct:\n\n / [ \\x{10 FFFF} ] /xx  # WRONG!\n\nThe SPACE in the middle of the hex constant is illegal.\n\nTo specify a literal SPACE character, you can escape it with a\nbackslash, like:\n\n /[ a e i o u \\  ]/xx\n\nThis matches the English vowels plus the SPACE character.\n\nFor clarity, you should already have been using C<\\t> to specify a\nliteral tab, and C<\\t> is unaffected by C</xx>.\n\n=head3 Character Ranges\n\nIt is not uncommon to want to match a range of characters. Luckily, instead\nof listing all characters in the range, one may use the hyphen (C<->).\nIf inside a bracketed character class you have two characters separated\nby a hyphen, it's treated as if all characters between the two were in\nthe class. For instance, C<[0-9]> matches any ASCII digit, and C<[a-m]>\nmatches any lowercase letter from the first half of the ASCII alphabet.\n\nNote that the two characters on either side of the hyphen are not\nnecessarily both letters or both digits. Any character is possible,\nalthough not advisable.  C<['-?]> contains a range of characters, but\nmost people will not know which characters that means.  Furthermore,\nsuch ranges may lead to portability problems if the code has to run on\na platform that uses a different character set, such as EBCDIC.\n\nIf a hyphen in a character class cannot syntactically be part of a range, for\ninstance because it is the first or the last character of the character class,\nor if it immediately follows a range, the hyphen isn't special, and so is\nconsidered a character to be matched literally.  If you want a hyphen in\nyour set of characters to be matched and its position in the class is such\nthat it could be considered part of a range, you must escape that hyphen\nwith a backslash.\n\nExamples:\n\n [a-z]       #  Matches a character that is a lower case ASCII letter.\n [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or\n             #  the letter 'z'.\n [-z]        #  Matches either a hyphen ('-') or the letter 'z'.\n [a-f-m]     #  Matches any letter between 'a' and 'f' (inclusive), the\n             #  hyphen ('-'), or the letter 'm'.\n ['-?]       #  Matches any of the characters  '()*+,-./0123456789:;<=>?\n             #  (But not on an EBCDIC platform).\n [\\N{APOSTROPHE}-\\N{QUESTION MARK}]\n             #  Matches any of the characters  '()*+,-./0123456789:;<=>?\n             #  even on an EBCDIC platform.\n [\\N{U+27}-\\N{U+3F}] # Same. (U+27 is \"'\", and U+3F is \"?\")\n\nAs the final two examples above show, you can achieve portablity to\nnon-ASCII platforms by using the C<\\N{...}> form for the range\nendpoints.  These indicate that the specified range is to be interpreted\nusing Unicode values, so C<[\\N{U+27}-\\N{U+3F}]> means to match\nC<\\N{U+27}>, C<\\N{U+28}>, C<\\N{U+29}>, ..., C<\\N{U+3D}>, C<\\N{U+3E}>,\nand C<\\N{U+3F}>, whatever the native code point versions for those are.\nThese are called \"Unicode\" ranges.  If either end is of the C<\\N{...}>\nform, the range is considered Unicode.  A C<regexp> warning is raised\nunder C<S<\"use re 'strict'\">> if the other endpoint is specified\nnon-portably:\n\n [\\N{U+00}-\\x09]    # Warning under re 'strict'; \\x09 is non-portable\n [\\N{U+00}-\\t]      # No warning;\n\nBoth of the above match the characters C<\\N{U+00}> C<\\N{U+01}>, ...\nC<\\N{U+08}>, C<\\N{U+09}>, but the C<\\x09> looks like it could be a\nmistake so the warning is raised (under C<re 'strict'>) for it.\n\nPerl also guarantees that the ranges C<A-Z>, C<a-z>, C<0-9>, and any\nsubranges of these match what an English-only speaker would expect them\nto match on any platform.  That is, C<[A-Z]> matches the 26 ASCII\nuppercase letters;\nC<[a-z]> matches the 26 lowercase letters; and C<[0-9]> matches the 10\ndigits.  Subranges, like C<[h-k]>, match correspondingly, in this case\njust the four letters C<\"h\">, C<\"i\">, C<\"j\">, and C<\"k\">.  This is the\nnatural behavior on ASCII platforms where the code points (ordinal\nvalues) for C<\"h\"> through C<\"k\"> are consecutive integers (0x68 through\n0x6B).  But special handling to achieve this may be needed on platforms\nwith a non-ASCII native character set.  For example, on EBCDIC\nplatforms, the code point for C<\"h\"> is 0x88, C<\"i\"> is 0x89, C<\"j\"> is\n0x91, and C<\"k\"> is 0x92.   Perl specially treats C<[h-k]> to exclude the\nseven code points in the gap: 0x8A through 0x90.  This special handling is\nonly invoked when the range is a subrange of one of the ASCII uppercase,\nlowercase, and digit ranges, AND each end of the range is expressed\neither as a literal, like C<\"A\">, or as a named character (C<\\N{...}>,\nincluding the C<\\N{U+...> form).\n\nEBCDIC Examples:\n\n [i-j]               #  Matches either \"i\" or \"j\"\n [i-\\N{LATIN SMALL LETTER J}]  # Same\n [i-\\N{U+6A}]        #  Same\n [\\N{U+69}-\\N{U+6A}] #  Same\n [\\x{89}-\\x{91}]     #  Matches 0x89 (\"i\"), 0x8A .. 0x90, 0x91 (\"j\")\n [i-\\x{91}]          #  Same\n [\\x{89}-j]          #  Same\n [i-J]               #  Matches, 0x89 (\"i\") .. 0xC1 (\"J\"); special\n                     #  handling doesn't apply because range is mixed\n                     #  case\n\n=head3 Negation\n\nIt is also possible to instead list the characters you do not want to\nmatch. You can do so by using a caret (C<^>) as the first character in the\ncharacter class. For instance, C<[^a-z]> matches any character that is not a\nlowercase ASCII letter, which therefore includes more than a million\nUnicode code points.  The class is said to be \"negated\" or \"inverted\".\n\nThis syntax make the caret a special character inside a bracketed character\nclass, but only if it is the first character of the class. So if you want\nthe caret as one of the characters to match, either escape the caret or\nelse don't list it first.\n\nIn inverted bracketed character classes, Perl ignores the Unicode rules\nthat normally say that named sequence, and certain characters should\nmatch a sequence of multiple characters use under caseless C</i>\nmatching.  Following those rules could lead to highly confusing\nsituations:\n\n \"ss\" =~ /^[^\\xDF]+$/ui;   # Matches!\n\nThis should match any sequences of characters that aren't C<\\xDF> nor\nwhat C<\\xDF> matches under C</i>.  C<\"s\"> isn't C<\\xDF>, but Unicode\nsays that C<\"ss\"> is what C<\\xDF> matches under C</i>.  So which one\n\"wins\"? Do you fail the match because the string has C<ss> or accept it\nbecause it has an C<s> followed by another C<s>?  Perl has chosen the\nlatter.  (See note in L</Bracketed Character Classes> above.)\n\nExamples:\n\n \"e\"  =~  /[^aeiou]/   #  No match, the 'e' is listed.\n \"x\"  =~  /[^aeiou]/   #  Match, as 'x' isn't a lowercase vowel.\n \"^\"  =~  /[^^]/       #  No match, matches anything that isn't a caret.\n \"^\"  =~  /[x^]/       #  Match, caret is not special here.\n\n=head3 Backslash Sequences\n\nYou can put any backslash sequence character class (with the exception of\nC<\\N> and C<\\R>) inside a bracketed character class, and it will act just\nas if you had put all characters matched by the backslash sequence inside the\ncharacter class. For instance, C<[a-f\\d]> matches any decimal digit, or any\nof the lowercase letters between 'a' and 'f' inclusive.\n\nC<\\N> within a bracketed character class must be of the forms C<\\N{I<name>}>\nor C<\\N{U+I<hex char>}>, and NOT be the form that matches non-newlines,\nfor the same reason that a dot C<.> inside a bracketed character class loses\nits special meaning: it matches nearly anything, which generally isn't what you\nwant to happen.\n\n\nExamples:\n\n /[\\p{Thai}\\d]/     # Matches a character that is either a Thai\n                    # character, or a digit.\n /[^\\p{Arabic}()]/  # Matches a character that is neither an Arabic\n                    # character, nor a parenthesis.\n\nBackslash sequence character classes cannot form one of the endpoints\nof a range.  Thus, you can't say:\n\n /[\\p{Thai}-\\d]/     # Wrong!\n\n=head3 POSIX Character Classes\nX<character class> X<\\p> X<\\p{}>\nX<alpha> X<alnum> X<ascii> X<blank> X<cntrl> X<digit> X<graph>\nX<lower> X<print> X<punct> X<space> X<upper> X<word> X<xdigit>\n\nPOSIX character classes have the form C<[:class:]>, where I<class> is the\nname, and the C<[:> and C<:]> delimiters. POSIX character classes only appear\nI<inside> bracketed character classes, and are a convenient and descriptive\nway of listing a group of characters.\n\nBe careful about the syntax,\n\n # Correct:\n $string =~ /[[:alpha:]]/\n\n # Incorrect (will warn):\n $string =~ /[:alpha:]/\n\nThe latter pattern would be a character class consisting of a colon,\nand the letters C<a>, C<l>, C<p> and C<h>.\n\nPOSIX character classes can be part of a larger bracketed character class.\nFor example,\n\n [01[:alpha:]%]\n\nis valid and matches '0', '1', any alphabetic character, and the percent sign.\n\nPerl recognizes the following POSIX character classes:\n\n alpha  Any alphabetical character (\"[A-Za-z]\").\n alnum  Any alphanumeric character (\"[A-Za-z0-9]\").\n ascii  Any character in the ASCII character set.\n blank  A GNU extension, equal to a space or a horizontal tab (\"\\t\").\n cntrl  Any control character.  See Note [2] below.\n digit  Any decimal digit (\"[0-9]\"), equivalent to \"\\d\".\n graph  Any printable character, excluding a space.  See Note [3] below.\n lower  Any lowercase character (\"[a-z]\").\n print  Any printable character, including a space.  See Note [4] below.\n punct  Any graphical character excluding \"word\" characters.  Note [5].\n space  Any whitespace character. \"\\s\" including the vertical tab\n        (\"\\cK\").\n upper  Any uppercase character (\"[A-Z]\").\n word   A Perl extension (\"[A-Za-z0-9_]\"), equivalent to \"\\w\".\n xdigit Any hexadecimal digit (\"[0-9a-fA-F]\").\n\nLike the L<Unicode properties|/Unicode Properties>, most of the POSIX\nproperties match the same regardless of whether case-insensitive (C</i>)\nmatching is in effect or not.  The two exceptions are C<[:upper:]> and\nC<[:lower:]>.  Under C</i>, they each match the union of C<[:upper:]> and\nC<[:lower:]>.\n\nMost POSIX character classes have two Unicode-style C<\\p> property\ncounterparts.  (They are not official Unicode properties, but Perl extensions\nderived from official Unicode properties.)  The table below shows the relation\nbetween POSIX character classes and these counterparts.\n\nOne counterpart, in the column labelled \"ASCII-range Unicode\" in\nthe table, matches only characters in the ASCII character set.\n\nThe other counterpart, in the column labelled \"Full-range Unicode\", matches any\nappropriate characters in the full Unicode character set.  For example,\nC<\\p{Alpha}> matches not just the ASCII alphabetic characters, but any\ncharacter in the entire Unicode character set considered alphabetic.\nAn entry in the column labelled \"backslash sequence\" is a (short)\nequivalent.\n\n [[:...:]]      ASCII-range          Full-range  backslash  Note\n                 Unicode              Unicode     sequence\n -----------------------------------------------------\n   alpha      \\p{PosixAlpha}       \\p{XPosixAlpha}\n   alnum      \\p{PosixAlnum}       \\p{XPosixAlnum}\n   ascii      \\p{ASCII}\n   blank      \\p{PosixBlank}       \\p{XPosixBlank}  \\h      [1]\n                                   or \\p{HorizSpace}        [1]\n   cntrl      \\p{PosixCntrl}       \\p{XPosixCntrl}          [2]\n   digit      \\p{PosixDigit}       \\p{XPosixDigit}  \\d\n   graph      \\p{PosixGraph}       \\p{XPosixGraph}          [3]\n   lower      \\p{PosixLower}       \\p{XPosixLower}\n   print      \\p{PosixPrint}       \\p{XPosixPrint}          [4]\n   punct      \\p{PosixPunct}       \\p{XPosixPunct}          [5]\n              \\p{PerlSpace}        \\p{XPerlSpace}   \\s      [6]\n   space      \\p{PosixSpace}       \\p{XPosixSpace}          [6]\n   upper      \\p{PosixUpper}       \\p{XPosixUpper}\n   word       \\p{PosixWord}        \\p{XPosixWord}   \\w\n   xdigit     \\p{PosixXDigit}      \\p{XPosixXDigit}\n\n=over 4\n\n=item [1]\n\nC<\\p{Blank}> and C<\\p{HorizSpace}> are synonyms.\n\n=item [2]\n\nControl characters don't produce output as such, but instead usually control\nthe terminal somehow: for example, newline and backspace are control characters.\nOn ASCII platforms, in the ASCII range, characters whose code points are\nbetween 0 and 31 inclusive, plus 127 (C<DEL>) are control characters; on\nEBCDIC platforms, their counterparts are control characters.\n\n=item [3]\n\nAny character that is I<graphical>, that is, visible. This class consists\nof all alphanumeric characters and all punctuation characters.\n\n=item [4]\n\nAll printable characters, which is the set of all graphical characters\nplus those whitespace characters which are not also controls.\n\n=item [5]\n\nC<\\p{PosixPunct}> and C<[[:punct:]]> in the ASCII range match all\nnon-controls, non-alphanumeric, non-space characters:\nC<[-!\"#$%&'()*+,./:;<=E<gt>?@[\\\\\\]^_`{|}~]> (although if a locale is in effect,\nit could alter the behavior of C<[[:punct:]]>).\n\nThe similarly named property, C<\\p{Punct}>, matches a somewhat different\nset in the ASCII range, namely\nC<[-!\"#%&'()*,./:;?@[\\\\\\]_{}]>.  That is, it is missing the nine\ncharacters C<[$+E<lt>=E<gt>^`|~]>.\nThis is because Unicode splits what POSIX considers to be punctuation into two\ncategories, Punctuation and Symbols.\n\nC<\\p{XPosixPunct}> and (under Unicode rules) C<[[:punct:]]>, match what\nC<\\p{PosixPunct}> matches in the ASCII range, plus what C<\\p{Punct}>\nmatches.  This is different than strictly matching according to\nC<\\p{Punct}>.  Another way to say it is that\nif Unicode rules are in effect, C<[[:punct:]]> matches all characters\nthat Unicode considers punctuation, plus all ASCII-range characters that\nUnicode considers symbols.\n\n=item [6]\n\nC<\\p{XPerlSpace}> and C<\\p{Space}> match identically starting with Perl\nv5.18.  In earlier versions, these differ only in that in non-locale\nmatching, C<\\p{XPerlSpace}> did not match the vertical tab, C<\\cK>.\nSame for the two ASCII-only range forms.\n\n=back\n\nThere are various other synonyms that can be used besides the names\nlisted in the table.  For example, C<\\p{XPosixAlpha}> can be written as\nC<\\p{Alpha}>.  All are listed in\nL<perluniprops/Properties accessible through \\p{} and \\P{}>.\n\nBoth the C<\\p> counterparts always assume Unicode rules are in effect.\nOn ASCII platforms, this means they assume that the code points from 128\nto 255 are Latin-1, and that means that using them under locale rules is\nunwise unless the locale is guaranteed to be Latin-1 or UTF-8.  In contrast, the\nPOSIX character classes are useful under locale rules.  They are\naffected by the actual rules in effect, as follows:\n\n=over\n\n=item If the C</a> modifier, is in effect ...\n\nEach of the POSIX classes matches exactly the same as their ASCII-range\ncounterparts.\n\n=item otherwise ...\n\n=over\n\n=item For code points above 255 ...\n\nThe POSIX class matches the same as its Full-range counterpart.\n\n=item For code points below 256 ...\n\n=over\n\n=item if locale rules are in effect ...\n\nThe POSIX class matches according to the locale, except:\n\n=over\n\n=item C<word>\n\nalso includes the platform's native underscore character, no matter what\nthe locale is.\n\n=item C<ascii>\n\non platforms that don't have the POSIX C<ascii> extension, this matches\njust the platform's native ASCII-range characters.\n\n=item C<blank>\n\non platforms that don't have the POSIX C<blank> extension, this matches\njust the platform's native tab and space characters.\n\n=back\n\n=item if, instead, Unicode rules are in effect ...\n\nThe POSIX class matches the same as the Full-range counterpart.\n\n=item otherwise ...\n\nThe POSIX class matches the same as the ASCII range counterpart.\n\n=back\n\n=back\n\n=back\n\nWhich rules apply are determined as described in\nL<perlre/Which character set modifier is in effect?>.\n\nIt is proposed to change this behavior in a future release of Perl so that\nwhether or not Unicode rules are in effect would not change the\nbehavior:  Outside of locale, the POSIX classes\nwould behave like their ASCII-range counterparts.  If you wish to\ncomment on this proposal, send email to C<perl5-porters@perl.org>.\n\n=head4 Negation of POSIX character classes\nX<character class, negation>\n\nA Perl extension to the POSIX character class is the ability to\nnegate it. This is done by prefixing the class name with a caret (C<^>).\nSome examples:\n\n     POSIX         ASCII-range     Full-range  backslash\n                    Unicode         Unicode    sequence\n -----------------------------------------------------\n [[:^digit:]]   \\P{PosixDigit}  \\P{XPosixDigit}   \\D\n [[:^space:]]   \\P{PosixSpace}  \\P{XPosixSpace}\n                \\P{PerlSpace}   \\P{XPerlSpace}    \\S\n [[:^word:]]    \\P{PerlWord}    \\P{XPosixWord}    \\W\n\nThe backslash sequence can mean either ASCII- or Full-range Unicode,\ndepending on various factors as described in L<perlre/Which character set modifier is in effect?>.\n\n=head4 [= =] and [. .]\n\nPerl recognizes the POSIX character classes C<[=class=]> and\nC<[.class.]>, but does not (yet?) support them.  Any attempt to use\neither construct raises an exception.\n\n=head4 Examples\n\n /[[:digit:]]/            # Matches a character that is a digit.\n /[01[:lower:]]/          # Matches a character that is either a\n                          # lowercase letter, or '0' or '1'.\n /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything\n                          # except the letters 'a' to 'f' and 'A' to\n                          # 'F'.  This is because the main character\n                          # class is composed of two POSIX character\n                          # classes that are ORed together, one that\n                          # matches any digit, and the other that\n                          # matches anything that isn't a hex digit.\n                          # The OR adds the digits, leaving only the\n                          # letters 'a' to 'f' and 'A' to 'F' excluded.\n\n=head3 Extended Bracketed Character Classes\nX<character class>\nX<set operations>\n\nThis is a fancy bracketed character class that can be used for more\nreadable and less error-prone classes, and to perform set operations,\nsuch as intersection. An example is\n\n /(?[ \\p{Thai} & \\p{Digit} ])/\n\nThis will match all the digit characters that are in the Thai script.\n\nThis is an experimental feature available starting in 5.18, and is\nsubject to change as we gain field experience with it.  Any attempt to\nuse it will raise a warning, unless disabled via\n\n no warnings \"experimental::regex_sets\";\n\nComments on this feature are welcome; send email to\nC<perl5-porters@perl.org>.\n\nThe rules used by L<C<use re 'strict>|re/'strict' mode> apply to this\nconstruct.\n\nWe can extend the example above:\n\n /(?[ ( \\p{Thai} + \\p{Lao} ) & \\p{Digit} ])/\n\nThis matches digits that are in either the Thai or Laotian scripts.\n\nNotice the white space in these examples.  This construct always has\nthe C<E<sol>xx> modifier turned on within it.\n\nThe available binary operators are:\n\n &    intersection\n +    union\n |    another name for '+', hence means union\n -    subtraction (the result matches the set consisting of those\n      code points matched by the first operand, excluding any that\n      are also matched by the second operand)\n ^    symmetric difference (the union minus the intersection).  This\n      is like an exclusive or, in that the result is the set of code\n      points that are matched by either, but not both, of the\n      operands.\n\nThere is one unary operator:\n\n !    complement\n\nAll the binary operators left associate; C<\"&\"> is higher precedence\nthan the others, which all have equal precedence.  The unary operator\nright associates, and has highest precedence.  Thus this follows the\nnormal Perl precedence rules for logical operators.  Use parentheses to\noverride the default precedence and associativity.\n\nThe main restriction is that everything is a metacharacter.  Thus,\nyou cannot refer to single characters by doing something like this:\n\n /(?[ a + b ])/ # Syntax error!\n\nThe easiest way to specify an individual typable character is to enclose\nit in brackets:\n\n /(?[ [a] + [b] ])/\n\n(This is the same thing as C<[ab]>.)  You could also have said the\nequivalent:\n\n /(?[[ a b ]])/\n\n(You can, of course, specify single characters by using, C<\\x{...}>,\nC<\\N{...}>, etc.)\n\nThis last example shows the use of this construct to specify an ordinary\nbracketed character class without additional set operations.  Note the\nwhite space within it.  This is allowed because C<E<sol>xx> is\nautomatically turned on within this construct.\n\nAll the other escapes accepted by normal bracketed character classes are\naccepted here as well.\n\nBecause this construct compiles under\nL<C<use re 'strict>|re/'strict' mode>,  unrecognized escapes that\ngenerate warnings in normal classes are fatal errors here, as well as\nall other warnings from these class elements, as well as some\npractices that don't currently warn outside C<re 'strict'>.  For example\nyou cannot say\n\n /(?[ [ \\xF ] ])/     # Syntax error!\n\nYou have to have two hex digits after a braceless C<\\x> (use a leading\nzero to make two).  These restrictions are to lower the incidence of\ntypos causing the class to not match what you thought it would.\n\nIf a regular bracketed character class contains a C<\\p{}> or C<\\P{}> and\nis matched against a non-Unicode code point, a warning may be\nraised, as the result is not Unicode-defined.  No such warning will come\nwhen using this extended form.\n\nThe final difference between regular bracketed character classes and\nthese, is that it is not possible to get these to match a\nmulti-character fold.  Thus,\n\n /(?[ [\\xDF] ])/iu\n\ndoes not match the string C<ss>.\n\nYou don't have to enclose POSIX class names inside double brackets,\nhence both of the following work:\n\n /(?[ [:word:] - [:lower:] ])/\n /(?[ [[:word:]] - [[:lower:]] ])/\n\nAny contained POSIX character classes, including things like C<\\w> and C<\\D>\nrespect the C<E<sol>a> (and C<E<sol>aa>) modifiers.\n\nC<< (?[ ]) >> is a regex-compile-time construct.  Any attempt to use\nsomething which isn't knowable at the time the containing regular\nexpression is compiled is a fatal error.  In practice, this means\njust three limitations:\n\n=over 4\n\n=item 1\n\nWhen compiled within the scope of C<use locale> (or the C<E<sol>l> regex\nmodifier), this construct assumes that the execution-time locale will be\na UTF-8 one, and the generated pattern always uses Unicode rules.  What\ngets matched or not thus isn't dependent on the actual runtime locale, so\ntainting is not enabled.  But a C<locale> category warning is raised\nif the runtime locale turns out to not be UTF-8.\n\n=item 2\n\nAny\nL<user-defined property|perlunicode/\"User-Defined Character Properties\">\nused must be already defined by the time the regular expression is\ncompiled (but note that this construct can be used instead of such\nproperties).\n\n=item 3\n\nA regular expression that otherwise would compile\nusing C<E<sol>d> rules, and which uses this construct will instead\nuse C<E<sol>u>.  Thus this construct tells Perl that you don't want\nC<E<sol>d> rules for the entire regular expression containing it.\n\n=back\n\nNote that skipping white space applies only to the interior of this\nconstruct.  There must not be any space between any of the characters\nthat form the initial C<(?[>.  Nor may there be space between the\nclosing C<])> characters.\n\nJust as in all regular expressions, the pattern can be built up by\nincluding variables that are interpolated at regex compilation time.\nCare must be taken to ensure that you are getting what you expect.  For\nexample:\n\n my $thai_or_lao = '\\p{Thai} + \\p{Lao}';\n ...\n qr/(?[ \\p{Digit} & $thai_or_lao ])/;\n\ncompiles to\n\n qr/(?[ \\p{Digit} & \\p{Thai} + \\p{Lao} ])/;\n\nBut this does not have the effect that someone reading the code would\nlikely expect, as the intersection applies just to C<\\p{Thai}>,\nexcluding the Laotian.  Pitfalls like this can be avoided by\nparenthesizing the component pieces:\n\n my $thai_or_lao = '( \\p{Thai} + \\p{Lao} )';\n\nBut any modifiers will still apply to all the components:\n\n my $lower = '\\p{Lower} + \\p{Digit}';\n qr/(?[ \\p{Greek} & $lower ])/i;\n\nmatches upper case things.  You can avoid surprises by making the\ncomponents into instances of this construct by compiling them:\n\n my $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\n my $lower = qr/(?[ \\p{Lower} + \\p{Digit} ])/;\n\nWhen these are embedded in another pattern, what they match does not\nchange, regardless of parenthesization or what modifiers are in effect\nin that outer pattern.\n\nDue to the way that Perl parses things, your parentheses and brackets\nmay need to be balanced, even including comments.  If you run into any\nexamples, please send them to C<perlbug@perl.org>, so that we can have a\nconcrete example for this man page.\n\nWe may change it so that things that remain legal uses in normal bracketed\ncharacter classes might become illegal within this experimental\nconstruct.  One proposal, for example, is to forbid adjacent uses of the\nsame character, as in C<(?[ [aa] ])>.  The motivation for such a change\nis that this usage is likely a typo, as the second \"a\" adds nothing.\n", "/*    regcomp.c\n */\n\n/*\n * 'A fair jaw-cracker dwarf-language must be.'            --Samwise Gamgee\n *\n *     [p.285 of _The Lord of the Rings_, II/iii: \"The Ring Goes South\"]\n */\n\n/* This file contains functions for compiling a regular expression.  See\n * also regexec.c which funnily enough, contains functions for executing\n * a regular expression.\n *\n * This file is also copied at build time to ext/re/re_comp.c, where\n * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.\n * This causes the main functions to be compiled under new names and with\n * debugging support added, which makes \"use re 'debug'\" work.\n */\n\n/* NOTE: this is derived from Henry Spencer's regexp code, and should not\n * confused with the original package (see point 3 below).  Thanks, Henry!\n */\n\n/* Additional note: this code is very heavily munged from Henry's version\n * in places.  In some spots I've traded clarity for efficiency, so don't\n * blame Henry for some of the lack of readability.\n */\n\n/* The names of the functions have been changed from regcomp and\n * regexec to pregcomp and pregexec in order to avoid conflicts\n * with the POSIX routines of the same names.\n*/\n\n#ifdef PERL_EXT_RE_BUILD\n#include \"re_top.h\"\n#endif\n\n/*\n * pregcomp and pregexec -- regsub and regerror are not used in perl\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n *\n ****    Alterations to Henry's code are...\n ****\n ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n ****    by Larry Wall and others\n ****\n ****    You may distribute under the terms of either the GNU General Public\n ****    License or the Artistic License, as specified in the README file.\n\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n */\n#include \"EXTERN.h\"\n#define PERL_IN_REGCOMP_C\n#include \"perl.h\"\n\n#ifndef PERL_IN_XSUB_RE\n#  include \"INTERN.h\"\n#endif\n\n#define REG_COMP_C\n#ifdef PERL_IN_XSUB_RE\n#  include \"re_comp.h\"\nEXTERN_C const struct regexp_engine my_reg_engine;\n#else\n#  include \"regcomp.h\"\n#endif\n\n#include \"dquote_inline.h\"\n#include \"invlist_inline.h\"\n#include \"unicode_constants.h\"\n\n#define HAS_NONLATIN1_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define IS_NON_FINAL_FOLD(c) _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n#define IS_IN_SOME_FOLD_L1(c) _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\n#ifndef STATIC\n#define\tSTATIC\tstatic\n#endif\n\n/* this is a chain of data about sub patterns we are processing that\n   need to be handled separately/specially in study_chunk. Its so\n   we can simulate recursion without losing state.  */\nstruct scan_frame;\ntypedef struct scan_frame {\n    regnode *last_regnode;      /* last node to process in this frame */\n    regnode *next_regnode;      /* next node to process when last is reached */\n    U32 prev_recursed_depth;\n    I32 stopparen;              /* what stopparen do we use */\n\n    struct scan_frame *this_prev_frame; /* this previous frame */\n    struct scan_frame *prev_frame;      /* previous frame */\n    struct scan_frame *next_frame;      /* next frame */\n} scan_frame;\n\n/* Certain characters are output as a sequence with the first being a\n * backslash. */\n#define isBACKSLASHED_PUNCT(c)  strchr(\"-[]\\\\^\", c)\n\n\nstruct RExC_state_t {\n    U32\t\tflags;\t\t\t/* RXf_* are we folding, multilining? */\n    U32\t\tpm_flags;\t\t/* PMf_* stuff from the calling PMOP */\n    char\t*precomp;\t\t/* uncompiled string. */\n    char\t*precomp_end;\t\t/* pointer to end of uncompiled string. */\n    REGEXP\t*rx_sv;\t\t\t/* The SV that is the regexp. */\n    regexp\t*rx;                    /* perl core regexp structure */\n    regexp_internal\t*rxi;           /* internal data for regexp object\n                                           pprivate field */\n    char\t*start;\t\t\t/* Start of input for compile */\n    char\t*end;\t\t\t/* End of input for compile */\n    char\t*parse;\t\t\t/* Input-scan pointer. */\n    char        *adjusted_start;        /* 'start', adjusted.  See code use */\n    STRLEN      precomp_adj;            /* an offset beyond precomp.  See code use */\n    SSize_t\twhilem_seen;\t\t/* number of WHILEM in this expr */\n    regnode\t*emit_start;\t\t/* Start of emitted-code area */\n    regnode\t*emit_bound;\t\t/* First regnode outside of the\n                                           allocated space */\n    regnode\t*emit;\t\t\t/* Code-emit pointer; if = &emit_dummy,\n                                           implies compiling, so don't emit */\n    regnode_ssc\temit_dummy;\t\t/* placeholder for emit to point to;\n                                           large enough for the largest\n                                           non-EXACTish node, so can use it as\n                                           scratch in pass1 */\n    I32\t\tnaughty;\t\t/* How bad is this pattern? */\n    I32\t\tsawback;\t\t/* Did we see \\1, ...? */\n    U32\t\tseen;\n    SSize_t\tsize;\t\t\t/* Code size. */\n    I32                npar;            /* Capture buffer count, (OPEN) plus\n                                           one. (\"par\" 0 is the whole\n                                           pattern)*/\n    I32\t\tnestroot;\t\t/* root parens we are in - used by\n                                           accept */\n    I32\t\textralen;\n    I32\t\tseen_zerolen;\n    regnode\t**open_parens;\t\t/* pointers to open parens */\n    regnode\t**close_parens;\t\t/* pointers to close parens */\n    regnode     *end_op;                /* END node in program */\n    I32\t\tutf8;\t\t/* whether the pattern is utf8 or not */\n    I32\t\torig_utf8;\t/* whether the pattern was originally in utf8 */\n\t\t\t\t/* XXX use this for future optimisation of case\n\t\t\t\t * where pattern must be upgraded to utf8. */\n    I32\t\tuni_semantics;\t/* If a d charset modifier should use unicode\n\t\t\t\t   rules, even if the pattern is not in\n\t\t\t\t   utf8 */\n    HV\t\t*paren_names;\t\t/* Paren names */\n\n    regnode\t**recurse;\t\t/* Recurse regops */\n    I32                recurse_count;                /* Number of recurse regops we have generated */\n    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved\n                                           through */\n    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */\n    I32\t\tin_lookbehind;\n    I32\t\tcontains_locale;\n    I32\t\toverride_recoding;\n#ifdef EBCDIC\n    I32\t\trecode_x_to_native;\n#endif\n    I32\t\tin_multi_char_class;\n    struct reg_code_blocks *code_blocks;/* positions of literal (?{})\n\t\t\t\t\t    within pattern */\n    int\t\tcode_index;\t\t/* next code_blocks[] slot */\n    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */\n    scan_frame *frame_head;\n    scan_frame *frame_last;\n    U32         frame_count;\n    AV         *warn_text;\n#ifdef ADD_TO_REGEXEC\n    char \t*starttry;\t\t/* -Dr: where regtry was called. */\n#define RExC_starttry\t(pRExC_state->starttry)\n#endif\n    SV\t\t*runtime_code_qr;\t/* qr with the runtime code blocks */\n#ifdef DEBUGGING\n    const char  *lastparse;\n    I32         lastnum;\n    AV          *paren_name_list;       /* idx -> name */\n    U32         study_chunk_recursed_count;\n    SV          *mysv1;\n    SV          *mysv2;\n#define RExC_lastparse\t(pRExC_state->lastparse)\n#define RExC_lastnum\t(pRExC_state->lastnum)\n#define RExC_paren_name_list    (pRExC_state->paren_name_list)\n#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)\n#define RExC_mysv\t(pRExC_state->mysv1)\n#define RExC_mysv1\t(pRExC_state->mysv1)\n#define RExC_mysv2\t(pRExC_state->mysv2)\n\n#endif\n    bool        seen_unfolded_sharp_s;\n    bool        strict;\n    bool        study_started;\n};\n\n#define RExC_flags\t(pRExC_state->flags)\n#define RExC_pm_flags\t(pRExC_state->pm_flags)\n#define RExC_precomp\t(pRExC_state->precomp)\n#define RExC_precomp_adj (pRExC_state->precomp_adj)\n#define RExC_adjusted_start  (pRExC_state->adjusted_start)\n#define RExC_precomp_end (pRExC_state->precomp_end)\n#define RExC_rx_sv\t(pRExC_state->rx_sv)\n#define RExC_rx\t\t(pRExC_state->rx)\n#define RExC_rxi\t(pRExC_state->rxi)\n#define RExC_start\t(pRExC_state->start)\n#define RExC_end\t(pRExC_state->end)\n#define RExC_parse\t(pRExC_state->parse)\n#define RExC_whilem_seen\t(pRExC_state->whilem_seen)\n\n/* Set during the sizing pass when there is a LATIN SMALL LETTER SHARP S in any\n * EXACTF node, hence was parsed under /di rules.  If later in the parse,\n * something forces the pattern into using /ui rules, the sharp s should be\n * folded into the sequence 'ss', which takes up more space than previously\n * calculated.  This means that the sizing pass needs to be restarted.  (The\n * node also becomes an EXACTFU_SS.)  For all other characters, an EXACTF node\n * that gets converted to /ui (and EXACTFU) occupies the same amount of space,\n * so there is no need to resize [perl #125990]. */\n#define RExC_seen_unfolded_sharp_s (pRExC_state->seen_unfolded_sharp_s)\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n#define RExC_offsets\t(pRExC_state->rxi->u.offsets) /* I am not like the\n                                                         others */\n#endif\n#define RExC_emit\t(pRExC_state->emit)\n#define RExC_emit_dummy\t(pRExC_state->emit_dummy)\n#define RExC_emit_start\t(pRExC_state->emit_start)\n#define RExC_emit_bound\t(pRExC_state->emit_bound)\n#define RExC_sawback\t(pRExC_state->sawback)\n#define RExC_seen\t(pRExC_state->seen)\n#define RExC_size\t(pRExC_state->size)\n#define RExC_maxlen        (pRExC_state->maxlen)\n#define RExC_npar\t(pRExC_state->npar)\n#define RExC_nestroot   (pRExC_state->nestroot)\n#define RExC_extralen\t(pRExC_state->extralen)\n#define RExC_seen_zerolen\t(pRExC_state->seen_zerolen)\n#define RExC_utf8\t(pRExC_state->utf8)\n#define RExC_uni_semantics\t(pRExC_state->uni_semantics)\n#define RExC_orig_utf8\t(pRExC_state->orig_utf8)\n#define RExC_open_parens\t(pRExC_state->open_parens)\n#define RExC_close_parens\t(pRExC_state->close_parens)\n#define RExC_end_op\t(pRExC_state->end_op)\n#define RExC_paren_names\t(pRExC_state->paren_names)\n#define RExC_recurse\t(pRExC_state->recurse)\n#define RExC_recurse_count\t(pRExC_state->recurse_count)\n#define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed)\n#define RExC_study_chunk_recursed_bytes  \\\n                                   (pRExC_state->study_chunk_recursed_bytes)\n#define RExC_in_lookbehind\t(pRExC_state->in_lookbehind)\n#define RExC_contains_locale\t(pRExC_state->contains_locale)\n#ifdef EBCDIC\n#   define RExC_recode_x_to_native (pRExC_state->recode_x_to_native)\n#endif\n#define RExC_in_multi_char_class (pRExC_state->in_multi_char_class)\n#define RExC_frame_head (pRExC_state->frame_head)\n#define RExC_frame_last (pRExC_state->frame_last)\n#define RExC_frame_count (pRExC_state->frame_count)\n#define RExC_strict (pRExC_state->strict)\n#define RExC_study_started      (pRExC_state->study_started)\n#define RExC_warn_text (pRExC_state->warn_text)\n\n/* Heuristic check on the complexity of the pattern: if TOO_NAUGHTY, we set\n * a flag to disable back-off on the fixed/floating substrings - if it's\n * a high complexity pattern we assume the benefit of avoiding a full match\n * is worth the cost of checking for the substrings even if they rarely help.\n */\n#define RExC_naughty\t(pRExC_state->naughty)\n#define TOO_NAUGHTY (10)\n#define MARK_NAUGHTY(add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += (add)\n#define MARK_NAUGHTY_EXP(exp, add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += RExC_naughty / (exp) + (add)\n\n#define\tISMULT1(c)\t((c) == '*' || (c) == '+' || (c) == '?')\n#define\tISMULT2(s)\t((*s) == '*' || (*s) == '+' || (*s) == '?' || \\\n\t((*s) == '{' && regcurly(s)))\n\n/*\n * Flags to be passed up and down.\n */\n#define\tWORST\t\t0\t/* Worst case. */\n#define\tHASWIDTH\t0x01\t/* Known to match non-null strings. */\n\n/* Simple enough to be STAR/PLUS operand; in an EXACTish node must be a single\n * character.  (There needs to be a case: in the switch statement in regexec.c\n * for any node marked SIMPLE.)  Note that this is not the same thing as\n * REGNODE_SIMPLE */\n#define\tSIMPLE\t\t0x02\n#define\tSPSTART\t\t0x04\t/* Starts with * or + */\n#define POSTPONED\t0x08    /* (?1),(?&name), (??{...}) or similar */\n#define TRYAGAIN\t0x10\t/* Weeded out a declaration. */\n#define RESTART_PASS1   0x20    /* Need to restart sizing pass */\n#define NEED_UTF8       0x40    /* In conjunction with RESTART_PASS1, need to\n                                   calcuate sizes as UTF-8 */\n\n#define REG_NODE_NUM(x) ((x) ? (int)((x)-RExC_emit_start) : -1)\n\n/* whether trie related optimizations are enabled */\n#if PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION\n#define TRIE_STUDY_OPT\n#define FULL_TRIE_STUDY\n#define TRIE_STCLASS\n#endif\n\n\n\n#define PBYTE(u8str,paren) ((U8*)(u8str))[(paren) >> 3]\n#define PBITVAL(paren) (1 << ((paren) & 7))\n#define PAREN_TEST(u8str,paren) ( PBYTE(u8str,paren) & PBITVAL(paren))\n#define PAREN_SET(u8str,paren) PBYTE(u8str,paren) |= PBITVAL(paren)\n#define PAREN_UNSET(u8str,paren) PBYTE(u8str,paren) &= (~PBITVAL(paren))\n\n#define REQUIRE_UTF8(flagp) STMT_START {                                   \\\n                                     if (!UTF) {                           \\\n                                         assert(PASS1);                    \\\n                                         *flagp = RESTART_PASS1|NEED_UTF8; \\\n                                         return NULL;                      \\\n                                     }                                     \\\n                             } STMT_END\n\n/* Change from /d into /u rules, and restart the parse if we've already seen\n * something whose size would increase as a result, by setting *flagp and\n * returning 'restart_retval'.  RExC_uni_semantics is a flag that indicates\n * we've change to /u during the parse.  */\n#define REQUIRE_UNI_RULES(flagp, restart_retval)                            \\\n    STMT_START {                                                            \\\n            if (DEPENDS_SEMANTICS) {                                        \\\n                assert(PASS1);                                              \\\n                set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);      \\\n                RExC_uni_semantics = 1;                                     \\\n                if (RExC_seen_unfolded_sharp_s) {                           \\\n                    *flagp |= RESTART_PASS1;                                \\\n                    return restart_retval;                                  \\\n                }                                                           \\\n            }                                                               \\\n    } STMT_END\n\n/* This converts the named class defined in regcomp.h to its equivalent class\n * number defined in handy.h. */\n#define namedclass_to_classnum(class)  ((int) ((class) / 2))\n#define classnum_to_namedclass(classnum)  ((classnum) * 2)\n\n#define _invlist_union_complement_2nd(a, b, output) \\\n                        _invlist_union_maybe_complement_2nd(a, b, TRUE, output)\n#define _invlist_intersection_complement_2nd(a, b, output) \\\n                 _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)\n\n/* About scan_data_t.\n\n  During optimisation we recurse through the regexp program performing\n  various inplace (keyhole style) optimisations. In addition study_chunk\n  and scan_commit populate this data structure with information about\n  what strings MUST appear in the pattern. We look for the longest\n  string that must appear at a fixed location, and we look for the\n  longest string that may appear at a floating location. So for instance\n  in the pattern:\n\n    /FOO[xX]A.*B[xX]BAR/\n\n  Both 'FOO' and 'A' are fixed strings. Both 'B' and 'BAR' are floating\n  strings (because they follow a .* construct). study_chunk will identify\n  both FOO and BAR as being the longest fixed and floating strings respectively.\n\n  The strings can be composites, for instance\n\n     /(f)(o)(o)/\n\n  will result in a composite fixed substring 'foo'.\n\n  For each string some basic information is maintained:\n\n  - min_offset\n    This is the position the string must appear at, or not before.\n    It also implicitly (when combined with minlenp) tells us how many\n    characters must match before the string we are searching for.\n    Likewise when combined with minlenp and the length of the string it\n    tells us how many characters must appear after the string we have\n    found.\n\n  - max_offset\n    Only used for floating strings. This is the rightmost point that\n    the string can appear at. If set to SSize_t_MAX it indicates that the\n    string can occur infinitely far to the right.\n    For fixed strings, it is equal to min_offset.\n\n  - minlenp\n    A pointer to the minimum number of characters of the pattern that the\n    string was found inside. This is important as in the case of positive\n    lookahead or positive lookbehind we can have multiple patterns\n    involved. Consider\n\n    /(?=FOO).*F/\n\n    The minimum length of the pattern overall is 3, the minimum length\n    of the lookahead part is 3, but the minimum length of the part that\n    will actually match is 1. So 'FOO's minimum length is 3, but the\n    minimum length for the F is 1. This is important as the minimum length\n    is used to determine offsets in front of and behind the string being\n    looked for.  Since strings can be composites this is the length of the\n    pattern at the time it was committed with a scan_commit. Note that\n    the length is calculated by study_chunk, so that the minimum lengths\n    are not known until the full pattern has been compiled, thus the\n    pointer to the value.\n\n  - lookbehind\n\n    In the case of lookbehind the string being searched for can be\n    offset past the start point of the final matching string.\n    If this value was just blithely removed from the min_offset it would\n    invalidate some of the calculations for how many chars must match\n    before or after (as they are derived from min_offset and minlen and\n    the length of the string being searched for).\n    When the final pattern is compiled and the data is moved from the\n    scan_data_t structure into the regexp structure the information\n    about lookbehind is factored in, with the information that would\n    have been lost precalculated in the end_shift field for the\n    associated string.\n\n  The fields pos_min and pos_delta are used to store the minimum offset\n  and the delta to the maximum offset at the current point in the pattern.\n\n*/\n\nstruct scan_data_substrs {\n    SV      *str;       /* longest substring found in pattern */\n    SSize_t min_offset; /* earliest point in string it can appear */\n    SSize_t max_offset; /* latest point in string it can appear */\n    SSize_t *minlenp;   /* pointer to the minlen relevant to the string */\n    SSize_t lookbehind; /* is the pos of the string modified by LB */\n    I32 flags;          /* per substring SF_* and SCF_* flags */\n};\n\ntypedef struct scan_data_t {\n    /*I32 len_min;      unused */\n    /*I32 len_delta;    unused */\n    SSize_t pos_min;\n    SSize_t pos_delta;\n    SV *last_found;\n    SSize_t last_end;\t    /* min value, <0 unless valid. */\n    SSize_t last_start_min;\n    SSize_t last_start_max;\n    U8      cur_is_floating; /* whether the last_* values should be set as\n                              * the next fixed (0) or floating (1)\n                              * substring */\n\n    /* [0] is longest fixed substring so far, [1] is longest float so far */\n    struct scan_data_substrs  substrs[2];\n\n    I32 flags;             /* common SF_* and SCF_* flags */\n    I32 whilem_c;\n    SSize_t *last_closep;\n    regnode_ssc *start_class;\n} scan_data_t;\n\n/*\n * Forward declarations for pregcomp()'s friends.\n */\n\nstatic const scan_data_t zero_scan_data = {\n    0, 0, NULL, 0, 0, 0, 0,\n    {\n        { NULL, 0, 0, 0, 0, 0 },\n        { NULL, 0, 0, 0, 0, 0 },\n    },\n    0, 0, NULL, NULL\n};\n\n/* study flags */\n\n#define SF_BEFORE_SEOL\t\t0x0001\n#define SF_BEFORE_MEOL\t\t0x0002\n#define SF_BEFORE_EOL\t\t(SF_BEFORE_SEOL|SF_BEFORE_MEOL)\n\n#define SF_IS_INF\t\t0x0040\n#define SF_HAS_PAR\t\t0x0080\n#define SF_IN_PAR\t\t0x0100\n#define SF_HAS_EVAL\t\t0x0200\n\n\n/* SCF_DO_SUBSTR is the flag that tells the regexp analyzer to track the\n * longest substring in the pattern. When it is not set the optimiser keeps\n * track of position, but does not keep track of the actual strings seen,\n *\n * So for instance /foo/ will be parsed with SCF_DO_SUBSTR being true, but\n * /foo/i will not.\n *\n * Similarly, /foo.*(blah|erm|huh).*fnorble/ will have \"foo\" and \"fnorble\"\n * parsed with SCF_DO_SUBSTR on, but while processing the (...) it will be\n * turned off because of the alternation (BRANCH). */\n#define SCF_DO_SUBSTR\t\t0x0400\n\n#define SCF_DO_STCLASS_AND\t0x0800\n#define SCF_DO_STCLASS_OR\t0x1000\n#define SCF_DO_STCLASS\t\t(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR)\n#define SCF_WHILEM_VISITED_POS\t0x2000\n\n#define SCF_TRIE_RESTUDY        0x4000 /* Do restudy? */\n#define SCF_SEEN_ACCEPT         0x8000\n#define SCF_TRIE_DOING_RESTUDY 0x10000\n#define SCF_IN_DEFINE          0x20000\n\n\n\n\n#define UTF cBOOL(RExC_utf8)\n\n/* The enums for all these are ordered so things work out correctly */\n#define LOC (get_regex_charset(RExC_flags) == REGEX_LOCALE_CHARSET)\n#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags)                    \\\n                                                     == REGEX_DEPENDS_CHARSET)\n#define UNI_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_UNICODE_CHARSET)\n#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags)                \\\n                                                     >= REGEX_UNICODE_CHARSET)\n#define ASCII_RESTRICTED (get_regex_charset(RExC_flags)                      \\\n                                            == REGEX_ASCII_RESTRICTED_CHARSET)\n#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags)             \\\n                                            >= REGEX_ASCII_RESTRICTED_CHARSET)\n#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags)                 \\\n                                        == REGEX_ASCII_MORE_RESTRICTED_CHARSET)\n\n#define FOLD cBOOL(RExC_flags & RXf_PMf_FOLD)\n\n/* For programs that want to be strictly Unicode compatible by dying if any\n * attempt is made to match a non-Unicode code point against a Unicode\n * property.  */\n#define ALWAYS_WARN_SUPER  ckDEAD(packWARN(WARN_NON_UNICODE))\n\n#define OOB_NAMEDCLASS\t\t-1\n\n/* There is no code point that is out-of-bounds, so this is problematic.  But\n * its only current use is to initialize a variable that is always set before\n * looked at. */\n#define OOB_UNICODE\t\t0xDEADBEEF\n\n#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))\n\n\n/* length of regex to show in messages that don't mark a position within */\n#define RegexLengthToShowInErrorMessages 127\n\n/*\n * If MARKER[12] are adjusted, be sure to adjust the constants at the top\n * of t/op/regmesg.t, the tests in t/op/re_tests, and those in\n * op/pragma/warn/regcomp.\n */\n#define MARKER1 \"<-- HERE\"    /* marker as it appears in the description */\n#define MARKER2 \" <-- HERE \"  /* marker as it appears within the regex */\n\n#define REPORT_LOCATION \" in regex; marked by \" MARKER1    \\\n                        \" in m/%\" UTF8f MARKER2 \"%\" UTF8f \"/\"\n\n/* The code in this file in places uses one level of recursion with parsing\n * rebased to an alternate string constructed by us in memory.  This can take\n * the form of something that is completely different from the input, or\n * something that uses the input as part of the alternate.  In the first case,\n * there should be no possibility of an error, as we are in complete control of\n * the alternate string.  But in the second case we don't control the input\n * portion, so there may be errors in that.  Here's an example:\n *      /[abc\\x{DF}def]/ui\n * is handled specially because \\x{df} folds to a sequence of more than one\n * character, 'ss'.  What is done is to create and parse an alternate string,\n * which looks like this:\n *      /(?:\\x{DF}|[abc\\x{DF}def])/ui\n * where it uses the input unchanged in the middle of something it constructs,\n * which is a branch for the DF outside the character class, and clustering\n * parens around the whole thing. (It knows enough to skip the DF inside the\n * class while in this substitute parse.) 'abc' and 'def' may have errors that\n * need to be reported.  The general situation looks like this:\n *\n *              sI                       tI               xI       eI\n * Input:       ----------------------------------------------------\n * Constructed:         ---------------------------------------------------\n *                      sC               tC               xC       eC     EC\n *\n * The input string sI..eI is the input pattern.  The string sC..EC is the\n * constructed substitute parse string.  The portions sC..tC and eC..EC are\n * constructed by us.  The portion tC..eC is an exact duplicate of the input\n * pattern tI..eI.  In the diagram, these are vertically aligned.  Suppose that\n * while parsing, we find an error at xC.  We want to display a message showing\n * the real input string.  Thus we need to find the point xI in it which\n * corresponds to xC.  xC >= tC, since the portion of the string sC..tC has\n * been constructed by us, and so shouldn't have errors.  We get:\n *\n *      xI = sI + (tI - sI) + (xC - tC)\n *\n * and, the offset into sI is:\n *\n *      (xI - sI) = (tI - sI) + (xC - tC)\n *\n * When the substitute is constructed, we save (tI -sI) as RExC_precomp_adj,\n * and we save tC as RExC_adjusted_start.\n *\n * During normal processing of the input pattern, everything points to that,\n * with RExC_precomp_adj set to 0, and RExC_adjusted_start set to sI.\n */\n\n#define tI_sI           RExC_precomp_adj\n#define tC              RExC_adjusted_start\n#define sC              RExC_precomp\n#define xI_offset(xC)   ((IV) (tI_sI + (xC - tC)))\n#define xI(xC)          (sC + xI_offset(xC))\n#define eC              RExC_precomp_end\n\n#define REPORT_LOCATION_ARGS(xC)                                            \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eC) /* Don't run off end */                          \\\n              ? eC - sC   /* Length before the <--HERE */                   \\\n              : ( __ASSERT_(xI_offset(xC) >= 0) xI_offset(xC) ),            \\\n             sC),         /* The input pattern printed up to the <--HERE */ \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eC) ? 0 : eC - xI(xC), /* Length after <--HERE */    \\\n             (xI(xC) > eC) ? eC : xI(xC))     /* pattern after <--HERE */\n\n/* Used to point after bad bytes for an error message, but avoid skipping\n * past a nul byte. */\n#define SKIP_IF_CHAR(s) (!*(s) ? 0 : UTF ? UTF8SKIP(s) : 1)\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given\n * arg. Show regex, up to a maximum length. If it's too long, chop and add\n * \"...\".\n */\n#define _FAIL(code) STMT_START {\t\t\t\t\t\\\n    const char *ellipses = \"\";\t\t\t\t\t\t\\\n    IV len = RExC_precomp_end - RExC_precomp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\t\t\\\n    if (len > RegexLengthToShowInErrorMessages) {\t\t\t\\\n\t/* chop 10 shorter than the max, to ensure meaning of \"...\" */\t\\\n\tlen = RegexLengthToShowInErrorMessages - 10;\t\t\t\\\n\tellipses = \"...\";\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    code;                                                               \\\n} STMT_END\n\n#define\tFAIL(msg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ \"%s in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n#define\tFAIL2(msg,arg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ msg \" in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    arg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n/*\n * Simple_vFAIL -- like FAIL, but marks the current location in the scan\n */\n#define\tSimple_vFAIL(m) STMT_START {\t\t\t\t\t\\\n    Perl_croak(aTHX_ \"%s\" REPORT_LOCATION,\t\t\t\t\\\n\t    m, REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL()\n */\n#define\tvFAIL(m) STMT_START {\t\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL(m);\t\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts two arguments.\n */\n#define\tSimple_vFAIL2(m,a1) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,\t\t\\\n                      REPORT_LOCATION_ARGS(RExC_parse));\t\\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL2().\n */\n#define\tvFAIL2(m,a1) STMT_START {\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL2(m, a1);\t\t\t\t\\\n} STMT_END\n\n\n/*\n * Like Simple_vFAIL(), but accepts three arguments.\n */\n#define\tSimple_vFAIL3(m, a1, a2) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,\t\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL3().\n */\n#define\tvFAIL3(m,a1,a2) STMT_START {\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL3(m, a1, a2);\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts four arguments.\n */\n#define\tSimple_vFAIL4(m, a1, a2, a3) STMT_START {\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n#define\tvFAIL4(m,a1,a2,a3) STMT_START {\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL4(m, a1, a2, a3);\t\t\t\\\n} STMT_END\n\n/* A specialized version of vFAIL2 that works with UTF8f */\n#define vFAIL2utf8f(m, a1) STMT_START {             \\\n    if (!SIZE_ONLY)                                 \\\n        SAVEFREESV(RExC_rx_sv);                     \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));      \\\n} STMT_END\n\n#define vFAIL3utf8f(m, a1, a2) STMT_START {             \\\n    if (!SIZE_ONLY)                                     \\\n        SAVEFREESV(RExC_rx_sv);                         \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));          \\\n} STMT_END\n\n/* These have asserts in them because of [perl #122671] Many warnings in\n * regcomp.c can occur twice.  If they get output in pass1 and later in that\n * pass, the pattern has to be converted to UTF-8 and the pass restarted, they\n * would get output again.  So they should be output in pass2, and these\n * asserts make sure new warnings follow that paradigm. */\n\n/* m is not necessarily a \"literal string\", in this macro */\n#define reg_warn_non_literal_string(loc, m) STMT_START {                \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       \"%s\" REPORT_LOCATION,            \\\n                                  m, REPORT_LOCATION_ARGS(loc));        \\\n} STMT_END\n\n#define\tckWARNreg(loc,m) STMT_START {\t\t\t\t\t\\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \\\n                                          m REPORT_LOCATION,\t        \\\n\t                                  REPORT_LOCATION_ARGS(loc));   \\\n} STMT_END\n\n#define\tvWARN(loc, m) STMT_START {\t\t\t\t        \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       m REPORT_LOCATION,               \\\n                                       REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n#define\tvWARN_dep(loc, m) STMT_START {\t\t\t\t        \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),       \\\n                                       m REPORT_LOCATION,               \\\n\t                               REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n#define\tckWARNdep(loc,m) STMT_START {\t\t\t\t        \\\n    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),  \\\n\t                                    m REPORT_LOCATION,          \\\n\t                                    REPORT_LOCATION_ARGS(loc)); \\\n} STMT_END\n\n#define\tckWARNregdep(loc,m) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,      \\\n                                                      WARN_REGEXP),         \\\n\t                                     m REPORT_LOCATION,             \\\n\t                                     REPORT_LOCATION_ARGS(loc));    \\\n} STMT_END\n\n#define\tckWARN2reg_d(loc,m, a1) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),          \\\n\t                                    m REPORT_LOCATION,              \\\n\t                                    a1, REPORT_LOCATION_ARGS(loc)); \\\n} STMT_END\n\n#define\tckWARN2reg(loc, m, a1) STMT_START {                                 \\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \\\n                                          m REPORT_LOCATION,\t            \\\n                                          a1, REPORT_LOCATION_ARGS(loc));   \\\n} STMT_END\n\n#define\tvWARN3(loc, m, a1, a2) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),               \\\n                                       m REPORT_LOCATION,                   \\\n\t                               a1, a2, REPORT_LOCATION_ARGS(loc));  \\\n} STMT_END\n\n#define\tckWARN3reg(loc, m, a1, a2) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \\\n                                          m REPORT_LOCATION,                \\\n\t                                  a1, a2,                           \\\n                                          REPORT_LOCATION_ARGS(loc));       \\\n} STMT_END\n\n#define\tvWARN4(loc, m, a1, a2, a3) STMT_START {\t\t\t\t\\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       m REPORT_LOCATION,               \\\n\t                               a1, a2, a3,                      \\\n                                       REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n#define\tckWARN4reg(loc, m, a1, a2, a3) STMT_START {\t\t\t\\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \\\n                                          m REPORT_LOCATION,            \\\n\t                                  a1, a2, a3,                   \\\n                                          REPORT_LOCATION_ARGS(loc));   \\\n} STMT_END\n\n#define\tvWARN5(loc, m, a1, a2, a3, a4) STMT_START {\t\t\t\\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       m REPORT_LOCATION,\t\t\\\n\t                               a1, a2, a3, a4,                  \\\n                                       REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n/* Macros for recording node offsets.   20001227 mjd@plover.com\n * Nodes are numbered 1, 2, 3, 4.  Node #n's position is recorded in\n * element 2*n-1 of the array.  Element #2n holds the byte length node #n.\n * Element 0 holds the number n.\n * Position is 1 indexed.\n */\n#ifndef RE_TRACK_PATTERN_OFFSETS\n#define Set_Node_Offset_To_R(node,byte)\n#define Set_Node_Offset(node,byte)\n#define Set_Cur_Node_Offset\n#define Set_Node_Length_To_R(node,len)\n#define Set_Node_Length(node,len)\n#define Set_Node_Cur_Length(node,start)\n#define Node_Offset(n)\n#define Node_Length(n)\n#define Set_Node_Offset_Length(node,offset,len)\n#define ProgLen(ri) ri->u.proglen\n#define SetProgLen(ri,x) ri->u.proglen = x\n#else\n#define ProgLen(ri) ri->u.offsets[0]\n#define SetProgLen(ri,x) ri->u.offsets[0] = x\n#define Set_Node_Offset_To_R(node,byte) STMT_START {\t\t\t\\\n    if (! SIZE_ONLY) {\t\t\t\t\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) offset of node %d is %d.\\n\",\t\t\\\n\t\t    __LINE__, (int)(node), (int)(byte)));\t\t\\\n\tif((node) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Offset macro\",     \\\n                                         (int)(node));                  \\\n\t} else {\t\t\t\t\t\t\t\\\n\t    RExC_offsets[2*(node)-1] = (byte);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Offset(node,byte) \\\n    Set_Node_Offset_To_R((node)-RExC_emit_start, (byte)-RExC_start)\n#define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)\n\n#define Set_Node_Length_To_R(node,len) STMT_START {\t\t\t\\\n    if (! SIZE_ONLY) {\t\t\t\t\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) size of node %d is %d.\\n\",\t\t\\\n\t\t__LINE__, (int)(node), (int)(len)));\t\t\t\\\n\tif((node) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Length macro\",     \\\n                                         (int)(node));                  \\\n\t} else {\t\t\t\t\t\t\t\\\n\t    RExC_offsets[2*(node)] = (len);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Length(node,len) \\\n    Set_Node_Length_To_R((node)-RExC_emit_start, len)\n#define Set_Node_Cur_Length(node, start)                \\\n    Set_Node_Length(node, RExC_parse - start)\n\n/* Get offsets and lengths */\n#define Node_Offset(n) (RExC_offsets[2*((n)-RExC_emit_start)-1])\n#define Node_Length(n) (RExC_offsets[2*((n)-RExC_emit_start)])\n\n#define Set_Node_Offset_Length(node,offset,len) STMT_START {\t\\\n    Set_Node_Offset_To_R((node)-RExC_emit_start, (offset));\t\\\n    Set_Node_Length_To_R((node)-RExC_emit_start, (len));\t\\\n} STMT_END\n#endif\n\n#if PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS\n#define EXPERIMENTAL_INPLACESCAN\n#endif /*PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS*/\n\n#ifdef DEBUGGING\nint\nPerl_re_printf(pTHX_ const char *fmt, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_PRINTF;\n    va_start(ap, fmt);\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n\nint\nPerl_re_indentf(pTHX_ const char *fmt, U32 depth, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_INDENTF;\n    va_start(ap, depth);\n    PerlIO_printf(f, \"%*s\", ( (int)depth % 20 ) * 2, \"\");\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n#endif /* DEBUGGING */\n\n#define DEBUG_RExC_seen()                                                   \\\n        DEBUG_OPTIMISE_MORE_r({                                             \\\n            Perl_re_printf( aTHX_ \"RExC_seen: \");                                       \\\n                                                                            \\\n            if (RExC_seen & REG_ZERO_LEN_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_ZERO_LEN_SEEN \");                            \\\n                                                                            \\\n            if (RExC_seen & REG_LOOKBEHIND_SEEN)                            \\\n                Perl_re_printf( aTHX_ \"REG_LOOKBEHIND_SEEN \");                          \\\n                                                                            \\\n            if (RExC_seen & REG_GPOS_SEEN)                                  \\\n                Perl_re_printf( aTHX_ \"REG_GPOS_SEEN \");                                \\\n                                                                            \\\n            if (RExC_seen & REG_RECURSE_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_RECURSE_SEEN \");                             \\\n                                                                            \\\n            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                    \\\n                Perl_re_printf( aTHX_ \"REG_TOP_LEVEL_BRANCHES_SEEN \");                  \\\n                                                                            \\\n            if (RExC_seen & REG_VERBARG_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_VERBARG_SEEN \");                             \\\n                                                                            \\\n            if (RExC_seen & REG_CUTGROUP_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_CUTGROUP_SEEN \");                            \\\n                                                                            \\\n            if (RExC_seen & REG_RUN_ON_COMMENT_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_RUN_ON_COMMENT_SEEN \");                      \\\n                                                                            \\\n            if (RExC_seen & REG_UNFOLDED_MULTI_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_UNFOLDED_MULTI_SEEN \");                      \\\n                                                                            \\\n            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                  \\\n                Perl_re_printf( aTHX_ \"REG_UNBOUNDED_QUANTIFIER_SEEN \");                \\\n                                                                            \\\n            Perl_re_printf( aTHX_ \"\\n\");                                                \\\n        });\n\n#define DEBUG_SHOW_STUDY_FLAG(flags,flag) \\\n  if ((flags) & flag) Perl_re_printf( aTHX_  \"%s \", #flag)\n\n\n#ifdef DEBUGGING\nstatic void\nS_debug_show_study_flags(pTHX_ U32 flags, const char *open_str,\n                                    const char *close_str)\n{\n    if (!flags)\n        return;\n\n    Perl_re_printf( aTHX_  \"%s\", open_str);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_SEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_MEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IS_INF);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IN_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_EVAL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_SUBSTR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_AND);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_OR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_WHILEM_VISITED_POS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_SEEN_ACCEPT);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_DOING_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_IN_DEFINE);\n    Perl_re_printf( aTHX_  \"%s\", close_str);\n}\n\n\nstatic void\nS_debug_studydata(pTHX_ const char *where, scan_data_t *data,\n                    U32 depth, int is_inf)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_MORE_r({\n        if (!data)\n            return;\n        Perl_re_indentf(aTHX_  \"%s: Pos:%\" IVdf \"/%\" IVdf \" Flags: 0x%\" UVXf,\n            depth,\n            where,\n            (IV)data->pos_min,\n            (IV)data->pos_delta,\n            (UV)data->flags\n        );\n\n        S_debug_show_study_flags(aTHX_ data->flags,\" [\",\"]\");\n\n        Perl_re_printf( aTHX_\n            \" Whilem_c: %\" IVdf \" Lcp: %\" IVdf \" %s\",\n            (IV)data->whilem_c,\n            (IV)(data->last_closep ? *((data)->last_closep) : -1),\n            is_inf ? \"INF \" : \"\"\n        );\n\n        if (data->last_found) {\n            int i;\n            Perl_re_printf(aTHX_\n                \"Last:'%s' %\" IVdf \":%\" IVdf \"/%\" IVdf,\n                    SvPVX_const(data->last_found),\n                    (IV)data->last_end,\n                    (IV)data->last_start_min,\n                    (IV)data->last_start_max\n            );\n\n            for (i = 0; i < 2; i++) {\n                Perl_re_printf(aTHX_\n                    \" %s%s: '%s' @ %\" IVdf \"/%\" IVdf,\n                    data->cur_is_floating == i ? \"*\" : \"\",\n                    i ? \"Float\" : \"Fixed\",\n                    SvPVX_const(data->substrs[i].str),\n                    (IV)data->substrs[i].min_offset,\n                    (IV)data->substrs[i].max_offset\n                );\n                S_debug_show_study_flags(aTHX_ data->substrs[i].flags,\" [\",\"]\");\n            }\n        }\n\n        Perl_re_printf( aTHX_ \"\\n\");\n    });\n}\n\n\nstatic void\nS_debug_peep(pTHX_ const char *str, const RExC_state_t *pRExC_state,\n                regnode *scan, U32 depth, U32 flags)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_r({\n        regnode *Next;\n\n        if (!scan)\n            return;\n        Next = regnext(scan);\n        regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n        Perl_re_indentf( aTHX_   \"%s>%3d: %s (%d)\",\n            depth,\n            str,\n            REG_NODE_NUM(scan), SvPV_nolen_const(RExC_mysv),\n            Next ? (REG_NODE_NUM(Next)) : 0 );\n        S_debug_show_study_flags(aTHX_ flags,\" [ \",\"]\");\n        Perl_re_printf( aTHX_  \"\\n\");\n   });\n}\n\n\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) \\\n                    S_debug_studydata(aTHX_ where, data, depth, is_inf)\n\n#  define DEBUG_PEEP(str, scan, depth, flags)   \\\n                    S_debug_peep(aTHX_ str, pRExC_state, scan, depth, flags)\n\n#else\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) NOOP\n#  define DEBUG_PEEP(str, scan, depth, flags)         NOOP\n#endif\n\n\n/* =========================================================\n * BEGIN edit_distance stuff.\n *\n * This calculates how many single character changes of any type are needed to\n * transform a string into another one.  It is taken from version 3.1 of\n *\n * https://metacpan.org/pod/Text::Levenshtein::Damerau::XS\n */\n\n/* Our unsorted dictionary linked list.   */\n/* Note we use UVs, not chars. */\n\nstruct dictionary{\n  UV key;\n  UV value;\n  struct dictionary* next;\n};\ntypedef struct dictionary item;\n\n\nPERL_STATIC_INLINE item*\npush(UV key,item* curr)\n{\n    item* head;\n    Newx(head, 1, item);\n    head->key = key;\n    head->value = 0;\n    head->next = curr;\n    return head;\n}\n\n\nPERL_STATIC_INLINE item*\nfind(item* head, UV key)\n{\n    item* iterator = head;\n    while (iterator){\n        if (iterator->key == key){\n            return iterator;\n        }\n        iterator = iterator->next;\n    }\n\n    return NULL;\n}\n\nPERL_STATIC_INLINE item*\nuniquePush(item* head,UV key)\n{\n    item* iterator = head;\n\n    while (iterator){\n        if (iterator->key == key) {\n            return head;\n        }\n        iterator = iterator->next;\n    }\n\n    return push(key,head);\n}\n\nPERL_STATIC_INLINE void\ndict_free(item* head)\n{\n    item* iterator = head;\n\n    while (iterator) {\n        item* temp = iterator;\n        iterator = iterator->next;\n        Safefree(temp);\n    }\n\n    head = NULL;\n}\n\n/* End of Dictionary Stuff */\n\n/* All calculations/work are done here */\nSTATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             /* length of src[] */\n                const STRLEN y,             /* length of tgt[] */\n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount,swapScore,targetCharCount,i,j;\n    UV *scores;\n    UV score_ceil = x + y;\n\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n\n    /* intialize matrix start values */\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head,src[0]),tgt[0]);\n\n    /* work loops    */\n    /* i = src index */\n    /* j = tgt index */\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head,src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head,tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n\n            targetCharCount = find(head,tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n\n        find(head,src[i-1])->value = i;\n    }\n\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }\n}\n\n/* END of edit_distance() stuff\n * ========================================================= */\n\n/* is c a control character for which we have a mnemonic? */\n#define isMNEMONIC_CNTRL(c) _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\nSTATIC const char *\nS_cntrl_to_mnemonic(const U8 c)\n{\n    /* Returns the mnemonic string that represents character 'c', if one\n     * exists; NULL otherwise.  The only ones that exist for the purposes of\n     * this routine are a few control characters */\n\n    switch (c) {\n        case '\\a':       return \"\\\\a\";\n        case '\\b':       return \"\\\\b\";\n        case ESC_NATIVE: return \"\\\\e\";\n        case '\\f':       return \"\\\\f\";\n        case '\\n':       return \"\\\\n\";\n        case '\\r':       return \"\\\\r\";\n        case '\\t':       return \"\\\\t\";\n    }\n\n    return NULL;\n}\n\n/* Mark that we cannot extend a found fixed substring at this point.\n   Update the longest found anchored substring or the longest found\n   floating substrings if needed. */\n\nSTATIC void\nS_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data,\n                    SSize_t *minlenp, int is_inf)\n{\n    const STRLEN l = CHR_SVLEN(data->last_found);\n    SV * const longest_sv = data->substrs[data->cur_is_floating].str;\n    const STRLEN old_l = CHR_SVLEN(longest_sv);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_SCAN_COMMIT;\n\n    if ((l >= old_l) && ((l > old_l) || (data->flags & SF_BEFORE_EOL))) {\n        const U8 i = data->cur_is_floating;\n\tSvSetMagicSV(longest_sv, data->last_found);\n        data->substrs[i].min_offset = l ? data->last_start_min : data->pos_min;\n\n\tif (!i) /* fixed */\n\t    data->substrs[0].max_offset = data->substrs[0].min_offset;\n\telse { /* float */\n\t    data->substrs[1].max_offset = (l\n                          ? data->last_start_max\n                          : (data->pos_delta > SSize_t_MAX - data->pos_min\n\t\t\t\t\t ? SSize_t_MAX\n\t\t\t\t\t : data->pos_min + data->pos_delta));\n\t    if (is_inf\n\t\t || (STRLEN)data->substrs[1].max_offset > (STRLEN)SSize_t_MAX)\n\t\tdata->substrs[1].max_offset = SSize_t_MAX;\n        }\n\n        if (data->flags & SF_BEFORE_EOL)\n            data->substrs[i].flags |= (data->flags & SF_BEFORE_EOL);\n        else\n            data->substrs[i].flags &= ~SF_BEFORE_EOL;\n        data->substrs[i].minlenp = minlenp;\n        data->substrs[i].lookbehind = 0;\n    }\n\n    SvCUR_set(data->last_found, 0);\n    {\n\tSV * const sv = data->last_found;\n\tif (SvUTF8(sv) && SvMAGICAL(sv)) {\n\t    MAGIC * const mg = mg_find(sv, PERL_MAGIC_utf8);\n\t    if (mg)\n\t\tmg->mg_len = 0;\n\t}\n    }\n    data->last_end = -1;\n    data->flags &= ~SF_BEFORE_EOL;\n    DEBUG_STUDYDATA(\"commit\", data, 0, is_inf);\n}\n\n/* An SSC is just a regnode_charclass_posix with an extra field: the inversion\n * list that describes which code points it matches */\n\nSTATIC void\nS_ssc_anything(pTHX_ regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to match an empty string or any code point */\n\n    PERL_ARGS_ASSERT_SSC_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* mortalize so won't leak */\n    ssc->invlist = sv_2mortal(_add_range_to_invlist(NULL, 0, UV_MAX));\n    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;  /* Plus matches empty */\n}\n\nSTATIC int\nS_ssc_is_anything(const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' can match the empty string and any code\n     * point; FALSE otherwise.  Thus, this is used to see if using 'ssc' buys\n     * us anything: if the function returns TRUE, 'ssc' hasn't been restricted\n     * in any way, so there's no point in using it */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    if (! (ANYOF_FLAGS(ssc) & SSC_MATCHES_EMPTY_STRING)) {\n        return FALSE;\n    }\n\n    /* See if the list consists solely of the range 0 - Infinity */\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (ret) {\n        return TRUE;\n    }\n\n    /* If e.g., both \\w and \\W are set, matches everything */\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        int i;\n        for (i = 0; i < ANYOF_POSIXL_MAX; i += 2) {\n            if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i+1)) {\n                return TRUE;\n            }\n        }\n    }\n\n    return FALSE;\n}\n\nSTATIC void\nS_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* Initializes the SSC 'ssc'.  This includes setting it to match an empty\n     * string, any code point, or any posix class under locale */\n\n    PERL_ARGS_ASSERT_SSC_INIT;\n\n    Zero(ssc, 1, regnode_ssc);\n    set_ANYOF_SYNTHETIC(ssc);\n    ARG_SET(ssc, ANYOF_ONLY_HAS_BITMAP);\n    ssc_anything(ssc);\n\n    /* If any portion of the regex is to operate under locale rules that aren't\n     * fully known at compile time, initialization includes it.  The reason\n     * this isn't done for all regexes is that the optimizer was written under\n     * the assumption that locale was all-or-nothing.  Given the complexity and\n     * lack of documentation in the optimizer, and that there are inadequate\n     * test cases for locale, many parts of it may not work properly, it is\n     * safest to avoid locale unless necessary. */\n    if (RExC_contains_locale) {\n\tANYOF_POSIXL_SETALL(ssc);\n    }\n    else {\n\tANYOF_POSIXL_ZERO(ssc);\n    }\n}\n\nSTATIC int\nS_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state,\n                        const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' is in its initial state with regard only\n     * to the list of code points matched, and locale posix classes; hence does\n     * not check its flags) */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (! ret) {\n        return FALSE;\n    }\n\n    if (RExC_contains_locale && ! ANYOF_POSIXL_SSC_TEST_ALL_SET(ssc)) {\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\nSTATIC SV*\nS_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state,\n                               const regnode_charclass* const node)\n{\n    /* Returns a mortal inversion list defining which code points are matched\n     * by 'node', which is of type ANYOF.  Handles complementing the result if\n     * appropriate.  If some code points aren't knowable at this time, the\n     * returned list must, and will, contain every code point that is a\n     * possibility. */\n\n    SV* invlist = NULL;\n    SV* only_utf8_locale_invlist = NULL;\n    unsigned int i;\n    const U32 n = ARG(node);\n    bool new_node_has_latin1 = FALSE;\n\n    PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC;\n\n    /* Look at the data structure created by S_set_ANYOF_arg() */\n    if (n != ANYOF_ONLY_HAS_BITMAP) {\n        SV * const rv = MUTABLE_SV(RExC_rxi->data->data[n]);\n        AV * const av = MUTABLE_AV(SvRV(rv));\n        SV **const ary = AvARRAY(av);\n        assert(RExC_rxi->data->what[n] == 's');\n\n        if (ary[1] && ary[1] != &PL_sv_undef) { /* Has compile-time swash */\n            invlist = sv_2mortal(invlist_clone(_get_swash_invlist(ary[1])));\n        }\n        else if (ary[0] && ary[0] != &PL_sv_undef) {\n\n            /* Here, no compile-time swash, and there are things that won't be\n             * known until runtime -- we have to assume it could be anything */\n            invlist = sv_2mortal(_new_invlist(1));\n            return _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else if (ary[3] && ary[3] != &PL_sv_undef) {\n\n            /* Here no compile-time swash, and no run-time only data.  Use the\n             * node's inversion list */\n            invlist = sv_2mortal(invlist_clone(ary[3]));\n        }\n\n        /* Get the code points valid only under UTF-8 locales */\n        if ((ANYOF_FLAGS(node) & ANYOFL_FOLD)\n            && ary[2] && ary[2] != &PL_sv_undef)\n        {\n            only_utf8_locale_invlist = ary[2];\n        }\n    }\n\n    if (! invlist) {\n        invlist = sv_2mortal(_new_invlist(0));\n    }\n\n    /* An ANYOF node contains a bitmap for the first NUM_ANYOF_CODE_POINTS\n     * code points, and an inversion list for the others, but if there are code\n     * points that should match only conditionally on the target string being\n     * UTF-8, those are placed in the inversion list, and not the bitmap.\n     * Since there are circumstances under which they could match, they are\n     * included in the SSC.  But if the ANYOF node is to be inverted, we have\n     * to exclude them here, so that when we invert below, the end result\n     * actually does include them.  (Think about \"\\xe0\" =~ /[^\\xc0]/di;).  We\n     * have to do this here before we add the unconditionally matched code\n     * points */\n    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {\n        _invlist_intersection_complement_2nd(invlist,\n                                             PL_UpperLatin1,\n                                             &invlist);\n    }\n\n    /* Add in the points from the bit map */\n    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n        if (ANYOF_BITMAP_TEST(node, i)) {\n            unsigned int start = i++;\n\n            for (; i < NUM_ANYOF_CODE_POINTS && ANYOF_BITMAP_TEST(node, i); ++i) {\n                /* empty */\n            }\n            invlist = _add_range_to_invlist(invlist, start, i-1);\n            new_node_has_latin1 = TRUE;\n        }\n    }\n\n    /* If this can match all upper Latin1 code points, have to add them\n     * as well.  But don't add them if inverting, as when that gets done below,\n     * it would exclude all these characters, including the ones it shouldn't\n     * that were added just above */\n    if (! (ANYOF_FLAGS(node) & ANYOF_INVERT) && OP(node) == ANYOFD\n        && (ANYOF_FLAGS(node) & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))\n    {\n        _invlist_union(invlist, PL_UpperLatin1, &invlist);\n    }\n\n    /* Similarly for these */\n    if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n        _invlist_union_complement_2nd(invlist, PL_InBitmap, &invlist);\n    }\n\n    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {\n        _invlist_invert(invlist);\n    }\n    else if (new_node_has_latin1 && ANYOF_FLAGS(node) & ANYOFL_FOLD) {\n\n        /* Under /li, any 0-255 could fold to any other 0-255, depending on the\n         * locale.  We can skip this if there are no 0-255 at all. */\n        _invlist_union(invlist, PL_Latin1, &invlist);\n    }\n\n    /* Similarly add the UTF-8 locale possible matches.  These have to be\n     * deferred until after the non-UTF-8 locale ones are taken care of just\n     * above, or it leads to wrong results under ANYOF_INVERT */\n    if (only_utf8_locale_invlist) {\n        _invlist_union_maybe_complement_2nd(invlist,\n                                            only_utf8_locale_invlist,\n                                            ANYOF_FLAGS(node) & ANYOF_INVERT,\n                                            &invlist);\n    }\n\n    return invlist;\n}\n\n/* These two functions currently do the exact same thing */\n#define ssc_init_zero\t\tssc_init\n\n#define ssc_add_cp(ssc, cp)   ssc_add_range((ssc), (cp), (cp))\n#define ssc_match_all_cp(ssc) ssc_add_range(ssc, 0, UV_MAX)\n\n/* 'AND' a given class with another one.  Can create false positives.  'ssc'\n * should not be inverted.  'and_with->flags & ANYOF_MATCHES_POSIXL' should be\n * 0 if 'and_with' is a regnode_charclass instead of a regnode_ssc. */\n\nSTATIC void\nS_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n                const regnode_charclass *and_with)\n{\n    /* Accumulate into SSC 'ssc' its 'AND' with 'and_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives. */\n\n    SV* anded_cp_list;\n    U8  anded_flags;\n\n    PERL_ARGS_ASSERT_SSC_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'and_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(and_with)) {\n        anded_cp_list = ((regnode_ssc *)and_with)->invlist;\n        anded_flags = ANYOF_FLAGS(and_with);\n\n        /* XXX This is a kludge around what appears to be deficiencies in the\n         * optimizer.  If we make S_ssc_anything() add in the WARN_SUPER flag,\n         * there are paths through the optimizer where it doesn't get weeded\n         * out when it should.  And if we don't make some extra provision for\n         * it like the code just below, it doesn't get added when it should.\n         * This solution is to add it only when AND'ing, which is here, and\n         * only when what is being AND'ed is the pristine, original node\n         * matching anything.  Thus it is like adding it to ssc_anything() but\n         * only when the result is to be AND'ed.  Probably the same solution\n         * could be adopted for the same problem we have with /l matching,\n         * which is solved differently in S_ssc_init(), and that would lead to\n         * fewer false positives than that solution has.  But if this solution\n         * creates bugs, the consequences are only that a warning isn't raised\n         * that should be; while the consequences for having /l bugs is\n         * incorrect matches */\n        if (ssc_is_anything((regnode_ssc *)and_with)) {\n            anded_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n        }\n    }\n    else {\n        anded_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, and_with);\n        if (OP(and_with) == ANYOFD) {\n            anded_flags = ANYOF_FLAGS(and_with) & ANYOF_COMMON_FLAGS;\n        }\n        else {\n            anded_flags = ANYOF_FLAGS(and_with)\n            &( ANYOF_COMMON_FLAGS\n              |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n              |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(and_with))) {\n                anded_flags &=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) &= anded_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'and-with'; P2, its posix classes.\n     * 'and_with' may be inverted.  When not inverted, we have the situation of\n     * computing:\n     *  (C1 | P1) & (C2 | P2)\n     *                     =  (C1 & (C2 | P2)) | (P1 & (C2 | P2))\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |       P2)) | ( P1       | (P1 & P2))\n     *                    <=  ((C1 & C2) | P1 | P2)\n     * Alternatively, the last few steps could be:\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |  C1      ) | (      C2  | (P1 & P2))\n     *                    <=  (C1 | C2 | (P1 & P2))\n     * We favor the second approach if either P1 or P2 is non-empty.  This is\n     * because these components are a barrier to doing optimizations, as what\n     * they match cannot be known until the moment of matching as they are\n     * dependent on the current locale, 'AND\"ing them likely will reduce or\n     * eliminate them.\n     * But we can do better if we know that C1,P1 are in their initial state (a\n     * frequent occurrence), each matching everything:\n     *  (<everything>) & (C2 | P2) =  C2 | P2\n     * Similarly, if C2,P2 are in their initial state (again a frequent\n     * occurrence), the result is a no-op\n     *  (C1 | P1) & (<everything>) =  C1 | P1\n     *\n     * Inverted, we have\n     *  (C1 | P1) & ~(C2 | P2)  =  (C1 | P1) & (~C2 & ~P2)\n     *                          =  (C1 & (~C2 & ~P2)) | (P1 & (~C2 & ~P2))\n     *                         <=  (C1 & ~C2) | (P1 & ~P2)\n     * */\n\n    if ((ANYOF_FLAGS(and_with) & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(and_with))\n    {\n        unsigned int i;\n\n        ssc_intersection(ssc,\n                         anded_cp_list,\n                         FALSE /* Has already been inverted */\n                         );\n\n        /* If either P1 or P2 is empty, the intersection will be also; can skip\n         * the loop */\n        if (! (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL)) {\n            ANYOF_POSIXL_ZERO(ssc);\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n\n            /* Note that the Posix class component P from 'and_with' actually\n             * looks like:\n             *      P = Pa | Pb | ... | Pn\n             * where each component is one posix class, such as in [\\w\\s].\n             * Thus\n             *      ~P = ~(Pa | Pb | ... | Pn)\n             *         = ~Pa & ~Pb & ... & ~Pn\n             *        <= ~Pa | ~Pb | ... | ~Pn\n             * The last is something we can easily calculate, but unfortunately\n             * is likely to have many false positives.  We could do better\n             * in some (but certainly not all) instances if two classes in\n             * P have known relationships.  For example\n             *      :lower: <= :alpha: <= :alnum: <= \\w <= :graph: <= :print:\n             * So\n             *      :lower: & :print: = :lower:\n             * And similarly for classes that must be disjoint.  For example,\n             * since \\s and \\w can have no elements in common based on rules in\n             * the POSIX standard,\n             *      \\w & ^\\S = nothing\n             * Unfortunately, some vendor locales do not meet the Posix\n             * standard, in particular almost everything by Microsoft.\n             * The loop below just changes e.g., \\w into \\W and vice versa */\n\n            regnode_charclass_posixl temp;\n            int add = 1;    /* To calculate the index of the complement */\n\n            Zero(&temp, 1, regnode_charclass_posixl);\n            ANYOF_POSIXL_ZERO(&temp);\n            for (i = 0; i < ANYOF_MAX; i++) {\n                assert(i % 2 != 0\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i + 1));\n\n                if (ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)) {\n                    ANYOF_POSIXL_SET(&temp, i + add);\n                }\n                add = 0 - add; /* 1 goes to -1; -1 goes to 1 */\n            }\n            ANYOF_POSIXL_AND(&temp, ssc);\n\n        } /* else ssc already has no posixes */\n    } /* else: Not inverted.  This routine is a no-op if 'and_with' is an SSC\n         in its initial state */\n    else if (! is_ANYOF_SYNTHETIC(and_with)\n             || ! ssc_is_cp_posixl_init(pRExC_state, (regnode_ssc *)and_with))\n    {\n        /* But if 'ssc' is in its initial state, the result is just 'and_with';\n         * copy it over 'ssc' */\n        if (ssc_is_cp_posixl_init(pRExC_state, ssc)) {\n            if (is_ANYOF_SYNTHETIC(and_with)) {\n                StructCopy(and_with, ssc, regnode_ssc);\n            }\n            else {\n                ssc->invlist = anded_cp_list;\n                ANYOF_POSIXL_ZERO(ssc);\n                if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {\n                    ANYOF_POSIXL_OR((regnode_charclass_posixl*) and_with, ssc);\n                }\n            }\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)\n                 || (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL))\n        {\n            /* One or the other of P1, P2 is non-empty. */\n            if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {\n                ANYOF_POSIXL_AND((regnode_charclass_posixl*) and_with, ssc);\n            }\n            ssc_union(ssc, anded_cp_list, FALSE);\n        }\n        else { /* P1 = P2 = empty */\n            ssc_intersection(ssc, anded_cp_list, FALSE);\n        }\n    }\n}\n\nSTATIC void\nS_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n               const regnode_charclass *or_with)\n{\n    /* Accumulate into SSC 'ssc' its 'OR' with 'or_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives if\n     * 'or_with' is to be inverted. */\n\n    SV* ored_cp_list;\n    U8 ored_flags;\n\n    PERL_ARGS_ASSERT_SSC_OR;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'or_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(or_with)) {\n        ored_cp_list = ((regnode_ssc*) or_with)->invlist;\n        ored_flags = ANYOF_FLAGS(or_with);\n    }\n    else {\n        ored_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, or_with);\n        ored_flags = ANYOF_FLAGS(or_with) & ANYOF_COMMON_FLAGS;\n        if (OP(or_with) != ANYOFD) {\n            ored_flags\n            |= ANYOF_FLAGS(or_with)\n             & ( ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n                |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(or_with))) {\n                ored_flags |=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) |= ored_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'or-with'; P2, its posix classes.\n     * 'or_with' may be inverted.  When not inverted, we have the simple\n     * situation of computing:\n     *  (C1 | P1) | (C2 | P2)  =  (C1 | C2) | (P1 | P2)\n     * If P1|P2 yields a situation with both a class and its complement are\n     * set, like having both \\w and \\W, this matches all code points, and we\n     * can delete these from the P component of the ssc going forward.  XXX We\n     * might be able to delete all the P components, but I (khw) am not certain\n     * about this, and it is better to be safe.\n     *\n     * Inverted, we have\n     *  (C1 | P1) | ~(C2 | P2)  =  (C1 | P1) | (~C2 & ~P2)\n     *                         <=  (C1 | P1) | ~C2\n     *                         <=  (C1 | ~C2) | P1\n     * (which results in actually simpler code than the non-inverted case)\n     * */\n\n    if ((ANYOF_FLAGS(or_with) & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(or_with))\n    {\n        /* We ignore P2, leaving P1 going forward */\n    }   /* else  Not inverted */\n    else if (ANYOF_FLAGS(or_with) & ANYOF_MATCHES_POSIXL) {\n        ANYOF_POSIXL_OR((regnode_charclass_posixl*)or_with, ssc);\n        if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n            unsigned int i;\n            for (i = 0; i < ANYOF_MAX; i += 2) {\n                if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i + 1))\n                {\n                    ssc_match_all_cp(ssc);\n                    ANYOF_POSIXL_CLEAR(ssc, i);\n                    ANYOF_POSIXL_CLEAR(ssc, i+1);\n                }\n            }\n        }\n    }\n\n    ssc_union(ssc,\n              ored_cp_list,\n              FALSE /* Already has been inverted */\n              );\n}\n\nPERL_STATIC_INLINE void\nS_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_UNION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_union_maybe_complement_2nd(ssc->invlist,\n                                        invlist,\n                                        invert2nd,\n                                        &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_intersection(pTHX_ regnode_ssc *ssc,\n                         SV* const invlist,\n                         const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_INTERSECTION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_intersection_maybe_complement_2nd(ssc->invlist,\n                                               invlist,\n                                               invert2nd,\n                                               &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_add_range(pTHX_ regnode_ssc *ssc, const UV start, const UV end)\n{\n    PERL_ARGS_ASSERT_SSC_ADD_RANGE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ssc->invlist = _add_range_to_invlist(ssc->invlist, start, end);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_cp_and(pTHX_ regnode_ssc *ssc, const UV cp)\n{\n    /* AND just the single code point 'cp' into the SSC 'ssc' */\n\n    SV* cp_list = _new_invlist(2);\n\n    PERL_ARGS_ASSERT_SSC_CP_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    cp_list = add_cp_to_invlist(cp_list, cp);\n    ssc_intersection(ssc, cp_list,\n                     FALSE /* Not inverted */\n                     );\n    SvREFCNT_dec_NN(cp_list);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_clear_locale(regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to not match any locale things */\n    PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ANYOF_POSIXL_ZERO(ssc);\n    ANYOF_FLAGS(ssc) &= ~ANYOF_LOCALE_FLAGS;\n}\n\n#define NON_OTHER_COUNT   NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC bool\nS_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc)\n{\n    /* The synthetic start class is used to hopefully quickly winnow down\n     * places where a pattern could start a match in the target string.  If it\n     * doesn't really narrow things down that much, there isn't much point to\n     * having the overhead of using it.  This function uses some very crude\n     * heuristics to decide if to use the ssc or not.\n     *\n     * It returns TRUE if 'ssc' rules out more than half what it considers to\n     * be the \"likely\" possible matches, but of course it doesn't know what the\n     * actual things being matched are going to be; these are only guesses\n     *\n     * For /l matches, it assumes that the only likely matches are going to be\n     *      in the 0-255 range, uniformly distributed, so half of that is 127\n     * For /a and /d matches, it assumes that the likely matches will be just\n     *      the ASCII range, so half of that is 63\n     * For /u and there isn't anything matching above the Latin1 range, it\n     *      assumes that that is the only range likely to be matched, and uses\n     *      half that as the cut-off: 127.  If anything matches above Latin1,\n     *      it assumes that all of Unicode could match (uniformly), except for\n     *      non-Unicode code points and things in the General Category \"Other\"\n     *      (unassigned, private use, surrogates, controls and formats).  This\n     *      is a much large number. */\n\n    U32 count = 0;      /* Running total of number of code points matched by\n                           'ssc' */\n    UV start, end;      /* Start and end points of current range in inversion\n                           list */\n    const U32 max_code_points = (LOC)\n                                ?  256\n                                : ((   ! UNI_SEMANTICS\n                                     || invlist_highest(ssc->invlist) < 256)\n                                  ? 128\n                                  : NON_OTHER_COUNT);\n    const U32 max_match = max_code_points / 2;\n\n    PERL_ARGS_ASSERT_IS_SSC_WORTH_IT;\n\n    invlist_iterinit(ssc->invlist);\n    while (invlist_iternext(ssc->invlist, &start, &end)) {\n        if (start >= max_code_points) {\n            break;\n        }\n        end = MIN(end, max_code_points - 1);\n        count += end - start + 1;\n        if (count >= max_match) {\n            invlist_iterfinish(ssc->invlist);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\nSTATIC void\nS_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* The inversion list in the SSC is marked mortal; now we need a more\n     * permanent copy, which is stored the same way that is done in a regular\n     * ANYOF node, with the first NUM_ANYOF_CODE_POINTS code points in a bit\n     * map */\n\n    SV* invlist = invlist_clone(ssc->invlist);\n\n    PERL_ARGS_ASSERT_SSC_FINALIZE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* The code in this file assumes that all but these flags aren't relevant\n     * to the SSC, except SSC_MATCHES_EMPTY_STRING, which should be cleared\n     * by the time we reach here */\n    assert(! (ANYOF_FLAGS(ssc)\n        & ~( ANYOF_COMMON_FLAGS\n            |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n            |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)));\n\n    populate_ANYOF_from_invlist( (regnode *) ssc, &invlist);\n\n    set_ANYOF_arg(pRExC_state, (regnode *) ssc, invlist,\n                                NULL, NULL, NULL, FALSE);\n\n    /* Make sure is clone-safe */\n    ssc->invlist = NULL;\n\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        ANYOF_FLAGS(ssc) |= ANYOF_MATCHES_POSIXL;\n    }\n\n    if (RExC_contains_locale) {\n        OP(ssc) = ANYOFL;\n    }\n\n    assert(! (ANYOF_FLAGS(ssc) & ANYOF_LOCALE_FLAGS) || RExC_contains_locale);\n}\n\n#define TRIE_LIST_ITEM(state,idx) (trie->states[state].trans.list)[ idx ]\n#define TRIE_LIST_CUR(state)  ( TRIE_LIST_ITEM( state, 0 ).forid )\n#define TRIE_LIST_LEN(state) ( TRIE_LIST_ITEM( state, 0 ).newstate )\n#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list         \\\n                               ? (TRIE_LIST_CUR( idx ) - 1)           \\\n                               : 0 )\n\n\n#ifdef DEBUGGING\n/*\n   dump_trie(trie,widecharmap,revcharmap)\n   dump_trie_interim_list(trie,widecharmap,revcharmap,next_alloc)\n   dump_trie_interim_table(trie,widecharmap,revcharmap,next_alloc)\n\n   These routines dump out a trie in a somewhat readable format.\n   The _interim_ variants are used for debugging the interim\n   tables that are used to generate the final compressed\n   representation which is what dump_trie expects.\n\n   Part of the reason for their existence is to provide a form\n   of documentation as to how the different representations function.\n\n*/\n\n/*\n  Dumps the final compressed table form of the trie to Perl_debug_log.\n  Used for debugging make_trie().\n*/\n\nSTATIC void\nS_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV *widecharmap,\n\t    AV *revcharmap, U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    U16 word;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE;\n\n    Perl_re_indentf( aTHX_  \"Char : %-6s%-6s%-4s \",\n        depth+1, \"Match\",\"Base\",\"Ofs\" );\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, state, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n    Perl_re_printf( aTHX_  \"\\n\");\n    Perl_re_indentf( aTHX_ \"State|-----------------------\", depth+1);\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ )\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth, \"--------\");\n    Perl_re_printf( aTHX_  \"\\n\");\n\n    for( state = 1 ; state < trie->statecount ; state++ ) {\n\tconst U32 base = trie->states[ state ].trans.base;\n\n        Perl_re_indentf( aTHX_  \"#%4\" UVXf \"|\", depth+1, (UV)state);\n\n        if ( trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \" W%4X\", trie->states[ state ].wordnum );\n        } else {\n            Perl_re_printf( aTHX_  \"%6s\", \"\" );\n        }\n\n        Perl_re_printf( aTHX_  \" @%4\" UVXf \" \", (UV)base );\n\n        if ( base ) {\n            U32 ofs = 0;\n\n            while( ( base + ofs  < trie->uniquecharcount ) ||\n                   ( base + ofs - trie->uniquecharcount < trie->lasttrans\n                     && trie->trans[ base + ofs - trie->uniquecharcount ].check\n                                                                    != state))\n                    ofs++;\n\n            Perl_re_printf( aTHX_  \"+%2\" UVXf \"[ \", (UV)ofs);\n\n            for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                if ( ( base + ofs >= trie->uniquecharcount )\n                        && ( base + ofs - trie->uniquecharcount\n                                                        < trie->lasttrans )\n                        && trie->trans[ base + ofs\n                                    - trie->uniquecharcount ].check == state )\n                {\n                   Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth,\n                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next\n                   );\n                } else {\n                    Perl_re_printf( aTHX_  \"%*s\",colwidth,\"   .\" );\n                }\n            }\n\n            Perl_re_printf( aTHX_  \"]\");\n\n        }\n        Perl_re_printf( aTHX_  \"\\n\" );\n    }\n    Perl_re_indentf( aTHX_  \"word_info N:(prev,len)=\",\n                                depth);\n    for (word=1; word <= trie->wordcount; word++) {\n        Perl_re_printf( aTHX_  \" %d:(%d,%d)\",\n\t    (int)word, (int)(trie->wordinfo[word].prev),\n\t    (int)(trie->wordinfo[word].len));\n    }\n    Perl_re_printf( aTHX_  \"\\n\" );\n}\n/*\n  Dumps a fully constructed but uncompressed trie in list form.\n  List tries normally only are used for construction when the number of\n  possible chars (trie->uniquecharcount) is very high.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST;\n\n    /* print out the table precompression.  */\n    Perl_re_indentf( aTHX_  \"State :Word | Transition Data\\n\",\n            depth+1 );\n    Perl_re_indentf( aTHX_  \"%s\",\n            depth+1, \"------:-----+-----------------\\n\" );\n\n    for( state=1 ; state < next_alloc ; state ++ ) {\n        U16 charid;\n\n        Perl_re_indentf( aTHX_  \" %4\" UVXf \" :\",\n            depth+1, (UV)state  );\n        if ( ! trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \"%5s| \",\"\");\n        } else {\n            Perl_re_printf( aTHX_  \"W%4x| \",\n                trie->states[ state ].wordnum\n            );\n        }\n        for( charid = 1 ; charid <= TRIE_LIST_USED( state ) ; charid++ ) {\n\t    SV ** const tmp = av_fetch( revcharmap,\n                                        TRIE_LIST_ITEM(state,charid).forid, 0);\n\t    if ( tmp ) {\n                Perl_re_printf( aTHX_  \"%*s:%3X=%4\" UVXf \" | \",\n                    colwidth,\n                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp),\n                              colwidth,\n                              PL_colors[0], PL_colors[1],\n                              (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)\n                              | PERL_PV_ESCAPE_FIRSTCHAR\n                    ) ,\n                    TRIE_LIST_ITEM(state,charid).forid,\n                    (UV)TRIE_LIST_ITEM(state,charid).newstate\n                );\n                if (!(charid % 10))\n                    Perl_re_printf( aTHX_  \"\\n%*s| \",\n                        (int)((depth * 2) + 14), \"\");\n            }\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    }\n}\n\n/*\n  Dumps a fully constructed but uncompressed trie in table form.\n  This is the normal DFA style state transition table, with a few\n  twists to facilitate compression later.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t  HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t  U32 depth)\n{\n    U32 state;\n    U16 charid;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE;\n\n    /*\n       print out the table precompression so that we can do a visual check\n       that they are identical.\n     */\n\n    Perl_re_indentf( aTHX_  \"Char : \", depth+1 );\n\n    for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, charid, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n\n    Perl_re_printf( aTHX_ \"\\n\");\n    Perl_re_indentf( aTHX_  \"State+-\", depth+1 );\n\n    for( charid=0 ; charid < trie->uniquecharcount ; charid++ ) {\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth,\"--------\");\n    }\n\n    Perl_re_printf( aTHX_  \"\\n\" );\n\n    for( state=1 ; state < next_alloc ; state += trie->uniquecharcount ) {\n\n        Perl_re_indentf( aTHX_  \"%4\" UVXf \" : \",\n            depth+1,\n            (UV)TRIE_NODENUM( state ) );\n\n        for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n            UV v=(UV)SAFE_TRIE_NODENUM( trie->trans[ state + charid ].next );\n            if (v)\n                Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth, v );\n            else\n                Perl_re_printf( aTHX_  \"%*s\", colwidth, \".\" );\n        }\n        if ( ! trie->states[ TRIE_NODENUM( state ) ].wordnum ) {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \")\\n\",\n                                            (UV)trie->trans[ state ].check );\n        } else {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \") W%4X\\n\",\n                                            (UV)trie->trans[ state ].check,\n            trie->states[ TRIE_NODENUM( state ) ].wordnum );\n        }\n    }\n}\n\n#endif\n\n\n/* make_trie(startbranch,first,last,tail,word_count,flags,depth)\n  startbranch: the first branch in the whole branch sequence\n  first      : start branch of sequence of branch-exact nodes.\n\t       May be the same as startbranch\n  last       : Thing following the last branch.\n\t       May be the same as tail.\n  tail       : item following the branch sequence\n  count      : words in the sequence\n  flags      : currently the OP() type we will be building one of /EXACT(|F|FA|FU|FU_SS|L|FLU8)/\n  depth      : indent depth\n\nInplace optimizes a sequence of 2 or more Branch-Exact nodes into a TRIE node.\n\nA trie is an N'ary tree where the branches are determined by digital\ndecomposition of the key. IE, at the root node you look up the 1st character and\nfollow that branch repeat until you find the end of the branches. Nodes can be\nmarked as \"accepting\" meaning they represent a complete word. Eg:\n\n  /he|she|his|hers/\n\nwould convert into the following structure. Numbers represent states, letters\nfollowing numbers represent valid transitions on the letter from that state, if\nthe number is in square brackets it represents an accepting state, otherwise it\nwill be in parenthesis.\n\n      +-h->+-e->[3]-+-r->(8)-+-s->[9]\n      |    |\n      |   (2)\n      |    |\n     (1)   +-i->(6)-+-s->[7]\n      |\n      +-s->(3)-+-h->(4)-+-e->[5]\n\n      Accept Word Mapping: 3=>1 (he),5=>2 (she), 7=>3 (his), 9=>4 (hers)\n\nThis shows that when matching against the string 'hers' we will begin at state 1\nread 'h' and move to state 2, read 'e' and move to state 3 which is accepting,\nthen read 'r' and go to state 8 followed by 's' which takes us to state 9 which\nis also accepting. Thus we know that we can match both 'he' and 'hers' with a\nsingle traverse. We store a mapping from accepting to state to which word was\nmatched, and then when we have multiple possibilities we try to complete the\nrest of the regex in the order in which they occurred in the alternation.\n\nThe only prior NFA like behaviour that would be changed by the TRIE support is\nthe silent ignoring of duplicate alternations which are of the form:\n\n / (DUPE|DUPE) X? (?{ ... }) Y /x\n\nThus EVAL blocks following a trie may be called a different number of times with\nand without the optimisation. With the optimisations dupes will be silently\nignored. This inconsistent behaviour of EVAL type nodes is well established as\nthe following demonstrates:\n\n 'words'=~/(word|word|word)(?{ print $1 })[xyz]/\n\nwhich prints out 'word' three times, but\n\n 'words'=~/(word|word|word)(?{ print $1 })S/\n\nwhich doesnt print it out at all. This is due to other optimisations kicking in.\n\nExample of what happens on a structural level:\n\nThe regexp /(ac|ad|ab)+/ will produce the following debug output:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   BRANCH(8)\n   6:     EXACT <ac>(16)\n   8:   BRANCH(11)\n   9:     EXACT <ad>(16)\n  11:   BRANCH(14)\n  12:     EXACT <ab>(16)\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nThis would be optimizable with startbranch=5, first=5, last=16, tail=16\nand should turn into:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   TRIE(16)\n\t[Words:3 Chars Stored:6 Unique Chars:4 States:5 NCP:1]\n\t  <ac>\n\t  <ad>\n\t  <ab>\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nCases where tail != last would be like /(?foo|bar)baz/:\n\n   1: BRANCH(4)\n   2:   EXACT <foo>(8)\n   4: BRANCH(7)\n   5:   EXACT <bar>(8)\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\nwhich would be optimizable with startbranch=1, first=1, last=7, tail=8\nand would end up looking like:\n\n    1: TRIE(8)\n      [Words:2 Chars Stored:6 Unique Chars:5 States:7 NCP:1]\n\t<foo>\n\t<bar>\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\n    d = uvchr_to_utf8_flags(d, uv, 0);\n\nis the recommended Unicode-aware way of saying\n\n    *(d++) = uv;\n*/\n\n#define TRIE_STORE_REVCHAR(val)                                            \\\n    STMT_START {                                                           \\\n\tif (UTF) {\t\t\t\t\t\t\t   \\\n            SV *zlopp = newSV(UTF8_MAXBYTES);\t\t\t\t   \\\n\t    unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp);\t   \\\n            unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, val); \\\n\t    SvCUR_set(zlopp, kapow - flrbbbbb);\t\t\t\t   \\\n\t    SvPOK_on(zlopp);\t\t\t\t\t\t   \\\n\t    SvUTF8_on(zlopp);\t\t\t\t\t\t   \\\n\t    av_push(revcharmap, zlopp);\t\t\t\t\t   \\\n\t} else {\t\t\t\t\t\t\t   \\\n            char ooooff = (char)val;                                           \\\n\t    av_push(revcharmap, newSVpvn(&ooooff, 1));\t\t\t   \\\n\t}\t\t\t\t\t\t\t\t   \\\n        } STMT_END\n\n/* This gets the next character from the input, folding it if not already\n * folded. */\n#define TRIE_READ_CHAR STMT_START {                                           \\\n    wordlen++;                                                                \\\n    if ( UTF ) {                                                              \\\n        /* if it is UTF then it is either already folded, or does not need    \\\n         * folding */                                                         \\\n        uvc = valid_utf8_to_uvchr( (const U8*) uc, &len);                     \\\n    }                                                                         \\\n    else if (folder == PL_fold_latin1) {                                      \\\n        /* This folder implies Unicode rules, which in the range expressible  \\\n         *  by not UTF is the lower case, with the two exceptions, one of     \\\n         *  which should have been taken care of before calling this */       \\\n        assert(*uc != LATIN_SMALL_LETTER_SHARP_S);                            \\\n        uvc = toLOWER_L1(*uc);                                                \\\n        if (UNLIKELY(uvc == MICRO_SIGN)) uvc = GREEK_SMALL_LETTER_MU;         \\\n        len = 1;                                                              \\\n    } else {                                                                  \\\n        /* raw data, will be folded later if needed */                        \\\n        uvc = (U32)*uc;                                                       \\\n        len = 1;                                                              \\\n    }                                                                         \\\n} STMT_END\n\n\n\n#define TRIE_LIST_PUSH(state,fid,ns) STMT_START {               \\\n    if ( TRIE_LIST_CUR( state ) >=TRIE_LIST_LEN( state ) ) {    \\\n\tU32 ging = TRIE_LIST_LEN( state ) * 2;                  \\\n\tRenew( trie->states[ state ].trans.list, ging, reg_trie_trans_le ); \\\n        TRIE_LIST_LEN( state ) = ging;                          \\\n    }                                                           \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).forid = fid;     \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).newstate = ns;   \\\n    TRIE_LIST_CUR( state )++;                                   \\\n} STMT_END\n\n#define TRIE_LIST_NEW(state) STMT_START {                       \\\n    Newx( trie->states[ state ].trans.list,                     \\\n\t4, reg_trie_trans_le );                                 \\\n     TRIE_LIST_CUR( state ) = 1;                                \\\n     TRIE_LIST_LEN( state ) = 4;                                \\\n} STMT_END\n\n#define TRIE_HANDLE_WORD(state) STMT_START {                    \\\n    U16 dupe= trie->states[ state ].wordnum;                    \\\n    regnode * const noper_next = regnext( noper );              \\\n                                                                \\\n    DEBUG_r({                                                   \\\n        /* store the word for dumping */                        \\\n        SV* tmp;                                                \\\n        if (OP(noper) != NOTHING)                               \\\n            tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), UTF);\t\\\n        else                                                    \\\n            tmp = newSVpvn_utf8( \"\", 0, UTF );\t\t\t\\\n        av_push( trie_words, tmp );                             \\\n    });                                                         \\\n                                                                \\\n    curword++;                                                  \\\n    trie->wordinfo[curword].prev   = 0;                         \\\n    trie->wordinfo[curword].len    = wordlen;                   \\\n    trie->wordinfo[curword].accept = state;                     \\\n                                                                \\\n    if ( noper_next < tail ) {                                  \\\n        if (!trie->jump)                                        \\\n            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, \\\n                                                 sizeof(U16) ); \\\n        trie->jump[curword] = (U16)(noper_next - convert);      \\\n        if (!jumper)                                            \\\n            jumper = noper_next;                                \\\n        if (!nextbranch)                                        \\\n            nextbranch= regnext(cur);                           \\\n    }                                                           \\\n                                                                \\\n    if ( dupe ) {                                               \\\n        /* It's a dupe. Pre-insert into the wordinfo[].prev   */\\\n        /* chain, so that when the bits of chain are later    */\\\n        /* linked together, the dups appear in the chain      */\\\n\ttrie->wordinfo[curword].prev = trie->wordinfo[dupe].prev; \\\n\ttrie->wordinfo[dupe].prev = curword;                    \\\n    } else {                                                    \\\n        /* we haven't inserted this word yet.                */ \\\n        trie->states[ state ].wordnum = curword;                \\\n    }                                                           \\\n} STMT_END\n\n\n#define TRIE_TRANS_STATE(state,base,ucharcount,charid,special)\t\t\\\n     ( ( base + charid >=  ucharcount\t\t\t\t\t\\\n         && base + charid < ubound\t\t\t\t\t\\\n         && state == trie->trans[ base - ucharcount + charid ].check\t\\\n         && trie->trans[ base - ucharcount + charid ].next )\t\t\\\n           ? trie->trans[ base - ucharcount + charid ].next\t\t\\\n           : ( state==1 ? special : 0 )\t\t\t\t\t\\\n      )\n\n#define TRIE_BITMAP_SET_FOLDED(trie, uvc, folder)           \\\nSTMT_START {                                                \\\n    TRIE_BITMAP_SET(trie, uvc);                             \\\n    /* store the folded codepoint */                        \\\n    if ( folder )                                           \\\n        TRIE_BITMAP_SET(trie, folder[(U8) uvc ]);           \\\n                                                            \\\n    if ( !UTF ) {                                           \\\n        /* store first byte of utf8 representation of */    \\\n        /* variant codepoints */                            \\\n        if (! UVCHR_IS_INVARIANT(uvc)) {                    \\\n            TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(uvc));   \\\n        }                                                   \\\n    }                                                       \\\n} STMT_END\n#define MADE_TRIE       1\n#define MADE_JUMP_TRIE  2\n#define MADE_EXACT_TRIE 4\n\nSTATIC I32\nS_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch,\n                  regnode *first, regnode *last, regnode *tail,\n                  U32 word_count, U32 flags, U32 depth)\n{\n    /* first pass, loop through and scan words */\n    reg_trie_data *trie;\n    HV *widecharmap = NULL;\n    AV *revcharmap = newAV();\n    regnode *cur;\n    STRLEN len = 0;\n    UV uvc = 0;\n    U16 curword = 0;\n    U32 next_alloc = 0;\n    regnode *jumper = NULL;\n    regnode *nextbranch = NULL;\n    regnode *convert = NULL;\n    U32 *prev_states; /* temp array mapping each state to previous one */\n    /* we just use folder as a flag in utf8 */\n    const U8 * folder = NULL;\n\n    /* in the below add_data call we are storing either 'tu' or 'tuaa'\n     * which stands for one trie structure, one hash, optionally followed\n     * by two arrays */\n#ifdef DEBUGGING\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tuaa\"));\n    AV *trie_words = NULL;\n    /* along with revcharmap, this only used during construction but both are\n     * useful during debugging so we store them in the struct when debugging.\n     */\n#else\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tu\"));\n    STRLEN trie_charcount=0;\n#endif\n    SV *re_trie_maxbuff;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_MAKE_TRIE;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    switch (flags) {\n        case EXACT: case EXACTL: break;\n\tcase EXACTFA:\n        case EXACTFU_SS:\n\tcase EXACTFU:\n\tcase EXACTFLU8: folder = PL_fold_latin1; break;\n\tcase EXACTF:  folder = PL_fold; break;\n        default: Perl_croak( aTHX_ \"panic! In trie construction, unknown node type %u %s\", (unsigned) flags, PL_reg_name[flags] );\n    }\n\n    trie = (reg_trie_data *) PerlMemShared_calloc( 1, sizeof(reg_trie_data) );\n    trie->refcount = 1;\n    trie->startstate = 1;\n    trie->wordcount = word_count;\n    RExC_rxi->data->data[ data_slot ] = (void*)trie;\n    trie->charmap = (U16 *) PerlMemShared_calloc( 256, sizeof(U16) );\n    if (flags == EXACT || flags == EXACTL)\n\ttrie->bitmap = (char *) PerlMemShared_calloc( ANYOF_BITMAP_SIZE, 1 );\n    trie->wordinfo = (reg_trie_wordinfo *) PerlMemShared_calloc(\n                       trie->wordcount+1, sizeof(reg_trie_wordinfo));\n\n    DEBUG_r({\n        trie_words = newAV();\n    });\n\n    re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n    assert(re_trie_maxbuff);\n    if (!SvIOK(re_trie_maxbuff)) {\n        sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n    }\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_\n          \"make_trie start==%d, first==%d, last==%d, tail==%d depth=%d\\n\",\n          depth+1,\n          REG_NODE_NUM(startbranch),REG_NODE_NUM(first),\n          REG_NODE_NUM(last), REG_NODE_NUM(tail), (int)depth);\n    });\n\n   /* Find the node we are going to overwrite */\n    if ( first == startbranch && OP( last ) != BRANCH ) {\n        /* whole branch chain */\n        convert = first;\n    } else {\n        /* branch sub-chain */\n        convert = NEXTOPER( first );\n    }\n\n    /*  -- First loop and Setup --\n\n       We first traverse the branches and scan each word to determine if it\n       contains widechars, and how many unique chars there are, this is\n       important as we have to build a table with at least as many columns as we\n       have unique chars.\n\n       We use an array of integers to represent the character codes 0..255\n       (trie->charmap) and we use a an HV* to store Unicode characters. We use\n       the native representation of the character value as the key and IV's for\n       the coded index.\n\n       *TODO* If we keep track of how many times each character is used we can\n       remap the columns so that the table compression later on is more\n       efficient in terms of memory by ensuring the most common value is in the\n       middle and the least common are on the outside.  IMO this would be better\n       than a most to least common mapping as theres a decent chance the most\n       common letter will share a node with the least common, meaning the node\n       will not be compressible. With a middle is most common approach the worst\n       case is when we have the least common nodes twice.\n\n     */\n\n    for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n        regnode *noper = NEXTOPER( cur );\n        const U8 *uc;\n        const U8 *e;\n        int foldlen = 0;\n        U32 wordlen      = 0;         /* required init */\n        STRLEN minchars = 0;\n        STRLEN maxchars = 0;\n        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the\n                                               bitmap?*/\n\n        if (OP(noper) == NOTHING) {\n            /* skip past a NOTHING at the start of an alternation\n             * eg, /(?:)a|(?:b)/ should be the same as /a|b/\n             */\n            regnode *noper_next= regnext(noper);\n            if (noper_next < tail)\n                noper= noper_next;\n        }\n\n        if ( noper < tail &&\n                (\n                    OP(noper) == flags ||\n                    (\n                        flags == EXACTFU &&\n                        OP(noper) == EXACTFU_SS\n                    )\n                )\n        ) {\n            uc= (U8*)STRING(noper);\n            e= uc + STR_LEN(noper);\n        } else {\n            trie->minlen= 0;\n            continue;\n        }\n\n\n        if ( set_bit ) { /* bitmap only alloced when !(UTF&&Folding) */\n            TRIE_BITMAP_SET(trie,*uc); /* store the raw first byte\n                                          regardless of encoding */\n            if (OP( noper ) == EXACTFU_SS) {\n                /* false positives are ok, so just set this */\n                TRIE_BITMAP_SET(trie, LATIN_SMALL_LETTER_SHARP_S);\n            }\n        }\n\n        for ( ; uc < e ; uc += len ) {  /* Look at each char in the current\n                                           branch */\n            TRIE_CHARCOUNT(trie)++;\n            TRIE_READ_CHAR;\n\n            /* TRIE_READ_CHAR returns the current character, or its fold if /i\n             * is in effect.  Under /i, this character can match itself, or\n             * anything that folds to it.  If not under /i, it can match just\n             * itself.  Most folds are 1-1, for example k, K, and KELVIN SIGN\n             * all fold to k, and all are single characters.   But some folds\n             * expand to more than one character, so for example LATIN SMALL\n             * LIGATURE FFI folds to the three character sequence 'ffi'.  If\n             * the string beginning at 'uc' is 'ffi', it could be matched by\n             * three characters, or just by the one ligature character. (It\n             * could also be matched by two characters: LATIN SMALL LIGATURE FF\n             * followed by 'i', or by 'f' followed by LATIN SMALL LIGATURE FI).\n             * (Of course 'I' and/or 'F' instead of 'i' and 'f' can also\n             * match.)  The trie needs to know the minimum and maximum number\n             * of characters that could match so that it can use size alone to\n             * quickly reject many match attempts.  The max is simple: it is\n             * the number of folded characters in this branch (since a fold is\n             * never shorter than what folds to it. */\n\n            maxchars++;\n\n            /* And the min is equal to the max if not under /i (indicated by\n             * 'folder' being NULL), or there are no multi-character folds.  If\n             * there is a multi-character fold, the min is incremented just\n             * once, for the character that folds to the sequence.  Each\n             * character in the sequence needs to be added to the list below of\n             * characters in the trie, but we count only the first towards the\n             * min number of characters needed.  This is done through the\n             * variable 'foldlen', which is returned by the macros that look\n             * for these sequences as the number of bytes the sequence\n             * occupies.  Each time through the loop, we decrement 'foldlen' by\n             * how many bytes the current char occupies.  Only when it reaches\n             * 0 do we increment 'minchars' or look for another multi-character\n             * sequence. */\n            if (folder == NULL) {\n                minchars++;\n            }\n            else if (foldlen > 0) {\n                foldlen -= (UTF) ? UTF8SKIP(uc) : 1;\n            }\n            else {\n                minchars++;\n\n                /* See if *uc is the beginning of a multi-character fold.  If\n                 * so, we decrement the length remaining to look at, to account\n                 * for the current character this iteration.  (We can use 'uc'\n                 * instead of the fold returned by TRIE_READ_CHAR because for\n                 * non-UTF, the latin1_safe macro is smart enough to account\n                 * for all the unfolded characters, and because for UTF, the\n                 * string will already have been folded earlier in the\n                 * compilation process */\n                if (UTF) {\n                    if ((foldlen = is_MULTI_CHAR_FOLD_utf8_safe(uc, e))) {\n                        foldlen -= UTF8SKIP(uc);\n                    }\n                }\n                else if ((foldlen = is_MULTI_CHAR_FOLD_latin1_safe(uc, e))) {\n                    foldlen--;\n                }\n            }\n\n            /* The current character (and any potential folds) should be added\n             * to the possible matching characters for this position in this\n             * branch */\n            if ( uvc < 256 ) {\n                if ( folder ) {\n                    U8 folded= folder[ (U8) uvc ];\n                    if ( !trie->charmap[ folded ] ) {\n                        trie->charmap[ folded ]=( ++trie->uniquecharcount );\n                        TRIE_STORE_REVCHAR( folded );\n                    }\n                }\n                if ( !trie->charmap[ uvc ] ) {\n                    trie->charmap[ uvc ]=( ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR( uvc );\n                }\n                if ( set_bit ) {\n\t\t    /* store the codepoint in the bitmap, and its folded\n\t\t     * equivalent. */\n                    TRIE_BITMAP_SET_FOLDED(trie, uvc, folder);\n                    set_bit = 0; /* We've done our bit :-) */\n                }\n            } else {\n\n                /* XXX We could come up with the list of code points that fold\n                 * to this using PL_utf8_foldclosures, except not for\n                 * multi-char folds, as there may be multiple combinations\n                 * there that could work, which needs to wait until runtime to\n                 * resolve (The comment about LIGATURE FFI above is such an\n                 * example */\n\n                SV** svpp;\n                if ( !widecharmap )\n                    widecharmap = newHV();\n\n                svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 1 );\n\n                if ( !svpp )\n                    Perl_croak( aTHX_ \"error creating/fetching widecharmap entry for 0x%\" UVXf, uvc );\n\n                if ( !SvTRUE( *svpp ) ) {\n                    sv_setiv( *svpp, ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR(uvc);\n                }\n            }\n        } /* end loop through characters in this branch of the trie */\n\n        /* We take the min and max for this branch and combine to find the min\n         * and max for all branches processed so far */\n        if( cur == first ) {\n            trie->minlen = minchars;\n            trie->maxlen = maxchars;\n        } else if (minchars < trie->minlen) {\n            trie->minlen = minchars;\n        } else if (maxchars > trie->maxlen) {\n            trie->maxlen = maxchars;\n        }\n    } /* end first pass */\n    DEBUG_TRIE_COMPILE_r(\n        Perl_re_indentf( aTHX_\n                \"TRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\\n\",\n                depth+1,\n                ( widecharmap ? \"UTF8\" : \"NATIVE\" ), (int)word_count,\n\t\t(int)TRIE_CHARCOUNT(trie), trie->uniquecharcount,\n\t\t(int)trie->minlen, (int)trie->maxlen )\n    );\n\n    /*\n        We now know what we are dealing with in terms of unique chars and\n        string sizes so we can calculate how much memory a naive\n        representation using a flat table  will take. If it's over a reasonable\n        limit (as specified by ${^RE_TRIE_MAXBUF}) we use a more memory\n        conservative but potentially much slower representation using an array\n        of lists.\n\n        At the end we convert both representations into the same compressed\n        form that will be used in regexec.c for matching with. The latter\n        is a form that cannot be used to construct with but has memory\n        properties similar to the list form and access properties similar\n        to the table form making it both suitable for fast searches and\n        small enough that its feasable to store for the duration of a program.\n\n        See the comment in the code where the compressed table is produced\n        inplace from the flat tabe representation for an explanation of how\n        the compression works.\n\n    */\n\n\n    Newx(prev_states, TRIE_CHARCOUNT(trie) + 2, U32);\n    prev_states[1] = 0;\n\n    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1)\n                                                    > SvIV(re_trie_maxbuff) )\n    {\n        /*\n            Second Pass -- Array Of Lists Representation\n\n            Each state will be represented by a list of charid:state records\n            (reg_trie_trans_le) the first such element holds the CUR and LEN\n            points of the allocated array. (See defines above).\n\n            We build the initial structure using the lists, and then convert\n            it into the compressed table form which allows faster lookups\n            (but cant be modified once converted).\n        */\n\n        STRLEN transcount = 1;\n\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using list compiler\\n\",\n            depth+1));\n\n\ttrie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        TRIE_LIST_NEW(1);\n        next_alloc = 2;\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\t    U32 state        = 1;         /* required init */\n\t    U16 charid       = 0;         /* sanity init */\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n            }\n\n            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n\t\t    } else {\n                        SV** const svpp = hv_fetch( widecharmap,\n                                                    (char*)&uvc,\n                                                    sizeof( UV ),\n                                                    0);\n                        if ( !svpp ) {\n                            charid = 0;\n                        } else {\n                            charid=(U16)SvIV( *svpp );\n                        }\n\t\t    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                    if ( charid ) {\n\n                        U16 check;\n                        U32 newstate = 0;\n\n                        charid--;\n                        if ( !trie->states[ state ].trans.list ) {\n                            TRIE_LIST_NEW( state );\n\t\t\t}\n                        for ( check = 1;\n                              check <= TRIE_LIST_USED( state );\n                              check++ )\n                        {\n                            if ( TRIE_LIST_ITEM( state, check ).forid\n                                                                    == charid )\n                            {\n                                newstate = TRIE_LIST_ITEM( state, check ).newstate;\n                                break;\n                            }\n                        }\n                        if ( ! newstate ) {\n                            newstate = next_alloc++;\n\t\t\t    prev_states[newstate] = state;\n                            TRIE_LIST_PUSH( state, charid, newstate );\n                            transcount++;\n                        }\n                        state = newstate;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n\t\t    }\n\t\t}\n\t    }\n            TRIE_HANDLE_WORD(state);\n\n        } /* end second pass */\n\n        /* next alloc is the NEXT state to be allocated */\n        trie->statecount = next_alloc;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states,\n\t\t\t\t   next_alloc\n\t\t\t\t   * sizeof(reg_trie_state) );\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_list(trie, widecharmap,\n\t\t\t\t\t\t\t revcharmap, next_alloc,\n\t\t\t\t\t\t\t depth+1)\n        );\n\n        trie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( transcount, sizeof(reg_trie_trans) );\n        {\n            U32 state;\n            U32 tp = 0;\n            U32 zp = 0;\n\n\n            for( state=1 ; state < next_alloc ; state ++ ) {\n                U32 base=0;\n\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \"tp: %d zp: %d \",tp,zp)\n                );\n                */\n\n                if (trie->states[state].trans.list) {\n                    U16 minid=TRIE_LIST_ITEM( state, 1).forid;\n                    U16 maxid=minid;\n\t\t    U16 idx;\n\n                    for( idx = 2 ; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n\t\t\tconst U16 forid = TRIE_LIST_ITEM( state, idx).forid;\n\t\t\tif ( forid < minid ) {\n\t\t\t    minid=forid;\n\t\t\t} else if ( forid > maxid ) {\n\t\t\t    maxid=forid;\n\t\t\t}\n                    }\n                    if ( transcount < tp + maxid - minid + 1) {\n                        transcount *= 2;\n\t\t\ttrie->trans = (reg_trie_trans *)\n\t\t\t    PerlMemShared_realloc( trie->trans,\n\t\t\t\t\t\t     transcount\n\t\t\t\t\t\t     * sizeof(reg_trie_trans) );\n                        Zero( trie->trans + (transcount / 2),\n                              transcount / 2,\n                              reg_trie_trans );\n                    }\n                    base = trie->uniquecharcount + tp - minid;\n                    if ( maxid == minid ) {\n                        U32 set = 0;\n                        for ( ; zp < tp ; zp++ ) {\n                            if ( ! trie->trans[ zp ].next ) {\n                                base = trie->uniquecharcount + zp - minid;\n                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                                trie->trans[ zp ].check = state;\n                                set = 1;\n                                break;\n                            }\n                        }\n                        if ( !set ) {\n                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                            trie->trans[ tp ].check = state;\n                            tp++;\n                            zp = tp;\n                        }\n                    } else {\n                        for ( idx=1; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n                            const U32 tid = base\n                                           - trie->uniquecharcount\n                                           + TRIE_LIST_ITEM( state, idx ).forid;\n                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state,\n                                                                idx ).newstate;\n                            trie->trans[ tid ].check = state;\n                        }\n                        tp += ( maxid - minid + 1 );\n                    }\n                    Safefree(trie->states[ state ].trans.list);\n                }\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \" base: %d\\n\",base);\n                );\n                */\n                trie->states[ state ].trans.base=base;\n            }\n            trie->lasttrans = tp + 1;\n        }\n    } else {\n        /*\n           Second Pass -- Flat Table Representation.\n\n           we dont use the 0 slot of either trans[] or states[] so we add 1 to\n           each.  We know that we will need Charcount+1 trans at most to store\n           the data (one row per char at worst case) So we preallocate both\n           structures assuming worst case.\n\n           We then construct the trie using only the .next slots of the entry\n           structs.\n\n           We use the .check field of the first entry of the node temporarily\n           to make compression both faster and easier by keeping track of how\n           many non zero fields are in the node.\n\n           Since trans are numbered from 1 any 0 pointer in the table is a FAIL\n           transition.\n\n           There are two terms at use here: state as a TRIE_NODEIDX() which is\n           a number representing the first entry of the node, and state as a\n           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1)\n           and TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3)\n           if there are 2 entrys per node. eg:\n\n             A B       A B\n          1. 2 4    1. 3 7\n          2. 0 3    3. 0 5\n          3. 0 0    5. 0 0\n          4. 0 0    7. 0 0\n\n           The table is internally in the right hand, idx form. However as we\n           also have to deal with the states array which is indexed by nodenum\n           we have to use TRIE_NODENUM() to convert.\n\n        */\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using table compiler\\n\",\n            depth+1));\n\n\ttrie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( ( TRIE_CHARCOUNT(trie) + 1 )\n\t\t\t\t  * trie->uniquecharcount + 1,\n\t\t\t\t  sizeof(reg_trie_trans) );\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        next_alloc = trie->uniquecharcount + 1;\n\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\n            U32 state        = 1;         /* required init */\n\n            U16 charid       = 0;         /* sanity init */\n            U32 accept_state = 0;         /* sanity init */\n\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n            }\n\n            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n                    } else {\n                        SV* const * const svpp = hv_fetch( widecharmap,\n                                                           (char*)&uvc,\n                                                           sizeof( UV ),\n                                                           0);\n                        charid = svpp ? (U16)SvIV(*svpp) : 0;\n                    }\n                    if ( charid ) {\n                        charid--;\n                        if ( !trie->trans[ state + charid ].next ) {\n                            trie->trans[ state + charid ].next = next_alloc;\n                            trie->trans[ state ].check++;\n\t\t\t    prev_states[TRIE_NODENUM(next_alloc)]\n\t\t\t\t    = TRIE_NODENUM(state);\n                            next_alloc += trie->uniquecharcount;\n                        }\n                        state = trie->trans[ state + charid ].next;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n                    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                }\n            }\n            accept_state = TRIE_NODENUM( state );\n            TRIE_HANDLE_WORD(accept_state);\n\n        } /* end second pass */\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_table(trie, widecharmap,\n\t\t\t\t\t\t\t  revcharmap,\n\t\t\t\t\t\t\t  next_alloc, depth+1));\n\n        {\n        /*\n           * Inplace compress the table.*\n\n           For sparse data sets the table constructed by the trie algorithm will\n           be mostly 0/FAIL transitions or to put it another way mostly empty.\n           (Note that leaf nodes will not contain any transitions.)\n\n           This algorithm compresses the tables by eliminating most such\n           transitions, at the cost of a modest bit of extra work during lookup:\n\n           - Each states[] entry contains a .base field which indicates the\n           index in the state[] array wheres its transition data is stored.\n\n           - If .base is 0 there are no valid transitions from that node.\n\n           - If .base is nonzero then charid is added to it to find an entry in\n           the trans array.\n\n           -If trans[states[state].base+charid].check!=state then the\n           transition is taken to be a 0/Fail transition. Thus if there are fail\n           transitions at the front of the node then the .base offset will point\n           somewhere inside the previous nodes data (or maybe even into a node\n           even earlier), but the .check field determines if the transition is\n           valid.\n\n           XXX - wrong maybe?\n           The following process inplace converts the table to the compressed\n           table: We first do not compress the root node 1,and mark all its\n           .check pointers as 1 and set its .base pointer as 1 as well. This\n           allows us to do a DFA construction from the compressed table later,\n           and ensures that any .base pointers we calculate later are greater\n           than 0.\n\n           - We set 'pos' to indicate the first entry of the second node.\n\n           - We then iterate over the columns of the node, finding the first and\n           last used entry at l and m. We then copy l..m into pos..(pos+m-l),\n           and set the .check pointers accordingly, and advance pos\n           appropriately and repreat for the next node. Note that when we copy\n           the next pointers we have to convert them from the original\n           NODEIDX form to NODENUM form as the former is not valid post\n           compression.\n\n           - If a node has no transitions used we mark its base as 0 and do not\n           advance the pos pointer.\n\n           - If a node only has one transition we use a second pointer into the\n           structure to fill in allocated fail transitions from other states.\n           This pointer is independent of the main pointer and scans forward\n           looking for null transitions that are allocated to a state. When it\n           finds one it writes the single transition into the \"hole\".  If the\n           pointer doesnt find one the single transition is appended as normal.\n\n           - Once compressed we can Renew/realloc the structures to release the\n           excess space.\n\n           See \"Table-Compression Methods\" in sec 3.9 of the Red Dragon,\n           specifically Fig 3.47 and the associated pseudocode.\n\n           demq\n        */\n        const U32 laststate = TRIE_NODENUM( next_alloc );\n\tU32 state, charid;\n        U32 pos = 0, zp=0;\n        trie->statecount = laststate;\n\n        for ( state = 1 ; state < laststate ; state++ ) {\n            U8 flag = 0;\n\t    const U32 stateidx = TRIE_NODEIDX( state );\n\t    const U32 o_used = trie->trans[ stateidx ].check;\n\t    U32 used = trie->trans[ stateidx ].check;\n            trie->trans[ stateidx ].check = 0;\n\n            for ( charid = 0;\n                  used && charid < trie->uniquecharcount;\n                  charid++ )\n            {\n                if ( flag || trie->trans[ stateidx + charid ].next ) {\n                    if ( trie->trans[ stateidx + charid ].next ) {\n                        if (o_used == 1) {\n                            for ( ; zp < pos ; zp++ ) {\n                                if ( ! trie->trans[ zp ].next ) {\n                                    break;\n                                }\n                            }\n                            trie->states[ state ].trans.base\n                                                    = zp\n                                                      + trie->uniquecharcount\n                                                      - charid ;\n                            trie->trans[ zp ].next\n                                = SAFE_TRIE_NODENUM( trie->trans[ stateidx\n                                                             + charid ].next );\n                            trie->trans[ zp ].check = state;\n                            if ( ++zp > pos ) pos = zp;\n                            break;\n                        }\n                        used--;\n                    }\n                    if ( !flag ) {\n                        flag = 1;\n                        trie->states[ state ].trans.base\n                                       = pos + trie->uniquecharcount - charid ;\n                    }\n                    trie->trans[ pos ].next\n                        = SAFE_TRIE_NODENUM(\n                                       trie->trans[ stateidx + charid ].next );\n                    trie->trans[ pos ].check = state;\n                    pos++;\n                }\n            }\n        }\n        trie->lasttrans = pos + 1;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states, laststate\n\t\t\t\t   * sizeof(reg_trie_state) );\n        DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Alloc: %d Orig: %\" IVdf \" elements, Final:%\" IVdf \". Savings of %%%5.2f\\n\",\n                depth+1,\n                (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount\n                       + 1 ),\n                (IV)next_alloc,\n                (IV)pos,\n                ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );\n            );\n\n        } /* end table compress */\n    }\n    DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Statecount:%\" UVxf \" Lasttrans:%\" UVxf \"\\n\",\n                depth+1,\n                (UV)trie->statecount,\n                (UV)trie->lasttrans)\n    );\n    /* resize the trans array to remove unused space */\n    trie->trans = (reg_trie_trans *)\n\tPerlMemShared_realloc( trie->trans, trie->lasttrans\n\t\t\t       * sizeof(reg_trie_trans) );\n\n    {   /* Modify the program and insert the new TRIE node */\n        U8 nodetype =(U8)(flags & 0xFF);\n        char *str=NULL;\n\n#ifdef DEBUGGING\n        regnode *optimize = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n\n        U32 mjd_offset = 0;\n        U32 mjd_nodelen = 0;\n#endif /* RE_TRACK_PATTERN_OFFSETS */\n#endif /* DEBUGGING */\n        /*\n           This means we convert either the first branch or the first Exact,\n           depending on whether the thing following (in 'last') is a branch\n           or not and whther first is the startbranch (ie is it a sub part of\n           the alternation or is it the whole thing.)\n           Assuming its a sub part we convert the EXACT otherwise we convert\n           the whole branch sequence, including the first.\n         */\n        /* Find the node we are going to overwrite */\n        if ( first != startbranch || OP( last ) == BRANCH ) {\n            /* branch sub-chain */\n            NEXT_OFF( first ) = (U16)(last - first);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n            DEBUG_r({\n                mjd_offset= Node_Offset((convert));\n                mjd_nodelen= Node_Length((convert));\n            });\n#endif\n            /* whole branch chain */\n        }\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        else {\n            DEBUG_r({\n                const  regnode *nop = NEXTOPER( convert );\n                mjd_offset= Node_Offset((nop));\n                mjd_nodelen= Node_Length((nop));\n            });\n        }\n        DEBUG_OPTIMISE_r(\n            Perl_re_indentf( aTHX_  \"MJD offset:%\" UVuf \" MJD length:%\" UVuf \"\\n\",\n                depth+1,\n                (UV)mjd_offset, (UV)mjd_nodelen)\n        );\n#endif\n        /* But first we check to see if there is a common prefix we can\n           split out as an EXACT and put in front of the TRIE node.  */\n        trie->startstate= 1;\n        if ( trie->bitmap && !widecharmap && !trie->jump  ) {\n            /* we want to find the first state that has more than\n             * one transition, if that state is not the first state\n             * then we have a common prefix which we can remove.\n             */\n            U32 state;\n            for ( state = 1 ; state < trie->statecount-1 ; state++ ) {\n                U32 ofs = 0;\n                I32 first_ofs = -1; /* keeps track of the ofs of the first\n                                       transition, -1 means none */\n                U32 count = 0;\n                const U32 base = trie->states[ state ].trans.base;\n\n                /* does this state terminate an alternation? */\n                if ( trie->states[state].wordnum )\n                        count = 1;\n\n                for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                    if ( ( base + ofs >= trie->uniquecharcount ) &&\n                         ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&\n                         trie->trans[ base + ofs - trie->uniquecharcount ].check == state )\n                    {\n                        if ( ++count > 1 ) {\n                            /* we have more than one transition */\n                            SV **tmp;\n                            U8 *ch;\n                            /* if this is the first state there is no common prefix\n                             * to extract, so we can exit */\n                            if ( state == 1 ) break;\n                            tmp = av_fetch( revcharmap, ofs, 0);\n                            ch = (U8*)SvPV_nolen_const( *tmp );\n\n                            /* if we are on count 2 then we need to initialize the\n                             * bitmap, and store the previous char if there was one\n                             * in it*/\n                            if ( count == 2 ) {\n                                /* clear the bitmap */\n                                Zero(trie->bitmap, ANYOF_BITMAP_SIZE, char);\n                                DEBUG_OPTIMISE_r(\n                                    Perl_re_indentf( aTHX_  \"New Start State=%\" UVuf \" Class: [\",\n                                        depth+1,\n                                        (UV)state));\n                                if (first_ofs >= 0) {\n                                    SV ** const tmp = av_fetch( revcharmap, first_ofs, 0);\n\t\t\t\t    const U8 * const ch = (U8*)SvPV_nolen_const( *tmp );\n\n                                    TRIE_BITMAP_SET_FOLDED(trie,*ch,folder);\n                                    DEBUG_OPTIMISE_r(\n                                        Perl_re_printf( aTHX_  \"%s\", (char*)ch)\n                                    );\n\t\t\t\t}\n\t\t\t    }\n                            /* store the current firstchar in the bitmap */\n                            TRIE_BITMAP_SET_FOLDED(trie,*ch,folder);\n                            DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"%s\", ch));\n\t\t\t}\n                        first_ofs = ofs;\n\t\t    }\n                }\n                if ( count == 1 ) {\n                    /* This state has only one transition, its transition is part\n                     * of a common prefix - we need to concatenate the char it\n                     * represents to what we have so far. */\n                    SV **tmp = av_fetch( revcharmap, first_ofs, 0);\n                    STRLEN len;\n                    char *ch = SvPV( *tmp, len );\n                    DEBUG_OPTIMISE_r({\n                        SV *sv=sv_newmortal();\n                        Perl_re_indentf( aTHX_  \"Prefix State: %\" UVuf \" Ofs:%\" UVuf \" Char='%s'\\n\",\n                            depth+1,\n                            (UV)state, (UV)first_ofs,\n                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6,\n\t                        PL_colors[0], PL_colors[1],\n\t                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                        PERL_PV_ESCAPE_FIRSTCHAR\n                            )\n                        );\n                    });\n                    if ( state==1 ) {\n                        OP( convert ) = nodetype;\n                        str=STRING(convert);\n                        STR_LEN(convert)=0;\n                    }\n                    STR_LEN(convert) += len;\n                    while (len--)\n                        *str++ = *ch++;\n\t\t} else {\n#ifdef DEBUGGING\n\t\t    if (state>1)\n                        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"]\\n\"));\n#endif\n\t\t    break;\n\t\t}\n\t    }\n\t    trie->prefixlen = (state-1);\n            if (str) {\n                regnode *n = convert+NODE_SZ_STR(convert);\n                NEXT_OFF(convert) = NODE_SZ_STR(convert);\n                trie->startstate = state;\n                trie->minlen -= (state - 1);\n                trie->maxlen -= (state - 1);\n#ifdef DEBUGGING\n               /* At least the UNICOS C compiler choked on this\n                * being argument to DEBUG_r(), so let's just have\n                * it right here. */\n               if (\n#ifdef PERL_EXT_RE_BUILD\n                   1\n#else\n                   DEBUG_r_TEST\n#endif\n                   ) {\n                   regnode *fix = convert;\n                   U32 word = trie->wordcount;\n                   mjd_nodelen++;\n                   Set_Node_Offset_Length(convert, mjd_offset, state - 1);\n                   while( ++fix < n ) {\n                       Set_Node_Offset_Length(fix, 0, 0);\n                   }\n                   while (word--) {\n                       SV ** const tmp = av_fetch( trie_words, word, 0 );\n                       if (tmp) {\n                           if ( STR_LEN(convert) <= SvCUR(*tmp) )\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + STR_LEN(convert));\n                           else\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + SvCUR(*tmp));\n                       }\n                   }\n               }\n#endif\n                if (trie->maxlen) {\n                    convert = n;\n\t\t} else {\n                    NEXT_OFF(convert) = (U16)(tail - convert);\n                    DEBUG_r(optimize= n);\n                }\n            }\n        }\n        if (!jumper)\n            jumper = last;\n        if ( trie->maxlen ) {\n\t    NEXT_OFF( convert ) = (U16)(tail - convert);\n\t    ARG_SET( convert, data_slot );\n\t    /* Store the offset to the first unabsorbed branch in\n\t       jump[0], which is otherwise unused by the jump logic.\n\t       We use this when dumping a trie and during optimisation. */\n\t    if (trie->jump)\n\t        trie->jump[0] = (U16)(nextbranch - convert);\n\n            /* If the start state is not accepting (meaning there is no empty string/NOTHING)\n\t     *   and there is a bitmap\n\t     *   and the first \"jump target\" node we found leaves enough room\n\t     * then convert the TRIE node into a TRIEC node, with the bitmap\n\t     * embedded inline in the opcode - this is hypothetically faster.\n\t     */\n            if ( !trie->states[trie->startstate].wordnum\n\t\t && trie->bitmap\n\t\t && ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )\n            {\n                OP( convert ) = TRIEC;\n                Copy(trie->bitmap, ((struct regnode_charclass *)convert)->bitmap, ANYOF_BITMAP_SIZE, char);\n                PerlMemShared_free(trie->bitmap);\n                trie->bitmap= NULL;\n            } else\n                OP( convert ) = TRIE;\n\n            /* store the type in the flags */\n            convert->flags = nodetype;\n            DEBUG_r({\n            optimize = convert\n                      + NODE_STEP_REGNODE\n                      + regarglen[ OP( convert ) ];\n            });\n            /* XXX We really should free up the resource in trie now,\n                   as we won't use them - (which resources?) dmq */\n        }\n        /* needed for dumping*/\n        DEBUG_r(if (optimize) {\n            regnode *opt = convert;\n\n            while ( ++opt < optimize) {\n                Set_Node_Offset_Length(opt,0,0);\n            }\n            /*\n                Try to clean up some of the debris left after the\n                optimisation.\n             */\n            while( optimize < jumper ) {\n                mjd_nodelen += Node_Length((optimize));\n                OP( optimize ) = OPTIMIZED;\n                Set_Node_Offset_Length(optimize,0,0);\n                optimize++;\n            }\n            Set_Node_Offset_Length(convert,mjd_offset,mjd_nodelen);\n        });\n    } /* end node insert */\n\n    /*  Finish populating the prev field of the wordinfo array.  Walk back\n     *  from each accept state until we find another accept state, and if\n     *  so, point the first word's .prev field at the second word. If the\n     *  second already has a .prev field set, stop now. This will be the\n     *  case either if we've already processed that word's accept state,\n     *  or that state had multiple words, and the overspill words were\n     *  already linked up earlier.\n     */\n    {\n\tU16 word;\n\tU32 state;\n\tU16 prev;\n\n\tfor (word=1; word <= trie->wordcount; word++) {\n\t    prev = 0;\n\t    if (trie->wordinfo[word].prev)\n\t\tcontinue;\n\t    state = trie->wordinfo[word].accept;\n\t    while (state) {\n\t\tstate = prev_states[state];\n\t\tif (!state)\n\t\t    break;\n\t\tprev = trie->states[state].wordnum;\n\t\tif (prev)\n\t\t    break;\n\t    }\n\t    trie->wordinfo[word].prev = prev;\n\t}\n\tSafefree(prev_states);\n    }\n\n\n    /* and now dump out the compressed format */\n    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));\n\n    RExC_rxi->data->data[ data_slot + 1 ] = (void*)widecharmap;\n#ifdef DEBUGGING\n    RExC_rxi->data->data[ data_slot + TRIE_WORDS_OFFSET ] = (void*)trie_words;\n    RExC_rxi->data->data[ data_slot + 3 ] = (void*)revcharmap;\n#else\n    SvREFCNT_dec_NN(revcharmap);\n#endif\n    return trie->jump\n           ? MADE_JUMP_TRIE\n           : trie->startstate>1\n             ? MADE_EXACT_TRIE\n             : MADE_TRIE;\n}\n\nSTATIC regnode *\nS_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth)\n{\n/* The Trie is constructed and compressed now so we can build a fail array if\n * it's needed\n\n   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and\n   3.32 in the\n   \"Red Dragon\" -- Compilers, principles, techniques, and tools. Aho, Sethi,\n   Ullman 1985/88\n   ISBN 0-201-10088-6\n\n   We find the fail state for each state in the trie, this state is the longest\n   proper suffix of the current state's 'word' that is also a proper prefix of\n   another word in our trie. State 1 represents the word '' and is thus the\n   default fail state. This allows the DFA not to have to restart after its\n   tried and failed a word at a given point, it simply continues as though it\n   had been matching the other word in the first place.\n   Consider\n      'abcdgu'=~/abcdefg|cdgu/\n   When we get to 'd' we are still matching the first word, we would encounter\n   'g' which would fail, which would bring us to the state representing 'd' in\n   the second word where we would try 'g' and succeed, proceeding to match\n   'cdgu'.\n */\n /* add a fail transition */\n    const U32 trie_offset = ARG(source);\n    reg_trie_data *trie=(reg_trie_data *)RExC_rxi->data->data[trie_offset];\n    U32 *q;\n    const U32 ucharcount = trie->uniquecharcount;\n    const U32 numstates = trie->statecount;\n    const U32 ubound = trie->lasttrans + ucharcount;\n    U32 q_read = 0;\n    U32 q_write = 0;\n    U32 charid;\n    U32 base = trie->states[ 1 ].trans.base;\n    U32 *fail;\n    reg_ac_data *aho;\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"T\"));\n    regnode *stclass;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE;\n    PERL_UNUSED_CONTEXT;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    if ( OP(source) == TRIE ) {\n        struct regnode_1 *op = (struct regnode_1 *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_1));\n        StructCopy(source,op,struct regnode_1);\n        stclass = (regnode *)op;\n    } else {\n        struct regnode_charclass *op = (struct regnode_charclass *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_charclass));\n        StructCopy(source,op,struct regnode_charclass);\n        stclass = (regnode *)op;\n    }\n    OP(stclass)+=2; /* convert the TRIE type to its AHO-CORASICK equivalent */\n\n    ARG_SET( stclass, data_slot );\n    aho = (reg_ac_data *) PerlMemShared_calloc( 1, sizeof(reg_ac_data) );\n    RExC_rxi->data->data[ data_slot ] = (void*)aho;\n    aho->trie=trie_offset;\n    aho->states=(reg_trie_state *)PerlMemShared_malloc( numstates * sizeof(reg_trie_state) );\n    Copy( trie->states, aho->states, numstates, reg_trie_state );\n    Newx( q, numstates, U32);\n    aho->fail = (U32 *) PerlMemShared_calloc( numstates, sizeof(U32) );\n    aho->refcount = 1;\n    fail = aho->fail;\n    /* initialize fail[0..1] to be 1 so that we always have\n       a valid final fail state */\n    fail[ 0 ] = fail[ 1 ] = 1;\n\n    for ( charid = 0; charid < ucharcount ; charid++ ) {\n\tconst U32 newstate = TRIE_TRANS_STATE( 1, base, ucharcount, charid, 0 );\n\tif ( newstate ) {\n            q[ q_write ] = newstate;\n            /* set to point at the root */\n            fail[ q[ q_write++ ] ]=1;\n        }\n    }\n    while ( q_read < q_write) {\n\tconst U32 cur = q[ q_read++ % numstates ];\n        base = trie->states[ cur ].trans.base;\n\n        for ( charid = 0 ; charid < ucharcount ; charid++ ) {\n\t    const U32 ch_state = TRIE_TRANS_STATE( cur, base, ucharcount, charid, 1 );\n\t    if (ch_state) {\n                U32 fail_state = cur;\n                U32 fail_base;\n                do {\n                    fail_state = fail[ fail_state ];\n                    fail_base = aho->states[ fail_state ].trans.base;\n                } while ( !TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 ) );\n\n                fail_state = TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 );\n                fail[ ch_state ] = fail_state;\n                if ( !aho->states[ ch_state ].wordnum && aho->states[ fail_state ].wordnum )\n                {\n                        aho->states[ ch_state ].wordnum =  aho->states[ fail_state ].wordnum;\n                }\n                q[ q_write++ % numstates] = ch_state;\n            }\n        }\n    }\n    /* restore fail[0..1] to 0 so that we \"fall out\" of the AC loop\n       when we fail in state 1, this allows us to use the\n       charclass scan to find a valid start char. This is based on the principle\n       that theres a good chance the string being searched contains lots of stuff\n       that cant be a start char.\n     */\n    fail[ 0 ] = fail[ 1 ] = 0;\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_  \"Stclass Failtable (%\" UVuf \" states): 0\",\n                      depth, (UV)numstates\n        );\n        for( q_read=1; q_read<numstates; q_read++ ) {\n            Perl_re_printf( aTHX_  \", %\" UVuf, (UV)fail[q_read]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n    Safefree(q);\n    /*RExC_seen |= REG_TRIEDFA_SEEN;*/\n    return stclass;\n}\n\n\n/* The below joins as many adjacent EXACTish nodes as possible into a single\n * one.  The regop may be changed if the node(s) contain certain sequences that\n * require special handling.  The joining is only done if:\n * 1) there is room in the current conglomerated node to entirely contain the\n *    next one.\n * 2) they are the exact same node type\n *\n * The adjacent nodes actually may be separated by NOTHING-kind nodes, and\n * these get optimized out\n *\n * XXX khw thinks this should be enhanced to fill EXACT (at least) nodes as full\n * as possible, even if that means splitting an existing node so that its first\n * part is moved to the preceeding node.  This would maximise the efficiency of\n * memEQ during matching.  Elsewhere in this file, khw proposes splitting\n * EXACTFish nodes into portions that don't change under folding vs those that\n * do.  Those portions that don't change may be the only things in the pattern that\n * could be used to find fixed and floating strings.\n *\n * If a node is to match under /i (folded), the number of characters it matches\n * can be different than its character length if it contains a multi-character\n * fold.  *min_subtract is set to the total delta number of characters of the\n * input nodes.\n *\n * And *unfolded_multi_char is set to indicate whether or not the node contains\n * an unfolded multi-char fold.  This happens when whether the fold is valid or\n * not won't be known until runtime; namely for EXACTF nodes that contain LATIN\n * SMALL LETTER SHARP S, as only if the target string being matched against\n * turns out to be UTF-8 is that fold valid; and also for EXACTFL nodes whose\n * folding rules depend on the locale in force at runtime.  (Multi-char folds\n * whose components are all above the Latin1 range are not run-time locale\n * dependent, and have already been folded by the time this function is\n * called.)\n *\n * This is as good a place as any to discuss the design of handling these\n * multi-character fold sequences.  It's been wrong in Perl for a very long\n * time.  There are three code points in Unicode whose multi-character folds\n * were long ago discovered to mess things up.  The previous designs for\n * dealing with these involved assigning a special node for them.  This\n * approach doesn't always work, as evidenced by this example:\n *      \"\\xDFs\" =~ /s\\xDF/ui    # Used to fail before these patches\n * Both sides fold to \"sss\", but if the pattern is parsed to create a node that\n * would match just the \\xDF, it won't be able to handle the case where a\n * successful match would have to cross the node's boundary.  The new approach\n * that hopefully generally solves the problem generates an EXACTFU_SS node\n * that is \"sss\" in this case.\n *\n * It turns out that there are problems with all multi-character folds, and not\n * just these three.  Now the code is general, for all such cases.  The\n * approach taken is:\n * 1)   This routine examines each EXACTFish node that could contain multi-\n *      character folded sequences.  Since a single character can fold into\n *      such a sequence, the minimum match length for this node is less than\n *      the number of characters in the node.  This routine returns in\n *      *min_subtract how many characters to subtract from the the actual\n *      length of the string to get a real minimum match length; it is 0 if\n *      there are no multi-char foldeds.  This delta is used by the caller to\n *      adjust the min length of the match, and the delta between min and max,\n *      so that the optimizer doesn't reject these possibilities based on size\n *      constraints.\n * 2)   For the sequence involving the Sharp s (\\xDF), the node type EXACTFU_SS\n *      is used for an EXACTFU node that contains at least one \"ss\" sequence in\n *      it.  For non-UTF-8 patterns and strings, this is the only case where\n *      there is a possible fold length change.  That means that a regular\n *      EXACTFU node without UTF-8 involvement doesn't have to concern itself\n *      with length changes, and so can be processed faster.  regexec.c takes\n *      advantage of this.  Generally, an EXACTFish node that is in UTF-8 is\n *      pre-folded by regcomp.c (except EXACTFL, some of whose folds aren't\n *      known until runtime).  This saves effort in regex matching.  However,\n *      the pre-folding isn't done for non-UTF8 patterns because the fold of\n *      the MICRO SIGN requires UTF-8, and we don't want to slow things down by\n *      forcing the pattern into UTF8 unless necessary.  Also what EXACTF (and,\n *      again, EXACTFL) nodes fold to isn't known until runtime.  The fold\n *      possibilities for the non-UTF8 patterns are quite simple, except for\n *      the sharp s.  All the ones that don't involve a UTF-8 target string are\n *      members of a fold-pair, and arrays are set up for all of them so that\n *      the other member of the pair can be found quickly.  Code elsewhere in\n *      this file makes sure that in EXACTFU nodes, the sharp s gets folded to\n *      'ss', even if the pattern isn't UTF-8.  This avoids the issues\n *      described in the next item.\n * 3)   A problem remains for unfolded multi-char folds. (These occur when the\n *      validity of the fold won't be known until runtime, and so must remain\n *      unfolded for now.  This happens for the sharp s in EXACTF and EXACTFA\n *      nodes when the pattern isn't in UTF-8.  (Note, BTW, that there cannot\n *      be an EXACTF node with a UTF-8 pattern.)  They also occur for various\n *      folds in EXACTFL nodes, regardless of the UTF-ness of the pattern.)\n *      The reason this is a problem is that the optimizer part of regexec.c\n *      (probably unwittingly, in Perl_regexec_flags()) makes an assumption\n *      that a character in the pattern corresponds to at most a single\n *      character in the target string.  (And I do mean character, and not byte\n *      here, unlike other parts of the documentation that have never been\n *      updated to account for multibyte Unicode.)  sharp s in EXACTF and\n *      EXACTFL nodes can match the two character string 'ss'; in EXACTFA nodes\n *      it can match \"\\x{17F}\\x{17F}\".  These, along with other ones in EXACTFL\n *      nodes, violate the assumption, and they are the only instances where it\n *      is violated.  I'm reluctant to try to change the assumption, as the\n *      code involved is impenetrable to me (khw), so instead the code here\n *      punts.  This routine examines EXACTFL nodes, and (when the pattern\n *      isn't UTF-8) EXACTF and EXACTFA for such unfolded folds, and returns a\n *      boolean indicating whether or not the node contains such a fold.  When\n *      it is true, the caller sets a flag that later causes the optimizer in\n *      this file to not set values for the floating and fixed string lengths,\n *      and thus avoids the optimizer code in regexec.c that makes the invalid\n *      assumption.  Thus, there is no optimization based on string lengths for\n *      EXACTFL nodes that contain these few folds, nor for non-UTF8-pattern\n *      EXACTF and EXACTFA nodes that contain the sharp s.  (The reason the\n *      assumption is wrong only in these cases is that all other non-UTF-8\n *      folds are 1-1; and, for UTF-8 patterns, we pre-fold all other folds to\n *      their expanded versions.  (Again, we can't prefold sharp s to 'ss' in\n *      EXACTF nodes because we don't know at compile time if it actually\n *      matches 'ss' or not.  For EXACTF nodes it will match iff the target\n *      string is in UTF-8.  This is in contrast to EXACTFU nodes, where it\n *      always matches; and EXACTFA where it never does.  In an EXACTFA node in\n *      a UTF-8 pattern, sharp s is folded to \"\\x{17F}\\x{17F}, avoiding the\n *      problem; but in a non-UTF8 pattern, folding it to that above-Latin1\n *      string would require the pattern to be forced into UTF-8, the overhead\n *      of which we want to avoid.  Similarly the unfolded multi-char folds in\n *      EXACTFL nodes will match iff the locale at the time of match is a UTF-8\n *      locale.)\n *\n *      Similarly, the code that generates tries doesn't currently handle\n *      not-already-folded multi-char folds, and it looks like a pain to change\n *      that.  Therefore, trie generation of EXACTFA nodes with the sharp s\n *      doesn't work.  Instead, such an EXACTFA is turned into a new regnode,\n *      EXACTFA_NO_TRIE, which the trie code knows not to handle.  Most people\n *      using /iaa matching will be doing so almost entirely with ASCII\n *      strings, so this should rarely be encountered in practice */\n\n#define JOIN_EXACT(scan,min_subtract,unfolded_multi_char, flags) \\\n    if (PL_regkind[OP(scan)] == EXACT) \\\n        join_exact(pRExC_state,(scan),(min_subtract),unfolded_multi_char, (flags),NULL,depth+1)\n\nSTATIC U32\nS_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan,\n                   UV *min_subtract, bool *unfolded_multi_char,\n                   U32 flags,regnode *val, U32 depth)\n{\n    /* Merge several consecutive EXACTish nodes into one. */\n    regnode *n = regnext(scan);\n    U32 stringok = 1;\n    regnode *next = scan + NODE_SZ_STR(scan);\n    U32 merged = 0;\n    U32 stopnow = 0;\n#ifdef DEBUGGING\n    regnode *stop = scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n#else\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    PERL_ARGS_ASSERT_JOIN_EXACT;\n#ifndef EXPERIMENTAL_INPLACESCAN\n    PERL_UNUSED_ARG(flags);\n    PERL_UNUSED_ARG(val);\n#endif\n    DEBUG_PEEP(\"join\", scan, depth, 0);\n\n    /* Look through the subsequent nodes in the chain.  Skip NOTHING, merge\n     * EXACT ones that are mergeable to the current one. */\n    while (n\n           && (PL_regkind[OP(n)] == NOTHING\n               || (stringok && OP(n) == OP(scan)))\n           && NEXT_OFF(n)\n           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX)\n    {\n\n        if (OP(n) == TAIL || n > next)\n            stringok = 0;\n        if (PL_regkind[OP(n)] == NOTHING) {\n            DEBUG_PEEP(\"skip:\", n, depth, 0);\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            next = n + NODE_STEP_REGNODE;\n#ifdef DEBUGGING\n            if (stringok)\n                stop = n;\n#endif\n            n = regnext(n);\n        }\n        else if (stringok) {\n            const unsigned int oldl = STR_LEN(scan);\n            regnode * const nnext = regnext(n);\n\n            /* XXX I (khw) kind of doubt that this works on platforms (should\n             * Perl ever run on one) where U8_MAX is above 255 because of lots\n             * of other assumptions */\n            /* Don't join if the sum can't fit into a single node */\n            if (oldl + STR_LEN(n) > U8_MAX)\n                break;\n\n            DEBUG_PEEP(\"merg\", n, depth, 0);\n            merged++;\n\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            STR_LEN(scan) += STR_LEN(n);\n            next = n + NODE_SZ_STR(n);\n            /* Now we can overwrite *n : */\n            Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);\n#ifdef DEBUGGING\n            stop = next - 1;\n#endif\n            n = nnext;\n            if (stopnow) break;\n        }\n\n#ifdef EXPERIMENTAL_INPLACESCAN\n\tif (flags && !NEXT_OFF(n)) {\n\t    DEBUG_PEEP(\"atch\", val, depth, 0);\n\t    if (reg_off_by_arg[OP(n)]) {\n\t\tARG_SET(n, val - n);\n\t    }\n\t    else {\n\t\tNEXT_OFF(n) = val - n;\n\t    }\n\t    stopnow = 1;\n\t}\n#endif\n    }\n\n    *min_subtract = 0;\n    *unfolded_multi_char = FALSE;\n\n    /* Here, all the adjacent mergeable EXACTish nodes have been merged.  We\n     * can now analyze for sequences of problematic code points.  (Prior to\n     * this final joining, sequences could have been split over boundaries, and\n     * hence missed).  The sequences only happen in folding, hence for any\n     * non-EXACT EXACTish node */\n    if (OP(scan) != EXACT && OP(scan) != EXACTL) {\n        U8* s0 = (U8*) STRING(scan);\n        U8* s = s0;\n        U8* s_end = s0 + STR_LEN(scan);\n\n        int total_count_delta = 0;  /* Total delta number of characters that\n                                       multi-char folds expand to */\n\n\t/* One pass is made over the node's string looking for all the\n\t * possibilities.  To avoid some tests in the loop, there are two main\n\t * cases, for UTF-8 patterns (which can't have EXACTF nodes) and\n\t * non-UTF-8 */\n\tif (UTF) {\n            U8* folded = NULL;\n\n            if (OP(scan) == EXACTFL) {\n                U8 *d;\n\n                /* An EXACTFL node would already have been changed to another\n                 * node type unless there is at least one character in it that\n                 * is problematic; likely a character whose fold definition\n                 * won't be known until runtime, and so has yet to be folded.\n                 * For all but the UTF-8 locale, folds are 1-1 in length, but\n                 * to handle the UTF-8 case, we need to create a temporary\n                 * folded copy using UTF-8 locale rules in order to analyze it.\n                 * This is because our macros that look to see if a sequence is\n                 * a multi-char fold assume everything is folded (otherwise the\n                 * tests in those macros would be too complicated and slow).\n                 * Note that here, the non-problematic folds will have already\n                 * been done, so we can just copy such characters.  We actually\n                 * don't completely fold the EXACTFL string.  We skip the\n                 * unfolded multi-char folds, as that would just create work\n                 * below to figure out the size they already are */\n\n                Newx(folded, UTF8_MAX_FOLD_CHAR_EXPAND * STR_LEN(scan) + 1, U8);\n                d = folded;\n                while (s < s_end) {\n                    STRLEN s_len = UTF8SKIP(s);\n                    if (! is_PROBLEMATIC_LOCALE_FOLD_utf8(s)) {\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (is_FOLDS_TO_MULTI_utf8(s)) {\n                        *unfolded_multi_char = TRUE;\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (isASCII(*s)) {\n                        *(d++) = toFOLD(*s);\n                    }\n                    else {\n                        STRLEN len;\n                        _toFOLD_utf8_flags(s, s_end, d, &len, FOLD_FLAGS_FULL);\n                        d += len;\n                    }\n                    s += s_len;\n                }\n\n                /* Point the remainder of the routine to look at our temporary\n                 * folded copy */\n                s = folded;\n                s_end = d;\n            } /* End of creating folded copy of EXACTFL string */\n\n            /* Examine the string for a multi-character fold sequence.  UTF-8\n             * patterns have all characters pre-folded by the time this code is\n             * executed */\n            while (s < s_end - 1) /* Can stop 1 before the end, as minimum\n                                     length sequence we are looking for is 2 */\n\t    {\n                int count = 0;  /* How many characters in a multi-char fold */\n                int len = is_MULTI_CHAR_FOLD_utf8_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold: get next char */\n                    s += UTF8SKIP(s);\n                    continue;\n                }\n\n                /* Nodes with 'ss' require special handling, except for\n                 * EXACTFA-ish for which there is no multi-char fold to this */\n                if (len == 2 && *s == 's' && *(s+1) == 's'\n                    && OP(scan) != EXACTFA\n                    && OP(scan) != EXACTFA_NO_TRIE)\n                {\n                    count = 2;\n                    if (OP(scan) != EXACTFL) {\n                        OP(scan) = EXACTFU_SS;\n                    }\n                    s += 2;\n                }\n                else { /* Here is a generic multi-char fold. */\n                    U8* multi_end  = s + len;\n\n                    /* Count how many characters are in it.  In the case of\n                     * /aa, no folds which contain ASCII code points are\n                     * allowed, so check for those, and skip if found. */\n                    if (OP(scan) != EXACTFA && OP(scan) != EXACTFA_NO_TRIE) {\n                        count = utf8_length(s, multi_end);\n                        s = multi_end;\n                    }\n                    else {\n                        while (s < multi_end) {\n                            if (isASCII(*s)) {\n                                s++;\n                                goto next_iteration;\n                            }\n                            else {\n                                s += UTF8SKIP(s);\n                            }\n                            count++;\n                        }\n                    }\n                }\n\n                /* The delta is how long the sequence is minus 1 (1 is how long\n                 * the character that folds to the sequence is) */\n                total_count_delta += count - 1;\n              next_iteration: ;\n\t    }\n\n            /* We created a temporary folded copy of the string in EXACTFL\n             * nodes.  Therefore we need to be sure it doesn't go below zero,\n             * as the real string could be shorter */\n            if (OP(scan) == EXACTFL) {\n                int total_chars = utf8_length((U8*) STRING(scan),\n                                           (U8*) STRING(scan) + STR_LEN(scan));\n                if (total_count_delta > total_chars) {\n                    total_count_delta = total_chars;\n                }\n            }\n\n            *min_subtract += total_count_delta;\n            Safefree(folded);\n\t}\n\telse if (OP(scan) == EXACTFA) {\n\n            /* Non-UTF-8 pattern, EXACTFA node.  There can't be a multi-char\n             * fold to the ASCII range (and there are no existing ones in the\n             * upper latin1 range).  But, as outlined in the comments preceding\n             * this function, we need to flag any occurrences of the sharp s.\n             * This character forbids trie formation (because of added\n             * complexity) */\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n\t    while (s < s_end) {\n                if (*s == LATIN_SMALL_LETTER_SHARP_S) {\n                    OP(scan) = EXACTFA_NO_TRIE;\n                    *unfolded_multi_char = TRUE;\n                    break;\n                }\n                s++;\n            }\n        }\n\telse {\n\n            /* Non-UTF-8 pattern, not EXACTFA node.  Look for the multi-char\n             * folds that are all Latin1.  As explained in the comments\n             * preceding this function, we look also for the sharp s in EXACTF\n             * and EXACTFL nodes; it can be in the final position.  Otherwise\n             * we can stop looking 1 byte earlier because have to find at least\n             * two characters for a multi-fold */\n\t    const U8* upper = (OP(scan) == EXACTF || OP(scan) == EXACTFL)\n                              ? s_end\n                              : s_end -1;\n\n\t    while (s < upper) {\n                int len = is_MULTI_CHAR_FOLD_latin1_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold. */\n                    if (*s == LATIN_SMALL_LETTER_SHARP_S\n                        && (OP(scan) == EXACTF || OP(scan) == EXACTFL))\n                    {\n                        *unfolded_multi_char = TRUE;\n                    }\n                    s++;\n                    continue;\n                }\n\n                if (len == 2\n                    && isALPHA_FOLD_EQ(*s, 's')\n                    && isALPHA_FOLD_EQ(*(s+1), 's'))\n                {\n\n                    /* EXACTF nodes need to know that the minimum length\n                     * changed so that a sharp s in the string can match this\n                     * ss in the pattern, but they remain EXACTF nodes, as they\n                     * won't match this unless the target string is is UTF-8,\n                     * which we don't know until runtime.  EXACTFL nodes can't\n                     * transform into EXACTFU nodes */\n                    if (OP(scan) != EXACTF && OP(scan) != EXACTFL) {\n                        OP(scan) = EXACTFU_SS;\n                    }\n\t\t}\n\n                *min_subtract += len - 1;\n                s += len;\n\t    }\n#endif\n\t}\n    }\n\n#ifdef DEBUGGING\n    /* Allow dumping but overwriting the collection of skipped\n     * ops and/or strings with fake optimized ops */\n    n = scan + NODE_SZ_STR(scan);\n    while (n <= stop) {\n\tOP(n) = OPTIMIZED;\n\tFLAGS(n) = 0;\n\tNEXT_OFF(n) = 0;\n        n++;\n    }\n#endif\n    DEBUG_OPTIMISE_r(if (merged){DEBUG_PEEP(\"finl\", scan, depth, 0);});\n    return stopnow;\n}\n\n/* REx optimizer.  Converts nodes into quicker variants \"in place\".\n   Finds fixed substrings.  */\n\n/* Stops at toplevel WHILEM as well as at \"last\". At end *scanp is set\n   to the position after last scanned or to NULL. */\n\n#define INIT_AND_WITHP \\\n    assert(!and_withp); \\\n    Newx(and_withp,1, regnode_ssc); \\\n    SAVEFREEPV(and_withp)\n\n\nstatic void\nS_unwind_scan_frames(pTHX_ const void *p)\n{\n    scan_frame *f= (scan_frame *)p;\n    do {\n        scan_frame *n= f->next_frame;\n        Safefree(f);\n        f= n;\n    } while (f);\n}\n\n\nSTATIC SSize_t\nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth)\n\t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    /* There must be at least this number of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i = 0 ; i < (U32)RExC_npar ; i++ ) {\n                    if (\n                        PAREN_TEST(RExC_study_chunk_recursed +\n                                   ( j * RExC_study_chunk_recursed_bytes), i )\n                        && (\n                            !j ||\n                            !PAREN_TEST(RExC_study_chunk_recursed +\n                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                        )\n                    ) {\n                        Perl_re_printf( aTHX_ \" %d\",(int)i);\n                        break;\n                    }\n                }\n                if ( j + 1 < recursed_depth ) {\n                    Perl_re_printf( aTHX_  \",\");\n                }\n            }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum\n                                   node length to get a real minimum (because\n                                   the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n\t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT\n         * parsing code, as each (?:..) is handled by a different invocation of\n         * reg() -- Yves\n         */\n        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n\n\t/* Follow the next-chain of the current node and optimize\n\t   away all the NOTHINGs from it.  */\n\tif (OP(scan) != CURLYX) {\n\t    const int max = (reg_off_by_arg[OP(scan)]\n\t\t       ? I32_MAX\n\t\t       /* I32 may be smaller than U16 on CRAYs! */\n\t\t       : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));\n\t    int off = (reg_off_by_arg[OP(scan)] ? ARG(scan) : NEXT_OFF(scan));\n\t    int noff;\n\t    regnode *n = scan;\n\n\t    /* Skip NOTHING and LONGJMP. */\n\t    while ((n = regnext(n))\n\t\t   && ((PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))\n\t\t       || ((OP(n) == LONGJMP) && (noff = ARG(n))))\n\t\t   && off + noff < max)\n\t\toff += noff;\n\t    if (reg_off_by_arg[OP(scan)])\n\t\tARG(scan) = off;\n\t    else\n\t\tNEXT_OFF(scan) = off;\n\t}\n\n\t/* The principal pseudo-switch.  Cannot be a switch, since we\n\t   look into several different things.  */\n        if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n            SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n            I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan) == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"next\", next, depth, flags);\n\n            /* we suppose the run is continuous, last=next...\n             * NOTE we dont use the return here! */\n            /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state, &scan, &minlen,\n                              &deltanext, next, &data_fake, stopparen,\n                              recursed_depth, NULL, f, depth+1);\n\n            scan = next;\n        } else\n        if (\n            OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n            OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\n             * IFTHEN is special as it might not appear in pairs.\n             * Not sure whether BRANCH-BRANCHJ is possible, regardless\n             * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN) {\n                /* NOTE - There is similar code to this block below for\n                 * handling TRIE nodes on a re-study.  If you change stuff here\n                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge strings after this. */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\tssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous, last=next...*/\n                    /* recurse study_chunk() for each BRANCH in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                      &deltanext, next, &data_fake, stopparen,\n                                      recursed_depth, NULL, f,depth+1);\n\n\t\t    if (min1 > minnext)\n\t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf = is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin > minnext)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 != min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION &&\n                        OP( startbranch ) == BRANCH )\n                {\n\t\t/* demq.\n\n                   Assuming this was/is a branch we are dealing with: 'scan'\n                   now points at the item that follows the branch sequence,\n                   whatever it is. We now start at the beginning of the\n                   sequence and look for subsequences of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n                   which would be constructed from a pattern like\n                   /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need to turn the first\n\t\t   element into a trie and then add the subsequent branch exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n                     1. patterns where the whole set of branches can be\n                        converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE; BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t    if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0  ) {\n                        regnode *cur;\n                        regnode *first = (regnode *)NULL;\n                        regnode *last = (regnode *)NULL;\n                        regnode *tail = scan;\n                        U8 trietype = 0;\n                        U32 count=0;\n\n                        /* var tail is used because there may be a TAIL\n                           regop in the way. Ie, the exacts will point to the\n                           thing following the TAIL, but the last branch will\n                           point at the TAIL. So we advance tail. If we\n                           have nested (?:) we may have to move through several\n                           tails.\n                         */\n\n                        while ( OP( tail ) == TAIL ) {\n                            /* this is the TAIL generated by (?:) */\n                            tail = regnext( tail );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                              depth+1,\n                              \"Looking for TRIE'able sequences. Tail node is \",\n                              (UV)(tail - RExC_emit_start),\n                              SvPV_nolen_const( RExC_mysv )\n                            );\n                        });\n\n                        /*\n\n                            Step through the branches\n                                cur represents each branch,\n                                noper is the first thing to be matched as part\n                                      of that branch\n                                noper_next is the regnext() of that node.\n\n                            We normally handle a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump trie\" but we also\n                            support building with NOJUMPTRIE, which restricts\n                            the trie logic to structures like /FOO|BAR/.\n\n                            If noper is a trieable nodetype then the branch is\n                            a possible optimization target. If we are building\n                            under NOJUMPTRIE then we require that noper_next is\n                            the same as scan (our current position in the regex\n                            program).\n\n                            Once we have two or more consecutive such branches\n                            we can create a trie of the EXACT's contents and\n                            stitch it in place into the program.\n\n                            If the sequence represents all of the branches in\n                            the alternation we replace the entire thing with a\n                            single TRIE node.\n\n                            Otherwise when it is a subsequence we need to\n                            stitch it in place and replace only the relevant\n                            branches. This means the first branch has to remain\n                            as it is used by the alternation logic, and its\n                            next pointer, and needs to be repointed at the item\n                            on the branch chain following the last branch we\n                            have optimized away.\n\n                            This could be either a BRANCH, in which case the\n                            subsequence is internal, or it could be the item\n                            following the branch sequence in which case the\n                            subsequence is at the end (which does not\n                            necessarily mean the first node is the start of the\n                            alternation).\n\n                            TRIE_TYPE(X) is a define which maps the optype to a\n                            trietype.\n\n                                optype          |  trietype\n                                ----------------+-----------\n                                NOTHING         | NOTHING\n                                EXACT           | EXACT\n                                EXACTFU         | EXACTFU\n                                EXACTFU_SS      | EXACTFU\n                                EXACTFA         | EXACTFA\n                                EXACTL          | EXACTL\n                                EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                       ? NOTHING                                            \\\n                       : ( EXACT == (X) )                                   \\\n                         ? EXACT                                            \\\n                         : ( EXACTFU == (X) || EXACTFU_SS == (X) )          \\\n                           ? EXACTFU                                        \\\n                           : ( EXACTFA == (X) )                             \\\n                             ? EXACTFA                                      \\\n                             : ( EXACTL == (X) )                            \\\n                               ? EXACTL                                     \\\n                               : ( EXACTFLU8 == (X) )                        \\\n                                 ? EXACTFLU8                                 \\\n                                 : 0 )\n\n                        /* dont use tail as the end marker for this traverse */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                            regnode * const noper = NEXTOPER( cur );\n                            U8 noper_type = OP( noper );\n                            U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                            regnode * const noper_next = regnext( noper );\n                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                   depth+1,\n                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\n                                if ( noper_next ) {\n                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                  Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                }\n                                Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\t\t\t\t);\n                            });\n\n                            /* Is noper a trieable nodetype that can be merged\n                             * with the current trie (if there is one)? */\n                            if ( noper_trietype\n                                  &&\n                                  (\n                                        ( noper_trietype == NOTHING )\n                                        || ( trietype == NOTHING )\n                                        || ( trietype == noper_trietype )\n                                  )\n#ifdef NOJUMPTRIE\n                                  && noper_next >= tail\n#endif\n                                  && count < U16_MAX)\n                            {\n                                /* Handle mergable triable node Either we are\n                                 * the first node in a new trieable sequence,\n                                 * in which case we do some bookkeeping,\n                                 * otherwise we update the end pointer. */\n                                if ( !first ) {\n                                    first = cur;\n\t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                                        if ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n                                        } else if (noper_next_type)  {\n                                            /* a NOTHING regop is 1 regop wide.\n                                             * We need at least two for a trie\n                                             * so we can't merge this in */\n                                            first = NULL;\n                                        }\n                                    } else {\n                                        trietype = noper_trietype;\n                                    }\n                                } else {\n                                    if ( trietype == NOTHING )\n                                        trietype = noper_trietype;\n                                    last = cur;\n                                }\n\t\t\t\tif (first)\n\t\t\t\t    count++;\n                            } /* end handle mergable triable node */\n                            else {\n                                /* handle unmergable node -\n                                 * noper may either be a triable node which can\n                                 * not be tried together with the current trie,\n                                 * or a non triable node */\n                                if ( last ) {\n                                    /* If last is set and trietype is not\n                                     * NOTHING then we have found at least two\n                                     * triable branch sequences in a row of a\n                                     * similar trietype so we can turn them\n                                     * into a trie. If/when we allow NOTHING to\n                                     * start a trie sequence this condition\n                                     * will be required, and it isn't expensive\n                                     * so we leave it in for now. */\n                                    if ( trietype && trietype != NOTHING )\n                                        make_trie( pRExC_state,\n                                                startbranch, first, cur, tail,\n                                                count, trietype, depth+1 );\n                                    last = NULL; /* note: we clear/update\n                                                    first, trietype etc below,\n                                                    so we dont do it here */\n                                }\n                                if ( noper_trietype\n#ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n#endif\n                                ){\n                                    /* noper is triable, so we can start a new\n                                     * trie sequence */\n                                    count = 1;\n                                    first = cur;\n                                    trietype = noper_trietype;\n                                } else if (first) {\n                                    /* if we already saw a first but the\n                                     * current node is not triable then we have\n                                     * to reset the first information. */\n                                    count = 0;\n                                    first = NULL;\n                                    trietype = 0;\n                                }\n                            } /* end handle unmergable node */\n                        } /* loop over branches */\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1, SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));\n                            Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                               PL_reg_name[trietype]\n                            );\n\n                        });\n                        if ( last && trietype ) {\n                            if ( trietype != NOTHING ) {\n                                /* the last branch of the sequence was part of\n                                 * a trie, so we have to construct it here\n                                 * outside of the loop */\n                                made= make_trie( pRExC_state, startbranch,\n                                                 first, scan, tail, count,\n                                                 trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n                                if ( ((made == MADE_EXACT_TRIE &&\n                                     startbranch == first)\n                                     || ( first_non_open == first )) &&\n                                     depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n                                    if ( startbranch == first\n                                         && scan >= tail )\n                                    {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                    }\n                                }\n#endif\n                            } else {\n                                /* at this point we know whatever we have is a\n                                 * NOTHING sequence/branch AND if 'startbranch'\n                                 * is 'first' then we can turn the whole thing\n                                 * into a NOTHING\n                                 */\n                                if ( startbranch == first ) {\n                                    regnode *opt;\n                                    /* the entire thing is a NOTHING sequence,\n                                     * something like this: (?:|) So we can\n                                     * turn it into a plain NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                        Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                          depth+1,\n                                          SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));\n\n                                    });\n                                    OP(startbranch)= NOTHING;\n                                    NEXT_OFF(startbranch)= tail - startbranch;\n                                    for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                        OP(opt)= OPTIMIZED;\n                                }\n                            }\n                        } /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ ) {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n            I32 paren = 0;\n            regnode *start = NULL;\n            regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup, note this code has side effects beyond\n                 * the rest of this block. Specifically setting\n                 * RExC_recurse[] must happen at least once during\n                 * study_chunk(). */\n                paren = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n                start = RExC_open_parens[paren];\n                end   = RExC_close_parens[paren];\n\n                /* NOTE we MUST always execute the above code, even\n                 * if we do nothing with a GOSUB */\n                if (\n                    ( flags & SCF_IN_DEFINE )\n                    ||\n                    (\n                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                        &&\n                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n                ) {\n                    /* no need to do anything here if we are in a define. */\n                    /* or we are after some kind of infinite construct\n                     * so we can skip recursing into this item.\n                     * Since it is infinite we will not change the maxlen\n                     * or delta, and if we miss something that might raise\n                     * the minlen it will merely pessimise a little.\n                     *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n                     * might result in a minlen of 1 and not of 4,\n                     * but this doesn't make us mismatch, just try a bit\n                     * harder than we should.\n                     * */\n                    scan= regnext(scan);\n                    continue;\n                }\n\n                if (\n                    !recursed_depth\n                    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n                    /* it is quite possible that there are more efficient ways\n                     * to do this. We maintain a bitmap per level of recursion\n                     * of which patterns we have entered so we can detect if a\n                     * pattern creates a possible infinite loop. When we\n                     * recurse down a level we copy the previous levels bitmap\n                     * down. When we are at recursion level 0 we zero the top\n                     * level bitmap. It would be nice to implement a different\n                     * more efficient way of doing this. In particular the top\n                     * level bitmap may be unnecessary.\n                     */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed_bytes, U8);\n                    }\n                    /* we havent recursed into this paren yet, so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth= recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite recursion, assume infinite length\n                     * */\n                    if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n                    }\n                    is_inf = is_inf_internal = 1;\n                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n                        ssc_anything(data->start_class);\n                    flags &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we dont recurse later on. */\n\t        }\n            } else {\n\t        paren = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\t    }\n            if (start) {\n                scan_frame *newframe;\n                assert(end);\n                if (!RExC_frame_last) {\n                    Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                    RExC_frame_head= newframe;\n                    RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame) {\n                    Newxz(newframe,1,scan_frame);\n                    RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame= RExC_frame_last;\n                    RExC_frame_count++;\n                } else {\n                    newframe= RExC_frame_last->next_frame;\n                }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode = regnext(scan);\n                newframe->last_regnode = last;\n                newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth = recursed_depth;\n                newframe->this_prev_frame= frame;\n\n                DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan, depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t        stopparen = paren;\n\t        last = end;\n                depth = depth + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\t    }\n\t}\n\telse if (OP(scan) == EXACT || OP(scan) == EXACTL) {\n\t    SSize_t l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset, later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t    data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                              (U8*)STRING(scan)+STR_LEN(scan));\n\t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n            /* ANDing the code point leaves at most it, and not in locale, and\n             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND) {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class, uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)] == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /* Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n            delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan) != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                    ANYOF_POSIXL_ZERO(data->start_class);\n                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                flags &= ~SCF_DO_STCLASS;\n                SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan))) {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)* . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\t\t    if (OP(next) == EXACT\n                        || OP(next) == EXACTL\n                        || (flags & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX) {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear cache processing any {n,m}\n\t\t   regops for which the combination of input pos and regex\n\t\t   pos is not enough information to determine if a match\n\t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t/* This will finish on WHILEM, setting scan, or on NULL: */\n                /* recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                  last, data, stopparen, recursed_depth, NULL,\n                                  (mincount == 0\n                                   ? (f & ~SCF_DO_SUBSTR)\n                                   : f)\n                                  ,depth+1);\n\n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n                                                |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan = next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                    && maxcount <= REG_INFTY/3) /* Complement check for big\n                                                   count */\n\t\t{\n\t\t    /* Fatal warnings may leak the regexp without this: */\n\t\t    SAVEFREESV(RExC_rx_sv);\n\t\t    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n\t\t\t\"Quantifier unexpected on zero-length expression \"\n\t\t\t\"in regex m/%\" UTF8f \"/\",\n\t\t\t UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp));\n\t\t    (void)ReREFCNT_inc(RExC_rx_sv);\n\t\t}\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext == SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext + deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf) {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta += (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext == 1 ) {\n\t\t    /* Try to optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n#endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens) {\n                        RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/\n                        RExC_close_parens[ARG(nxt1)]=nxt+2; /*close->while*/\n\t\t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t/* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t}\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t      && minnext != 0\t/* CURLYM can't handle zero width */\n\n                         /* Nor characters whose fold at run-time may be\n                          * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\t\t) {\n\t\t    /* XXXX How to optimize if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif (RExC_open_parens) {\n                            RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/\n                            RExC_close_parens[ARG(nxt1)]=nxt2+1; /*close->NOTHING*/\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t    }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n                        /* recurse study_chunk() on optimised CURLYX => CURLYM */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                    NULL, stopparen, recursed_depth, NULL, 0,depth+1);\n\t\t    }\n\t\t    else\n\t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair. */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n                    if (nxt->flags & 0xf) {\n                        /* we've already set whilem count on this node */\n                    } else if (++data->whilem_c < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n                        nxt->flags = (U8)(data->whilem_c\n                            | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                    if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                                                                  string. */\n\t\t\tSSize_t b = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\t\t\tSSize_t old = b - data->last_start_min;\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop((U8*)s, old) - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                        last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                            (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str), l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\tSvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                                last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t    data->last_start_max =\n                              is_inf\n                               ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n                                 (maxcount - 1) * (minnext + data->pos_delta);\n\t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\nPerl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\t\t\t    the group.  */\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /* float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data && (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\t\tif (OP(oscan) != CURLYX) {\n\t\t    while (PL_regkind[OP(next = regnext(oscan))] == NOTHING\n\t\t\t   && NEXT_OFF(next))\n\t\t\tNEXT_OFF(oscan) += NEXT_OFF(next);\n\t\t}\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                    OP(scan));\n#endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    /* Cannot expect anything... */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n                        /* Actually is any start char, but very few code points\n                         * aren't start characters */\n                        ssc_match_all_cp(data->start_class);\n                    }\n                    else {\n                        ssc_anything(data->start_class);\n                    }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS) {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                    ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n                              PL_XPosix_ptrs[_CC_VERTSPACE],\n                              FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg for\n                     * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n            if (delta != SSize_t_MAX)\n                delta++;    /* Because of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n\t        data->pos_delta += 1;\n\t\tdata->cur_is_floating = 1; /* float */\n    \t    }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                     OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t    break;\n\n\t\tcase REG_ANY:\n                    {\n                        SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                            '\\n');\n                        if (flags & SCF_DO_STCLASS_OR) {\n                            ssc_union(data->start_class,\n                                      REG_ANY_invlist,\n                                      TRUE /* TRUE => invert, hence all but \\n\n                                            */\n                                      );\n                        }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n                            ssc_intersection(data->start_class,\n                                             REG_ANY_invlist,\n                                             TRUE  /* TRUE => invert */\n                                             );\n                            ssc_clear_locale(data->start_class);\n                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case ANYOFL:\n                case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class,\n                                (regnode_charclass *) scan);\n\t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                                                          (regnode_charclass *) scan);\n\t\t    break;\n\n\t\tcase NPOSIXL:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        bool was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n                                                                 namedclass));\n                        ANYOF_POSIXL_ZERO(data->start_class);\n                        if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                        /* No individual code points can now match */\n                        data->start_class->invlist\n                                                = sv_2mortal(_new_invlist(0));\n                    }\n                    else {\n                        int complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this class was already there,\n                         * the result is that they match all code points,\n                         * (\\d + \\D == everything).  Remove the classes from\n                         * future consideration.  Locale is not relevant in\n                         * this case */\n                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                            ssc_match_all_cp(data->start_class);\n                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                            ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                        }\n                        else {  /* The usual case; just add this class to the\n                                   existing set */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                    }\n                    break;\n\n                case NPOSIXA:   /* For these, we always know the exact set of\n                                   what's matched */\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n                    if (FLAGS(scan) == _CC_ASCII) {\n                        my_invlist = invlist_clone(PL_XPosix_ptrs[_CC_ASCII]);\n                    }\n                    else {\n                        _invlist_intersection(PL_XPosix_ptrs[FLAGS(scan)],\n                                              PL_XPosix_ptrs[_CC_ASCII],\n                                              &my_invlist);\n                    }\n                    goto join_posix;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)]);\n\n                    /* NPOSIXD matches all upper Latin1 code points unless the\n                     * target string being matched is UTF-8, which is\n                     * unknowable until match time.  Since we are going to\n                     * invert, we want to get rid of all of them so that the\n                     * inversion will match all */\n                    if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                          &my_invlist);\n                    }\n\n                  join_posix:\n\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n                    }\n                    else {\n                        assert(flags & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class, my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t}\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) == UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n                   In this case we can't do fixed string optimisation.\n                */\n\n                SSize_t deltanext, minnext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                if (data) {\n                    data_fake.whilem_c = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\t\t}\n                else\n                    data_fake.last_closep = &fake;\n\t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk() for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                      last, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n                if (scan->flags) {\n                    if (deltanext) {\n\t\t\tFAIL(\"Variable length lookbehind not implemented\");\n                    }\n                    else if (minnext > (I32)U8_MAX) {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n                    scan->flags = (U8)minnext;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after: ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t    }  else {\n                        /* AND before and after: combine and continue.  These\n                         * assertions are zero-length, so can match an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n                                                   |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n            else {\n                /* Positive Lookahead/lookbehind\n                   In this case we can do fixed string optimisation,\n                   but we must be careful about it. Note in the case of\n                   lookbehind the positions will be offset by the minimum\n                   length of the pattern, something we won't know about\n                   until after the recurse.\n                */\n                SSize_t deltanext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n                /* We use SAVEFREEPV so that when the full compile\n                    is finished perl will clean up the allocated\n                    minlens when it's all done. This way we don't\n                    have to worry about freeing them when we know\n                    they wont be used, which would be a pain.\n                 */\n                SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n                SAVEFREEPV(minnextp);\n\n                if (data) {\n                    StructCopy(data, &data_fake, scan_data_t);\n                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |= SCF_DO_SUBSTR;\n                        if (scan->flags)\n                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                        data_fake.last_found=newSVsv(data->last_found);\n                    }\n                }\n                else\n                    data_fake.last_closep = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* positive lookahead study_chunk() recursion */\n                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                        &deltanext, last, &data_fake,\n                                        stopparen, recursed_depth, NULL,\n                                        f,depth+1);\n                if (scan->flags) {\n                    if (deltanext) {\n\t\t\tFAIL(\"Variable length lookbehind not implemented\");\n                    }\n                    else if (*minnextp > (I32)U8_MAX) {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n                    scan->flags = (U8)*minnextp;\n                }\n\n                *minnextp += min;\n\n                if (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n                            RExC_rx->minlen=*minnextp;\n                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                        SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp != minlenp) {\n                                data->substrs[i].min_offset =\n                                            data_fake.substrs[i].min_offset;\n                                data->substrs[i].max_offset =\n                                            data_fake.substrs[i].max_offset;\n                                data->substrs[i].minlenp =\n                                            data_fake.substrs[i].minlenp;\n                                data->substrs[i].lookbehind += scan->flags;\n                            }\n                        }\n                    }\n                }\n\t    }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen == (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par) {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL) {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t        if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n                RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n        else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is similar code to this block above for handling\n               BRANCH nodes on the initial study.  If you change stuff here\n               check there too. */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump) {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n            } else {\n                const regnode *nextbranch= NULL;\n                U32 word;\n\n                for ( word=1 ; word <= trie->wordcount ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0, f = 0, fake;\n                    regnode_ssc this_class;\n\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                    if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n                        data_fake.last_closep = data->last_closep;\n                    }\n                    else\n                        data_fake.last_closep = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n                        data_fake.start_class = &this_class;\n                        f = SCF_DO_STCLASS_AND;\n                    }\n                    if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n                            nextbranch = trie_node + trie->jump[0];\n                        scan= trie_node + trie->jump[word];\n                        /* We go from the jump point to the branch that follows\n                           it. Note this means we need the vestigal unused\n                           branches even though they arent otherwise used. */\n                        /* optimise study_chunk() for TRIE */\n                        minnext = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext, (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth, NULL, f,depth+1);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode*)nextbranch);\n\n                    if (min1 > (SSize_t)(minnext + trie->minlen))\n                        min1 = minnext + trie->minlen;\n                    if (deltanext == SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n                        max1 = SSize_t_MAX;\n                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1 = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin > min + min1)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n                            data->flags |= SF_HAS_EVAL;\n                        data->whilem_c = data_fake.whilem_c;\n                    }\n                    if (flags & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                }\n            }\n            if (flags & SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta += max1 - min1;\n                if (max1 != min1 || is_inf)\n                    data->cur_is_floating = 1; /* float */\n            }\n            min += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n                else\n                    delta = SSize_t_MAX;\n            }\n            if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n                else {\n                    /* Switch to OR mode: cache the old value of\n                     * data->start_class */\n\t\t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp, regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n                    StructCopy(&accum, data->start_class, regnode_ssc);\n                    flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n            scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)] == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth, flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ? SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n                RExC_maxlen = final_minlen + delta;\n        }\n        return final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */\n}\n\nSTATIC U32\nS_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)\n{\n    U32 count = RExC_rxi->data ? RExC_rxi->data->count : 0;\n\n    PERL_ARGS_ASSERT_ADD_DATA;\n\n    Renewc(RExC_rxi->data,\n\t   sizeof(*RExC_rxi->data) + sizeof(void*) * (count + n - 1),\n\t   char, struct reg_data);\n    if(count)\n\tRenew(RExC_rxi->data->what, count + n, U8);\n    else\n\tNewx(RExC_rxi->data->what, n, U8);\n    RExC_rxi->data->count = count + n;\n    Copy(s, RExC_rxi->data->what + count, n, U8);\n    return count;\n}\n\n/*XXX: todo make this not included in a non debugging perl, but appears to be\n * used anyway there, in 'use re' */\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_reginitcolors(pTHX)\n{\n    const char * const s = PerlEnv_getenv(\"PERL_RE_COLORS\");\n    if (s) {\n\tchar *t = savepv(s);\n\tint i = 0;\n\tPL_colors[0] = t;\n\twhile (++i < 6) {\n\t    t = strchr(t, '\\t');\n\t    if (t) {\n\t\t*t = '\\0';\n\t\tPL_colors[i] = ++t;\n\t    }\n\t    else\n\t\tPL_colors[i] = t = (char *)\"\";\n\t}\n    } else {\n\tint i = 0;\n\twhile (i < 6)\n\t    PL_colors[i++] = (char *)\"\";\n    }\n    PL_colorset = 1;\n}\n#endif\n\n\n#ifdef TRIE_STUDY_OPT\n#define CHECK_RESTUDY_GOTO_butfirst(dOsomething)            \\\n    STMT_START {                                            \\\n        if (                                                \\\n              (data.flags & SCF_TRIE_RESTUDY)               \\\n              && ! restudied++                              \\\n        ) {                                                 \\\n            dOsomething;                                    \\\n            goto reStudy;                                   \\\n        }                                                   \\\n    } STMT_END\n#else\n#define CHECK_RESTUDY_GOTO_butfirst\n#endif\n\n/*\n * pregcomp - compile a regular expression into internal code\n *\n * Decides which engine's compiler to call based on the hint currently in\n * scope\n */\n\n#ifndef PERL_IN_XSUB_RE\n\n/* return the currently in-scope regex engine (or the default if none)  */\n\nregexp_engine const *\nPerl_current_re_engine(pTHX)\n{\n    if (IN_PERL_COMPILETIME) {\n\tHV * const table = GvHV(PL_hintgv);\n\tSV **ptr;\n\n\tif (!table || !(PL_hints & HINT_LOCALIZE_HH))\n\t    return &PL_core_reg_engine;\n\tptr = hv_fetchs(table, \"regcomp\", FALSE);\n\tif ( !(ptr && SvIOK(*ptr) && SvIV(*ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*,SvIV(*ptr));\n    }\n    else {\n\tSV *ptr;\n\tif (!PL_curcop->cop_hints_hash)\n\t    return &PL_core_reg_engine;\n\tptr = cop_hints_fetch_pvs(PL_curcop, \"regcomp\", 0);\n\tif ( !(ptr && SvIOK(ptr) && SvIV(ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*,SvIV(ptr));\n    }\n}\n\n\nREGEXP *\nPerl_pregcomp(pTHX_ SV * const pattern, const U32 flags)\n{\n    regexp_engine const *eng = current_re_engine();\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGCOMP;\n\n    /* Dispatch a request to compile a regexp to correct regexp engine. */\n    DEBUG_COMPILE_r({\n        Perl_re_printf( aTHX_  \"Using engine %\" UVxf \"\\n\",\n\t\t\tPTR2UV(eng));\n    });\n    return CALLREGCOMP_ENG(eng, pattern, flags);\n}\n#endif\n\n/* public(ish) entry point for the perl core's own regex compiling code.\n * It's actually a wrapper for Perl_re_op_compile that only takes an SV\n * pattern rather than a list of OPs, and uses the internal engine rather\n * than the current one */\n\nREGEXP *\nPerl_re_compile(pTHX_ SV * const pattern, U32 rx_flags)\n{\n    SV *pat = pattern; /* defeat constness! */\n    PERL_ARGS_ASSERT_RE_COMPILE;\n    return Perl_re_op_compile(aTHX_ &pat, 1, NULL,\n#ifdef PERL_IN_XSUB_RE\n                                &my_reg_engine,\n#else\n                                &PL_core_reg_engine,\n#endif\n                                NULL, NULL, rx_flags, 0);\n}\n\n\nstatic void\nS_free_codeblocks(pTHX_ struct reg_code_blocks *cbs)\n{\n    int n;\n\n    if (--cbs->refcnt > 0)\n        return;\n    for (n = 0; n < cbs->count; n++) {\n        REGEXP *rx = cbs->cb[n].src_regex;\n        cbs->cb[n].src_regex = NULL;\n        SvREFCNT_dec(rx);\n    }\n    Safefree(cbs->cb);\n    Safefree(cbs);\n}\n\n\nstatic struct reg_code_blocks *\nS_alloc_code_blocks(pTHX_  int ncode)\n{\n     struct reg_code_blocks *cbs;\n    Newx(cbs, 1, struct reg_code_blocks);\n    cbs->count = ncode;\n    cbs->refcnt = 1;\n    SAVEDESTRUCTOR_X(S_free_codeblocks, cbs);\n    if (ncode)\n        Newx(cbs->cb, ncode, struct reg_code_block);\n    else\n        cbs->cb = NULL;\n    return cbs;\n}\n\n\n/* upgrade pattern pat_p of length plen_p to UTF8, and if there are code\n * blocks, recalculate the indices. Update pat_p and plen_p in-place to\n * point to the realloced string and length.\n *\n * This is essentially a copy of Perl_bytes_to_utf8() with the code index\n * stuff added */\n\nstatic void\nS_pat_upgrade_to_utf8(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char **pat_p, STRLEN *plen_p, int num_code_blocks)\n{\n    U8 *const src = (U8*)*pat_p;\n    U8 *dst, *d;\n    int n=0;\n    STRLEN s = 0;\n    bool do_end = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"UTF8 mismatch! Converting to utf8 for resizing and compile\\n\"));\n\n    Newx(dst, *plen_p * 2 + 1, U8);\n    d = dst;\n\n    while (s < *plen_p) {\n        append_utf8_from_native_byte(src[s], &d);\n\n        if (n < num_code_blocks) {\n            assert(pRExC_state->code_blocks);\n            if (!do_end && pRExC_state->code_blocks->cb[n].start == s) {\n                pRExC_state->code_blocks->cb[n].start = d - dst - 1;\n                assert(*(d - 1) == '(');\n                do_end = 1;\n            }\n            else if (do_end && pRExC_state->code_blocks->cb[n].end == s) {\n                pRExC_state->code_blocks->cb[n].end = d - dst - 1;\n                assert(*(d - 1) == ')');\n                do_end = 0;\n                n++;\n            }\n        }\n        s++;\n    }\n    *d = '\\0';\n    *plen_p = d - dst;\n    *pat_p = (char*) dst;\n    SAVEFREEPV(*pat_p);\n    RExC_orig_utf8 = RExC_utf8 = 1;\n}\n\n\n\n/* S_concat_pat(): concatenate a list of args to the pattern string pat,\n * while recording any code block indices, and handling overloading,\n * nested qr// objects etc.  If pat is null, it will allocate a new\n * string, or just return the first arg, if there's only one.\n *\n * Returns the malloced/updated pat.\n * patternp and pat_count is the array of SVs to be concatted;\n * oplist is the optional list of ops that generated the SVs;\n * recompile_p is a pointer to a boolean that will be set if\n *   the regex will need to be recompiled.\n * delim, if non-null is an SV that will be inserted between each element\n */\n\nstatic SV*\nS_concat_pat(pTHX_ RExC_state_t * const pRExC_state,\n                SV *pat, SV ** const patternp, int pat_count,\n                OP *oplist, bool *recompile_p, SV *delim)\n{\n    SV **svp;\n    int n = 0;\n    bool use_delim = FALSE;\n    bool alloced = FALSE;\n\n    /* if we know we have at least two args, create an empty string,\n     * then concatenate args to that. For no args, return an empty string */\n    if (!pat && pat_count != 1) {\n        pat = newSVpvs(\"\");\n        SAVEFREESV(pat);\n        alloced = TRUE;\n    }\n\n    for (svp = patternp; svp < patternp + pat_count; svp++) {\n        SV *sv;\n        SV *rx  = NULL;\n        STRLEN orig_patlen = 0;\n        bool code = 0;\n        SV *msv = use_delim ? delim : *svp;\n        if (!msv) msv = &PL_sv_undef;\n\n        /* if we've got a delimiter, we go round the loop twice for each\n         * svp slot (except the last), using the delimiter the second\n         * time round */\n        if (use_delim) {\n            svp--;\n            use_delim = FALSE;\n        }\n        else if (delim)\n            use_delim = TRUE;\n\n        if (SvTYPE(msv) == SVt_PVAV) {\n            /* we've encountered an interpolated array within\n             * the pattern, e.g. /...@a..../. Expand the list of elements,\n             * then recursively append elements.\n             * The code in this block is based on S_pushav() */\n\n            AV *const av = (AV*)msv;\n            const SSize_t maxarg = AvFILL(av) + 1;\n            SV **array;\n\n            if (oplist) {\n                assert(oplist->op_type == OP_PADAV\n                    || oplist->op_type == OP_RV2AV);\n                oplist = OpSIBLING(oplist);\n            }\n\n            if (SvRMAGICAL(av)) {\n                SSize_t i;\n\n                Newx(array, maxarg, SV*);\n                SAVEFREEPV(array);\n                for (i=0; i < maxarg; i++) {\n                    SV ** const svp = av_fetch(av, i, FALSE);\n                    array[i] = svp ? *svp : &PL_sv_undef;\n                }\n            }\n            else\n                array = AvARRAY(av);\n\n            pat = S_concat_pat(aTHX_ pRExC_state, pat,\n                                array, maxarg, NULL, recompile_p,\n                                /* $\" */\n                                GvSV((gv_fetchpvs(\"\\\"\", GV_ADDMULTI, SVt_PV))));\n\n            continue;\n        }\n\n\n        /* we make the assumption here that each op in the list of\n         * op_siblings maps to one SV pushed onto the stack,\n         * except for code blocks, with have both an OP_NULL and\n         * and OP_CONST.\n         * This allows us to match up the list of SVs against the\n         * list of OPs to find the next code block.\n         *\n         * Note that       PUSHMARK PADSV PADSV ..\n         * is optimised to\n         *                 PADRANGE PADSV  PADSV  ..\n         * so the alignment still works. */\n\n        if (oplist) {\n            if (oplist->op_type == OP_NULL\n                && (oplist->op_flags & OPf_SPECIAL))\n            {\n                assert(n < pRExC_state->code_blocks->count);\n                pRExC_state->code_blocks->cb[n].start = pat ? SvCUR(pat) : 0;\n                pRExC_state->code_blocks->cb[n].block = oplist;\n                pRExC_state->code_blocks->cb[n].src_regex = NULL;\n                n++;\n                code = 1;\n                oplist = OpSIBLING(oplist); /* skip CONST */\n                assert(oplist);\n            }\n            oplist = OpSIBLING(oplist);;\n        }\n\n\t/* apply magic and QR overloading to arg */\n\n        SvGETMAGIC(msv);\n        if (SvROK(msv) && SvAMAGIC(msv)) {\n            SV *sv = AMG_CALLunary(msv, regexp_amg);\n            if (sv) {\n                if (SvROK(sv))\n                    sv = SvRV(sv);\n                if (SvTYPE(sv) != SVt_REGEXP)\n                    Perl_croak(aTHX_ \"Overloaded qr did not return a REGEXP\");\n                msv = sv;\n            }\n        }\n\n        /* try concatenation overload ... */\n        if (pat && (SvAMAGIC(pat) || SvAMAGIC(msv)) &&\n                (sv = amagic_call(pat, msv, concat_amg, AMGf_assign)))\n        {\n            sv_setsv(pat, sv);\n            /* overloading involved: all bets are off over literal\n             * code. Pretend we haven't seen it */\n            if (n)\n                pRExC_state->code_blocks->count -= n;\n            n = 0;\n        }\n        else  {\n            /* ... or failing that, try \"\" overload */\n            while (SvAMAGIC(msv)\n                    && (sv = AMG_CALLunary(msv, string_amg))\n                    && sv != msv\n                    &&  !(   SvROK(msv)\n                          && SvROK(sv)\n                          && SvRV(msv) == SvRV(sv))\n            ) {\n                msv = sv;\n                SvGETMAGIC(msv);\n            }\n            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)\n                msv = SvRV(msv);\n\n            if (pat) {\n                /* this is a partially unrolled\n                 *     sv_catsv_nomg(pat, msv);\n                 * that allows us to adjust code block indices if\n                 * needed */\n                STRLEN dlen;\n                char *dst = SvPV_force_nomg(pat, dlen);\n                orig_patlen = dlen;\n                if (SvUTF8(msv) && !SvUTF8(pat)) {\n                    S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &dst, &dlen, n);\n                    sv_setpvn(pat, dst, dlen);\n                    SvUTF8_on(pat);\n                }\n                sv_catsv_nomg(pat, msv);\n                rx = msv;\n            }\n            else {\n                /* We have only one SV to process, but we need to verify\n                 * it is properly null terminated or we will fail asserts\n                 * later. In theory we probably shouldn't get such SV's,\n                 * but if we do we should handle it gracefully. */\n                if ( SvTYPE(msv) != SVt_PV || (SvLEN(msv) > SvCUR(msv) && *(SvEND(msv)) == 0) ) {\n                    /* not a string, or a string with a trailing null */\n                    pat = msv;\n                } else {\n                    /* a string with no trailing null, we need to copy it\n                     * so it we have a trailing null */\n                    pat = newSVsv(msv);\n                }\n            }\n\n            if (code)\n                pRExC_state->code_blocks->cb[n-1].end = SvCUR(pat)-1;\n        }\n\n        /* extract any code blocks within any embedded qr//'s */\n        if (rx && SvTYPE(rx) == SVt_REGEXP\n            && RX_ENGINE((REGEXP*)rx)->op_comp)\n        {\n\n            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);\n            if (ri->code_blocks && ri->code_blocks->count) {\n                int i;\n                /* the presence of an embedded qr// with code means\n                 * we should always recompile: the text of the\n                 * qr// may not have changed, but it may be a\n                 * different closure than last time */\n                *recompile_p = 1;\n                if (pRExC_state->code_blocks) {\n                    int new_count = pRExC_state->code_blocks->count\n                            + ri->code_blocks->count;\n                    Renew(pRExC_state->code_blocks->cb,\n                            new_count, struct reg_code_block);\n                    pRExC_state->code_blocks->count = new_count;\n                }\n                else\n                    pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_\n                                                    ri->code_blocks->count);\n\n                for (i=0; i < ri->code_blocks->count; i++) {\n                    struct reg_code_block *src, *dst;\n                    STRLEN offset =  orig_patlen\n                        + ReANY((REGEXP *)rx)->pre_prefix;\n                    assert(n < pRExC_state->code_blocks->count);\n                    src = &ri->code_blocks->cb[i];\n                    dst = &pRExC_state->code_blocks->cb[n];\n                    dst->start\t    = src->start + offset;\n                    dst->end\t    = src->end   + offset;\n                    dst->block\t    = src->block;\n                    dst->src_regex  = (REGEXP*) SvREFCNT_inc( (SV*)\n                                            src->src_regex\n                                                ? src->src_regex\n                                                : (REGEXP*)rx);\n                    n++;\n                }\n            }\n        }\n    }\n    /* avoid calling magic multiple times on a single element e.g. =~ $qr */\n    if (alloced)\n        SvSETMAGIC(pat);\n\n    return pat;\n}\n\n\n\n/* see if there are any run-time code blocks in the pattern.\n * False positives are allowed */\n\nstatic bool\nS_has_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char *pat, STRLEN plen)\n{\n    int n = 0;\n    STRLEN s;\n    \n    PERL_UNUSED_CONTEXT;\n\n    for (s = 0; s < plen; s++) {\n\tif (   pRExC_state->code_blocks\n            && n < pRExC_state->code_blocks->count\n\t    && s == pRExC_state->code_blocks->cb[n].start)\n\t{\n\t    s = pRExC_state->code_blocks->cb[n].end;\n\t    n++;\n\t    continue;\n\t}\n\t/* TODO ideally should handle [..], (#..), /#.../x to reduce false\n\t * positives here */\n\tif (pat[s] == '(' && s+2 <= plen && pat[s+1] == '?' &&\n\t    (pat[s+2] == '{'\n                || (s + 2 <= plen && pat[s+2] == '?' && pat[s+3] == '{'))\n\t)\n\t    return 1;\n    }\n    return 0;\n}\n\n/* Handle run-time code blocks. We will already have compiled any direct\n * or indirect literal code blocks. Now, take the pattern 'pat' and make a\n * copy of it, but with any literal code blocks blanked out and\n * appropriate chars escaped; then feed it into\n *\n *    eval \"qr'modified_pattern'\"\n *\n * For example,\n *\n *       a\\bc(?{\"this was literal\"})def'ghi\\\\jkl(?{\"this is runtime\"})mno\n *\n * becomes\n *\n *    qr'a\\\\bc_______________________def\\'ghi\\\\\\\\jkl(?{\"this is runtime\"})mno'\n *\n * After eval_sv()-ing that, grab any new code blocks from the returned qr\n * and merge them with any code blocks of the original regexp.\n *\n * If the pat is non-UTF8, while the evalled qr is UTF8, don't merge;\n * instead, just save the qr and return FALSE; this tells our caller that\n * the original pattern needs upgrading to utf8.\n */\n\nstatic bool\nS_compile_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n    char *pat, STRLEN plen)\n{\n    SV *qr;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    if (pRExC_state->runtime_code_qr) {\n\t/* this is the second time we've been called; this should\n\t * only happen if the main pattern got upgraded to utf8\n\t * during compilation; re-use the qr we compiled first time\n\t * round (which should be utf8 too)\n\t */\n\tqr = pRExC_state->runtime_code_qr;\n\tpRExC_state->runtime_code_qr = NULL;\n\tassert(RExC_utf8 && SvUTF8(qr));\n    }\n    else {\n\tint n = 0;\n\tSTRLEN s;\n\tchar *p, *newpat;\n\tint newlen = plen + 7; /* allow for \"qr''xx\\0\" extra chars */\n\tSV *sv, *qr_ref;\n\tdSP;\n\n\t/* determine how many extra chars we need for ' and \\ escaping */\n\tfor (s = 0; s < plen; s++) {\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\tnewlen++;\n\t}\n\n\tNewx(newpat, newlen, char);\n\tp = newpat;\n\t*p++ = 'q'; *p++ = 'r'; *p++ = '\\'';\n\n\tfor (s = 0; s < plen; s++) {\n\t    if (   pRExC_state->code_blocks\n\t        && n < pRExC_state->code_blocks->count\n\t\t&& s == pRExC_state->code_blocks->cb[n].start)\n\t    {\n\t\t/* blank out literal code block */\n\t\tassert(pat[s] == '(');\n\t\twhile (s <= pRExC_state->code_blocks->cb[n].end) {\n\t\t    *p++ = '_';\n\t\t    s++;\n\t\t}\n\t\ts--;\n\t\tn++;\n\t\tcontinue;\n\t    }\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\t*p++ = '\\\\';\n\t    *p++ = pat[s];\n\t}\n\t*p++ = '\\'';\n\tif (pRExC_state->pm_flags & RXf_PMf_EXTENDED) {\n\t    *p++ = 'x';\n            if (pRExC_state->pm_flags & RXf_PMf_EXTENDED_MORE) {\n                *p++ = 'x';\n            }\n        }\n\t*p++ = '\\0';\n\tDEBUG_COMPILE_r({\n            Perl_re_printf( aTHX_\n\t\t\"%sre-parsing pattern for runtime code:%s %s\\n\",\n\t\tPL_colors[4],PL_colors[5],newpat);\n\t});\n\n\tsv = newSVpvn_flags(newpat, p-newpat-1, RExC_utf8 ? SVf_UTF8 : 0);\n\tSafefree(newpat);\n\n\tENTER;\n\tSAVETMPS;\n\tsave_re_context();\n\tPUSHSTACKi(PERLSI_REQUIRE);\n        /* G_RE_REPARSING causes the toker to collapse \\\\ into \\ when\n         * parsing qr''; normally only q'' does this. It also alters\n         * hints handling */\n\teval_sv(sv, G_SCALAR|G_RE_REPARSING);\n\tSvREFCNT_dec_NN(sv);\n\tSPAGAIN;\n\tqr_ref = POPs;\n\tPUTBACK;\n\t{\n\t    SV * const errsv = ERRSV;\n\t    if (SvTRUE_NN(errsv))\n                /* use croak_sv ? */\n\t\tPerl_croak_nocontext(\"%\" SVf, SVfARG(errsv));\n\t}\n\tassert(SvROK(qr_ref));\n\tqr = SvRV(qr_ref);\n\tassert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);\n\t/* the leaving below frees the tmp qr_ref.\n\t * Give qr a life of its own */\n\tSvREFCNT_inc(qr);\n\tPOPSTACK;\n\tFREETMPS;\n\tLEAVE;\n\n    }\n\n    if (!RExC_utf8 && SvUTF8(qr)) {\n\t/* first time through; the pattern got upgraded; save the\n\t * qr for the next time through */\n\tassert(!pRExC_state->runtime_code_qr);\n\tpRExC_state->runtime_code_qr = qr;\n\treturn 0;\n    }\n\n\n    /* extract any code blocks within the returned qr//  */\n\n\n    /* merge the main (r1) and run-time (r2) code blocks into one */\n    {\n\tRXi_GET_DECL(ReANY((REGEXP *)qr), r2);\n\tstruct reg_code_block *new_block, *dst;\n\tRExC_state_t * const r1 = pRExC_state; /* convenient alias */\n\tint i1 = 0, i2 = 0;\n        int r1c, r2c;\n\n\tif (!r2->code_blocks || !r2->code_blocks->count) /* we guessed wrong */\n\t{\n\t    SvREFCNT_dec_NN(qr);\n\t    return 1;\n\t}\n\n        if (!r1->code_blocks)\n            r1->code_blocks = S_alloc_code_blocks(aTHX_ 0);\n\n        r1c = r1->code_blocks->count;\n        r2c = r2->code_blocks->count;\n\n\tNewx(new_block, r1c + r2c, struct reg_code_block);\n\n\tdst = new_block;\n\n\twhile (i1 < r1c || i2 < r2c) {\n\t    struct reg_code_block *src;\n\t    bool is_qr = 0;\n\n\t    if (i1 == r1c) {\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t    }\n\t    else if (i2 == r2c)\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t    else if (  r1->code_blocks->cb[i1].start\n\t             < r2->code_blocks->cb[i2].start)\n\t    {\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t\tassert(src->end < r2->code_blocks->cb[i2].start);\n\t    }\n\t    else {\n\t\tassert(  r1->code_blocks->cb[i1].start\n\t\t       > r2->code_blocks->cb[i2].start);\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t\tassert(src->end < r1->code_blocks->cb[i1].start);\n\t    }\n\n\t    assert(pat[src->start] == '(');\n\t    assert(pat[src->end]   == ')');\n\t    dst->start\t    = src->start;\n\t    dst->end\t    = src->end;\n\t    dst->block\t    = src->block;\n\t    dst->src_regex  = is_qr ? (REGEXP*) SvREFCNT_inc( (SV*) qr)\n\t\t\t\t    : src->src_regex;\n\t    dst++;\n\t}\n\tr1->code_blocks->count += r2c;\n\tSafefree(r1->code_blocks->cb);\n\tr1->code_blocks->cb = new_block;\n    }\n\n    SvREFCNT_dec_NN(qr);\n    return 1;\n}\n\n\nSTATIC bool\nS_setup_longest(pTHX_ RExC_state_t *pRExC_state,\n                      struct reg_substr_datum  *rsd,\n                      struct scan_data_substrs *sub,\n                      STRLEN longest_length)\n{\n    /* This is the common code for setting up the floating and fixed length\n     * string data extracted from Perl_re_op_compile() below.  Returns a boolean\n     * as to whether succeeded or not */\n\n    I32 t;\n    SSize_t ml;\n    bool eol  = cBOOL(sub->flags & SF_BEFORE_EOL);\n    bool meol = cBOOL(sub->flags & SF_BEFORE_MEOL);\n\n    if (! (longest_length\n           || (eol /* Can't have SEOL and MULTI */\n               && (! meol || (RExC_flags & RXf_PMf_MULTILINE)))\n          )\n            /* See comments for join_exact for why REG_UNFOLDED_MULTI_SEEN */\n        || (RExC_seen & REG_UNFOLDED_MULTI_SEEN))\n    {\n        return FALSE;\n    }\n\n    /* copy the information about the longest from the reg_scan_data\n        over to the program. */\n    if (SvUTF8(sub->str)) {\n        rsd->substr      = NULL;\n        rsd->utf8_substr = sub->str;\n    } else {\n        rsd->substr      = sub->str;\n        rsd->utf8_substr = NULL;\n    }\n    /* end_shift is how many chars that must be matched that\n        follow this item. We calculate it ahead of time as once the\n        lookbehind offset is added in we lose the ability to correctly\n        calculate it.*/\n    ml = sub->minlenp ? *(sub->minlenp) : (SSize_t)longest_length;\n    rsd->end_shift = ml - sub->min_offset\n        - longest_length\n            /* XXX SvTAIL is always false here - did you mean FBMcf_TAIL\n             * intead? - DAPM\n            + (SvTAIL(sub->str) != 0)\n            */\n        + sub->lookbehind;\n\n    t = (eol/* Can't have SEOL and MULTI */\n         && (! meol || (RExC_flags & RXf_PMf_MULTILINE)));\n    fbm_compile(sub->str, t ? FBMcf_TAIL : 0);\n\n    return TRUE;\n}\n\n/*\n * Perl_re_op_compile - the perl internal RE engine's function to compile a\n * regular expression into internal code.\n * The pattern may be passed either as:\n *    a list of SVs (patternp plus pat_count)\n *    a list of OPs (expr)\n * If both are passed, the SV list is used, but the OP list indicates\n * which SVs are actually pre-compiled code blocks\n *\n * The SVs in the list have magic and qr overloading applied to them (and\n * the list may be modified in-place with replacement SVs in the latter\n * case).\n *\n * If the pattern hasn't changed from old_re, then old_re will be\n * returned.\n *\n * eng is the current engine. If that engine has an op_comp method, then\n * handle directly (i.e. we assume that op_comp was us); otherwise, just\n * do the initial concatenation of arguments and pass on to the external\n * engine.\n *\n * If is_bare_re is not null, set it to a boolean indicating whether the\n * arg list reduced (after overloading) to a single bare regex which has\n * been returned (i.e. /$qr/).\n *\n * orig_rx_flags contains RXf_* flags. See perlreapi.pod for more details.\n *\n * pm_flags contains the PMf_* flags, typically based on those from the\n * pm_flags field of the related PMOP. Currently we're only interested in\n * PMf_HAS_CV, PMf_IS_QR, PMf_USE_RE_EVAL.\n *\n * We can't allocate space until we know how big the compiled form will be,\n * but we can't compile it (and thus know how big it is) until we've got a\n * place to put the code.  So we cheat:  we compile it twice, once with code\n * generation turned off and size counting turned on, and once \"for real\".\n * This also means that we don't allocate space until we are sure that the\n * thing really will compile successfully, and we never have to move the\n * code and thus invalidate pointers into it.  (Note that it has to be in\n * one piece because free() must be able to free it all.) [NB: not true in perl]\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.  [I'll say.]\n */\n\nREGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags)\n{\n    REGEXP *rx;\n    struct regexp *r;\n    regexp_internal *ri;\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_AboveLatin1) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n\tPL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);\n\tPL_Latin1 = _new_invlist_C_array(Latin1_invlist);\n\tPL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);\n        PL_utf8_foldable = _new_invlist_C_array(_Perl_Any_Folds_invlist);\n        PL_HasMultiCharFold =\n                       _new_invlist_C_array(_Perl_Folds_To_Multi_Char_invlist);\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n\n    RExC_uni_semantics = 0;\n    RExC_seen_unfolded_sharp_s = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4],PL_colors[5],s);\n        });\n\n  redo_first_pass:\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    rx_flags = orig_rx_flags;\n\n    if (   initial_charset == REGEX_DEPENDS_CHARSET\n        && (RExC_utf8 ||RExC_uni_semantics))\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    RExC_precomp = exp;\n    RExC_precomp_adj = 0;\n    RExC_flags = rx_flags;\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_first_pass;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n    RExC_extralen = 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    /* First pass: determine size, legality. */\n    RExC_parse = exp;\n    RExC_start = RExC_adjusted_start = exp;\n    RExC_end = exp + plen;\n    RExC_precomp_end = RExC_end;\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_nestroot = 0;\n    RExC_size = 0L;\n    RExC_emit = (regnode *) &RExC_emit_dummy;\n    RExC_whilem_seen = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_end_op = NULL;\n    RExC_paren_names = NULL;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    DEBUG_PARSE_r(\n        Perl_re_printf( aTHX_  \"Starting first pass (sizing)\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    );\n\n    if (reg(pRExC_state, 0, &flags,1) == NULL) {\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & RESTART_PASS1) {\n            if (flags & NEED_UTF8) {\n                S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            }\n            else {\n                DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Need to redo pass 1\\n\"));\n            }\n\n            goto redo_first_pass;\n        }\n        Perl_croak(aTHX_ \"panic: reg returned NULL to re_op_compile for sizing pass, flags=%#\" UVxf, (UV) flags);\n    }\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\"\n            \"Starting second pass (creation)\\n\",\n            (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* The first pass could have found things that force Unicode semantics */\n    if ((RExC_utf8 || RExC_uni_semantics)\n\t && get_regex_charset(rx_flags) == REGEX_DEPENDS_CHARSET)\n    {\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    /* Small enough for pointer-storage convention?\n       If extralen==0, this means that we will not need long jumps. */\n    if (RExC_size >= 0x10000L && RExC_extralen)\n        RExC_size += RExC_extralen;\n    else\n\tRExC_extralen = 0;\n    if (RExC_whilem_seen > 15)\n\tRExC_whilem_seen = 15;\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    r = ReANY(rx);\n    Newxc(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),\n\t char, regexp_internal);\n    if ( r == NULL || ri == NULL )\n\tFAIL(\"Regexp out of space\");\n#ifdef DEBUGGING\n    /* avoid reading uninitialized memory in DEBUGGING code in study_chunk() */\n    Zero(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),\n         char);\n#else\n    /* bulk initialize base fields with 0. */\n    Zero(ri, sizeof(regexp_internal), char);\n#endif\n\n    /* non-zero initialization begins here */\n    RXi_SET( r, ri );\n    r->engine= eng;\n    r->extflags = rx_flags;\n    RXp_COMPFLAGS(r) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tri->code_blocks = pRExC_state->code_blocks;\n\tif (ri->code_blocks)\n            ri->code_blocks->refcnt++;\n    }\n\n    {\n        bool has_p     = ((r->extflags & RXf_PMf_KEEPCOPY) == RXf_PMf_KEEPCOPY);\n        bool has_charset = (get_regex_charset(r->extflags)\n                                                    != REGEX_DEPENDS_CHARSET);\n\n        /* The caret is output if there are any defaults: if not all the STD\n         * flags are set, or if no character set specifier is needed */\n        bool has_default =\n                    (((r->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD)\n                    || ! has_charset);\n        bool has_runon = ((RExC_seen & REG_RUN_ON_COMMENT_SEEN)\n                                                   == REG_RUN_ON_COMMENT_SEEN);\n\tU8 reganch = (U8)((r->extflags & RXf_PMf_STD_PMMOD)\n\t\t\t    >> RXf_PMf_STD_PMMOD_SHIFT);\n\tconst char *fptr = STD_PAT_MODS;        /*\"msixxn\"*/\n\tchar *p;\n\n        /* We output all the necessary flags; we never output a minus, as all\n         * those are defaults, so are\n         * covered by the caret */\n\tconst STRLEN wraplen = plen + has_p + has_runon\n            + has_default       /* If needs a caret */\n            + PL_bitcount[reganch] /* 1 char for each set standard flag */\n\n\t\t/* If needs a character set specifier */\n\t    + ((has_charset) ? MAX_CHARSET_NAME_LENGTH : 0)\n            + (sizeof(\"(?:)\") - 1);\n\n        /* make sure PL_bitcount bounds not exceeded */\n        assert(sizeof(STD_PAT_MODS) <= 8);\n\n        p = sv_grow(MUTABLE_SV(rx), wraplen + 1); /* +1 for the ending NUL */\n        SvPOK_on(rx);\n\tif (RExC_utf8)\n\t    SvFLAGS(rx) |= SVf_UTF8;\n        *p++='('; *p++='?';\n\n        /* If a default, cover it using the caret */\n        if (has_default) {\n            *p++= DEFAULT_PAT_MOD;\n        }\n        if (has_charset) {\n\t    STRLEN len;\n\t    const char* const name = get_regex_charset_name(r->extflags, &len);\n\t    Copy(name, p, len, char);\n\t    p += len;\n        }\n        if (has_p)\n            *p++ = KEEPCOPY_PAT_MOD; /*'p'*/\n        {\n            char ch;\n            while((ch = *fptr++)) {\n                if(reganch & 1)\n                    *p++ = ch;\n                reganch >>= 1;\n            }\n        }\n\n        *p++ = ':';\n        Copy(RExC_precomp, p, plen, char);\n\tassert ((RX_WRAPPED(rx) - p) < 16);\n\tr->pre_prefix = p - RX_WRAPPED(rx);\n        p += plen;\n        if (has_runon)\n            *p++ = '\\n';\n        *p++ = ')';\n        *p = 0;\n\tSvCUR_set(rx, p - RX_WRAPPED(rx));\n    }\n\n    r->intflags = 0;\n    r->nparens = RExC_npar - 1;\t/* set early to validate backrefs */\n\n    /* Useful during FAIL. */\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    Newxz(ri->u.offsets, 2*RExC_size+1, U32); /* MJD 20001228 */\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          ri->u.offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((2*RExC_size+1) * sizeof(U32))));\n#endif\n    SetProgLen(ri,RExC_size);\n    RExC_rx_sv = rx;\n    RExC_rx = r;\n    RExC_rxi = ri;\n\n    /* Second pass: emit code. */\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_pm_flags = pm_flags;\n    RExC_parse = exp;\n    RExC_end = exp + plen;\n    RExC_naughty = 0;\n    RExC_emit_start = ri->program;\n    RExC_emit = ri->program;\n    RExC_emit_bound = ri->program + RExC_size + 1;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit++) = (char) REG_MAGIC;\n    /* setup various meta data about recursion, this all requires\n     * RExC_npar to be correctly set, and a bit later on we clear it */\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n            \"%*s%*s Setting up open/close parens\\n\",\n                  22, \"|    |\", (int)(0 * 2 + 1), \"\"));\n\n        /* setup RExC_open_parens, which holds the address of each\n         * OPEN tag, and to make things simpler for the 0 index\n         * the start of the program - this is used later for offsets */\n        Newxz(RExC_open_parens, RExC_npar,regnode *);\n        SAVEFREEPV(RExC_open_parens);\n        RExC_open_parens[0] = RExC_emit;\n\n        /* setup RExC_close_parens, which holds the address of each\n         * CLOSE tag, and to make things simpler for the 0 index\n         * the end of the program - this is used later for offsets */\n        Newxz(RExC_close_parens, RExC_npar,regnode *);\n        SAVEFREEPV(RExC_close_parens);\n        /* we dont know where end op starts yet, so we dont\n         * need to set RExC_close_parens[0] like we do RExC_open_parens[0] above */\n\n        /* Note, RExC_npar is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_npar >> 3) +\n                                         ((RExC_npar & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_npar, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n    RExC_npar = 1;\n    if (reg(pRExC_state, 0, &flags,1) == NULL) {\n\tReREFCNT_dec(rx);\n        Perl_croak(aTHX_ \"panic: reg returned NULL to re_op_compile for generation pass, flags=%#\" UVxf, (UV) flags);\n    }\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(r->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse,RExC_recurse_count,regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n  reStudy:\n    r->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(r->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_npar, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    r->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(rx);\t/* Unicode in it? */\n    ri->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tr->intflags |= PREGf_NAUGHTY;\n    scan = ri->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (OP(first) == EXACT || OP(first) == EXACTL)\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n\t    else\n\t\tri->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)ri->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            ri->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    ri->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    ri->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            r->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            r->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(r->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            r->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    r->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!ri->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_npar == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    r->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen,0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(r->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                r->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                r->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    r->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                r->substrs->data[i].substr      = NULL;\n                r->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (ri->regstclass\n\t    && (OP(ri->regstclass) == REG_ANY || OP(ri->regstclass) == SANY))\n\t    ri->regstclass = NULL;\n\n\tif ((!(r->substrs->data[0].substr || r->substrs->data[0].utf8_substr)\n              || r->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    ri->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    r->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        r->substrs->check_ix = i;\n        r->check_end_shift  = r->substrs->data[i].end_shift;\n        r->check_substr     = r->substrs->data[i].substr;\n        r->check_utf8       = r->substrs->data[i].utf8_substr;\n        r->check_offset_min = r->substrs->data[i].min_offset;\n        r->check_offset_max = r->substrs->data[i].max_offset;\n        if (!i && (r->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            r->intflags |= PREGf_NOSCAN;\n\n\tif ((r->check_substr || r->check_utf8) ) {\n\t    r->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(r->check_substr ? r->check_substr : r->check_utf8))\n\t\tr->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = ri->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tr->check_substr = NULL;\n        r->check_utf8 = NULL;\n        r->substrs->data[0].substr      = NULL;\n        r->substrs->data[0].utf8_substr = NULL;\n        r->substrs->data[1].substr      = NULL;\n        r->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    ri->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    r->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        r->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        r->maxlen = REG_INFTY;\n    }\n    else {\n        r->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" r->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)r->minlen, (IV)RExC_maxlen);\n    });\n    r->minlenret = minlen;\n    if (r->minlen < minlen)\n        r->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        r->intflags |= PREGf_RECURSE_SEEN;\n        Newx(r->recurse_locinput, r->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        r->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        r->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tr->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tr->intflags |= PREGf_VERBARG_SEEN;\n        r->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tr->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tr->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(r) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(r) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (r->intflags & PREGf_ANCH)\n        r->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = ri->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            r->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            r->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            r->extflags |= RXf_WHITE;\n        else if ( r->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            r->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(r) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        ri->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        ri->data->data[ri->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    ri->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - scan );\n    }\n\n    Newxz(r->offs, RExC_npar, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(r);\n    });\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(if (ri->u.offsets) {\n        const STRLEN len = ri->u.offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)ri->u.offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (ri->u.offsets[i*2-1] || ri->u.offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)ri->u.offsets[i*2-1], (UV)ri->u.offsets[i*2]);\n            }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n#endif\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(rx);\n#endif\n    return rx;\n}\n\n\nSV*\nPerl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value,\n                    const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF;\n\n    PERL_UNUSED_ARG(value);\n\n    if (flags & RXapif_FETCH) {\n        return reg_named_buff_fetch(rx, key, flags);\n    } else if (flags & (RXapif_STORE | RXapif_DELETE | RXapif_CLEAR)) {\n        Perl_croak_no_modify();\n        return NULL;\n    } else if (flags & RXapif_EXISTS) {\n        return reg_named_buff_exists(rx, key, flags)\n            ? &PL_sv_yes\n            : &PL_sv_no;\n    } else if (flags & RXapif_REGNAMES) {\n        return reg_named_buff_all(rx, flags);\n    } else if (flags & (RXapif_SCALAR | RXapif_REGNAMES_COUNT)) {\n        return reg_named_buff_scalar(rx, flags);\n    } else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff\", (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey,\n                         const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER;\n    PERL_UNUSED_ARG(lastkey);\n\n    if (flags & RXapif_FIRSTKEY)\n        return reg_named_buff_firstkey(rx, flags);\n    else if (flags & RXapif_NEXTKEY)\n        return reg_named_buff_nextkey(rx, flags);\n    else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_iter\",\n                                            (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_fetch(pTHX_ REGEXP * const r, SV * const namesv,\n\t\t\t  const U32 flags)\n{\n    SV *ret;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HE *he_str = hv_fetch_ent( RXp_PAREN_NAMES(rx), namesv, 0, 0 );\n        if (he_str) {\n            IV i;\n            SV* sv_dat=HeVAL(he_str);\n            I32 *nums=(I32*)SvPVX(sv_dat);\n            AV * const retarray = (flags & RXapif_ALL) ? newAV() : NULL;\n            for ( i=0; i<SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->nparens) >= nums[i]\n                    && rx->offs[nums[i]].start != -1\n                    && rx->offs[nums[i]].end != -1)\n                {\n                    ret = newSVpvs(\"\");\n                    CALLREG_NUMBUF_FETCH(r,nums[i],ret);\n                    if (!retarray)\n                        return ret;\n                } else {\n                    if (retarray)\n                        ret = newSVsv(&PL_sv_undef);\n                }\n                if (retarray)\n                    av_push(retarray, ret);\n            }\n            if (retarray)\n                return newRV_noinc(MUTABLE_SV(retarray));\n        }\n    }\n    return NULL;\n}\n\nbool\nPerl_reg_named_buff_exists(pTHX_ REGEXP * const r, SV * const key,\n                           const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & RXapif_ALL) {\n            return hv_exists_ent(RXp_PAREN_NAMES(rx), key, 0);\n        } else {\n\t    SV *sv = CALLREG_NAMED_BUFF_FETCH(r, key, flags);\n            if (sv) {\n\t\tSvREFCNT_dec_NN(sv);\n                return TRUE;\n            } else {\n                return FALSE;\n            }\n        }\n    } else {\n        return FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_firstkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY;\n\n    if ( rx && RXp_PAREN_NAMES(rx) ) {\n\t(void)hv_iterinit(RXp_PAREN_NAMES(rx));\n\n\treturn CALLREG_NAMED_BUFF_NEXTKEY(r, NULL, flags & ~RXapif_FIRSTKEY);\n    } else {\n\treturn FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv,0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;\n}\n\nSV*\nPerl_reg_named_buff_scalar(pTHX_ REGEXP * const r, const U32 flags)\n{\n    SV *ret;\n    AV *av;\n    SSize_t length;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & (RXapif_ALL | RXapif_REGNAMES_COUNT)) {\n            return newSViv(HvTOTALKEYS(RXp_PAREN_NAMES(rx)));\n        } else if (flags & RXapif_ONE) {\n            ret = CALLREG_NAMED_BUFF_ALL(r, (flags | RXapif_REGNAMES));\n            av = MUTABLE_AV(SvRV(ret));\n            length = av_tindex(av);\n\t    SvREFCNT_dec_NN(ret);\n            return newSViv(length + 1);\n        } else {\n            Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_scalar\",\n                                                (int)flags);\n            return NULL;\n        }\n    }\n    return &PL_sv_undef;\n}\n\nSV*\nPerl_reg_named_buff_all(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    AV *av = newAV();\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv= RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        (void)hv_iterinit(hv);\n        while ( (temphe = hv_iternext_flags(hv,0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n                av_push(av, newSVhek(HeKEY_hek(temphe)));\n            }\n        }\n    }\n\n    return newRV_noinc(MUTABLE_SV(av));\n}\n\nvoid\nPerl_reg_numbered_buff_fetch(pTHX_ REGEXP * const r, const I32 paren,\n\t\t\t     SV * const sv)\n{\n    struct regexp *const rx = ReANY(r);\n    char *s = NULL;\n    SSize_t i = 0;\n    SSize_t s1, t1;\n    I32 n = paren;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH;\n\n    if (      n == RX_BUFF_IDX_CARET_PREMATCH\n           || n == RX_BUFF_IDX_CARET_FULLMATCH\n           || n == RX_BUFF_IDX_CARET_POSTMATCH\n       )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto ret_undef;\n    }\n\n    if (!rx->subbeg)\n        goto ret_undef;\n\n    if (n == RX_BUFF_IDX_CARET_FULLMATCH)\n        /* no need to distinguish between them any more */\n        n = RX_BUFF_IDX_FULLMATCH;\n\n    if ((n == RX_BUFF_IDX_PREMATCH || n == RX_BUFF_IDX_CARET_PREMATCH)\n        && rx->offs[0].start != -1)\n    {\n        /* $`, ${^PREMATCH} */\n\ti = rx->offs[0].start;\n\ts = rx->subbeg;\n    }\n    else\n    if ((n == RX_BUFF_IDX_POSTMATCH || n == RX_BUFF_IDX_CARET_POSTMATCH)\n        && rx->offs[0].end != -1)\n    {\n        /* $', ${^POSTMATCH} */\n\ts = rx->subbeg - rx->suboffset + rx->offs[0].end;\n\ti = rx->sublen + rx->suboffset - rx->offs[0].end;\n    }\n    else\n    if ( 0 <= n && n <= (I32)rx->nparens &&\n        (s1 = rx->offs[n].start) != -1 &&\n        (t1 = rx->offs[n].end) != -1)\n    {\n        /* $&, ${^MATCH},  $1 ... */\n        i = t1 - s1;\n        s = rx->subbeg + s1 - rx->suboffset;\n    } else {\n        goto ret_undef;\n    }\n\n    assert(s >= rx->subbeg);\n    assert((STRLEN)rx->sublen >= (STRLEN)((s - rx->subbeg) + i) );\n    if (i >= 0) {\n#ifdef NO_TAINT_SUPPORT\n        sv_setpvn(sv, s, i);\n#else\n        const int oldtainted = TAINT_get;\n        TAINT_NOT;\n        sv_setpvn(sv, s, i);\n        TAINT_set(oldtainted);\n#endif\n        if (RXp_MATCH_UTF8(rx))\n            SvUTF8_on(sv);\n        else\n            SvUTF8_off(sv);\n        if (TAINTING_get) {\n            if (RXp_MATCH_TAINTED(rx)) {\n                if (SvTYPE(sv) >= SVt_PVMG) {\n                    MAGIC* const mg = SvMAGIC(sv);\n                    MAGIC* mgt;\n                    TAINT;\n                    SvMAGIC_set(sv, mg->mg_moremagic);\n                    SvTAINT(sv);\n                    if ((mgt = SvMAGIC(sv))) {\n                        mg->mg_moremagic = mgt;\n                        SvMAGIC_set(sv, mg);\n                    }\n                } else {\n                    TAINT;\n                    SvTAINT(sv);\n                }\n            } else\n                SvTAINTED_off(sv);\n        }\n    } else {\n      ret_undef:\n        sv_set_undef(sv);\n        return;\n    }\n}\n\nvoid\nPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,\n\t\t\t\t\t\t\t SV const * const value)\n{\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;\n\n    PERL_UNUSED_ARG(rx);\n    PERL_UNUSED_ARG(paren);\n    PERL_UNUSED_ARG(value);\n\n    if (!PL_localizing)\n        Perl_croak_no_modify();\n}\n\nI32\nPerl_reg_numbered_buff_length(pTHX_ REGEXP * const r, const SV * const sv,\n                              const I32 paren)\n{\n    struct regexp *const rx = ReANY(r);\n    I32 i;\n    I32 s1, t1;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH;\n\n    if (   paren == RX_BUFF_IDX_CARET_PREMATCH\n        || paren == RX_BUFF_IDX_CARET_FULLMATCH\n        || paren == RX_BUFF_IDX_CARET_POSTMATCH\n    )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto warn_undef;\n    }\n\n    /* Some of this code was originally in C<Perl_magic_len> in F<mg.c> */\n    switch (paren) {\n      case RX_BUFF_IDX_CARET_PREMATCH: /* ${^PREMATCH} */\n      case RX_BUFF_IDX_PREMATCH:       /* $` */\n        if (rx->offs[0].start != -1) {\n\t\t\ti = rx->offs[0].start;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = 0;\n\t\t\t\tt1 = i;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      case RX_BUFF_IDX_CARET_POSTMATCH: /* ${^POSTMATCH} */\n      case RX_BUFF_IDX_POSTMATCH:       /* $' */\n\t    if (rx->offs[0].end != -1) {\n\t\t\ti = rx->sublen - rx->offs[0].end;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = rx->offs[0].end;\n\t\t\t\tt1 = rx->sublen;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      default: /* $& / ${^MATCH}, $1, $2, ... */\n\t    if (paren <= (I32)rx->nparens &&\n            (s1 = rx->offs[paren].start) != -1 &&\n            (t1 = rx->offs[paren].end) != -1)\n\t    {\n            i = t1 - s1;\n            goto getlen;\n        } else {\n          warn_undef:\n            if (ckWARN(WARN_UNINITIALIZED))\n                report_uninit((const SV *)sv);\n            return 0;\n        }\n    }\n  getlen:\n    if (i > 0 && RXp_MATCH_UTF8(rx)) {\n        const char * const s = rx->subbeg - rx->suboffset + s1;\n        const U8 *ep;\n        STRLEN el;\n\n        i = t1 - s1;\n        if (is_utf8_string_loclen((U8*)s, i, &ep, &el))\n\t\t\ti = el;\n    }\n    return i;\n}\n\nSV*\nPerl_reg_qr_package(pTHX_ REGEXP * const rx)\n{\n    PERL_ARGS_ASSERT_REG_QR_PACKAGE;\n\tPERL_UNUSED_ARG(rx);\n\tif (0)\n\t    return NULL;\n\telse\n\t    return newSVpvs(\"Regexp\");\n}\n\n/* Scans the name of a named buffer from the pattern.\n * If flags is REG_RSN_RETURN_NULL returns null.\n * If flags is REG_RSN_RETURN_NAME returns an SV* containing the name\n * If flags is REG_RSN_RETURN_DATA returns the data SV* corresponding\n * to the parsed name as looked up in the RExC_paren_names hash.\n * If there is an error throws a vFAIL().. type exception.\n */\n\n#define REG_RSN_RETURN_NULL    0\n#define REG_RSN_RETURN_NAME    1\n#define REG_RSN_RETURN_DATA    2\n\nSTATIC SV*\nS_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags)\n{\n    char *name_start = RExC_parse;\n\n    PERL_ARGS_ASSERT_REG_SCAN_NAME;\n\n    assert (RExC_parse <= RExC_end);\n    if (RExC_parse == RExC_end) NOOP;\n    else if (isIDFIRST_lazy_if_safe(RExC_parse, RExC_end, UTF)) {\n         /* Note that the code here assumes well-formed UTF-8.  Skip IDFIRST by\n          * using do...while */\n\tif (UTF)\n\t    do {\n\t\tRExC_parse += UTF8SKIP(RExC_parse);\n\t    } while (   RExC_parse < RExC_end\n                     && isWORDCHAR_utf8_safe((U8*)RExC_parse, (U8*) RExC_end));\n\telse\n\t    do {\n\t\tRExC_parse++;\n\t    } while (RExC_parse < RExC_end && isWORDCHAR(*RExC_parse));\n    } else {\n        RExC_parse++; /* so the <- from the vFAIL is after the offending\n                         character */\n        vFAIL(\"Group name must start with a non-digit word character\");\n    }\n    if ( flags ) {\n        SV* sv_name\n\t    = newSVpvn_flags(name_start, (int)(RExC_parse - name_start),\n\t\t\t     SVs_TEMP | (UTF ? SVf_UTF8 : 0));\n        if ( flags == REG_RSN_RETURN_NAME)\n            return sv_name;\n        else if (flags==REG_RSN_RETURN_DATA) {\n            HE *he_str = NULL;\n            SV *sv_dat = NULL;\n            if ( ! sv_name )      /* should not happen*/\n                Perl_croak(aTHX_ \"panic: no svname in reg_scan_name\");\n            if (RExC_paren_names)\n                he_str = hv_fetch_ent( RExC_paren_names, sv_name, 0, 0 );\n            if ( he_str )\n                sv_dat = HeVAL(he_str);\n            if ( ! sv_dat )\n                vFAIL(\"Reference to nonexistent named group\");\n            return sv_dat;\n        }\n        else {\n            Perl_croak(aTHX_ \"panic: bad flag %lx in reg_scan_name\",\n\t\t       (unsigned long) flags);\n        }\n        NOT_REACHED; /* NOTREACHED */\n    }\n    return NULL;\n}\n\n#define DEBUG_PARSE_MSG(funcname)     DEBUG_PARSE_r({           \\\n    int num;                                                    \\\n    if (RExC_lastparse!=RExC_parse) {                           \\\n        Perl_re_printf( aTHX_  \"%s\",                                        \\\n            Perl_pv_pretty(aTHX_ RExC_mysv1, RExC_parse,        \\\n                RExC_end - RExC_parse, 16,                      \\\n                \"\", \"\",                                         \\\n                PERL_PV_ESCAPE_UNI_DETECT |                     \\\n                PERL_PV_PRETTY_ELLIPSES   |                     \\\n                PERL_PV_PRETTY_LTGT       |                     \\\n                PERL_PV_ESCAPE_RE         |                     \\\n                PERL_PV_PRETTY_EXACTSIZE                        \\\n            )                                                   \\\n        );                                                      \\\n    } else                                                      \\\n        Perl_re_printf( aTHX_ \"%16s\",\"\");                                   \\\n                                                                \\\n    if (SIZE_ONLY)                                              \\\n       num = RExC_size + 1;                                     \\\n    else                                                        \\\n       num=REG_NODE_NUM(RExC_emit);                             \\\n    if (RExC_lastnum!=num)                                      \\\n       Perl_re_printf( aTHX_ \"|%4d\",num);                                   \\\n    else                                                        \\\n       Perl_re_printf( aTHX_ \"|%4s\",\"\");                                    \\\n    Perl_re_printf( aTHX_ \"|%*s%-4s\",                                       \\\n        (int)((depth*2)), \"\",                                   \\\n        (funcname)                                              \\\n    );                                                          \\\n    RExC_lastnum=num;                                           \\\n    RExC_lastparse=RExC_parse;                                  \\\n})\n\n\n\n#define DEBUG_PARSE(funcname)     DEBUG_PARSE_r({           \\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ \"%4s\",\"\\n\");                                  \\\n})\n#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({\\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ fmt \"\\n\",args);                               \\\n})\n\n/* This section of code defines the inversion list object and its methods.  The\n * interfaces are highly subject to change, so as much as possible is static to\n * this file.  An inversion list is here implemented as a malloc'd C UV array\n * as an SVt_INVLIST scalar.\n *\n * An inversion list for Unicode is an array of code points, sorted by ordinal\n * number.  Each element gives the code point that begins a range that extends\n * up-to but not including the code point given by the next element.  The final\n * element gives the first code point of a range that extends to the platform's\n * infinity.  The even-numbered elements (invlist[0], invlist[2], invlist[4],\n * ...) give ranges whose code points are all in the inversion list.  We say\n * that those ranges are in the set.  The odd-numbered elements give ranges\n * whose code points are not in the inversion list, and hence not in the set.\n * Thus, element [0] is the first code point in the list.  Element [1]\n * is the first code point beyond that not in the list; and element [2] is the\n * first code point beyond that that is in the list.  In other words, the first\n * range is invlist[0]..(invlist[1]-1), and all code points in that range are\n * in the inversion list.  The second range is invlist[1]..(invlist[2]-1), and\n * all code points in that range are not in the inversion list.  The third\n * range invlist[2]..(invlist[3]-1) gives code points that are in the inversion\n * list, and so forth.  Thus every element whose index is divisible by two\n * gives the beginning of a range that is in the list, and every element whose\n * index is not divisible by two gives the beginning of a range not in the\n * list.  If the final element's index is divisible by two, the inversion list\n * extends to the platform's infinity; otherwise the highest code point in the\n * inversion list is the contents of that element minus 1.\n *\n * A range that contains just a single code point N will look like\n *  invlist[i]   == N\n *  invlist[i+1] == N+1\n *\n * If N is UV_MAX (the highest representable code point on the machine), N+1 is\n * impossible to represent, so element [i+1] is omitted.  The single element\n * inversion list\n *  invlist[0] == UV_MAX\n * contains just UV_MAX, but is interpreted as matching to infinity.\n *\n * Taking the complement (inverting) an inversion list is quite simple, if the\n * first element is 0, remove it; otherwise add a 0 element at the beginning.\n * This implementation reserves an element at the beginning of each inversion\n * list to always contain 0; there is an additional flag in the header which\n * indicates if the list begins at the 0, or is offset to begin at the next\n * element.  This means that the inversion list can be inverted without any\n * copying; just flip the flag.\n *\n * More about inversion lists can be found in \"Unicode Demystified\"\n * Chapter 13 by Richard Gillam, published by Addison-Wesley.\n *\n * The inversion list data structure is currently implemented as an SV pointing\n * to an array of UVs that the SV thinks are bytes.  This allows us to have an\n * array of UV whose memory management is automatically handled by the existing\n * facilities for SV's.\n *\n * Some of the methods should always be private to the implementation, and some\n * should eventually be made public */\n\n/* The header definitions are in F<invlist_inline.h> */\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV*\nS__invlist_array_init(SV* const invlist, const bool will_have_0)\n{\n    /* Returns a pointer to the first element in the inversion list's array.\n     * This is called upon initialization of an inversion list.  Where the\n     * array begins depends on whether the list has the code point U+0000 in it\n     * or not.  The other parameter tells it whether the code that follows this\n     * call is about to put a 0 in the inversion list or not.  The first\n     * element is either the element reserved for 0, if TRUE, or the element\n     * after it, if FALSE */\n\n    bool* offset = get_invlist_offset_addr(invlist);\n    UV* zero_addr = (UV *) SvPVX(invlist);\n\n    PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT;\n\n    /* Must be empty */\n    assert(! _invlist_len(invlist));\n\n    *zero_addr = 0;\n\n    /* 1^1 = 0; 1^0 = 1 */\n    *offset = 1 ^ will_have_0;\n    return zero_addr + *offset;\n}\n\n#endif\n\nPERL_STATIC_INLINE void\nS_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset)\n{\n    /* Sets the current number of elements stored in the inversion list.\n     * Updates SvCUR correspondingly */\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INVLIST_SET_LEN;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    SvCUR_set(invlist,\n              (len == 0)\n               ? 0\n               : TO_INTERNAL_SIZE(len + offset));\n    assert(SvLEN(invlist) == 0 || SvCUR(invlist) <= SvLEN(invlist));\n}\n\n#ifndef PERL_IN_XSUB_RE\n\nSTATIC void\nS_invlist_replace_list_destroys_src(pTHX_ SV * dest, SV * src)\n{\n    /* Replaces the inversion list in 'dest' with the one from 'src'.  It\n     * steals the list from 'src', so 'src' is made to have a NULL list.  This\n     * is similar to what SvSetMagicSV() would do, if it were implemented on\n     * inversion lists, though this routine avoids a copy */\n\n    const UV src_len          = _invlist_len(src);\n    const bool src_offset     = *get_invlist_offset_addr(src);\n    const STRLEN src_byte_len = SvLEN(src);\n    char * array              = SvPVX(src);\n\n    const int oldtainted = TAINT_get;\n\n    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;\n\n    assert(SvTYPE(src) == SVt_INVLIST);\n    assert(SvTYPE(dest) == SVt_INVLIST);\n    assert(! invlist_is_iterating(src));\n    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));\n\n    /* Make sure it ends in the right place with a NUL, as our inversion list\n     * manipulations aren't careful to keep this true, but sv_usepvn_flags()\n     * asserts it */\n    array[src_byte_len - 1] = '\\0';\n\n    TAINT_NOT;      /* Otherwise it breaks */\n    sv_usepvn_flags(dest,\n                    (char *) array,\n                    src_byte_len - 1,\n\n                    /* This flag is documented to cause a copy to be avoided */\n                    SV_HAS_TRAILING_NUL);\n    TAINT_set(oldtainted);\n    SvPV_set(src, 0);\n    SvLEN_set(src, 0);\n    SvCUR_set(src, 0);\n\n    /* Finish up copying over the other fields in an inversion list */\n    *get_invlist_offset_addr(dest) = src_offset;\n    invlist_set_len(dest, src_len, src_offset);\n    *get_invlist_previous_index_addr(dest) = 0;\n    invlist_iterfinish(dest);\n}\n\nPERL_STATIC_INLINE IV*\nS_get_invlist_previous_index_addr(SV* invlist)\n{\n    /* Return the address of the IV that is reserved to hold the cached index\n     * */\n    PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    return &(((XINVLIST*) SvANY(invlist))->prev_index);\n}\n\nPERL_STATIC_INLINE IV\nS_invlist_previous_index(SV* const invlist)\n{\n    /* Returns cached index of previous search */\n\n    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;\n\n    return *get_invlist_previous_index_addr(invlist);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_set_previous_index(SV* const invlist, const IV index)\n{\n    /* Caches <index> for later retrieval */\n\n    PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX;\n\n    assert(index == 0 || index < (int) _invlist_len(invlist));\n\n    *get_invlist_previous_index_addr(invlist) = index;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_trim(SV* invlist)\n{\n    /* Free the not currently-being-used space in an inversion list */\n\n    /* But don't free up the space needed for the 0 UV that is always at the\n     * beginning of the list, nor the trailing NUL */\n    const UV min_size = TO_INTERNAL_SIZE(1) + 1;\n\n    PERL_ARGS_ASSERT_INVLIST_TRIM;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    SvPV_renew(invlist, MAX(min_size, SvCUR(invlist) + 1));\n}\n\nPERL_STATIC_INLINE void\nS_invlist_clear(pTHX_ SV* invlist)    /* Empty the inversion list */\n{\n    PERL_ARGS_ASSERT_INVLIST_CLEAR;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    invlist_set_len(invlist, 0, 0);\n    invlist_trim(invlist);\n}\n\n#endif /* ifndef PERL_IN_XSUB_RE */\n\nPERL_STATIC_INLINE bool\nS_invlist_is_iterating(SV* const invlist)\n{\n    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;\n\n    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;\n}\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV\nS_invlist_max(SV* const invlist)\n{\n    /* Returns the maximum number of elements storable in the inversion list's\n     * array, without having to realloc() */\n\n    PERL_ARGS_ASSERT_INVLIST_MAX;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    /* Assumes worst case, in which the 0 element is not counted in the\n     * inversion list, so subtracts 1 for that */\n    return SvLEN(invlist) == 0  /* This happens under _new_invlist_C_array */\n           ? FROM_INTERNAL_SIZE(SvCUR(invlist)) - 1\n           : FROM_INTERNAL_SIZE(SvLEN(invlist)) - 1;\n}\nSV*\nPerl__new_invlist(pTHX_ IV initial_size)\n{\n\n    /* Return a pointer to a newly constructed inversion list, with enough\n     * space to store 'initial_size' elements.  If that number is negative, a\n     * system default is used instead */\n\n    SV* new_list;\n\n    if (initial_size < 0) {\n\tinitial_size = 10;\n    }\n\n    /* Allocate the initial space */\n    new_list = newSV_type(SVt_INVLIST);\n\n    /* First 1 is in case the zero element isn't in the list; second 1 is for\n     * trailing NUL */\n    SvGROW(new_list, TO_INTERNAL_SIZE(initial_size + 1) + 1);\n    invlist_set_len(new_list, 0, 0);\n\n    /* Force iterinit() to be used to get iteration to work */\n    *get_invlist_iter_addr(new_list) = (STRLEN) UV_MAX;\n\n    *get_invlist_previous_index_addr(new_list) = 0;\n\n    return new_list;\n}\n\nSV*\nPerl__new_invlist_C_array(pTHX_ const UV* const list)\n{\n    /* Return a pointer to a newly constructed inversion list, initialized to\n     * point to <list>, which has to be in the exact correct inversion list\n     * form, including internal fields.  Thus this is a dangerous routine that\n     * should not be used in the wrong hands.  The passed in 'list' contains\n     * several header fields at the beginning that are not part of the\n     * inversion list body proper */\n\n    const STRLEN length = (STRLEN) list[0];\n    const UV version_id =          list[1];\n    const bool offset   =    cBOOL(list[2]);\n#define HEADER_LENGTH 3\n    /* If any of the above changes in any way, you must change HEADER_LENGTH\n     * (if appropriate) and regenerate INVLIST_VERSION_ID by running\n     *      perl -E 'say int(rand 2**31-1)'\n     */\n#define INVLIST_VERSION_ID 148565664 /* This is a combination of a version and\n                                        data structure type, so that one being\n                                        passed in can be validated to be an\n                                        inversion list of the correct vintage.\n                                       */\n\n    SV* invlist = newSV_type(SVt_INVLIST);\n\n    PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY;\n\n    if (version_id != INVLIST_VERSION_ID) {\n        Perl_croak(aTHX_ \"panic: Incorrect version for previously generated inversion list\");\n    }\n\n    /* The generated array passed in includes header elements that aren't part\n     * of the list proper, so start it just after them */\n    SvPV_set(invlist, (char *) (list + HEADER_LENGTH));\n\n    SvLEN_set(invlist, 0);  /* Means we own the contents, and the system\n\t\t\t       shouldn't touch it */\n\n    *(get_invlist_offset_addr(invlist)) = offset;\n\n    /* The 'length' passed to us is the physical number of elements in the\n     * inversion list.  But if there is an offset the logical number is one\n     * less than that */\n    invlist_set_len(invlist, length  - offset, offset);\n\n    invlist_set_previous_index(invlist, 0);\n\n    /* Initialize the iteration pointer. */\n    invlist_iterfinish(invlist);\n\n    SvREADONLY_on(invlist);\n\n    return invlist;\n}\n\nSTATIC void\nS_invlist_extend(pTHX_ SV* const invlist, const UV new_max)\n{\n    /* Grow the maximum size of an inversion list */\n\n    PERL_ARGS_ASSERT_INVLIST_EXTEND;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    /* Add one to account for the zero element at the beginning which may not\n     * be counted by the calling parameters */\n    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max + 1));\n}\n\nSTATIC void\nS__append_range_to_invlist(pTHX_ SV* const invlist,\n                                 const UV start, const UV end)\n{\n   /* Subject to change or removal.  Append the range from 'start' to 'end' at\n    * the end of the inversion list.  The range must be above any existing\n    * ones. */\n\n    UV* array;\n    UV max = invlist_max(invlist);\n    UV len = _invlist_len(invlist);\n    bool offset;\n\n    PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST;\n\n    if (len == 0) { /* Empty lists must be initialized */\n        offset = start != 0;\n        array = _invlist_array_init(invlist, ! offset);\n    }\n    else {\n\t/* Here, the existing list is non-empty. The current max entry in the\n\t * list is generally the first value not in the set, except when the\n\t * set extends to the end of permissible values, in which case it is\n\t * the first entry in that final set, and so this call is an attempt to\n\t * append out-of-order */\n\n\tUV final_element = len - 1;\n\tarray = invlist_array(invlist);\n\tif (   array[final_element] > start\n\t    || ELEMENT_RANGE_MATCHES_INVLIST(final_element))\n\t{\n\t    Perl_croak(aTHX_ \"panic: attempting to append to an inversion list, but wasn't at the end of the list, final=%\" UVuf \", start=%\" UVuf \", match=%c\",\n\t\t     array[final_element], start,\n\t\t     ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');\n\t}\n\n        /* Here, it is a legal append.  If the new range begins 1 above the end\n         * of the range below it, it is extending the range below it, so the\n         * new first value not in the set is one greater than the newly\n         * extended range.  */\n        offset = *get_invlist_offset_addr(invlist);\n\tif (array[final_element] == start) {\n\t    if (end != UV_MAX) {\n\t\tarray[final_element] = end + 1;\n\t    }\n\t    else {\n\t\t/* But if the end is the maximum representable on the machine,\n                 * assume that infinity was actually what was meant.  Just let\n                 * the range that this would extend to have no end */\n\t\tinvlist_set_len(invlist, len - 1, offset);\n\t    }\n\t    return;\n\t}\n    }\n\n    /* Here the new range doesn't extend any existing set.  Add it */\n\n    len += 2;\t/* Includes an element each for the start and end of range */\n\n    /* If wll overflow the existing space, extend, which may cause the array to\n     * be moved */\n    if (max < len) {\n\tinvlist_extend(invlist, len);\n\n        /* Have to set len here to avoid assert failure in invlist_array() */\n        invlist_set_len(invlist, len, offset);\n\n\tarray = invlist_array(invlist);\n    }\n    else {\n\tinvlist_set_len(invlist, len, offset);\n    }\n\n    /* The next item on the list starts the range, the one after that is\n     * one past the new range.  */\n    array[len - 2] = start;\n    if (end != UV_MAX) {\n\tarray[len - 1] = end + 1;\n    }\n    else {\n\t/* But if the end is the maximum representable on the machine, just let\n\t * the range have no end */\n\tinvlist_set_len(invlist, len - 1, offset);\n    }\n}\n\nSSize_t\nPerl__invlist_search(SV* const invlist, const UV cp)\n{\n    /* Searches the inversion list for the entry that contains the input code\n     * point <cp>.  If <cp> is not in the list, -1 is returned.  Otherwise, the\n     * return value is the index into the list's array of the range that\n     * contains <cp>, that is, 'i' such that\n     *\tarray[i] <= cp < array[i+1]\n     */\n\n    IV low = 0;\n    IV mid;\n    IV high = _invlist_len(invlist);\n    const IV highest_element = high - 1;\n    const UV* array;\n\n    PERL_ARGS_ASSERT__INVLIST_SEARCH;\n\n    /* If list is empty, return failure. */\n    if (high == 0) {\n\treturn -1;\n    }\n\n    /* (We can't get the array unless we know the list is non-empty) */\n    array = invlist_array(invlist);\n\n    mid = invlist_previous_index(invlist);\n    assert(mid >=0);\n    if (mid > highest_element) {\n        mid = highest_element;\n    }\n\n    /* <mid> contains the cache of the result of the previous call to this\n     * function (0 the first time).  See if this call is for the same result,\n     * or if it is for mid-1.  This is under the theory that calls to this\n     * function will often be for related code points that are near each other.\n     * And benchmarks show that caching gives better results.  We also test\n     * here if the code point is within the bounds of the list.  These tests\n     * replace others that would have had to be made anyway to make sure that\n     * the array bounds were not exceeded, and these give us extra information\n     * at the same time */\n    if (cp >= array[mid]) {\n        if (cp >= array[highest_element]) {\n            return highest_element;\n        }\n\n        /* Here, array[mid] <= cp < array[highest_element].  This means that\n         * the final element is not the answer, so can exclude it; it also\n         * means that <mid> is not the final element, so can refer to 'mid + 1'\n         * safely */\n        if (cp < array[mid + 1]) {\n            return mid;\n        }\n        high--;\n        low = mid + 1;\n    }\n    else { /* cp < aray[mid] */\n        if (cp < array[0]) { /* Fail if outside the array */\n            return -1;\n        }\n        high = mid;\n        if (cp >= array[mid - 1]) {\n            goto found_entry;\n        }\n    }\n\n    /* Binary search.  What we are looking for is <i> such that\n     *\tarray[i] <= cp < array[i+1]\n     * The loop below converges on the i+1.  Note that there may not be an\n     * (i+1)th element in the array, and things work nonetheless */\n    while (low < high) {\n\tmid = (low + high) / 2;\n        assert(mid <= highest_element);\n\tif (array[mid] <= cp) { /* cp >= array[mid] */\n\t    low = mid + 1;\n\n\t    /* We could do this extra test to exit the loop early.\n\t    if (cp < array[low]) {\n\t\treturn mid;\n\t    }\n\t    */\n\t}\n\telse { /* cp < array[mid] */\n\t    high = mid;\n\t}\n    }\n\n  found_entry:\n    high--;\n    invlist_set_previous_index(invlist, high);\n    return high;\n}\n\nvoid\nPerl__invlist_populate_swatch(SV* const invlist,\n                              const UV start, const UV end, U8* swatch)\n{\n    /* populates a swatch of a swash the same way swatch_get() does in utf8.c,\n     * but is used when the swash has an inversion list.  This makes this much\n     * faster, as it uses a binary search instead of a linear one.  This is\n     * intimately tied to that function, and perhaps should be in utf8.c,\n     * except it is intimately tied to inversion lists as well.  It assumes\n     * that <swatch> is all 0's on input */\n\n    UV current = start;\n    const IV len = _invlist_len(invlist);\n    IV i;\n    const UV * array;\n\n    PERL_ARGS_ASSERT__INVLIST_POPULATE_SWATCH;\n\n    if (len == 0) { /* Empty inversion list */\n        return;\n    }\n\n    array = invlist_array(invlist);\n\n    /* Find which element it is */\n    i = _invlist_search(invlist, start);\n\n    /* We populate from <start> to <end> */\n    while (current < end) {\n        UV upper;\n\n\t/* The inversion list gives the results for every possible code point\n\t * after the first one in the list.  Only those ranges whose index is\n\t * even are ones that the inversion list matches.  For the odd ones,\n\t * and if the initial code point is not in the list, we have to skip\n\t * forward to the next element */\n        if (i == -1 || ! ELEMENT_RANGE_MATCHES_INVLIST(i)) {\n            i++;\n            if (i >= len) { /* Finished if beyond the end of the array */\n                return;\n            }\n            current = array[i];\n\t    if (current >= end) {   /* Finished if beyond the end of what we\n\t\t\t\t       are populating */\n                if (LIKELY(end < UV_MAX)) {\n                    return;\n                }\n\n                /* We get here when the upper bound is the maximum\n                 * representable on the machine, and we are looking for just\n                 * that code point.  Have to special case it */\n                i = len;\n                goto join_end_of_list;\n            }\n        }\n        assert(current >= start);\n\n\t/* The current range ends one below the next one, except don't go past\n\t * <end> */\n        i++;\n        upper = (i < len && array[i] < end) ? array[i] : end;\n\n\t/* Here we are in a range that matches.  Populate a bit in the 3-bit U8\n\t * for each code point in it */\n        for (; current < upper; current++) {\n            const STRLEN offset = (STRLEN)(current - start);\n            swatch[offset >> 3] |= 1 << (offset & 7);\n        }\n\n      join_end_of_list:\n\n\t/* Quit if at the end of the list */\n        if (i >= len) {\n\n\t    /* But first, have to deal with the highest possible code point on\n\t     * the platform.  The previous code assumes that <end> is one\n\t     * beyond where we want to populate, but that is impossible at the\n\t     * platform's infinity, so have to handle it specially */\n            if (UNLIKELY(end == UV_MAX && ELEMENT_RANGE_MATCHES_INVLIST(len-1)))\n\t    {\n                const STRLEN offset = (STRLEN)(end - start);\n                swatch[offset >> 3] |= 1 << (offset & 7);\n            }\n            return;\n        }\n\n\t/* Advance to the next range, which will be for code points not in the\n\t * inversion list */\n        current = array[i];\n    }\n\n    return;\n}\n\nvoid\nPerl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                         const bool complement_b, SV** output)\n{\n    /* Take the union of two inversion lists and point '*output' to it.  On\n     * input, '*output' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the union.  The first list, 'a', may be\n     * NULL, in which case a copy of the second list is placed in '*output'.\n     * If 'complement_b' is TRUE, the union is taken of the complement\n     * (inversion) of 'b' instead of b itself.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.\n     *\n     * The algorithm is like a merge sort. */\n\n    const UV* array_a;    /* a's array */\n    const UV* array_b;\n    UV len_a;\t    /* length of a's array */\n    UV len_b;\n\n    SV* u;\t\t\t/* the resulting union */\n    UV* array_u;\n    UV len_u = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_u = 0;\n\n    /* running count, as explained in the algorithm source book; items are\n     * stopped accumulating and are output when the count changes to/from 0.\n     * The count is incremented when we start a range that's in an input's set,\n     * and decremented when we start a range that's not in a set.  So this\n     * variable can be 0, 1, or 2.  When it is 0 neither input is in their set,\n     * and hence nothing goes into the union; 1, just one of the inputs is in\n     * its set (and its current range gets added to the union); and 2 when both\n     * inputs are in their sets.  */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*output == NULL || SvTYPE(*output) == SVt_INVLIST);\n\n    len_b = _invlist_len(b);\n    if (len_b == 0) {\n\n        /* Here, 'b' is empty, hence it's complement is all possible code\n         * points.  So if the union includes the complement of 'b', it includes\n         * everything, and we need not even look at 'a'.  It's easiest to\n         * create a new inversion list that matches everything.  */\n        if (complement_b) {\n            SV* everything = _add_range_to_invlist(NULL, 0, UV_MAX);\n\n            if (*output == NULL) { /* If the output didn't exist, just point it\n                                      at the new list */\n                *output = everything;\n            }\n            else { /* Otherwise, replace its contents with the new list */\n                invlist_replace_list_destroys_src(*output, everything);\n                SvREFCNT_dec_NN(everything);\n            }\n\n            return;\n        }\n\n        /* Here, we don't want the complement of 'b', and since 'b' is empty,\n         * the union will come entirely from 'a'.  If 'a' is NULL or empty, the\n         * output will be empty */\n\n        if (a == NULL || _invlist_len(a) == 0) {\n            if (*output == NULL) {\n                *output = _new_invlist(0);\n            }\n            else {\n                invlist_clear(*output);\n            }\n            return;\n        }\n\n        /* Here, 'a' is not empty, but 'b' is, so 'a' entirely determines the\n         * union.  We can just return a copy of 'a' if '*output' doesn't point\n         * to an existing list */\n        if (*output == NULL) {\n            *output = invlist_clone(a);\n            return;\n        }\n\n        /* If the output is to overwrite 'a', we have a no-op, as it's\n         * already in 'a' */\n        if (*output == a) {\n            return;\n        }\n\n        /* Here, '*output' is to be overwritten by 'a' */\n        u = invlist_clone(a);\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n\n        return;\n    }\n\n    /* Here 'b' is not empty.  See about 'a' */\n\n    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {\n\n        /* Here, 'a' is empty (and b is not).  That means the union will come\n         * entirely from 'b'.  If '*output' is NULL, we can directly return a\n         * clone of 'b'.  Otherwise, we replace the contents of '*output' with\n         * the clone */\n\n        SV ** dest = (*output == NULL) ? output : &u;\n        *dest = invlist_clone(b);\n        if (complement_b) {\n            _invlist_invert(*dest);\n        }\n\n        if (dest == &u) {\n            invlist_replace_list_destroys_src(*output, u);\n            SvREFCNT_dec_NN(u);\n        }\n\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the union of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the union for the worst case: that the sets are completely\n     * disjoint */\n    u = _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 if either component does */\n    array_u = _invlist_array_init(u, (    len_a > 0 && array_a[0] == 0)\n                                      || (len_b > 0 && array_b[0] == 0));\n\n    /* Go through each input list item by item, stopping when have exhausted\n     * one of them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the union's array */\n\tbool cp_in_set;   /* is it in the the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the union.\n\t * Since we are merging two sorted lists, we take the smaller of the\n         * next items.  In case of a tie, we take first the one that is in its\n         * set.  If we first took the one not in its set, it would decrement\n         * the count, possibly to 0 which would cause it to be output as ending\n         * the range, and the next time through we would take the same number,\n         * and output it again as beginning the next range.  By doing it the\n         * opposite way, there is no possibility that the count will be\n         * momentarily decremented to 0, and thus the two adjoining ranges will\n         * be seamlessly merged.  (In a tie and both are in the set or both not\n         * in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp = array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 0, which marks the\n\t * beginning/end of a range that's in the set */\n\tif (cp_in_set) {\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t    count++;\n\t}\n\telse {\n\t    count--;\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t}\n    }\n\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We decrement 'count', as explained below, if\n     * that list is in its set.  (i_a and i_b each currently index the element\n     * beyond the one we care about.) */\n    if (   (i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n\t|| (i_b != len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount--;\n    }\n\n    /* Above we decremented 'count' if the list that had unexamined elements in\n     * it was in its set.  This has made it so that 'count' being non-zero\n     * means there isn't anything left to output; and 'count' equal to 0 means\n     * that what is left to output is precisely that which is left in the\n     * non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to add to the union.  If it was in its set at its end, that means\n     * the set extends from here to the platform's infinity, and hence so does\n     * the union and the non-exhausted set is irrelevant.  The exhausted set\n     * also contributed 1 to 'count'.  If 'count' was 2, it got decremented to\n     * 1, but if it was 1, the non-exhausted set wasn't in its set, and so\n     * 'count' remains at 1.  This is consistent with the decremented 'count'\n     * != 0 meaning there's nothing left to add to the union.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the rest of the union will be whatever the other input is.\n     * If 'count' was 0, neither list was in its set, and 'count' remains 0;\n     * otherwise it gets decremented to 0.  This is consistent with 'count'\n     * == 0 meaning the remainder of the union is whatever is left in the\n     * non-exhausted list. */\n    if (count != 0) {\n        len_u = i_u;\n    }\n    else {\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* The non-exhausted input is 'a' */\n\t    Copy(array_a + i_a, array_u + i_u, copy_count, UV);\n        }\n        else { /* The non-exhausted input is b */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_u + i_u, copy_count, UV);\n        }\n        len_u = i_u + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_u, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_u != _invlist_len(u)) {\n\tinvlist_set_len(u, len_u, *get_invlist_offset_addr(u));\n\tinvlist_trim(u);\n\tarray_u = invlist_array(u);\n    }\n\n    if (*output == NULL) {  /* Simply return the new inversion list */\n        *output = u;\n    }\n    else {\n        /* Otherwise, overwrite the inversion list that was in '*output'.  We\n         * could instead free '*output', and then set it to 'u', but experience\n         * has shown [perl #127392] that if the input is a mortal, we can get a\n         * huge build-up of these during regex compilation before they get\n         * freed. */\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n    }\n\n    return;\n}\n\nvoid\nPerl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                               const bool complement_b, SV** i)\n{\n    /* Take the intersection of two inversion lists and point '*i' to it.  On\n     * input, '*i' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the intersection.  The first list, 'a', may be\n     * NULL, in which case '*i' will be an empty list.  If 'complement_b' is\n     * TRUE, the result will be the intersection of 'a' and the complement (or\n     * inversion) of 'b' instead of 'b' directly.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.  In fact, it had bugs\n     *\n     * The algorithm is like a merge sort, and is essentially the same as the\n     * union above\n     */\n\n    const UV* array_a;\t\t/* a's array */\n    const UV* array_b;\n    UV len_a;\t/* length of a's array */\n    UV len_b;\n\n    SV* r;\t\t     /* the resulting intersection */\n    UV* array_r;\n    UV len_r = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_r = 0;\n\n    /* running count of how many of the two inputs are postitioned at ranges\n     * that are in their sets.  As explained in the algorithm source book,\n     * items are stopped accumulating and are output when the count changes\n     * to/from 2.  The count is incremented when we start a range that's in an\n     * input's set, and decremented when we start a range that's not in a set.\n     * Only when it is 2 are we in the intersection. */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*i == NULL || SvTYPE(*i) == SVt_INVLIST);\n\n    /* Special case if either one is empty */\n    len_a = (a == NULL) ? 0 : _invlist_len(a);\n    if ((len_a == 0) || ((len_b = _invlist_len(b)) == 0)) {\n        if (len_a != 0 && complement_b) {\n\n            /* Here, 'a' is not empty, therefore from the enclosing 'if', 'b'\n             * must be empty.  Here, also we are using 'b's complement, which\n             * hence must be every possible code point.  Thus the intersection\n             * is simply 'a'. */\n\n            if (*i == a) {  /* No-op */\n                return;\n            }\n\n            if (*i == NULL) {\n                *i = invlist_clone(a);\n                return;\n            }\n\n            r = invlist_clone(a);\n            invlist_replace_list_destroys_src(*i, r);\n            SvREFCNT_dec_NN(r);\n            return;\n        }\n\n        /* Here, 'a' or 'b' is empty and not using the complement of 'b'.  The\n         * intersection must be empty */\n        if (*i == NULL) {\n            *i = _new_invlist(0);\n            return;\n        }\n\n        invlist_clear(*i);\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the intersection of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the intersection for the worst case: that the intersection ends up\n     * fragmenting everything to be completely disjoint */\n    r= _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 iff both components do */\n    array_r = _invlist_array_init(r,    len_a > 0 && array_a[0] == 0\n                                     && len_b > 0 && array_b[0] == 0);\n\n    /* Go through each list item by item, stopping when have exhausted one of\n     * them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the intersection's\n\t\t       array */\n\tbool cp_in_set;\t/* Is it in the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the\n\t * intersection.  Since we are merging two sorted lists, we take the\n         * smaller of the next items.  In case of a tie, we take first the one\n         * that is not in its set (a difference from the union algorithm).  If\n         * we first took the one in its set, it would increment the count,\n         * possibly to 2 which would cause it to be output as starting a range\n         * in the intersection, and the next time through we would take that\n         * same number, and output it again as ending the set.  By doing the\n         * opposite of this, there is no possibility that the count will be\n         * momentarily incremented to 2.  (In a tie and both are in the set or\n         * both not in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ! ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp= array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 2, which marks the\n\t * beginning/end of a range that's in the intersection */\n\tif (cp_in_set) {\n\t    count++;\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t}\n\telse {\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t    count--;\n\t}\n\n    }\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We increment 'count', as explained below, if the\n     * exhausted list was in its set.  (i_a and i_b each currently index the\n     * element beyond the one we care about.) */\n    if (   (i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n        || (i_b == len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount++;\n    }\n\n    /* Above we incremented 'count' if the exhausted list was in its set.  This\n     * has made it so that 'count' being below 2 means there is nothing left to\n     * output; otheriwse what's left to add to the intersection is precisely\n     * that which is left in the non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to affect the intersection.  If it was in its set at its end, that\n     * means the set extends from here to the platform's infinity, and hence\n     * anything in the non-exhausted's list will be in the intersection, and\n     * anything not in it won't be.  Hence, the rest of the intersection is\n     * precisely what's in the non-exhausted list  The exhausted set also\n     * contributed 1 to 'count', meaning 'count' was at least 1.  Incrementing\n     * it means 'count' is now at least 2.  This is consistent with the\n     * incremented 'count' being >= 2 means to add the non-exhausted list to\n     * the intersection.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the intersection can't include anything further; the\n     * non-exhausted set is irrelevant.  'count' was at most 1, and doesn't get\n     * incremented.  This is consistent with 'count' being < 2 meaning nothing\n     * further to add to the intersection. */\n    if (count < 2) { /* Nothing left to put in the intersection. */\n        len_r = i_r;\n    }\n    else { /* copy the non-exhausted list, unchanged. */\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* a is the one with stuff left */\n\t    Copy(array_a + i_a, array_r + i_r, copy_count, UV);\n        }\n        else {  /* b is the one with stuff left */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_r + i_r, copy_count, UV);\n        }\n        len_r = i_r + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_r, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_r != _invlist_len(r)) {\n\tinvlist_set_len(r, len_r, *get_invlist_offset_addr(r));\n\tinvlist_trim(r);\n\tarray_r = invlist_array(r);\n    }\n\n    if (*i == NULL) { /* Simply return the calculated intersection */\n        *i = r;\n    }\n    else { /* Otherwise, replace the existing inversion list in '*i'.  We could\n              instead free '*i', and then set it to 'r', but experience has\n              shown [perl #127392] that if the input is a mortal, we can get a\n              huge build-up of these during regex compilation before they get\n              freed. */\n        if (len_r) {\n            invlist_replace_list_destroys_src(*i, r);\n        }\n        else {\n            invlist_clear(*i);\n        }\n        SvREFCNT_dec_NN(r);\n    }\n\n    return;\n}\n\nSV*\nPerl__add_range_to_invlist(pTHX_ SV* invlist, UV start, UV end)\n{\n    /* Add the range from 'start' to 'end' inclusive to the inversion list's\n     * set.  A pointer to the inversion list is returned.  This may actually be\n     * a new list, in which case the passed in one has been destroyed.  The\n     * passed-in inversion list can be NULL, in which case a new one is created\n     * with just the one range in it.  The new list is not necessarily\n     * NUL-terminated.  Space is not freed if the inversion list shrinks as a\n     * result of this function.  The gain would not be large, and in many\n     * cases, this is called multiple times on a single inversion list, so\n     * anything freed may almost immediately be needed again.\n     *\n     * This used to mostly call the 'union' routine, but that is much more\n     * heavyweight than really needed for a single range addition */\n\n    UV* array;              /* The array implementing the inversion list */\n    UV len;                 /* How many elements in 'array' */\n    SSize_t i_s;            /* index into the invlist array where 'start'\n                               should go */\n    SSize_t i_e = 0;        /* And the index where 'end' should go */\n    UV cur_highest;         /* The highest code point in the inversion list\n                               upon entry to this function */\n\n    /* This range becomes the whole inversion list if none already existed */\n    if (invlist == NULL) {\n\tinvlist = _new_invlist(2);\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Likewise, if the inversion list is currently empty */\n    len = _invlist_len(invlist);\n    if (len == 0) {\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Starting here, we have to know the internals of the list */\n    array = invlist_array(invlist);\n\n    /* If the new range ends higher than the current highest ... */\n    cur_highest = invlist_highest(invlist);\n    if (end > cur_highest) {\n\n        /* If the whole range is higher, we can just append it */\n        if (start > cur_highest) {\n            _append_range_to_invlist(invlist, start, end);\n            return invlist;\n        }\n\n        /* Otherwise, add the portion that is higher ... */\n        _append_range_to_invlist(invlist, cur_highest + 1, end);\n\n        /* ... and continue on below to handle the rest.  As a result of the\n         * above append, we know that the index of the end of the range is the\n         * final even numbered one of the array.  Recall that the final element\n         * always starts a range that extends to infinity.  If that range is in\n         * the set (meaning the set goes from here to infinity), it will be an\n         * even index, but if it isn't in the set, it's odd, and the final\n         * range in the set is one less, which is even. */\n        if (end == UV_MAX) {\n            i_e = len;\n        }\n        else {\n            i_e = len - 2;\n        }\n    }\n\n    /* We have dealt with appending, now see about prepending.  If the new\n     * range starts lower than the current lowest ... */\n    if (start < array[0]) {\n\n        /* Adding something which has 0 in it is somewhat tricky, and uncommon.\n         * Let the union code handle it, rather than having to know the\n         * trickiness in two code places.  */\n        if (UNLIKELY(start == 0)) {\n            SV* range_invlist;\n\n            range_invlist = _new_invlist(2);\n            _append_range_to_invlist(range_invlist, start, end);\n\n            _invlist_union(invlist, range_invlist, &invlist);\n\n            SvREFCNT_dec_NN(range_invlist);\n\n            return invlist;\n        }\n\n        /* If the whole new range comes before the first entry, and doesn't\n         * extend it, we have to insert it as an additional range */\n        if (end < array[0] - 1) {\n            i_s = i_e = -1;\n            goto splice_in_new_range;\n        }\n\n        /* Here the new range adjoins the existing first range, extending it\n         * downwards. */\n        array[0] = start;\n\n        /* And continue on below to handle the rest.  We know that the index of\n         * the beginning of the range is the first one of the array */\n        i_s = 0;\n    }\n    else { /* Not prepending any part of the new range to the existing list.\n            * Find where in the list it should go.  This finds i_s, such that:\n            *     invlist[i_s] <= start < array[i_s+1]\n            */\n        i_s = _invlist_search(invlist, start);\n    }\n\n    /* At this point, any extending before the beginning of the inversion list\n     * and/or after the end has been done.  This has made it so that, in the\n     * code below, each endpoint of the new range is either in a range that is\n     * in the set, or is in a gap between two ranges that are.  This means we\n     * don't have to worry about exceeding the array bounds.\n     *\n     * Find where in the list the new range ends (but we can skip this if we\n     * have already determined what it is, or if it will be the same as i_s,\n     * which we already have computed) */\n    if (i_e == 0) {\n        i_e = (start == end)\n              ? i_s\n              : _invlist_search(invlist, end);\n    }\n\n    /* Here generally invlist[i_e] <= end < array[i_e+1].  But if invlist[i_e]\n     * is a range that goes to infinity there is no element at invlist[i_e+1],\n     * so only the first relation holds. */\n\n    if ( ! ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n\n        /* Here, the ranges on either side of the beginning of the new range\n         * are in the set, and this range starts in the gap between them.\n         *\n         * The new range extends the range above it downwards if the new range\n         * ends at or above that range's start */\n        const bool extends_the_range_above = (   end == UV_MAX\n                                              || end + 1 >= array[i_s+1]);\n\n        /* The new range extends the range below it upwards if it begins just\n         * after where that range ends */\n        if (start == array[i_s]) {\n\n            /* If the new range fills the entire gap between the other ranges,\n             * they will get merged together.  Other ranges may also get\n             * merged, depending on how many of them the new range spans.  In\n             * the general case, we do the merge later, just once, after we\n             * figure out how many to merge.  But in the case where the new\n             * range exactly spans just this one gap (possibly extending into\n             * the one above), we do the merge here, and an early exit.  This\n             * is done here to avoid having to special case later. */\n            if (i_e - i_s <= 1) {\n\n                /* If i_e - i_s == 1, it means that the new range terminates\n                 * within the range above, and hence 'extends_the_range_above'\n                 * must be true.  (If the range above it extends to infinity,\n                 * 'i_s+2' will be above the array's limit, but 'len-i_s-2'\n                 * will be 0, so no harm done.) */\n                if (extends_the_range_above) {\n                    Move(array + i_s + 2, array + i_s, len - i_s - 2, UV);\n                    invlist_set_len(invlist,\n                                    len - 2,\n                                    *(get_invlist_offset_addr(invlist)));\n                    return invlist;\n                }\n\n                /* Here, i_e must == i_s.  We keep them in sync, as they apply\n                 * to the same range, and below we are about to decrement i_s\n                 * */\n                i_e--;\n            }\n\n            /* Here, the new range is adjacent to the one below.  (It may also\n             * span beyond the range above, but that will get resolved later.)\n             * Extend the range below to include this one. */\n            array[i_s] = (end == UV_MAX) ? UV_MAX : end + 1;\n            i_s--;\n            start = array[i_s];\n        }\n        else if (extends_the_range_above) {\n\n            /* Here the new range only extends the range above it, but not the\n             * one below.  It merges with the one above.  Again, we keep i_e\n             * and i_s in sync if they point to the same range */\n            if (i_e == i_s) {\n                i_e++;\n            }\n            i_s++;\n            array[i_s] = start;\n        }\n    }\n\n    /* Here, we've dealt with the new range start extending any adjoining\n     * existing ranges.\n     *\n     * If the new range extends to infinity, it is now the final one,\n     * regardless of what was there before */\n    if (UNLIKELY(end == UV_MAX)) {\n        invlist_set_len(invlist, i_s + 1, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* If i_e started as == i_s, it has also been dealt with,\n     * and been updated to the new i_s, which will fail the following if */\n    if (! ELEMENT_RANGE_MATCHES_INVLIST(i_e)) {\n\n        /* Here, the ranges on either side of the end of the new range are in\n         * the set, and this range ends in the gap between them.\n         *\n         * If this range is adjacent to (hence extends) the range above it, it\n         * becomes part of that range; likewise if it extends the range below,\n         * it becomes part of that range */\n        if (end + 1 == array[i_e+1]) {\n            i_e++;\n            array[i_e] = start;\n        }\n        else if (start <= array[i_e]) {\n            array[i_e] = end + 1;\n            i_e--;\n        }\n    }\n\n    if (i_s == i_e) {\n\n        /* If the range fits entirely in an existing range (as possibly already\n         * extended above), it doesn't add anything new */\n        if (ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n            return invlist;\n        }\n\n        /* Here, no part of the range is in the list.  Must add it.  It will\n         * occupy 2 more slots */\n      splice_in_new_range:\n\n        invlist_extend(invlist, len + 2);\n        array = invlist_array(invlist);\n        /* Move the rest of the array down two slots. Don't include any\n         * trailing NUL */\n        Move(array + i_e + 1, array + i_e + 3, len - i_e - 1, UV);\n\n        /* Do the actual splice */\n        array[i_e+1] = start;\n        array[i_e+2] = end + 1;\n        invlist_set_len(invlist, len + 2, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* Here the new range crossed the boundaries of a pre-existing range.  The\n     * code above has adjusted things so that both ends are in ranges that are\n     * in the set.  This means everything in between must also be in the set.\n     * Just squash things together */\n    Move(array + i_e + 1, array + i_s + 1, len - i_e - 1, UV);\n    invlist_set_len(invlist,\n                    len - i_e + i_s,\n                    *(get_invlist_offset_addr(invlist)));\n\n    return invlist;\n}\n\nSV*\nPerl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0,\n                                 UV** other_elements_ptr)\n{\n    /* Create and return an inversion list whose contents are to be populated\n     * by the caller.  The caller gives the number of elements (in 'size') and\n     * the very first element ('element0').  This function will set\n     * '*other_elements_ptr' to an array of UVs, where the remaining elements\n     * are to be placed.\n     *\n     * Obviously there is some trust involved that the caller will properly\n     * fill in the other elements of the array.\n     *\n     * (The first element needs to be passed in, as the underlying code does\n     * things differently depending on whether it is zero or non-zero) */\n\n    SV* invlist = _new_invlist(size);\n    bool offset;\n\n    PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST;\n\n    invlist = add_cp_to_invlist(invlist, element0);\n    offset = *get_invlist_offset_addr(invlist);\n\n    invlist_set_len(invlist, size, offset);\n    *other_elements_ptr = invlist_array(invlist) + 1;\n    return invlist;\n}\n\n#endif\n\nPERL_STATIC_INLINE SV*\nS_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp) {\n    return _add_range_to_invlist(invlist, cp, cp);\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_invert(pTHX_ SV* const invlist)\n{\n    /* Complement the input inversion list.  This adds a 0 if the list didn't\n     * have a zero; removes it otherwise.  As described above, the data\n     * structure is set up so that this is very efficient */\n\n    PERL_ARGS_ASSERT__INVLIST_INVERT;\n\n    assert(! invlist_is_iterating(invlist));\n\n    /* The inverse of matching nothing is matching everything */\n    if (_invlist_len(invlist) == 0) {\n\t_append_range_to_invlist(invlist, 0, UV_MAX);\n\treturn;\n    }\n\n    *get_invlist_offset_addr(invlist) = ! *get_invlist_offset_addr(invlist);\n}\n\n#endif\n\nPERL_STATIC_INLINE SV*\nS_invlist_clone(pTHX_ SV* const invlist)\n{\n\n    /* Return a new inversion list that is a copy of the input one, which is\n     * unchanged.  The new list will not be mortal even if the old one was. */\n\n    /* Need to allocate extra space to accommodate Perl's addition of a\n     * trailing NUL to SvPV's, since it thinks they are always strings */\n    SV* new_invlist = _new_invlist(_invlist_len(invlist) + 1);\n    STRLEN physical_length = SvCUR(invlist);\n    bool offset = *(get_invlist_offset_addr(invlist));\n\n    PERL_ARGS_ASSERT_INVLIST_CLONE;\n\n    *(get_invlist_offset_addr(new_invlist)) = offset;\n    invlist_set_len(new_invlist, _invlist_len(invlist), offset);\n    Copy(SvPVX(invlist), SvPVX(new_invlist), physical_length, char);\n\n    return new_invlist;\n}\n\nPERL_STATIC_INLINE STRLEN*\nS_get_invlist_iter_addr(SV* invlist)\n{\n    /* Return the address of the UV that contains the current iteration\n     * position */\n\n    PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    return &(((XINVLIST*) SvANY(invlist))->iterator);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterinit(SV* invlist)\t/* Initialize iterator for invlist */\n{\n    PERL_ARGS_ASSERT_INVLIST_ITERINIT;\n\n    *get_invlist_iter_addr(invlist) = 0;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterfinish(SV* invlist)\n{\n    /* Terminate iterator for invlist.  This is to catch development errors.\n     * Any iteration that is interrupted before completed should call this\n     * function.  Functions that add code points anywhere else but to the end\n     * of an inversion list assert that they are not in the middle of an\n     * iteration.  If they were, the addition would make the iteration\n     * problematical: if the iteration hadn't reached the place where things\n     * were being added, it would be ok */\n\n    PERL_ARGS_ASSERT_INVLIST_ITERFINISH;\n\n    *get_invlist_iter_addr(invlist) = (STRLEN) UV_MAX;\n}\n\nSTATIC bool\nS_invlist_iternext(SV* invlist, UV* start, UV* end)\n{\n    /* An C<invlist_iterinit> call on <invlist> must be used to set this up.\n     * This call sets in <*start> and <*end>, the next range in <invlist>.\n     * Returns <TRUE> if successful and the next call will return the next\n     * range; <FALSE> if was already at the end of the list.  If the latter,\n     * <*start> and <*end> are unchanged, and the next call to this function\n     * will start over at the beginning of the list */\n\n    STRLEN* pos = get_invlist_iter_addr(invlist);\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_ITERNEXT;\n\n    if (*pos >= len) {\n\t*pos = (STRLEN) UV_MAX;\t/* Force iterinit() to be required next time */\n\treturn FALSE;\n    }\n\n    array = invlist_array(invlist);\n\n    *start = array[(*pos)++];\n\n    if (*pos >= len) {\n\t*end = UV_MAX;\n    }\n    else {\n\t*end = array[(*pos)++] - 1;\n    }\n\n    return TRUE;\n}\n\nPERL_STATIC_INLINE UV\nS_invlist_highest(SV* const invlist)\n{\n    /* Returns the highest code point that matches an inversion list.  This API\n     * has an ambiguity, as it returns 0 under either the highest is actually\n     * 0, or if the list is empty.  If this distinction matters to you, check\n     * for emptiness before calling this function */\n\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_HIGHEST;\n\n    if (len == 0) {\n\treturn 0;\n    }\n\n    array = invlist_array(invlist);\n\n    /* The last element in the array in the inversion list always starts a\n     * range that goes to infinity.  That range may be for code points that are\n     * matched in the inversion list, or it may be for ones that aren't\n     * matched.  In the latter case, the highest code point in the set is one\n     * less than the beginning of this range; otherwise it is the final element\n     * of this range: infinity */\n    return (ELEMENT_RANGE_MATCHES_INVLIST(len - 1))\n           ? UV_MAX\n           : array[len - 1] - 1;\n}\n\nSTATIC SV *\nS_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)\n{\n    /* Get the contents of an inversion list into a string SV so that they can\n     * be printed out.  If 'traditional_style' is TRUE, it uses the format\n     * traditionally done for debug tracing; otherwise it uses a format\n     * suitable for just copying to the output, with blanks between ranges and\n     * a dash between range components */\n\n    UV start, end;\n    SV* output;\n    const char intra_range_delimiter = (traditional_style ? '\\t' : '-');\n    const char inter_range_delimiter = (traditional_style ? '\\n' : ' ');\n\n    if (traditional_style) {\n        output = newSVpvs(\"\\n\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    PERL_ARGS_ASSERT_INVLIST_CONTENTS;\n\n    assert(! invlist_is_iterating(invlist));\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%cINFINITY%c\",\n                                          start, intra_range_delimiter,\n                                                 inter_range_delimiter);\n\t}\n\telse if (end != start) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c%04\" UVXf \"%c\",\n\t\t                          start,\n                                                   intra_range_delimiter,\n                                                  end, inter_range_delimiter);\n\t}\n\telse {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c\",\n                                          start, inter_range_delimiter);\n\t}\n    }\n\n    if (SvCUR(output) && ! traditional_style) {/* Get rid of trailing blank */\n        SvCUR_set(output, SvCUR(output) - 1);\n    }\n\n    return output;\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_dump(pTHX_ PerlIO *file, I32 level,\n                         const char * const indent, SV* const invlist)\n{\n    /* Designed to be called only by do_sv_dump().  Dumps out the ranges of the\n     * inversion list 'invlist' to 'file' at 'level'  Each line is prefixed by\n     * the string 'indent'.  The output looks like this:\n         [0] 0x000A .. 0x000D\n         [2] 0x0085\n         [4] 0x2028 .. 0x2029\n         [6] 0x3104 .. INFINITY\n     * This means that the first range of code points matched by the list are\n     * 0xA through 0xD; the second range contains only the single code point\n     * 0x85, etc.  An inversion list is an array of UVs.  Two array elements\n     * are used to define each range (except if the final range extends to\n     * infinity, only a single element is needed).  The array index of the\n     * first element for the corresponding range is given in brackets. */\n\n    UV start, end;\n    STRLEN count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_DUMP;\n\n    if (invlist_is_iterating(invlist)) {\n        Perl_dump_indent(aTHX_ level, file,\n             \"%sCan't dump inversion list because is in middle of iterating\\n\",\n             indent);\n        return;\n    }\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                       \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. INFINITY\\n\",\n                                   indent, (UV)count, start);\n\t}\n\telse if (end != start) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                    \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. 0x%04\" UVXf \"\\n\",\n\t\t                indent, (UV)count, start,         end);\n\t}\n\telse {\n\t    Perl_dump_indent(aTHX_ level, file, \"%s[%\" UVuf \"] 0x%04\" UVXf \"\\n\",\n                                            indent, (UV)count, start);\n\t}\n        count += 2;\n    }\n}\n\nvoid\nPerl__load_PL_utf8_foldclosures (pTHX)\n{\n    assert(! PL_utf8_foldclosures);\n\n    /* If the folds haven't been read in, call a fold function\n     * to force that */\n    if (! PL_utf8_tofold) {\n        U8 dummy[UTF8_MAXBYTES_CASE+1];\n        const U8 hyphen[] = HYPHEN_UTF8;\n\n        /* This string is just a short named one above \\xff */\n        toFOLD_utf8_safe(hyphen, hyphen + sizeof(hyphen) - 1, dummy, NULL);\n        assert(PL_utf8_tofold); /* Verify that worked */\n    }\n    PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);\n}\n#endif\n\n#if defined(PERL_ARGS_ASSERT__INVLISTEQ) && !defined(PERL_IN_XSUB_RE)\nbool\nPerl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)\n{\n    /* Return a boolean as to if the two passed in inversion lists are\n     * identical.  The final argument, if TRUE, says to take the complement of\n     * the second inversion list before doing the comparison */\n\n    const UV* array_a = invlist_array(a);\n    const UV* array_b = invlist_array(b);\n    UV len_a = _invlist_len(a);\n    UV len_b = _invlist_len(b);\n\n    PERL_ARGS_ASSERT__INVLISTEQ;\n\n    /* If are to compare 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n        /* The complement of nothing is everything, so <a> would have to have\n         * just one element, starting at zero (ending at infinity) */\n        if (len_b == 0) {\n            return (len_a == 1 && array_a[0] == 0);\n        }\n        else if (array_b[0] == 0) {\n\n            /* Otherwise, to complement, we invert.  Here, the first element is\n             * 0, just remove it.  To do this, we just pretend the array starts\n             * one later */\n\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    return    len_a == len_b\n           && memEQ(array_a, array_b, len_a * sizeof(array_a[0]));\n\n}\n#endif\n\n/*\n * As best we can, determine the characters that can match the start of\n * the given EXACTF-ish node.\n *\n * Returns the invlist as a new SV*; it is the caller's responsibility to\n * call SvREFCNT_dec() when done with it.\n */\nSTATIC SV*\nS__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)\n{\n    const U8 * s = (U8*)STRING(node);\n    SSize_t bytelen = STR_LEN(node);\n    UV uc;\n    /* Start out big enough for 2 separate code points */\n    SV* invlist = _new_invlist(4);\n\n    PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST;\n\n    if (! UTF) {\n        uc = *s;\n\n        /* We punt and assume can match anything if the node begins\n         * with a multi-character fold.  Things are complicated.  For\n         * example, /ffi/i could match any of:\n         *  \"\\N{LATIN SMALL LIGATURE FFI}\"\n         *  \"\\N{LATIN SMALL LIGATURE FF}I\"\n         *  \"F\\N{LATIN SMALL LIGATURE FI}\"\n         *  plus several other things; and making sure we have all the\n         *  possibilities is hard. */\n        if (is_MULTI_CHAR_FOLD_latin1_safe(s, s + bytelen)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {\n            /* Any Latin1 range character can potentially match any\n             * other depending on the locale */\n            if (OP(node) == EXACTFL) {\n                _invlist_union(invlist, PL_Latin1, &invlist);\n            }\n            else {\n                /* But otherwise, it matches at least itself.  We can\n                 * quickly tell if it has a distinct fold, and if so,\n                 * it matches that as well */\n                invlist = add_cp_to_invlist(invlist, uc);\n                if (IS_IN_SOME_FOLD_L1(uc))\n                    invlist = add_cp_to_invlist(invlist, PL_fold_latin1[uc]);\n            }\n\n            /* Some characters match above-Latin1 ones under /i.  This\n             * is true of EXACTFL ones when the locale is UTF-8 */\n            if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(uc)\n                && (! isASCII(uc) || (OP(node) != EXACTFA\n                                    && OP(node) != EXACTFA_NO_TRIE)))\n            {\n                add_above_Latin1_folds(pRExC_state, (U8) uc, &invlist);\n            }\n        }\n    }\n    else {  /* Pattern is UTF-8 */\n        U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\\0' };\n        STRLEN foldlen = UTF8SKIP(s);\n        const U8* e = s + bytelen;\n        SV** listp;\n\n        uc = utf8_to_uvchr_buf(s, s + bytelen, NULL);\n\n        /* The only code points that aren't folded in a UTF EXACTFish\n         * node are are the problematic ones in EXACTFL nodes */\n        if (OP(node) == EXACTFL && is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(uc)) {\n            /* We need to check for the possibility that this EXACTFL\n             * node begins with a multi-char fold.  Therefore we fold\n             * the first few characters of it so that we can make that\n             * check */\n            U8 *d = folded;\n            int i;\n\n            for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < e; i++) {\n                if (isASCII(*s)) {\n                    *(d++) = (U8) toFOLD(*s);\n                    s++;\n                }\n                else {\n                    STRLEN len;\n                    toFOLD_utf8_safe(s, e, d, &len);\n                    d += len;\n                    s += UTF8SKIP(s);\n                }\n            }\n\n            /* And set up so the code below that looks in this folded\n             * buffer instead of the node's string */\n            e = d;\n            foldlen = UTF8SKIP(folded);\n            s = folded;\n        }\n\n        /* When we reach here 's' points to the fold of the first\n         * character(s) of the node; and 'e' points to far enough along\n         * the folded string to be just past any possible multi-char\n         * fold. 'foldlen' is the length in bytes of the first\n         * character in 's'\n         *\n         * Unlike the non-UTF-8 case, the macro for determining if a\n         * string is a multi-char fold requires all the characters to\n         * already be folded.  This is because of all the complications\n         * if not.  Note that they are folded anyway, except in EXACTFL\n         * nodes.  Like the non-UTF case above, we punt if the node\n         * begins with a multi-char fold  */\n\n        if (is_MULTI_CHAR_FOLD_utf8_safe(s, e)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {  /* Single char fold */\n\n            /* It matches all the things that fold to it, which are\n             * found in PL_utf8_foldclosures (including itself) */\n            invlist = add_cp_to_invlist(invlist, uc);\n            if (! PL_utf8_foldclosures)\n                _load_PL_utf8_foldclosures();\n            if ((listp = hv_fetch(PL_utf8_foldclosures,\n                                (char *) s, foldlen, FALSE)))\n            {\n                AV* list = (AV*) *listp;\n                IV k;\n                for (k = 0; k <= av_tindex_skip_len_mg(list); k++) {\n                    SV** c_p = av_fetch(list, k, FALSE);\n                    UV c;\n                    assert(c_p);\n\n                    c = SvUV(*c_p);\n\n                    /* /aa doesn't allow folds between ASCII and non- */\n                    if ((OP(node) == EXACTFA || OP(node) == EXACTFA_NO_TRIE)\n                        && isASCII(c) != isASCII(uc))\n                    {\n                        continue;\n                    }\n\n                    invlist = add_cp_to_invlist(invlist, c);\n                }\n            }\n        }\n    }\n\n    return invlist;\n}\n\n#undef HEADER_LENGTH\n#undef TO_INTERNAL_SIZE\n#undef FROM_INTERNAL_SIZE\n#undef INVLIST_VERSION_ID\n\n/* End of inversion list object */\n\nSTATIC void\nS_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)\n{\n    /* This parses the flags that are in either the '(?foo)' or '(?foo:bar)'\n     * constructs, and updates RExC_flags with them.  On input, RExC_parse\n     * should point to the first flag; it is updated on output to point to the\n     * final ')' or ':'.  There needs to be at least one flag, or this will\n     * abort */\n\n    /* for (?g), (?gc), and (?o) warnings; warning\n       about (?c) will warn about (?g) -- japhy    */\n\n#define WASTED_O  0x01\n#define WASTED_G  0x02\n#define WASTED_C  0x04\n#define WASTED_GC (WASTED_G|WASTED_C)\n    I32 wastedflags = 0x00;\n    U32 posflags = 0, negflags = 0;\n    U32 *flagsp = &posflags;\n    char has_charset_modifier = '\\0';\n    regex_charset cs;\n    bool has_use_defaults = FALSE;\n    const char* const seqstart = RExC_parse - 1; /* Point to the '?' */\n    int x_mod_count = 0;\n\n    PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS;\n\n    /* '^' as an initial flag sets certain defaults */\n    if (UCHARAT(RExC_parse) == '^') {\n        RExC_parse++;\n        has_use_defaults = TRUE;\n        STD_PMMOD_FLAGS_CLEAR(&RExC_flags);\n        set_regex_charset(&RExC_flags, (RExC_utf8 || RExC_uni_semantics)\n                                        ? REGEX_UNICODE_CHARSET\n                                        : REGEX_DEPENDS_CHARSET);\n    }\n\n    cs = get_regex_charset(RExC_flags);\n    if (cs == REGEX_DEPENDS_CHARSET\n        && (RExC_utf8 || RExC_uni_semantics))\n    {\n        cs = REGEX_UNICODE_CHARSET;\n    }\n\n    while (RExC_parse < RExC_end) {\n        /* && strchr(\"iogcmsx\", *RExC_parse) */\n        /* (?g), (?gc) and (?o) are useless here\n           and must be globally applied -- japhy */\n        switch (*RExC_parse) {\n\n            /* Code for the imsxn flags */\n            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp, x_mod_count);\n\n            case LOCALE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_LOCALE_CHARSET;\n                has_charset_modifier = LOCALE_PAT_MOD;\n                break;\n            case UNICODE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_UNICODE_CHARSET;\n                has_charset_modifier = UNICODE_PAT_MOD;\n                break;\n            case ASCII_RESTRICT_PAT_MOD:\n                if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                if (has_charset_modifier) {\n                    if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {\n                        goto excess_modifier;\n                    }\n                    /* Doubled modifier implies more restricted */\n                    cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;\n                }\n                else {\n                    cs = REGEX_ASCII_RESTRICTED_CHARSET;\n                }\n                has_charset_modifier = ASCII_RESTRICT_PAT_MOD;\n                break;\n            case DEPENDS_PAT_MOD:\n                if (has_use_defaults) {\n                    goto fail_modifiers;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                else if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n\n                /* The dual charset means unicode semantics if the\n                 * pattern (or target, not known until runtime) are\n                 * utf8, or something in the pattern indicates unicode\n                 * semantics */\n                cs = (RExC_utf8 || RExC_uni_semantics)\n                     ? REGEX_UNICODE_CHARSET\n                     : REGEX_DEPENDS_CHARSET;\n                has_charset_modifier = DEPENDS_PAT_MOD;\n                break;\n              excess_modifier:\n                RExC_parse++;\n                if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may appear a maximum of twice\", ASCII_RESTRICT_PAT_MOD);\n                }\n                else if (has_charset_modifier == *(RExC_parse - 1)) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear twice\",\n                                        *(RExC_parse - 1));\n                }\n                else {\n                    vFAIL3(\"Regexp modifiers \\\"%c\\\" and \\\"%c\\\" are mutually exclusive\", has_charset_modifier, *(RExC_parse - 1));\n                }\n                NOT_REACHED; /*NOTREACHED*/\n              neg_modifier:\n                RExC_parse++;\n                vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear after the \\\"-\\\"\",\n                                    *(RExC_parse - 1));\n                NOT_REACHED; /*NOTREACHED*/\n            case ONCE_PAT_MOD: /* 'o' */\n            case GLOBAL_PAT_MOD: /* 'g' */\n                if (PASS2 && ckWARN(WARN_REGEXP)) {\n                    const I32 wflagbit = *RExC_parse == 'o'\n                                         ? WASTED_O\n                                         : WASTED_G;\n                    if (! (wastedflags & wflagbit) ) {\n                        wastedflags |= wflagbit;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN5(\n                            RExC_parse + 1,\n                            \"Useless (%s%c) - %suse /%c modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            *RExC_parse,\n                            flagsp == &negflags ? \"don't \" : \"\",\n                            *RExC_parse\n                        );\n                    }\n                }\n                break;\n\n            case CONTINUE_PAT_MOD: /* 'c' */\n                if (PASS2 && ckWARN(WARN_REGEXP)) {\n                    if (! (wastedflags & WASTED_C) ) {\n                        wastedflags |= WASTED_GC;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN3(\n                            RExC_parse + 1,\n                            \"Useless (%sc) - %suse /gc modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            flagsp == &negflags ? \"don't \" : \"\"\n                        );\n                    }\n                }\n                break;\n            case KEEPCOPY_PAT_MOD: /* 'p' */\n                if (flagsp == &negflags) {\n                    if (PASS2)\n                        ckWARNreg(RExC_parse + 1,\"Useless use of (?-p)\");\n                } else {\n                    *flagsp |= RXf_PMf_KEEPCOPY;\n                }\n                break;\n            case '-':\n                /* A flag is a default iff it is following a minus, so\n                 * if there is a minus, it means will be trying to\n                 * re-specify a default which is an error */\n                if (has_use_defaults || flagsp == &negflags) {\n                    goto fail_modifiers;\n                }\n                flagsp = &negflags;\n                wastedflags = 0;  /* reset so (?g-c) warns twice */\n                x_mod_count = 0;\n                break;\n            case ':':\n            case ')':\n\n                if ((posflags & (RXf_PMf_EXTENDED|RXf_PMf_EXTENDED_MORE)) == RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags |= posflags;\n\n                if (negflags & RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags &= ~negflags;\n                set_regex_charset(&RExC_flags, cs);\n\n                return;\n            default:\n              fail_modifiers:\n                RExC_parse += SKIP_IF_CHAR(RExC_parse);\n\t\t/* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                vFAIL2utf8f(\"Sequence (%\" UTF8f \"...) not recognized\",\n                      UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n                NOT_REACHED; /*NOTREACHED*/\n        }\n\n        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n    }\n\n    vFAIL(\"Sequence (?... not terminated\");\n}\n\n/*\n - reg - regular expression, i.e. main body or parenthesized thing\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\n#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)\n#ifdef DEBUGGING\n#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)\n#else\n#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)\n#endif\n\nPERL_STATIC_INLINE regnode *\nS_handle_named_backref(pTHX_ RExC_state_t *pRExC_state,\n                             I32 *flagp,\n                             char * parse_start,\n                             char ch\n                      )\n{\n    regnode *ret;\n    char* name_start = RExC_parse;\n    U32 num = 0;\n    SV *sv_dat = reg_scan_name(pRExC_state, SIZE_ONLY\n                                            ? REG_RSN_RETURN_NULL\n                                            : REG_RSN_RETURN_DATA);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF;\n\n    if (RExC_parse == name_start || *RExC_parse != ch) {\n        /* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n        vFAIL2(\"Sequence %.3s... not terminated\",parse_start);\n    }\n\n    if (!SIZE_ONLY) {\n        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n        RExC_rxi->data->data[num]=(void*)sv_dat;\n        SvREFCNT_inc_simple_void(sv_dat);\n    }\n    RExC_sawback = 1;\n    ret = reganode(pRExC_state,\n                   ((! FOLD)\n                     ? NREF\n                     : (ASCII_FOLD_RESTRICTED)\n                       ? NREFFA\n                       : (AT_LEAST_UNI_SEMANTICS)\n                         ? NREFFU\n                         : (LOC)\n                           ? NREFFL\n                           : NREFF),\n                    num);\n    *flagp |= HASWIDTH;\n\n    Set_Node_Offset(ret, parse_start+1);\n    Set_Node_Cur_Length(ret, parse_start);\n\n    nextchar(pRExC_state);\n    return ret;\n}\n\n/* Returns NULL, setting *flagp to TRYAGAIN at the end of (?) that only sets\n   flags. Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan\n   needs to be restarted, or'd with NEED_UTF8 if the pattern needs to be\n   upgraded to UTF-8.  Otherwise would only return NULL if regbranch() returns\n   NULL, which cannot happen.  */\nSTATIC regnode *\nS_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp,U32 depth)\n    /* paren: Parenthesized? 0=top; 1,2=inside '(': changed to letter.\n     * 2 is like 1, but indicates that nextchar() has been called to advance\n     * RExC_parse beyond the '('.  Things like '(?' are indivisible tokens, and\n     * this flag alerts us to the need to check for that */\n{\n    regnode *ret;\t\t/* Will be the head of the group. */\n    regnode *br;\n    regnode *lastbr;\n    regnode *ender = NULL;\n    I32 parno = 0;\n    I32 flags;\n    U32 oregflags = RExC_flags;\n    bool have_branch = 0;\n    bool is_open = 0;\n    I32 freeze_paren = 0;\n    I32 after_freeze = 0;\n    I32 num; /* numeric backreferences */\n\n    char * parse_start = RExC_parse; /* MJD */\n    char * const oregcomp_parse = RExC_parse;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG;\n    DEBUG_PARSE(\"reg \");\n\n    *flagp = 0;\t\t\t\t/* Tentatively. */\n\n    /* Having this true makes it feasible to have a lot fewer tests for the\n     * parse pointer being in scope.  For example, we can write\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     * instead of\n     *      while(RExC_parse < RExC_end && isFOO(*RExC_parse)) RExC_parse++;\n     */\n    assert(*RExC_end == '\\0');\n\n    /* Make an OPEN node, if parenthesized. */\n    if (paren) {\n\n        /* Under /x, space and comments can be gobbled up between the '(' and\n         * here (if paren ==2).  The forms '(*VERB' and '(?...' disallow such\n         * intervening space, as the sequence is a token, and a token should be\n         * indivisible */\n        bool has_intervening_patws = paren == 2 && *(RExC_parse - 1) != '(';\n\n        if (RExC_parse >= RExC_end) {\n\t    vFAIL(\"Unmatched (\");\n        }\n\n        if ( *RExC_parse == '*') { /* (*VERB:ARG) */\n\t    char *start_verb = RExC_parse + 1;\n\t    STRLEN verb_len;\n\t    char *start_arg = NULL;\n\t    unsigned char op = 0;\n            int arg_required = 0;\n            int internal_argval = -1; /* if >-1 we are not allowed an argument*/\n\n            if (has_intervening_patws) {\n                RExC_parse++;   /* past the '*' */\n                vFAIL(\"In '(*VERB...)', the '(' and '*' must be adjacent\");\n            }\n\t    while (RExC_parse < RExC_end && *RExC_parse != ')' ) {\n\t        if ( *RExC_parse == ':' ) {\n\t            start_arg = RExC_parse + 1;\n\t            break;\n\t        }\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t    }\n\t    verb_len = RExC_parse - start_verb;\n\t    if ( start_arg ) {\n                if (RExC_parse >= RExC_end) {\n                    goto unterminated_verb_pattern;\n                }\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t        while ( RExC_parse < RExC_end && *RExC_parse != ')' )\n                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )\n                  unterminated_verb_pattern:\n\t            vFAIL(\"Unterminated verb pattern argument\");\n\t        if ( RExC_parse == start_arg )\n\t            start_arg = NULL;\n\t    } else {\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )\n\t            vFAIL(\"Unterminated verb pattern\");\n\t    }\n\n            /* Here, we know that RExC_parse < RExC_end */\n\n\t    switch ( *start_verb ) {\n            case 'A':  /* (*ACCEPT) */\n                if ( memEQs(start_verb,verb_len,\"ACCEPT\") ) {\n\t\t    op = ACCEPT;\n\t\t    internal_argval = RExC_nestroot;\n\t\t}\n\t\tbreak;\n            case 'C':  /* (*COMMIT) */\n                if ( memEQs(start_verb,verb_len,\"COMMIT\") )\n                    op = COMMIT;\n                break;\n            case 'F':  /* (*FAIL) */\n                if ( verb_len==1 || memEQs(start_verb,verb_len,\"FAIL\") ) {\n\t\t    op = OPFAIL;\n\t\t}\n\t\tbreak;\n            case ':':  /* (*:NAME) */\n\t    case 'M':  /* (*MARK:NAME) */\n\t        if ( verb_len==0 || memEQs(start_verb,verb_len,\"MARK\") ) {\n                    op = MARKPOINT;\n                    arg_required = 1;\n                }\n                break;\n            case 'P':  /* (*PRUNE) */\n                if ( memEQs(start_verb,verb_len,\"PRUNE\") )\n                    op = PRUNE;\n                break;\n            case 'S':   /* (*SKIP) */\n                if ( memEQs(start_verb,verb_len,\"SKIP\") )\n                    op = SKIP;\n                break;\n            case 'T':  /* (*THEN) */\n                /* [19:06] <TimToady> :: is then */\n                if ( memEQs(start_verb,verb_len,\"THEN\") ) {\n                    op = CUTGROUP;\n                    RExC_seen |= REG_CUTGROUP_SEEN;\n                }\n                break;\n\t    }\n\t    if ( ! op ) {\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                vFAIL2utf8f(\n                    \"Unknown verb pattern '%\" UTF8f \"'\",\n                    UTF8fARG(UTF, verb_len, start_verb));\n\t    }\n            if ( arg_required && !start_arg ) {\n                vFAIL3(\"Verb pattern '%.*s' has a mandatory argument\",\n                    verb_len, start_verb);\n            }\n            if (internal_argval == -1) {\n                ret = reganode(pRExC_state, op, 0);\n            } else {\n                ret = reg2Lanode(pRExC_state, op, 0, internal_argval);\n            }\n            RExC_seen |= REG_VERBARG_SEEN;\n            if ( ! SIZE_ONLY ) {\n                if (start_arg) {\n                    SV *sv = newSVpvn( start_arg,\n                                       RExC_parse - start_arg);\n                    ARG(ret) = add_data( pRExC_state,\n                                         STR_WITH_LEN(\"S\"));\n                    RExC_rxi->data->data[ARG(ret)]=(void*)sv;\n                    ret->flags = 1;\n                } else {\n                    ret->flags = 0;\n                }\n                if ( internal_argval != -1 )\n                    ARG2L_SET(ret, internal_argval);\n            }\n\t    nextchar(pRExC_state);\n\t    return ret;\n        }\n        else if (*RExC_parse == '?') { /* (?...) */\n\t    bool is_logical = 0;\n\t    const char * const seqstart = RExC_parse;\n            const char * endptr;\n            if (has_intervening_patws) {\n                RExC_parse++;\n                vFAIL(\"In '(?...)', the '(' and '?' must be adjacent\");\n            }\n\n\t    RExC_parse++;           /* past the '?' */\n            paren = *RExC_parse;    /* might be a trailing NUL, if not\n                                       well-formed */\n            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n            if (RExC_parse > RExC_end) {\n                paren = '\\0';\n            }\n\t    ret = NULL;\t\t\t/* For look-ahead/behind. */\n\t    switch (paren) {\n\n\t    case 'P':\t/* (?P...) variants for those used to PCRE/Python */\n\t        paren = *RExC_parse;\n\t\tif ( paren == '<') {    /* (?P<...>) named capture */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P<... not terminated\");\n                    }\n\t\t    goto named_capture;\n                }\n                else if (paren == '>') {   /* (?P>name) named recursion */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P>... not terminated\");\n                    }\n                    goto named_recursion;\n                }\n                else if (paren == '=') {   /* (?P=...)  named backref */\n                    RExC_parse++;\n                    return handle_named_backref(pRExC_state, flagp,\n                                                parse_start, ')');\n                }\n                RExC_parse += SKIP_IF_CHAR(RExC_parse);\n                /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n\t\tvFAIL3(\"Sequence (%.*s...) not recognized\",\n                                RExC_parse-seqstart, seqstart);\n\t\tNOT_REACHED; /*NOTREACHED*/\n            case '<':           /* (?<...) */\n\t\tif (*RExC_parse == '!')\n\t\t    paren = ',';\n\t\telse if (*RExC_parse != '=')\n              named_capture:\n\t\t{               /* (?<...>) */\n\t\t    char *name_start;\n\t\t    SV *svname;\n\t\t    paren= '>';\n                /* FALLTHROUGH */\n            case '\\'':          /* (?'...') */\n                    name_start = RExC_parse;\n                    svname = reg_scan_name(pRExC_state,\n                        SIZE_ONLY    /* reverse test from the others */\n                        ? REG_RSN_RETURN_NAME\n                        : REG_RSN_RETURN_NULL);\n\t\t    if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != paren)\n                    {\n\t\t        vFAIL2(\"Sequence (?%c... not terminated\",\n\t\t            paren=='>' ? '<' : paren);\n                    }\n\t\t    if (SIZE_ONLY) {\n\t\t\tHE *he_str;\n\t\t\tSV *sv_dat = NULL;\n                        if (!svname) /* shouldn't happen */\n                            Perl_croak(aTHX_\n                                \"panic: reg_scan_name returned NULL\");\n                        if (!RExC_paren_names) {\n                            RExC_paren_names= newHV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_names));\n#ifdef DEBUGGING\n                            RExC_paren_name_list= newAV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_name_list));\n#endif\n                        }\n                        he_str = hv_fetch_ent( RExC_paren_names, svname, 1, 0 );\n                        if ( he_str )\n                            sv_dat = HeVAL(he_str);\n                        if ( ! sv_dat ) {\n                            /* croak baby croak */\n                            Perl_croak(aTHX_\n                                \"panic: paren_name hash element allocation failed\");\n                        } else if ( SvPOK(sv_dat) ) {\n                            /* (?|...) can mean we have dupes so scan to check\n                               its already been stored. Maybe a flag indicating\n                               we are inside such a construct would be useful,\n                               but the arrays are likely to be quite small, so\n                               for now we punt -- dmq */\n                            IV count = SvIV(sv_dat);\n                            I32 *pv = (I32*)SvPVX(sv_dat);\n                            IV i;\n                            for ( i = 0 ; i < count ; i++ ) {\n                                if ( pv[i] == RExC_npar ) {\n                                    count = 0;\n                                    break;\n                                }\n                            }\n                            if ( count ) {\n                                pv = (I32*)SvGROW(sv_dat,\n                                                SvCUR(sv_dat) + sizeof(I32)+1);\n                                SvCUR_set(sv_dat, SvCUR(sv_dat) + sizeof(I32));\n                                pv[count] = RExC_npar;\n                                SvIV_set(sv_dat, SvIVX(sv_dat) + 1);\n                            }\n                        } else {\n                            (void)SvUPGRADE(sv_dat,SVt_PVNV);\n                            sv_setpvn(sv_dat, (char *)&(RExC_npar),\n                                                                sizeof(I32));\n                            SvIOK_on(sv_dat);\n                            SvIV_set(sv_dat, 1);\n                        }\n#ifdef DEBUGGING\n                        /* Yes this does cause a memory leak in debugging Perls\n                         * */\n                        if (!av_store(RExC_paren_name_list,\n                                      RExC_npar, SvREFCNT_inc(svname)))\n                            SvREFCNT_dec_NN(svname);\n#endif\n\n                        /*sv_dump(sv_dat);*/\n                    }\n                    nextchar(pRExC_state);\n\t\t    paren = 1;\n\t\t    goto capturing_parens;\n\t\t}\n                RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t\tRExC_in_lookbehind++;\n\t\tRExC_parse++;\n                if (RExC_parse >= RExC_end) {\n                    vFAIL(\"Sequence (?... not terminated\");\n                }\n\n                /* FALLTHROUGH */\n\t    case '=':           /* (?=...) */\n\t\tRExC_seen_zerolen++;\n                break;\n\t    case '!':           /* (?!...) */\n\t\tRExC_seen_zerolen++;\n\t\t/* check if we're really just a \"FAIL\" assertion */\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t        if (*RExC_parse == ')') {\n                    ret=reganode(pRExC_state, OPFAIL, 0);\n\t            nextchar(pRExC_state);\n\t            return ret;\n\t        }\n\t        break;\n\t    case '|':           /* (?|...) */\n\t        /* branch reset, behave like a (?:...) except that\n\t           buffers in alternations share the same numbers */\n\t        paren = ':';\n\t        after_freeze = freeze_paren = RExC_npar;\n\t        break;\n\t    case ':':           /* (?:...) */\n\t    case '>':           /* (?>...) */\n\t\tbreak;\n\t    case '$':           /* (?$...) */\n\t    case '@':           /* (?@...) */\n\t\tvFAIL2(\"Sequence (?%c...) not implemented\", (int)paren);\n\t\tbreak;\n\t    case '0' :           /* (?0) */\n\t    case 'R' :           /* (?R) */\n                if (RExC_parse == RExC_end || *RExC_parse != ')')\n\t\t    FAIL(\"Sequence (?R) not terminated\");\n                num = 0;\n                RExC_seen |= REG_RECURSE_SEEN;\n\t\t*flagp |= POSTPONED;\n                goto gen_recurse_regop;\n\t\t/*notreached*/\n            /* named and numeric backreferences */\n            case '&':            /* (?&NAME) */\n                parse_start = RExC_parse - 1;\n              named_recursion:\n                {\n    \t\t    SV *sv_dat = reg_scan_name(pRExC_state,\n    \t\t        SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);\n    \t\t     num = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;\n                }\n                if (RExC_parse >= RExC_end || *RExC_parse != ')')\n                    vFAIL(\"Sequence (?&... not terminated\");\n                goto gen_recurse_regop;\n                /* NOTREACHED */\n            case '+':\n                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {\n                    RExC_parse++;\n                    vFAIL(\"Illegal pattern\");\n                }\n                goto parse_recursion;\n                /* NOTREACHED*/\n            case '-': /* (?-1) */\n                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {\n                    RExC_parse--; /* rewind to let it be handled later */\n                    goto parse_flags;\n                }\n                /* FALLTHROUGH */\n            case '1': case '2': case '3': case '4': /* (?1) */\n\t    case '5': case '6': case '7': case '8': case '9':\n\t        RExC_parse = (char *) seqstart + 1;  /* Point to the digit */\n              parse_recursion:\n                {\n                    bool is_neg = FALSE;\n                    UV unum;\n                    parse_start = RExC_parse - 1; /* MJD */\n                    if (*RExC_parse == '-') {\n                        RExC_parse++;\n                        is_neg = TRUE;\n                    }\n                    if (grok_atoUV(RExC_parse, &unum, &endptr)\n                        && unum <= I32_MAX\n                    ) {\n                        num = (I32)unum;\n                        RExC_parse = (char*)endptr;\n                    } else\n                        num = I32_MAX;\n                    if (is_neg) {\n                        /* Some limit for num? */\n                        num = -num;\n                    }\n                }\n\t        if (*RExC_parse!=')')\n\t            vFAIL(\"Expecting close bracket\");\n\n              gen_recurse_regop:\n                if ( paren == '-' ) {\n                    /*\n                    Diagram of capture buffer numbering.\n                    Top line is the normal capture buffer numbers\n                    Bottom line is the negative indexing as from\n                    the X (the (?-2))\n\n                    +   1 2    3 4 5 X          6 7\n                       /(a(x)y)(a(b(c(?-2)d)e)f)(g(h))/\n                    -   5 4    3 2 1 X          x x\n\n                    */\n                    num = RExC_npar + num;\n                    if (num < 1)  {\n                        RExC_parse++;\n                        vFAIL(\"Reference to nonexistent group\");\n                    }\n                } else if ( paren == '+' ) {\n                    num = RExC_npar + num - 1;\n                }\n                /* We keep track how many GOSUB items we have produced.\n                   To start off the ARG2L() of the GOSUB holds its \"id\",\n                   which is used later in conjunction with RExC_recurse\n                   to calculate the offset we need to jump for the GOSUB,\n                   which it will store in the final representation.\n                   We have to defer the actual calculation until much later\n                   as the regop may move.\n                 */\n\n                ret = reg2Lanode(pRExC_state, GOSUB, num, RExC_recurse_count);\n                if (!SIZE_ONLY) {\n\t\t    if (num > (I32)RExC_rx->nparens) {\n\t\t\tRExC_parse++;\n\t\t\tvFAIL(\"Reference to nonexistent group\");\n\t            }\n\t            RExC_recurse_count++;\n                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Recurse #%\" UVuf \" to %\" IVdf \"\\n\",\n                              22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                              (UV)ARG(ret), (IV)ARG2L(ret)));\n                }\n                RExC_seen |= REG_RECURSE_SEEN;\n\n                Set_Node_Length(ret, 1 + regarglen[OP(ret)]); /* MJD */\n\t\tSet_Node_Offset(ret, parse_start); /* MJD */\n\n                *flagp |= POSTPONED;\n                assert(*RExC_parse == ')');\n                nextchar(pRExC_state);\n                return ret;\n\n            /* NOTREACHED */\n\n\t    case '?':           /* (??...) */\n\t\tis_logical = 1;\n\t\tif (*RExC_parse != '{') {\n                    RExC_parse += SKIP_IF_CHAR(RExC_parse);\n                    /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                    vFAIL2utf8f(\n                        \"Sequence (%\" UTF8f \"...) not recognized\",\n                        UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n\t\t    NOT_REACHED; /*NOTREACHED*/\n\t\t}\n\t\t*flagp |= POSTPONED;\n\t\tparen = '{';\n                RExC_parse++;\n\t\t/* FALLTHROUGH */\n\t    case '{':           /* (?{...}) */\n\t    {\n\t\tU32 n = 0;\n\t\tstruct reg_code_block *cb;\n\n\t\tRExC_seen_zerolen++;\n\n\t\tif (   !pRExC_state->code_blocks\n\t\t    || pRExC_state->code_index\n                                        >= pRExC_state->code_blocks->count\n\t\t    || pRExC_state->code_blocks->cb[pRExC_state->code_index].start\n\t\t\t!= (STRLEN)((RExC_parse -3 - (is_logical ? 1 : 0))\n\t\t\t    - RExC_start)\n\t\t) {\n\t\t    if (RExC_pm_flags & PMf_USE_RE_EVAL)\n\t\t\tFAIL(\"panic: Sequence (?{...}): no code block found\\n\");\n\t\t    FAIL(\"Eval-group not allowed at runtime, use re 'eval'\");\n\t\t}\n\t\t/* this is a pre-compiled code block (?{...}) */\n\t\tcb = &pRExC_state->code_blocks->cb[pRExC_state->code_index];\n\t\tRExC_parse = RExC_start + cb->end;\n\t\tif (!SIZE_ONLY) {\n\t\t    OP *o = cb->block;\n\t\t    if (cb->src_regex) {\n\t\t\tn = add_data(pRExC_state, STR_WITH_LEN(\"rl\"));\n\t\t\tRExC_rxi->data->data[n] =\n\t\t\t    (void*)SvREFCNT_inc((SV*)cb->src_regex);\n\t\t\tRExC_rxi->data->data[n+1] = (void*)o;\n\t\t    }\n\t\t    else {\n\t\t\tn = add_data(pRExC_state,\n\t\t\t       (RExC_pm_flags & PMf_HAS_CV) ? \"L\" : \"l\", 1);\n\t\t\tRExC_rxi->data->data[n] = (void*)o;\n\t\t    }\n\t\t}\n\t\tpRExC_state->code_index++;\n\t\tnextchar(pRExC_state);\n\n\t\tif (is_logical) {\n                    regnode *eval;\n\t\t    ret = reg_node(pRExC_state, LOGICAL);\n\n                    eval = reg2Lanode(pRExC_state, EVAL,\n                                       n,\n\n                                       /* for later propagation into (??{})\n                                        * return value */\n                                       RExC_flags & RXf_PMf_COMPILETIME\n                                      );\n\t\t    if (!SIZE_ONLY) {\n\t\t\tret->flags = 2;\n                    }\n                    REGTAIL(pRExC_state, ret, eval);\n                    /* deal with the length of this later - MJD */\n\t\t    return ret;\n\t\t}\n\t\tret = reg2Lanode(pRExC_state, EVAL, n, 0);\n\t\tSet_Node_Length(ret, RExC_parse - parse_start + 1);\n\t\tSet_Node_Offset(ret, parse_start);\n\t\treturn ret;\n\t    }\n\t    case '(':           /* (?(?{...})...) and (?(?=...)...) */\n\t    {\n\t        int is_define= 0;\n                const int DEFINE_len = sizeof(\"DEFINE\") - 1;\n\t\tif (RExC_parse[0] == '?') {        /* (?(?...)) */\n                    if (   RExC_parse < RExC_end - 1\n                        && (   RExC_parse[1] == '='\n                            || RExC_parse[1] == '!'\n                            || RExC_parse[1] == '<'\n                            || RExC_parse[1] == '{')\n                    ) { /* Lookahead or eval. */\n\t\t\tI32 flag;\n                        regnode *tail;\n\n\t\t\tret = reg_node(pRExC_state, LOGICAL);\n\t\t\tif (!SIZE_ONLY)\n\t\t\t    ret->flags = 1;\n\n                        tail = reg(pRExC_state, 1, &flag, depth+1);\n                        if (flag & (RESTART_PASS1|NEED_UTF8)) {\n                            *flagp = flag & (RESTART_PASS1|NEED_UTF8);\n                            return NULL;\n                        }\n                        REGTAIL(pRExC_state, ret, tail);\n\t\t\tgoto insert_if;\n\t\t    }\n\t\t    /* Fall through to \u2018Unknown switch condition\u2019 at the\n\t\t       end of the if/else chain. */\n\t\t}\n\t\telse if ( RExC_parse[0] == '<'     /* (?(<NAME>)...) */\n\t\t         || RExC_parse[0] == '\\'' ) /* (?('NAME')...) */\n\t        {\n\t            char ch = RExC_parse[0] == '<' ? '>' : '\\'';\n\t            char *name_start= RExC_parse++;\n\t            U32 num = 0;\n\t            SV *sv_dat=reg_scan_name(pRExC_state,\n\t                SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);\n\t            if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != ch)\n                    {\n                        vFAIL2(\"Sequence (?(%c... not terminated\",\n                            (ch == '>' ? '<' : ch));\n                    }\n                    RExC_parse++;\n\t            if (!SIZE_ONLY) {\n                        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n                        RExC_rxi->data->data[num]=(void*)sv_dat;\n                        SvREFCNT_inc_simple_void(sv_dat);\n                    }\n                    ret = reganode(pRExC_state,NGROUPP,num);\n                    goto insert_if_check_paren;\n\t\t}\n\t\telse if (memBEGINs(RExC_parse,\n                                   (STRLEN) (RExC_end - RExC_parse),\n                                   \"DEFINE\"))\n                {\n\t\t    ret = reganode(pRExC_state,DEFINEP,0);\n\t\t    RExC_parse += DEFINE_len;\n\t\t    is_define = 1;\n\t\t    goto insert_if_check_paren;\n\t\t}\n\t\telse if (RExC_parse[0] == 'R') {\n\t\t    RExC_parse++;\n                    /* parno == 0 => /(?(R)YES|NO)/  \"in any form of recursion OR eval\"\n                     * parno == 1 => /(?(R0)YES|NO)/ \"in GOSUB (?0) / (?R)\"\n                     * parno == 2 => /(?(R1)YES|NO)/ \"in GOSUB (?1) (parno-1)\"\n                     */\n\t\t    parno = 0;\n                    if (RExC_parse[0] == '0') {\n                        parno = 1;\n                        RExC_parse++;\n                    }\n                    else if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {\n                        UV uv;\n                        if (grok_atoUV(RExC_parse, &uv, &endptr)\n                            && uv <= I32_MAX\n                        ) {\n                            parno = (I32)uv + 1;\n                            RExC_parse = (char*)endptr;\n                        }\n                        /* else \"Switch condition not recognized\" below */\n\t\t    } else if (RExC_parse[0] == '&') {\n\t\t        SV *sv_dat;\n\t\t        RExC_parse++;\n\t\t        sv_dat = reg_scan_name(pRExC_state,\n                            SIZE_ONLY\n                            ? REG_RSN_RETURN_NULL\n                            : REG_RSN_RETURN_DATA);\n\n                        /* we should only have a false sv_dat when\n                         * SIZE_ONLY is true, and we always have false\n                         * sv_dat when SIZE_ONLY is true.\n                         * reg_scan_name() will VFAIL() if the name is\n                         * unknown when SIZE_ONLY is false, and otherwise\n                         * will return something, and when SIZE_ONLY is\n                         * true, reg_scan_name() just parses the string,\n                         * and doesnt return anything. (in theory) */\n                        assert(SIZE_ONLY ? !sv_dat : !!sv_dat);\n\n                        if (sv_dat)\n                            parno = 1 + *((I32 *)SvPVX(sv_dat));\n\t\t    }\n\t\t    ret = reganode(pRExC_state,INSUBP,parno);\n\t\t    goto insert_if_check_paren;\n\t\t}\n\t\telse if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {\n                    /* (?(1)...) */\n\t\t    char c;\n                    UV uv;\n                    if (grok_atoUV(RExC_parse, &uv, &endptr)\n                        && uv <= I32_MAX\n                    ) {\n                        parno = (I32)uv;\n                        RExC_parse = (char*)endptr;\n                    }\n                    else {\n                        vFAIL(\"panic: grok_atoUV returned FALSE\");\n                    }\n                    ret = reganode(pRExC_state, GROUPP, parno);\n\n                 insert_if_check_paren:\n\t\t    if (UCHARAT(RExC_parse) != ')') {\n                        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t\t\tvFAIL(\"Switch condition not recognized\");\n\t\t    }\n\t\t    nextchar(pRExC_state);\n\t\t  insert_if:\n                    REGTAIL(pRExC_state, ret, reganode(pRExC_state, IFTHEN, 0));\n                    br = regbranch(pRExC_state, &flags, 1,depth+1);\n\t\t    if (br == NULL) {\n                        if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                            *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                            return NULL;\n                        }\n                        FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf,\n                              (UV) flags);\n                    } else\n                        REGTAIL(pRExC_state, br, reganode(pRExC_state,\n                                                          LONGJMP, 0));\n\t\t    c = UCHARAT(RExC_parse);\n                    nextchar(pRExC_state);\n\t\t    if (flags&HASWIDTH)\n\t\t\t*flagp |= HASWIDTH;\n\t\t    if (c == '|') {\n\t\t        if (is_define)\n\t\t            vFAIL(\"(?(DEFINE)....) does not allow branches\");\n\n                        /* Fake one for optimizer.  */\n                        lastbr = reganode(pRExC_state, IFTHEN, 0);\n\n                        if (!regbranch(pRExC_state, &flags, 1,depth+1)) {\n                            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                                return NULL;\n                            }\n                            FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf,\n                                  (UV) flags);\n                        }\n                        REGTAIL(pRExC_state, ret, lastbr);\n\t\t \tif (flags&HASWIDTH)\n\t\t\t    *flagp |= HASWIDTH;\n                        c = UCHARAT(RExC_parse);\n                        nextchar(pRExC_state);\n\t\t    }\n\t\t    else\n\t\t\tlastbr = NULL;\n                    if (c != ')') {\n                        if (RExC_parse >= RExC_end)\n                            vFAIL(\"Switch (?(condition)... not terminated\");\n                        else\n                            vFAIL(\"Switch (?(condition)... contains too many branches\");\n                    }\n\t\t    ender = reg_node(pRExC_state, TAIL);\n                    REGTAIL(pRExC_state, br, ender);\n\t\t    if (lastbr) {\n                        REGTAIL(pRExC_state, lastbr, ender);\n                        REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);\n\t\t    }\n\t\t    else\n                        REGTAIL(pRExC_state, ret, ender);\n                    RExC_size++; /* XXX WHY do we need this?!!\n                                    For large programs it seems to be required\n                                    but I can't figure out why. -- dmq*/\n\t\t    return ret;\n\t\t}\n                RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                vFAIL(\"Unknown switch condition (?(...))\");\n\t    }\n\t    case '[':           /* (?[ ... ]) */\n                return handle_regex_sets(pRExC_state, NULL, flagp, depth+1,\n                                         oregcomp_parse);\n            case 0: /* A NUL */\n\t\tRExC_parse--; /* for vFAIL to print correctly */\n                vFAIL(\"Sequence (? incomplete\");\n                break;\n\t    default: /* e.g., (?i) */\n\t        RExC_parse = (char *) seqstart + 1;\n              parse_flags:\n\t\tparse_lparen_question_flags(pRExC_state);\n                if (UCHARAT(RExC_parse) != ':') {\n                    if (RExC_parse < RExC_end)\n                        nextchar(pRExC_state);\n                    *flagp = TRYAGAIN;\n                    return NULL;\n                }\n                paren = ':';\n                nextchar(pRExC_state);\n                ret = NULL;\n                goto parse_rest;\n            } /* end switch */\n\t}\n\telse if (!(RExC_flags & RXf_PMf_NOCAPTURE)) {   /* (...) */\n\t  capturing_parens:\n\t    parno = RExC_npar;\n\t    RExC_npar++;\n\n\t    ret = reganode(pRExC_state, OPEN, parno);\n\t    if (!SIZE_ONLY ){\n\t        if (!RExC_nestroot)\n\t            RExC_nestroot = parno;\n                if (RExC_open_parens && !RExC_open_parens[parno])\n\t        {\n                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting open paren #%\" IVdf \" to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\",\n\t\t\t(IV)parno, REG_NODE_NUM(ret)));\n                    RExC_open_parens[parno]= ret;\n\t        }\n\t    }\n            Set_Node_Length(ret, 1); /* MJD */\n            Set_Node_Offset(ret, RExC_parse); /* MJD */\n\t    is_open = 1;\n\t} else {\n            /* with RXf_PMf_NOCAPTURE treat (...) as (?:...) */\n            paren = ':';\n\t    ret = NULL;\n\t}\n    }\n    else                        /* ! paren */\n\tret = NULL;\n\n   parse_rest:\n    /* Pick up the branches, linking them together. */\n    parse_start = RExC_parse;   /* MJD */\n    br = regbranch(pRExC_state, &flags, 1,depth+1);\n\n    /*     branch_len = (paren != 0); */\n\n    if (br == NULL) {\n        if (flags & (RESTART_PASS1|NEED_UTF8)) {\n            *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n            return NULL;\n        }\n        FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf, (UV) flags);\n    }\n    if (*RExC_parse == '|') {\n\tif (!SIZE_ONLY && RExC_extralen) {\n\t    reginsert(pRExC_state, BRANCHJ, br, depth+1);\n\t}\n\telse {                  /* MJD */\n\t    reginsert(pRExC_state, BRANCH, br, depth+1);\n            Set_Node_Length(br, paren != 0);\n            Set_Node_Offset_To_R(br-RExC_emit_start, parse_start-RExC_start);\n        }\n\thave_branch = 1;\n\tif (SIZE_ONLY)\n\t    RExC_extralen += 1;\t\t/* For BRANCHJ-BRANCH. */\n    }\n    else if (paren == ':') {\n\t*flagp |= flags&SIMPLE;\n    }\n    if (is_open) {\t\t\t\t/* Starts with OPEN. */\n        REGTAIL(pRExC_state, ret, br);          /* OPEN -> first. */\n    }\n    else if (paren != '?')\t\t/* Not Conditional */\n\tret = br;\n    *flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    lastbr = br;\n    while (*RExC_parse == '|') {\n\tif (!SIZE_ONLY && RExC_extralen) {\n\t    ender = reganode(pRExC_state, LONGJMP,0);\n\n            /* Append to the previous. */\n            REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);\n\t}\n\tif (SIZE_ONLY)\n\t    RExC_extralen += 2;\t\t/* Account for LONGJMP. */\n\tnextchar(pRExC_state);\n\tif (freeze_paren) {\n\t    if (RExC_npar > after_freeze)\n\t        after_freeze = RExC_npar;\n            RExC_npar = freeze_paren;\n        }\n        br = regbranch(pRExC_state, &flags, 0, depth+1);\n\n\tif (br == NULL) {\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return NULL;\n            }\n            FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf, (UV) flags);\n        }\n        REGTAIL(pRExC_state, lastbr, br);               /* BRANCH -> BRANCH. */\n\tlastbr = br;\n\t*flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    }\n\n    if (have_branch || paren != ':') {\n\t/* Make a closing node, and hook it on the end. */\n\tswitch (paren) {\n\tcase ':':\n\t    ender = reg_node(pRExC_state, TAIL);\n\t    break;\n\tcase 1: case 2:\n\t    ender = reganode(pRExC_state, CLOSE, parno);\n            if ( RExC_close_parens ) {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting close paren #%\" IVdf \" to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\", (IV)parno, REG_NODE_NUM(ender)));\n                RExC_close_parens[parno]= ender;\n\t        if (RExC_nestroot == parno)\n\t            RExC_nestroot = 0;\n\t    }\n            Set_Node_Offset(ender,RExC_parse+1); /* MJD */\n            Set_Node_Length(ender,1); /* MJD */\n\t    break;\n\tcase '<':\n\tcase ',':\n\tcase '=':\n\tcase '!':\n\t    *flagp &= ~HASWIDTH;\n\t    /* FALLTHROUGH */\n\tcase '>':\n\t    ender = reg_node(pRExC_state, SUCCEED);\n\t    break;\n\tcase 0:\n\t    ender = reg_node(pRExC_state, END);\n\t    if (!SIZE_ONLY) {\n                assert(!RExC_end_op); /* there can only be one! */\n                RExC_end_op = ender;\n                if (RExC_close_parens) {\n                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting close paren #0 (END) to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\", REG_NODE_NUM(ender)));\n\n                    RExC_close_parens[0]= ender;\n                }\n            }\n\t    break;\n\t}\n        DEBUG_PARSE_r(if (!SIZE_ONLY) {\n            DEBUG_PARSE_MSG(\"lsbr\");\n            regprop(RExC_rx, RExC_mysv1, lastbr, NULL, pRExC_state);\n            regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ tying lastbr %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                          SvPV_nolen_const(RExC_mysv1),\n                          (IV)REG_NODE_NUM(lastbr),\n                          SvPV_nolen_const(RExC_mysv2),\n                          (IV)REG_NODE_NUM(ender),\n                          (IV)(ender - lastbr)\n            );\n        });\n        REGTAIL(pRExC_state, lastbr, ender);\n\n\tif (have_branch && !SIZE_ONLY) {\n            char is_nothing= 1;\n\t    if (depth==1)\n                RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n\n\t    /* Hook the tails of the branches to the closing node. */\n\t    for (br = ret; br; br = regnext(br)) {\n\t\tconst U8 op = PL_regkind[OP(br)];\n\t\tif (op == BRANCH) {\n                    REGTAIL_STUDY(pRExC_state, NEXTOPER(br), ender);\n                    if ( OP(NEXTOPER(br)) != NOTHING\n                         || regnext(NEXTOPER(br)) != ender)\n                        is_nothing= 0;\n\t\t}\n\t\telse if (op == BRANCHJ) {\n                    REGTAIL_STUDY(pRExC_state, NEXTOPER(NEXTOPER(br)), ender);\n                    /* for now we always disable this optimisation * /\n                    if ( OP(NEXTOPER(NEXTOPER(br))) != NOTHING\n                         || regnext(NEXTOPER(NEXTOPER(br))) != ender)\n                    */\n                        is_nothing= 0;\n\t\t}\n\t    }\n            if (is_nothing) {\n                br= PL_regkind[OP(ret)] != BRANCH ? regnext(ret) : ret;\n                DEBUG_PARSE_r(if (!SIZE_ONLY) {\n                    DEBUG_PARSE_MSG(\"NADA\");\n                    regprop(RExC_rx, RExC_mysv1, ret, NULL, pRExC_state);\n                    regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);\n                    Perl_re_printf( aTHX_  \"~ converting ret %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                                  SvPV_nolen_const(RExC_mysv1),\n                                  (IV)REG_NODE_NUM(ret),\n                                  SvPV_nolen_const(RExC_mysv2),\n                                  (IV)REG_NODE_NUM(ender),\n                                  (IV)(ender - ret)\n                    );\n                });\n                OP(br)= NOTHING;\n                if (OP(ender) == TAIL) {\n                    NEXT_OFF(br)= 0;\n                    RExC_emit= br + 1;\n                } else {\n                    regnode *opt;\n                    for ( opt= br + 1; opt < ender ; opt++ )\n                        OP(opt)= OPTIMIZED;\n                    NEXT_OFF(br)= ender - br;\n                }\n            }\n\t}\n    }\n\n    {\n        const char *p;\n        static const char parens[] = \"=!<,>\";\n\n\tif (paren && (p = strchr(parens, paren))) {\n\t    U8 node = ((p - parens) % 2) ? UNLESSM : IFMATCH;\n\t    int flag = (p - parens) > 1;\n\n\t    if (paren == '>')\n\t\tnode = SUSPEND, flag = 0;\n\t    reginsert(pRExC_state, node,ret, depth+1);\n            Set_Node_Cur_Length(ret, parse_start);\n\t    Set_Node_Offset(ret, parse_start + 1);\n\t    ret->flags = flag;\n            REGTAIL_STUDY(pRExC_state, ret, reg_node(pRExC_state, TAIL));\n\t}\n    }\n\n    /* Check for proper termination. */\n    if (paren) {\n        /* restore original flags, but keep (?p) and, if we've changed from /d\n         * rules to /u, keep the /u */\n\tRExC_flags = oregflags | (RExC_flags & RXf_PMf_KEEPCOPY);\n        if (DEPENDS_SEMANTICS && RExC_uni_semantics) {\n            set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n        }\n\tif (RExC_parse >= RExC_end || UCHARAT(RExC_parse) != ')') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched (\");\n\t}\n\tnextchar(pRExC_state);\n    }\n    else if (!paren && RExC_parse < RExC_end) {\n\tif (*RExC_parse == ')') {\n\t    RExC_parse++;\n\t    vFAIL(\"Unmatched )\");\n\t}\n\telse\n\t    FAIL(\"Junk on end of regexp\");\t/* \"Can't happen\". */\n\tNOT_REACHED; /* NOTREACHED */\n    }\n\n    if (RExC_in_lookbehind) {\n\tRExC_in_lookbehind--;\n    }\n    if (after_freeze > RExC_npar)\n        RExC_npar = after_freeze;\n    return(ret);\n}\n\n/*\n - regbranch - one alternative of an | operator\n *\n * Implements the concatenation operator.\n *\n * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be\n * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n */\nSTATIC regnode *\nS_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth)\n{\n    regnode *ret;\n    regnode *chain = NULL;\n    regnode *latest;\n    I32 flags = 0, c = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGBRANCH;\n\n    DEBUG_PARSE(\"brnc\");\n\n    if (first)\n\tret = NULL;\n    else {\n\tif (!SIZE_ONLY && RExC_extralen)\n\t    ret = reganode(pRExC_state, BRANCHJ,0);\n\telse {\n\t    ret = reg_node(pRExC_state, BRANCH);\n            Set_Node_Length(ret, 1);\n        }\n    }\n\n    if (!first && SIZE_ONLY)\n\tRExC_extralen += 1;\t\t\t/* BRANCHJ */\n\n    *flagp = WORST;\t\t\t/* Tentatively. */\n\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                            FALSE /* Don't force to /x */ );\n    while (RExC_parse < RExC_end && *RExC_parse != '|' && *RExC_parse != ')') {\n\tflags &= ~TRYAGAIN;\n        latest = regpiece(pRExC_state, &flags,depth+1);\n\tif (latest == NULL) {\n\t    if (flags & TRYAGAIN)\n\t\tcontinue;\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return NULL;\n            }\n            FAIL2(\"panic: regpiece returned NULL, flags=%#\" UVxf, (UV) flags);\n\t}\n\telse if (ret == NULL)\n            ret = latest;\n\t*flagp |= flags&(HASWIDTH|POSTPONED);\n\tif (chain == NULL) \t/* First piece. */\n\t    *flagp |= flags&SPSTART;\n\telse {\n\t    /* FIXME adding one for every branch after the first is probably\n\t     * excessive now we have TRIE support. (hv) */\n\t    MARK_NAUGHTY(1);\n            REGTAIL(pRExC_state, chain, latest);\n\t}\n\tchain = latest;\n\tc++;\n    }\n    if (chain == NULL) {\t/* Loop ran zero times. */\n\tchain = reg_node(pRExC_state, NOTHING);\n\tif (ret == NULL)\n\t    ret = chain;\n    }\n    if (c == 1) {\n\t*flagp |= flags&SIMPLE;\n    }\n\n    return ret;\n}\n\n/*\n - regpiece - something followed by possible quantifier * + ? {n,m}\n *\n * Note that the branching code sequences used for ? and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n *\n * Returns NULL, setting *flagp to TRYAGAIN if regatom() returns NULL with\n * TRYAGAIN.\n * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be\n * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n */\nSTATIC regnode *\nS_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    regnode *ret;\n    char op;\n    char *next;\n    I32 flags;\n    const char * const origparse = RExC_parse;\n    I32 min;\n    I32 max = REG_INFTY;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    char *parse_start;\n#endif\n    const char *maxpos = NULL;\n    UV uv;\n\n    /* Save the original in case we change the emitted regop to a FAIL. */\n    regnode * const orig_emit = RExC_emit;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPIECE;\n\n    DEBUG_PARSE(\"piec\");\n\n    ret = regatom(pRExC_state, &flags,depth+1);\n    if (ret == NULL) {\n\tif (flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8))\n\t    *flagp |= flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8);\n        else\n            FAIL2(\"panic: regatom returned NULL, flags=%#\" UVxf, (UV) flags);\n\treturn(NULL);\n    }\n\n    op = *RExC_parse;\n\n    if (op == '{' && regcurly(RExC_parse)) {\n\tmaxpos = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        parse_start = RExC_parse; /* MJD */\n#endif\n\tnext = RExC_parse + 1;\n\twhile (isDIGIT(*next) || *next == ',') {\n\t    if (*next == ',') {\n\t\tif (maxpos)\n\t\t    break;\n\t\telse\n\t\t    maxpos = next;\n\t    }\n\t    next++;\n\t}\n\tif (*next == '}') {\t\t/* got one */\n            const char* endptr;\n\t    if (!maxpos)\n\t\tmaxpos = next;\n\t    RExC_parse++;\n            if (isDIGIT(*RExC_parse)) {\n                if (!grok_atoUV(RExC_parse, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                min = (I32)uv;\n            } else {\n                min = 0;\n            }\n\t    if (*maxpos == ',')\n\t\tmaxpos++;\n\t    else\n\t\tmaxpos = RExC_parse;\n            if (isDIGIT(*maxpos)) {\n                if (!grok_atoUV(maxpos, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                max = (I32)uv;\n            } else {\n\t\tmax = REG_INFTY;\t\t/* meaning \"infinity\" */\n            }\n\t    RExC_parse = next;\n\t    nextchar(pRExC_state);\n            if (max < min) {    /* If can't match, warn and optimize to fail\n                                   unconditionally */\n                reginsert(pRExC_state, OPFAIL, orig_emit, depth+1);\n                if (PASS2) {\n                    ckWARNreg(RExC_parse, \"Quantifier {n,m} with n > m can't match\");\n                    NEXT_OFF(orig_emit)= regarglen[OPFAIL] + NODE_STEP_REGNODE;\n                }\n                return ret;\n            }\n            else if (min == max && *RExC_parse == '?')\n            {\n                if (PASS2) {\n                    ckWARN2reg(RExC_parse + 1,\n                               \"Useless use of greediness modifier '%c'\",\n                               *RExC_parse);\n                }\n            }\n\n\t  do_curly:\n\t    if ((flags&SIMPLE)) {\n                if (min == 0 && max == REG_INFTY) {\n                    reginsert(pRExC_state, STAR, ret, depth+1);\n                    MARK_NAUGHTY(4);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                if (min == 1 && max == REG_INFTY) {\n                    reginsert(pRExC_state, PLUS, ret, depth+1);\n                    MARK_NAUGHTY(3);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                MARK_NAUGHTY_EXP(2, 2);\n\t\treginsert(pRExC_state, CURLY, ret, depth+1);\n                Set_Node_Offset(ret, parse_start+1); /* MJD */\n                Set_Node_Cur_Length(ret, parse_start);\n\t    }\n\t    else {\n\t\tregnode * const w = reg_node(pRExC_state, WHILEM);\n\n\t\tw->flags = 0;\n                REGTAIL(pRExC_state, ret, w);\n\t\tif (!SIZE_ONLY && RExC_extralen) {\n\t\t    reginsert(pRExC_state, LONGJMP,ret, depth+1);\n\t\t    reginsert(pRExC_state, NOTHING,ret, depth+1);\n\t\t    NEXT_OFF(ret) = 3;\t/* Go over LONGJMP. */\n\t\t}\n\t\treginsert(pRExC_state, CURLYX,ret, depth+1);\n                                /* MJD hk */\n                Set_Node_Offset(ret, parse_start+1);\n                Set_Node_Length(ret,\n                                op == '{' ? (RExC_parse - parse_start) : 1);\n\n\t\tif (!SIZE_ONLY && RExC_extralen)\n\t\t    NEXT_OFF(ret) = 3;\t/* Go over NOTHING to LONGJMP. */\n                REGTAIL(pRExC_state, ret, reg_node(pRExC_state, NOTHING));\n\t\tif (SIZE_ONLY)\n\t\t    RExC_whilem_seen++, RExC_extralen += 3;\n                MARK_NAUGHTY_EXP(1, 4);     /* compound interest */\n\t    }\n\t    ret->flags = 0;\n\n\t    if (min > 0)\n\t\t*flagp = WORST;\n\t    if (max > 0)\n\t\t*flagp |= HASWIDTH;\n\t    if (!SIZE_ONLY) {\n\t\tARG1_SET(ret, (U16)min);\n\t\tARG2_SET(ret, (U16)max);\n\t    }\n            if (max == REG_INFTY)\n                RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n\n\t    goto nest_check;\n\t}\n    }\n\n    if (!ISMULT1(op)) {\n\t*flagp = flags;\n\treturn(ret);\n    }\n\n#if 0\t\t\t\t/* Now runtime fix should be reliable. */\n\n    /* if this is reinstated, don't forget to put this back into perldiag:\n\n\t    =item Regexp *+ operand could be empty at {#} in regex m/%s/\n\n\t   (F) The part of the regexp subject to either the * or + quantifier\n           could match an empty string. The {#} shows in the regular\n           expression about where the problem was discovered.\n\n    */\n\n    if (!(flags&HASWIDTH) && op != '?')\n      vFAIL(\"Regexp *+ operand could be empty\");\n#endif\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    parse_start = RExC_parse;\n#endif\n    nextchar(pRExC_state);\n\n    *flagp = (op != '+') ? (WORST|SPSTART|HASWIDTH) : (WORST|HASWIDTH);\n\n    if (op == '*') {\n\tmin = 0;\n\tgoto do_curly;\n    }\n    else if (op == '+') {\n\tmin = 1;\n\tgoto do_curly;\n    }\n    else if (op == '?') {\n\tmin = 0; max = 1;\n\tgoto do_curly;\n    }\n  nest_check:\n    if (!SIZE_ONLY && !(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3) {\n\tSAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */\n\tckWARN2reg(RExC_parse,\n\t\t   \"%\" UTF8f \" matches null string many times\",\n\t\t   UTF8fARG(UTF, (RExC_parse >= origparse\n                                 ? RExC_parse - origparse\n                                 : 0),\n\t\t   origparse));\n\t(void)ReREFCNT_inc(RExC_rx_sv);\n    }\n\n    if (*RExC_parse == '?') {\n\tnextchar(pRExC_state);\n\treginsert(pRExC_state, MINMOD, ret, depth+1);\n        REGTAIL(pRExC_state, ret, ret + NODE_STEP_REGNODE);\n    }\n    else if (*RExC_parse == '+') {\n        regnode *ender;\n        nextchar(pRExC_state);\n        ender = reg_node(pRExC_state, SUCCEED);\n        REGTAIL(pRExC_state, ret, ender);\n        reginsert(pRExC_state, SUSPEND, ret, depth+1);\n        ender = reg_node(pRExC_state, TAIL);\n        REGTAIL(pRExC_state, ret, ender);\n    }\n\n    if (ISMULT2(RExC_parse)) {\n\tRExC_parse++;\n\tvFAIL(\"Nested quantifiers\");\n    }\n\n    return(ret);\n}\n\nSTATIC bool\nS_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,\n                regnode ** node_p,\n                UV * code_point_p,\n                int * cp_count,\n                I32 * flagp,\n                const bool strict,\n                const U32 depth\n    )\n{\n /* This routine teases apart the various meanings of \\N and returns\n  * accordingly.  The input parameters constrain which meaning(s) is/are valid\n  * in the current context.\n  *\n  * Exactly one of <node_p> and <code_point_p> must be non-NULL.\n  *\n  * If <code_point_p> is not NULL, the context is expecting the result to be a\n  * single code point.  If this \\N instance turns out to a single code point,\n  * the function returns TRUE and sets *code_point_p to that code point.\n  *\n  * If <node_p> is not NULL, the context is expecting the result to be one of\n  * the things representable by a regnode.  If this \\N instance turns out to be\n  * one such, the function generates the regnode, returns TRUE and sets *node_p\n  * to point to that regnode.\n  *\n  * If this instance of \\N isn't legal in any context, this function will\n  * generate a fatal error and not return.\n  *\n  * On input, RExC_parse should point to the first char following the \\N at the\n  * time of the call.  On successful return, RExC_parse will have been updated\n  * to point to just after the sequence identified by this routine.  Also\n  * *flagp has been updated as needed.\n  *\n  * When there is some problem with the current context and this \\N instance,\n  * the function returns FALSE, without advancing RExC_parse, nor setting\n  * *node_p, nor *code_point_p, nor *flagp.\n  *\n  * If <cp_count> is not NULL, the caller wants to know the length (in code\n  * points) that this \\N sequence matches.  This is set even if the function\n  * returns FALSE, as detailed below.\n  *\n  * There are 5 possibilities here, as detailed in the next 5 paragraphs.\n  *\n  * Probably the most common case is for the \\N to specify a single code point.\n  * *cp_count will be set to 1, and *code_point_p will be set to that code\n  * point.\n  *\n  * Another possibility is for the input to be an empty \\N{}, which for\n  * backwards compatibility we accept.  *cp_count will be set to 0. *node_p\n  * will be set to a generated NOTHING node.\n  *\n  * Still another possibility is for the \\N to mean [^\\n]. *cp_count will be\n  * set to 0. *node_p will be set to a generated REG_ANY node.\n  *\n  * The fourth possibility is that \\N resolves to a sequence of more than one\n  * code points.  *cp_count will be set to the number of code points in the\n  * sequence. *node_p * will be set to a generated node returned by this\n  * function calling S_reg().\n  *\n  * The final possibility is that it is premature to be calling this function;\n  * that pass1 needs to be restarted.  This can happen when this changes from\n  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The\n  * latter occurs only when the fourth possibility would otherwise be in\n  * effect, and is because one of those code points requires the pattern to be\n  * recompiled as UTF-8.  The function returns FALSE, and sets the\n  * RESTART_PASS1 and NEED_UTF8 flags in *flagp, as appropriate.  When this\n  * happens, the caller needs to desist from continuing parsing, and return\n  * this information to its caller.  This is not set for when there is only one\n  * code point, as this can be called as part of an ANYOF node, and they can\n  * store above-Latin1 code points without the pattern having to be in UTF-8.\n  *\n  * For non-single-quoted regexes, the tokenizer has resolved character and\n  * sequence names inside \\N{...} into their Unicode values, normalizing the\n  * result into what we should see here: '\\N{U+c1.c2...}', where c1... are the\n  * hex-represented code points in the sequence.  This is done there because\n  * the names can vary based on what charnames pragma is in scope at the time,\n  * so we need a way to take a snapshot of what they resolve to at the time of\n  * the original parse. [perl #56444].\n  *\n  * That parsing is skipped for single-quoted regexes, so we may here get\n  * '\\N{NAME}'.  This is a fatal error.  These names have to be resolved by the\n  * parser.  But if the single-quoted regex is something like '\\N{U+41}', that\n  * is legal and handled here.  The code point is Unicode, and has to be\n  * translated into the native character set for non-ASCII platforms.\n  */\n\n    char * endbrace;    /* points to '}' following the name */\n    char *endchar;\t/* Points to '.' or '}' ending cur char in the input\n                           stream */\n    char* p = RExC_parse; /* Temporary */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_GROK_BSLASH_N;\n\n    GET_RE_DEBUG_FLAGS;\n\n    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */\n    assert(! (node_p && cp_count));               /* At most 1 should be set */\n\n    if (cp_count) {     /* Initialize return for the most common case */\n        *cp_count = 1;\n    }\n\n    /* The [^\\n] meaning of \\N ignores spaces and comments under the /x\n     * modifier.  The other meanings do not, so use a temporary until we find\n     * out which we are being called with */\n    skip_to_be_ignored_text(pRExC_state, &p,\n                            FALSE /* Don't force to /x */ );\n\n    /* Disambiguate between \\N meaning a named character versus \\N meaning\n     * [^\\n].  The latter is assumed when the {...} following the \\N is a legal\n     * quantifier, or there is no '{' at all */\n    if (*p != '{' || regcurly(p)) {\n\tRExC_parse = p;\n        if (cp_count) {\n            *cp_count = -1;\n        }\n\n\tif (! node_p) {\n            return FALSE;\n        }\n\n\t*node_p = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(*node_p, 1); /* MJD */\n\treturn TRUE;\n    }\n\n    /* Here, we have decided it should be a named character or sequence */\n\n    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t/* Skip past the '{' */\n\n    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t/* nothing between the {} */\n               || memBEGINs(RExC_parse,   /* U+ (bad hex is checked below\n                                                   for a  better error msg) */\n                                  (STRLEN) (RExC_end - RExC_parse),\n                                 \"U+\")))\n    {\n\tRExC_parse = endbrace;\t/* position msg's '<--HERE' */\n\tvFAIL(\"\\\\N{NAME} must be resolved by the lexer\");\n    }\n\n    REQUIRE_UNI_RULES(flagp, FALSE); /* Unicode named chars imply Unicode\n                                        semantics */\n\n    if (endbrace == RExC_parse) {   /* empty: \\N{} */\n        if (strict) {\n            RExC_parse++;   /* Position after the \"}\" */\n            vFAIL(\"Zero length \\\\N{}\");\n        }\n        if (cp_count) {\n            *cp_count = 0;\n        }\n        nextchar(pRExC_state);\n\tif (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state,NOTHING);\n        return TRUE;\n    }\n\n    RExC_parse += 2;\t/* Skip past the 'U+' */\n\n    /* Because toke.c has generated a special construct for us guaranteed not\n     * to have NULs, we can use a str function */\n    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n    /* Code points are separated by dots.  If none, there is only one code\n     * point, and is terminated by the brace */\n\n    if (endchar >= endbrace) {\n\tSTRLEN length_of_hex;\n\tI32 grok_hex_flags;\n\n        /* Here, exactly one code point.  If that isn't what is wanted, fail */\n        if (! code_point_p) {\n            RExC_parse = p;\n            return FALSE;\n        }\n\n        /* Convert code point from hex */\n\tlength_of_hex = (STRLEN)(endchar - RExC_parse);\n\tgrok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES\n                       | PERL_SCAN_DISALLOW_PREFIX\n\n                           /* No errors in the first pass (See [perl\n                            * #122671].)  We let the code below find the\n                            * errors when there are multiple chars. */\n                       | ((SIZE_ONLY)\n                          ? PERL_SCAN_SILENT_ILLDIGIT\n                          : 0);\n\n        /* This routine is the one place where both single- and double-quotish\n         * \\N{U+xxxx} are evaluated.  The value is a Unicode code point which\n         * must be converted to native. */\n\t*code_point_p = UNI_TO_NATIVE(grok_hex(RExC_parse,\n                                               &length_of_hex,\n                                               &grok_hex_flags,\n                                               NULL));\n\n\t/* The tokenizer should have guaranteed validity, but it's possible to\n         * bypass it by using single quoting, so check.  Don't do the check\n         * here when there are multiple chars; we do it below anyway. */\n        if (length_of_hex == 0\n            || length_of_hex != (STRLEN)(endchar - RExC_parse) )\n        {\n            RExC_parse += length_of_hex;\t/* Includes all the valid */\n            RExC_parse += (RExC_orig_utf8)\t/* point to after 1st invalid */\n                            ? UTF8SKIP(RExC_parse)\n                            : 1;\n            /* Guard against malformed utf8 */\n            if (RExC_parse >= endchar) {\n                RExC_parse = endchar;\n            }\n            vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n        }\n\n        RExC_parse = endbrace + 1;\n        return TRUE;\n    }\n    else {  /* Is a multiple character sequence */\n\tSV * substitute_parse;\n\tSTRLEN len;\n\tchar *orig_end = RExC_end;\n\tchar *save_start = RExC_start;\n        I32 flags;\n\n        /* Count the code points, if desired, in the sequence */\n        if (cp_count) {\n            *cp_count = 0;\n            while (RExC_parse < endbrace) {\n                /* Point to the beginning of the next character in the sequence. */\n                RExC_parse = endchar + 1;\n                endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n                (*cp_count)++;\n            }\n        }\n\n        /* Fail if caller doesn't want to handle a multi-code-point sequence.\n         * But don't backup up the pointer if the caller wants to know how many\n         * code points there are (they can then handle things) */\n        if (! node_p) {\n            if (! cp_count) {\n                RExC_parse = p;\n            }\n            return FALSE;\n        }\n\n\t/* What is done here is to convert this to a sub-pattern of the form\n         * \\x{char1}\\x{char2}...  and then call reg recursively to parse it\n         * (enclosing in \"(?: ... )\" ).  That way, it retains its atomicness,\n         * while not having to worry about special handling that some code\n         * points may have. */\n\n\tsubstitute_parse = newSVpvs(\"?:\");\n\n\twhile (RExC_parse < endbrace) {\n\n\t    /* Convert to notation the rest of the code understands */\n\t    sv_catpv(substitute_parse, \"\\\\x{\");\n\t    sv_catpvn(substitute_parse, RExC_parse, endchar - RExC_parse);\n\t    sv_catpv(substitute_parse, \"}\");\n\n\t    /* Point to the beginning of the next character in the sequence. */\n\t    RExC_parse = endchar + 1;\n\t    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n\t}\n        sv_catpv(substitute_parse, \")\");\n\n        len = SvCUR(substitute_parse);\n\n\t/* Don't allow empty number */\n\tif (len < (STRLEN) 8) {\n            RExC_parse = endbrace;\n\t    vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n\t}\n\n        RExC_parse = RExC_start = RExC_adjusted_start\n                                              = SvPV_nolen(substitute_parse);\n\tRExC_end = RExC_parse + len;\n\n        /* The values are Unicode, and therefore not subject to recoding, but\n         * have to be converted to native on a non-Unicode (meaning non-ASCII)\n         * platform. */\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 1;\n#endif\n\n        *node_p = reg(pRExC_state, 1, &flags, depth+1);\n\n        /* Restore the saved values */\n\tRExC_start = RExC_adjusted_start = save_start;\n\tRExC_parse = endbrace;\n\tRExC_end = orig_end;\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 0;\n#endif\n        SvREFCNT_dec_NN(substitute_parse);\n\n        if (! *node_p) {\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return FALSE;\n            }\n            FAIL2(\"panic: reg returned NULL to grok_bslash_N, flags=%#\" UVxf,\n                (UV) flags);\n        }\n        *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\n        nextchar(pRExC_state);\n\n        return TRUE;\n    }\n}\n\n\nPERL_STATIC_INLINE U8\nS_compute_EXACTish(RExC_state_t *pRExC_state)\n{\n    U8 op;\n\n    PERL_ARGS_ASSERT_COMPUTE_EXACTISH;\n\n    if (! FOLD) {\n        return (LOC)\n                ? EXACTL\n                : EXACT;\n    }\n\n    op = get_regex_charset(RExC_flags);\n    if (op >= REGEX_ASCII_RESTRICTED_CHARSET) {\n        op--; /* /a is same as /u, and map /aa's offset to what /a's would have\n                 been, so there is no hole */\n    }\n\n    return op + EXACTF;\n}\n\nPERL_STATIC_INLINE void\nS_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state,\n                         regnode *node, I32* flagp, STRLEN len, UV code_point,\n                         bool downgradable)\n{\n    /* This knows the details about sizing an EXACTish node, setting flags for\n     * it (by setting <*flagp>, and potentially populating it with a single\n     * character.\n     *\n     * If <len> (the length in bytes) is non-zero, this function assumes that\n     * the node has already been populated, and just does the sizing.  In this\n     * case <code_point> should be the final code point that has already been\n     * placed into the node.  This value will be ignored except that under some\n     * circumstances <*flagp> is set based on it.\n     *\n     * If <len> is zero, the function assumes that the node is to contain only\n     * the single character given by <code_point> and calculates what <len>\n     * should be.  In pass 1, it sizes the node appropriately.  In pass 2, it\n     * additionally will populate the node's STRING with <code_point> or its\n     * fold if folding.\n     *\n     * In both cases <*flagp> is appropriately set\n     *\n     * It knows that under FOLD, the Latin Sharp S and UTF characters above\n     * 255, must be folded (the former only when the rules indicate it can\n     * match 'ss')\n     *\n     * When it does the populating, it looks at the flag 'downgradable'.  If\n     * true with a node that folds, it checks if the single code point\n     * participates in a fold, and if not downgrades the node to an EXACT.\n     * This helps the optimizer */\n\n    bool len_passed_in = cBOOL(len != 0);\n    U8 character[UTF8_MAXBYTES_CASE+1];\n\n    PERL_ARGS_ASSERT_ALLOC_MAYBE_POPULATE_EXACT;\n\n    /* Don't bother to check for downgrading in PASS1, as it doesn't make any\n     * sizing difference, and is extra work that is thrown away */\n    if (downgradable && ! PASS2) {\n        downgradable = FALSE;\n    }\n\n    if (! len_passed_in) {\n        if (UTF) {\n            if (UVCHR_IS_INVARIANT(code_point)) {\n                if (LOC || ! FOLD) {    /* /l defers folding until runtime */\n                    *character = (U8) code_point;\n                }\n                else { /* Here is /i and not /l. (toFOLD() is defined on just\n                          ASCII, which isn't the same thing as INVARIANT on\n                          EBCDIC, but it works there, as the extra invariants\n                          fold to themselves) */\n                    *character = toFOLD((U8) code_point);\n\n                    /* We can downgrade to an EXACT node if this character\n                     * isn't a folding one.  Note that this assumes that\n                     * nothing above Latin1 folds to some other invariant than\n                     * one of these alphabetics; otherwise we would also have\n                     * to check:\n                     *  && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)\n                     *      || ASCII_FOLD_RESTRICTED))\n                     */\n                    if (downgradable && PL_fold[code_point] == code_point) {\n                        OP(node) = EXACT;\n                    }\n                }\n                len = 1;\n            }\n            else if (FOLD && (! LOC\n                              || ! is_PROBLEMATIC_LOCALE_FOLD_cp(code_point)))\n            {   /* Folding, and ok to do so now */\n                UV folded = _to_uni_fold_flags(\n                                   code_point,\n                                   character,\n                                   &len,\n                                   FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)\n                                                      ? FOLD_FLAGS_NOMIX_ASCII\n                                                      : 0));\n                if (downgradable\n                    && folded == code_point /* This quickly rules out many\n                                               cases, avoiding the\n                                               _invlist_contains_cp() overhead\n                                               for those.  */\n                    && ! _invlist_contains_cp(PL_utf8_foldable, code_point))\n                {\n                    OP(node) = (LOC)\n                               ? EXACTL\n                               : EXACT;\n                }\n            }\n            else if (code_point <= MAX_UTF8_TWO_BYTE) {\n\n                /* Not folding this cp, and can output it directly */\n                *character = UTF8_TWO_BYTE_HI(code_point);\n                *(character + 1) = UTF8_TWO_BYTE_LO(code_point);\n                len = 2;\n            }\n            else {\n                uvchr_to_utf8( character, code_point);\n                len = UTF8SKIP(character);\n            }\n        } /* Else pattern isn't UTF8.  */\n        else if (! FOLD) {\n            *character = (U8) code_point;\n            len = 1;\n        } /* Else is folded non-UTF8 */\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n        else if (LIKELY(code_point != LATIN_SMALL_LETTER_SHARP_S)) {\n#else\n        else if (1) {\n#endif\n            /* We don't fold any non-UTF8 except possibly the Sharp s  (see\n             * comments at join_exact()); */\n            *character = (U8) code_point;\n            len = 1;\n\n            /* Can turn into an EXACT node if we know the fold at compile time,\n             * and it folds to itself and doesn't particpate in other folds */\n            if (downgradable\n                && ! LOC\n                && PL_fold_latin1[code_point] == code_point\n                && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)\n                    || (isASCII(code_point) && ASCII_FOLD_RESTRICTED)))\n            {\n                OP(node) = EXACT;\n            }\n        } /* else is Sharp s.  May need to fold it */\n        else if (AT_LEAST_UNI_SEMANTICS && ! ASCII_FOLD_RESTRICTED) {\n            *character = 's';\n            *(character + 1) = 's';\n            len = 2;\n        }\n        else {\n            *character = LATIN_SMALL_LETTER_SHARP_S;\n            len = 1;\n        }\n    }\n\n    if (SIZE_ONLY) {\n        RExC_size += STR_SZ(len);\n    }\n    else {\n        RExC_emit += STR_SZ(len);\n        STR_LEN(node) = len;\n        if (! len_passed_in) {\n            Copy((char *) character, STRING(node), len, char);\n        }\n    }\n\n    *flagp |= HASWIDTH;\n\n    /* A single character node is SIMPLE, except for the special-cased SHARP S\n     * under /di. */\n    if ((len == 1 || (UTF && len == UVCHR_SKIP(code_point)))\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n        && ( code_point != LATIN_SMALL_LETTER_SHARP_S\n            || ! FOLD || ! DEPENDS_SEMANTICS)\n#endif\n    ) {\n        *flagp |= SIMPLE;\n    }\n\n    /* The OP may not be well defined in PASS1 */\n    if (PASS2 && OP(node) == EXACTFL) {\n        RExC_contains_locale = 1;\n    }\n}\n\nSTATIC bool\nS_new_regcurly(const char *s, const char *e)\n{\n    /* This is a temporary function designed to match the most lenient form of\n     * a {m,n} quantifier we ever envision, with either number omitted, and\n     * spaces anywhere between/before/after them.\n     *\n     * If this function fails, then the string it matches is very unlikely to\n     * ever be considered a valid quantifier, so we can allow the '{' that\n     * begins it to be considered as a literal */\n\n    bool has_min = FALSE;\n    bool has_max = FALSE;\n\n    PERL_ARGS_ASSERT_NEW_REGCURLY;\n\n    if (s >= e || *s++ != '{')\n\treturn FALSE;\n\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n    while (s < e && isDIGIT(*s)) {\n        has_min = TRUE;\n        s++;\n    }\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n\n    if (*s == ',') {\n\ts++;\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n        while (s < e && isDIGIT(*s)) {\n            has_max = TRUE;\n            s++;\n        }\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n    }\n\n    return s < e && *s == '}' && (has_min || has_max);\n}\n\n/* Parse backref decimal value, unless it's too big to sensibly be a backref,\n * in which case return I32_MAX (rather than possibly 32-bit wrapping) */\n\nstatic I32\nS_backref_value(char *p)\n{\n    const char* endptr;\n    UV val;\n    if (grok_atoUV(p, &val, &endptr) && val <= I32_MAX)\n        return (I32)val;\n    return I32_MAX;\n}\n\n\n/*\n - regatom - the lowest level\n\n   Try to identify anything special at the start of the current parse position.\n   If there is, then handle it as required. This may involve generating a\n   single regop, such as for an assertion; or it may involve recursing, such as\n   to handle a () structure.\n\n   If the string doesn't start with something special then we gobble up\n   as much literal text as we can.  If we encounter a quantifier, we have to\n   back off the final literal character, as that quantifier applies to just it\n   and not to the whole string of literals.\n\n   Once we have been able to handle whatever type of thing started the\n   sequence, we return.\n\n   Note: we have to be careful with escapes, as they can be both literal\n   and special, and in the case of \\10 and friends, context determines which.\n\n   A summary of the code structure is:\n\n   switch (first_byte) {\n\tcases for each special:\n\t    handle this special;\n\t    break;\n\tcase '\\\\':\n\t    switch (2nd byte) {\n\t\tcases for each unambiguous special:\n\t\t    handle this special;\n\t\t    break;\n\t\tcases for each ambigous special/literal:\n\t\t    disambiguate;\n\t\t    if (special)  handle here\n\t\t    else goto defchar;\n\t\tdefault: // unambiguously literal:\n\t\t    goto defchar;\n\t    }\n\tdefault:  // is a literal char\n\t    // FALL THROUGH\n\tdefchar:\n\t    create EXACTish node for literal;\n\t    while (more input and node isn't full) {\n\t\tswitch (input_byte) {\n\t\t   cases for each special;\n                       make sure parse pointer is set so that the next call to\n                           regatom will see this special first\n                       goto loopdone; // EXACTish node terminated by prev. char\n\t\t   default:\n\t\t       append char to EXACTISH node;\n\t\t}\n\t        get next input byte;\n\t    }\n        loopdone:\n   }\n   return the generated node;\n\n   Specifically there are two separate switches for handling\n   escape sequences, with the one for handling literal escapes requiring\n   a dummy entry for all of the special escapes that are actually handled\n   by the other.\n\n   Returns NULL, setting *flagp to TRYAGAIN if reg() returns NULL with\n   TRYAGAIN.\n   Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be\n   restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n   Otherwise does not return NULL.\n*/\n\nSTATIC regnode *\nS_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    regnode *ret = NULL;\n    I32 flags = 0;\n    char *parse_start;\n    U8 op;\n    int invert = 0;\n    U8 arg;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    *flagp = WORST;\t\t/* Tentatively. */\n\n    DEBUG_PARSE(\"atom\");\n\n    PERL_ARGS_ASSERT_REGATOM;\n\n  tryagain:\n    parse_start = RExC_parse;\n    assert(RExC_parse < RExC_end);\n    switch ((U8)*RExC_parse) {\n    case '^':\n\tRExC_seen_zerolen++;\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MBOL);\n\telse\n\t    ret = reg_node(pRExC_state, SBOL);\n        Set_Node_Length(ret, 1); /* MJD */\n\tbreak;\n    case '$':\n\tnextchar(pRExC_state);\n\tif (*RExC_parse)\n\t    RExC_seen_zerolen++;\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MEOL);\n\telse\n\t    ret = reg_node(pRExC_state, SEOL);\n        Set_Node_Length(ret, 1); /* MJD */\n\tbreak;\n    case '.':\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_SINGLELINE)\n\t    ret = reg_node(pRExC_state, SANY);\n\telse\n\t    ret = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(ret, 1); /* MJD */\n\tbreak;\n    case '[':\n    {\n\tchar * const oregcomp_parse = ++RExC_parse;\n        ret = regclass(pRExC_state, flagp,depth+1,\n                       FALSE, /* means parse the whole char class */\n                       TRUE, /* allow multi-char folds */\n                       FALSE, /* don't silence non-portable warnings. */\n                       (bool) RExC_strict,\n                       TRUE, /* Allow an optimized regnode result */\n                       NULL,\n                       NULL);\n        if (ret == NULL) {\n            if (*flagp & (RESTART_PASS1|NEED_UTF8))\n                return NULL;\n            FAIL2(\"panic: regclass returned NULL to regatom, flags=%#\" UVxf,\n                  (UV) *flagp);\n        }\n\tif (*RExC_parse != ']') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched [\");\n\t}\n\tnextchar(pRExC_state);\n        Set_Node_Length(ret, RExC_parse - oregcomp_parse + 1); /* MJD */\n\tbreak;\n    }\n    case '(':\n\tnextchar(pRExC_state);\n        ret = reg(pRExC_state, 2, &flags,depth+1);\n\tif (ret == NULL) {\n\t\tif (flags & TRYAGAIN) {\n\t\t    if (RExC_parse >= RExC_end) {\n\t\t\t /* Make parent create an empty node if needed. */\n\t\t\t*flagp |= TRYAGAIN;\n\t\t\treturn(NULL);\n\t\t    }\n\t\t    goto tryagain;\n\t\t}\n                if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                    *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                    return NULL;\n                }\n                FAIL2(\"panic: reg returned NULL to regatom, flags=%#\" UVxf,\n                                                                 (UV) flags);\n\t}\n\t*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\tbreak;\n    case '|':\n    case ')':\n\tif (flags & TRYAGAIN) {\n\t    *flagp |= TRYAGAIN;\n\t    return NULL;\n\t}\n\tvFAIL(\"Internal urp\");\n\t\t\t\t/* Supposed to be caught earlier. */\n\tbreak;\n    case '?':\n    case '+':\n    case '*':\n\tRExC_parse++;\n\tvFAIL(\"Quantifier follows nothing\");\n\tbreak;\n    case '\\\\':\n\t/* Special Escapes\n\n\t   This switch handles escape sequences that resolve to some kind\n\t   of special regop and not to literal text. Escape sequnces that\n\t   resolve to literal text are handled below in the switch marked\n\t   \"Literal Escapes\".\n\n\t   Every entry in this switch *must* have a corresponding entry\n\t   in the literal escape switch. However, the opposite is not\n\t   required, as the default for this switch is to jump to the\n\t   literal text handling code.\n\t*/\n\tRExC_parse++;\n\tswitch ((U8)*RExC_parse) {\n\t/* Special Escapes */\n\tcase 'A':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, SBOL);\n            /* SBOL is shared with /^/ so we set the flags so we can tell\n             * /\\A/ from /^/ in split. We check ret because first pass we\n             * have no regop struct to set the flags on. */\n            if (PASS2)\n                ret->flags = 1;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'G':\n\t    ret = reg_node(pRExC_state, GPOS);\n            RExC_seen |= REG_GPOS_SEEN;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'K':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, KEEPS);\n\t    *flagp |= SIMPLE;\n\t    /* XXX:dmq : disabling in-place substitution seems to\n\t     * be necessary here to avoid cases of memory corruption, as\n\t     * with: C<$_=\"x\" x 80; s/x\\K/y/> -- rgs\n\t     */\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    goto finish_meta_pat;\n\tcase 'Z':\n\t    ret = reg_node(pRExC_state, SEOL);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'z':\n\t    ret = reg_node(pRExC_state, EOS);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'C':\n\t    vFAIL(\"\\\\C no longer supported\");\n\tcase 'X':\n\t    ret = reg_node(pRExC_state, CLUMP);\n\t    *flagp |= HASWIDTH;\n\t    goto finish_meta_pat;\n\n\tcase 'W':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'w':\n            arg = ANYOF_WORDCHAR;\n            goto join_posix;\n\n\tcase 'B':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'b':\n          {\n\t    regex_charset charset = get_regex_charset(RExC_flags);\n\n\t    RExC_seen_zerolen++;\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    op = BOUND + charset;\n\n            if (op == BOUNDL) {\n                RExC_contains_locale = 1;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n\t    *flagp |= SIMPLE;\n\t    if (RExC_parse >= RExC_end || *(RExC_parse + 1) != '{') {\n                FLAGS(ret) = TRADITIONAL_BOUND;\n                if (PASS2 && op > BOUNDA) {  /* /aa is same as /a */\n                    OP(ret) = BOUNDA;\n                }\n            }\n            else {\n                STRLEN length;\n                char name = *RExC_parse;\n                char * endbrace = NULL;\n                RExC_parse += 2;\n                if (RExC_parse < RExC_end) {\n                    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n                }\n\n                if (! endbrace) {\n                    vFAIL2(\"Missing right brace on \\\\%c{}\", name);\n                }\n                /* XXX Need to decide whether to take spaces or not.  Should be\n                 * consistent with \\p{}, but that currently is SPACE, which\n                 * means vertical too, which seems wrong\n                 * while (isBLANK(*RExC_parse)) {\n                    RExC_parse++;\n                }*/\n                if (endbrace == RExC_parse) {\n                    RExC_parse++;  /* After the '}' */\n                    vFAIL2(\"Empty \\\\%c{}\", name);\n                }\n                length = endbrace - RExC_parse;\n                /*while (isBLANK(*(RExC_parse + length - 1))) {\n                    length--;\n                }*/\n                switch (*RExC_parse) {\n                    case 'g':\n                        if (    length != 1\n                            && (memNEs(RExC_parse + 1, length - 1, \"cb\")))\n                        {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = GCB_BOUND;\n                        break;\n                    case 'l':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = LB_BOUND;\n                        break;\n                    case 's':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = SB_BOUND;\n                        break;\n                    case 'w':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = WB_BOUND;\n                        break;\n                    default:\n                      bad_bound_type:\n                        RExC_parse = endbrace;\n\t\t\tvFAIL2utf8f(\n                            \"'%\" UTF8f \"' is an unknown bound type\",\n\t\t\t    UTF8fARG(UTF, length, endbrace - length));\n                        NOT_REACHED; /*NOTREACHED*/\n                }\n                RExC_parse = endbrace;\n                REQUIRE_UNI_RULES(flagp, NULL);\n\n                if (PASS2 && op >= BOUNDA) {  /* /aa is same as /a */\n                    OP(ret) = BOUNDU;\n                    length += 4;\n\n                    /* Don't have to worry about UTF-8, in this message because\n                     * to get here the contents of the \\b must be ASCII */\n                    ckWARN4reg(RExC_parse + 1,  /* Include the '}' in msg */\n                              \"Using /u for '%.*s' instead of /%s\",\n                              (unsigned) length,\n                              endbrace - length + 1,\n                              (charset == REGEX_ASCII_RESTRICTED_CHARSET)\n                              ? ASCII_RESTRICT_PAT_MODS\n                              : ASCII_MORE_RESTRICT_PAT_MODS);\n                }\n\t    }\n\n            if (PASS2 && invert) {\n                OP(ret) += NBOUND - BOUND;\n            }\n\t    goto finish_meta_pat;\n          }\n\n\tcase 'D':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'd':\n            arg = ANYOF_DIGIT;\n            if (! DEPENDS_SEMANTICS) {\n                goto join_posix;\n            }\n\n            /* \\d doesn't have any matches in the upper Latin1 range, hence /d\n             * is equivalent to /u.  Changing to /u saves some branches at\n             * runtime */\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'R':\n\t    ret = reg_node(pRExC_state, LNBREAK);\n\t    *flagp |= HASWIDTH|SIMPLE;\n\t    goto finish_meta_pat;\n\n\tcase 'H':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'h':\n\t    arg = ANYOF_BLANK;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'V':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'v':\n\t    arg = ANYOF_VERTWS;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'S':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 's':\n            arg = ANYOF_SPACE;\n\n          join_posix:\n\n\t    op = POSIXD + get_regex_charset(RExC_flags);\n            if (op > POSIXA) {  /* /aa is same as /a */\n                op = POSIXA;\n            }\n            else if (op == POSIXL) {\n                RExC_contains_locale = 1;\n            }\n\n          join_posix_op_known:\n\n            if (invert) {\n                op += NPOSIXD - POSIXD;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n            if (! SIZE_ONLY) {\n                FLAGS(ret) = namedclass_to_classnum(arg);\n            }\n\n\t    *flagp |= HASWIDTH|SIMPLE;\n            /* FALLTHROUGH */\n\n          finish_meta_pat:\n            if (   UCHARAT(RExC_parse + 1) == '{'\n                && UNLIKELY(! new_regcurly(RExC_parse + 1, RExC_end)))\n            {\n                RExC_parse += 2;\n                vFAIL(\"Unescaped left brace in regex is illegal here\");\n            }\n\t    nextchar(pRExC_state);\n            Set_Node_Length(ret, 2); /* MJD */\n\t    break;\n\tcase 'p':\n\tcase 'P':\n            RExC_parse--;\n\n            ret = regclass(pRExC_state, flagp,depth+1,\n                           TRUE, /* means just parse this element */\n                           FALSE, /* don't allow multi-char folds */\n                           FALSE, /* don't silence non-portable warnings.  It\n                                     would be a bug if these returned\n                                     non-portables */\n                           (bool) RExC_strict,\n                           TRUE, /* Allow an optimized regnode result */\n                           NULL,\n                           NULL);\n            if (*flagp & RESTART_PASS1)\n                return NULL;\n            /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if\n             * multi-char folds are allowed.  */\n            if (!ret)\n                FAIL2(\"panic: regclass returned NULL to regatom, flags=%#\" UVxf,\n                      (UV) *flagp);\n\n            RExC_parse--;\n\n            Set_Node_Offset(ret, parse_start);\n            Set_Node_Cur_Length(ret, parse_start - 2);\n            nextchar(pRExC_state);\n\t    break;\n        case 'N':\n            /* Handle \\N, \\N{} and \\N{NAMED SEQUENCE} (the latter meaning the\n             * \\N{...} evaluates to a sequence of more than one code points).\n             * The function call below returns a regnode, which is our result.\n             * The parameters cause it to fail if the \\N{} evaluates to a\n             * single code point; we handle those like any other literal.  The\n             * reason that the multicharacter case is handled here and not as\n             * part of the EXACtish code is because of quantifiers.  In\n             * /\\N{BLAH}+/, the '+' applies to the whole thing, and doing it\n             * this way makes that Just Happen. dmq.\n             * join_exact() will join this up with adjacent EXACTish nodes\n             * later on, if appropriate. */\n            ++RExC_parse;\n            if (grok_bslash_N(pRExC_state,\n                              &ret,     /* Want a regnode returned */\n                              NULL,     /* Fail if evaluates to a single code\n                                           point */\n                              NULL,     /* Don't need a count of how many code\n                                           points */\n                              flagp,\n                              RExC_strict,\n                              depth)\n            ) {\n                break;\n            }\n\n            if (*flagp & RESTART_PASS1)\n                return NULL;\n\n            /* Here, evaluates to a single code point.  Go get that */\n            RExC_parse = parse_start;\n            goto defchar;\n\n\tcase 'k':    /* Handle \\k<NAME> and \\k'NAME' */\n      parse_named_seq:\n        {\n            char ch;\n            if (   RExC_parse >= RExC_end - 1\n                || ((   ch = RExC_parse[1]) != '<'\n                                      && ch != '\\''\n                                      && ch != '{'))\n            {\n\t        RExC_parse++;\n\t\t/* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n\t        vFAIL2(\"Sequence %.2s... not terminated\",parse_start);\n\t    } else {\n\t\tRExC_parse += 2;\n                ret = handle_named_backref(pRExC_state,\n                                           flagp,\n                                           parse_start,\n                                           (ch == '<')\n                                           ? '>'\n                                           : (ch == '{')\n                                             ? '}'\n                                             : '\\'');\n            }\n            break;\n\t}\n\tcase 'g':\n\tcase '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t    {\n\t\tI32 num;\n\t\tbool hasbrace = 0;\n\n\t\tif (*RExC_parse == 'g') {\n                    bool isrel = 0;\n\n\t\t    RExC_parse++;\n\t\t    if (*RExC_parse == '{') {\n\t\t        RExC_parse++;\n\t\t        hasbrace = 1;\n\t\t    }\n\t\t    if (*RExC_parse == '-') {\n\t\t        RExC_parse++;\n\t\t        isrel = 1;\n\t\t    }\n\t\t    if (hasbrace && !isDIGIT(*RExC_parse)) {\n\t\t        if (isrel) RExC_parse--;\n                        RExC_parse -= 2;\n\t\t        goto parse_named_seq;\n                    }\n\n                    if (RExC_parse >= RExC_end) {\n                        goto unterminated_g;\n                    }\n                    num = S_backref_value(RExC_parse);\n                    if (num == 0)\n                        vFAIL(\"Reference to invalid group 0\");\n                    else if (num == I32_MAX) {\n                         if (isDIGIT(*RExC_parse))\n\t\t\t    vFAIL(\"Reference to nonexistent group\");\n                        else\n                          unterminated_g:\n                            vFAIL(\"Unterminated \\\\g... pattern\");\n                    }\n\n                    if (isrel) {\n                        num = RExC_npar - num;\n                        if (num < 1)\n                            vFAIL(\"Reference to nonexistent or unclosed group\");\n                    }\n                }\n                else {\n                    num = S_backref_value(RExC_parse);\n                    /* bare \\NNN might be backref or octal - if it is larger\n                     * than or equal RExC_npar then it is assumed to be an\n                     * octal escape. Note RExC_npar is +1 from the actual\n                     * number of parens. */\n                    /* Note we do NOT check if num == I32_MAX here, as that is\n                     * handled by the RExC_npar check */\n\n                    if (\n                        /* any numeric escape < 10 is always a backref */\n                        num > 9\n                        /* any numeric escape < RExC_npar is a backref */\n                        && num >= RExC_npar\n                        /* cannot be an octal escape if it starts with 8 */\n                        && *RExC_parse != '8'\n                        /* cannot be an octal escape it it starts with 9 */\n                        && *RExC_parse != '9'\n                    )\n                    {\n                        /* Probably not a backref, instead likely to be an\n                         * octal character escape, e.g. \\35 or \\777.\n                         * The above logic should make it obvious why using\n                         * octal escapes in patterns is problematic. - Yves */\n                        RExC_parse = parse_start;\n                        goto defchar;\n                    }\n                }\n\n                /* At this point RExC_parse points at a numeric escape like\n                 * \\12 or \\88 or something similar, which we should NOT treat\n                 * as an octal escape. It may or may not be a valid backref\n                 * escape. For instance \\88888888 is unlikely to be a valid\n                 * backref. */\n                while (isDIGIT(*RExC_parse))\n                    RExC_parse++;\n                if (hasbrace) {\n                    if (*RExC_parse != '}')\n                        vFAIL(\"Unterminated \\\\g{...} pattern\");\n                    RExC_parse++;\n                }\n                if (!SIZE_ONLY) {\n                    if (num > (I32)RExC_rx->nparens)\n                        vFAIL(\"Reference to nonexistent group\");\n                }\n                RExC_sawback = 1;\n                ret = reganode(pRExC_state,\n                               ((! FOLD)\n                                 ? REF\n                                 : (ASCII_FOLD_RESTRICTED)\n                                   ? REFFA\n                                   : (AT_LEAST_UNI_SEMANTICS)\n                                     ? REFFU\n                                     : (LOC)\n                                       ? REFFL\n                                       : REFF),\n                                num);\n                *flagp |= HASWIDTH;\n\n                /* override incorrect value set in reganode MJD */\n                Set_Node_Offset(ret, parse_start);\n                Set_Node_Cur_Length(ret, parse_start-1);\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t    }\n\t    break;\n\tcase '\\0':\n\t    if (RExC_parse >= RExC_end)\n\t\tFAIL(\"Trailing \\\\\");\n\t    /* FALLTHROUGH */\n\tdefault:\n\t    /* Do not generate \"unrecognized\" warnings here, we fall\n\t       back into the quick-grab loop below */\n            RExC_parse = parse_start;\n\t    goto defchar;\n\t} /* end of switch on a \\foo sequence */\n\tbreak;\n\n    case '#':\n\n        /* '#' comments should have been spaced over before this function was\n         * called */\n        assert((RExC_flags & RXf_PMf_EXTENDED) == 0);\n\t/*\n        if (RExC_flags & RXf_PMf_EXTENDED) {\n\t    RExC_parse = reg_skipcomment( pRExC_state, RExC_parse );\n\t    if (RExC_parse < RExC_end)\n\t\tgoto tryagain;\n\t}\n        */\n\n\t/* FALLTHROUGH */\n\n    default:\n\t  defchar: {\n\n            /* Here, we have determined that the next thing is probably a\n             * literal character.  RExC_parse points to the first byte of its\n             * definition.  (It still may be an escape sequence that evaluates\n             * to a single character) */\n\n\t    STRLEN len = 0;\n\t    UV ender = 0;\n\t    char *p;\n\t    char *s;\n#define MAX_NODE_STRING_SIZE 127\n\t    char foldbuf[MAX_NODE_STRING_SIZE+UTF8_MAXBYTES_CASE];\n\t    char *s0;\n\t    U8 upper_parse = MAX_NODE_STRING_SIZE;\n            U8 node_type = compute_EXACTish(pRExC_state);\n            bool next_is_quantifier;\n            char * oldp = NULL;\n\n            /* We can convert EXACTF nodes to EXACTFU if they contain only\n             * characters that match identically regardless of the target\n             * string's UTF8ness.  The reason to do this is that EXACTF is not\n             * trie-able, EXACTFU is.\n             *\n             * Similarly, we can convert EXACTFL nodes to EXACTFLU8 if they\n             * contain only above-Latin1 characters (hence must be in UTF8),\n             * which don't participate in folds with Latin1-range characters,\n             * as the latter's folds aren't known until runtime.  (We don't\n             * need to figure this out until pass 2) */\n            bool maybe_exactfu = PASS2\n                               && (node_type == EXACTF || node_type == EXACTFL);\n\n            /* If a folding node contains only code points that don't\n             * participate in folds, it can be changed into an EXACT node,\n             * which allows the optimizer more things to look for */\n            bool maybe_exact;\n\n\t    ret = reg_node(pRExC_state, node_type);\n\n            /* In pass1, folded, we use a temporary buffer instead of the\n             * actual node, as the node doesn't exist yet */\n\t    s = (SIZE_ONLY && FOLD) ? foldbuf : STRING(ret);\n\n            s0 = s;\n\n\t  reparse:\n\n            /* We look for the EXACTFish to EXACT node optimizaton only if\n             * folding.  (And we don't need to figure this out until pass 2).\n             * XXX It might actually make sense to split the node into portions\n             * that are exact and ones that aren't, so that we could later use\n             * the exact ones to find the longest fixed and floating strings.\n             * One would want to join them back into a larger node.  One could\n             * use a pseudo regnode like 'EXACT_ORIG_FOLD' */\n            maybe_exact = FOLD && PASS2;\n\n\t    /* XXX The node can hold up to 255 bytes, yet this only goes to\n             * 127.  I (khw) do not know why.  Keeping it somewhat less than\n             * 255 allows us to not have to worry about overflow due to\n             * converting to utf8 and fold expansion, but that value is\n             * 255-UTF8_MAXBYTES_CASE.  join_exact() may join adjacent nodes\n             * split up by this limit into a single one using the real max of\n             * 255.  Even at 127, this breaks under rare circumstances.  If\n             * folding, we do not want to split a node at a character that is a\n             * non-final in a multi-char fold, as an input string could just\n             * happen to want to match across the node boundary.  The join\n             * would solve that problem if the join actually happens.  But a\n             * series of more than two nodes in a row each of 127 would cause\n             * the first join to succeed to get to 254, but then there wouldn't\n             * be room for the next one, which could at be one of those split\n             * multi-char folds.  I don't know of any fool-proof solution.  One\n             * could back off to end with only a code point that isn't such a\n             * non-final, but it is possible for there not to be any in the\n             * entire node. */\n\n            assert(   ! UTF     /* Is at the beginning of a character */\n                   || UTF8_IS_INVARIANT(UCHARAT(RExC_parse))\n                   || UTF8_IS_START(UCHARAT(RExC_parse)));\n\n            /* Here, we have a literal character.  Find the maximal string of\n             * them in the input that we can fit into a single EXACTish node.\n             * We quit at the first non-literal or when the node gets full */\n\t    for (p = RExC_parse;\n\t         len < upper_parse && p < RExC_end;\n\t         len++)\n\t    {\n\t\toldp = p;\n\n                /* White space has already been ignored */\n                assert(   (RExC_flags & RXf_PMf_EXTENDED) == 0\n                       || ! is_PATWS_safe((p), RExC_end, UTF));\n\n\t\tswitch ((U8)*p) {\n\t\tcase '^':\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '[':\n\t\tcase '(':\n\t\tcase ')':\n\t\tcase '|':\n\t\t    goto loopdone;\n\t\tcase '\\\\':\n\t\t    /* Literal Escapes Switch\n\n\t\t       This switch is meant to handle escape sequences that\n\t\t       resolve to a literal character.\n\n\t\t       Every escape sequence that represents something\n\t\t       else, like an assertion or a char class, is handled\n\t\t       in the switch marked 'Special Escapes' above in this\n\t\t       routine, but also has an entry here as anything that\n\t\t       isn't explicitly mentioned here will be treated as\n\t\t       an unescaped equivalent literal.\n\t\t    */\n\n\t\t    switch ((U8)*++p) {\n\t\t    /* These are all the special escapes. */\n\t\t    case 'A':             /* Start assertion */\n\t\t    case 'b': case 'B':   /* Word-boundary assertion*/\n\t\t    case 'C':             /* Single char !DANGEROUS! */\n\t\t    case 'd': case 'D':   /* digit class */\n\t\t    case 'g': case 'G':   /* generic-backref, pos assertion */\n\t\t    case 'h': case 'H':   /* HORIZWS */\n\t\t    case 'k': case 'K':   /* named backref, keep marker */\n\t\t    case 'p': case 'P':   /* Unicode property */\n\t\t              case 'R':   /* LNBREAK */\n\t\t    case 's': case 'S':   /* space class */\n\t\t    case 'v': case 'V':   /* VERTWS */\n\t\t    case 'w': case 'W':   /* word class */\n                    case 'X':             /* eXtended Unicode \"combining\n                                             character sequence\" */\n\t\t    case 'z': case 'Z':   /* End of line/string assertion */\n\t\t\t--p;\n\t\t\tgoto loopdone;\n\n\t            /* Anything after here is an escape that resolves to a\n\t               literal. (Except digits, which may or may not)\n\t             */\n\t\t    case 'n':\n\t\t\tender = '\\n';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'N': /* Handle a single-code point named character. */\n                        RExC_parse = p + 1;\n                        if (! grok_bslash_N(pRExC_state,\n                                            NULL,   /* Fail if evaluates to\n                                                       anything other than a\n                                                       single code point */\n                                            &ender, /* The returned single code\n                                                       point */\n                                            NULL,   /* Don't need a count of\n                                                       how many code points */\n                                            flagp,\n                                            RExC_strict,\n                                            depth)\n                        ) {\n                            if (*flagp & NEED_UTF8)\n                                FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n                            if (*flagp & RESTART_PASS1)\n                                return NULL;\n\n                            /* Here, it wasn't a single code point.  Go close\n                             * up this EXACTish node.  The switch() prior to\n                             * this switch handles the other cases */\n                            RExC_parse = p = oldp;\n                            goto loopdone;\n                        }\n                        p = RExC_parse;\n                        RExC_parse = parse_start;\n                        if (ender > 0xff) {\n                            REQUIRE_UTF8(flagp);\n                        }\n                        break;\n\t\t    case 'r':\n\t\t\tender = '\\r';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 't':\n\t\t\tender = '\\t';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'f':\n\t\t\tender = '\\f';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'e':\n\t\t\tender = ESC_NATIVE;\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'a':\n\t\t\tender = '\\a';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'o':\n\t\t\t{\n\t\t\t    UV result;\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_o(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n\t\t\t\t\t\t       PASS2, /* out warnings */\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Output warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            ender = result;\n\t\t\t    if (ender > 0xff) {\n\t\t\t\tREQUIRE_UTF8(flagp);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'x':\n\t\t\t{\n                            UV result = UV_MAX; /* initialize to erroneous\n                                                   value */\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_x(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n\t\t\t\t\t\t       PASS2, /* out warnings */\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Silence warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            ender = result;\n\n                            if (ender < 0x100) {\n#ifdef EBCDIC\n                                if (RExC_recode_x_to_native) {\n                                    ender = LATIN1_TO_NATIVE(ender);\n                                }\n#endif\n\t\t\t    }\n                            else {\n\t\t\t\tREQUIRE_UTF8(flagp);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'c':\n\t\t\tp++;\n\t\t\tender = grok_bslash_c(*p++, PASS2);\n\t\t\tbreak;\n                    case '8': case '9': /* must be a backreference */\n                        --p;\n                        /* we have an escape like \\8 which cannot be an octal escape\n                         * so we exit the loop, and let the outer loop handle this\n                         * escape which may or may not be a legitimate backref. */\n                        goto loopdone;\n                    case '1': case '2': case '3':case '4':\n\t\t    case '5': case '6': case '7':\n                        /* When we parse backslash escapes there is ambiguity\n                         * between backreferences and octal escapes. Any escape\n                         * from \\1 - \\9 is a backreference, any multi-digit\n                         * escape which does not start with 0 and which when\n                         * evaluated as decimal could refer to an already\n                         * parsed capture buffer is a back reference. Anything\n                         * else is octal.\n                         *\n                         * Note this implies that \\118 could be interpreted as\n                         * 118 OR as \"\\11\" . \"8\" depending on whether there\n                         * were 118 capture buffers defined already in the\n                         * pattern.  */\n\n                        /* NOTE, RExC_npar is 1 more than the actual number of\n                         * parens we have seen so far, hence the < RExC_npar below. */\n\n                        if ( !isDIGIT(p[1]) || S_backref_value(p) < RExC_npar)\n                        {  /* Not to be treated as an octal constant, go\n                                   find backref */\n                            --p;\n                            goto loopdone;\n                        }\n                        /* FALLTHROUGH */\n                    case '0':\n\t\t\t{\n\t\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n\t\t\t    STRLEN numlen = 3;\n\t\t\t    ender = grok_oct(p, &numlen, &flags, NULL);\n\t\t\t    if (ender > 0xff) {\n\t\t\t\tREQUIRE_UTF8(flagp);\n\t\t\t    }\n\t\t\t    p += numlen;\n                            if (PASS2   /* like \\08, \\178 */\n                                && numlen < 3\n                                && isDIGIT(*p) && ckWARN(WARN_REGEXP))\n                            {\n\t\t\t\treg_warn_non_literal_string(\n                                         p + 1,\n                                         form_short_octal_warning(p, numlen));\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case '\\0':\n\t\t\tif (p >= RExC_end)\n\t\t\t    FAIL(\"Trailing \\\\\");\n\t\t\t/* FALLTHROUGH */\n\t\t    default:\n\t\t\tif (!SIZE_ONLY&& isALPHANUMERIC(*p)) {\n\t\t\t    /* Include any left brace following the alpha to emphasize\n\t\t\t     * that it could be part of an escape at some point\n\t\t\t     * in the future */\n\t\t\t    int len = (isALPHA(*p) && *(p + 1) == '{') ? 2 : 1;\n\t\t\t    ckWARN3reg(p + len, \"Unrecognized escape \\\\%.*s passed through\", len, p);\n\t\t\t}\n\t\t\tgoto normal_default;\n\t\t    } /* End of switch on '\\' */\n\t\t    break;\n\t\tcase '{':\n                    /* Currently we allow an lbrace at the start of a construct\n                     * without raising a warning.  This is because we think we\n                     * will never want such a brace to be meant to be other\n                     * than taken literally. */\n\t\t    if (len || (p > RExC_start && isALPHA_A(*(p - 1)))) {\n\n                        /* But, we raise a fatal warning otherwise, as the\n                         * deprecation cycle has come and gone.  Except that it\n                         * turns out that some heavily-relied on upstream\n                         * software, notably GNU Autoconf, have failed to fix\n                         * their uses.  For these, don't make it fatal unless\n                         * we anticipate using the '{' for something else.\n                         * This happens after any alpha, and for a looser {m,n}\n                         * quantifier specification */\n                        if (      RExC_strict\n                            || (  p > parse_start + 1\n                                && isALPHA_A(*(p - 1))\n                                && *(p - 2) == '\\\\')\n                            || new_regcurly(p, RExC_end))\n                        {\n                            RExC_parse = p + 1;\n                            vFAIL(\"Unescaped left brace in regex is \"\n                                  \"illegal here\");\n                        }\n                        if (PASS2) {\n                            ckWARNregdep(p + 1,\n                                        \"Unescaped left brace in regex is \"\n                                        \"deprecated here (and will be fatal \"\n                                        \"in Perl 5.30), passed through\");\n                        }\n\t\t    }\n\t\t    goto normal_default;\n                case '}':\n                case ']':\n                    if (PASS2 && p > RExC_parse && RExC_strict) {\n                        ckWARN2reg(p + 1, \"Unescaped literal '%c'\", *p);\n                    }\n\t\t    /*FALLTHROUGH*/\n\t\tdefault:    /* A literal character */\n\t\t  normal_default:\n\t\t    if (! UTF8_IS_INVARIANT(*p) && UTF) {\n\t\t\tSTRLEN numlen;\n\t\t\tender = utf8n_to_uvchr((U8*)p, RExC_end - p,\n\t\t\t\t\t       &numlen, UTF8_ALLOW_DEFAULT);\n\t\t\tp += numlen;\n\t\t    }\n\t\t    else\n\t\t\tender = (U8) *p++;\n\t\t    break;\n\t\t} /* End of switch on the literal */\n\n\t\t/* Here, have looked at the literal character and <ender>\n                 * contains its ordinal, <p> points to the character after it.\n                 * We need to check if the next non-ignored thing is a\n                 * quantifier.  Move <p> to after anything that should be\n                 * ignored, which, as a side effect, positions <p> for the next\n                 * loop iteration */\n                skip_to_be_ignored_text(pRExC_state, &p,\n                                        FALSE /* Don't force to /x */ );\n\n                /* If the next thing is a quantifier, it applies to this\n                 * character only, which means that this character has to be in\n                 * its own node and can't just be appended to the string in an\n                 * existing node, so if there are already other characters in\n                 * the node, close the node with just them, and set up to do\n                 * this character again next time through, when it will be the\n                 * only thing in its new node */\n\n                next_is_quantifier =    LIKELY(p < RExC_end)\n                                     && UNLIKELY(ISMULT2(p));\n\n                if (next_is_quantifier && LIKELY(len)) {\n                    p = oldp;\n                    goto loopdone;\n                }\n\n                /* Ready to add 'ender' to the node */\n\n                if (! FOLD) {  /* The simple case, just append the literal */\n\n                    /* In the sizing pass, we need only the size of the\n                     * character we are appending, hence we can delay getting\n                     * its representation until PASS2. */\n                    if (SIZE_ONLY) {\n                        if (UTF && ! UVCHR_IS_INVARIANT(ender)) {\n                            const STRLEN unilen = UVCHR_SKIP(ender);\n                            s += unilen;\n\n                            /* We have to subtract 1 just below (and again in\n                             * the corresponding PASS2 code) because the loop\n                             * increments <len> each time, as all but this path\n                             * (and one other) through it add a single byte to\n                             * the EXACTish node.  But these paths would change\n                             * len to be the correct final value, so cancel out\n                             * the increment that follows */\n                            len += unilen - 1;\n                        }\n                        else {\n                            s++;\n                        }\n                    } else { /* PASS2 */\n                      not_fold_common:\n                        if (UTF && ! UVCHR_IS_INVARIANT(ender)) {\n                            U8 * new_s = uvchr_to_utf8((U8*)s, ender);\n                            len += (char *) new_s - s - 1;\n                            s = (char *) new_s;\n                        }\n                        else {\n                            *(s++) = (char) ender;\n                        }\n                    }\n                }\n                else if (LOC && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)) {\n\n                    /* Here are folding under /l, and the code point is\n                     * problematic.  First, we know we can't simplify things */\n                    maybe_exact = FALSE;\n                    maybe_exactfu = FALSE;\n\n                    /* A problematic code point in this context means that its\n                     * fold isn't known until runtime, so we can't fold it now.\n                     * (The non-problematic code points are the above-Latin1\n                     * ones that fold to also all above-Latin1.  Their folds\n                     * don't vary no matter what the locale is.) But here we\n                     * have characters whose fold depends on the locale.\n                     * Unlike the non-folding case above, we have to keep track\n                     * of these in the sizing pass, so that we can make sure we\n                     * don't split too-long nodes in the middle of a potential\n                     * multi-char fold.  And unlike the regular fold case\n                     * handled in the else clauses below, we don't actually\n                     * fold and don't have special cases to consider.  What we\n                     * do for both passes is the PASS2 code for non-folding */\n                    goto not_fold_common;\n                }\n                else /* A regular FOLD code point */\n                    if (! (   UTF\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n                            /* See comments for join_exact() as to why we fold\n                             * this non-UTF at compile time */\n                            || (   node_type == EXACTFU\n                                && ender == LATIN_SMALL_LETTER_SHARP_S)\n#endif\n                )) {\n                    /* Here, are folding and are not UTF-8 encoded; therefore\n                     * the character must be in the range 0-255, and is not /l\n                     * (Not /l because we already handled these under /l in\n                     * is_PROBLEMATIC_LOCALE_FOLD_cp) */\n                    if (IS_IN_SOME_FOLD_L1(ender)) {\n                        maybe_exact = FALSE;\n\n                        /* See if the character's fold differs between /d and\n                         * /u.  This includes the multi-char fold SHARP S to\n                         * 'ss' */\n                        if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {\n                            RExC_seen_unfolded_sharp_s = 1;\n                            maybe_exactfu = FALSE;\n                        }\n                        else if (maybe_exactfu\n                            && (PL_fold[ender] != PL_fold_latin1[ender]\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n                                || (   len > 0\n                                    && isALPHA_FOLD_EQ(ender, 's')\n                                    && isALPHA_FOLD_EQ(*(s-1), 's'))\n#endif\n                        )) {\n                            maybe_exactfu = FALSE;\n                        }\n                    }\n\n                    /* Even when folding, we store just the input character, as\n                     * we have an array that finds its fold quickly */\n                    *(s++) = (char) ender;\n                }\n                else {  /* FOLD, and UTF (or sharp s) */\n                    /* Unlike the non-fold case, we do actually have to\n                     * calculate the results here in pass 1.  This is for two\n                     * reasons, the folded length may be longer than the\n                     * unfolded, and we have to calculate how many EXACTish\n                     * nodes it will take; and we may run out of room in a node\n                     * in the middle of a potential multi-char fold, and have\n                     * to back off accordingly.  */\n\n                    UV folded;\n                    if (isASCII_uni(ender)) {\n                        folded = toFOLD(ender);\n                        *(s)++ = (U8) folded;\n                    }\n                    else {\n                        STRLEN foldlen;\n\n                        folded = _to_uni_fold_flags(\n                                     ender,\n                                     (U8 *) s,\n                                     &foldlen,\n                                     FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)\n                                                        ? FOLD_FLAGS_NOMIX_ASCII\n                                                        : 0));\n                        s += foldlen;\n\n                        /* The loop increments <len> each time, as all but this\n                         * path (and one other) through it add a single byte to\n                         * the EXACTish node.  But this one has changed len to\n                         * be the correct final value, so subtract one to\n                         * cancel out the increment that follows */\n                        len += foldlen - 1;\n                    }\n                    /* If this node only contains non-folding code points so\n                     * far, see if this new one is also non-folding */\n                    if (maybe_exact) {\n                        if (folded != ender) {\n                            maybe_exact = FALSE;\n                        }\n                        else {\n                            /* Here the fold is the original; we have to check\n                             * further to see if anything folds to it */\n                            if (_invlist_contains_cp(PL_utf8_foldable,\n                                                        ender))\n                            {\n                                maybe_exact = FALSE;\n                            }\n                        }\n                    }\n                    ender = folded;\n\t\t}\n\n\t\tif (next_is_quantifier) {\n\n                    /* Here, the next input is a quantifier, and to get here,\n                     * the current character is the only one in the node.\n                     * Also, here <len> doesn't include the final byte for this\n                     * character */\n                    len++;\n                    goto loopdone;\n\t\t}\n\n\t    } /* End of loop through literal characters */\n\n            /* Here we have either exhausted the input or ran out of room in\n             * the node.  (If we encountered a character that can't be in the\n             * node, transfer is made directly to <loopdone>, and so we\n             * wouldn't have fallen off the end of the loop.)  In the latter\n             * case, we artificially have to split the node into two, because\n             * we just don't have enough space to hold everything.  This\n             * creates a problem if the final character participates in a\n             * multi-character fold in the non-final position, as a match that\n             * should have occurred won't, due to the way nodes are matched,\n             * and our artificial boundary.  So back off until we find a non-\n             * problematic character -- one that isn't at the beginning or\n             * middle of such a fold.  (Either it doesn't participate in any\n             * folds, or appears only in the final position of all the folds it\n             * does participate in.)  A better solution with far fewer false\n             * positives, and that would fill the nodes more completely, would\n             * be to actually have available all the multi-character folds to\n             * test against, and to back-off only far enough to be sure that\n             * this node isn't ending with a partial one.  <upper_parse> is set\n             * further below (if we need to reparse the node) to include just\n             * up through that final non-problematic character that this code\n             * identifies, so when it is set to less than the full node, we can\n             * skip the rest of this */\n            if (FOLD && p < RExC_end && upper_parse == MAX_NODE_STRING_SIZE) {\n\n                const STRLEN full_len = len;\n\n\t\tassert(len >= MAX_NODE_STRING_SIZE);\n\n                /* Here, <s> points to the final byte of the final character.\n                 * Look backwards through the string until find a non-\n                 * problematic character */\n\n\t\tif (! UTF) {\n\n                    /* This has no multi-char folds to non-UTF characters */\n                    if (ASCII_FOLD_RESTRICTED) {\n                        goto loopdone;\n                    }\n\n                    while (--s >= s0 && IS_NON_FINAL_FOLD(*s)) { }\n                    len = s - s0 + 1;\n\t\t}\n                else {\n                    if (!  PL_NonL1NonFinalFold) {\n                        PL_NonL1NonFinalFold = _new_invlist_C_array(\n                                        NonL1_Perl_Non_Final_Folds_invlist);\n                    }\n\n                    /* Point to the first byte of the final character */\n                    s = (char *) utf8_hop((U8 *) s, -1);\n\n                    while (s >= s0) {   /* Search backwards until find\n                                           non-problematic char */\n                        if (UTF8_IS_INVARIANT(*s)) {\n\n                            /* There are no ascii characters that participate\n                             * in multi-char folds under /aa.  In EBCDIC, the\n                             * non-ascii invariants are all control characters,\n                             * so don't ever participate in any folds. */\n                            if (ASCII_FOLD_RESTRICTED\n                                || ! IS_NON_FINAL_FOLD(*s))\n                            {\n                                break;\n                            }\n                        }\n                        else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {\n                            if (! IS_NON_FINAL_FOLD(EIGHT_BIT_UTF8_TO_NATIVE(\n                                                                  *s, *(s+1))))\n                            {\n                                break;\n                            }\n                        }\n                        else if (! _invlist_contains_cp(\n                                        PL_NonL1NonFinalFold,\n                                        valid_utf8_to_uvchr((U8 *) s, NULL)))\n                        {\n                            break;\n                        }\n\n                        /* Here, the current character is problematic in that\n                         * it does occur in the non-final position of some\n                         * fold, so try the character before it, but have to\n                         * special case the very first byte in the string, so\n                         * we don't read outside the string */\n                        s = (s == s0) ? s -1 : (char *) utf8_hop((U8 *) s, -1);\n                    } /* End of loop backwards through the string */\n\n                    /* If there were only problematic characters in the string,\n                     * <s> will point to before s0, in which case the length\n                     * should be 0, otherwise include the length of the\n                     * non-problematic character just found */\n                    len = (s < s0) ? 0 : s - s0 + UTF8SKIP(s);\n\t\t}\n\n                /* Here, have found the final character, if any, that is\n                 * non-problematic as far as ending the node without splitting\n                 * it across a potential multi-char fold.  <len> contains the\n                 * number of bytes in the node up-to and including that\n                 * character, or is 0 if there is no such character, meaning\n                 * the whole node contains only problematic characters.  In\n                 * this case, give up and just take the node as-is.  We can't\n                 * do any better */\n                if (len == 0) {\n                    len = full_len;\n\n                    /* If the node ends in an 's' we make sure it stays EXACTF,\n                     * as if it turns into an EXACTFU, it could later get\n                     * joined with another 's' that would then wrongly match\n                     * the sharp s */\n                    if (maybe_exactfu && isALPHA_FOLD_EQ(ender, 's'))\n                    {\n                        maybe_exactfu = FALSE;\n                    }\n                } else {\n\n                    /* Here, the node does contain some characters that aren't\n                     * problematic.  If one such is the final character in the\n                     * node, we are done */\n                    if (len == full_len) {\n                        goto loopdone;\n                    }\n                    else if (len + ((UTF) ? UTF8SKIP(s) : 1) == full_len) {\n\n                        /* If the final character is problematic, but the\n                         * penultimate is not, back-off that last character to\n                         * later start a new node with it */\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* Here, the final non-problematic character is earlier\n                     * in the input than the penultimate character.  What we do\n                     * is reparse from the beginning, going up only as far as\n                     * this final ok one, thus guaranteeing that the node ends\n                     * in an acceptable character.  The reason we reparse is\n                     * that we know how far in the character is, but we don't\n                     * know how to correlate its position with the input parse.\n                     * An alternate implementation would be to build that\n                     * correlation as we go along during the original parse,\n                     * but that would entail extra work for every node, whereas\n                     * this code gets executed only when the string is too\n                     * large for the node, and the final two characters are\n                     * problematic, an infrequent occurrence.  Yet another\n                     * possible strategy would be to save the tail of the\n                     * string, and the next time regatom is called, initialize\n                     * with that.  The problem with this is that unless you\n                     * back off one more character, you won't be guaranteed\n                     * regatom will get called again, unless regbranch,\n                     * regpiece ... are also changed.  If you do back off that\n                     * extra character, so that there is input guaranteed to\n                     * force calling regatom, you can't handle the case where\n                     * just the first character in the node is acceptable.  I\n                     * (khw) decided to try this method which doesn't have that\n                     * pitfall; if performance issues are found, we can do a\n                     * combination of the current approach plus that one */\n                    upper_parse = len;\n                    len = 0;\n                    s = s0;\n                    goto reparse;\n                }\n\t    }   /* End of verifying node ends with an appropriate char */\n\n          loopdone:   /* Jumped to when encounters something that shouldn't be\n                         in the node */\n\n            /* I (khw) don't know if you can get here with zero length, but the\n             * old code handled this situation by creating a zero-length EXACT\n             * node.  Might as well be NOTHING instead */\n            if (len == 0) {\n                OP(ret) = NOTHING;\n            }\n            else {\n                if (FOLD) {\n                    /* If 'maybe_exact' is still set here, means there are no\n                     * code points in the node that participate in folds;\n                     * similarly for 'maybe_exactfu' and code points that match\n                     * differently depending on UTF8ness of the target string\n                     * (for /u), or depending on locale for /l */\n                    if (maybe_exact) {\n                        OP(ret) = (LOC)\n                                  ? EXACTL\n                                  : EXACT;\n                    }\n                    else if (maybe_exactfu) {\n                        OP(ret) = (LOC)\n                                  ? EXACTFLU8\n                                  : EXACTFU;\n                    }\n                }\n                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, len, ender,\n                                           FALSE /* Don't look to see if could\n                                                    be turned into an EXACT\n                                                    node, as we have already\n                                                    computed that */\n                                          );\n            }\n\n\t    RExC_parse = p - 1;\n            Set_Node_Cur_Length(ret, parse_start);\n\t    RExC_parse = p;\n\t    {\n\t\t/* len is STRLEN which is unsigned, need to copy to signed */\n\t\tIV iv = len;\n\t\tif (iv < 0)\n\t\t    vFAIL(\"Internal disaster\");\n\t    }\n\n\t} /* End of label 'defchar:' */\n\tbreak;\n    } /* End of giant switch on input character */\n\n    /* Position parse to next real character */\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                            FALSE /* Don't force to /x */ );\n    if (PASS2 && *RExC_parse == '{' && OP(ret) != SBOL && ! regcurly(RExC_parse)) {\n        ckWARNregdep(RExC_parse + 1, \"Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through\");\n    }\n\n    return(ret);\n}\n\n\nSTATIC void\nS_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)\n{\n    /* Uses the inversion list '*invlist_ptr' to populate the ANYOF 'node'.  It\n     * sets up the bitmap and any flags, removing those code points from the\n     * inversion list, setting it to NULL should it become completely empty */\n\n    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;\n    assert(PL_regkind[OP(node)] == ANYOF);\n\n    ANYOF_BITMAP_ZERO(node);\n    if (*invlist_ptr) {\n\n\t/* This gets set if we actually need to modify things */\n\tbool change_invlist = FALSE;\n\n\tUV start, end;\n\n\t/* Start looking through *invlist_ptr */\n\tinvlist_iterinit(*invlist_ptr);\n\twhile (invlist_iternext(*invlist_ptr, &start, &end)) {\n\t    UV high;\n\t    int i;\n\n            if (end == UV_MAX && start <= NUM_ANYOF_CODE_POINTS) {\n                ANYOF_FLAGS(node) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;\n            }\n\n\t    /* Quit if are above what we should change */\n\t    if (start >= NUM_ANYOF_CODE_POINTS) {\n\t\tbreak;\n\t    }\n\n\t    change_invlist = TRUE;\n\n\t    /* Set all the bits in the range, up to the max that we are doing */\n\t    high = (end < NUM_ANYOF_CODE_POINTS - 1)\n                   ? end\n                   : NUM_ANYOF_CODE_POINTS - 1;\n\t    for (i = start; i <= (int) high; i++) {\n\t\tif (! ANYOF_BITMAP_TEST(node, i)) {\n\t\t    ANYOF_BITMAP_SET(node, i);\n\t\t}\n\t    }\n\t}\n\tinvlist_iterfinish(*invlist_ptr);\n\n        /* Done with loop; remove any code points that are in the bitmap from\n         * *invlist_ptr; similarly for code points above the bitmap if we have\n         * a flag to match all of them anyways */\n\tif (change_invlist) {\n\t    _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n        if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n\t    _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n\n\t/* If have completely emptied it, remove it completely */\n\tif (_invlist_len(*invlist_ptr) == 0) {\n\t    SvREFCNT_dec_NN(*invlist_ptr);\n\t    *invlist_ptr = NULL;\n\t}\n    }\n}\n\n/* Parse POSIX character classes: [[:foo:]], [[=foo=]], [[.foo.]].\n   Character classes ([:foo:]) can also be negated ([:^foo:]).\n   Returns a named class id (ANYOF_XXX) if successful, -1 otherwise.\n   Equivalence classes ([=foo=]) and composites ([.foo.]) are parsed,\n   but trigger failures because they are currently unimplemented. */\n\n#define POSIXCC_DONE(c)   ((c) == ':')\n#define POSIXCC_NOTYET(c) ((c) == '=' || (c) == '.')\n#define POSIXCC(c) (POSIXCC_DONE(c) || POSIXCC_NOTYET(c))\n#define MAYBE_POSIXCC(c) (POSIXCC(c) || (c) == '^' || (c) == ';')\n\n#define WARNING_PREFIX              \"Assuming NOT a POSIX class since \"\n#define NO_BLANKS_POSIX_WARNING     \"no blanks are allowed in one\"\n#define SEMI_COLON_POSIX_WARNING    \"a semi-colon was found instead of a colon\"\n\n#define NOT_MEANT_TO_BE_A_POSIX_CLASS (OOB_NAMEDCLASS - 1)\n\n/* 'posix_warnings' and 'warn_text' are names of variables in the following\n * routine. q.v. */\n#define ADD_POSIX_WARNING(p, text)  STMT_START {                            \\\n        if (posix_warnings) {                                               \\\n            if (! RExC_warn_text ) RExC_warn_text = (AV *) sv_2mortal((SV *) newAV()); \\\n            av_push(RExC_warn_text, Perl_newSVpvf(aTHX_                          \\\n                                             WARNING_PREFIX                 \\\n                                             text                           \\\n                                             REPORT_LOCATION,               \\\n                                             REPORT_LOCATION_ARGS(p)));     \\\n        }                                                                   \\\n    } STMT_END\n#define CLEAR_POSIX_WARNINGS()                                              \\\n    STMT_START {                                                            \\\n        if (posix_warnings && RExC_warn_text)                               \\\n            av_clear(RExC_warn_text);                                       \\\n    } STMT_END\n\n#define CLEAR_POSIX_WARNINGS_AND_RETURN(ret)                                \\\n    STMT_START {                                                            \\\n        CLEAR_POSIX_WARNINGS();                                             \\\n        return ret;                                                         \\\n    } STMT_END\n\nSTATIC int\nS_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state,\n\n    const char * const s,      /* Where the putative posix class begins.\n                                  Normally, this is one past the '['.  This\n                                  parameter exists so it can be somewhere\n                                  besides RExC_parse. */\n    char ** updated_parse_ptr, /* Where to set the updated parse pointer, or\n                                  NULL */\n    AV ** posix_warnings,      /* Where to place any generated warnings, or\n                                  NULL */\n    const bool check_only      /* Don't die if error */\n)\n{\n    /* This parses what the caller thinks may be one of the three POSIX\n     * constructs:\n     *  1) a character class, like [:blank:]\n     *  2) a collating symbol, like [. .]\n     *  3) an equivalence class, like [= =]\n     * In the latter two cases, it croaks if it finds a syntactically legal\n     * one, as these are not handled by Perl.\n     *\n     * The main purpose is to look for a POSIX character class.  It returns:\n     *  a) the class number\n     *      if it is a completely syntactically and semantically legal class.\n     *      'updated_parse_ptr', if not NULL, is set to point to just after the\n     *      closing ']' of the class\n     *  b) OOB_NAMEDCLASS\n     *      if it appears that one of the three POSIX constructs was meant, but\n     *      its specification was somehow defective.  'updated_parse_ptr', if\n     *      not NULL, is set to point to the character just after the end\n     *      character of the class.  See below for handling of warnings.\n     *  c) NOT_MEANT_TO_BE_A_POSIX_CLASS\n     *      if it  doesn't appear that a POSIX construct was intended.\n     *      'updated_parse_ptr' is not changed.  No warnings nor errors are\n     *      raised.\n     *\n     * In b) there may be errors or warnings generated.  If 'check_only' is\n     * TRUE, then any errors are discarded.  Warnings are returned to the\n     * caller via an AV* created into '*posix_warnings' if it is not NULL.  If\n     * instead it is NULL, warnings are suppressed.  This is done in all\n     * passes.  The reason for this is that the rest of the parsing is heavily\n     * dependent on whether this routine found a valid posix class or not.  If\n     * it did, the closing ']' is absorbed as part of the class.  If no class,\n     * or an invalid one is found, any ']' will be considered the terminator of\n     * the outer bracketed character class, leading to very different results.\n     * In particular, a '(?[ ])' construct will likely have a syntax error if\n     * the class is parsed other than intended, and this will happen in pass1,\n     * before the warnings would normally be output.  This mechanism allows the\n     * caller to output those warnings in pass1 just before dieing, giving a\n     * much better clue as to what is wrong.\n     *\n     * The reason for this function, and its complexity is that a bracketed\n     * character class can contain just about anything.  But it's easy to\n     * mistype the very specific posix class syntax but yielding a valid\n     * regular bracketed class, so it silently gets compiled into something\n     * quite unintended.\n     *\n     * The solution adopted here maintains backward compatibility except that\n     * it adds a warning if it looks like a posix class was intended but\n     * improperly specified.  The warning is not raised unless what is input\n     * very closely resembles one of the 14 legal posix classes.  To do this,\n     * it uses fuzzy parsing.  It calculates how many single-character edits it\n     * would take to transform what was input into a legal posix class.  Only\n     * if that number is quite small does it think that the intention was a\n     * posix class.  Obviously these are heuristics, and there will be cases\n     * where it errs on one side or another, and they can be tweaked as\n     * experience informs.\n     *\n     * The syntax for a legal posix class is:\n     *\n     * qr/(?xa: \\[ : \\^? [[:lower:]]{4,6} : \\] )/\n     *\n     * What this routine considers syntactically to be an intended posix class\n     * is this (the comments indicate some restrictions that the pattern\n     * doesn't show):\n     *\n     *  qr/(?x: \\[?                         # The left bracket, possibly\n     *                                      # omitted\n     *          \\h*                         # possibly followed by blanks\n     *          (?: \\^ \\h* )?               # possibly a misplaced caret\n     *          [:;]?                       # The opening class character,\n     *                                      # possibly omitted.  A typo\n     *                                      # semi-colon can also be used.\n     *          \\h*\n     *          \\^?                         # possibly a correctly placed\n     *                                      # caret, but not if there was also\n     *                                      # a misplaced one\n     *          \\h*\n     *          .{3,15}                     # The class name.  If there are\n     *                                      # deviations from the legal syntax,\n     *                                      # its edit distance must be close\n     *                                      # to a real class name in order\n     *                                      # for it to be considered to be\n     *                                      # an intended posix class.\n     *          \\h*\n     *          [[:punct:]]?                # The closing class character,\n     *                                      # possibly omitted.  If not a colon\n     *                                      # nor semi colon, the class name\n     *                                      # must be even closer to a valid\n     *                                      # one\n     *          \\h*\n     *          \\]?                         # The right bracket, possibly\n     *                                      # omitted.\n     *     )/\n     *\n     * In the above, \\h must be ASCII-only.\n     *\n     * These are heuristics, and can be tweaked as field experience dictates.\n     * There will be cases when someone didn't intend to specify a posix class\n     * that this warns as being so.  The goal is to minimize these, while\n     * maximizing the catching of things intended to be a posix class that\n     * aren't parsed as such.\n     */\n\n    const char* p             = s;\n    const char * const e      = RExC_end;\n    unsigned complement       = 0;      /* If to complement the class */\n    bool found_problem        = FALSE;  /* Assume OK until proven otherwise */\n    bool has_opening_bracket  = FALSE;\n    bool has_opening_colon    = FALSE;\n    int class_number          = OOB_NAMEDCLASS; /* Out-of-bounds until find\n                                                   valid class */\n    const char * possible_end = NULL;   /* used for a 2nd parse pass */\n    const char* name_start;             /* ptr to class name first char */\n\n    /* If the number of single-character typos the input name is away from a\n     * legal name is no more than this number, it is considered to have meant\n     * the legal name */\n    int max_distance          = 2;\n\n    /* to store the name.  The size determines the maximum length before we\n     * decide that no posix class was intended.  Should be at least\n     * sizeof(\"alphanumeric\") */\n    UV input_text[15];\n    STATIC_ASSERT_DECL(C_ARRAY_LENGTH(input_text) >= sizeof \"alphanumeric\");\n\n    PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX;\n\n    CLEAR_POSIX_WARNINGS();\n\n    if (p >= e) {\n        return NOT_MEANT_TO_BE_A_POSIX_CLASS;\n    }\n\n    if (*(p - 1) != '[') {\n        ADD_POSIX_WARNING(p, \"it doesn't start with a '['\");\n        found_problem = TRUE;\n    }\n    else {\n        has_opening_bracket = TRUE;\n    }\n\n    /* They could be confused and think you can put spaces between the\n     * components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    /* For [. .] and [= =].  These are quite different internally from [: :],\n     * so they are handled separately.  */\n    if (POSIXCC_NOTYET(*p) && p < e - 3) /* 1 for the close, and 1 for the ']'\n                                            and 1 for at least one char in it\n                                          */\n    {\n        const char open_char  = *p;\n        const char * temp_ptr = p + 1;\n\n        /* These two constructs are not handled by perl, and if we find a\n         * syntactically valid one, we croak.  khw, who wrote this code, finds\n         * this explanation of them very unclear:\n         * http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap09.html\n         * And searching the rest of the internet wasn't very helpful either.\n         * It looks like just about any byte can be in these constructs,\n         * depending on the locale.  But unless the pattern is being compiled\n         * under /l, which is very rare, Perl runs under the C or POSIX locale.\n         * In that case, it looks like [= =] isn't allowed at all, and that\n         * [. .] could be any single code point, but for longer strings the\n         * constituent characters would have to be the ASCII alphabetics plus\n         * the minus-hyphen.  Any sensible locale definition would limit itself\n         * to these.  And any portable one definitely should.  Trying to parse\n         * the general case is a nightmare (see [perl #127604]).  So, this code\n         * looks only for interiors of these constructs that match:\n         *      qr/.|[-\\w]{2,}/\n         * Using \\w relaxes the apparent rules a little, without adding much\n         * danger of mistaking something else for one of these constructs.\n         *\n         * [. .] in some implementations described on the internet is usable to\n         * escape a character that otherwise is special in bracketed character\n         * classes.  For example [.].] means a literal right bracket instead of\n         * the ending of the class\n         *\n         * [= =] can legitimately contain a [. .] construct, but we don't\n         * handle this case, as that [. .] construct will later get parsed\n         * itself and croak then.  And [= =] is checked for even when not under\n         * /l, as Perl has long done so.\n         *\n         * The code below relies on there being a trailing NUL, so it doesn't\n         * have to keep checking if the parse ptr < e.\n         */\n        if (temp_ptr[1] == open_char) {\n            temp_ptr++;\n        }\n        else while (    temp_ptr < e\n                    && (isWORDCHAR(*temp_ptr) || *temp_ptr == '-'))\n        {\n            temp_ptr++;\n        }\n\n        if (*temp_ptr == open_char) {\n            temp_ptr++;\n            if (*temp_ptr == ']') {\n                temp_ptr++;\n                if (! found_problem && ! check_only) {\n                    RExC_parse = (char *) temp_ptr;\n                    vFAIL3(\"POSIX syntax [%c %c] is reserved for future \"\n                            \"extensions\", open_char, open_char);\n                }\n\n                /* Here, the syntax wasn't completely valid, or else the call\n                 * is to check-only */\n                if (updated_parse_ptr) {\n                    *updated_parse_ptr = (char *) temp_ptr;\n                }\n\n                CLEAR_POSIX_WARNINGS_AND_RETURN(OOB_NAMEDCLASS);\n            }\n        }\n\n        /* If we find something that started out to look like one of these\n         * constructs, but isn't, we continue below so that it can be checked\n         * for being a class name with a typo of '.' or '=' instead of a colon.\n         * */\n    }\n\n    /* Here, we think there is a possibility that a [: :] class was meant, and\n     * we have the first real character.  It could be they think the '^' comes\n     * first */\n    if (*p == '^') {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p + 1, \"the '^' must come after the colon\");\n        complement = 1;\n        p++;\n\n        if (isBLANK(*p)) {\n            found_problem = TRUE;\n\n            do {\n                p++;\n            } while (p < e && isBLANK(*p));\n\n            ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n        }\n    }\n\n    /* But the first character should be a colon, which they could have easily\n     * mistyped on a qwerty keyboard as a semi-colon (and which may be hard to\n     * distinguish from a colon, so treat that as a colon).  */\n    if (*p == ':') {\n        p++;\n        has_opening_colon = TRUE;\n    }\n    else if (*p == ';') {\n        found_problem = TRUE;\n        p++;\n        ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        has_opening_colon = TRUE;\n    }\n    else {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p, \"there must be a starting ':'\");\n\n        /* Consider an initial punctuation (not one of the recognized ones) to\n         * be a left terminator */\n        if (*p != '^' && *p != ']' && isPUNCT(*p)) {\n            p++;\n        }\n    }\n\n    /* They may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == '^') {\n\n        /* We consider something like [^:^alnum:]] to not have been intended to\n         * be a posix class, but XXX maybe we should */\n        if (complement) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        complement = 1;\n        p++;\n    }\n\n    /* Again, they may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == ']') {\n\n        /* XXX This ']' may be a typo, and something else was meant.  But\n         * treating it as such creates enough complications, that that\n         * possibility isn't currently considered here.  So we assume that the\n         * ']' is what is intended, and if we've already found an initial '[',\n         * this leaves this construct looking like [:] or [:^], which almost\n         * certainly weren't intended to be posix classes */\n        if (has_opening_bracket) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* But this function can be called when we parse the colon for\n         * something like qr/[alpha:]]/, so we back up to look for the\n         * beginning */\n        p--;\n\n        if (*p == ';') {\n            found_problem = TRUE;\n            ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        }\n        else if (*p != ':') {\n\n            /* XXX We are currently very restrictive here, so this code doesn't\n             * consider the possibility that, say, /[alpha.]]/ was intended to\n             * be a posix class. */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Here we have something like 'foo:]'.  There was no initial colon,\n         * and we back up over 'foo.  XXX Unlike the going forward case, we\n         * don't handle typos of non-word chars in the middle */\n        has_opening_colon = FALSE;\n        p--;\n\n        while (p > RExC_start && isWORDCHAR(*p)) {\n            p--;\n        }\n        p++;\n\n        /* Here, we have positioned ourselves to where we think the first\n         * character in the potential class is */\n    }\n\n    /* Now the interior really starts.  There are certain key characters that\n     * can end the interior, or these could just be typos.  To catch both\n     * cases, we may have to do two passes.  In the first pass, we keep on\n     * going unless we come to a sequence that matches\n     *      qr/ [[:punct:]] [[:blank:]]* \\] /xa\n     * This means it takes a sequence to end the pass, so two typos in a row if\n     * that wasn't what was intended.  If the class is perfectly formed, just\n     * this one pass is needed.  We also stop if there are too many characters\n     * being accumulated, but this number is deliberately set higher than any\n     * real class.  It is set high enough so that someone who thinks that\n     * 'alphanumeric' is a correct name would get warned that it wasn't.\n     * While doing the pass, we keep track of where the key characters were in\n     * it.  If we don't find an end to the class, and one of the key characters\n     * was found, we redo the pass, but stop when we get to that character.\n     * Thus the key character was considered a typo in the first pass, but a\n     * terminator in the second.  If two key characters are found, we stop at\n     * the second one in the first pass.  Again this can miss two typos, but\n     * catches a single one\n     *\n     * In the first pass, 'possible_end' starts as NULL, and then gets set to\n     * point to the first key character.  For the second pass, it starts as -1.\n     * */\n\n    name_start = p;\n  parse_name:\n    {\n        bool has_blank               = FALSE;\n        bool has_upper               = FALSE;\n        bool has_terminating_colon   = FALSE;\n        bool has_terminating_bracket = FALSE;\n        bool has_semi_colon          = FALSE;\n        unsigned int name_len        = 0;\n        int punct_count              = 0;\n\n        while (p < e) {\n\n            /* Squeeze out blanks when looking up the class name below */\n            if (isBLANK(*p) ) {\n                has_blank = TRUE;\n                found_problem = TRUE;\n                p++;\n                continue;\n            }\n\n            /* The name will end with a punctuation */\n            if (isPUNCT(*p)) {\n                const char * peek = p + 1;\n\n                /* Treat any non-']' punctuation followed by a ']' (possibly\n                 * with intervening blanks) as trying to terminate the class.\n                 * ']]' is very likely to mean a class was intended (but\n                 * missing the colon), but the warning message that gets\n                 * generated shows the error position better if we exit the\n                 * loop at the bottom (eventually), so skip it here. */\n                if (*p != ']') {\n                    if (peek < e && isBLANK(*peek)) {\n                        has_blank = TRUE;\n                        found_problem = TRUE;\n                        do {\n                            peek++;\n                        } while (peek < e && isBLANK(*peek));\n                    }\n\n                    if (peek < e && *peek == ']') {\n                        has_terminating_bracket = TRUE;\n                        if (*p == ':') {\n                            has_terminating_colon = TRUE;\n                        }\n                        else if (*p == ';') {\n                            has_semi_colon = TRUE;\n                            has_terminating_colon = TRUE;\n                        }\n                        else {\n                            found_problem = TRUE;\n                        }\n                        p = peek + 1;\n                        goto try_posix;\n                    }\n                }\n\n                /* Here we have punctuation we thought didn't end the class.\n                 * Keep track of the position of the key characters that are\n                 * more likely to have been class-enders */\n                if (*p == ']' || *p == '[' || *p == ':' || *p == ';') {\n\n                    /* Allow just one such possible class-ender not actually\n                     * ending the class. */\n                    if (possible_end) {\n                        break;\n                    }\n                    possible_end = p;\n                }\n\n                /* If we have too many punctuation characters, no use in\n                 * keeping going */\n                if (++punct_count > max_distance) {\n                    break;\n                }\n\n                /* Treat the punctuation as a typo. */\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else if (isUPPER(*p)) { /* Use lowercase for lookup */\n                input_text[name_len++] = toLOWER(*p);\n                has_upper = TRUE;\n                found_problem = TRUE;\n                p++;\n            } else if (! UTF || UTF8_IS_INVARIANT(*p)) {\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else {\n                input_text[name_len++] = utf8_to_uvchr_buf((U8 *) p, e, NULL);\n                p+= UTF8SKIP(p);\n            }\n\n            /* The declaration of 'input_text' is how long we allow a potential\n             * class name to be, before saying they didn't mean a class name at\n             * all */\n            if (name_len >= C_ARRAY_LENGTH(input_text)) {\n                break;\n            }\n        }\n\n        /* We get to here when the possible class name hasn't been properly\n         * terminated before:\n         *   1) we ran off the end of the pattern; or\n         *   2) found two characters, each of which might have been intended to\n         *      be the name's terminator\n         *   3) found so many punctuation characters in the purported name,\n         *      that the edit distance to a valid one is exceeded\n         *   4) we decided it was more characters than anyone could have\n         *      intended to be one. */\n\n        found_problem = TRUE;\n\n        /* In the final two cases, we know that looking up what we've\n         * accumulated won't lead to a match, even a fuzzy one. */\n        if (   name_len >= C_ARRAY_LENGTH(input_text)\n            || punct_count > max_distance)\n        {\n            /* If there was an intermediate key character that could have been\n             * an intended end, redo the parse, but stop there */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1; /* Special signal value to say\n                                               we've done a first pass */\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Otherwise, it can't have meant to have been a class */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* If we ran off the end, and the final character was a punctuation\n         * one, back up one, to look at that final one just below.  Later, we\n         * will restore the parse pointer if appropriate */\n        if (name_len && p == e && isPUNCT(*(p-1))) {\n            p--;\n            name_len--;\n        }\n\n        if (p < e && isPUNCT(*p)) {\n            if (*p == ']') {\n                has_terminating_bracket = TRUE;\n\n                /* If this is a 2nd ']', and the first one is just below this\n                 * one, consider that to be the real terminator.  This gives a\n                 * uniform and better positioning for the warning message  */\n                if (   possible_end\n                    && possible_end != (char *) -1\n                    && *possible_end == ']'\n                    && name_len && input_text[name_len - 1] == ']')\n                {\n                    name_len--;\n                    p = possible_end;\n\n                    /* And this is actually equivalent to having done the 2nd\n                     * pass now, so set it to not try again */\n                    possible_end = (char *) -1;\n                }\n            }\n            else {\n                if (*p == ':') {\n                    has_terminating_colon = TRUE;\n                }\n                else if (*p == ';') {\n                    has_semi_colon = TRUE;\n                    has_terminating_colon = TRUE;\n                }\n                p++;\n            }\n        }\n\n    try_posix:\n\n        /* Here, we have a class name to look up.  We can short circuit the\n         * stuff below for short names that can't possibly be meant to be a\n         * class name.  (We can do this on the first pass, as any second pass\n         * will yield an even shorter name) */\n        if (name_len < 3) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Find which class it is.  Initially switch on the length of the name.\n         * */\n        switch (name_len) {\n            case 4:\n                if (memEQs(name_start, 4, \"word\")) {\n                    /* this is not POSIX, this is the Perl \\w */\n                    class_number = ANYOF_WORDCHAR;\n                }\n                break;\n            case 5:\n                /* Names all of length 5: alnum alpha ascii blank cntrl digit\n                 *                        graph lower print punct space upper\n                 * Offset 4 gives the best switch position.  */\n                switch (name_start[4]) {\n                    case 'a':\n                        if (memBEGINs(name_start, 5, \"alph\")) /* alpha */\n                            class_number = ANYOF_ALPHA;\n                        break;\n                    case 'e':\n                        if (memBEGINs(name_start, 5, \"spac\")) /* space */\n                            class_number = ANYOF_SPACE;\n                        break;\n                    case 'h':\n                        if (memBEGINs(name_start, 5, \"grap\")) /* graph */\n                            class_number = ANYOF_GRAPH;\n                        break;\n                    case 'i':\n                        if (memBEGINs(name_start, 5, \"asci\")) /* ascii */\n                            class_number = ANYOF_ASCII;\n                        break;\n                    case 'k':\n                        if (memBEGINs(name_start, 5, \"blan\")) /* blank */\n                            class_number = ANYOF_BLANK;\n                        break;\n                    case 'l':\n                        if (memBEGINs(name_start, 5, \"cntr\")) /* cntrl */\n                            class_number = ANYOF_CNTRL;\n                        break;\n                    case 'm':\n                        if (memBEGINs(name_start, 5, \"alnu\")) /* alnum */\n                            class_number = ANYOF_ALPHANUMERIC;\n                        break;\n                    case 'r':\n                        if (memBEGINs(name_start, 5, \"lowe\")) /* lower */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;\n                        else if (memBEGINs(name_start, 5, \"uppe\")) /* upper */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;\n                        break;\n                    case 't':\n                        if (memBEGINs(name_start, 5, \"digi\")) /* digit */\n                            class_number = ANYOF_DIGIT;\n                        else if (memBEGINs(name_start, 5, \"prin\")) /* print */\n                            class_number = ANYOF_PRINT;\n                        else if (memBEGINs(name_start, 5, \"punc\")) /* punct */\n                            class_number = ANYOF_PUNCT;\n                        break;\n                }\n                break;\n            case 6:\n                if (memEQs(name_start, 6, \"xdigit\"))\n                    class_number = ANYOF_XDIGIT;\n                break;\n        }\n\n        /* If the name exactly matches a posix class name the class number will\n         * here be set to it, and the input almost certainly was meant to be a\n         * posix class, so we can skip further checking.  If instead the syntax\n         * is exactly correct, but the name isn't one of the legal ones, we\n         * will return that as an error below.  But if neither of these apply,\n         * it could be that no posix class was intended at all, or that one\n         * was, but there was a typo.  We tease these apart by doing fuzzy\n         * matching on the name */\n        if (class_number == OOB_NAMEDCLASS && found_problem) {\n            const UV posix_names[][6] = {\n                                                { 'a', 'l', 'n', 'u', 'm' },\n                                                { 'a', 'l', 'p', 'h', 'a' },\n                                                { 'a', 's', 'c', 'i', 'i' },\n                                                { 'b', 'l', 'a', 'n', 'k' },\n                                                { 'c', 'n', 't', 'r', 'l' },\n                                                { 'd', 'i', 'g', 'i', 't' },\n                                                { 'g', 'r', 'a', 'p', 'h' },\n                                                { 'l', 'o', 'w', 'e', 'r' },\n                                                { 'p', 'r', 'i', 'n', 't' },\n                                                { 'p', 'u', 'n', 'c', 't' },\n                                                { 's', 'p', 'a', 'c', 'e' },\n                                                { 'u', 'p', 'p', 'e', 'r' },\n                                                { 'w', 'o', 'r', 'd' },\n                                                { 'x', 'd', 'i', 'g', 'i', 't' }\n                                            };\n            /* The names of the above all have added NULs to make them the same\n             * size, so we need to also have the real lengths */\n            const UV posix_name_lengths[] = {\n                                                sizeof(\"alnum\") - 1,\n                                                sizeof(\"alpha\") - 1,\n                                                sizeof(\"ascii\") - 1,\n                                                sizeof(\"blank\") - 1,\n                                                sizeof(\"cntrl\") - 1,\n                                                sizeof(\"digit\") - 1,\n                                                sizeof(\"graph\") - 1,\n                                                sizeof(\"lower\") - 1,\n                                                sizeof(\"print\") - 1,\n                                                sizeof(\"punct\") - 1,\n                                                sizeof(\"space\") - 1,\n                                                sizeof(\"upper\") - 1,\n                                                sizeof(\"word\")  - 1,\n                                                sizeof(\"xdigit\")- 1\n                                            };\n            unsigned int i;\n            int temp_max = max_distance;    /* Use a temporary, so if we\n                                               reparse, we haven't changed the\n                                               outer one */\n\n            /* Use a smaller max edit distance if we are missing one of the\n             * delimiters */\n            if (   has_opening_bracket + has_opening_colon < 2\n                || has_terminating_bracket + has_terminating_colon < 2)\n            {\n                temp_max--;\n            }\n\n            /* See if the input name is close to a legal one */\n            for (i = 0; i < C_ARRAY_LENGTH(posix_names); i++) {\n\n                /* Short circuit call if the lengths are too far apart to be\n                 * able to match */\n                if (abs( (int) (name_len - posix_name_lengths[i]))\n                    > temp_max)\n                {\n                    continue;\n                }\n\n                if (edit_distance(input_text,\n                                  posix_names[i],\n                                  name_len,\n                                  posix_name_lengths[i],\n                                  temp_max\n                                 )\n                    > -1)\n                { /* If it is close, it probably was intended to be a class */\n                    goto probably_meant_to_be;\n                }\n            }\n\n            /* Here the input name is not close enough to a valid class name\n             * for us to consider it to be intended to be a posix class.  If\n             * we haven't already done so, and the parse found a character that\n             * could have been terminators for the name, but which we absorbed\n             * as typos during the first pass, repeat the parse, signalling it\n             * to stop at that character */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1;\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Here neither pass found a close-enough class name */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n    probably_meant_to_be:\n\n        /* Here we think that a posix specification was intended.  Update any\n         * parse pointer */\n        if (updated_parse_ptr) {\n            *updated_parse_ptr = (char *) p;\n        }\n\n        /* If a posix class name was intended but incorrectly specified, we\n         * output or return the warnings */\n        if (found_problem) {\n\n            /* We set flags for these issues in the parse loop above instead of\n             * adding them to the list of warnings, because we can parse it\n             * twice, and we only want one warning instance */\n            if (has_upper) {\n                ADD_POSIX_WARNING(p, \"the name must be all lowercase letters\");\n            }\n            if (has_blank) {\n                ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n            }\n            if (has_semi_colon) {\n                ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n            }\n            else if (! has_terminating_colon) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ':'\");\n            }\n            if (! has_terminating_bracket) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ']'\");\n            }\n\n            if (posix_warnings && RExC_warn_text && av_top_index(RExC_warn_text) > -1) {\n                *posix_warnings = RExC_warn_text;\n            }\n        }\n        else if (class_number != OOB_NAMEDCLASS) {\n            /* If it is a known class, return the class.  The class number\n             * #defines are structured so each complement is +1 to the normal\n             * one */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(class_number + complement);\n        }\n        else if (! check_only) {\n\n            /* Here, it is an unrecognized class.  This is an error (unless the\n            * call is to check only, which we've already handled above) */\n            const char * const complement_string = (complement)\n                                                   ? \"^\"\n                                                   : \"\";\n            RExC_parse = (char *) p;\n            vFAIL3utf8f(\"POSIX class [:%s%\" UTF8f \":] unknown\",\n                        complement_string,\n                        UTF8fARG(UTF, RExC_parse - name_start - 2, name_start));\n        }\n    }\n\n    return OOB_NAMEDCLASS;\n}\n#undef ADD_POSIX_WARNING\n\nSTATIC unsigned  int\nS_regex_set_precedence(const U8 my_operator) {\n\n    /* Returns the precedence in the (?[...]) construct of the input operator,\n     * specified by its character representation.  The precedence follows\n     * general Perl rules, but it extends this so that ')' and ']' have (low)\n     * precedence even though they aren't really operators */\n\n    switch (my_operator) {\n        case '!':\n            return 5;\n        case '&':\n            return 4;\n        case '^':\n        case '|':\n        case '+':\n        case '-':\n            return 3;\n        case ')':\n            return 2;\n        case ']':\n            return 1;\n    }\n\n    NOT_REACHED; /* NOTREACHED */\n    return 0;   /* Silence compiler warning */\n}\n\nSTATIC regnode *\nS_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist,\n                    I32 *flagp, U32 depth,\n                    char * const oregcomp_parse)\n{\n    /* Handle the (?[...]) construct to do set operations */\n\n    U8 curchar;                     /* Current character being parsed */\n    UV start, end;\t            /* End points of code point ranges */\n    SV* final = NULL;               /* The end result inversion list */\n    SV* result_string;              /* 'final' stringified */\n    AV* stack;                      /* stack of operators and operands not yet\n                                       resolved */\n    AV* fence_stack = NULL;         /* A stack containing the positions in\n                                       'stack' of where the undealt-with left\n                                       parens would be if they were actually\n                                       put there */\n    /* The 'volatile' is a workaround for an optimiser bug\n     * in Solaris Studio 12.3. See RT #127455 */\n    volatile IV fence = 0;          /* Position of where most recent undealt-\n                                       with left paren in stack is; -1 if none.\n                                     */\n    STRLEN len;                     /* Temporary */\n    regnode* node;                  /* Temporary, and final regnode returned by\n                                       this function */\n    const bool save_fold = FOLD;    /* Temporary */\n    char *save_end, *save_parse;    /* Temporaries */\n    const bool in_locale = LOC;     /* we turn off /l during processing */\n    AV* posix_warnings = NULL;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_REGEX_SETS;\n\n    DEBUG_PARSE(\"xcls\");\n\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    REQUIRE_UNI_RULES(flagp, NULL);   /* The use of this operator implies /u.\n                                         This is required so that the compile\n                                         time values are valid in all runtime\n                                         cases */\n\n    /* This will return only an ANYOF regnode, or (unlikely) something smaller\n     * (such as EXACT).  Thus we can skip most everything if just sizing.  We\n     * call regclass to handle '[]' so as to not have to reinvent its parsing\n     * rules here (throwing away the size it computes each time).  And, we exit\n     * upon an unescaped ']' that isn't one ending a regclass.  To do both\n     * these things, we need to realize that something preceded by a backslash\n     * is escaped, so we have to keep track of backslashes */\n    if (SIZE_ONLY) {\n        UV nest_depth = 0; /* how many nested (?[...]) constructs */\n\n        while (RExC_parse < RExC_end) {\n            SV* current = NULL;\n\n            skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                    TRUE /* Force /x */ );\n\n            switch (*RExC_parse) {\n                case '?':\n                    if (RExC_parse[1] == '[') nest_depth++, RExC_parse++;\n                    /* FALLTHROUGH */\n                default:\n                    break;\n                case '\\\\':\n                    /* Skip past this, so the next character gets skipped, after\n                     * the switch */\n                    RExC_parse++;\n                    if (*RExC_parse == 'c') {\n                            /* Skip the \\cX notation for control characters */\n                            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                    }\n                    break;\n\n                case '[':\n                {\n                    /* See if this is a [:posix:] class. */\n                    bool is_posix_class = (OOB_NAMEDCLASS\n                            < handle_possible_posix(pRExC_state,\n                                                RExC_parse + 1,\n                                                NULL,\n                                                NULL,\n                                                TRUE /* checking only */));\n                    /* If it is a posix class, leave the parse pointer at the\n                     * '[' to fool regclass() into thinking it is part of a\n                     * '[[:posix:]]'. */\n                    if (! is_posix_class) {\n                        RExC_parse++;\n                    }\n\n                    /* regclass() can only return RESTART_PASS1 and NEED_UTF8\n                     * if multi-char folds are allowed.  */\n                    if (!regclass(pRExC_state, flagp,depth+1,\n                                  is_posix_class, /* parse the whole char\n                                                     class only if not a\n                                                     posix class */\n                                  FALSE, /* don't allow multi-char folds */\n                                  TRUE, /* silence non-portable warnings. */\n                                  TRUE, /* strict */\n                                  FALSE, /* Require return to be an ANYOF */\n                                  &current,\n                                  &posix_warnings\n                                 ))\n                        FAIL2(\"panic: regclass returned NULL to handle_sets, \"\n                              \"flags=%#\" UVxf, (UV) *flagp);\n\n                    /* function call leaves parse pointing to the ']', except\n                     * if we faked it */\n                    if (is_posix_class) {\n                        RExC_parse--;\n                    }\n\n                    SvREFCNT_dec(current);   /* In case it returned something */\n                    break;\n                }\n\n                case ']':\n                    if (nest_depth--) break;\n                    RExC_parse++;\n                    if (*RExC_parse == ')') {\n                        node = reganode(pRExC_state, ANYOF, 0);\n                        RExC_size += ANYOF_SKIP;\n                        nextchar(pRExC_state);\n                        Set_Node_Length(node,\n                                RExC_parse - oregcomp_parse + 1); /* MJD */\n                        if (in_locale) {\n                            set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);\n                        }\n\n                        return node;\n                    }\n                    goto no_close;\n            }\n\n            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n        }\n\n      no_close:\n        /* We output the messages even if warnings are off, because we'll fail\n         * the very next thing, and these give a likely diagnosis for that */\n        if (posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {\n            output_or_return_posix_warnings(pRExC_state, posix_warnings, NULL);\n        }\n\n        FAIL(\"Syntax error in (?[...])\");\n    }\n\n    /* Pass 2 only after this. */\n    Perl_ck_warner_d(aTHX_\n        packWARN(WARN_EXPERIMENTAL__REGEX_SETS),\n        \"The regex_sets feature is experimental\" REPORT_LOCATION,\n        REPORT_LOCATION_ARGS(RExC_parse));\n\n    /* Everything in this construct is a metacharacter.  Operands begin with\n     * either a '\\' (for an escape sequence), or a '[' for a bracketed\n     * character class.  Any other character should be an operator, or\n     * parenthesis for grouping.  Both types of operands are handled by calling\n     * regclass() to parse them.  It is called with a parameter to indicate to\n     * return the computed inversion list.  The parsing here is implemented via\n     * a stack.  Each entry on the stack is a single character representing one\n     * of the operators; or else a pointer to an operand inversion list. */\n\n#define IS_OPERATOR(a) SvIOK(a)\n#define IS_OPERAND(a)  (! IS_OPERATOR(a))\n\n    /* The stack is kept in \u0141ukasiewicz order.  (That's pronounced similar\n     * to luke-a-shave-itch (or -itz), but people who didn't want to bother\n     * with pronouncing it called it Reverse Polish instead, but now that YOU\n     * know how to pronounce it you can use the correct term, thus giving due\n     * credit to the person who invented it, and impressing your geek friends.\n     * Wikipedia says that the pronounciation of \"\u0141\" has been changing so that\n     * it is now more like an English initial W (as in wonk) than an L.)\n     *\n     * This means that, for example, 'a | b & c' is stored on the stack as\n     *\n     * c  [4]\n     * b  [3]\n     * &  [2]\n     * a  [1]\n     * |  [0]\n     *\n     * where the numbers in brackets give the stack [array] element number.\n     * In this implementation, parentheses are not stored on the stack.\n     * Instead a '(' creates a \"fence\" so that the part of the stack below the\n     * fence is invisible except to the corresponding ')' (this allows us to\n     * replace testing for parens, by using instead subtraction of the fence\n     * position).  As new operands are processed they are pushed onto the stack\n     * (except as noted in the next paragraph).  New operators of higher\n     * precedence than the current final one are inserted on the stack before\n     * the lhs operand (so that when the rhs is pushed next, everything will be\n     * in the correct positions shown above.  When an operator of equal or\n     * lower precedence is encountered in parsing, all the stacked operations\n     * of equal or higher precedence are evaluated, leaving the result as the\n     * top entry on the stack.  This makes higher precedence operations\n     * evaluate before lower precedence ones, and causes operations of equal\n     * precedence to left associate.\n     *\n     * The only unary operator '!' is immediately pushed onto the stack when\n     * encountered.  When an operand is encountered, if the top of the stack is\n     * a '!\", the complement is immediately performed, and the '!' popped.  The\n     * resulting value is treated as a new operand, and the logic in the\n     * previous paragraph is executed.  Thus in the expression\n     *      [a] + ! [b]\n     * the stack looks like\n     *\n     * !\n     * a\n     * +\n     *\n     * as 'b' gets parsed, the latter gets evaluated to '!b', and the stack\n     * becomes\n     *\n     * !b\n     * a\n     * +\n     *\n     * A ')' is treated as an operator with lower precedence than all the\n     * aforementioned ones, which causes all operations on the stack above the\n     * corresponding '(' to be evaluated down to a single resultant operand.\n     * Then the fence for the '(' is removed, and the operand goes through the\n     * algorithm above, without the fence.\n     *\n     * A separate stack is kept of the fence positions, so that the position of\n     * the latest so-far unbalanced '(' is at the top of it.\n     *\n     * The ']' ending the construct is treated as the lowest operator of all,\n     * so that everything gets evaluated down to a single operand, which is the\n     * result */\n\n    sv_2mortal((SV *)(stack = newAV()));\n    sv_2mortal((SV *)(fence_stack = newAV()));\n\n    while (RExC_parse < RExC_end) {\n        I32 top_index;              /* Index of top-most element in 'stack' */\n        SV** top_ptr;               /* Pointer to top 'stack' element */\n        SV* current = NULL;         /* To contain the current inversion list\n                                       operand */\n        SV* only_to_avoid_leaks;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                TRUE /* Force /x */ );\n        if (RExC_parse >= RExC_end) {\n            Perl_croak(aTHX_ \"panic: Read past end of '(?[ ])'\");\n        }\n\n        curchar = UCHARAT(RExC_parse);\n\nredo_curchar:\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n                    /* Enable with -Accflags=-DENABLE_REGEX_SETS_DEBUGGING */\n        DEBUG_U(dump_regex_sets_structures(pRExC_state,\n                                           stack, fence, fence_stack));\n#endif\n\n        top_index = av_tindex_skip_len_mg(stack);\n\n        switch (curchar) {\n            SV** stacked_ptr;       /* Ptr to something already on 'stack' */\n            char stacked_operator;  /* The topmost operator on the 'stack'. */\n            SV* lhs;                /* Operand to the left of the operator */\n            SV* rhs;                /* Operand to the right of the operator */\n            SV* fence_ptr;          /* Pointer to top element of the fence\n                                       stack */\n\n            case '(':\n\n                if (   RExC_parse < RExC_end - 1\n                    && (UCHARAT(RExC_parse + 1) == '?'))\n                {\n                    /* If is a '(?', could be an embedded '(?flags:(?[...])'.\n                     * This happens when we have some thing like\n                     *\n                     *   my $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\n                     *   ...\n                     *   qr/(?[ \\p{Digit} & $thai_or_lao ])/;\n                     *\n                     * Here we would be handling the interpolated\n                     * '$thai_or_lao'.  We handle this by a recursive call to\n                     * ourselves which returns the inversion list the\n                     * interpolated expression evaluates to.  We use the flags\n                     * from the interpolated pattern. */\n                    U32 save_flags = RExC_flags;\n                    const char * save_parse;\n\n                    RExC_parse += 2;        /* Skip past the '(?' */\n                    save_parse = RExC_parse;\n\n                    /* Parse any flags for the '(?' */\n                    parse_lparen_question_flags(pRExC_state);\n\n                    if (RExC_parse == save_parse  /* Makes sure there was at\n                                                     least one flag (or else\n                                                     this embedding wasn't\n                                                     compiled) */\n                        || RExC_parse >= RExC_end - 4\n                        || UCHARAT(RExC_parse) != ':'\n                        || UCHARAT(++RExC_parse) != '('\n                        || UCHARAT(++RExC_parse) != '?'\n                        || UCHARAT(++RExC_parse) != '[')\n                    {\n\n                        /* In combination with the above, this moves the\n                         * pointer to the point just after the first erroneous\n                         * character (or if there are no flags, to where they\n                         * should have been) */\n                        if (RExC_parse >= RExC_end - 4) {\n                            RExC_parse = RExC_end;\n                        }\n                        else if (RExC_parse != save_parse) {\n                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                        }\n                        vFAIL(\"Expecting '(?flags:(?[...'\");\n                    }\n\n                    /* Recurse, with the meat of the embedded expression */\n                    RExC_parse++;\n                    (void) handle_regex_sets(pRExC_state, &current, flagp,\n                                                    depth+1, oregcomp_parse);\n\n                    /* Here, 'current' contains the embedded expression's\n                     * inversion list, and RExC_parse points to the trailing\n                     * ']'; the next character should be the ')' */\n                    RExC_parse++;\n                    assert(UCHARAT(RExC_parse) == ')');\n\n                    /* Then the ')' matching the original '(' handled by this\n                     * case: statement */\n                    RExC_parse++;\n                    assert(UCHARAT(RExC_parse) == ')');\n\n                    RExC_parse++;\n                    RExC_flags = save_flags;\n                    goto handle_operand;\n                }\n\n                /* A regular '('.  Look behind for illegal syntax */\n                if (top_index - fence >= 0) {\n                    /* If the top entry on the stack is an operator, it had\n                     * better be a '!', otherwise the entry below the top\n                     * operand should be an operator */\n                    if (   ! (top_ptr = av_fetch(stack, top_index, FALSE))\n                        || (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) != '!')\n                        || (   IS_OPERAND(*top_ptr)\n                            && (   top_index - fence < 1\n                                || ! (stacked_ptr = av_fetch(stack,\n                                                             top_index - 1,\n                                                             FALSE))\n                                || ! IS_OPERATOR(*stacked_ptr))))\n                    {\n                        RExC_parse++;\n                        vFAIL(\"Unexpected '(' with no preceding operator\");\n                    }\n                }\n\n                /* Stack the position of this undealt-with left paren */\n                av_push(fence_stack, newSViv(fence));\n                fence = top_index + 1;\n                break;\n\n            case '\\\\':\n                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp,depth+1,\n                              TRUE, /* means parse just the next thing */\n                              FALSE, /* don't allow multi-char folds */\n                              FALSE, /* don't silence non-portable warnings.  */\n                              TRUE,  /* strict */\n                              FALSE, /* Require return to be an ANYOF */\n                              &current,\n                              NULL))\n                {\n                    FAIL2(\"panic: regclass returned NULL to handle_sets, \"\n                          \"flags=%#\" UVxf, (UV) *flagp);\n                }\n\n                /* regclass() will return with parsing just the \\ sequence,\n                 * leaving the parse pointer at the next thing to parse */\n                RExC_parse--;\n                goto handle_operand;\n\n            case '[':   /* Is a bracketed character class */\n            {\n                /* See if this is a [:posix:] class. */\n                bool is_posix_class = (OOB_NAMEDCLASS\n                            < handle_possible_posix(pRExC_state,\n                                                RExC_parse + 1,\n                                                NULL,\n                                                NULL,\n                                                TRUE /* checking only */));\n                /* If it is a posix class, leave the parse pointer at the '['\n                 * to fool regclass() into thinking it is part of a\n                 * '[[:posix:]]'. */\n                if (! is_posix_class) {\n                    RExC_parse++;\n                }\n\n                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp,depth+1,\n                                is_posix_class, /* parse the whole char\n                                                    class only if not a\n                                                    posix class */\n                                FALSE, /* don't allow multi-char folds */\n                                TRUE, /* silence non-portable warnings. */\n                                TRUE, /* strict */\n                                FALSE, /* Require return to be an ANYOF */\n                                &current,\n                                NULL\n                                ))\n                {\n                    FAIL2(\"panic: regclass returned NULL to handle_sets, \"\n                          \"flags=%#\" UVxf, (UV) *flagp);\n                }\n\n                /* function call leaves parse pointing to the ']', except if we\n                 * faked it */\n                if (is_posix_class) {\n                    RExC_parse--;\n                }\n\n                goto handle_operand;\n            }\n\n            case ']':\n                if (top_index >= 1) {\n                    goto join_operators;\n                }\n\n                /* Only a single operand on the stack: are done */\n                goto done;\n\n            case ')':\n                if (av_tindex_skip_len_mg(fence_stack) < 0) {\n                    RExC_parse++;\n                    vFAIL(\"Unexpected ')'\");\n                }\n\n                /* If nothing after the fence, is missing an operand */\n                if (top_index - fence < 0) {\n                    RExC_parse++;\n                    goto bad_syntax;\n                }\n                /* If at least two things on the stack, treat this as an\n                  * operator */\n                if (top_index - fence >= 1) {\n                    goto join_operators;\n                }\n\n                /* Here only a single thing on the fenced stack, and there is a\n                 * fence.  Get rid of it */\n                fence_ptr = av_pop(fence_stack);\n                assert(fence_ptr);\n                fence = SvIV(fence_ptr) - 1;\n                SvREFCNT_dec_NN(fence_ptr);\n                fence_ptr = NULL;\n\n                if (fence < 0) {\n                    fence = 0;\n                }\n\n                /* Having gotten rid of the fence, we pop the operand at the\n                 * stack top and process it as a newly encountered operand */\n                current = av_pop(stack);\n                if (IS_OPERAND(current)) {\n                    goto handle_operand;\n                }\n\n                RExC_parse++;\n                goto bad_syntax;\n\n            case '&':\n            case '|':\n            case '+':\n            case '-':\n            case '^':\n\n                /* These binary operators should have a left operand already\n                 * parsed */\n                if (   top_index - fence < 0\n                    || top_index - fence == 1\n                    || ( ! (top_ptr = av_fetch(stack, top_index, FALSE)))\n                    || ! IS_OPERAND(*top_ptr))\n                {\n                    goto unexpected_binary;\n                }\n\n                /* If only the one operand is on the part of the stack visible\n                 * to us, we just place this operator in the proper position */\n                if (top_index - fence < 2) {\n\n                    /* Place the operator before the operand */\n\n                    SV* lhs = av_pop(stack);\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* But if there is something else on the stack, we need to\n                 * process it before this new operator if and only if the\n                 * stacked operation has equal or higher precedence than the\n                 * new one */\n\n             join_operators:\n\n                /* The operator on the stack is supposed to be below both its\n                 * operands */\n                if (   ! (stacked_ptr = av_fetch(stack, top_index - 2, FALSE))\n                    || IS_OPERAND(*stacked_ptr))\n                {\n                    /* But if not, it's legal and indicates we are completely\n                     * done if and only if we're currently processing a ']',\n                     * which should be the final thing in the expression */\n                    if (curchar == ']') {\n                        goto done;\n                    }\n\n                  unexpected_binary:\n                    RExC_parse++;\n                    vFAIL2(\"Unexpected binary operator '%c' with no \"\n                           \"preceding operand\", curchar);\n                }\n                stacked_operator = (char) SvUV(*stacked_ptr);\n\n                if (regex_set_precedence(curchar)\n                    > regex_set_precedence(stacked_operator))\n                {\n                    /* Here, the new operator has higher precedence than the\n                     * stacked one.  This means we need to add the new one to\n                     * the stack to await its rhs operand (and maybe more\n                     * stuff).  We put it before the lhs operand, leaving\n                     * untouched the stacked operator and everything below it\n                     * */\n                    lhs = av_pop(stack);\n                    assert(IS_OPERAND(lhs));\n\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* Here, the new operator has equal or lower precedence than\n                 * what's already there.  This means the operation already\n                 * there should be performed now, before the new one. */\n\n                rhs = av_pop(stack);\n                if (! IS_OPERAND(rhs)) {\n\n                    /* This can happen when a ! is not followed by an operand,\n                     * like in /(?[\\t &!])/ */\n                    goto bad_syntax;\n                }\n\n                lhs = av_pop(stack);\n\n                if (! IS_OPERAND(lhs)) {\n\n                    /* This can happen when there is an empty (), like in\n                     * /(?[[0]+()+])/ */\n                    goto bad_syntax;\n                }\n\n                switch (stacked_operator) {\n                    case '&':\n                        _invlist_intersection(lhs, rhs, &rhs);\n                        break;\n\n                    case '|':\n                    case '+':\n                        _invlist_union(lhs, rhs, &rhs);\n                        break;\n\n                    case '-':\n                        _invlist_subtract(lhs, rhs, &rhs);\n                        break;\n\n                    case '^':   /* The union minus the intersection */\n                    {\n                        SV* i = NULL;\n                        SV* u = NULL;\n\n                        _invlist_union(lhs, rhs, &u);\n                        _invlist_intersection(lhs, rhs, &i);\n                        _invlist_subtract(u, i, &rhs);\n                        SvREFCNT_dec_NN(i);\n                        SvREFCNT_dec_NN(u);\n                        break;\n                    }\n                }\n                SvREFCNT_dec(lhs);\n\n                /* Here, the higher precedence operation has been done, and the\n                 * result is in 'rhs'.  We overwrite the stacked operator with\n                 * the result.  Then we redo this code to either push the new\n                 * operator onto the stack or perform any higher precedence\n                 * stacked operation */\n                only_to_avoid_leaks = av_pop(stack);\n                SvREFCNT_dec(only_to_avoid_leaks);\n                av_push(stack, rhs);\n                goto redo_curchar;\n\n            case '!':   /* Highest priority, right associative */\n\n                /* If what's already at the top of the stack is another '!\",\n                 * they just cancel each other out */\n                if (   (top_ptr = av_fetch(stack, top_index, FALSE))\n                    && (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) == '!'))\n                {\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n                }\n                else { /* Otherwise, since it's right associative, just push\n                          onto the stack */\n                    av_push(stack, newSVuv(curchar));\n                }\n                break;\n\n            default:\n                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                vFAIL(\"Unexpected character\");\n\n          handle_operand:\n\n            /* Here 'current' is the operand.  If something is already on the\n             * stack, we have to check if it is a !.  But first, the code above\n             * may have altered the stack in the time since we earlier set\n             * 'top_index'.  */\n\n            top_index = av_tindex_skip_len_mg(stack);\n            if (top_index - fence >= 0) {\n                /* If the top entry on the stack is an operator, it had better\n                 * be a '!', otherwise the entry below the top operand should\n                 * be an operator */\n                top_ptr = av_fetch(stack, top_index, FALSE);\n                assert(top_ptr);\n                if (IS_OPERATOR(*top_ptr)) {\n\n                    /* The only permissible operator at the top of the stack is\n                     * '!', which is applied immediately to this operand. */\n                    curchar = (char) SvUV(*top_ptr);\n                    if (curchar != '!') {\n                        SvREFCNT_dec(current);\n                        vFAIL2(\"Unexpected binary operator '%c' with no \"\n                                \"preceding operand\", curchar);\n                    }\n\n                    _invlist_invert(current);\n\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n\n                    /* And we redo with the inverted operand.  This allows\n                     * handling multiple ! in a row */\n                    goto handle_operand;\n                }\n                          /* Single operand is ok only for the non-binary ')'\n                           * operator */\n                else if ((top_index - fence == 0 && curchar != ')')\n                         || (top_index - fence > 0\n                             && (! (stacked_ptr = av_fetch(stack,\n                                                           top_index - 1,\n                                                           FALSE))\n                                 || IS_OPERAND(*stacked_ptr))))\n                {\n                    SvREFCNT_dec(current);\n                    vFAIL(\"Operand with no preceding operator\");\n                }\n            }\n\n            /* Here there was nothing on the stack or the top element was\n             * another operand.  Just add this new one */\n            av_push(stack, current);\n\n        } /* End of switch on next parse token */\n\n        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n    } /* End of loop parsing through the construct */\n\n  done:\n    if (av_tindex_skip_len_mg(fence_stack) >= 0) {\n        vFAIL(\"Unmatched (\");\n    }\n\n    if (av_tindex_skip_len_mg(stack) < 0   /* Was empty */\n        || ((final = av_pop(stack)) == NULL)\n        || ! IS_OPERAND(final)\n        || SvTYPE(final) != SVt_INVLIST\n        || av_tindex_skip_len_mg(stack) >= 0)  /* More left on stack */\n    {\n      bad_syntax:\n        SvREFCNT_dec(final);\n        vFAIL(\"Incomplete expression within '(?[ ])'\");\n    }\n\n    /* Here, 'final' is the resultant inversion list from evaluating the\n     * expression.  Return it if so requested */\n    if (return_invlist) {\n        *return_invlist = final;\n        return END;\n    }\n\n    /* Otherwise generate a resultant node, based on 'final'.  regclass() is\n     * expecting a string of ranges and individual code points */\n    invlist_iterinit(final);\n    result_string = newSVpvs(\"\");\n    while (invlist_iternext(final, &start, &end)) {\n        if (start == end) {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}\", start);\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}-\\\\x{%\" UVXf \"}\",\n                                                     start,          end);\n        }\n    }\n\n    /* About to generate an ANYOF (or similar) node from the inversion list we\n     * have calculated */\n    save_parse = RExC_parse;\n    RExC_parse = SvPV(result_string, len);\n    save_end = RExC_end;\n    RExC_end = RExC_parse + len;\n\n    /* We turn off folding around the call, as the class we have constructed\n     * already has all folding taken into consideration, and we don't want\n     * regclass() to add to that */\n    RExC_flags &= ~RXf_PMf_FOLD;\n    /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if multi-char\n     * folds are allowed.  */\n    node = regclass(pRExC_state, flagp,depth+1,\n                    FALSE, /* means parse the whole char class */\n                    FALSE, /* don't allow multi-char folds */\n                    TRUE, /* silence non-portable warnings.  The above may very\n                             well have generated non-portable code points, but\n                             they're valid on this machine */\n                    FALSE, /* similarly, no need for strict */\n                    FALSE, /* Require return to be an ANYOF */\n                    NULL,\n                    NULL\n                );\n    if (!node)\n        FAIL2(\"panic: regclass returned NULL to handle_sets, flags=%#\" UVxf,\n                    PTR2UV(flagp));\n\n    /* Fix up the node type if we are in locale.  (We have pretended we are\n     * under /u for the purposes of regclass(), as this construct will only\n     * work under UTF-8 locales.  But now we change the opcode to be ANYOFL (so\n     * as to cause any warnings about bad locales to be output in regexec.c),\n     * and add the flag that indicates to check if not in a UTF-8 locale.  The\n     * reason we above forbid optimization into something other than an ANYOF\n     * node is simply to minimize the number of code changes in regexec.c.\n     * Otherwise we would have to create new EXACTish node types and deal with\n     * them.  This decision could be revisited should this construct become\n     * popular.\n     *\n     * (One might think we could look at the resulting ANYOF node and suppress\n     * the flag if everything is above 255, as those would be UTF-8 only,\n     * but this isn't true, as the components that led to that result could\n     * have been locale-affected, and just happen to cancel each other out\n     * under UTF-8 locales.) */\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);\n\n        assert(OP(node) == ANYOF);\n\n        OP(node) = ANYOFL;\n        ANYOF_FLAGS(node)\n                |= ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n    }\n\n    if (save_fold) {\n        RExC_flags |= RXf_PMf_FOLD;\n    }\n\n    RExC_parse = save_parse + 1;\n    RExC_end = save_end;\n    SvREFCNT_dec_NN(final);\n    SvREFCNT_dec_NN(result_string);\n\n    nextchar(pRExC_state);\n    Set_Node_Length(node, RExC_parse - oregcomp_parse + 1); /* MJD */\n    return node;\n}\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n\nSTATIC void\nS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state,\n                             AV * stack, const IV fence, AV * fence_stack)\n{   /* Dumps the stacks in handle_regex_sets() */\n\n    const SSize_t stack_top = av_tindex_skip_len_mg(stack);\n    const SSize_t fence_stack_top = av_tindex_skip_len_mg(fence_stack);\n    SSize_t i;\n\n    PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES;\n\n    PerlIO_printf(Perl_debug_log, \"\\nParse position is:%s\\n\", RExC_parse);\n\n    if (stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Stack: (fence=%d)\\n\", (int) fence);\n        for (i = stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            if (IS_OPERATOR(*element_ptr)) {\n                PerlIO_printf(Perl_debug_log, \"[%d]: %c\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n            }\n            else {\n                PerlIO_printf(Perl_debug_log, \"[%d] \", (int) i);\n                sv_dump(*element_ptr);\n            }\n        }\n    }\n\n    if (fence_stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on fence_stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Fence_stack: \\n\");\n        for (i = fence_stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(fence_stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            PerlIO_printf(Perl_debug_log, \"[%d]: %d\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n        }\n    }\n}\n\n#endif\n\n#undef IS_OPERATOR\n#undef IS_OPERAND\n\nSTATIC void\nS_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist)\n{\n    /* This hard-codes the Latin1/above-Latin1 folding rules, so that an\n     * innocent-looking character class, like /[ks]/i won't have to go out to\n     * disk to find the possible matches.\n     *\n     * This should be called only for a Latin1-range code points, cp, which is\n     * known to be involved in a simple fold with other code points above\n     * Latin1.  It would give false results if /aa has been specified.\n     * Multi-char folds are outside the scope of this, and must be handled\n     * specially.\n     *\n     * XXX It would be better to generate these via regen, in case a new\n     * version of the Unicode standard adds new mappings, though that is not\n     * really likely, and may be caught by the default: case of the switch\n     * below. */\n\n    PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS;\n\n    assert(HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(cp));\n\n    switch (cp) {\n        case 'k':\n        case 'K':\n          *invlist =\n             add_cp_to_invlist(*invlist, KELVIN_SIGN);\n            break;\n        case 's':\n        case 'S':\n          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_LONG_S);\n            break;\n        case MICRO_SIGN:\n          *invlist = add_cp_to_invlist(*invlist, GREEK_CAPITAL_LETTER_MU);\n          *invlist = add_cp_to_invlist(*invlist, GREEK_SMALL_LETTER_MU);\n            break;\n        case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:\n        case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:\n          *invlist = add_cp_to_invlist(*invlist, ANGSTROM_SIGN);\n            break;\n        case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:\n          *invlist = add_cp_to_invlist(*invlist,\n                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);\n            break;\n\n#ifdef LATIN_CAPITAL_LETTER_SHARP_S /* not defined in early Unicode releases */\n\n        case LATIN_SMALL_LETTER_SHARP_S:\n          *invlist = add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_SHARP_S);\n            break;\n\n#endif\n\n#if    UNICODE_MAJOR_VERSION < 3                                        \\\n   || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0)\n\n        /* In 3.0 and earlier, U+0130 folded simply to 'i'; and in 3.0.1 so did\n         * U+0131.  */\n        case 'i':\n        case 'I':\n          *invlist =\n             add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n#   if UNICODE_DOT_DOT_VERSION == 1\n          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_DOTLESS_I);\n#   endif\n            break;\n#endif\n\n        default:\n            /* Use deprecated warning to increase the chances of this being\n             * output */\n            if (PASS2) {\n                ckWARN2reg_d(RExC_parse, \"Perl folding rules are not up-to-date for 0x%02X; please use the perlbug utility to report;\", cp);\n            }\n            break;\n    }\n}\n\nSTATIC void\nS_output_or_return_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings, AV** return_posix_warnings)\n{\n    /* If the final parameter is NULL, output the elements of the array given\n     * by '*posix_warnings' as REGEXP warnings.  Otherwise, the elements are\n     * pushed onto it, (creating if necessary) */\n\n    SV * msg;\n    const bool first_is_fatal =  ! return_posix_warnings\n                                && ckDEAD(packWARN(WARN_REGEXP));\n\n    PERL_ARGS_ASSERT_OUTPUT_OR_RETURN_POSIX_WARNINGS;\n\n    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {\n        if (return_posix_warnings) {\n            if (! *return_posix_warnings) { /* mortalize to not leak if\n                                               warnings are fatal */\n                *return_posix_warnings = (AV *) sv_2mortal((SV *) newAV());\n            }\n            av_push(*return_posix_warnings, msg);\n        }\n        else {\n            if (first_is_fatal) {           /* Avoid leaking this */\n                av_undef(posix_warnings);   /* This isn't necessary if the\n                                               array is mortal, but is a\n                                               fail-safe */\n                (void) sv_2mortal(msg);\n                if (PASS2) {\n                    SAVEFREESV(RExC_rx_sv);\n                }\n            }\n            Perl_warner(aTHX_ packWARN(WARN_REGEXP), \"%s\", SvPVX(msg));\n            SvREFCNT_dec_NN(msg);\n        }\n    }\n}\n\nSTATIC AV *\nS_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count)\n{\n    /* This adds the string scalar <multi_string> to the array\n     * <multi_char_matches>.  <multi_string> is known to have exactly\n     * <cp_count> code points in it.  This is used when constructing a\n     * bracketed character class and we find something that needs to match more\n     * than a single character.\n     *\n     * <multi_char_matches> is actually an array of arrays.  Each top-level\n     * element is an array that contains all the strings known so far that are\n     * the same length.  And that length (in number of code points) is the same\n     * as the index of the top-level array.  Hence, the [2] element is an\n     * array, each element thereof is a string containing TWO code points;\n     * while element [3] is for strings of THREE characters, and so on.  Since\n     * this is for multi-char strings there can never be a [0] nor [1] element.\n     *\n     * When we rewrite the character class below, we will do so such that the\n     * longest strings are written first, so that it prefers the longest\n     * matching strings first.  This is done even if it turns out that any\n     * quantifier is non-greedy, out of this programmer's (khw) laziness.  Tom\n     * Christiansen has agreed that this is ok.  This makes the test for the\n     * ligature 'ffi' come before the test for 'ff', for example */\n\n    AV* this_array;\n    AV** this_array_ptr;\n\n    PERL_ARGS_ASSERT_ADD_MULTI_MATCH;\n\n    if (! multi_char_matches) {\n        multi_char_matches = newAV();\n    }\n\n    if (av_exists(multi_char_matches, cp_count)) {\n        this_array_ptr = (AV**) av_fetch(multi_char_matches, cp_count, FALSE);\n        this_array = *this_array_ptr;\n    }\n    else {\n        this_array = newAV();\n        av_store(multi_char_matches, cp_count,\n                 (SV*) this_array);\n    }\n    av_push(this_array, multi_string);\n\n    return multi_char_matches;\n}\n\n/* The names of properties whose definitions are not known at compile time are\n * stored in this SV, after a constant heading.  So if the length has been\n * changed since initialization, then there is a run-time definition. */\n#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION                            \\\n                                        (SvCUR(listsv) != initial_listsv_len)\n\n/* There is a restricted set of white space characters that are legal when\n * ignoring white space in a bracketed character class.  This generates the\n * code to skip them.\n *\n * There is a line below that uses the same white space criteria but is outside\n * this macro.  Both here and there must use the same definition */\n#define SKIP_BRACKETED_WHITE_SPACE(do_skip, p)                          \\\n    STMT_START {                                                        \\\n        if (do_skip) {                                                  \\\n            while (isBLANK_A(UCHARAT(p)))                               \\\n            {                                                           \\\n                p++;                                                    \\\n            }                                                           \\\n        }                                                               \\\n    } STMT_END\n\nSTATIC regnode *\nS_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,\n                 const bool stop_at_1,  /* Just parse the next thing, don't\n                                           look for a full character class */\n                 bool allow_multi_folds,\n                 const bool silence_non_portable,   /* Don't output warnings\n                                                       about too large\n                                                       characters */\n                 const bool strict,\n                 bool optimizable,                  /* ? Allow a non-ANYOF return\n                                                       node */\n                 SV** ret_invlist, /* Return an inversion list, not a node */\n                 AV** return_posix_warnings\n          )\n{\n    /* parse a bracketed class specification.  Most of these will produce an\n     * ANYOF node; but something like [a] will produce an EXACT node; [aA], an\n     * EXACTFish node; [[:ascii:]], a POSIXA node; etc.  It is more complex\n     * under /i with multi-character folds: it will be rewritten following the\n     * paradigm of this example, where the <multi-fold>s are characters which\n     * fold to multiple character sequences:\n     *      /[abc\\x{multi-fold1}def\\x{multi-fold2}ghi]/i\n     * gets effectively rewritten as:\n     *      /(?:\\x{multi-fold1}|\\x{multi-fold2}|[abcdefghi]/i\n     * reg() gets called (recursively) on the rewritten version, and this\n     * function will return what it constructs.  (Actually the <multi-fold>s\n     * aren't physically removed from the [abcdefghi], it's just that they are\n     * ignored in the recursion by means of a flag:\n     * <RExC_in_multi_char_class>.)\n     *\n     * ANYOF nodes contain a bit map for the first NUM_ANYOF_CODE_POINTS\n     * characters, with the corresponding bit set if that character is in the\n     * list.  For characters above this, a range list or swash is used.  There\n     * are extra bits for \\w, etc. in locale ANYOFs, as what these match is not\n     * determinable at compile time\n     *\n     * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs\n     * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded\n     * to UTF-8.  This can only happen if ret_invlist is non-NULL.\n     */\n\n    UV prevvalue = OOB_UNICODE, save_prevvalue = OOB_UNICODE;\n    IV range = 0;\n    UV value = OOB_UNICODE, save_value = OOB_UNICODE;\n    regnode *ret;\n    STRLEN numlen;\n    int namedclass = OOB_NAMEDCLASS;\n    char *rangebegin = NULL;\n    bool need_class = 0;\n    SV *listsv = NULL;\n    STRLEN initial_listsv_len = 0; /* Kind of a kludge to see if it is more\n\t\t\t\t      than just initialized.  */\n    SV* properties = NULL;    /* Code points that match \\p{} \\P{} */\n    SV* posixes = NULL;     /* Code points that match classes like [:word:],\n                               extended beyond the Latin1 range.  These have to\n                               be kept separate from other code points for much\n                               of this function because their handling  is\n                               different under /i, and for most classes under\n                               /d as well */\n    SV* nposixes = NULL;    /* Similarly for [:^word:].  These are kept\n                               separate for a while from the non-complemented\n                               versions because of complications with /d\n                               matching */\n    SV* simple_posixes = NULL; /* But under some conditions, the classes can be\n                                  treated more simply than the general case,\n                                  leading to less compilation and execution\n                                  work */\n    UV element_count = 0;   /* Number of distinct elements in the class.\n\t\t\t       Optimizations may be possible if this is tiny */\n    AV * multi_char_matches = NULL; /* Code points that fold to more than one\n                                       character; used under /i */\n    UV n;\n    char * stop_ptr = RExC_end;    /* where to stop parsing */\n\n    /* ignore unescaped whitespace? */\n    const bool skip_white = cBOOL(   ret_invlist\n                                  || (RExC_flags & RXf_PMf_EXTENDED_MORE));\n\n    /* Unicode properties are stored in a swash; this holds the current one\n     * being parsed.  If this swash is the only above-latin1 component of the\n     * character class, an optimization is to pass it directly on to the\n     * execution engine.  Otherwise, it is set to NULL to indicate that there\n     * are other things in the class that have to be dealt with at execution\n     * time */\n    SV* swash = NULL;\t\t/* Code points that match \\p{} \\P{} */\n\n    /* Set if a component of this character class is user-defined; just passed\n     * on to the engine */\n    bool has_user_defined_property = FALSE;\n\n    /* inversion list of code points this node matches only when the target\n     * string is in UTF-8.  These are all non-ASCII, < 256.  (Because is under\n     * /d) */\n    SV* has_upper_latin1_only_utf8_matches = NULL;\n\n    /* Inversion list of code points this node matches regardless of things\n     * like locale, folding, utf8ness of the target string */\n    SV* cp_list = NULL;\n\n    /* Like cp_list, but code points on this list need to be checked for things\n     * that fold to/from them under /i */\n    SV* cp_foldable_list = NULL;\n\n    /* Like cp_list, but code points on this list are valid only when the\n     * runtime locale is UTF-8 */\n    SV* only_utf8_locale_list = NULL;\n\n    /* In a range, if one of the endpoints is non-character-set portable,\n     * meaning that it hard-codes a code point that may mean a different\n     * charactger in ASCII vs. EBCDIC, as opposed to, say, a literal 'A' or a\n     * mnemonic '\\t' which each mean the same character no matter which\n     * character set the platform is on. */\n    unsigned int non_portable_endpoint = 0;\n\n    /* Is the range unicode? which means on a platform that isn't 1-1 native\n     * to Unicode (i.e. non-ASCII), each code point in it should be considered\n     * to be a Unicode value.  */\n    bool unicode_range = FALSE;\n    bool invert = FALSE;    /* Is this class to be complemented */\n\n    bool warn_super = ALWAYS_WARN_SUPER;\n\n    regnode * const orig_emit = RExC_emit; /* Save the original RExC_emit in\n        case we need to change the emitted regop to an EXACT. */\n    const char * orig_parse = RExC_parse;\n    const SSize_t orig_size = RExC_size;\n    bool posixl_matches_all = FALSE; /* Does /l class have both e.g. \\W,\\w ? */\n\n    /* This variable is used to mark where the end in the input is of something\n     * that looks like a POSIX construct but isn't.  During the parse, when\n     * something looks like it could be such a construct is encountered, it is\n     * checked for being one, but not if we've already checked this area of the\n     * input.  Only after this position is reached do we check again */\n    char *not_posix_region_end = RExC_parse - 1;\n\n    AV* posix_warnings = NULL;\n    const bool do_posix_warnings =     return_posix_warnings\n                                   || (PASS2 && ckWARN(WARN_REGEXP));\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGCLASS;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    DEBUG_PARSE(\"clas\");\n\n#if UNICODE_MAJOR_VERSION < 3 /* no multifolds in early Unicode */      \\\n    || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0          \\\n                                   && UNICODE_DOT_DOT_VERSION == 0)\n    allow_multi_folds = FALSE;\n#endif\n\n    /* Assume we are going to generate an ANYOF node. */\n    ret = reganode(pRExC_state,\n                   (LOC)\n                    ? ANYOFL\n                    : ANYOF,\n                   0);\n\n    if (SIZE_ONLY) {\n\tRExC_size += ANYOF_SKIP;\n\tlistsv = &PL_sv_undef; /* For code scanners: listsv always non-NULL. */\n    }\n    else {\n        ANYOF_FLAGS(ret) = 0;\n\n \tRExC_emit += ANYOF_SKIP;\n\tlistsv = newSVpvs_flags(\"# comment\\n\", SVs_TEMP);\n\tinitial_listsv_len = SvCUR(listsv);\n        SvTEMP_off(listsv); /* Grr, TEMPs and mortals are conflated.  */\n    }\n\n    SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n    assert(RExC_parse <= RExC_end);\n\n    if (UCHARAT(RExC_parse) == '^') {\t/* Complement the class */\n\tRExC_parse++;\n        invert = TRUE;\n        allow_multi_folds = FALSE;\n        MARK_NAUGHTY(1);\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n    }\n\n    /* Check that they didn't say [:posix:] instead of [[:posix:]] */\n    if (! ret_invlist && MAYBE_POSIXCC(UCHARAT(RExC_parse))) {\n        int maybe_class = handle_possible_posix(pRExC_state,\n                                                RExC_parse,\n                                                &not_posix_region_end,\n                                                NULL,\n                                                TRUE /* checking only */);\n        if (PASS2 && maybe_class >= OOB_NAMEDCLASS && do_posix_warnings) {\n            SAVEFREESV(RExC_rx_sv);\n            ckWARN4reg(not_posix_region_end,\n                    \"POSIX syntax [%c %c] belongs inside character classes%s\",\n                    *RExC_parse, *RExC_parse,\n                    (maybe_class == OOB_NAMEDCLASS)\n                    ? ((POSIXCC_NOTYET(*RExC_parse))\n                        ? \" (but this one isn't implemented)\"\n                        : \" (but this one isn't fully valid)\")\n                    : \"\"\n                    );\n            (void)ReREFCNT_inc(RExC_rx_sv);\n        }\n    }\n\n    /* If the caller wants us to just parse a single element, accomplish this\n     * by faking the loop ending condition */\n    if (stop_at_1 && RExC_end > RExC_parse) {\n        stop_ptr = RExC_parse + 1;\n    }\n\n    /* allow 1st char to be ']' (allowing it to be '-' is dealt with later) */\n    if (UCHARAT(RExC_parse) == ']')\n\tgoto charclassloop;\n\n    while (1) {\n\n        if (   posix_warnings\n            && av_tindex_skip_len_mg(posix_warnings) >= 0\n            && RExC_parse > not_posix_region_end)\n        {\n            /* Warnings about posix class issues are considered tentative until\n             * we are far enough along in the parse that we can no longer\n             * change our mind, at which point we either output them or add\n             * them, if it has so specified, to what gets returned to the\n             * caller.  This is done each time through the loop so that a later\n             * class won't zap them before they have been dealt with. */\n            output_or_return_posix_warnings(pRExC_state, posix_warnings,\n                                            return_posix_warnings);\n        }\n\n        if  (RExC_parse >= stop_ptr) {\n            break;\n        }\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        if  (UCHARAT(RExC_parse) == ']') {\n            break;\n        }\n\n      charclassloop:\n\n\tnamedclass = OOB_NAMEDCLASS; /* initialize as illegal */\n        save_value = value;\n        save_prevvalue = prevvalue;\n\n\tif (!range) {\n\t    rangebegin = RExC_parse;\n\t    element_count++;\n            non_portable_endpoint = 0;\n\t}\n\tif (UTF && ! UTF8_IS_INVARIANT(* RExC_parse)) {\n\t    value = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t    RExC_parse += numlen;\n\t}\n\telse\n\t    value = UCHARAT(RExC_parse++);\n\n        if (value == '[') {\n            char * posix_class_end;\n            namedclass = handle_possible_posix(pRExC_state,\n                                               RExC_parse,\n                                               &posix_class_end,\n                                               do_posix_warnings ? &posix_warnings : NULL,\n                                               FALSE    /* die if error */);\n            if (namedclass > OOB_NAMEDCLASS) {\n\n                /* If there was an earlier attempt to parse this particular\n                 * posix class, and it failed, it was a false alarm, as this\n                 * successful one proves */\n                if (   posix_warnings\n                    && av_tindex_skip_len_mg(posix_warnings) >= 0\n                    && not_posix_region_end >= RExC_parse\n                    && not_posix_region_end <= posix_class_end)\n                {\n                    av_undef(posix_warnings);\n                }\n\n                RExC_parse = posix_class_end;\n            }\n            else if (namedclass == OOB_NAMEDCLASS) {\n                not_posix_region_end = posix_class_end;\n            }\n            else {\n                namedclass = OOB_NAMEDCLASS;\n            }\n        }\n        else if (   RExC_parse - 1 > not_posix_region_end\n                 && MAYBE_POSIXCC(value))\n        {\n            (void) handle_possible_posix(\n                        pRExC_state,\n                        RExC_parse - 1,  /* -1 because parse has already been\n                                            advanced */\n                        &not_posix_region_end,\n                        do_posix_warnings ? &posix_warnings : NULL,\n                        TRUE /* checking only */);\n        }\n        else if (value == '\\\\') {\n            /* Is a backslash; get the code point of the char after it */\n\n            if (RExC_parse >= RExC_end) {\n                vFAIL(\"Unmatched [\");\n            }\n\n\t    if (UTF && ! UTF8_IS_INVARIANT(UCHARAT(RExC_parse))) {\n\t\tvalue = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t\tRExC_parse += numlen;\n\t    }\n\t    else\n\t\tvalue = UCHARAT(RExC_parse++);\n\n\t    /* Some compilers cannot handle switching on 64-bit integer\n\t     * values, therefore value cannot be an UV.  Yes, this will\n\t     * be a problem later if we want switch on Unicode.\n\t     * A similar issue a little bit later when switching on\n\t     * namedclass. --jhi */\n\n            /* If the \\ is escaping white space when white space is being\n             * skipped, it means that that white space is wanted literally, and\n             * is already in 'value'.  Otherwise, need to translate the escape\n             * into what it signifies. */\n            if (! skip_white || ! isBLANK_A(value)) switch ((I32)value) {\n\n\t    case 'w':\tnamedclass = ANYOF_WORDCHAR;\tbreak;\n\t    case 'W':\tnamedclass = ANYOF_NWORDCHAR;\tbreak;\n\t    case 's':\tnamedclass = ANYOF_SPACE;\tbreak;\n\t    case 'S':\tnamedclass = ANYOF_NSPACE;\tbreak;\n\t    case 'd':\tnamedclass = ANYOF_DIGIT;\tbreak;\n\t    case 'D':\tnamedclass = ANYOF_NDIGIT;\tbreak;\n\t    case 'v':\tnamedclass = ANYOF_VERTWS;\tbreak;\n\t    case 'V':\tnamedclass = ANYOF_NVERTWS;\tbreak;\n\t    case 'h':\tnamedclass = ANYOF_HORIZWS;\tbreak;\n\t    case 'H':\tnamedclass = ANYOF_NHORIZWS;\tbreak;\n            case 'N':  /* Handle \\N{NAME} in class */\n                {\n                    const char * const backslash_N_beg = RExC_parse - 2;\n                    int cp_count;\n\n                    if (! grok_bslash_N(pRExC_state,\n                                        NULL,      /* No regnode */\n                                        &value,    /* Yes single value */\n                                        &cp_count, /* Multiple code pt count */\n                                        flagp,\n                                        strict,\n                                        depth)\n                    ) {\n\n                        if (*flagp & NEED_UTF8)\n                            FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n                        if (*flagp & RESTART_PASS1)\n                            return NULL;\n\n                        if (cp_count < 0) {\n                            vFAIL(\"\\\\N in a character class must be a named character: \\\\N{...}\");\n                        }\n                        else if (cp_count == 0) {\n                            if (PASS2) {\n                                ckWARNreg(RExC_parse,\n                                        \"Ignoring zero length \\\\N{} in character class\");\n                            }\n                        }\n                        else { /* cp_count > 1 */\n                            if (! RExC_in_multi_char_class) {\n                                if (invert || range || *RExC_parse == '-') {\n                                    if (strict) {\n                                        RExC_parse--;\n                                        vFAIL(\"\\\\N{} in inverted character class or as a range end-point is restricted to one character\");\n                                    }\n                                    else if (PASS2) {\n                                        ckWARNreg(RExC_parse, \"Using just the first character returned by \\\\N{} in character class\");\n                                    }\n                                    break; /* <value> contains the first code\n                                              point. Drop out of the switch to\n                                              process it */\n                                }\n                                else {\n                                    SV * multi_char_N = newSVpvn(backslash_N_beg,\n                                                 RExC_parse - backslash_N_beg);\n                                    multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_char_N,\n                                                          cp_count);\n                                }\n                            }\n                        } /* End of cp_count != 1 */\n\n                        /* This element should not be processed further in this\n                         * class */\n                        element_count--;\n                        value = save_value;\n                        prevvalue = save_prevvalue;\n                        continue;   /* Back to top of loop to get next char */\n                    }\n\n                    /* Here, is a single code point, and <value> contains it */\n                    unicode_range = TRUE;   /* \\N{} are Unicode */\n                }\n                break;\n\t    case 'p':\n\t    case 'P':\n\t\t{\n\t\tchar *e;\n\n                /* We will handle any undefined properties ourselves */\n                U8 swash_init_flags = _CORE_SWASH_INIT_RETURN_IF_UNDEF\n                                       /* And we actually would prefer to get\n                                        * the straight inversion list of the\n                                        * swash, since we will be accessing it\n                                        * anyway, to save a little time */\n                                      |_CORE_SWASH_INIT_ACCEPT_INVLIST;\n\n\t\tif (RExC_parse >= RExC_end)\n\t\t    vFAIL2(\"Empty \\\\%c\", (U8)value);\n\t\tif (*RExC_parse == '{') {\n\t\t    const U8 c = (U8)value;\n\t\t    e = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n                    if (!e) {\n                        RExC_parse++;\n                        vFAIL2(\"Missing right brace on \\\\%c{}\", c);\n                    }\n\n                    RExC_parse++;\n                    while (isSPACE(*RExC_parse)) {\n                         RExC_parse++;\n\t\t    }\n\n\t\t    if (UCHARAT(RExC_parse) == '^') {\n\n                        /* toggle.  (The rhs xor gets the single bit that\n                         * differs between P and p; the other xor inverts just\n                         * that bit) */\n                        value ^= 'P' ^ 'p';\n\n                        RExC_parse++;\n                        while (isSPACE(*RExC_parse)) {\n                            RExC_parse++;\n                        }\n                    }\n\n                    if (e == RExC_parse)\n                        vFAIL2(\"Empty \\\\%c{}\", c);\n\n\t\t    n = e - RExC_parse;\n\t\t    while (isSPACE(*(RExC_parse + n - 1)))\n\t\t        n--;\n\t\t}   /* The \\p isn't immediately followed by a '{' */\n\t\telse if (! isALPHA(*RExC_parse)) {\n                    RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                    vFAIL2(\"Character following \\\\%c must be '{' or a \"\n                           \"single-character Unicode property name\",\n                           (U8) value);\n                }\n                else {\n\t\t    e = RExC_parse;\n\t\t    n = 1;\n\t\t}\n\t\tif (!SIZE_ONLY) {\n                    SV* invlist;\n                    char* name;\n                    char* base_name;    /* name after any packages are stripped */\n                    char* lookup_name = NULL;\n                    const char * const colon_colon = \"::\";\n\n                    /* Try to get the definition of the property into\n                     * <invlist>.  If /i is in effect, the effective property\n                     * will have its name be <__NAME_i>.  The design is\n                     * discussed in commit\n                     * 2f833f5208e26b208886e51e09e2c072b5eabb46 */\n                    name = savepv(Perl_form(aTHX_ \"%.*s\", (int)n, RExC_parse));\n                    SAVEFREEPV(name);\n                    if (FOLD) {\n                        lookup_name = savepv(Perl_form(aTHX_ \"__%s_i\", name));\n\n                        /* The function call just below that uses this can fail\n                         * to return, leaking memory if we don't do this */\n                        SAVEFREEPV(lookup_name);\n                    }\n\n                    /* Look up the property name, and get its swash and\n                     * inversion list, if the property is found  */\n                    SvREFCNT_dec(swash); /* Free any left-overs */\n                    swash = _core_swash_init(\"utf8\",\n                                             (lookup_name)\n                                              ? lookup_name\n                                              : name,\n                                             &PL_sv_undef,\n                                             1, /* binary */\n                                             0, /* not tr/// */\n                                             NULL, /* No inversion list */\n                                             &swash_init_flags\n                                            );\n                    if (! swash || ! (invlist = _get_swash_invlist(swash))) {\n                        HV* curpkg = (IN_PERL_COMPILETIME)\n                                      ? PL_curstash\n                                      : CopSTASH(PL_curcop);\n                        UV final_n = n;\n                        bool has_pkg;\n\n                        if (swash) {    /* Got a swash but no inversion list.\n                                           Something is likely wrong that will\n                                           be sorted-out later */\n                            SvREFCNT_dec_NN(swash);\n                            swash = NULL;\n                        }\n\n                        /* Here didn't find it.  It could be a an error (like a\n                         * typo) in specifying a Unicode property, or it could\n                         * be a user-defined property that will be available at\n                         * run-time.  The names of these must begin with 'In'\n                         * or 'Is' (after any packages are stripped off).  So\n                         * if not one of those, or if we accept only\n                         * compile-time properties, is an error; otherwise add\n                         * it to the list for run-time look up. */\n                        if ((base_name = rninstr(name, name + n,\n                                                 colon_colon, colon_colon + 2)))\n                        { /* Has ::.  We know this must be a user-defined\n                             property */\n                            base_name += 2;\n                            final_n -= base_name - name;\n                            has_pkg = TRUE;\n                        }\n                        else {\n                            base_name = name;\n                            has_pkg = FALSE;\n                        }\n\n                        if (   final_n < 3\n                            || base_name[0] != 'I'\n                            || (base_name[1] != 's' && base_name[1] != 'n')\n                            || ret_invlist)\n                        {\n                            const char * const msg\n                                = (has_pkg)\n                                  ? \"Illegal user-defined property name\"\n                                  : \"Can't find Unicode property definition\";\n                            RExC_parse = e + 1;\n\n                            /* diag_listed_as: Can't find Unicode property definition \"%s\" */\n                            vFAIL3utf8f(\"%s \\\"%\" UTF8f \"\\\"\",\n                                msg, UTF8fARG(UTF, n, name));\n                        }\n\n                        /* If the property name doesn't already have a package\n                         * name, add the current one to it so that it can be\n                         * referred to outside it. [perl #121777] */\n                        if (! has_pkg && curpkg) {\n                            char* pkgname = HvNAME(curpkg);\n                            if (memNEs(pkgname, HvNAMELEN(curpkg), \"main\")) {\n                                char* full_name = Perl_form(aTHX_\n                                                            \"%s::%s\",\n                                                            pkgname,\n                                                            name);\n                                n = strlen(full_name);\n                                name = savepvn(full_name, n);\n                                SAVEFREEPV(name);\n                            }\n                        }\n                        Perl_sv_catpvf(aTHX_ listsv, \"%cutf8::%s%\" UTF8f \"%s\\n\",\n                                        (value == 'p' ? '+' : '!'),\n                                        (FOLD) ? \"__\" : \"\",\n                                        UTF8fARG(UTF, n, name),\n                                        (FOLD) ? \"_i\" : \"\");\n                        has_user_defined_property = TRUE;\n                        optimizable = FALSE;    /* Will have to leave this an\n                                                   ANYOF node */\n\n                        /* We don't know yet what this matches, so have to flag\n                         * it */\n                        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n                    }\n                    else {\n\n                        /* Here, did get the swash and its inversion list.  If\n                         * the swash is from a user-defined property, then this\n                         * whole character class should be regarded as such */\n                        if (swash_init_flags\n                            & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY)\n                        {\n                            has_user_defined_property = TRUE;\n                        }\n                        else if\n                            /* We warn on matching an above-Unicode code point\n                             * if the match would return true, except don't\n                             * warn for \\p{All}, which has exactly one element\n                             * = 0 */\n                            (_invlist_contains_cp(invlist, 0x110000)\n                                && (! (_invlist_len(invlist) == 1\n                                       && *invlist_array(invlist) == 0)))\n                        {\n                            warn_super = TRUE;\n                        }\n\n\n                        /* Invert if asking for the complement */\n                        if (value == 'P') {\n\t\t\t    _invlist_union_complement_2nd(properties,\n                                                          invlist,\n                                                          &properties);\n\n                            /* The swash can't be used as-is, because we've\n\t\t\t     * inverted things; delay removing it to here after\n\t\t\t     * have copied its invlist above */\n                            SvREFCNT_dec_NN(swash);\n                            swash = NULL;\n                        }\n                        else {\n                            _invlist_union(properties, invlist, &properties);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tRExC_parse = e + 1;\n                namedclass = ANYOF_UNIPROP;  /* no official name, but it's\n                                                named */\n\n\t\t/* \\p means they want Unicode semantics */\n\t\tREQUIRE_UNI_RULES(flagp, NULL);\n\t\t}\n\t\tbreak;\n\t    case 'n':\tvalue = '\\n';\t\t\tbreak;\n\t    case 'r':\tvalue = '\\r';\t\t\tbreak;\n\t    case 't':\tvalue = '\\t';\t\t\tbreak;\n\t    case 'f':\tvalue = '\\f';\t\t\tbreak;\n\t    case 'b':\tvalue = '\\b';\t\t\tbreak;\n\t    case 'e':\tvalue = ESC_NATIVE;             break;\n\t    case 'a':\tvalue = '\\a';                   break;\n\t    case 'o':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'o' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_o(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n                                               PASS2,   /* warnings only in\n                                                           pass 2 */\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n\t\t    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'x':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'x' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_x(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n\t\t\t\t\t       PASS2, /* Output warnings */\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n                    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'c':\n\t\tvalue = grok_bslash_c(*RExC_parse++, PASS2);\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case '0': case '1': case '2': case '3': case '4':\n\t    case '5': case '6': case '7':\n\t\t{\n\t\t    /* Take 1-3 octal digits */\n\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n                    numlen = (strict) ? 4 : 3;\n                    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);\n\t\t    RExC_parse += numlen;\n                    if (numlen != 3) {\n                        if (strict) {\n                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                            vFAIL(\"Need exactly 3 octal digits\");\n                        }\n                        else if (! SIZE_ONLY /* like \\08, \\178 */\n                                 && numlen < 3\n                                 && RExC_parse < RExC_end\n                                 && isDIGIT(*RExC_parse)\n                                 && ckWARN(WARN_REGEXP))\n                        {\n                            SAVEFREESV(RExC_rx_sv);\n                            reg_warn_non_literal_string(\n                                 RExC_parse + 1,\n                                 form_short_octal_warning(RExC_parse, numlen));\n                            (void)ReREFCNT_inc(RExC_rx_sv);\n                        }\n                    }\n                    non_portable_endpoint++;\n\t\t    break;\n\t\t}\n\t    default:\n\t\t/* Allow \\_ to not give an error */\n\t\tif (!SIZE_ONLY && isWORDCHAR(value) && value != '_') {\n                    if (strict) {\n                        vFAIL2(\"Unrecognized escape \\\\%c in character class\",\n                               (int)value);\n                    }\n                    else {\n                        SAVEFREESV(RExC_rx_sv);\n                        ckWARN2reg(RExC_parse,\n                            \"Unrecognized escape \\\\%c in character class passed through\",\n                            (int)value);\n                        (void)ReREFCNT_inc(RExC_rx_sv);\n                    }\n\t\t}\n\t\tbreak;\n\t    }   /* End of switch on char following backslash */\n\t} /* end of handling backslash escape sequences */\n\n        /* Here, we have the current token in 'value' */\n\n\tif (namedclass > OOB_NAMEDCLASS) { /* this is a named class \\blah */\n            U8 classnum;\n\n\t    /* a bad range like a-\\d, a-[:digit:].  The '-' is taken as a\n\t     * literal, as is the character that began the false range, i.e.\n\t     * the 'a' in the examples */\n\t    if (range) {\n\t\tif (!SIZE_ONLY) {\n\t\t    const int w = (RExC_parse >= rangebegin)\n                                  ? RExC_parse - rangebegin\n                                  : 0;\n                    if (strict) {\n                        vFAIL2utf8f(\n                            \"False [] range \\\"%\" UTF8f \"\\\"\",\n                            UTF8fARG(UTF, w, rangebegin));\n                    }\n                    else {\n                        SAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */\n                        ckWARN2reg(RExC_parse,\n                            \"False [] range \\\"%\" UTF8f \"\\\"\",\n                            UTF8fARG(UTF, w, rangebegin));\n                        (void)ReREFCNT_inc(RExC_rx_sv);\n                        cp_list = add_cp_to_invlist(cp_list, '-');\n                        cp_foldable_list = add_cp_to_invlist(cp_foldable_list,\n                                                             prevvalue);\n                    }\n\t\t}\n\n\t\trange = 0; /* this was not a true range */\n                element_count += 2; /* So counts for three values */\n\t    }\n\n            classnum = namedclass_to_classnum(namedclass);\n\n\t    if (LOC && namedclass < ANYOF_POSIXL_MAX\n#ifndef HAS_ISASCII\n                && classnum != _CC_ASCII\n#endif\n            ) {\n                /* What the Posix classes (like \\w, [:space:]) match in locale\n                 * isn't knowable under locale until actual match time.  Room\n                 * must be reserved (one time per outer bracketed class) to\n                 * store such classes.  The space will contain a bit for each\n                 * named class that is to be matched against.  This isn't\n                 * needed for \\p{} and pseudo-classes, as they are not affected\n                 * by locale, and hence are dealt with separately */\n                if (! need_class) {\n                    need_class = 1;\n                    if (SIZE_ONLY) {\n                        RExC_size += ANYOF_POSIXL_SKIP - ANYOF_SKIP;\n                    }\n                    else {\n                        RExC_emit += ANYOF_POSIXL_SKIP - ANYOF_SKIP;\n                    }\n                    ANYOF_FLAGS(ret) |= ANYOF_MATCHES_POSIXL;\n                    ANYOF_POSIXL_ZERO(ret);\n\n                    /* We can't change this into some other type of node\n                     * (unless this is the only element, in which case there\n                     * are nodes that mean exactly this) as has runtime\n                     * dependencies */\n                    optimizable = FALSE;\n                }\n\n                /* Coverity thinks it is possible for this to be negative; both\n                 * jhi and khw think it's not, but be safer */\n                assert(! (ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)\n                       || (namedclass + ((namedclass % 2) ? -1 : 1)) >= 0);\n\n                /* See if it already matches the complement of this POSIX\n                 * class */\n                if ((ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)\n                    && ANYOF_POSIXL_TEST(ret, namedclass + ((namedclass % 2)\n                                                            ? -1\n                                                            : 1)))\n                {\n                    posixl_matches_all = TRUE;\n                    break;  /* No need to continue.  Since it matches both\n                               e.g., \\w and \\W, it matches everything, and the\n                               bracketed class can be optimized into qr/./s */\n                }\n\n                /* Add this class to those that should be checked at runtime */\n                ANYOF_POSIXL_SET(ret, namedclass);\n\n                /* The above-Latin1 characters are not subject to locale rules.\n                 * Just add them, in the second pass, to the\n                 * unconditionally-matched list */\n                if (! SIZE_ONLY) {\n                    SV* scratch_list = NULL;\n\n                    /* Get the list of the above-Latin1 code points this\n                     * matches */\n                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,\n                                          PL_XPosix_ptrs[classnum],\n\n                                          /* Odd numbers are complements, like\n                                           * NDIGIT, NASCII, ... */\n                                          namedclass % 2 != 0,\n                                          &scratch_list);\n                    /* Checking if 'cp_list' is NULL first saves an extra\n                     * clone.  Its reference count will be decremented at the\n                     * next union, etc, or if this is the only instance, at the\n                     * end of the routine */\n                    if (! cp_list) {\n                        cp_list = scratch_list;\n                    }\n                    else {\n                        _invlist_union(cp_list, scratch_list, &cp_list);\n                        SvREFCNT_dec_NN(scratch_list);\n                    }\n                    continue;   /* Go get next character */\n                }\n            }\n            else if (! SIZE_ONLY) {\n\n                /* Here, not in pass1 (in that pass we skip calculating the\n                 * contents of this class), and is not /l, or is a POSIX class\n                 * for which /l doesn't matter (or is a Unicode property, which\n                 * is skipped here). */\n                if (namedclass >= ANYOF_POSIXL_MAX) {  /* If a special class */\n                    if (namedclass != ANYOF_UNIPROP) { /* UNIPROP = \\p and \\P */\n\n                        /* Here, should be \\h, \\H, \\v, or \\V.  None of /d, /i\n                         * nor /l make a difference in what these match,\n                         * therefore we just add what they match to cp_list. */\n                        if (classnum != _CC_VERTSPACE) {\n                            assert(   namedclass == ANYOF_HORIZWS\n                                   || namedclass == ANYOF_NHORIZWS);\n\n                            /* It turns out that \\h is just a synonym for\n                             * XPosixBlank */\n                            classnum = _CC_BLANK;\n                        }\n\n                        _invlist_union_maybe_complement_2nd(\n                                cp_list,\n                                PL_XPosix_ptrs[classnum],\n                                namedclass % 2 != 0,    /* Complement if odd\n                                                          (NHORIZWS, NVERTWS)\n                                                        */\n                                &cp_list);\n                    }\n                }\n                else if (  UNI_SEMANTICS\n                        || classnum == _CC_ASCII\n                        || (DEPENDS_SEMANTICS && (   classnum == _CC_DIGIT\n                                                  || classnum == _CC_XDIGIT)))\n                {\n                    /* We usually have to worry about /d and /a affecting what\n                     * POSIX classes match, with special code needed for /d\n                     * because we won't know until runtime what all matches.\n                     * But there is no extra work needed under /u, and\n                     * [:ascii:] is unaffected by /a and /d; and :digit: and\n                     * :xdigit: don't have runtime differences under /d.  So we\n                     * can special case these, and avoid some extra work below,\n                     * and at runtime. */\n                    _invlist_union_maybe_complement_2nd(\n                                                     simple_posixes,\n                                                     PL_XPosix_ptrs[classnum],\n                                                     namedclass % 2 != 0,\n                                                     &simple_posixes);\n                }\n                else {  /* Garden variety class.  If is NUPPER, NALPHA, ...\n                           complement and use nposixes */\n                    SV** posixes_ptr = namedclass % 2 == 0\n                                       ? &posixes\n                                       : &nposixes;\n                    _invlist_union_maybe_complement_2nd(\n                                                     *posixes_ptr,\n                                                     PL_XPosix_ptrs[classnum],\n                                                     namedclass % 2 != 0,\n                                                     posixes_ptr);\n                }\n\t    }\n\t} /* end of namedclass \\blah */\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        /* If 'range' is set, 'value' is the ending of a range--check its\n         * validity.  (If value isn't a single code point in the case of a\n         * range, we should have figured that out above in the code that\n         * catches false ranges).  Later, we will handle each individual code\n         * point in the range.  If 'range' isn't set, this could be the\n         * beginning of a range, so check for that by looking ahead to see if\n         * the next real character to be processed is the range indicator--the\n         * minus sign */\n\n\tif (range) {\n#ifdef EBCDIC\n            /* For unicode ranges, we have to test that the Unicode as opposed\n             * to the native values are not decreasing.  (Above 255, there is\n             * no difference between native and Unicode) */\n\t    if (unicode_range && prevvalue < 255 && value < 255) {\n                if (NATIVE_TO_LATIN1(prevvalue) > NATIVE_TO_LATIN1(value)) {\n                    goto backwards_range;\n                }\n            }\n            else\n#endif\n\t    if (prevvalue > value) /* b-a */ {\n\t\tint w;\n#ifdef EBCDIC\n              backwards_range:\n#endif\n                w = RExC_parse - rangebegin;\n                vFAIL2utf8f(\n                    \"Invalid [] range \\\"%\" UTF8f \"\\\"\",\n                    UTF8fARG(UTF, w, rangebegin));\n                NOT_REACHED; /* NOTREACHED */\n\t    }\n\t}\n\telse {\n            prevvalue = value; /* save the beginning of the potential range */\n            if (! stop_at_1     /* Can't be a range if parsing just one thing */\n                && *RExC_parse == '-')\n            {\n                char* next_char_ptr = RExC_parse + 1;\n\n                /* Get the next real char after the '-' */\n                SKIP_BRACKETED_WHITE_SPACE(skip_white, next_char_ptr);\n\n                /* If the '-' is at the end of the class (just before the ']',\n                 * it is a literal minus; otherwise it is a range */\n                if (next_char_ptr < RExC_end && *next_char_ptr != ']') {\n                    RExC_parse = next_char_ptr;\n\n                    /* a bad range like \\w-, [:word:]- ? */\n                    if (namedclass > OOB_NAMEDCLASS) {\n                        if (strict || (PASS2 && ckWARN(WARN_REGEXP))) {\n                            const int w = RExC_parse >= rangebegin\n                                          ?  RExC_parse - rangebegin\n                                          : 0;\n                            if (strict) {\n                                vFAIL4(\"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                            else if (PASS2) {\n                                vWARN4(RExC_parse,\n                                    \"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                        }\n                        if (!SIZE_ONLY) {\n                            cp_list = add_cp_to_invlist(cp_list, '-');\n                        }\n                        element_count++;\n                    } else\n                        range = 1;\t/* yeah, it's a range! */\n                    continue;\t/* but do it the next time */\n                }\n\t    }\n\t}\n\n        if (namedclass > OOB_NAMEDCLASS) {\n            continue;\n        }\n\n        /* Here, we have a single value this time through the loop, and\n         * <prevvalue> is the beginning of the range, if any; or <value> if\n         * not. */\n\n\t/* non-Latin1 code point implies unicode semantics.  Must be set in\n\t * pass1 so is there for the whole of pass 2 */\n\tif (value > 255) {\n            REQUIRE_UNI_RULES(flagp, NULL);\n\t}\n\n        /* Ready to process either the single value, or the completed range.\n         * For single-valued non-inverted ranges, we consider the possibility\n         * of multi-char folds.  (We made a conscious decision to not do this\n         * for the other cases because it can often lead to non-intuitive\n         * results.  For example, you have the peculiar case that:\n         *  \"s s\" =~ /^[^\\xDF]+$/i => Y\n         *  \"ss\"  =~ /^[^\\xDF]+$/i => N\n         *\n         * See [perl #89750] */\n        if (FOLD && allow_multi_folds && value == prevvalue) {\n            if (value == LATIN_SMALL_LETTER_SHARP_S\n                || (value > 255 && _invlist_contains_cp(PL_HasMultiCharFold,\n                                                        value)))\n            {\n                /* Here <value> is indeed a multi-char fold.  Get what it is */\n\n                U8 foldbuf[UTF8_MAXBYTES_CASE];\n                STRLEN foldlen;\n\n                UV folded = _to_uni_fold_flags(\n                                value,\n                                foldbuf,\n                                &foldlen,\n                                FOLD_FLAGS_FULL | (ASCII_FOLD_RESTRICTED\n                                                   ? FOLD_FLAGS_NOMIX_ASCII\n                                                   : 0)\n                                );\n\n                /* Here, <folded> should be the first character of the\n                 * multi-char fold of <value>, with <foldbuf> containing the\n                 * whole thing.  But, if this fold is not allowed (because of\n                 * the flags), <fold> will be the same as <value>, and should\n                 * be processed like any other character, so skip the special\n                 * handling */\n                if (folded != value) {\n\n                    /* Skip if we are recursed, currently parsing the class\n                     * again.  Otherwise add this character to the list of\n                     * multi-char folds. */\n                    if (! RExC_in_multi_char_class) {\n                        STRLEN cp_count = utf8_length(foldbuf,\n                                                      foldbuf + foldlen);\n                        SV* multi_fold = sv_2mortal(newSVpvs(\"\"));\n\n                        Perl_sv_catpvf(aTHX_ multi_fold, \"\\\\x{%\" UVXf \"}\", value);\n\n                        multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_fold,\n                                                          cp_count);\n\n                    }\n\n                    /* This element should not be processed further in this\n                     * class */\n                    element_count--;\n                    value = save_value;\n                    prevvalue = save_prevvalue;\n                    continue;\n                }\n            }\n        }\n\n        if (strict && PASS2 && ckWARN(WARN_REGEXP)) {\n            if (range) {\n\n                /* If the range starts above 255, everything is portable and\n                 * likely to be so for any forseeable character set, so don't\n                 * warn. */\n                if (unicode_range && non_portable_endpoint && prevvalue < 256) {\n                    vWARN(RExC_parse, \"Both or neither range ends should be Unicode\");\n                }\n                else if (prevvalue != value) {\n\n                    /* Under strict, ranges that stop and/or end in an ASCII\n                     * printable should have each end point be a portable value\n                     * for it (preferably like 'A', but we don't warn if it is\n                     * a (portable) Unicode name or code point), and the range\n                     * must be be all digits or all letters of the same case.\n                     * Otherwise, the range is non-portable and unclear as to\n                     * what it contains */\n                    if (             (isPRINT_A(prevvalue) || isPRINT_A(value))\n                        && (          non_portable_endpoint\n                            || ! (   (isDIGIT_A(prevvalue) && isDIGIT_A(value))\n                                  || (isLOWER_A(prevvalue) && isLOWER_A(value))\n                                  || (isUPPER_A(prevvalue) && isUPPER_A(value))\n                    ))) {\n                        vWARN(RExC_parse, \"Ranges of ASCII printables should\"\n                                          \" be some subset of \\\"0-9\\\",\"\n                                          \" \\\"A-Z\\\", or \\\"a-z\\\"\");\n                    }\n                    else if (prevvalue >= 0x660) { /* ARABIC_INDIC_DIGIT_ZERO */\n                        SSize_t index_start;\n                        SSize_t index_final;\n\n                        /* But the nature of Unicode and languages mean we\n                         * can't do the same checks for above-ASCII ranges,\n                         * except in the case of digit ones.  These should\n                         * contain only digits from the same group of 10.  The\n                         * ASCII case is handled just above.  0x660 is the\n                         * first digit character beyond ASCII.  Hence here, the\n                         * range could be a range of digits.  First some\n                         * unlikely special cases.  Grandfather in that a range\n                         * ending in 19DA (NEW TAI LUE THAM DIGIT ONE) is bad\n                         * if its starting value is one of the 10 digits prior\n                         * to it.  This is because it is an alternate way of\n                         * writing 19D1, and some people may expect it to be in\n                         * that group.  But it is bad, because it won't give\n                         * the expected results.  In Unicode 5.2 it was\n                         * considered to be in that group (of 11, hence), but\n                         * this was fixed in the next version */\n\n                        if (UNLIKELY(value == 0x19DA && prevvalue >= 0x19D0)) {\n                            goto warn_bad_digit_range;\n                        }\n                        else if (UNLIKELY(   prevvalue >= 0x1D7CE\n                                          &&     value <= 0x1D7FF))\n                        {\n                            /* This is the only other case currently in Unicode\n                             * where the algorithm below fails.  The code\n                             * points just above are the end points of a single\n                             * range containing only decimal digits.  It is 5\n                             * different series of 0-9.  All other ranges of\n                             * digits currently in Unicode are just a single\n                             * series.  (And mktables will notify us if a later\n                             * Unicode version breaks this.)\n                             *\n                             * If the range being checked is at most 9 long,\n                             * and the digit values represented are in\n                             * numerical order, they are from the same series.\n                             * */\n                            if (         value - prevvalue > 9\n                                ||    (((    value - 0x1D7CE) % 10)\n                                     <= (prevvalue - 0x1D7CE) % 10))\n                            {\n                                goto warn_bad_digit_range;\n                            }\n                        }\n                        else {\n\n                            /* For all other ranges of digits in Unicode, the\n                             * algorithm is just to check if both end points\n                             * are in the same series, which is the same range.\n                             * */\n                            index_start = _invlist_search(\n                                                    PL_XPosix_ptrs[_CC_DIGIT],\n                                                    prevvalue);\n\n                            /* Warn if the range starts and ends with a digit,\n                             * and they are not in the same group of 10. */\n                            if (   index_start >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_start)\n                                && (index_final =\n                                    _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],\n                                                    value)) != index_start\n                                && index_final >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_final))\n                            {\n                              warn_bad_digit_range:\n                                vWARN(RExC_parse, \"Ranges of digits should be\"\n                                                  \" from the same group of\"\n                                                  \" 10\");\n                            }\n                        }\n                    }\n                }\n            }\n            if ((! range || prevvalue == value) && non_portable_endpoint) {\n                if (isPRINT_A(value)) {\n                    char literal[3];\n                    unsigned d = 0;\n                    if (isBACKSLASHED_PUNCT(value)) {\n                        literal[d++] = '\\\\';\n                    }\n                    literal[d++] = (char) value;\n                    literal[d++] = '\\0';\n\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           literal\n                        );\n                }\n                else if isMNEMONIC_CNTRL(value) {\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           cntrl_to_mnemonic((U8) value)\n                        );\n                }\n            }\n        }\n\n        /* Deal with this element of the class */\n\tif (! SIZE_ONLY) {\n\n#ifndef EBCDIC\n            cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                     prevvalue, value);\n#else\n            /* On non-ASCII platforms, for ranges that span all of 0..255, and\n             * ones that don't require special handling, we can just add the\n             * range like we do for ASCII platforms */\n            if ((UNLIKELY(prevvalue == 0) && value >= 255)\n                || ! (prevvalue < 256\n                      && (unicode_range\n                          || (! non_portable_endpoint\n                              && ((isLOWER_A(prevvalue) && isLOWER_A(value))\n                                  || (isUPPER_A(prevvalue)\n                                      && isUPPER_A(value)))))))\n            {\n                cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                         prevvalue, value);\n            }\n            else {\n                /* Here, requires special handling.  This can be because it is\n                 * a range whose code points are considered to be Unicode, and\n                 * so must be individually translated into native, or because\n                 * its a subrange of 'A-Z' or 'a-z' which each aren't\n                 * contiguous in EBCDIC, but we have defined them to include\n                 * only the \"expected\" upper or lower case ASCII alphabetics.\n                 * Subranges above 255 are the same in native and Unicode, so\n                 * can be added as a range */\n                U8 start = NATIVE_TO_LATIN1(prevvalue);\n                unsigned j;\n                U8 end = (value < 256) ? NATIVE_TO_LATIN1(value) : 255;\n                for (j = start; j <= end; j++) {\n                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list, LATIN1_TO_NATIVE(j));\n                }\n                if (value > 255) {\n                    cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                             256, value);\n                }\n            }\n#endif\n        }\n\n\trange = 0; /* this range (if it was one) is done now */\n    } /* End of loop through all the text within the brackets */\n\n\n    if (   posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {\n        output_or_return_posix_warnings(pRExC_state, posix_warnings,\n                                        return_posix_warnings);\n    }\n\n    /* If anything in the class expands to more than one character, we have to\n     * deal with them by building up a substitute parse string, and recursively\n     * calling reg() on it, instead of proceeding */\n    if (multi_char_matches) {\n\tSV * substitute_parse = newSVpvn_flags(\"?:\", 2, SVs_TEMP);\n        I32 cp_count;\n\tSTRLEN len;\n\tchar *save_end = RExC_end;\n\tchar *save_parse = RExC_parse;\n\tchar *save_start = RExC_start;\n        STRLEN prefix_end = 0;      /* We copy the character class after a\n                                       prefix supplied here.  This is the size\n                                       + 1 of that prefix */\n        bool first_time = TRUE;     /* First multi-char occurrence doesn't get\n                                       a \"|\" */\n        I32 reg_flags;\n\n        assert(! invert);\n        assert(RExC_precomp_adj == 0); /* Only one level of recursion allowed */\n\n#if 0   /* Have decided not to deal with multi-char folds in inverted classes,\n           because too confusing */\n        if (invert) {\n            sv_catpv(substitute_parse, \"(?:\");\n        }\n#endif\n\n        /* Look at the longest folds first */\n        for (cp_count = av_tindex_skip_len_mg(multi_char_matches);\n                        cp_count > 0;\n                        cp_count--)\n        {\n\n            if (av_exists(multi_char_matches, cp_count)) {\n                AV** this_array_ptr;\n                SV* this_sequence;\n\n                this_array_ptr = (AV**) av_fetch(multi_char_matches,\n                                                 cp_count, FALSE);\n                while ((this_sequence = av_pop(*this_array_ptr)) !=\n                                                                &PL_sv_undef)\n                {\n                    if (! first_time) {\n                        sv_catpv(substitute_parse, \"|\");\n                    }\n                    first_time = FALSE;\n\n                    sv_catpv(substitute_parse, SvPVX(this_sequence));\n                }\n            }\n        }\n\n        /* If the character class contains anything else besides these\n         * multi-character folds, have to include it in recursive parsing */\n        if (element_count) {\n            sv_catpv(substitute_parse, \"|[\");\n            prefix_end = SvCUR(substitute_parse);\n            sv_catpvn(substitute_parse, orig_parse, RExC_parse - orig_parse);\n\n            /* Put in a closing ']' only if not going off the end, as otherwise\n             * we are adding something that really isn't there */\n            if (RExC_parse < RExC_end) {\n                sv_catpv(substitute_parse, \"]\");\n            }\n        }\n\n        sv_catpv(substitute_parse, \")\");\n#if 0\n        if (invert) {\n            /* This is a way to get the parse to skip forward a whole named\n             * sequence instead of matching the 2nd character when it fails the\n             * first */\n            sv_catpv(substitute_parse, \"(*THEN)(*SKIP)(*FAIL)|.)\");\n        }\n#endif\n\n        /* Set up the data structure so that any errors will be properly\n         * reported.  See the comments at the definition of\n         * REPORT_LOCATION_ARGS for details */\n        RExC_precomp_adj = orig_parse - RExC_precomp;\n\tRExC_start =  RExC_parse = SvPV(substitute_parse, len);\n        RExC_adjusted_start = RExC_start + prefix_end;\n\tRExC_end = RExC_parse + len;\n        RExC_in_multi_char_class = 1;\n        RExC_emit = (regnode *)orig_emit;\n\n\tret = reg(pRExC_state, 1, &reg_flags, depth+1);\n\n\t*flagp |= reg_flags&(HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_PASS1|NEED_UTF8);\n\n        /* And restore so can parse the rest of the pattern */\n        RExC_parse = save_parse;\n\tRExC_start = RExC_adjusted_start = save_start;\n        RExC_precomp_adj = 0;\n\tRExC_end = save_end;\n\tRExC_in_multi_char_class = 0;\n        SvREFCNT_dec_NN(multi_char_matches);\n        return ret;\n    }\n\n    /* Here, we've gone through the entire class and dealt with multi-char\n     * folds.  We are now in a position that we can do some checks to see if we\n     * can optimize this ANYOF node into a simpler one, even in Pass 1.\n     * Currently we only do two checks:\n     * 1) is in the unlikely event that the user has specified both, eg. \\w and\n     *    \\W under /l, then the class matches everything.  (This optimization\n     *    is done only to make the optimizer code run later work.)\n     * 2) if the character class contains only a single element (including a\n     *    single range), we see if there is an equivalent node for it.\n     * Other checks are possible */\n    if (   optimizable\n        && ! ret_invlist   /* Can't optimize if returning the constructed\n                              inversion list */\n        && (UNLIKELY(posixl_matches_all) || element_count == 1))\n    {\n        U8 op = END;\n        U8 arg = 0;\n\n        if (UNLIKELY(posixl_matches_all)) {\n            op = SANY;\n        }\n        else if (namedclass > OOB_NAMEDCLASS) { /* this is a single named\n                                                   class, like \\w or [:digit:]\n                                                   or \\p{foo} */\n\n            /* All named classes are mapped into POSIXish nodes, with its FLAG\n             * argument giving which class it is */\n            switch ((I32)namedclass) {\n                case ANYOF_UNIPROP:\n                    break;\n\n                /* These don't depend on the charset modifiers.  They always\n                 * match under /u rules */\n                case ANYOF_NHORIZWS:\n                case ANYOF_HORIZWS:\n                    namedclass = ANYOF_BLANK + namedclass - ANYOF_HORIZWS;\n                    /* FALLTHROUGH */\n\n                case ANYOF_NVERTWS:\n                case ANYOF_VERTWS:\n                    op = POSIXU;\n                    goto join_posix;\n\n                /* The actual POSIXish node for all the rest depends on the\n                 * charset modifier.  The ones in the first set depend only on\n                 * ASCII or, if available on this platform, also locale */\n                case ANYOF_ASCII:\n                case ANYOF_NASCII:\n#ifdef HAS_ISASCII\n                    op = (LOC) ? POSIXL : POSIXA;\n#else\n                    op = POSIXA;\n#endif\n                    goto join_posix;\n\n                /* The following don't have any matches in the upper Latin1\n                 * range, hence /d is equivalent to /u for them.  Making it /u\n                 * saves some branches at runtime */\n                case ANYOF_DIGIT:\n                case ANYOF_NDIGIT:\n                case ANYOF_XDIGIT:\n                case ANYOF_NXDIGIT:\n                    if (! DEPENDS_SEMANTICS) {\n                        goto treat_as_default;\n                    }\n\n                    op = POSIXU;\n                    goto join_posix;\n\n                /* The following change to CASED under /i */\n                case ANYOF_LOWER:\n                case ANYOF_NLOWER:\n                case ANYOF_UPPER:\n                case ANYOF_NUPPER:\n                    if (FOLD) {\n                        namedclass = ANYOF_CASED + (namedclass % 2);\n                    }\n                    /* FALLTHROUGH */\n\n                /* The rest have more possibilities depending on the charset.\n                 * We take advantage of the enum ordering of the charset\n                 * modifiers to get the exact node type, */\n                default:\n                  treat_as_default:\n                    op = POSIXD + get_regex_charset(RExC_flags);\n                    if (op > POSIXA) { /* /aa is same as /a */\n                        op = POSIXA;\n                    }\n\n                  join_posix:\n                    /* The odd numbered ones are the complements of the\n                     * next-lower even number one */\n                    if (namedclass % 2 == 1) {\n                        invert = ! invert;\n                        namedclass--;\n                    }\n                    arg = namedclass_to_classnum(namedclass);\n                    break;\n            }\n        }\n        else if (value == prevvalue) {\n\n            /* Here, the class consists of just a single code point */\n\n            if (invert) {\n                if (! LOC && value == '\\n') {\n                    op = REG_ANY; /* Optimize [^\\n] */\n                    *flagp |= HASWIDTH|SIMPLE;\n                    MARK_NAUGHTY(1);\n                }\n            }\n            else if (value < 256 || UTF) {\n\n                /* Optimize a single value into an EXACTish node, but not if it\n                 * would require converting the pattern to UTF-8. */\n                op = compute_EXACTish(pRExC_state);\n            }\n        } /* Otherwise is a range */\n        else if (! LOC) {   /* locale could vary these */\n            if (prevvalue == '0') {\n                if (value == '9') {\n                    arg = _CC_DIGIT;\n                    op = POSIXA;\n                }\n            }\n            else if (! FOLD || ASCII_FOLD_RESTRICTED) {\n                /* We can optimize A-Z or a-z, but not if they could match\n                 * something like the KELVIN SIGN under /i. */\n                if (prevvalue == 'A') {\n                    if (value == 'Z'\n#ifdef EBCDIC\n                        && ! non_portable_endpoint\n#endif\n                    ) {\n                        arg = (FOLD) ? _CC_ALPHA : _CC_UPPER;\n                        op = POSIXA;\n                    }\n                }\n                else if (prevvalue == 'a') {\n                    if (value == 'z'\n#ifdef EBCDIC\n                        && ! non_portable_endpoint\n#endif\n                    ) {\n                        arg = (FOLD) ? _CC_ALPHA : _CC_LOWER;\n                        op = POSIXA;\n                    }\n                }\n            }\n        }\n\n        /* Here, we have changed <op> away from its initial value iff we found\n         * an optimization */\n        if (op != END) {\n\n            /* Throw away this ANYOF regnode, and emit the calculated one,\n             * which should correspond to the beginning, not current, state of\n             * the parse */\n            const char * cur_parse = RExC_parse;\n            RExC_parse = (char *)orig_parse;\n            if ( SIZE_ONLY) {\n                if (! LOC) {\n\n                    /* To get locale nodes to not use the full ANYOF size would\n                     * require moving the code above that writes the portions\n                     * of it that aren't in other nodes to after this point.\n                     * e.g.  ANYOF_POSIXL_SET */\n                    RExC_size = orig_size;\n                }\n            }\n            else {\n                RExC_emit = (regnode *)orig_emit;\n                if (PL_regkind[op] == POSIXD) {\n                    if (op == POSIXL) {\n                        RExC_contains_locale = 1;\n                    }\n                    if (invert) {\n                        op += NPOSIXD - POSIXD;\n                    }\n                }\n            }\n\n            ret = reg_node(pRExC_state, op);\n\n            if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {\n                if (! SIZE_ONLY) {\n                    FLAGS(ret) = arg;\n                }\n                *flagp |= HASWIDTH|SIMPLE;\n            }\n            else if (PL_regkind[op] == EXACT) {\n                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,\n                                           TRUE /* downgradable to EXACT */\n                                           );\n            }\n\n            RExC_parse = (char *) cur_parse;\n\n            SvREFCNT_dec(posixes);\n            SvREFCNT_dec(nposixes);\n            SvREFCNT_dec(simple_posixes);\n            SvREFCNT_dec(cp_list);\n            SvREFCNT_dec(cp_foldable_list);\n            return ret;\n        }\n    }\n\n    if (SIZE_ONLY)\n        return ret;\n    /****** !SIZE_ONLY (Pass 2) AFTER HERE *********/\n\n    /* If folding, we calculate all characters that could fold to or from the\n     * ones already on the list */\n    if (cp_foldable_list) {\n        if (FOLD) {\n            UV start, end;\t/* End points of code point ranges */\n\n            SV* fold_intersection = NULL;\n            SV** use_list;\n\n            /* Our calculated list will be for Unicode rules.  For locale\n             * matching, we have to keep a separate list that is consulted at\n             * runtime only when the locale indicates Unicode rules.  For\n             * non-locale, we just use the general list */\n            if (LOC) {\n                use_list = &only_utf8_locale_list;\n            }\n            else {\n                use_list = &cp_list;\n            }\n\n            /* Only the characters in this class that participate in folds need\n             * be checked.  Get the intersection of this class and all the\n             * possible characters that are foldable.  This can quickly narrow\n             * down a large class */\n            _invlist_intersection(PL_utf8_foldable, cp_foldable_list,\n                                  &fold_intersection);\n\n            /* The folds for all the Latin1 characters are hard-coded into this\n             * program, but we have to go out to disk to get the others. */\n            if (invlist_highest(cp_foldable_list) >= 256) {\n\n                /* This is a hash that for a particular fold gives all\n                 * characters that are involved in it */\n                if (! PL_utf8_foldclosures) {\n                    _load_PL_utf8_foldclosures();\n                }\n            }\n\n            /* Now look at the foldable characters in this class individually */\n            invlist_iterinit(fold_intersection);\n            while (invlist_iternext(fold_intersection, &start, &end)) {\n                UV j;\n\n                /* Look at every character in the range */\n                for (j = start; j <= end; j++) {\n                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];\n                    STRLEN foldlen;\n                    SV** listp;\n\n                    if (j < 256) {\n\n                        if (IS_IN_SOME_FOLD_L1(j)) {\n\n                            /* ASCII is always matched; non-ASCII is matched\n                             * only under Unicode rules (which could happen\n                             * under /l if the locale is a UTF-8 one */\n                            if (isASCII(j) || ! DEPENDS_SEMANTICS) {\n                                *use_list = add_cp_to_invlist(*use_list,\n                                                            PL_fold_latin1[j]);\n                            }\n                            else {\n                                has_upper_latin1_only_utf8_matches\n                                    = add_cp_to_invlist(\n                                            has_upper_latin1_only_utf8_matches,\n                                            PL_fold_latin1[j]);\n                            }\n                        }\n\n                        if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(j)\n                            && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))\n                        {\n                            add_above_Latin1_folds(pRExC_state,\n                                                   (U8) j,\n                                                   use_list);\n                        }\n                        continue;\n                    }\n\n                    /* Here is an above Latin1 character.  We don't have the\n                     * rules hard-coded for it.  First, get its fold.  This is\n                     * the simple fold, as the multi-character folds have been\n                     * handled earlier and separated out */\n                    _to_uni_fold_flags(j, foldbuf, &foldlen,\n                                                        (ASCII_FOLD_RESTRICTED)\n                                                        ? FOLD_FLAGS_NOMIX_ASCII\n                                                        : 0);\n\n                    /* Single character fold of above Latin1.  Add everything in\n                    * its fold closure to the list that this node should match.\n                    * The fold closures data structure is a hash with the keys\n                    * being the UTF-8 of every character that is folded to, like\n                    * 'k', and the values each an array of all code points that\n                    * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].\n                    * Multi-character folds are not included */\n                    if ((listp = hv_fetch(PL_utf8_foldclosures,\n                                        (char *) foldbuf, foldlen, FALSE)))\n                    {\n                        AV* list = (AV*) *listp;\n                        IV k;\n                        for (k = 0; k <= av_tindex_skip_len_mg(list); k++) {\n                            SV** c_p = av_fetch(list, k, FALSE);\n                            UV c;\n                            assert(c_p);\n\n                            c = SvUV(*c_p);\n\n                            /* /aa doesn't allow folds between ASCII and non- */\n                            if ((ASCII_FOLD_RESTRICTED\n                                && (isASCII(c) != isASCII(j))))\n                            {\n                                continue;\n                            }\n\n                            /* Folds under /l which cross the 255/256 boundary\n                             * are added to a separate list.  (These are valid\n                             * only when the locale is UTF-8.) */\n                            if (c < 256 && LOC) {\n                                *use_list = add_cp_to_invlist(*use_list, c);\n                                continue;\n                            }\n\n                            if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)\n                            {\n                                cp_list = add_cp_to_invlist(cp_list, c);\n                            }\n                            else {\n                                /* Similarly folds involving non-ascii Latin1\n                                * characters under /d are added to their list */\n                                has_upper_latin1_only_utf8_matches\n                                        = add_cp_to_invlist(\n                                           has_upper_latin1_only_utf8_matches,\n                                           c);\n                            }\n                        }\n                    }\n                }\n            }\n            SvREFCNT_dec_NN(fold_intersection);\n        }\n\n        /* Now that we have finished adding all the folds, there is no reason\n         * to keep the foldable list separate */\n        _invlist_union(cp_list, cp_foldable_list, &cp_list);\n\tSvREFCNT_dec_NN(cp_foldable_list);\n    }\n\n    /* And combine the result (if any) with any inversion lists from posix\n     * classes.  The lists are kept separate up to now because we don't want to\n     * fold the classes (folding of those is automatically handled by the swash\n     * fetching code) */\n    if (simple_posixes) {   /* These are the classes known to be unaffected by\n                               /a, /aa, and /d */\n        if (cp_list) {\n            _invlist_union(cp_list, simple_posixes, &cp_list);\n            SvREFCNT_dec_NN(simple_posixes);\n        }\n        else {\n            cp_list = simple_posixes;\n        }\n    }\n    if (posixes || nposixes) {\n\n        /* We have to adjust /a and /aa */\n        if (AT_LEAST_ASCII_RESTRICTED) {\n\n            /* Under /a and /aa, nothing above ASCII matches these */\n            if (posixes) {\n                _invlist_intersection(posixes,\n                                    PL_XPosix_ptrs[_CC_ASCII],\n                                    &posixes);\n            }\n\n            /* Under /a and /aa, everything above ASCII matches these\n             * complements */\n            if (nposixes) {\n                _invlist_union_complement_2nd(nposixes,\n                                              PL_XPosix_ptrs[_CC_ASCII],\n                                              &nposixes);\n            }\n        }\n\n        if (! DEPENDS_SEMANTICS) {\n\n            /* For everything but /d, we can just add the current 'posixes' and\n             * 'nposixes' to the main list */\n            if (posixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                }\n                else {\n                    cp_list = posixes;\n                }\n            }\n            if (nposixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                }\n                else {\n                    cp_list = nposixes;\n                }\n            }\n        }\n        else {\n            /* Under /d, things like \\w match upper Latin1 characters only if\n             * the target string is in UTF-8.  But things like \\W match all the\n             * upper Latin1 characters if the target string is not in UTF-8.\n             *\n             * Handle the case where there something like \\W separately */\n            if (nposixes) {\n                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1);\n\n                /* A complemented posix class matches all upper Latin1\n                 * characters if not in UTF-8.  And it matches just certain\n                 * ones when in UTF-8.  That means those certain ones are\n                 * matched regardless, so can just be added to the\n                 * unconditional list */\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                    nposixes = NULL;\n                }\n                else {\n                    cp_list = nposixes;\n                }\n\n                /* Likewise for 'posixes' */\n                _invlist_union(posixes, cp_list, &cp_list);\n\n                /* Likewise for anything else in the range that matched only\n                 * under UTF-8 */\n                if (has_upper_latin1_only_utf8_matches) {\n                    _invlist_union(cp_list,\n                                   has_upper_latin1_only_utf8_matches,\n                                   &cp_list);\n                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);\n                    has_upper_latin1_only_utf8_matches = NULL;\n                }\n\n                /* If we don't match all the upper Latin1 characters regardless\n                 * of UTF-8ness, we have to set a flag to match the rest when\n                 * not in UTF-8 */\n                _invlist_subtract(only_non_utf8_list, cp_list,\n                                  &only_non_utf8_list);\n                if (_invlist_len(only_non_utf8_list) != 0) {\n                    ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n                }\n            }\n            else {\n                /* Here there were no complemented posix classes.  That means\n                 * the upper Latin1 characters in 'posixes' match only when the\n                 * target string is in UTF-8.  So we have to add them to the\n                 * list of those types of code points, while adding the\n                 * remainder to the unconditional list.\n                 *\n                 * First calculate what they are */\n                SV* nonascii_but_latin1_properties = NULL;\n                _invlist_intersection(posixes, PL_UpperLatin1,\n                                      &nonascii_but_latin1_properties);\n\n                /* And add them to the final list of such characters. */\n                _invlist_union(has_upper_latin1_only_utf8_matches,\n                               nonascii_but_latin1_properties,\n                               &has_upper_latin1_only_utf8_matches);\n\n                /* Remove them from what now becomes the unconditional list */\n                _invlist_subtract(posixes, nonascii_but_latin1_properties,\n                                  &posixes);\n\n                /* And add those unconditional ones to the final list */\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                    posixes = NULL;\n                }\n                else {\n                    cp_list = posixes;\n                }\n\n                SvREFCNT_dec(nonascii_but_latin1_properties);\n\n                /* Get rid of any characters that we now know are matched\n                 * unconditionally from the conditional list, which may make\n                 * that list empty */\n                _invlist_subtract(has_upper_latin1_only_utf8_matches,\n                                  cp_list,\n                                  &has_upper_latin1_only_utf8_matches);\n                if (_invlist_len(has_upper_latin1_only_utf8_matches) == 0) {\n                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);\n                    has_upper_latin1_only_utf8_matches = NULL;\n                }\n            }\n        }\n    }\n\n    /* And combine the result (if any) with any inversion list from properties.\n     * The lists are kept separate up to now so that we can distinguish the two\n     * in regards to matching above-Unicode.  A run-time warning is generated\n     * if a Unicode property is matched against a non-Unicode code point. But,\n     * we allow user-defined properties to match anything, without any warning,\n     * and we also suppress the warning if there is a portion of the character\n     * class that isn't a Unicode property, and which matches above Unicode, \\W\n     * or [\\x{110000}] for example.\n     * (Note that in this case, unlike the Posix one above, there is no\n     * <has_upper_latin1_only_utf8_matches>, because having a Unicode property\n     * forces Unicode semantics */\n    if (properties) {\n        if (cp_list) {\n\n            /* If it matters to the final outcome, see if a non-property\n             * component of the class matches above Unicode.  If so, the\n             * warning gets suppressed.  This is true even if just a single\n             * such code point is specified, as, though not strictly correct if\n             * another such code point is matched against, the fact that they\n             * are using above-Unicode code points indicates they should know\n             * the issues involved */\n            if (warn_super) {\n                warn_super = ! (invert\n                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));\n            }\n\n            _invlist_union(properties, cp_list, &cp_list);\n            SvREFCNT_dec_NN(properties);\n        }\n        else {\n            cp_list = properties;\n        }\n\n        if (warn_super) {\n            ANYOF_FLAGS(ret)\n             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n\n            /* Because an ANYOF node is the only one that warns, this node\n             * can't be optimized into something else */\n            optimizable = FALSE;\n        }\n    }\n\n    /* Here, we have calculated what code points should be in the character\n     * class.\n     *\n     * Now we can see about various optimizations.  Fold calculation (which we\n     * did above) needs to take place before inversion.  Otherwise /[^k]/i\n     * would invert to include K, which under /i would match k, which it\n     * shouldn't.  Therefore we can't invert folded locale now, as it won't be\n     * folded until runtime */\n\n    /* If we didn't do folding, it's because some information isn't available\n     * until runtime; set the run-time fold flag for these.  (We don't have to\n     * worry about properties folding, as that is taken care of by the swash\n     * fetching).  We know to set the flag if we have a non-NULL list for UTF-8\n     * locales, or the class matches at least one 0-255 range code point */\n    if (LOC && FOLD) {\n\n        /* Some things on the list might be unconditionally included because of\n         * other components.  Remove them, and clean up the list if it goes to\n         * 0 elements */\n        if (only_utf8_locale_list && cp_list) {\n            _invlist_subtract(only_utf8_locale_list, cp_list,\n                              &only_utf8_locale_list);\n\n            if (_invlist_len(only_utf8_locale_list) == 0) {\n                SvREFCNT_dec_NN(only_utf8_locale_list);\n                only_utf8_locale_list = NULL;\n            }\n        }\n        if (only_utf8_locale_list) {\n            ANYOF_FLAGS(ret)\n                 |=  ANYOFL_FOLD\n                    |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n        }\n        else if (cp_list) { /* Look to see if a 0-255 code point is in list */\n            UV start, end;\n            invlist_iterinit(cp_list);\n            if (invlist_iternext(cp_list, &start, &end) && start < 256) {\n                ANYOF_FLAGS(ret) |= ANYOFL_FOLD;\n            }\n            invlist_iterfinish(cp_list);\n        }\n    }\n    else if (   DEPENDS_SEMANTICS\n             && (    has_upper_latin1_only_utf8_matches\n                 || (ANYOF_FLAGS(ret) & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)))\n    {\n        OP(ret) = ANYOFD;\n        optimizable = FALSE;\n    }\n\n\n    /* Optimize inverted simple patterns (e.g. [^a-z]) when everything is known\n     * at compile time.  Besides not inverting folded locale now, we can't\n     * invert if there are things such as \\w, which aren't known until runtime\n     * */\n    if (cp_list\n        && invert\n        && OP(ret) != ANYOFD\n        && ! (ANYOF_FLAGS(ret) & (ANYOF_LOCALE_FLAGS))\n\t&& ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)\n    {\n        _invlist_invert(cp_list);\n\n        /* Any swash can't be used as-is, because we've inverted things */\n        if (swash) {\n            SvREFCNT_dec_NN(swash);\n            swash = NULL;\n        }\n\n\t/* Clear the invert flag since have just done it here */\n\tinvert = FALSE;\n    }\n\n    if (ret_invlist) {\n        assert(cp_list);\n\n        *ret_invlist = cp_list;\n        SvREFCNT_dec(swash);\n\n        /* Discard the generated node */\n        if (SIZE_ONLY) {\n            RExC_size = orig_size;\n        }\n        else {\n            RExC_emit = orig_emit;\n        }\n        return orig_emit;\n    }\n\n    /* Some character classes are equivalent to other nodes.  Such nodes take\n     * up less room and generally fewer operations to execute than ANYOF nodes.\n     * Above, we checked for and optimized into some such equivalents for\n     * certain common classes that are easy to test.  Getting to this point in\n     * the code means that the class didn't get optimized there.  Since this\n     * code is only executed in Pass 2, it is too late to save space--it has\n     * been allocated in Pass 1, and currently isn't given back.  But turning\n     * things into an EXACTish node can allow the optimizer to join it to any\n     * adjacent such nodes.  And if the class is equivalent to things like /./,\n     * expensive run-time swashes can be avoided.  Now that we have more\n     * complete information, we can find things necessarily missed by the\n     * earlier code.  Another possible \"optimization\" that isn't done is that\n     * something like [Ee] could be changed into an EXACTFU.  khw tried this\n     * and found that the ANYOF is faster, including for code points not in the\n     * bitmap.  This still might make sense to do, provided it got joined with\n     * an adjacent node(s) to create a longer EXACTFU one.  This could be\n     * accomplished by creating a pseudo ANYOF_EXACTFU node type that the join\n     * routine would know is joinable.  If that didn't happen, the node type\n     * could then be made a straight ANYOF */\n\n    if (optimizable && cp_list && ! invert) {\n        UV start, end;\n        U8 op = END;  /* The optimzation node-type */\n        int posix_class = -1;   /* Illegal value */\n        const char * cur_parse= RExC_parse;\n\n        invlist_iterinit(cp_list);\n        if (! invlist_iternext(cp_list, &start, &end)) {\n\n            /* Here, the list is empty.  This happens, for example, when a\n             * Unicode property that doesn't match anything is the only element\n             * in the character class (perluniprops.pod notes such properties).\n             * */\n            op = OPFAIL;\n            *flagp |= HASWIDTH|SIMPLE;\n        }\n        else if (start == end) {    /* The range is a single code point */\n            if (! invlist_iternext(cp_list, &start, &end)\n\n                    /* Don't do this optimization if it would require changing\n                     * the pattern to UTF-8 */\n                && (start < 256 || UTF))\n            {\n                /* Here, the list contains a single code point.  Can optimize\n                 * into an EXACTish node */\n\n                value = start;\n\n                if (! FOLD) {\n                    op = (LOC)\n                         ? EXACTL\n                         : EXACT;\n                }\n                else if (LOC) {\n\n                    /* A locale node under folding with one code point can be\n                     * an EXACTFL, as its fold won't be calculated until\n                     * runtime */\n                    op = EXACTFL;\n                }\n                else {\n\n                    /* Here, we are generally folding, but there is only one\n                     * code point to match.  If we have to, we use an EXACT\n                     * node, but it would be better for joining with adjacent\n                     * nodes in the optimization pass if we used the same\n                     * EXACTFish node that any such are likely to be.  We can\n                     * do this iff the code point doesn't participate in any\n                     * folds.  For example, an EXACTF of a colon is the same as\n                     * an EXACT one, since nothing folds to or from a colon. */\n                    if (value < 256) {\n                        if (IS_IN_SOME_FOLD_L1(value)) {\n                            op = EXACT;\n                        }\n                    }\n                    else {\n                        if (_invlist_contains_cp(PL_utf8_foldable, value)) {\n                            op = EXACT;\n                        }\n                    }\n\n                    /* If we haven't found the node type, above, it means we\n                     * can use the prevailing one */\n                    if (op == END) {\n                        op = compute_EXACTish(pRExC_state);\n                    }\n                }\n            }\n        }   /* End of first range contains just a single code point */\n        else if (start == 0) {\n            if (end == UV_MAX) {\n                op = SANY;\n                *flagp |= HASWIDTH|SIMPLE;\n                MARK_NAUGHTY(1);\n            }\n            else if (end == '\\n' - 1\n                    && invlist_iternext(cp_list, &start, &end)\n                    && start == '\\n' + 1 && end == UV_MAX)\n            {\n                op = REG_ANY;\n                *flagp |= HASWIDTH|SIMPLE;\n                MARK_NAUGHTY(1);\n            }\n        }\n        invlist_iterfinish(cp_list);\n\n        if (op == END) {\n            const UV cp_list_len = _invlist_len(cp_list);\n            const UV* cp_list_array = invlist_array(cp_list);\n\n            /* Here, didn't find an optimization.  See if this matches any of\n             * the POSIX classes.  These run slightly faster for above-Unicode\n             * code points, so don't bother with POSIXA ones nor the 2 that\n             * have no above-Unicode matches.  We can avoid these checks unless\n             * the ANYOF matches at least as high as the lowest POSIX one\n             * (which was manually found to be \\v.  The actual code point may\n             * increase in later Unicode releases, if a higher code point is\n             * assigned to be \\v, but this code will never break.  It would\n             * just mean we could execute the checks for posix optimizations\n             * unnecessarily) */\n\n            if (cp_list_array[cp_list_len-1] > 0x2029) {\n                for (posix_class = 0;\n                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;\n                     posix_class++)\n                {\n                    int try_inverted;\n                    if (posix_class == _CC_ASCII || posix_class == _CC_CNTRL) {\n                        continue;\n                    }\n                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {\n\n                        /* Check if matches normal or inverted */\n                        if (_invlistEQ(cp_list,\n                                       PL_XPosix_ptrs[posix_class],\n                                       try_inverted))\n                        {\n                            op = (try_inverted)\n                                 ? NPOSIXU\n                                 : POSIXU;\n                            *flagp |= HASWIDTH|SIMPLE;\n                            goto found_posix;\n                        }\n                    }\n                }\n              found_posix: ;\n            }\n        }\n\n        if (op != END) {\n            RExC_parse = (char *)orig_parse;\n            RExC_emit = (regnode *)orig_emit;\n\n            if (regarglen[op]) {\n                ret = reganode(pRExC_state, op, 0);\n            } else {\n                ret = reg_node(pRExC_state, op);\n            }\n\n            RExC_parse = (char *)cur_parse;\n\n            if (PL_regkind[op] == EXACT) {\n                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,\n                                           TRUE /* downgradable to EXACT */\n                                          );\n            }\n            else if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {\n                FLAGS(ret) = posix_class;\n            }\n\n            SvREFCNT_dec_NN(cp_list);\n            return ret;\n        }\n    }\n\n    /* Here, <cp_list> contains all the code points we can determine at\n     * compile time that match under all conditions.  Go through it, and\n     * for things that belong in the bitmap, put them there, and delete from\n     * <cp_list>.  While we are at it, see if everything above 255 is in the\n     * list, and if so, set a flag to speed up execution */\n\n    populate_ANYOF_from_invlist(ret, &cp_list);\n\n    if (invert) {\n        ANYOF_FLAGS(ret) |= ANYOF_INVERT;\n    }\n\n    /* Here, the bitmap has been populated with all the Latin1 code points that\n     * always match.  Can now add to the overall list those that match only\n     * when the target string is UTF-8 (<has_upper_latin1_only_utf8_matches>).\n     * */\n    if (has_upper_latin1_only_utf8_matches) {\n\tif (cp_list) {\n\t    _invlist_union(cp_list,\n                           has_upper_latin1_only_utf8_matches,\n                           &cp_list);\n\t    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);\n\t}\n\telse {\n\t    cp_list = has_upper_latin1_only_utf8_matches;\n\t}\n        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n    }\n\n    /* If there is a swash and more than one element, we can't use the swash in\n     * the optimization below. */\n    if (swash && element_count > 1) {\n\tSvREFCNT_dec_NN(swash);\n\tswash = NULL;\n    }\n\n    /* Note that the optimization of using 'swash' if it is the only thing in\n     * the class doesn't have us change swash at all, so it can include things\n     * that are also in the bitmap; otherwise we have purposely deleted that\n     * duplicate information */\n    set_ANYOF_arg(pRExC_state, ret, cp_list,\n                  (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)\n                   ? listsv : NULL,\n                  only_utf8_locale_list,\n                  swash, has_user_defined_property);\n\n    *flagp |= HASWIDTH|SIMPLE;\n\n    if (ANYOF_FLAGS(ret) & ANYOF_LOCALE_FLAGS) {\n        RExC_contains_locale = 1;\n    }\n\n    return ret;\n}\n\n#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION\n\nSTATIC void\nS_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state,\n                regnode* const node,\n                SV* const cp_list,\n                SV* const runtime_defns,\n                SV* const only_utf8_locale_list,\n                SV* const swash,\n                const bool has_user_defined_property)\n{\n    /* Sets the arg field of an ANYOF-type node 'node', using information about\n     * the node passed-in.  If there is nothing outside the node's bitmap, the\n     * arg is set to ANYOF_ONLY_HAS_BITMAP.  Otherwise, it sets the argument to\n     * the count returned by add_data(), having allocated and stored an array,\n     * av, that that count references, as follows:\n     *  av[0] stores the character class description in its textual form.\n     *        This is used later (regexec.c:Perl_regclass_swash()) to\n     *        initialize the appropriate swash, and is also useful for dumping\n     *        the regnode.  This is set to &PL_sv_undef if the textual\n     *        description is not needed at run-time (as happens if the other\n     *        elements completely define the class)\n     *  av[1] if &PL_sv_undef, is a placeholder to later contain the swash\n     *        computed from av[0].  But if no further computation need be done,\n     *        the swash is stored here now (and av[0] is &PL_sv_undef).\n     *  av[2] stores the inversion list of code points that match only if the\n     *        current locale is UTF-8\n     *  av[3] stores the cp_list inversion list for use in addition or instead\n     *        of av[0]; used only if cp_list exists and av[1] is &PL_sv_undef.\n     *        (Otherwise everything needed is already in av[0] and av[1])\n     *  av[4] is set if any component of the class is from a user-defined\n     *        property; used only if av[3] exists */\n\n    UV n;\n\n    PERL_ARGS_ASSERT_SET_ANYOF_ARG;\n\n    if (! cp_list && ! runtime_defns && ! only_utf8_locale_list) {\n        assert(! (ANYOF_FLAGS(node)\n                & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP));\n\tARG_SET(node, ANYOF_ONLY_HAS_BITMAP);\n    }\n    else {\n\tAV * const av = newAV();\n\tSV *rv;\n\n\tav_store(av, 0, (runtime_defns)\n\t\t\t? SvREFCNT_inc(runtime_defns) : &PL_sv_undef);\n\tif (swash) {\n\t    assert(cp_list);\n\t    av_store(av, 1, swash);\n\t    SvREFCNT_dec_NN(cp_list);\n\t}\n\telse {\n\t    av_store(av, 1, &PL_sv_undef);\n\t    if (cp_list) {\n\t\tav_store(av, 3, cp_list);\n\t\tav_store(av, 4, newSVuv(has_user_defined_property));\n\t    }\n\t}\n\n        if (only_utf8_locale_list) {\n\t    av_store(av, 2, only_utf8_locale_list);\n        }\n        else {\n\t    av_store(av, 2, &PL_sv_undef);\n        }\n\n\trv = newRV_noinc(MUTABLE_SV(av));\n\tn = add_data(pRExC_state, STR_WITH_LEN(\"s\"));\n\tRExC_rxi->data->data[n] = (void*)rv;\n\tARG_SET(node, n);\n    }\n}\n\n#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)\nSV *\nPerl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,\n                                        const regnode* node,\n                                        bool doinit,\n                                        SV** listsvp,\n                                        SV** only_utf8_locale_ptr,\n                                        SV** output_invlist)\n\n{\n    /* For internal core use only.\n     * Returns the swash for the input 'node' in the regex 'prog'.\n     * If <doinit> is 'true', will attempt to create the swash if not already\n     *\t  done.\n     * If <listsvp> is non-null, will return the printable contents of the\n     *    swash.  This can be used to get debugging information even before the\n     *    swash exists, by calling this function with 'doinit' set to false, in\n     *    which case the components that will be used to eventually create the\n     *    swash are returned  (in a printable form).\n     * If <only_utf8_locale_ptr> is not NULL, it is where this routine is to\n     *    store an inversion list of code points that should match only if the\n     *    execution-time locale is a UTF-8 one.\n     * If <output_invlist> is not NULL, it is where this routine is to store an\n     *    inversion list of the code points that would be instead returned in\n     *    <listsvp> if this were NULL.  Thus, what gets output in <listsvp>\n     *    when this parameter is used, is just the non-code point data that\n     *    will go into creating the swash.  This currently should be just\n     *    user-defined properties whose definitions were not known at compile\n     *    time.  Using this parameter allows for easier manipulation of the\n     *    swash's data by the caller.  It is illegal to call this function with\n     *    this parameter set, but not <listsvp>\n     *\n     * Tied intimately to how S_set_ANYOF_arg sets up the data structure.  Note\n     * that, in spite of this function's name, the swash it returns may include\n     * the bitmap data as well */\n\n    SV *sw  = NULL;\n    SV *si  = NULL;         /* Input swash initialization string */\n    SV* invlist = NULL;\n\n    RXi_GET_DECL(prog,progi);\n    const struct reg_data * const data = prog ? progi->data : NULL;\n\n    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;\n    assert(! output_invlist || listsvp);\n\n    if (data && data->count) {\n\tconst U32 n = ARG(node);\n\n\tif (data->what[n] == 's') {\n\t    SV * const rv = MUTABLE_SV(data->data[n]);\n\t    AV * const av = MUTABLE_AV(SvRV(rv));\n\t    SV **const ary = AvARRAY(av);\n\t    U8 swash_init_flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;\n\n\t    si = *ary;\t/* ary[0] = the string to initialize the swash with */\n\n            if (av_tindex_skip_len_mg(av) >= 2) {\n                if (only_utf8_locale_ptr\n                    && ary[2]\n                    && ary[2] != &PL_sv_undef)\n                {\n                    *only_utf8_locale_ptr = ary[2];\n                }\n                else {\n                    assert(only_utf8_locale_ptr);\n                    *only_utf8_locale_ptr = NULL;\n                }\n\n                /* Elements 3 and 4 are either both present or both absent. [3]\n                 * is any inversion list generated at compile time; [4]\n                 * indicates if that inversion list has any user-defined\n                 * properties in it. */\n                if (av_tindex_skip_len_mg(av) >= 3) {\n                    invlist = ary[3];\n                    if (SvUV(ary[4])) {\n                        swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;\n                    }\n                }\n                else {\n                    invlist = NULL;\n                }\n\t    }\n\n\t    /* Element [1] is reserved for the set-up swash.  If already there,\n\t     * return it; if not, create it and store it there */\n\t    if (ary[1] && SvROK(ary[1])) {\n\t\tsw = ary[1];\n\t    }\n\t    else if (doinit && ((si && si != &PL_sv_undef)\n                                 || (invlist && invlist != &PL_sv_undef))) {\n\t\tassert(si);\n\t\tsw = _core_swash_init(\"utf8\", /* the utf8 package */\n\t\t\t\t      \"\", /* nameless */\n\t\t\t\t      si,\n\t\t\t\t      1, /* binary */\n\t\t\t\t      0, /* not from tr/// */\n\t\t\t\t      invlist,\n\t\t\t\t      &swash_init_flags);\n\t\t(void)av_store(av, 1, sw);\n\t    }\n\t}\n    }\n\n    /* If requested, return a printable version of what this swash matches */\n    if (listsvp) {\n\tSV* matches_string = NULL;\n\n        /* The swash should be used, if possible, to get the data, as it\n         * contains the resolved data.  But this function can be called at\n         * compile-time, before everything gets resolved, in which case we\n         * return the currently best available information, which is the string\n         * that will eventually be used to do that resolving, 'si' */\n\tif ((! sw || (invlist = _get_swash_invlist(sw)) == NULL)\n            && (si && si != &PL_sv_undef))\n        {\n            /* Here, we only have 'si' (and possibly some passed-in data in\n             * 'invlist', which is handled below)  If the caller only wants\n             * 'si', use that.  */\n            if (! output_invlist) {\n                matches_string = newSVsv(si);\n            }\n            else {\n                /* But if the caller wants an inversion list of the node, we\n                 * need to parse 'si' and place as much as possible in the\n                 * desired output inversion list, making 'matches_string' only\n                 * contain the currently unresolvable things */\n                const char *si_string = SvPVX(si);\n                STRLEN remaining = SvCUR(si);\n                UV prev_cp = 0;\n                U8 count = 0;\n\n                /* Ignore everything before the first new-line */\n                while (*si_string != '\\n' && remaining > 0) {\n                    si_string++;\n                    remaining--;\n                }\n                assert(remaining > 0);\n\n                si_string++;\n                remaining--;\n\n                while (remaining > 0) {\n\n                    /* The data consists of just strings defining user-defined\n                     * property names, but in prior incarnations, and perhaps\n                     * somehow from pluggable regex engines, it could still\n                     * hold hex code point definitions.  Each component of a\n                     * range would be separated by a tab, and each range by a\n                     * new-line.  If these are found, instead add them to the\n                     * inversion list */\n                    I32 grok_flags =  PERL_SCAN_SILENT_ILLDIGIT\n                                     |PERL_SCAN_SILENT_NON_PORTABLE;\n                    STRLEN len = remaining;\n                    UV cp = grok_hex(si_string, &len, &grok_flags, NULL);\n\n                    /* If the hex decode routine found something, it should go\n                     * up to the next \\n */\n                    if (   *(si_string + len) == '\\n') {\n                        if (count) {    /* 2nd code point on line */\n                            *output_invlist = _add_range_to_invlist(*output_invlist, prev_cp, cp);\n                        }\n                        else {\n                            *output_invlist = add_cp_to_invlist(*output_invlist, cp);\n                        }\n                        count = 0;\n                        goto prepare_for_next_iteration;\n                    }\n\n                    /* If the hex decode was instead for the lower range limit,\n                     * save it, and go parse the upper range limit */\n                    if (*(si_string + len) == '\\t') {\n                        assert(count == 0);\n\n                        prev_cp = cp;\n                        count = 1;\n                      prepare_for_next_iteration:\n                        si_string += len + 1;\n                        remaining -= len + 1;\n                        continue;\n                    }\n\n                    /* Here, didn't find a legal hex number.  Just add it from\n                     * here to the next \\n */\n\n                    remaining -= len;\n                    while (*(si_string + len) != '\\n' && remaining > 0) {\n                        remaining--;\n                        len++;\n                    }\n                    if (*(si_string + len) == '\\n') {\n                        len++;\n                        remaining--;\n                    }\n                    if (matches_string) {\n                        sv_catpvn(matches_string, si_string, len - 1);\n                    }\n                    else {\n                        matches_string = newSVpvn(si_string, len - 1);\n                    }\n                    si_string += len;\n                    sv_catpvs(matches_string, \" \");\n                } /* end of loop through the text */\n\n                assert(matches_string);\n                if (SvCUR(matches_string)) {  /* Get rid of trailing blank */\n                    SvCUR_set(matches_string, SvCUR(matches_string) - 1);\n                }\n            } /* end of has an 'si' but no swash */\n\t}\n\n        /* If we have a swash in place, its equivalent inversion list was above\n         * placed into 'invlist'.  If not, this variable may contain a stored\n         * inversion list which is information beyond what is in 'si' */\n        if (invlist) {\n\n            /* Again, if the caller doesn't want the output inversion list, put\n             * everything in 'matches-string' */\n            if (! output_invlist) {\n                if ( ! matches_string) {\n                    matches_string = newSVpvs(\"\\n\");\n                }\n                sv_catsv(matches_string, invlist_contents(invlist,\n                                                  TRUE /* traditional style */\n                                                  ));\n            }\n            else if (! *output_invlist) {\n                *output_invlist = invlist_clone(invlist);\n            }\n            else {\n                _invlist_union(*output_invlist, invlist, output_invlist);\n            }\n        }\n\n\t*listsvp = matches_string;\n    }\n\n    return sw;\n}\n#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */\n\n/* reg_skipcomment()\n\n   Absorbs an /x style # comment from the input stream,\n   returning a pointer to the first character beyond the comment, or if the\n   comment terminates the pattern without anything following it, this returns\n   one past the final character of the pattern (in other words, RExC_end) and\n   sets the REG_RUN_ON_COMMENT_SEEN flag.\n\n   Note it's the callers responsibility to ensure that we are\n   actually in /x mode\n\n*/\n\nPERL_STATIC_INLINE char*\nS_reg_skipcomment(RExC_state_t *pRExC_state, char* p)\n{\n    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;\n\n    assert(*p == '#');\n\n    while (p < RExC_end) {\n        if (*(++p) == '\\n') {\n            return p+1;\n        }\n    }\n\n    /* we ran off the end of the pattern without ending the comment, so we have\n     * to add an \\n when wrapping */\n    RExC_seen |= REG_RUN_ON_COMMENT_SEEN;\n    return p;\n}\n\nSTATIC void\nS_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state,\n                                char ** p,\n                                const bool force_to_xmod\n                         )\n{\n    /* If the text at the current parse position '*p' is a '(?#...)' comment,\n     * or if we are under /x or 'force_to_xmod' is TRUE, and the text at '*p'\n     * is /x whitespace, advance '*p' so that on exit it points to the first\n     * byte past all such white space and comments */\n\n    const bool use_xmod = force_to_xmod || (RExC_flags & RXf_PMf_EXTENDED);\n\n    PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT;\n\n    assert( ! UTF || UTF8_IS_INVARIANT(**p) || UTF8_IS_START(**p));\n\n    for (;;) {\n\tif (RExC_end - (*p) >= 3\n\t    && *(*p)     == '('\n\t    && *(*p + 1) == '?'\n\t    && *(*p + 2) == '#')\n\t{\n\t    while (*(*p) != ')') {\n\t\tif ((*p) == RExC_end)\n\t\t    FAIL(\"Sequence (?#... not terminated\");\n\t\t(*p)++;\n\t    }\n\t    (*p)++;\n\t    continue;\n\t}\n\n\tif (use_xmod) {\n            const char * save_p = *p;\n            while ((*p) < RExC_end) {\n                STRLEN len;\n                if ((len = is_PATWS_safe((*p), RExC_end, UTF))) {\n                    (*p) += len;\n                }\n                else if (*(*p) == '#') {\n                    (*p) = reg_skipcomment(pRExC_state, (*p));\n                }\n                else {\n                    break;\n                }\n            }\n            if (*p != save_p) {\n                continue;\n            }\n\t}\n\n        break;\n    }\n\n    return;\n}\n\n/* nextchar()\n\n   Advances the parse position by one byte, unless that byte is the beginning\n   of a '(?#...)' style comment, or is /x whitespace and /x is in effect.  In\n   those two cases, the parse position is advanced beyond all such comments and\n   white space.\n\n   This is the UTF, (?#...), and /x friendly way of saying RExC_parse++.\n*/\n\nSTATIC void\nS_nextchar(pTHX_ RExC_state_t *pRExC_state)\n{\n    PERL_ARGS_ASSERT_NEXTCHAR;\n\n    if (RExC_parse < RExC_end) {\n        assert(   ! UTF\n               || UTF8_IS_INVARIANT(*RExC_parse)\n               || UTF8_IS_START(*RExC_parse));\n\n        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                FALSE /* Don't force /x */ );\n    }\n}\n\nSTATIC regnode *\nS_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_size, const char* const name)\n{\n    /* Allocate a regnode for 'op' and returns it, with 'extra_size' extra\n     * space.  In pass1, it aligns and increments RExC_size; in pass2,\n     * RExC_emit */\n\n    regnode * const ret = RExC_emit;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGNODE_GUTS;\n\n    assert(extra_size >= regarglen[op]);\n\n    if (SIZE_ONLY) {\n\tSIZE_ALIGN(RExC_size);\n\tRExC_size += 1 + extra_size;\n\treturn(ret);\n    }\n    if (RExC_emit >= RExC_emit_bound)\n        Perl_croak(aTHX_ \"panic: reg_node overrun trying to emit %d, %p>=%p\",\n\t\t   op, (void*)RExC_emit, (void*)RExC_emit_bound);\n\n    NODE_ALIGN_FILL(ret);\n#ifndef RE_TRACK_PATTERN_OFFSETS\n    PERL_UNUSED_ARG(name);\n#else\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s:%d: (op %s) %s %\" UVuf \" (len %\" UVuf \") (max %\" UVuf \").\\n\",\n              name, __LINE__,\n              PL_reg_name[op],\n              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0]\n\t\t? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)(RExC_emit - RExC_emit_start),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(RExC_emit, RExC_parse + (op == END));\n    }\n#endif\n    return(ret);\n}\n\n/*\n- reg_node - emit a node\n*/\nSTATIC regnode *\t\t\t/* Location. */\nS_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)\n{\n    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg_node\");\n\n    PERL_ARGS_ASSERT_REG_NODE;\n\n    assert(regarglen[op] == 0);\n\n    if (PASS2) {\n        regnode *ptr = ret;\n        FILL_ADVANCE_NODE(ptr, op);\n        RExC_emit = ptr;\n    }\n    return(ret);\n}\n\n/*\n- reganode - emit a node with an argument\n*/\nSTATIC regnode *\t\t\t/* Location. */\nS_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)\n{\n    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], \"reganode\");\n\n    PERL_ARGS_ASSERT_REGANODE;\n\n    assert(regarglen[op] == 1);\n\n    if (PASS2) {\n        regnode *ptr = ret;\n        FILL_ADVANCE_NODE_ARG(ptr, op, arg);\n        RExC_emit = ptr;\n    }\n    return(ret);\n}\n\nSTATIC regnode *\nS_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2)\n{\n    /* emit a node with U32 and I32 arguments */\n\n    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg2Lanode\");\n\n    PERL_ARGS_ASSERT_REG2LANODE;\n\n    assert(regarglen[op] == 2);\n\n    if (PASS2) {\n        regnode *ptr = ret;\n        FILL_ADVANCE_NODE_2L_ARG(ptr, op, arg1, arg2);\n        RExC_emit = ptr;\n    }\n    return(ret);\n}\n\n/*\n- reginsert - insert an operator in front of already-emitted operand\n*\n* Means relocating the operand.\n*\n* IMPORTANT NOTE - it is the *callers* responsibility to correctly\n* set up NEXT_OFF() of the inserted node if needed. Something like this:\n*\n* reginsert(pRExC, OPFAIL, orig_emit, depth+1);\n* if (PASS2)\n*     NEXT_OFF(orig_emit) = regarglen[OPFAIL] + NODE_STEP_REGNODE;\n*\n* ALSO NOTE - operand->flags will be set to 0 as well.\n*/\nSTATIC void\nS_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *operand, U32 depth)\n{\n    regnode *src;\n    regnode *dst;\n    regnode *place;\n    const int offset = regarglen[(U8)op];\n    const int size = NODE_STEP_REGNODE + offset;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGINSERT;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(depth);\n/* (PL_regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */\n    DEBUG_PARSE_FMT(\"inst\",\" - %s\",PL_reg_name[op]);\n    if (SIZE_ONLY) {\n\tRExC_size += size;\n\treturn;\n    }\n    assert(!RExC_study_started); /* I believe we should never use reginsert once we have started\n                                    studying. If this is wrong then we need to adjust RExC_recurse\n                                    below like we do with RExC_open_parens/RExC_close_parens. */\n    src = RExC_emit;\n    RExC_emit += size;\n    dst = RExC_emit;\n    if (RExC_open_parens) {\n        int paren;\n        /*DEBUG_PARSE_FMT(\"inst\",\" - %\" IVdf, (IV)RExC_npar);*/\n        /* remember that RExC_npar is rex->nparens + 1,\n         * iow it is 1 more than the number of parens seen in\n         * the pattern so far. */\n        for ( paren=0 ; paren < RExC_npar ; paren++ ) {\n            /* note, RExC_open_parens[0] is the start of the\n             * regex, it can't move. RExC_close_parens[0] is the end\n             * of the regex, it *can* move. */\n            if ( paren && RExC_open_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %d\",size);*/\n                RExC_open_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %s\",\"ok\");*/\n            }\n            if ( RExC_close_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %d\",size);*/\n                RExC_close_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %s\",\"ok\");*/\n            }\n        }\n    }\n    if (RExC_end_op)\n        RExC_end_op += size;\n\n    while (src > operand) {\n\tStructCopy(--src, --dst, regnode);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        if (RExC_offsets) {     /* MJD 20010112 */\n\t    MJD_OFFSET_DEBUG(\n                 (\"%s(%d): (op %s) %s copy %\" UVuf \" -> %\" UVuf \" (max %\" UVuf \").\\n\",\n                  \"reg_insert\",\n\t\t  __LINE__,\n\t\t  PL_reg_name[op],\n                  (UV)(dst - RExC_emit_start) > RExC_offsets[0]\n\t\t    ? \"Overwriting end of array!\\n\" : \"OK\",\n                  (UV)(src - RExC_emit_start),\n                  (UV)(dst - RExC_emit_start),\n                  (UV)RExC_offsets[0]));\n\t    Set_Node_Offset_To_R(dst-RExC_emit_start, Node_Offset(src));\n\t    Set_Node_Length_To_R(dst-RExC_emit_start, Node_Length(src));\n        }\n#endif\n    }\n\n    place = operand;\t\t/* Op node, where operand used to be. */\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s(%d): (op %s) %s %\" UVuf \" <- %\" UVuf \" (max %\" UVuf \").\\n\",\n              \"reginsert\",\n\t      __LINE__,\n\t      PL_reg_name[op],\n              (UV)(place - RExC_emit_start) > RExC_offsets[0]\n              ? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)(place - RExC_emit_start),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(place, RExC_parse);\n\tSet_Node_Length(place, 1);\n    }\n#endif\n    src = NEXTOPER(place);\n    place->flags = 0;\n    FILL_ADVANCE_NODE(place, op);\n    Zero(src, offset, regnode);\n}\n\n/*\n- regtail - set the next-pointer at the end of a node chain of p to val.\n- SEE ALSO: regtail_study\n*/\nSTATIC void\nS_regtail(pTHX_ RExC_state_t * pRExC_state,\n                const regnode * const p,\n                const regnode * const val,\n                const U32 depth)\n{\n    regnode *scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    if (SIZE_ONLY)\n\treturn;\n\n    /* Find last node. */\n    scan = (regnode *) p;\n    for (;;) {\n\tregnode * const temp = regnext(scan);\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tail\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) %s %s\\n\",\n                SvPV_nolen_const(RExC_mysv), REG_NODE_NUM(scan),\n                    (temp == NULL ? \"->\" : \"\"),\n                    (temp == NULL ? PL_reg_name[OP(val)] : \"\")\n            );\n        });\n        if (temp == NULL)\n            break;\n        scan = temp;\n    }\n\n    if (reg_off_by_arg[OP(scan)]) {\n        ARG_SET(scan, val - scan);\n    }\n    else {\n        NEXT_OFF(scan) = val - scan;\n    }\n}\n\n#ifdef DEBUGGING\n/*\n- regtail_study - set the next-pointer at the end of a node chain of p to val.\n- Look for optimizable sequences at the same time.\n- currently only looks for EXACT chains.\n\nThis is experimental code. The idea is to use this routine to perform\nin place optimizations on branches and groups as they are constructed,\nwith the long term intention of removing optimization from study_chunk so\nthat it is purely analytical.\n\nCurrently only used when in DEBUG mode. The macro REGTAIL_STUDY() is used\nto control which is which.\n\n*/\n/* TODO: All four parms should be const */\n\nSTATIC U8\nS_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p,\n                      const regnode *val,U32 depth)\n{\n    regnode *scan;\n    U8 exact = PSEUDO;\n#ifdef EXPERIMENTAL_INPLACESCAN\n    I32 min = 0;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL_STUDY;\n\n\n    if (SIZE_ONLY)\n        return exact;\n\n    /* Find last node. */\n\n    scan = p;\n    for (;;) {\n        regnode * const temp = regnext(scan);\n#ifdef EXPERIMENTAL_INPLACESCAN\n        if (PL_regkind[OP(scan)] == EXACT) {\n\t    bool unfolded_multi_char;\t/* Unexamined in this routine */\n            if (join_exact(pRExC_state, scan, &min,\n                           &unfolded_multi_char, 1, val, depth+1))\n                return EXACT;\n\t}\n#endif\n        if ( exact ) {\n            switch (OP(scan)) {\n                case EXACT:\n                case EXACTL:\n                case EXACTF:\n                case EXACTFA_NO_TRIE:\n                case EXACTFA:\n                case EXACTFU:\n                case EXACTFLU8:\n                case EXACTFU_SS:\n                case EXACTFL:\n                        if( exact == PSEUDO )\n                            exact= OP(scan);\n                        else if ( exact != OP(scan) )\n                            exact= 0;\n                case NOTHING:\n                    break;\n                default:\n                    exact= 0;\n            }\n        }\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tsdy\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) -> %s\\n\",\n                SvPV_nolen_const(RExC_mysv),\n                REG_NODE_NUM(scan),\n                PL_reg_name[exact]);\n        });\n\tif (temp == NULL)\n\t    break;\n\tscan = temp;\n    }\n    DEBUG_PARSE_r({\n        DEBUG_PARSE_MSG(\"\");\n        regprop(RExC_rx, RExC_mysv, val, NULL, pRExC_state);\n        Perl_re_printf( aTHX_\n                      \"~ attach to %s (%\" IVdf \") offset to %\" IVdf \"\\n\",\n\t\t      SvPV_nolen_const(RExC_mysv),\n\t\t      (IV)REG_NODE_NUM(val),\n\t\t      (IV)(val - scan)\n        );\n    });\n    if (reg_off_by_arg[OP(scan)]) {\n\tARG_SET(scan, val - scan);\n    }\n    else {\n\tNEXT_OFF(scan) = val - scan;\n    }\n\n    return exact;\n}\n#endif\n\n/*\n - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form\n */\n#ifdef DEBUGGING\n\nstatic void\nS_regdump_intflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n\n    ASSUME(REG_INTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_INTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\",lead);\n            Perl_re_printf( aTHX_  \"%s \",PL_reg_intflags_name[bit]);\n        }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\",lead);\n    }\n}\n\nstatic void\nS_regdump_extflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n    regex_charset cs;\n\n    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n\t    if ((1<<bit) & RXf_PMf_CHARSET) {\t/* Output separately, below */\n\t\tcontinue;\n\t    }\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\",lead);\n            Perl_re_printf( aTHX_  \"%s \",PL_reg_extflags_name[bit]);\n        }\n    }\n    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {\n            if (!set++ && lead) {\n                Perl_re_printf( aTHX_  \"%s\",lead);\n            }\n            switch (cs) {\n                case REGEX_UNICODE_CHARSET:\n                    Perl_re_printf( aTHX_  \"UNICODE\");\n                    break;\n                case REGEX_LOCALE_CHARSET:\n                    Perl_re_printf( aTHX_  \"LOCALE\");\n                    break;\n                case REGEX_ASCII_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-RESTRICTED\");\n                    break;\n                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-MORE_RESTRICTED\");\n                    break;\n                default:\n                    Perl_re_printf( aTHX_  \"UNKNOWN CHARACTER SET\");\n                    break;\n            }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\",lead);\n    }\n}\n#endif\n\nvoid\nPerl_regdump(pTHX_ const regexp *r)\n{\n#ifdef DEBUGGING\n    int i;\n    SV * const sv = sv_newmortal();\n    SV *dsv= sv_newmortal();\n    RXi_GET_DECL(r,ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGDUMP;\n\n    (void)dumpuntil(r, ri->program, ri->program + 1, NULL, NULL, sv, 0, 0);\n\n    /* Header fields of interest. */\n    for (i = 0; i < 2; i++) {\n        if (r->substrs->data[i].substr) {\n            RE_PV_QUOTED_DECL(s, 0, dsv,\n                            SvPVX_const(r->substrs->data[i].substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].substr),\n                            PL_dump_re_max_len);\n            Perl_re_printf( aTHX_\n                          \"%s %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n        else if (r->substrs->data[i].utf8_substr) {\n            RE_PV_QUOTED_DECL(s, 1, dsv,\n                            SvPVX_const(r->substrs->data[i].utf8_substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].utf8_substr),\n                            30);\n            Perl_re_printf( aTHX_\n                          \"%s utf8 %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].utf8_substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n    }\n\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_\n\t\t      (const char *)\n\t\t      (   r->check_substr == r->substrs->data[1].substr\n\t\t       && r->check_utf8   == r->substrs->data[1].utf8_substr\n\t\t       ? \"(checking floating\" : \"(checking anchored\"));\n    if (r->intflags & PREGf_NOSCAN)\n        Perl_re_printf( aTHX_  \" noscan\");\n    if (r->extflags & RXf_CHECK_ALL)\n        Perl_re_printf( aTHX_  \" isall\");\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_  \") \");\n\n    if (ri->regstclass) {\n        regprop(r, sv, ri->regstclass, NULL, NULL);\n        Perl_re_printf( aTHX_  \"stclass %s \", SvPVX_const(sv));\n    }\n    if (r->intflags & PREGf_ANCH) {\n        Perl_re_printf( aTHX_  \"anchored\");\n        if (r->intflags & PREGf_ANCH_MBOL)\n            Perl_re_printf( aTHX_  \"(MBOL)\");\n        if (r->intflags & PREGf_ANCH_SBOL)\n            Perl_re_printf( aTHX_  \"(SBOL)\");\n        if (r->intflags & PREGf_ANCH_GPOS)\n            Perl_re_printf( aTHX_  \"(GPOS)\");\n        Perl_re_printf( aTHX_ \" \");\n    }\n    if (r->intflags & PREGf_GPOS_SEEN)\n        Perl_re_printf( aTHX_  \"GPOS:%\" UVuf \" \", (UV)r->gofs);\n    if (r->intflags & PREGf_SKIP)\n        Perl_re_printf( aTHX_  \"plus \");\n    if (r->intflags & PREGf_IMPLICIT)\n        Perl_re_printf( aTHX_  \"implicit \");\n    Perl_re_printf( aTHX_  \"minlen %\" IVdf \" \", (IV)r->minlen);\n    if (r->extflags & RXf_EVAL_SEEN)\n        Perl_re_printf( aTHX_  \"with eval \");\n    Perl_re_printf( aTHX_  \"\\n\");\n    DEBUG_FLAGS_r({\n        regdump_extflags(\"r->extflags: \",r->extflags);\n        regdump_intflags(\"r->intflags: \",r->intflags);\n    });\n#else\n    PERL_ARGS_ASSERT_REGDUMP;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(r);\n#endif\t/* DEBUGGING */\n}\n\n/* Should be synchronized with ANYOF_ #defines in regcomp.h */\n#ifdef DEBUGGING\n\n#  if   _CC_WORDCHAR != 0 || _CC_DIGIT != 1        || _CC_ALPHA != 2    \\\n     || _CC_LOWER != 3    || _CC_UPPER != 4        || _CC_PUNCT != 5    \\\n     || _CC_PRINT != 6    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8    \\\n     || _CC_CASED != 9    || _CC_SPACE != 10       || _CC_BLANK != 11   \\\n     || _CC_XDIGIT != 12  || _CC_CNTRL != 13       || _CC_ASCII != 14   \\\n     || _CC_VERTSPACE != 15\n#   error Need to adjust order of anyofs[]\n#  endif\nstatic const char * const anyofs[] = {\n    \"\\\\w\",\n    \"\\\\W\",\n    \"\\\\d\",\n    \"\\\\D\",\n    \"[:alpha:]\",\n    \"[:^alpha:]\",\n    \"[:lower:]\",\n    \"[:^lower:]\",\n    \"[:upper:]\",\n    \"[:^upper:]\",\n    \"[:punct:]\",\n    \"[:^punct:]\",\n    \"[:print:]\",\n    \"[:^print:]\",\n    \"[:alnum:]\",\n    \"[:^alnum:]\",\n    \"[:graph:]\",\n    \"[:^graph:]\",\n    \"[:cased:]\",\n    \"[:^cased:]\",\n    \"\\\\s\",\n    \"\\\\S\",\n    \"[:blank:]\",\n    \"[:^blank:]\",\n    \"[:xdigit:]\",\n    \"[:^xdigit:]\",\n    \"[:cntrl:]\",\n    \"[:^cntrl:]\",\n    \"[:ascii:]\",\n    \"[:^ascii:]\",\n    \"\\\\v\",\n    \"\\\\V\"\n};\n#endif\n\n/*\n- regprop - printable representation of opcode, with run time support\n*/\n\nvoid\nPerl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state)\n{\n#ifdef DEBUGGING\n    int k;\n    RXi_GET_DECL(prog,progi);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPROP;\n\n    SvPVCLEAR(sv);\n\n    if (OP(o) > REGNODE_MAX)\t\t/* regnode.type is unsigned */\n\t/* It would be nice to FAIL() here, but this may be called from\n\t   regexec.c, and it would be hard to supply pRExC_state. */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                              (int)OP(o), (int)REGNODE_MAX);\n    sv_catpv(sv, PL_reg_name[OP(o)]); /* Take off const! */\n\n    k = PL_regkind[OP(o)];\n\n    if (k == EXACT) {\n\tsv_catpvs(sv, \" \");\n\t/* Using is_utf8_string() (via PERL_PV_UNI_DETECT)\n\t * is a crude hack but it may be the best for now since\n\t * we have no flag \"this EXACTish node was UTF-8\"\n\t * --jhi */\n\tpv_pretty(sv, STRING(o), STR_LEN(o), PL_dump_re_max_len,\n                  PL_colors[0], PL_colors[1],\n\t\t  PERL_PV_ESCAPE_UNI_DETECT |\n\t\t  PERL_PV_ESCAPE_NONASCII   |\n\t\t  PERL_PV_PRETTY_ELLIPSES   |\n\t\t  PERL_PV_PRETTY_LTGT       |\n\t\t  PERL_PV_PRETTY_NOCLEAR\n\t\t  );\n    } else if (k == TRIE) {\n\t/* print the details of the trie in dumpuntil instead, as\n\t * progi->data isn't available here */\n        const char op = OP(o);\n        const U32 n = ARG(o);\n        const reg_ac_data * const ac = IS_TRIE_AC(op) ?\n               (reg_ac_data *)progi->data->data[n] :\n               NULL;\n        const reg_trie_data * const trie\n\t    = (reg_trie_data*)progi->data->data[!IS_TRIE_AC(op) ? n : ac->trie];\n\n        Perl_sv_catpvf(aTHX_ sv, \"-%s\",PL_reg_name[o->flags]);\n        DEBUG_TRIE_COMPILE_r({\n          if (trie->jump)\n            sv_catpvs(sv, \"(JUMP)\");\n          Perl_sv_catpvf(aTHX_ sv,\n            \"<S:%\" UVuf \"/%\" IVdf \" W:%\" UVuf \" L:%\" UVuf \"/%\" UVuf \" C:%\" UVuf \"/%\" UVuf \">\",\n            (UV)trie->startstate,\n            (IV)trie->statecount-1, /* -1 because of the unused 0 element */\n            (UV)trie->wordcount,\n            (UV)trie->minlen,\n            (UV)trie->maxlen,\n            (UV)TRIE_CHARCOUNT(trie),\n            (UV)trie->uniquecharcount\n          );\n        });\n        if ( IS_ANYOF_TRIE(op) || trie->bitmap ) {\n            sv_catpvs(sv, \"[\");\n            (void) put_charclass_bitmap_innards(sv,\n                                                ((IS_ANYOF_TRIE(op))\n                                                 ? ANYOF_BITMAP(o)\n                                                 : TRIE_BITMAP(trie)),\n                                                NULL,\n                                                NULL,\n                                                NULL,\n                                                FALSE\n                                               );\n            sv_catpvs(sv, \"]\");\n        }\n    } else if (k == CURLY) {\n        U32 lo = ARG1(o), hi = ARG2(o);\n\tif (OP(o) == CURLYM || OP(o) == CURLYN || OP(o) == CURLYX)\n\t    Perl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags); /* Parenth number */\n        Perl_sv_catpvf(aTHX_ sv, \"{%u,\", (unsigned) lo);\n        if (hi == REG_INFTY)\n            sv_catpvs(sv, \"INFTY\");\n        else\n            Perl_sv_catpvf(aTHX_ sv, \"%u\", (unsigned) hi);\n        sv_catpvs(sv, \"}\");\n    }\n    else if (k == WHILEM && o->flags)\t\t\t/* Ordinal/of */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d/%d]\", o->flags & 0xf, o->flags>>4);\n    else if (k == REF || k == OPEN || k == CLOSE\n             || k == GROUPP || OP(o)==ACCEPT)\n    {\n        AV *name_list= NULL;\n        U32 parno= OP(o) == ACCEPT ? (U32)ARG2L(o) : ARG(o);\n        Perl_sv_catpvf(aTHX_ sv, \"%\" UVuf, (UV)parno);        /* Parenth number */\n\tif ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n        if (name_list) {\n            if ( k != REF || (OP(o) < NREF)) {\n                SV **name= av_fetch(name_list, parno, 0 );\n\t        if (name)\n\t            Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n            }\n            else {\n                SV *sv_dat= MUTABLE_SV(progi->data->data[ parno ]);\n                I32 *nums=(I32*)SvPVX(sv_dat);\n                SV **name= av_fetch(name_list, nums[0], 0 );\n                I32 n;\n                if (name) {\n                    for ( n=0; n<SvIVX(sv_dat); n++ ) {\n                        Perl_sv_catpvf(aTHX_ sv, \"%s%\" IVdf,\n\t\t\t   \t    (n ? \",\" : \"\"), (IV)nums[n]);\n                    }\n                    Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n                }\n            }\n        }\n        if ( k == REF && reginfo) {\n            U32 n = ARG(o);  /* which paren pair */\n            I32 ln = prog->offs[n].start;\n            if (prog->lastparen < n || ln == -1)\n                Perl_sv_catpvf(aTHX_ sv, \": FAIL\");\n            else if (ln == prog->offs[n].end)\n                Perl_sv_catpvf(aTHX_ sv, \": ACCEPT - EMPTY STRING\");\n            else {\n                const char *s = reginfo->strbeg + ln;\n                Perl_sv_catpvf(aTHX_ sv, \": \");\n                Perl_pv_pretty( aTHX_ sv, s, prog->offs[n].end - prog->offs[n].start, 32, 0, 0,\n                    PERL_PV_ESCAPE_UNI_DETECT|PERL_PV_PRETTY_NOCLEAR|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE );\n            }\n        }\n    } else if (k == GOSUB) {\n        AV *name_list= NULL;\n        if ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n\n        /* Paren and offset */\n        Perl_sv_catpvf(aTHX_ sv, \"%d[%+d:%d]\", (int)ARG(o),(int)ARG2L(o),\n                (int)((o + (int)ARG2L(o)) - progi->program) );\n        if (name_list) {\n            SV **name= av_fetch(name_list, ARG(o), 0 );\n            if (name)\n                Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n        }\n    }\n    else if (k == LOGICAL)\n        /* 2: embedded, otherwise 1 */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags);\n    else if (k == ANYOF) {\n\tconst U8 flags = ANYOF_FLAGS(o);\n        bool do_sep = FALSE;    /* Do we need to separate various components of\n                                   the output? */\n        /* Set if there is still an unresolved user-defined property */\n        SV *unresolved                = NULL;\n\n        /* Things that are ignored except when the runtime locale is UTF-8 */\n        SV *only_utf8_locale_invlist = NULL;\n\n        /* Code points that don't fit in the bitmap */\n        SV *nonbitmap_invlist = NULL;\n\n        /* And things that aren't in the bitmap, but are small enough to be */\n        SV* bitmap_range_not_in_bitmap = NULL;\n\n        const bool inverted = flags & ANYOF_INVERT;\n\n\tif (OP(o) == ANYOFL) {\n            if (ANYOFL_UTF8_LOCALE_REQD(flags)) {\n                sv_catpvs(sv, \"{utf8-locale-reqd}\");\n            }\n            if (flags & ANYOFL_FOLD) {\n                sv_catpvs(sv, \"{i}\");\n            }\n        }\n\n        /* If there is stuff outside the bitmap, get it */\n        if (ARG(o) != ANYOF_ONLY_HAS_BITMAP) {\n            (void) _get_regclass_nonbitmap_data(prog, o, FALSE,\n                                                &unresolved,\n                                                &only_utf8_locale_invlist,\n                                                &nonbitmap_invlist);\n            /* The non-bitmap data may contain stuff that could fit in the\n             * bitmap.  This could come from a user-defined property being\n             * finally resolved when this call was done; or much more likely\n             * because there are matches that require UTF-8 to be valid, and so\n             * aren't in the bitmap.  This is teased apart later */\n            _invlist_intersection(nonbitmap_invlist,\n                                  PL_InBitmap,\n                                  &bitmap_range_not_in_bitmap);\n            /* Leave just the things that don't fit into the bitmap */\n            _invlist_subtract(nonbitmap_invlist,\n                              PL_InBitmap,\n                              &nonbitmap_invlist);\n        }\n\n        /* Obey this flag to add all above-the-bitmap code points */\n        if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n            nonbitmap_invlist = _add_range_to_invlist(nonbitmap_invlist,\n                                                      NUM_ANYOF_CODE_POINTS,\n                                                      UV_MAX);\n        }\n\n        /* Ready to start outputting.  First, the initial left bracket */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%s\", PL_colors[0]);\n\n        /* Then all the things that could fit in the bitmap */\n        do_sep = put_charclass_bitmap_innards(sv,\n                                              ANYOF_BITMAP(o),\n                                              bitmap_range_not_in_bitmap,\n                                              only_utf8_locale_invlist,\n                                              o,\n\n                                              /* Can't try inverting for a\n                                               * better display if there are\n                                               * things that haven't been\n                                               * resolved */\n                                              unresolved != NULL);\n        SvREFCNT_dec(bitmap_range_not_in_bitmap);\n\n        /* If there are user-defined properties which haven't been defined yet,\n         * output them.  If the result is not to be inverted, it is clearest to\n         * output them in a separate [] from the bitmap range stuff.  If the\n         * result is to be complemented, we have to show everything in one [],\n         * as the inversion applies to the whole thing.  Use {braces} to\n         * separate them from anything in the bitmap and anything above the\n         * bitmap. */\n        if (unresolved) {\n            if (inverted) {\n                if (! do_sep) { /* If didn't output anything in the bitmap */\n                    sv_catpvs(sv, \"^\");\n                }\n                sv_catpvs(sv, \"{\");\n            }\n            else if (do_sep) {\n                Perl_sv_catpvf(aTHX_ sv,\"%s][%s\",PL_colors[1],PL_colors[0]);\n            }\n            sv_catsv(sv, unresolved);\n            if (inverted) {\n                sv_catpvs(sv, \"}\");\n            }\n            do_sep = ! inverted;\n        }\n\n        /* And, finally, add the above-the-bitmap stuff */\n        if (nonbitmap_invlist && _invlist_len(nonbitmap_invlist)) {\n            SV* contents;\n\n            /* See if truncation size is overridden */\n            const STRLEN dump_len = (PL_dump_re_max_len > 256)\n                                    ? PL_dump_re_max_len\n                                    : 256;\n\n            /* This is output in a separate [] */\n            if (do_sep) {\n                Perl_sv_catpvf(aTHX_ sv,\"%s][%s\",PL_colors[1],PL_colors[0]);\n            }\n\n            /* And, for easy of understanding, it is shown in the\n             * uncomplemented form if possible.  The one exception being if\n             * there are unresolved items, where the inversion has to be\n             * delayed until runtime */\n            if (inverted && ! unresolved) {\n                _invlist_invert(nonbitmap_invlist);\n                _invlist_subtract(nonbitmap_invlist, PL_InBitmap, &nonbitmap_invlist);\n            }\n\n            contents = invlist_contents(nonbitmap_invlist,\n                                        FALSE /* output suitable for catsv */\n                                       );\n\n            /* If the output is shorter than the permissible maximum, just do it. */\n            if (SvCUR(contents) <= dump_len) {\n                sv_catsv(sv, contents);\n            }\n            else {\n                const char * contents_string = SvPVX(contents);\n                STRLEN i = dump_len;\n\n                /* Otherwise, start at the permissible max and work back to the\n                 * first break possibility */\n                while (i > 0 && contents_string[i] != ' ') {\n                    i--;\n                }\n                if (i == 0) {       /* Fail-safe.  Use the max if we couldn't\n                                       find a legal break */\n                    i = dump_len;\n                }\n\n                sv_catpvn(sv, contents_string, i);\n                sv_catpvs(sv, \"...\");\n            }\n\n            SvREFCNT_dec_NN(contents);\n            SvREFCNT_dec_NN(nonbitmap_invlist);\n        }\n\n        /* And finally the matching, closing ']' */\n\tPerl_sv_catpvf(aTHX_ sv, \"%s]\", PL_colors[1]);\n\n        SvREFCNT_dec(unresolved);\n    }\n    else if (k == POSIXD || k == NPOSIXD) {\n        U8 index = FLAGS(o) * 2;\n        if (index < C_ARRAY_LENGTH(anyofs)) {\n            if (*anyofs[index] != '[')  {\n                sv_catpv(sv, \"[\");\n            }\n            sv_catpv(sv, anyofs[index]);\n            if (*anyofs[index] != '[')  {\n                sv_catpv(sv, \"]\");\n            }\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ sv, \"[illegal type=%d])\", index);\n        }\n    }\n    else if (k == BOUND || k == NBOUND) {\n        /* Must be synced with order of 'bound_type' in regcomp.h */\n        const char * const bounds[] = {\n            \"\",      /* Traditional */\n            \"{gcb}\",\n            \"{lb}\",\n            \"{sb}\",\n            \"{wb}\"\n        };\n        assert(FLAGS(o) < C_ARRAY_LENGTH(bounds));\n        sv_catpv(sv, bounds[FLAGS(o)]);\n    }\n    else if (k == BRANCHJ && (OP(o) == UNLESSM || OP(o) == IFMATCH))\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d]\", -(o->flags));\n    else if (OP(o) == SBOL)\n        Perl_sv_catpvf(aTHX_ sv, \" /%s/\", o->flags ? \"\\\\A\" : \"^\");\n\n    /* add on the verb argument if there is one */\n    if ( ( k == VERB || OP(o) == ACCEPT || OP(o) == OPFAIL ) && o->flags) {\n        if ( ARG(o) )\n            Perl_sv_catpvf(aTHX_ sv, \":%\" SVf,\n                       SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));\n        else\n            sv_catpvs(sv, \":NULL\");\n    }\n#else\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n    PERL_UNUSED_ARG(o);\n    PERL_UNUSED_ARG(prog);\n    PERL_UNUSED_ARG(reginfo);\n    PERL_UNUSED_ARG(pRExC_state);\n#endif\t/* DEBUGGING */\n}\n\n\n\nSV *\nPerl_re_intuit_string(pTHX_ REGEXP * const r)\n{\t\t\t\t/* Assume that RE_INTUIT is set */\n    struct regexp *const prog = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_INTUIT_STRING;\n    PERL_UNUSED_CONTEXT;\n\n    DEBUG_COMPILE_r(\n\t{\n\t    const char * const s = SvPV_nolen_const(RX_UTF8(r)\n\t\t      ? prog->check_utf8 : prog->check_substr);\n\n\t    if (!PL_colorset) reginitcolors();\n            Perl_re_printf( aTHX_\n\t\t      \"%sUsing REx %ssubstr:%s \\\"%s%.60s%s%s\\\"\\n\",\n\t\t      PL_colors[4],\n\t\t      RX_UTF8(r) ? \"utf8 \" : \"\",\n\t\t      PL_colors[5],PL_colors[0],\n\t\t      s,\n\t\t      PL_colors[1],\n\t\t      (strlen(s) > PL_dump_re_max_len ? \"...\" : \"\"));\n\t} );\n\n    /* use UTF8 check substring if regexp pattern itself is in UTF8 */\n    return RX_UTF8(r) ? prog->check_utf8 : prog->check_substr;\n}\n\n/*\n   pregfree()\n\n   handles refcounting and freeing the perl core regexp structure. When\n   it is necessary to actually free the structure the first thing it\n   does is call the 'free' method of the regexp_engine associated to\n   the regexp, allowing the handling of the void *pprivate; member\n   first. (This routine is not overridable by extensions, which is why\n   the extensions free is called first.)\n\n   See regdupe and regdupe_internal if you change anything here.\n*/\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_pregfree(pTHX_ REGEXP *r)\n{\n    SvREFCNT_dec(r);\n}\n\nvoid\nPerl_pregfree2(pTHX_ REGEXP *rx)\n{\n    struct regexp *const r = ReANY(rx);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGFREE2;\n\n    if (r->mother_re) {\n        ReREFCNT_dec(r->mother_re);\n    } else {\n        CALLREGFREE_PVT(rx); /* free the private data */\n        SvREFCNT_dec(RXp_PAREN_NAMES(r));\n    }\n    if (r->substrs) {\n        int i;\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_dec(r->substrs->data[i].substr);\n            SvREFCNT_dec(r->substrs->data[i].utf8_substr);\n        }\n\tSafefree(r->substrs);\n    }\n    RX_MATCH_COPY_FREE(rx);\n#ifdef PERL_ANY_COW\n    SvREFCNT_dec(r->saved_copy);\n#endif\n    Safefree(r->offs);\n    SvREFCNT_dec(r->qr_anoncv);\n    if (r->recurse_locinput)\n        Safefree(r->recurse_locinput);\n}\n\n\n/*  reg_temp_copy()\n\n    Copy ssv to dsv, both of which should of type SVt_REGEXP or SVt_PVLV,\n    except that dsv will be created if NULL.\n\n    This function is used in two main ways. First to implement\n        $r = qr/....; $s = $$r;\n\n    Secondly, it is used as a hacky workaround to the structural issue of\n    match results\n    being stored in the regexp structure which is in turn stored in\n    PL_curpm/PL_reg_curpm. The problem is that due to qr// the pattern\n    could be PL_curpm in multiple contexts, and could require multiple\n    result sets being associated with the pattern simultaneously, such\n    as when doing a recursive match with (??{$qr})\n\n    The solution is to make a lightweight copy of the regexp structure\n    when a qr// is returned from the code executed by (??{$qr}) this\n    lightweight copy doesn't actually own any of its data except for\n    the starp/end and the actual regexp structure itself.\n\n*/\n\n\nREGEXP *\nPerl_reg_temp_copy(pTHX_ REGEXP *dsv, REGEXP *ssv)\n{\n    struct regexp *drx;\n    struct regexp *const srx = ReANY(ssv);\n    const bool islv = dsv && SvTYPE(dsv) == SVt_PVLV;\n\n    PERL_ARGS_ASSERT_REG_TEMP_COPY;\n\n    if (!dsv)\n\tdsv = (REGEXP*) newSV_type(SVt_REGEXP);\n    else {\n\tSvOK_off((SV *)dsv);\n\tif (islv) {\n\t    /* For PVLVs, the head (sv_any) points to an XPVLV, while\n             * the LV's xpvlenu_rx will point to a regexp body, which\n             * we allocate here */\n\t    REGEXP *temp = (REGEXP *)newSV_type(SVt_REGEXP);\n\t    assert(!SvPVX(dsv));\n            ((XPV*)SvANY(dsv))->xpv_len_u.xpvlenu_rx = temp->sv_any;\n\t    temp->sv_any = NULL;\n\t    SvFLAGS(temp) = (SvFLAGS(temp) & ~SVTYPEMASK) | SVt_NULL;\n\t    SvREFCNT_dec_NN(temp);\n\t    /* SvCUR still resides in the xpvlv struct, so the regexp copy-\n\t       ing below will not set it. */\n\t    SvCUR_set(dsv, SvCUR(ssv));\n\t}\n    }\n    /* This ensures that SvTHINKFIRST(sv) is true, and hence that\n       sv_force_normal(sv) is called.  */\n    SvFAKE_on(dsv);\n    drx = ReANY(dsv);\n\n    SvFLAGS(dsv) |= SvFLAGS(ssv) & (SVf_POK|SVp_POK|SVf_UTF8);\n    SvPV_set(dsv, RX_WRAPPED(ssv));\n    /* We share the same string buffer as the original regexp, on which we\n       hold a reference count, incremented when mother_re is set below.\n       The string pointer is copied here, being part of the regexp struct.\n     */\n    memcpy(&(drx->xpv_cur), &(srx->xpv_cur),\n\t   sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur));\n    if (!islv)\n        SvLEN_set(dsv, 0);\n    if (srx->offs) {\n        const I32 npar = srx->nparens+1;\n        Newx(drx->offs, npar, regexp_paren_pair);\n        Copy(srx->offs, drx->offs, npar, regexp_paren_pair);\n    }\n    if (srx->substrs) {\n        int i;\n        Newx(drx->substrs, 1, struct reg_substr_data);\n\tStructCopy(srx->substrs, drx->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_inc_void(drx->substrs->data[i].substr);\n            SvREFCNT_inc_void(drx->substrs->data[i].utf8_substr);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n    }\n    RX_MATCH_COPIED_off(dsv);\n#ifdef PERL_ANY_COW\n    drx->saved_copy = NULL;\n#endif\n    drx->mother_re = ReREFCNT_inc(srx->mother_re ? srx->mother_re : ssv);\n    SvREFCNT_inc_void(drx->qr_anoncv);\n    if (srx->recurse_locinput)\n        Newx(drx->recurse_locinput,srx->nparens + 1,char *);\n\n    return dsv;\n}\n#endif\n\n\n/* regfree_internal()\n\n   Free the private data in a regexp. This is overloadable by\n   extensions. Perl takes care of the regexp structure in pregfree(),\n   this covers the *pprivate pointer which technically perl doesn't\n   know about, however of course we have to handle the\n   regexp_internal structure when no extension is in use.\n\n   Note this is called before freeing anything in the regexp\n   structure.\n */\n\nvoid\nPerl_regfree_internal(pTHX_ REGEXP * const rx)\n{\n    struct regexp *const r = ReANY(rx);\n    RXi_GET_DECL(r,ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGFREE_INTERNAL;\n\n    DEBUG_COMPILE_r({\n\tif (!PL_colorset)\n\t    reginitcolors();\n\t{\n\t    SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RX_UTF8(rx),\n                dsv, RX_PRECOMP(rx), RX_PRELEN(rx), PL_dump_re_max_len);\n            Perl_re_printf( aTHX_ \"%sFreeing REx:%s %s\\n\",\n                PL_colors[4],PL_colors[5],s);\n        }\n    });\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets)\n        Safefree(ri->u.offsets);             /* 20010421 MJD */\n#endif\n    if (ri->code_blocks)\n        S_free_codeblocks(aTHX_ ri->code_blocks);\n\n    if (ri->data) {\n\tint n = ri->data->count;\n\n\twhile (--n >= 0) {\n          /* If you add a ->what type here, update the comment in regcomp.h */\n\t    switch (ri->data->what[n]) {\n\t    case 'a':\n\t    case 'r':\n\t    case 's':\n\t    case 'S':\n\t    case 'u':\n\t\tSvREFCNT_dec(MUTABLE_SV(ri->data->data[n]));\n\t\tbreak;\n\t    case 'f':\n\t\tSafefree(ri->data->data[n]);\n\t\tbreak;\n\t    case 'l':\n\t    case 'L':\n\t        break;\n            case 'T':\n                { /* Aho Corasick add-on structure for a trie node.\n                     Used in stclass optimization only */\n                    U32 refcount;\n                    reg_ac_data *aho=(reg_ac_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --aho->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(aho->states);\n                        PerlMemShared_free(aho->fail);\n\t\t\t /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n                        /* we should only ever get called once, so\n                         * assert as much, and also guard the free\n                         * which /might/ happen twice. At the least\n                         * it will make code anlyzers happy and it\n                         * doesn't cost much. - Yves */\n                        assert(ri->regstclass);\n                        if (ri->regstclass) {\n                            PerlMemShared_free(ri->regstclass);\n                            ri->regstclass = 0;\n                        }\n                    }\n                }\n                break;\n\t    case 't':\n\t        {\n\t            /* trie structure. */\n\t            U32 refcount;\n\t            reg_trie_data *trie=(reg_trie_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --trie->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(trie->charmap);\n                        PerlMemShared_free(trie->states);\n                        PerlMemShared_free(trie->trans);\n                        if (trie->bitmap)\n                            PerlMemShared_free(trie->bitmap);\n                        if (trie->jump)\n                            PerlMemShared_free(trie->jump);\n\t\t\tPerlMemShared_free(trie->wordinfo);\n                        /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tPerl_croak(aTHX_ \"panic: regfree data code '%c'\",\n                                                    ri->data->what[n]);\n\t    }\n\t}\n\tSafefree(ri->data->what);\n\tSafefree(ri->data);\n    }\n\n    Safefree(ri);\n}\n\n#define av_dup_inc(s,t)\tMUTABLE_AV(sv_dup_inc((const SV *)s,t))\n#define hv_dup_inc(s,t)\tMUTABLE_HV(sv_dup_inc((const SV *)s,t))\n#define SAVEPVN(p,n)\t((p) ? savepvn(p,n) : NULL)\n\n/*\n   re_dup_guts - duplicate a regexp.\n\n   This routine is expected to clone a given regexp structure. It is only\n   compiled under USE_ITHREADS.\n\n   After all of the core data stored in struct regexp is duplicated\n   the regexp_engine.dupe method is used to copy any private data\n   stored in the *pprivate pointer. This allows extensions to handle\n   any duplication it needs to do.\n\n   See pregfree() and regfree_internal() if you change anything here.\n*/\n#if defined(USE_ITHREADS)\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS *param)\n{\n    dVAR;\n    I32 npar;\n    const struct regexp *r = ReANY(sstr);\n    struct regexp *ret = ReANY(dstr);\n\n    PERL_ARGS_ASSERT_RE_DUP_GUTS;\n\n    npar = r->nparens+1;\n    Newx(ret->offs, npar, regexp_paren_pair);\n    Copy(r->offs, ret->offs, npar, regexp_paren_pair);\n\n    if (ret->substrs) {\n\t/* Do it this way to avoid reading from *r after the StructCopy().\n\t   That way, if any of the sv_dup_inc()s dislodge *r from the L1\n\t   cache, it doesn't matter.  */\n        int i;\n\tconst bool anchored = r->check_substr\n\t    ? r->check_substr == r->substrs->data[0].substr\n\t    : r->check_utf8   == r->substrs->data[0].utf8_substr;\n        Newx(ret->substrs, 1, struct reg_substr_data);\n\tStructCopy(r->substrs, ret->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            ret->substrs->data[i].substr =\n                        sv_dup_inc(ret->substrs->data[i].substr, param);\n            ret->substrs->data[i].utf8_substr =\n                        sv_dup_inc(ret->substrs->data[i].utf8_substr, param);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n\n\tif (ret->check_substr) {\n\t    if (anchored) {\n\t\tassert(r->check_utf8 == r->substrs->data[0].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[0].substr;\n\t\tret->check_utf8   = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tassert(r->check_substr == r->substrs->data[1].substr);\n\t\tassert(r->check_utf8   == r->substrs->data[1].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[1].substr;\n\t\tret->check_utf8   = ret->substrs->data[1].utf8_substr;\n\t    }\n\t} else if (ret->check_utf8) {\n\t    if (anchored) {\n\t\tret->check_utf8 = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tret->check_utf8 = ret->substrs->data[1].utf8_substr;\n\t    }\n\t}\n    }\n\n    RXp_PAREN_NAMES(ret) = hv_dup_inc(RXp_PAREN_NAMES(ret), param);\n    ret->qr_anoncv = MUTABLE_CV(sv_dup_inc((const SV *)ret->qr_anoncv, param));\n    if (r->recurse_locinput)\n        Newx(ret->recurse_locinput,r->nparens + 1,char *);\n\n    if (ret->pprivate)\n\tRXi_SET(ret,CALLREGDUPE_PVT(dstr,param));\n\n    if (RX_MATCH_COPIED(dstr))\n\tret->subbeg  = SAVEPVN(ret->subbeg, ret->sublen);\n    else\n\tret->subbeg = NULL;\n#ifdef PERL_ANY_COW\n    ret->saved_copy = NULL;\n#endif\n\n    /* Whether mother_re be set or no, we need to copy the string.  We\n       cannot refrain from copying it when the storage points directly to\n       our mother regexp, because that's\n\t       1: a buffer in a different thread\n\t       2: something we no longer hold a reference on\n\t       so we need to copy it locally.  */\n    RX_WRAPPED(dstr) = SAVEPVN(RX_WRAPPED_const(sstr), SvCUR(sstr)+1);\n    ret->mother_re   = NULL;\n}\n#endif /* PERL_IN_XSUB_RE */\n\n/*\n   regdupe_internal()\n\n   This is the internal complement to regdupe() which is used to copy\n   the structure pointed to by the *pprivate pointer in the regexp.\n   This is the core version of the extension overridable cloning hook.\n   The regexp structure being duplicated will be copied by perl prior\n   to this and will be provided as the regexp *r argument, however\n   with the /old/ structures pprivate pointer value. Thus this routine\n   may override any copying normally done by perl.\n\n   It returns a pointer to the new regexp_internal structure.\n*/\n\nvoid *\nPerl_regdupe_internal(pTHX_ REGEXP * const rx, CLONE_PARAMS *param)\n{\n    dVAR;\n    struct regexp *const r = ReANY(rx);\n    regexp_internal *reti;\n    int len;\n    RXi_GET_DECL(r,ri);\n\n    PERL_ARGS_ASSERT_REGDUPE_INTERNAL;\n\n    len = ProgLen(ri);\n\n    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode),\n          char, regexp_internal);\n    Copy(ri->program, reti->program, len+1, regnode);\n\n\n    if (ri->code_blocks) {\n\tint n;\n\tNewx(reti->code_blocks, 1, struct reg_code_blocks);\n\tNewx(reti->code_blocks->cb, ri->code_blocks->count,\n                    struct reg_code_block);\n\tCopy(ri->code_blocks->cb, reti->code_blocks->cb,\n             ri->code_blocks->count, struct reg_code_block);\n\tfor (n = 0; n < ri->code_blocks->count; n++)\n\t     reti->code_blocks->cb[n].src_regex = (REGEXP*)\n\t\t    sv_dup_inc((SV*)(ri->code_blocks->cb[n].src_regex), param);\n        reti->code_blocks->count = ri->code_blocks->count;\n        reti->code_blocks->refcnt = 1;\n    }\n    else\n\treti->code_blocks = NULL;\n\n    reti->regstclass = NULL;\n\n    if (ri->data) {\n\tstruct reg_data *d;\n        const int count = ri->data->count;\n\tint i;\n\n\tNewxc(d, sizeof(struct reg_data) + count*sizeof(void *),\n\t\tchar, struct reg_data);\n\tNewx(d->what, count, U8);\n\n\td->count = count;\n\tfor (i = 0; i < count; i++) {\n\t    d->what[i] = ri->data->what[i];\n\t    switch (d->what[i]) {\n\t        /* see also regcomp.h and regfree_internal() */\n            case 'a': /* actually an AV, but the dup function is identical.\n                         values seem to be \"plain sv's\" generally. */\n            case 'r': /* a compiled regex (but still just another SV) */\n            case 's': /* an RV (currently only used for an RV to an AV by the ANYOF code)\n                         this use case should go away, the code could have used\n                         'a' instead - see S_set_ANYOF_arg() for array contents. */\n            case 'S': /* actually an SV, but the dup function is identical.  */\n            case 'u': /* actually an HV, but the dup function is identical.\n                         values are \"plain sv's\" */\n\t\td->data[i] = sv_dup_inc((const SV *)ri->data->data[i], param);\n\t\tbreak;\n\t    case 'f':\n                /* Synthetic Start Class - \"Fake\" charclass we generate to optimize\n                 * patterns which could start with several different things. Pre-TRIE\n                 * this was more important than it is now, however this still helps\n                 * in some places, for instance /x?a+/ might produce a SSC equivalent\n                 * to [xa]. This is used by Perl_re_intuit_start() and S_find_byclass()\n                 * in regexec.c\n                 */\n\t\t/* This is cheating. */\n\t\tNewx(d->data[i], 1, regnode_ssc);\n\t\tStructCopy(ri->data->data[i], d->data[i], regnode_ssc);\n\t\treti->regstclass = (regnode*)d->data[i];\n\t\tbreak;\n\t    case 'T':\n                /* AHO-CORASICK fail table */\n                /* Trie stclasses are readonly and can thus be shared\n\t\t * without duplication. We free the stclass in pregfree\n\t\t * when the corresponding reg_ac_data struct is freed.\n\t\t */\n\t\treti->regstclass= ri->regstclass;\n\t\t/* FALLTHROUGH */\n\t    case 't':\n                /* TRIE transition table */\n\t\tOP_REFCNT_LOCK;\n\t\t((reg_trie_data*)ri->data->data[i])->refcount++;\n\t\tOP_REFCNT_UNLOCK;\n\t\t/* FALLTHROUGH */\n            case 'l': /* (?{...}) or (??{ ... }) code (cb->block) */\n            case 'L': /* same when RExC_pm_flags & PMf_HAS_CV and code\n                         is not from another regexp */\n\t\td->data[i] = ri->data->data[i];\n\t\tbreak;\n            default:\n                Perl_croak(aTHX_ \"panic: re_dup_guts unknown data code '%c'\",\n                                                           ri->data->what[i]);\n\t    }\n\t}\n\n\treti->data = d;\n    }\n    else\n\treti->data = NULL;\n\n    reti->name_list_idx = ri->name_list_idx;\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets) {\n        Newx(reti->u.offsets, 2*len+1, U32);\n        Copy(ri->u.offsets, reti->u.offsets, 2*len+1, U32);\n    }\n#else\n    SetProgLen(reti,len);\n#endif\n\n    return (void*)reti;\n}\n\n#endif    /* USE_ITHREADS */\n\n#ifndef PERL_IN_XSUB_RE\n\n/*\n - regnext - dig the \"next\" pointer out of a node\n */\nregnode *\nPerl_regnext(pTHX_ regnode *p)\n{\n    I32 offset;\n\n    if (!p)\n\treturn(NULL);\n\n    if (OP(p) > REGNODE_MAX) {\t\t/* regnode.type is unsigned */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                                (int)OP(p), (int)REGNODE_MAX);\n    }\n\n    offset = (reg_off_by_arg[OP(p)] ? ARG(p) : NEXT_OFF(p));\n    if (offset == 0)\n\treturn(NULL);\n\n    return(p+offset);\n}\n#endif\n\nSTATIC void\nS_re_croak2(pTHX_ bool utf8, const char* pat1,const char* pat2,...)\n{\n    va_list args;\n    STRLEN l1 = strlen(pat1);\n    STRLEN l2 = strlen(pat2);\n    char buf[512];\n    SV *msv;\n    const char *message;\n\n    PERL_ARGS_ASSERT_RE_CROAK2;\n\n    if (l1 > 510)\n\tl1 = 510;\n    if (l1 + l2 > 510)\n\tl2 = 510 - l1;\n    Copy(pat1, buf, l1 , char);\n    Copy(pat2, buf + l1, l2 , char);\n    buf[l1 + l2] = '\\n';\n    buf[l1 + l2 + 1] = '\\0';\n    va_start(args, pat2);\n    msv = vmess(buf, &args);\n    va_end(args);\n    message = SvPV_const(msv,l1);\n    if (l1 > 512)\n\tl1 = 512;\n    Copy(message, buf, l1 , char);\n    /* l1-1 to avoid \\n */\n    Perl_croak(aTHX_ \"%\" UTF8f, UTF8fARG(utf8, l1-1, buf));\n}\n\n/* XXX Here's a total kludge.  But we need to re-enter for swash routines. */\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_save_re_context(pTHX)\n{\n    I32 nparens = -1;\n    I32 i;\n\n    /* Save $1..$n (#18107: UTF-8 s/(\\w+)/uc($1)/e); AMS 20021106. */\n\n    if (PL_curpm) {\n\tconst REGEXP * const rx = PM_GETRE(PL_curpm);\n\tif (rx)\n            nparens = RX_NPARENS(rx);\n    }\n\n    /* RT #124109. This is a complete hack; in the SWASHNEW case we know\n     * that PL_curpm will be null, but that utf8.pm and the modules it\n     * loads will only use $1..$3.\n     * The t/porting/re_context.t test file checks this assumption.\n     */\n    if (nparens == -1)\n        nparens = 3;\n\n    for (i = 1; i <= nparens; i++) {\n        char digits[TYPE_CHARS(long)];\n        const STRLEN len = my_snprintf(digits, sizeof(digits),\n                                       \"%lu\", (long)i);\n        GV *const *const gvp\n            = (GV**)hv_fetch(PL_defstash, digits, len, 0);\n\n        if (gvp) {\n            GV * const gv = *gvp;\n            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))\n                save_scalar(gv);\n        }\n    }\n}\n#endif\n\n#ifdef DEBUGGING\n\nSTATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\n        /* We use {phrase} as metanotation in the class, so also escape literal\n         * braces */\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }\n}\n\n#define MAX_PRINT_A MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC void\nS_put_range(pTHX_ SV *sv, UV start, const UV end, const bool allow_literals)\n{\n    /* Appends to 'sv' a displayable version of the range of code points from\n     * 'start' to 'end'.  Mnemonics (like '\\r') are used for the few controls\n     * that have them, when they occur at the beginning or end of the range.\n     * It uses hex to output the remaining code points, unless 'allow_literals'\n     * is true, in which case the printable ASCII ones are output as-is (though\n     * some of these will be escaped by put_code_point()).\n     *\n     * NOTE:  This is designed only for printing ranges of code points that fit\n     *        inside an ANYOF bitmap.  Higher code points are simply suppressed\n     */\n\n    const unsigned int min_range_count = 3;\n\n    assert(start <= end);\n\n    PERL_ARGS_ASSERT_PUT_RANGE;\n\n    while (start <= end) {\n        UV this_end;\n        const char * format;\n\n        if (end - start < min_range_count) {\n\n            /* Output chars individually when they occur in short ranges */\n            for (; start <= end; start++) {\n                put_code_point(sv, start);\n            }\n            break;\n        }\n\n        /* If permitted by the input options, and there is a possibility that\n         * this range contains a printable literal, look to see if there is\n         * one. */\n        if (allow_literals && start <= MAX_PRINT_A) {\n\n            /* If the character at the beginning of the range isn't an ASCII\n             * printable, effectively split the range into two parts:\n             *  1) the portion before the first such printable,\n             *  2) the rest\n             * and output them separately. */\n            if (! isPRINT_A(start)) {\n                UV temp_end = start + 1;\n\n                /* There is no point looking beyond the final possible\n                 * printable, in MAX_PRINT_A */\n                UV max = MIN(end, MAX_PRINT_A);\n\n                while (temp_end <= max && ! isPRINT_A(temp_end)) {\n                    temp_end++;\n                }\n\n                /* Here, temp_end points to one beyond the first printable if\n                 * found, or to one beyond 'max' if not.  If none found, make\n                 * sure that we use the entire range */\n                if (temp_end > MAX_PRINT_A) {\n                    temp_end = end + 1;\n                }\n\n                /* Output the first part of the split range: the part that\n                 * doesn't have printables, with the parameter set to not look\n                 * for literals (otherwise we would infinitely recurse) */\n                put_range(sv, start, temp_end - 1, FALSE);\n\n                /* The 2nd part of the range (if any) starts here. */\n                start = temp_end;\n\n                /* We do a continue, instead of dropping down, because even if\n                 * the 2nd part is non-empty, it could be so short that we want\n                 * to output it as individual characters, as tested for at the\n                 * top of this loop.  */\n                continue;\n            }\n\n            /* Here, 'start' is a printable ASCII.  If it is an alphanumeric,\n             * output a sub-range of just the digits or letters, then process\n             * the remaining portion as usual. */\n            if (isALPHANUMERIC_A(start)) {\n                UV mask = (isDIGIT_A(start))\n                           ? _CC_DIGIT\n                             : isUPPER_A(start)\n                               ? _CC_UPPER\n                               : _CC_LOWER;\n                UV temp_end = start + 1;\n\n                /* Find the end of the sub-range that includes just the\n                 * characters in the same class as the first character in it */\n                while (temp_end <= end && _generic_isCC_A(temp_end, mask)) {\n                    temp_end++;\n                }\n                temp_end--;\n\n                /* For short ranges, don't duplicate the code above to output\n                 * them; just call recursively */\n                if (temp_end - start < min_range_count) {\n                    put_range(sv, start, temp_end, FALSE);\n                }\n                else {  /* Output as a range */\n                    put_code_point(sv, start);\n                    sv_catpvs(sv, \"-\");\n                    put_code_point(sv, temp_end);\n                }\n                start = temp_end + 1;\n                continue;\n            }\n\n            /* We output any other printables as individual characters */\n            if (isPUNCT_A(start) || isSPACE_A(start)) {\n                while (start <= end && (isPUNCT_A(start)\n                                        || isSPACE_A(start)))\n                {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                continue;\n            }\n        } /* End of looking for literals */\n\n        /* Here is not to output as a literal.  Some control characters have\n         * mnemonic names.  Split off any of those at the beginning and end of\n         * the range to print mnemonically.  It isn't possible for many of\n         * these to be in a row, so this won't overwhelm with output */\n        if (   start <= end\n            && (isMNEMONIC_CNTRL(start) || isMNEMONIC_CNTRL(end)))\n        {\n            while (isMNEMONIC_CNTRL(start) && start <= end) {\n                put_code_point(sv, start);\n                start++;\n            }\n\n            /* If this didn't take care of the whole range ... */\n            if (start <= end) {\n\n                /* Look backwards from the end to find the final non-mnemonic\n                 * */\n                UV temp_end = end;\n                while (isMNEMONIC_CNTRL(temp_end)) {\n                    temp_end--;\n                }\n\n                /* And separately output the interior range that doesn't start\n                 * or end with mnemonics */\n                put_range(sv, start, temp_end, FALSE);\n\n                /* Then output the mnemonic trailing controls */\n                start = temp_end + 1;\n                while (start <= end) {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                break;\n            }\n        }\n\n        /* As a final resort, output the range or subrange as hex. */\n\n        this_end = (end < NUM_ANYOF_CODE_POINTS)\n                    ? end\n                    : NUM_ANYOF_CODE_POINTS - 1;\n#if NUM_ANYOF_CODE_POINTS > 256\n        format = (this_end < 256)\n                 ? \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf\n                 : \"\\\\x{%04\" UVXf \"}-\\\\x{%04\" UVXf \"}\";\n#else\n        format = \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf;\n#endif\n        GCC_DIAG_IGNORE(-Wformat-nonliteral);\n        Perl_sv_catpvf(aTHX_ sv, format, start, this_end);\n        GCC_DIAG_RESTORE;\n        break;\n    }\n}\n\nSTATIC void\nS_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist)\n{\n    /* Concatenate onto the PV in 'sv' a displayable form of the inversion list\n     * 'invlist' */\n\n    UV start, end;\n    bool allow_literals = TRUE;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST;\n\n    /* Generally, it is more readable if printable characters are output as\n     * literals, but if a range (nearly) spans all of them, it's best to output\n     * it as a single range.  This code will use a single range if all but 2\n     * ASCII printables are in it */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\n        /* If the range starts beyond the final printable, it doesn't have any\n         * in it */\n        if (start > MAX_PRINT_A) {\n            break;\n        }\n\n        /* In both ASCII and EBCDIC, a SPACE is the lowest printable.  To span\n         * all but two, the range must start and end no later than 2 from\n         * either end */\n        if (start < ' ' + 2 && end > MAX_PRINT_A - 2) {\n            if (end > MAX_PRINT_A) {\n                end = MAX_PRINT_A;\n            }\n            if (start < ' ') {\n                start = ' ';\n            }\n            if (end - start >= MAX_PRINT_A - ' ' - 2) {\n                allow_literals = FALSE;\n            }\n            break;\n        }\n    }\n    invlist_iterfinish(invlist);\n\n    /* Here we have figured things out.  Output each range */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n        if (start >= NUM_ANYOF_CODE_POINTS) {\n            break;\n        }\n        put_range(sv, start, end, allow_literals);\n    }\n    invlist_iterfinish(invlist);\n\n    return;\n}\n\nSTATIC SV*\nS_put_charclass_bitmap_innards_common(pTHX_\n        SV* invlist,            /* The bitmap */\n        SV* posixes,            /* Under /l, things like [:word:], \\S */\n        SV* only_utf8,          /* Under /d, matches iff the target is UTF-8 */\n        SV* not_utf8,           /* /d, matches iff the target isn't UTF-8 */\n        SV* only_utf8_locale,   /* Under /l, matches if the locale is UTF-8 */\n        const bool invert       /* Is the result to be inverted? */\n)\n{\n    /* Create and return an SV containing a displayable version of the bitmap\n     * and associated information determined by the input parameters.  If the\n     * output would have been only the inversion indicator '^', NULL is instead\n     * returned. */\n\n    SV * output;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON;\n\n    if (invert) {\n        output = newSVpvs(\"^\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    /* First, the code points in the bitmap that are unconditionally there */\n    put_charclass_bitmap_innards_invlist(output, invlist);\n\n    /* Traditionally, these have been placed after the main code points */\n    if (posixes) {\n        sv_catsv(output, posixes);\n    }\n\n    if (only_utf8 && _invlist_len(only_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8);\n    }\n\n    if (not_utf8 && _invlist_len(not_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{not utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, not_utf8);\n    }\n\n    if (only_utf8_locale && _invlist_len(only_utf8_locale)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8 locale}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8_locale);\n\n        /* This is the only list in this routine that can legally contain code\n         * points outside the bitmap range.  The call just above to\n         * 'put_charclass_bitmap_innards_invlist' will simply suppress them, so\n         * output them here.  There's about a half-dozen possible, and none in\n         * contiguous ranges longer than 2 */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            UV start, end;\n            SV* above_bitmap = NULL;\n\n            _invlist_subtract(only_utf8_locale, PL_InBitmap, &above_bitmap);\n\n            invlist_iterinit(above_bitmap);\n            while (invlist_iternext(above_bitmap, &start, &end)) {\n                UV i;\n\n                for (i = start; i <= end; i++) {\n                    put_code_point(output, i);\n                }\n            }\n            invlist_iterfinish(above_bitmap);\n            SvREFCNT_dec_NN(above_bitmap);\n        }\n    }\n\n    if (invert && SvCUR(output) == 1) {\n        return NULL;\n    }\n\n    return output;\n}\n\nSTATIC bool\nS_put_charclass_bitmap_innards(pTHX_ SV *sv,\n                                     char *bitmap,\n                                     SV *nonbitmap_invlist,\n                                     SV *only_utf8_locale_invlist,\n                                     const regnode * const node,\n                                     const bool force_as_is_display)\n{\n    /* Appends to 'sv' a displayable version of the innards of the bracketed\n     * character class defined by the other arguments:\n     *  'bitmap' points to the bitmap.\n     *  'nonbitmap_invlist' is an inversion list of the code points that are in\n     *      the bitmap range, but for some reason aren't in the bitmap; NULL if\n     *      none.  The reasons for this could be that they require some\n     *      condition such as the target string being or not being in UTF-8\n     *      (under /d), or because they came from a user-defined property that\n     *      was not resolved at the time of the regex compilation (under /u)\n     *  'only_utf8_locale_invlist' is an inversion list of the code points that\n     *      are valid only if the runtime locale is a UTF-8 one; NULL if none\n     *  'node' is the regex pattern node.  It is needed only when the above two\n     *      parameters are not null, and is passed so that this routine can\n     *      tease apart the various reasons for them.\n     *  'force_as_is_display' is TRUE if this routine should definitely NOT try\n     *      to invert things to see if that leads to a cleaner display.  If\n     *      FALSE, this routine is free to use its judgment about doing this.\n     *\n     * It returns TRUE if there was actually something output.  (It may be that\n     * the bitmap, etc is empty.)\n     *\n     * When called for outputting the bitmap of a non-ANYOF node, just pass the\n     * bitmap, with the succeeding parameters set to NULL, and the final one to\n     * FALSE.\n     */\n\n    /* In general, it tries to display the 'cleanest' representation of the\n     * innards, choosing whether to display them inverted or not, regardless of\n     * whether the class itself is to be inverted.  However,  there are some\n     * cases where it can't try inverting, as what actually matches isn't known\n     * until runtime, and hence the inversion isn't either. */\n    bool inverting_allowed = ! force_as_is_display;\n\n    int i;\n    STRLEN orig_sv_cur = SvCUR(sv);\n\n    SV* invlist;            /* Inversion list we accumulate of code points that\n                               are unconditionally matched */\n    SV* only_utf8 = NULL;   /* Under /d, list of matches iff the target is\n                               UTF-8 */\n    SV* not_utf8 =  NULL;   /* /d, list of matches iff the target isn't UTF-8\n                             */\n    SV* posixes = NULL;     /* Under /l, string of things like [:word:], \\D */\n    SV* only_utf8_locale = NULL;    /* Under /l, list of matches if the locale\n                                       is UTF-8 */\n\n    SV* as_is_display;      /* The output string when we take the inputs\n                               literally */\n    SV* inverted_display;   /* The output string when we invert the inputs */\n\n    U8 flags = (node) ? ANYOF_FLAGS(node) : 0;\n\n    bool invert = cBOOL(flags & ANYOF_INVERT);  /* Is the input to be inverted\n                                                   to match? */\n    /* We are biased in favor of displaying things without them being inverted,\n     * as that is generally easier to understand */\n    const int bias = 5;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS;\n\n    /* Start off with whatever code points are passed in.  (We clone, so we\n     * don't change the caller's list) */\n    if (nonbitmap_invlist) {\n        assert(invlist_highest(nonbitmap_invlist) < NUM_ANYOF_CODE_POINTS);\n        invlist = invlist_clone(nonbitmap_invlist);\n    }\n    else {  /* Worst case size is every other code point is matched */\n        invlist = _new_invlist(NUM_ANYOF_CODE_POINTS / 2);\n    }\n\n    if (flags) {\n        if (OP(node) == ANYOFD) {\n\n            /* This flag indicates that the code points below 0x100 in the\n             * nonbitmap list are precisely the ones that match only when the\n             * target is UTF-8 (they should all be non-ASCII). */\n            if (flags & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)\n            {\n                _invlist_intersection(invlist, PL_UpperLatin1, &only_utf8);\n                _invlist_subtract(invlist, only_utf8, &invlist);\n            }\n\n            /* And this flag for matching all non-ASCII 0xFF and below */\n            if (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)\n            {\n                not_utf8 = invlist_clone(PL_UpperLatin1);\n            }\n        }\n        else if (OP(node) == ANYOFL) {\n\n            /* If either of these flags are set, what matches isn't\n             * determinable except during execution, so don't know enough here\n             * to invert */\n            if (flags & (ANYOFL_FOLD|ANYOF_MATCHES_POSIXL)) {\n                inverting_allowed = FALSE;\n            }\n\n            /* What the posix classes match also varies at runtime, so these\n             * will be output symbolically. */\n            if (ANYOF_POSIXL_TEST_ANY_SET(node)) {\n                int i;\n\n                posixes = newSVpvs(\"\");\n                for (i = 0; i < ANYOF_POSIXL_MAX; i++) {\n                    if (ANYOF_POSIXL_TEST(node,i)) {\n                        sv_catpv(posixes, anyofs[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    /* Accumulate the bit map into the unconditional match list */\n    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n        if (BITMAP_TEST(bitmap, i)) {\n            int start = i++;\n            for (; i < NUM_ANYOF_CODE_POINTS && BITMAP_TEST(bitmap, i); i++) {\n                /* empty */\n            }\n            invlist = _add_range_to_invlist(invlist, start, i-1);\n        }\n    }\n\n    /* Make sure that the conditional match lists don't have anything in them\n     * that match unconditionally; otherwise the output is quite confusing.\n     * This could happen if the code that populates these misses some\n     * duplication. */\n    if (only_utf8) {\n        _invlist_subtract(only_utf8, invlist, &only_utf8);\n    }\n    if (not_utf8) {\n        _invlist_subtract(not_utf8, invlist, &not_utf8);\n    }\n\n    if (only_utf8_locale_invlist) {\n\n        /* Since this list is passed in, we have to make a copy before\n         * modifying it */\n        only_utf8_locale = invlist_clone(only_utf8_locale_invlist);\n\n        _invlist_subtract(only_utf8_locale, invlist, &only_utf8_locale);\n\n        /* And, it can get really weird for us to try outputting an inverted\n         * form of this list when it has things above the bitmap, so don't even\n         * try */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            inverting_allowed = FALSE;\n        }\n    }\n\n    /* Calculate what the output would be if we take the input as-is */\n    as_is_display = put_charclass_bitmap_innards_common(invlist,\n                                                    posixes,\n                                                    only_utf8,\n                                                    not_utf8,\n                                                    only_utf8_locale,\n                                                    invert);\n\n    /* If have to take the output as-is, just do that */\n    if (! inverting_allowed) {\n        if (as_is_display) {\n            sv_catsv(sv, as_is_display);\n            SvREFCNT_dec_NN(as_is_display);\n        }\n    }\n    else { /* But otherwise, create the output again on the inverted input, and\n              use whichever version is shorter */\n\n        int inverted_bias, as_is_bias;\n\n        /* We will apply our bias to whichever of the the results doesn't have\n         * the '^' */\n        if (invert) {\n            invert = FALSE;\n            as_is_bias = bias;\n            inverted_bias = 0;\n        }\n        else {\n            invert = TRUE;\n            as_is_bias = 0;\n            inverted_bias = bias;\n        }\n\n        /* Now invert each of the lists that contribute to the output,\n         * excluding from the result things outside the possible range */\n\n        /* For the unconditional inversion list, we have to add in all the\n         * conditional code points, so that when inverted, they will be gone\n         * from it */\n        _invlist_union(only_utf8, invlist, &invlist);\n        _invlist_union(not_utf8, invlist, &invlist);\n        _invlist_union(only_utf8_locale, invlist, &invlist);\n        _invlist_invert(invlist);\n        _invlist_intersection(invlist, PL_InBitmap, &invlist);\n\n        if (only_utf8) {\n            _invlist_invert(only_utf8);\n            _invlist_intersection(only_utf8, PL_UpperLatin1, &only_utf8);\n        }\n        else if (not_utf8) {\n\n            /* If a code point matches iff the target string is not in UTF-8,\n             * then complementing the result has it not match iff not in UTF-8,\n             * which is the same thing as matching iff it is UTF-8. */\n            only_utf8 = not_utf8;\n            not_utf8 = NULL;\n        }\n\n        if (only_utf8_locale) {\n            _invlist_invert(only_utf8_locale);\n            _invlist_intersection(only_utf8_locale,\n                                  PL_InBitmap,\n                                  &only_utf8_locale);\n        }\n\n        inverted_display = put_charclass_bitmap_innards_common(\n                                            invlist,\n                                            posixes,\n                                            only_utf8,\n                                            not_utf8,\n                                            only_utf8_locale, invert);\n\n        /* Use the shortest representation, taking into account our bias\n         * against showing it inverted */\n        if (   inverted_display\n            && (   ! as_is_display\n                || (  SvCUR(inverted_display) + inverted_bias\n                    < SvCUR(as_is_display)    + as_is_bias)))\n        {\n\t    sv_catsv(sv, inverted_display);\n        }\n        else if (as_is_display) {\n\t    sv_catsv(sv, as_is_display);\n        }\n\n        SvREFCNT_dec(as_is_display);\n        SvREFCNT_dec(inverted_display);\n    }\n\n    SvREFCNT_dec_NN(invlist);\n    SvREFCNT_dec(only_utf8);\n    SvREFCNT_dec(not_utf8);\n    SvREFCNT_dec(posixes);\n    SvREFCNT_dec(only_utf8_locale);\n\n    return SvCUR(sv) > orig_sv_cur;\n}\n\n#define CLEAR_OPTSTART                                                       \\\n    if (optstart) STMT_START {                                               \\\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_                                           \\\n                              \" (%\" IVdf \" nodes)\\n\", (IV)(node - optstart))); \\\n        optstart=NULL;                                                       \\\n    } STMT_END\n\n#define DUMPUNTIL(b,e)                                                       \\\n                    CLEAR_OPTSTART;                                          \\\n                    node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);\n\nSTATIC const regnode *\nS_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node,\n\t    const regnode *last, const regnode *plast,\n\t    SV* sv, I32 indent, U32 depth)\n{\n    U8 op = PSEUDO;\t/* Arbitrary non-END op. */\n    const regnode *next;\n    const regnode *optstart= NULL;\n\n    RXi_GET_DECL(r,ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMPUNTIL;\n\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d : %d - %d - %d\\n\",indent,node-start,\n        last ? last-start : 0,plast ? plast-start : 0);\n#endif\n\n    if (plast && plast < last)\n        last= plast;\n\n    while (PL_regkind[op] != END && (!last || node < last)) {\n        assert(node);\n\t/* While that wasn't END last time... */\n\tNODE_ALIGN(node);\n\top = OP(node);\n\tif (op == CLOSE || op == WHILEM)\n\t    indent--;\n\tnext = regnext((regnode *)node);\n\n\t/* Where, what. */\n\tif (OP(node) == OPTIMIZED) {\n\t    if (!optstart && RE_DEBUG_FLAG(RE_DEBUG_COMPILE_OPTIMISE))\n\t        optstart = node;\n\t    else\n\t\tgoto after_print;\n\t} else\n\t    CLEAR_OPTSTART;\n\n        regprop(r, sv, node, NULL, NULL);\n        Perl_re_printf( aTHX_  \"%4\" IVdf \":%*s%s\", (IV)(node - start),\n\t\t      (int)(2*indent + 1), \"\", SvPVX_const(sv));\n\n        if (OP(node) != OPTIMIZED) {\n            if (next == NULL)\t\t/* Next ptr. */\n                Perl_re_printf( aTHX_  \" (0)\");\n            else if (PL_regkind[(U8)op] == BRANCH\n                     && PL_regkind[OP(next)] != BRANCH )\n                Perl_re_printf( aTHX_  \" (FAIL)\");\n            else\n                Perl_re_printf( aTHX_  \" (%\" IVdf \")\", (IV)(next - start));\n            Perl_re_printf( aTHX_ \"\\n\");\n        }\n\n      after_print:\n\tif (PL_regkind[(U8)op] == BRANCHJ) {\n\t    assert(next);\n\t    {\n                const regnode *nnode = (OP(next) == LONGJMP\n                                       ? regnext((regnode *)next)\n                                       : next);\n                if (last && nnode > last)\n                    nnode = last;\n                DUMPUNTIL(NEXTOPER(NEXTOPER(node)), nnode);\n\t    }\n\t}\n\telse if (PL_regkind[(U8)op] == BRANCH) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node), next);\n\t}\n\telse if ( PL_regkind[(U8)op]  == TRIE ) {\n\t    const regnode *this_trie = node;\n\t    const char op = OP(node);\n            const U32 n = ARG(node);\n\t    const reg_ac_data * const ac = op>=AHOCORASICK ?\n               (reg_ac_data *)ri->data->data[n] :\n               NULL;\n\t    const reg_trie_data * const trie =\n\t        (reg_trie_data*)ri->data->data[op<AHOCORASICK ? n : ac->trie];\n#ifdef DEBUGGING\n\t    AV *const trie_words\n                           = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);\n#endif\n\t    const regnode *nextbranch= NULL;\n\t    I32 word_idx;\n            SvPVCLEAR(sv);\n\t    for (word_idx= 0; word_idx < (I32)trie->wordcount; word_idx++) {\n\t\tSV ** const elem_ptr = av_fetch(trie_words,word_idx,0);\n\n                Perl_re_indentf( aTHX_  \"%s \",\n                    indent+3,\n                    elem_ptr\n                    ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr),\n                                SvCUR(*elem_ptr), PL_dump_re_max_len,\n                                PL_colors[0], PL_colors[1],\n                                (SvUTF8(*elem_ptr)\n                                 ? PERL_PV_ESCAPE_UNI\n                                 : 0)\n                                | PERL_PV_PRETTY_ELLIPSES\n                                | PERL_PV_PRETTY_LTGT\n                            )\n                    : \"???\"\n                );\n                if (trie->jump) {\n                    U16 dist= trie->jump[word_idx+1];\n                    Perl_re_printf( aTHX_  \"(%\" UVuf \")\\n\",\n                               (UV)((dist ? this_trie + dist : next) - start));\n                    if (dist) {\n                        if (!nextbranch)\n                            nextbranch= this_trie + trie->jump[0];\n\t\t\tDUMPUNTIL(this_trie + dist, nextbranch);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode *)nextbranch);\n                } else {\n                    Perl_re_printf( aTHX_  \"\\n\");\n\t\t}\n\t    }\n\t    if (last && next > last)\n\t        node= last;\n\t    else\n\t        node= next;\n\t}\n\telse if ( op == CURLY ) {   /* \"next\" might be very big: optimizer */\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS,\n                    NEXTOPER(node) + EXTRA_STEP_2ARGS + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS, next);\n\t}\n\telse if ( op == PLUS || op == STAR) {\n\t    DUMPUNTIL(NEXTOPER(node), NEXTOPER(node) + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == ANYOF) {\n\t    /* arglen 1 + class block */\n\t    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_MATCHES_POSIXL)\n                          ? ANYOF_POSIXL_SKIP\n                          : ANYOF_SKIP);\n\t    node = NEXTOPER(node);\n\t}\n\telse if (PL_regkind[(U8)op] == EXACT) {\n            /* Literal string, where present. */\n\t    node += NODE_SZ_STR(node) - 1;\n\t    node = NEXTOPER(node);\n\t}\n\telse {\n\t    node = NEXTOPER(node);\n\t    node += regarglen[(U8)op];\n\t}\n\tif (op == CURLYX || op == OPEN)\n\t    indent++;\n    }\n    CLEAR_OPTSTART;\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d\\n\", (int)indent);\n#endif\n    return node;\n}\n\n#endif\t/* DEBUGGING */\n\n/*\n * ex: set ts=8 sts=4 sw=4 et:\n */\n", "  regcomp.c\tThese tests have been moved to t/re/reg_mesg.t\n\t\texcept for those that explicitly test line numbers\n                and those that don't have a <-- HERE in them, and those that\n                die plus have warnings, or otherwise require special handling\n\n__END__\nuse warnings 'regexp';\n$r=qr/(??{ q\"\\\\b+\" })/;\n\"a\" =~ /a$r/; # warning should come from this line\nEXPECT\n\\b+ matches null string many times in regex; marked by <-- HERE in m/\\b+ <-- HERE / at - line 3.\n########\n# regcomp.c\nuse warnings 'digit' ;\nmy $a = qr/\\o{1238456}\\x{100}/;\nmy $a = qr/[\\o{6548321}]\\x{100}/;\nno warnings 'digit' ;\nmy $a = qr/\\o{1238456}\\x{100}/;\nmy $a = qr/[\\o{6548321}]\\x{100}/;\nEXPECT\nNon-octal character '8'.  Resolved as \"\\o{123}\" at - line 3.\nNon-octal character '8'.  Resolved as \"\\o{654}\" at - line 4.\n########\n# regcomp.c\nBEGIN {\n    if (ord('A') == 193) {\n        print \"SKIPPED\\n# Different results on EBCDIC\";\n        exit 0;\n    }\n}\nuse warnings;\n$a = qr/\\c,/;\n$a = qr/[\\c,]/;\nno warnings 'syntax';\n$a = qr/\\c,/;\n$a = qr/[\\c,]/;\nEXPECT\n\"\\c,\" is more clearly written simply as \"l\" at - line 9.\n\"\\c,\" is more clearly written simply as \"l\" at - line 10.\n########\n# This is because currently a different error is output under\n# use re 'strict', so can't go in reg_mesg.t\n# NAME perl #126261, error message causes segfault\n# OPTION fatal\n qr/abc[\\x{df}[.00./i\nEXPECT\nUnmatched [ in regex; marked by <-- HERE in m/abc[ <-- HERE \\x{df}[.00./ at - line 4.\n########\n# NAME perl #126261, with 'use utf8'\n# OPTION fatal\nuse utf8;\nno warnings 'utf8';\nqr/abc[\ufb01[.00./i;\nEXPECT\nUnmatched [ in regex; marked by <-- HERE in m/abc[ <-- HERE \ufb01[.00./ at - line 4.\n########\n# NAME perl qr/(?[[[:word]]])/ XXX Why is 'syntax' lc?\n# OPTION fatal\nqr/(?[[[:word]]])/;\nEXPECT\nAssuming NOT a POSIX class since there is no terminating ':' in regex; marked by <-- HERE in m/(?[[[:word <-- HERE ]]])/ at - line 2.\nsyntax error in (?[...]) in regex m/(?[[[:word]]])/ at - line 2.\n########\n# NAME qr/(?[ [[:digit: ])/\n# OPTION fatal\nqr/(?[[[:digit: ])/;\nEXPECT\nAssuming NOT a POSIX class since no blanks are allowed in one in regex; marked by <-- HERE in m/(?[[[:digit: ] <-- HERE )/ at - line 2.\nsyntax error in (?[...]) in regex m/(?[[[:digit: ])/ at - line 2.\n########\n# NAME qr/(?[ [:digit: ])/\n# OPTION fatal\nqr/(?[[:digit: ])/\nEXPECT\nAssuming NOT a POSIX class since no blanks are allowed in one in regex; marked by <-- HERE in m/(?[[:digit: ] <-- HERE )/ at - line 2.\nsyntax error in (?[...]) in regex m/(?[[:digit: ])/ at - line 2.\n########\n# NAME [perl #126141]\n# OPTION fatal\neval {/$_/}, print \"$_ ==> \", $@ || \"OK!\\n\" for \"]]]]]]]]][\\\\\", \"]]]]][\\\\\"\nEXPECT\n]]]]]]]]][\\ ==> Unmatched [ in regex; marked by <-- HERE in m/]]]]]]]]][\\ <-- HERE / at - line 2.\n]]]]][\\ ==> Unmatched [ in regex; marked by <-- HERE in m/]]]]][\\ <-- HERE / at - line 2.\n########\n# NAME [perl #123417]\n# OPTION fatal\nqr/[\\N{}]/;\nEXPECT\nUnknown charname '' at - line 2, within pattern\nExecution of - aborted due to compilation errors.\n########\n# NAME [perl #123417]\n# OPTION fatal\nqr/\\N{}/;\nEXPECT\nUnknown charname '' at - line 2, within pattern\nExecution of - aborted due to compilation errors.\n########\n# NAME [perl #131868]\nuse warnings;\nmy $qr = qr {\n    (?(DEFINE)\n      (?<digit>   [0-9])\n      (?<digits>  (?&digit){4})\n    )\n    ^(?&digits)$\n}x;\nEXPECT\n########\n", "#!./perl -w\n\n$|=1;   # outherwise things get mixed up in output\n\nBEGIN {\n\tchdir 't' if -d 't';\n\trequire './test.pl';\n    set_up_inc( qw '../lib ../ext/re' );\n\teval 'require Config'; # assume defaults if this fails\n}\n\nskip_all_without_unicode_tables();\n\nuse strict;\nuse open qw(:utf8 :std);\n\n# Kind of a kludge to mark warnings to be expected only if we are testing\n# under \"use re 'strict'\"\nmy $only_strict_marker = ':expected_only_under_strict';\n\n## If the markers used are changed (search for \"MARKER1\" in regcomp.c),\n## update only these two regexs, and leave the {#} in the @death/@warning\n## arrays below. The {#} is a meta-marker -- it marks where the marker should\n## go.\n\nsub fixup_expect ($$) {\n\n    # Fixes up the expected results by inserting the boiler plate text.\n    # Returns empty string if that is what is expected.  Otherwise, handles\n    # either a scalar, turning it into a single element array; or a ref to an\n    # array, adjusting each element.  If called in array context, returns an\n    # array, otherwise the join of all elements.\n\n    # The string $only_strict_marker will be removed from any expect line it\n    # begins, and if $strict is not true, that expect line will be removed\n    # from the output (hence won't be expected)\n\n    my ($expect_ref, $strict) = @_;\n    return \"\" if $expect_ref eq \"\";\n\n    my @expect;\n    if (ref $expect_ref) {\n        @expect = @$expect_ref;\n    }\n    else {\n        @expect = $expect_ref;\n    }\n\n    my @new_expect;\n    foreach my $element (@expect) {\n        $element =~ s/\\{\\#\\}/in regex; marked by <-- HERE in/;\n        $element =~ s/\\{\\#\\}/ <-- HERE /;\n        $element .= \" at \";\n        next if $element =~ s/ ^ $only_strict_marker \\s* //x && ! $strict;\n        push @new_expect, $element;\n    }\n    return wantarray ? @new_expect : join \"\", @new_expect;\n}\n\nsub add_markers {\n    my ($element)= @_;\n    $element =~ s/ at .* line \\d+\\.?\\n$//;\n    $element =~ s/in regex; marked by <-- HERE in/{#}/;\n    $element =~ s/ <-- HERE /{#}/;\n    return $element;\n}\n\nsub _qq {\n    my ($str)= @_;\n    $str =~ s/\\\\/\\\\\\\\/g;\n    $str =~ s/\\$/\\\\\\$/g;\n    return qq(\"$str\");\n}\n\n\n## Because we don't \"use utf8\" in this file, we need to do some extra legwork\n## for the utf8 tests: Prepend 'use utf8' to the pattern, and mark the strings\n## to check against as UTF-8, but for this all to work properly, the character\n## '\u30cd' (U+30CD) is required in each pattern somewhere as a marker.\n##\n## This also creates a second variant of the tests to check if the\n## latin1 error messages are working correctly.  Because we don't 'use utf8',\n## we can't tell if something is UTF-8 or Latin1, so you need the suffix\n## '; no latin1' to not have the second variant.\nmy $l1   = \"\\x{ef}\";\nmy $utf8 = \"\\x{30cd}\";\nutf8::encode($utf8);\n\nsub mark_as_utf8 {\n    my @ret;\n    for (my $i = 0; $i < @_; $i += 2) {\n        my $pat = $_[$i];\n        my $msg = $_[$i+1];\n        my $l1_pat = $pat =~ s/$utf8/$l1/gr;\n        my $l1_msg;\n        $pat = \"use utf8; $pat\";\n\n        if (ref $msg) {\n            $l1_msg = [ map { s/$utf8/$l1/gr } @$msg ];\n            @$msg   = map { my $c = $_; utf8::decode($c); $c } @$msg;\n        }\n        else {\n            $l1_msg = $msg =~ s/$utf8/$l1/gr;\n            utf8::decode($msg);\n        }\n        push @ret, $pat => $msg;\n\n        push @ret, $l1_pat => $l1_msg unless $l1_pat =~ /#no latin1/;\n    }\n    return @ret;\n}\n\nmy $inf_m1 = ($Config::Config{reg_infty} || 32767) - 1;\nmy $inf_p1 = $inf_m1 + 2;\n\nmy $B_hex = sprintf(\"\\\\x%02X\", ord \"B\");\nmy $low_mixed_alpha = ('A' lt 'a') ? 'A' : 'a';\nmy $high_mixed_alpha = ('A' lt 'a') ? 'a' : 'A';\nmy $low_mixed_digit = ('A' lt '0') ? 'A' : '0';\nmy $high_mixed_digit = ('A' lt '0') ? '0' : 'A';\n\nmy $colon_hex = sprintf \"%02X\", ord(\":\");\nmy $tab_hex = sprintf \"%02X\", ord(\"\\t\");\n\n# Key-value pairs of strings eval'd as patterns => warn/error messages that\n# they should generate.  In some cases, the value is an array of multiple\n# messages.  Some groups have the message(s) be default on; others, default\n# off.  This can be overridden on an individual key basis by preceding the\n# pattern string with either 'default_on' or 'default_off'\n#\n# The first set are those that should be fatal errors.\n\nmy @death =\n(\n '/[[=foo=]]/' => 'POSIX syntax [= =] is reserved for future extensions {#} m/[[=foo=]{#}]/',\n\n '/(?<= .*)/' =>  'Variable length lookbehind not implemented in regex m/(?<= .*)/',\n\n '/(?<= x{1000})/' => 'Lookbehind longer than 255 not implemented in regex m/(?<= x{1000})/',\n\n '/(?@)/' => 'Sequence (?@...) not implemented {#} m/(?@{#})/',\n\n '/(?{ 1/' => 'Missing right curly or square bracket',\n\n '/(?(1x))/' => 'Switch condition not recognized {#} m/(?(1x{#}))/',\n '/(?(1x(?#)))/'=> 'Switch condition not recognized {#} m/(?(1x{#}(?#)))/',\n\n '/(?(1)/'    => 'Switch (?(condition)... not terminated {#} m/(?(1){#}/',\n '/(?(1)x/'    => 'Switch (?(condition)... not terminated {#} m/(?(1)x{#}/',\n '/(?(1)x|y/'    => 'Switch (?(condition)... not terminated {#} m/(?(1)x|y{#}/',\n '/(?(1)x|y|z)/' => 'Switch (?(condition)... contains too many branches {#} m/(?(1)x|y|{#}z)/',\n\n '/(?(x)y|x)/' => 'Unknown switch condition (?(...)) {#} m/(?(x{#})y|x)/',\n '/(?(??{}))/' => 'Unknown switch condition (?(...)) {#} m/(?(?{#}?{}))/',\n '/(?(?[]))/' => 'Unknown switch condition (?(...)) {#} m/(?(?{#}[]))/',\n\n '/(?/' => 'Sequence (? incomplete {#} m/(?{#}/',\n\n '/(?;x/' => 'Sequence (?;...) not recognized {#} m/(?;{#}x/',\n '/(?<;x/' => 'Group name must start with a non-digit word character {#} m/(?<;{#}x/',\n '/(?\\ix/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}ix/',\n '/(?\\mx/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}mx/',\n '/(?\\:x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}:x/',\n '/(?\\=x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}=x/',\n '/(?\\!x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}!x/',\n '/(?\\<=x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}<=x/',\n '/(?\\<!x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}<!x/',\n '/(?\\>x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}>x/',\n '/(?^-i:foo)/' => 'Sequence (?^-...) not recognized {#} m/(?^-{#}i:foo)/',\n '/(?^-i)foo/' => 'Sequence (?^-...) not recognized {#} m/(?^-{#}i)foo/',\n '/(?^d:foo)/' => 'Sequence (?^d...) not recognized {#} m/(?^d{#}:foo)/',\n '/(?^d)foo/' => 'Sequence (?^d...) not recognized {#} m/(?^d{#})foo/',\n '/(?^lu:foo)/' => 'Regexp modifiers \"l\" and \"u\" are mutually exclusive {#} m/(?^lu{#}:foo)/',\n '/(?^lu)foo/' => 'Regexp modifiers \"l\" and \"u\" are mutually exclusive {#} m/(?^lu{#})foo/',\n'/(?da:foo)/' => 'Regexp modifiers \"d\" and \"a\" are mutually exclusive {#} m/(?da{#}:foo)/',\n'/(?lil:foo)/' => 'Regexp modifier \"l\" may not appear twice {#} m/(?lil{#}:foo)/',\n'/(?aaia:foo)/' => 'Regexp modifier \"a\" may appear a maximum of twice {#} m/(?aaia{#}:foo)/',\n'/(?i-l:foo)/' => 'Regexp modifier \"l\" may not appear after the \"-\" {#} m/(?i-l{#}:foo)/',\n\n '/((x)/' => 'Unmatched ( {#} m/({#}(x)/',\n '/{(}/' => 'Unmatched ( {#} m/{({#}}/',    # [perl #127599]\n\n \"/x{$inf_p1}/\" => \"Quantifier in {,} bigger than $inf_m1 {#} m/x{{#}$inf_p1}/\",\n\n\n '/x**/' => 'Nested quantifiers {#} m/x**{#}/',\n\n '/x[/' => 'Unmatched [ {#} m/x[{#}/',\n\n '/*/', => 'Quantifier follows nothing {#} m/*{#}/',\n\n '/\\p{x/' => 'Missing right brace on \\p{} {#} m/\\p{{#}x/',\n\n '/[\\p{x]/' => 'Missing right brace on \\p{} {#} m/[\\p{{#}x]/',\n\n '/(x)\\2/' => 'Reference to nonexistent group {#} m/(x)\\2{#}/',\n\n '/\\g/' => 'Unterminated \\g... pattern {#} m/\\g{#}/',\n '/\\g{1/' => 'Unterminated \\g{...} pattern {#} m/\\g{1{#}/',\n\n 'my $m = \"\\\\\\\"; $m =~ $m', => 'Trailing \\ in regex m/\\/',\n\n '/\\x{1/' => 'Missing right brace on \\x{} {#} m/\\x{1{#}/',\n '/\\x{X/' => 'Missing right brace on \\x{} {#} m/\\x{{#}X/',\n\n '/[\\x{X]/' => 'Missing right brace on \\x{} {#} m/[\\x{{#}X]/',\n '/[\\x{A]/' => 'Missing right brace on \\x{} {#} m/[\\x{A{#}]/',\n\n '/\\o{1/' => 'Missing right brace on \\o{ {#} m/\\o{1{#}/',\n '/\\o{X/' => 'Missing right brace on \\o{ {#} m/\\o{{#}X/',\n\n '/[\\o{X]/' => 'Missing right brace on \\o{ {#} m/[\\o{{#}X]/',\n '/[\\o{7]/' => 'Missing right brace on \\o{ {#} m/[\\o{7{#}]/',\n\n '/[[:barf:]]/' => 'POSIX class [:barf:] unknown {#} m/[[:barf:]{#}]/',\n\n '/[[=barf=]]/' => 'POSIX syntax [= =] is reserved for future extensions {#} m/[[=barf=]{#}]/',\n\n '/[[.barf.]]/' => 'POSIX syntax [. .] is reserved for future extensions {#} m/[[.barf.]{#}]/',\n\n '/[z-a]/' => 'Invalid [] range \"z-a\" {#} m/[z-a{#}]/',\n\n '/\\p/' => 'Empty \\p {#} m/\\p{#}/',\n '/\\P/' => 'Empty \\P {#} m/\\P{#}/',\n '/\\p{}/' => 'Empty \\p{} {#} m/\\p{{#}}/',\n '/\\P{}/' => 'Empty \\P{} {#} m/\\P{{#}}/',\n\n'/a\\b{cde/' => 'Missing right brace on \\b{} {#} m/a\\b{{#}cde/',\n'/a\\B{cde/' => 'Missing right brace on \\B{} {#} m/a\\B{{#}cde/',\n\n '/\\b{}/' => 'Empty \\b{} {#} m/\\b{}{#}/',\n '/\\B{}/' => 'Empty \\B{} {#} m/\\B{}{#}/',\n\n '/\\b{gc}/' => \"'gc' is an unknown bound type {#} m/\\\\b{gc{#}}/\",\n '/\\B{gc}/' => \"'gc' is an unknown bound type {#} m/\\\\B{gc{#}}/\",\n\n '/(?[[[::]]])/' => \"Syntax error in (?[...]) in regex m/(?[[[::]]])/\",\n '/(?[[[:w:]]])/' => \"Syntax error in (?[...]) in regex m/(?[[[:w:]]])/\",\n '/(?[[:w:]])/' => \"\",\n '/([.].*)[.]/'   => \"\",    # [perl #127582]\n '/[.].*[.]/'     => \"\",    # [perl #127604]\n '/(?[a])/' =>  'Unexpected character {#} m/(?[a{#}])/',\n '/(?[ + \\t ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/(?[ +{#} \\t ])/',\n '/(?[ \\cK - ( + \\t ) ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/(?[ \\cK - ( +{#} \\t ) ])/',\n '/(?[ \\cK ( \\t ) ])/' => 'Unexpected \\'(\\' with no preceding operator {#} m/(?[ \\cK ({#} \\t ) ])/',\n '/(?[ \\cK \\t ])/' => 'Operand with no preceding operator {#} m/(?[ \\cK \\t{#} ])/',\n '/(?[ \\0004 ])/' => 'Need exactly 3 octal digits {#} m/(?[ \\0004 {#}])/',\n '/(?[ \\05 ])/' => 'Need exactly 3 octal digits {#} m/(?[ \\05 {#}])/',\n '/(?[ \\o{1038} ])/' => 'Non-octal character {#} m/(?[ \\o{1038{#}} ])/',\n '/(?[ \\o{} ])/' => 'Number with no digits {#} m/(?[ \\o{}{#} ])/',\n '/(?[ \\x{defg} ])/' => 'Non-hex character {#} m/(?[ \\x{defg{#}} ])/',\n '/(?[ \\xabcdef ])/' => 'Use \\\\x{...} for more than two hex characters {#} m/(?[ \\xabc{#}def ])/',\n '/(?[ \\x{} ])/' => 'Number with no digits {#} m/(?[ \\x{}{#} ])/',\n '/(?[ \\cK + ) ])/' => 'Unexpected \\')\\' {#} m/(?[ \\cK + ){#} ])/',\n '/(?[ \\cK + ])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[ \\cK + {#}])/',\n '/(?[ ( ) ])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[ ( ){#} ])/',\n '/(?[[0]+()+])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[[0]+(){#}+])/',\n '/(?[ \\p{foo} ])/' => 'Can\\'t find Unicode property definition \"foo\" {#} m/(?[ \\p{foo}{#} ])/',\n '/(?[ \\p{ foo = bar } ])/' => 'Can\\'t find Unicode property definition \"foo = bar\" {#} m/(?[ \\p{ foo = bar }{#} ])/',\n '/(?[ \\8 ])/' => 'Unrecognized escape \\8 in character class {#} m/(?[ \\8{#} ])/',\n '/(?[ \\t ]/' => 'Syntax error in (?[...]) in regex m/(?[ \\t ]/',\n '/(?[ [ \\t ]/' => 'Syntax error in (?[...]) in regex m/(?[ [ \\t ]/',\n '/(?[ \\t ] ]/' => 'Syntax error in (?[...]) in regex m/(?[ \\t ] ]/',\n '/(?[ [ ] ]/' => 'Syntax error in (?[...]) in regex m/(?[ [ ] ]/',\n '/(?[ \\t + \\e # This was supposed to be a comment ])/' => 'Syntax error in (?[...]) in regex m/(?[ \\t + \\e # This was supposed to be a comment ])/',\n '/(?[ ])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[ {#}])/',\n 'm/(?[[a-\\d]])/' => 'False [] range \"a-\\d\" {#} m/(?[[a-\\d{#}]])/',\n 'm/(?[[\\w-x]])/' => 'False [] range \"\\w-\" {#} m/(?[[\\w-{#}x]])/',\n 'm/(?[[a-\\pM]])/' => 'False [] range \"a-\\pM\" {#} m/(?[[a-\\pM{#}]])/',\n 'm/(?[[\\pM-x]])/' => 'False [] range \"\\pM-\" {#} m/(?[[\\pM-{#}x]])/',\n 'm/(?[[^\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}]])/' => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/(?[[^\\N{U+100.300{#}}]])/',\n 'm/(?[ \\p{Digit} & (?(?[ \\p{Thai} | \\p{Lao} ]))])/' => 'Sequence (?(...) not recognized {#} m/(?[ \\p{Digit} & (?({#}?[ \\p{Thai} | \\p{Lao} ]))])/',\n 'm/(?[ \\p{Digit} & (?:(?[ \\p{Thai} | \\p{Lao} ]))])/' => 'Expecting \\'(?flags:(?[...\\' {#} m/(?[ \\p{Digit} & (?{#}:(?[ \\p{Thai} | \\p{Lao} ]))])/',\n 'm/\\o{/' => 'Missing right brace on \\o{ {#} m/\\o{{#}/',\n 'm/\\o/' => 'Missing braces on \\o{} {#} m/\\o{#}/',\n 'm/\\o{}/' => 'Number with no digits {#} m/\\o{}{#}/',\n 'm/[\\o{]/' => 'Missing right brace on \\o{ {#} m/[\\o{{#}]/',\n 'm/[\\o]/' => 'Missing braces on \\o{} {#} m/[\\o{#}]/',\n 'm/[\\o{}]/' => 'Number with no digits {#} m/[\\o{}{#}]/',\n 'm/(?^-i:foo)/' => 'Sequence (?^-...) not recognized {#} m/(?^-{#}i:foo)/',\n 'm/\\87/' => 'Reference to nonexistent group {#} m/\\87{#}/',\n 'm/a\\87/' => 'Reference to nonexistent group {#} m/a\\87{#}/',\n 'm/a\\97/' => 'Reference to nonexistent group {#} m/a\\97{#}/',\n 'm/(*DOOF)/' => 'Unknown verb pattern \\'DOOF\\' {#} m/(*DOOF){#}/',\n 'm/(?&a/'  => 'Sequence (?&... not terminated {#} m/(?&a{#}/',\n 'm/(?P=/' => 'Sequence ?P=... not terminated {#} m/(?P={#}/',\n \"m/(?'/\"  => \"Sequence (?'... not terminated {#} m/(?'{#}/\",\n \"m/(?</\"  => \"Sequence (?<... not terminated {#} m/(?<{#}/\",\n 'm/(?&/'  => 'Sequence (?&... not terminated {#} m/(?&{#}/',\n 'm/(?(</' => 'Sequence (?(<... not terminated {#} m/(?(<{#}/',\n \"m/(?('/\" => \"Sequence (?('... not terminated {#} m/(?('{#}/\",\n 'm/\\g{/'  => 'Sequence \\g{... not terminated {#} m/\\g{{#}/',\n 'm/\\k</'  => 'Sequence \\k<... not terminated {#} m/\\k<{#}/',\n 'm/\\c\u00df/' => \"Character following \\\"\\\\c\\\" must be printable ASCII\",\n '/((?# This is a comment in the middle of a token)?:foo)/' => 'In \\'(?...)\\', the \\'(\\' and \\'?\\' must be adjacent {#} m/((?# This is a comment in the middle of a token)?{#}:foo)/',\n '/((?# This is a comment in the middle of a token)*FAIL)/' => 'In \\'(*VERB...)\\', the \\'(\\' and \\'*\\' must be adjacent {#} m/((?# This is a comment in the middle of a token)*{#}FAIL)/',\n '/(?[\\ &!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ &!{#}])/',    # [perl #126180]\n '/(?[\\ +!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ +!{#}])/',    # [perl #126180]\n '/(?[\\ -!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ -!{#}])/',    # [perl #126180]\n '/(?[\\ ^!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ ^!{#}])/',    # [perl #126180]\n '/(?[\\ |!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ |!{#}])/',    # [perl #126180]\n '/(?[()-!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[(){#}-!])/',    # [perl #126204]\n '/(?[!()])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[!(){#}])/',      # [perl #126404]\n '/\\w{/' => 'Unescaped left brace in regex is illegal here {#} m/\\w{{#}/',\n '/\\q{/' => 'Unescaped left brace in regex is illegal here {#} m/\\q{{#}/',\n '/\\A{/' => 'Unescaped left brace in regex is illegal here {#} m/\\A{{#}/',\n '/abc/xix' => \"\",\n '/(?xmsixp:abc)/' => \"\",\n '/(?xmsixp)abc/' => \"\",\n '/(?xxxx:abc)/' => \"\",\n '/(?<=/' => 'Sequence (?... not terminated {#} m/(?<={#}/',                        # [perl #128170]\n\n);\n\n# These are messages that are warnings when not strict; death under 'use re\n# \"strict\".  See comment before @warnings as to why some have a \\x{100} in\n# them.  This array has 3 elements per construct.  [0] is the regex to use;\n# [1] is the message under no strict, and [2] is under strict.\nmy @death_only_under_strict = (\n    'm/\\xABC/' => \"\",\n               => 'Use \\x{...} for more than two hex characters {#} m/\\xABC{#}/',\n    'm/[\\xABC]/' => \"\",\n                 => 'Use \\x{...} for more than two hex characters {#} m/[\\xABC{#}]/',\n\n    # XXX This is a confusing error message.  The G isn't ignored; it just\n    # terminates the \\x.  Also some messages below are missing the <-- HERE,\n    # aren't all category 'regexp'.  (Hence we have to turn off 'digit'\n    # messages as well below)\n    'm/\\xAG/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n              => 'Non-hex character {#} m/\\xAG{#}/',\n    'm/[\\xAG]/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n                => 'Non-hex character {#} m/[\\xAG{#}]/',\n    'm/\\o{789}/' => 'Non-octal character \\'8\\'.  Resolved as \"\\o{7}\"',\n                 => 'Non-octal character {#} m/\\o{78{#}9}/',\n    'm/[\\o{789}]/' => 'Non-octal character \\'8\\'.  Resolved as \"\\o{7}\"',\n                   => 'Non-octal character {#} m/[\\o{78{#}9}]/',\n    'm/\\x{}/' => \"\",\n              => 'Number with no digits {#} m/\\x{}{#}/',\n    'm/[\\x{}]/' => \"\",\n                => 'Number with no digits {#} m/[\\x{}{#}]/',\n    'm/\\x{ABCDEFG}/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n                     => 'Non-hex character {#} m/\\x{ABCDEFG{#}}/',\n    'm/[\\x{ABCDEFG}]/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n                       => 'Non-hex character {#} m/[\\x{ABCDEFG{#}}]/',\n    \"m'[\\\\y]\\\\x{100}'\" => 'Unrecognized escape \\y in character class passed through {#} m/[\\y{#}]\\x{100}/',\n                       => 'Unrecognized escape \\y in character class {#} m/[\\y{#}]\\x{100}/',\n    'm/[a-\\d]\\x{100}/' => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n                       => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n    'm/[\\w-x]\\x{100}/' => 'False [] range \"\\w-\" {#} m/[\\w-{#}x]\\x{100}/',\n                       => 'False [] range \"\\w-\" {#} m/[\\w-{#}x]\\x{100}/',\n    'm/[a-\\pM]\\x{100}/' => 'False [] range \"a-\\pM\" {#} m/[a-\\pM{#}]\\x{100}/',\n                        => 'False [] range \"a-\\pM\" {#} m/[a-\\pM{#}]\\x{100}/',\n    'm/[\\pM-x]\\x{100}/' => 'False [] range \"\\pM-\" {#} m/[\\pM-{#}x]\\x{100}/',\n                        => 'False [] range \"\\pM-\" {#} m/[\\pM-{#}x]\\x{100}/',\n    'm/[^\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}]/' => 'Using just the first character returned by \\N{} in character class {#} m/[^\\N{U+100.300}{#}]/',\n                                       => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/[^\\N{U+100.300{#}}]/',\n    'm/[\\x03-\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}]/' => 'Using just the first character returned by \\N{} in character class {#} m/[\\x03-\\N{U+100.300}{#}]/',\n                                            => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/[\\x03-\\N{U+100.300{#}}]/',\n    'm/[\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}-\\x{10FFFF}]/' => 'Using just the first character returned by \\N{} in character class {#} m/[\\N{U+100.300}{#}-\\x{10FFFF}]/',\n                                                  => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/[\\N{U+100.300{#}}-\\x{10FFFF}]/',\n    '/[\\08]/'   => '\\'\\08\\' resolved to \\'\\o{0}8\\' {#} m/[\\08{#}]/',\n                => 'Need exactly 3 octal digits {#} m/[\\08{#}]/',\n    '/[\\018]/'  => '\\'\\018\\' resolved to \\'\\o{1}8\\' {#} m/[\\018{#}]/',\n                => 'Need exactly 3 octal digits {#} m/[\\018{#}]/',\n    '/[\\_\\0]/'  => \"\",\n                => 'Need exactly 3 octal digits {#} m/[\\_\\0]{#}/',\n    '/[\\07]/'   => \"\",\n                => 'Need exactly 3 octal digits {#} m/[\\07]{#}/',\n    '/[\\0005]/' => \"\",\n                => 'Need exactly 3 octal digits {#} m/[\\0005]{#}/',\n    '/[\\8\\9]\\x{100}/' => ['Unrecognized escape \\8 in character class passed through {#} m/[\\8{#}\\9]\\x{100}/',\n                          'Unrecognized escape \\9 in character class passed through {#} m/[\\8\\9{#}]\\x{100}/',\n                         ],\n                      => 'Unrecognized escape \\8 in character class {#} m/[\\8{#}\\9]\\x{100}/',\n    '/[a-\\d]\\x{100}/' => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n                      => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n    '/[\\d-b]\\x{100}/' => 'False [] range \"\\d-\" {#} m/[\\d-{#}b]\\x{100}/',\n                      => 'False [] range \"\\d-\" {#} m/[\\d-{#}b]\\x{100}/',\n    '/[\\s-\\d]\\x{100}/' => 'False [] range \"\\s-\" {#} m/[\\s-{#}\\d]\\x{100}/',\n                       => 'False [] range \"\\s-\" {#} m/[\\s-{#}\\d]\\x{100}/',\n    '/[\\d-\\s]\\x{100}/' => 'False [] range \"\\d-\" {#} m/[\\d-{#}\\s]\\x{100}/',\n                       => 'False [] range \"\\d-\" {#} m/[\\d-{#}\\s]\\x{100}/',\n    '/[a-[:digit:]]\\x{100}/' => 'False [] range \"a-[:digit:]\" {#} m/[a-[:digit:]{#}]\\x{100}/',\n                             => 'False [] range \"a-[:digit:]\" {#} m/[a-[:digit:]{#}]\\x{100}/',\n    '/[[:digit:]-b]\\x{100}/' => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}b]\\x{100}/',\n                             => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}b]\\x{100}/',\n    '/[[:alpha:]-[:digit:]]\\x{100}/' => 'False [] range \"[:alpha:]-\" {#} m/[[:alpha:]-{#}[:digit:]]\\x{100}/',\n                                     => 'False [] range \"[:alpha:]-\" {#} m/[[:alpha:]-{#}[:digit:]]\\x{100}/',\n    '/[[:digit:]-[:alpha:]]\\x{100}/' => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}[:alpha:]]\\x{100}/',\n                                     => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}[:alpha:]]\\x{100}/',\n    '/[a\\zb]\\x{100}/' => 'Unrecognized escape \\z in character class passed through {#} m/[a\\z{#}b]\\x{100}/',\n                      => 'Unrecognized escape \\z in character class {#} m/[a\\z{#}b]\\x{100}/',\n    'default_on/:{4,a}/'     => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/:{{#}4,a}/',\n                             => 'Unescaped left brace in regex is illegal here {#} m/:{{#}4,a}/',\n    'default_on/xa{3\\,4}y/'  => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/xa{{#}3\\,4}y/',\n                             => 'Unescaped left brace in regex is illegal here {#} m/xa{{#}3\\,4}y/',\n  'default_on/\\\\${[^\\\\}]*}/' => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/\\\\${{#}[^\\\\}]*}/',\n                             => 'Unescaped left brace in regex is illegal here {#} m/\\\\${{#}[^\\\\}]*}/',\n);\n\n# These need the character '\u30cd' as a marker for mark_as_utf8()\nmy @death_utf8 = mark_as_utf8(\n '/\u30cd(?<= .*)/' =>  'Variable length lookbehind not implemented in regex m/\u30cd(?<= .*)/',\n\n '/(?<= \u30cd{1000})/' => 'Lookbehind longer than 255 not implemented in regex m/(?<= \u30cd{1000})/',\n\n '/\u30cd(?\u30cd)\u30cd/' => 'Sequence (?\u30cd...) not recognized {#} m/\u30cd(?\u30cd{#})\u30cd/',\n\n '/\u30cd(?(1\u30cd))\u30cd/' => 'Switch condition not recognized {#} m/\u30cd(?(1\u30cd{#}))\u30cd/',\n\n '/(?(1)\u30cd|y|\u30cc)/' => 'Switch (?(condition)... contains too many branches {#} m/(?(1)\u30cd|y|{#}\u30cc)/',\n\n '/(?(\u30cd)y|\u30cd)/' => 'Unknown switch condition (?(...)) {#} m/(?(\u30cd{#})y|\u30cd)/',\n\n '/\u30cd(?/' => 'Sequence (? incomplete {#} m/\u30cd(?{#}/',\n\n '/\u30cd(?;\u30cd/' => 'Sequence (?;...) not recognized {#} m/\u30cd(?;{#}\u30cd/',\n '/\u30cd(?<;\u30cd/' => 'Group name must start with a non-digit word character {#} m/\u30cd(?<;{#}\u30cd/',\n '/\u30cd(?\\ix\u30cd/' => 'Sequence (?\\...) not recognized {#} m/\u30cd(?\\{#}ix\u30cd/',\n '/\u30cd(?^lu:\u30cd)/' => 'Regexp modifiers \"l\" and \"u\" are mutually exclusive {#} m/\u30cd(?^lu{#}:\u30cd)/',\n'/\u30cd(?lil:\u30cd)/' => 'Regexp modifier \"l\" may not appear twice {#} m/\u30cd(?lil{#}:\u30cd)/',\n'/\u30cd(?aaia:\u30cd)/' => 'Regexp modifier \"a\" may appear a maximum of twice {#} m/\u30cd(?aaia{#}:\u30cd)/',\n'/\u30cd(?i-l:\u30cd)/' => 'Regexp modifier \"l\" may not appear after the \"-\" {#} m/\u30cd(?i-l{#}:\u30cd)/',\n\n '/\u30cd((\u30cd)/' => 'Unmatched ( {#} m/\u30cd({#}(\u30cd)/',\n\n \"/\u30cd{$inf_p1}\u30cd/\" => \"Quantifier in {,} bigger than $inf_m1 {#} m/\u30cd{{#}$inf_p1}\u30cd/\",\n\n\n '/\u30cd**\u30cd/' => 'Nested quantifiers {#} m/\u30cd**{#}\u30cd/',\n\n '/\u30cd[\u30cd/' => 'Unmatched [ {#} m/\u30cd[{#}\u30cd/',\n\n '/*\u30cd/', => 'Quantifier follows nothing {#} m/*{#}\u30cd/',\n\n '/\u30cd\\p{\u30cd/' => 'Missing right brace on \\p{} {#} m/\u30cd\\p{{#}\u30cd/',\n\n '/(\u30cd)\\2\u30cd/' => 'Reference to nonexistent group {#} m/(\u30cd)\\2{#}\u30cd/',\n\n '/\\g{\u30cd/; #no latin1' => 'Sequence \\g{... not terminated {#} m/\\g{\u30cd{#}/',\n\n 'my $m = \"\u30cd\\\\\\\"; $m =~ $m', => 'Trailing \\ in regex m/\u30cd\\/',\n\n '/\\x{\u30cd/' => 'Missing right brace on \\x{} {#} m/\\x{{#}\u30cd/',\n '/\u30cd[\\x{\u30cd]\u30cd/' => 'Missing right brace on \\x{} {#} m/\u30cd[\\x{{#}\u30cd]\u30cd/',\n '/\u30cd[\\x{\u30cd]/' => 'Missing right brace on \\x{} {#} m/\u30cd[\\x{{#}\u30cd]/',\n\n '/\u30cd\\o{\u30cd/' => 'Missing right brace on \\o{ {#} m/\u30cd\\o{{#}\u30cd/',\n '/\u30cd[[:\u30cd:]]\u30cd/' => \"\",\n\n '/[\u30cd-a]\u30cd/' => 'Invalid [] range \"\u30cd-a\" {#} m/[\u30cd-a{#}]\u30cd/',\n\n '/\u30cd\\p{}\u30cd/' => 'Empty \\p{} {#} m/\u30cd\\p{{#}}\u30cd/',\n\n '/\u30cd(?[[[:\u30cd]]])\u30cd/' => \"Syntax error in (?[...]) in regex m/\u30cd(?[[[:\u30cd]]])\u30cd/\",\n '/\u30cd(?[[[:\u30cd: ])\u30cd/' => \"Syntax error in (?[...]) in regex m/\u30cd(?[[[:\u30cd: ])\u30cd/\",\n '/\u30cd(?[[[::]]])\u30cd/' => \"Syntax error in (?[...]) in regex m/\u30cd(?[[[::]]])\u30cd/\",\n '/\u30cd(?[[[:\u30cd:]]])\u30cd/' => \"Syntax error in (?[...]) in regex m/\u30cd(?[[[:\u30cd:]]])\u30cd/\",\n '/\u30cd(?[[:\u30cd:]])\u30cd/' => \"\",\n '/\u30cd(?[\u30cd])\u30cd/' =>  'Unexpected character {#} m/\u30cd(?[\u30cd{#}])\u30cd/',\n '/\u30cd(?[ + [\u30cd] ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/\u30cd(?[ +{#} [\u30cd] ])/',\n '/\u30cd(?[ \\cK - ( + [\u30cd] ) ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/\u30cd(?[ \\cK - ( +{#} [\u30cd] ) ])/',\n '/\u30cd(?[ \\cK ( [\u30cd] ) ])/' => 'Unexpected \\'(\\' with no preceding operator {#} m/\u30cd(?[ \\cK ({#} [\u30cd] ) ])/',\n '/\u30cd(?[ \\cK [\u30cd] ])\u30cd/' => 'Operand with no preceding operator {#} m/\u30cd(?[ \\cK [\u30cd{#}] ])\u30cd/',\n '/\u30cd(?[ \\0004 ])\u30cd/' => 'Need exactly 3 octal digits {#} m/\u30cd(?[ \\0004 {#}])\u30cd/',\n '/(?[ \\o{\u30cd} ])\u30cd/' => 'Non-octal character {#} m/(?[ \\o{\u30cd{#}} ])\u30cd/',\n '/\u30cd(?[ \\o{} ])\u30cd/' => 'Number with no digits {#} m/\u30cd(?[ \\o{}{#} ])\u30cd/',\n '/(?[ \\x{\u30cd} ])\u30cd/' => 'Non-hex character {#} m/(?[ \\x{\u30cd{#}} ])\u30cd/',\n '/(?[ \\p{\u30cd} ])/' => 'Can\\'t find Unicode property definition \"\u30cd\" {#} m/(?[ \\p{\u30cd}{#} ])/',\n '/(?[ \\p{ \u30cd = bar } ])/' => 'Can\\'t find Unicode property definition \"\u30cd = bar\" {#} m/(?[ \\p{ \u30cd = bar }{#} ])/',\n '/\u30cd(?[ \\t ]/' => 'Syntax error in (?[...]) in regex m/\u30cd(?[ \\t ]/',\n '/(?[ \\t + \\e # \u30cd This was supposed to be a comment ])/' => 'Syntax error in (?[...]) in regex m/(?[ \\t + \\e # \u30cd This was supposed to be a comment ])/',\n 'm/(*\u30cd)\u30cd/' => q<Unknown verb pattern '\u30cd' {#} m/(*\u30cd){#}\u30cd/>,\n '/\\c\u30cd/' => \"Character following \\\"\\\\c\\\" must be printable ASCII\",\n '/\\b{\u30cd}/' => \"'\u30cd' is an unknown bound type {#} m/\\\\b{\u30cd{#}}/\",\n '/\\B{\u30cd}/' => \"'\u30cd' is an unknown bound type {#} m/\\\\B{\u30cd{#}}/\",\n);\npush @death, @death_utf8;\n\nmy @death_utf8_only_under_strict = (\n    \"m'\u30cd[\\\\y]\u30cd'\" => 'Unrecognized escape \\y in character class passed through {#} m/\u30cd[\\y{#}]\u30cd/',\n                   => 'Unrecognized escape \\y in character class {#} m/\u30cd[\\y{#}]\u30cd/',\n    'm/\u30cd[\u30cd-\\d]\u30cd/' => 'False [] range \"\u30cd-\\d\" {#} m/\u30cd[\u30cd-\\d{#}]\u30cd/',\n                     => 'False [] range \"\u30cd-\\d\" {#} m/\u30cd[\u30cd-\\d{#}]\u30cd/',\n    'm/\u30cd[\\w-\u30cd]\u30cd/' => 'False [] range \"\\w-\" {#} m/\u30cd[\\w-{#}\u30cd]\u30cd/',\n                     => 'False [] range \"\\w-\" {#} m/\u30cd[\\w-{#}\u30cd]\u30cd/',\n    'm/\u30cd[\u30cd-\\pM]\u30cd/' => 'False [] range \"\u30cd-\\pM\" {#} m/\u30cd[\u30cd-\\pM{#}]\u30cd/',\n                      => 'False [] range \"\u30cd-\\pM\" {#} m/\u30cd[\u30cd-\\pM{#}]\u30cd/',\n    '/\u30cd[\u30cd-[:digit:]]\u30cd/' => 'False [] range \"\u30cd-[:digit:]\" {#} m/\u30cd[\u30cd-[:digit:]{#}]\u30cd/',\n                           => 'False [] range \"\u30cd-[:digit:]\" {#} m/\u30cd[\u30cd-[:digit:]{#}]\u30cd/',\n    '/\u30cd[\\d-\\s]\u30cd/' => 'False [] range \"\\d-\" {#} m/\u30cd[\\d-{#}\\s]\u30cd/',\n                    => 'False [] range \"\\d-\" {#} m/\u30cd[\\d-{#}\\s]\u30cd/',\n    '/\u30cd[a\\zb]\u30cd/' => 'Unrecognized escape \\z in character class passed through {#} m/\u30cd[a\\z{#}b]\u30cd/',\n                   => 'Unrecognized escape \\z in character class {#} m/\u30cd[a\\z{#}b]\u30cd/',\n);\n# Tests involving a user-defined charnames translator are in pat_advanced.t\n\n# In the following arrays of warnings, the value can be an array of things to\n# expect.  If the empty string, it means no warning should be raised.\n\n\n# Key-value pairs of code/error of code that should have non-fatal regexp\n# warnings.  Most currently have \\x{100} appended to them to force them to be\n# upgraded to UTF-8, and the first pass restarted.  Previously this would\n# cause some warnings to be output twice.  This tests that that behavior has\n# been fixed.\n\nmy @warning = (\n    'm/\\b*\\x{100}/' => '\\b* matches null string many times {#} m/\\b*{#}\\x{100}/',\n    '/\\b{g}/a' => \"Using /u for '\\\\b{g}' instead of /a {#} m/\\\\b{g}{#}/\",\n    '/\\B{gcb}/a' => \"Using /u for '\\\\B{gcb}' instead of /a {#} m/\\\\B{gcb}{#}/\",\n    'm/[:blank:]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes {#} m/[:blank:]{#}\\x{100}/',\n    'm/[[:cntrl:]][:^ascii:]\\x{100}/' =>  'POSIX syntax [: :] belongs inside character classes {#} m/[[:cntrl:]][:^ascii:]{#}\\x{100}/',\n    'm/[[:ascii]]\\x{100}/' => \"Assuming NOT a POSIX class since there is no terminating ':' {#} m/[[:ascii{#}]]\\\\x{100}/\",\n    'm/(?[[:word]])\\x{100}/' => \"Assuming NOT a POSIX class since there is no terminating ':' {#} m/(?[[:word{#}]])\\\\x{100}/\",\n    \"m'\\\\y\\\\x{100}'\"     => 'Unrecognized escape \\y passed through {#} m/\\y{#}\\x{100}/',\n    '/x{3,1}/'   => 'Quantifier {n,m} with n > m can\\'t match {#} m/x{3,1}{#}/',\n    '/\\08/' => '\\'\\08\\' resolved to \\'\\o{0}8\\' {#} m/\\08{#}/',\n    '/\\018/' => '\\'\\018\\' resolved to \\'\\o{1}8\\' {#} m/\\018{#}/',\n    '/(?=a)*/' => '(?=a)* matches null string many times {#} m/(?=a)*{#}/',\n    'my $x = \\'\\m\\'; qr/a$x/' => 'Unrecognized escape \\m passed through {#} m/a\\m{#}/',\n    '/\\q/' => 'Unrecognized escape \\q passed through {#} m/\\q{#}/',\n\n    # These two tests do not include the marker, because regcomp.c no\n    # longer knows where it goes by the time this warning is emitted.\n    # See [perl #122680] regcomp warning gives wrong position of\n    # problem.\n    '/(?=a){1,3}\\x{100}/' => 'Quantifier unexpected on zero-length expression in regex m/(?=a){1,3}\\x{100}/',\n    '/(a|b)(?=a){3}\\x{100}/' => 'Quantifier unexpected on zero-length expression in regex m/(a|b)(?=a){3}\\x{100}/',\n\n    '/\\_/' => \"\",\n    '/[\\006]/' => \"\",\n    '/[:alpha:]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes {#} m/[:alpha:]{#}\\x{100}/',\n    '/[:zog:]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes (but this one isn\\'t fully valid) {#} m/[:zog:]{#}\\x{100}/',\n    '/[.zog.]\\x{100}/' => 'POSIX syntax [. .] belongs inside character classes (but this one isn\\'t implemented) {#} m/[.zog.]{#}\\x{100}/',\n    '/[a-b]/' => \"\",\n    '/(?c)\\x{100}/' => 'Useless (?c) - use /gc modifier {#} m/(?c{#})\\x{100}/',\n    '/(?-c)\\x{100}/' => 'Useless (?-c) - don\\'t use /gc modifier {#} m/(?-c{#})\\x{100}/',\n    '/(?g)\\x{100}/' => 'Useless (?g) - use /g modifier {#} m/(?g{#})\\x{100}/',\n    '/(?-g)\\x{100}/' => 'Useless (?-g) - don\\'t use /g modifier {#} m/(?-g{#})\\x{100}/',\n    '/(?o)\\x{100}/' => 'Useless (?o) - use /o modifier {#} m/(?o{#})\\x{100}/',\n    '/(?-o)\\x{100}/' => 'Useless (?-o) - don\\'t use /o modifier {#} m/(?-o{#})\\x{100}/',\n    '/(?g-o)\\x{100}/' => [ 'Useless (?g) - use /g modifier {#} m/(?g{#}-o)\\x{100}/',\n                    'Useless (?-o) - don\\'t use /o modifier {#} m/(?g-o{#})\\x{100}/',\n                  ],\n    '/(?g-c)\\x{100}/' => [ 'Useless (?g) - use /g modifier {#} m/(?g{#}-c)\\x{100}/',\n                    'Useless (?-c) - don\\'t use /gc modifier {#} m/(?g-c{#})\\x{100}/',\n                  ],\n      # (?c) means (?g) error won't be thrown\n     '/(?o-cg)\\x{100}/' => [ 'Useless (?o) - use /o modifier {#} m/(?o{#}-cg)\\x{100}/',\n                      'Useless (?-c) - don\\'t use /gc modifier {#} m/(?o-c{#}g)\\x{100}/',\n                    ],\n    '/(?ogc)\\x{100}/' => [ 'Useless (?o) - use /o modifier {#} m/(?o{#}gc)\\x{100}/',\n                    'Useless (?g) - use /g modifier {#} m/(?og{#}c)\\x{100}/',\n                    'Useless (?c) - use /gc modifier {#} m/(?ogc{#})\\x{100}/',\n                  ],\n    '/a{1,1}?\\x{100}/' => 'Useless use of greediness modifier \\'?\\' {#} m/a{1,1}?{#}\\x{100}/',\n    \"/(?[ [ % - % ] ])/\" => \"\",\n    \"/(?[ [ : - \\\\x$colon_hex ] ])\\\\x{100}/\" => \"\\\": - \\\\x$colon_hex \\\" is more clearly written simply as \\\":\\\" {#} m/(?[ [ : - \\\\x$colon_hex {#}] ])\\\\x{100}/\",\n    \"/(?[ [ \\\\x$colon_hex - : ] ])\\\\x{100}/\" => \"\\\"\\\\x$colon_hex\\ - : \\\" is more clearly written simply as \\\":\\\" {#} m/(?[ [ \\\\x$colon_hex - : {#}] ])\\\\x{100}/\",\n    \"/(?[ [ \\\\t - \\\\x$tab_hex ] ])\\\\x{100}/\" => \"\\\"\\\\t - \\\\x$tab_hex \\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/(?[ [ \\\\t - \\\\x$tab_hex {#}] ])\\\\x{100}/\",\n    \"/(?[ [ \\\\x$tab_hex - \\\\t ] ])\\\\x{100}/\" => \"\\\"\\\\x$tab_hex\\ - \\\\t \\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/(?[ [ \\\\x$tab_hex - \\\\t {#}] ])\\\\x{100}/\",\n    \"/(?[ [ $B_hex - C ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ $B_hex - C {#}] ])/\",\n    \"/(?[ [ A - $B_hex ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ A - $B_hex {#}] ])/\",\n    \"/(?[ [ $low_mixed_alpha - $high_mixed_alpha ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ $low_mixed_alpha - $high_mixed_alpha {#}] ])/\",\n    \"/(?[ [ $low_mixed_digit - $high_mixed_digit ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ $low_mixed_digit - $high_mixed_digit {#}] ])/\",\n    \"/[alnum]/\" => \"\",\n    \"/[^alnum]/\" => \"\",\n    '/[:blank]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes (but this one isn\\'t fully valid) {#} m/[:blank{#}]\\x{100}/',\n    '/[[:digit]]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[:digit{#}]]\\x{100}/', # [perl # 8904]\n    '/[[:digit:foo]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\']\\' {#} m/[[:digit:{#}foo]\\x{100}/',\n    '/[[:di#it:foo]\\x{100}/x' => 'Assuming NOT a POSIX class since there is no terminating \\']\\' {#} m/[[:di#it:{#}foo]\\x{100}/',\n    '/[[:dgit]]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[:dgit{#}]]\\x{100}/',\n    '/[[:dgit:foo]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\']\\' {#} m/[[:dgit:{#}foo]\\x{100}/',\n    '/[[:dgt]]\\x{100}/' => \"\",      # Far enough away from a real class to not be recognized as one\n    '/[[:dgt:foo]\\x{100}/' => \"\",\n    '/[[:DIGIT]]\\x{100}/' => [ 'Assuming NOT a POSIX class since the name must be all lowercase letters {#} m/[[:DIGIT{#}]]\\x{100}/',\n                               'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[:DIGIT{#}]]\\x{100}/',\n                           ],\n    '/[[digit]\\x{100}/' => [ 'Assuming NOT a POSIX class since there must be a starting \\':\\' {#} m/[[{#}digit]\\x{100}/',\n                             'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[digit{#}]\\x{100}/',\n                           ],\n    '/[[alpha]]\\x{100}/' => [ 'Assuming NOT a POSIX class since there must be a starting \\':\\' {#} m/[[{#}alpha]]\\x{100}/',\n                              'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[alpha{#}]]\\x{100}/',\n                           ],\n    '/[[^word]\\x{100}/' => [ 'Assuming NOT a POSIX class since the \\'^\\' must come after the colon {#} m/[[^{#}word]\\x{100}/',\n                              'Assuming NOT a POSIX class since there must be a starting \\':\\' {#} m/[[^{#}word]\\x{100}/',\n                              'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[^word{#}]\\x{100}/',\n                            ],\n    '/[[   ^   :   x d i g i t   :   ]   ]\\x{100}/' => [ 'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   {#}^   :   x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since the \\'^\\' must come after the colon {#} m/[[   ^{#}   :   x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   ^   {#}:   x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   ^   :   {#}x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   ^   :   x d i g i t   :   ]{#}   ]\\x{100}/',\n                                               $only_strict_marker . 'Unescaped literal \\']\\' {#} m/[[   ^   :   x d i g i t   :   ]   ]{#}\\x{100}/',\n                            ],\n    '/[foo:lower:]]\\x{100}/' => 'Assuming NOT a POSIX class since it doesn\\'t start with a \\'[\\' {#} m/[foo{#}:lower:]]\\x{100}/',\n    '/[[;upper;]]\\x{100}/' => [ 'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[[;{#}upper;]]\\x{100}/',\n                                'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[[;upper;]{#}]\\x{100}/',\n                              ],\n    '/[foo;punct;]]\\x{100}/' => [ 'Assuming NOT a POSIX class since it doesn\\'t start with a \\'[\\' {#} m/[foo{#};punct;]]\\x{100}/',\n                                  'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[foo;{#}punct;]]\\x{100}/',\n                                  'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[foo;punct;]{#}]\\x{100}/',\n                                ],\n   '/[][[:alpha:]]/' => \"\",        # [perl #127581]\n   '/[][[:alpha:]\\\\@\\\\\\\\^_?]/' => \"\", # [perl #131522]\n); # See comments before this for why '\\x{100}' is generally needed\n\n# These need the character '\u30cd' as a marker for mark_as_utf8()\nmy @warnings_utf8 = mark_as_utf8(\n    'm/\u30cd\\b*\u30cd/' => '\\b* matches null string many times {#} m/\u30cd\\b*{#}\u30cd/',\n    '/(?=\u30cd)*/' => '(?=\u30cd)* matches null string many times {#} m/(?=\u30cd)*{#}/',\n    'm/\u30cd[:foo:]\u30cd/' => 'POSIX syntax [: :] belongs inside character classes (but this one isn\\'t fully valid) {#} m/\u30cd[:foo:]{#}\u30cd/',\n    '/\u30cd(?c)\u30cd/' => 'Useless (?c) - use /gc modifier {#} m/\u30cd(?c{#})\u30cd/',\n    '/utf8 \u30cd (?ogc) \u30cd/' => [\n        'Useless (?o) - use /o modifier {#} m/utf8 \u30cd (?o{#}gc) \u30cd/',\n        'Useless (?g) - use /g modifier {#} m/utf8 \u30cd (?og{#}c) \u30cd/',\n        'Useless (?c) - use /gc modifier {#} m/utf8 \u30cd (?ogc{#}) \u30cd/',\n    ],\n\n);\n\npush @warning, @warnings_utf8;\n\nmy @warning_only_under_strict = (\n    '/[\\N{U+00}-\\x01]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+00}-\\x01{#}]\\x{100}/',\n    '/[\\x00-\\N{SOH}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\x00-\\N{U+01}{#}]\\x{100}/',\n    '/[\\N{DEL}-\\o{377}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+7F}-\\o{377}{#}]\\x{100}/',\n    '/[\\o{0}-\\N{U+01}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\o{0}-\\N{U+01}{#}]\\x{100}/',\n    '/[\\000-\\N{U+01}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\000-\\N{U+01}{#}]\\x{100}/',\n    '/[\\N{DEL}-\\377]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+7F}-\\377{#}]\\x{100}/',\n    '/[\\N{U+00}-A]\\x{100}/' => 'Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or \"a-z\" {#} m/[\\N{U+00}-A{#}]\\x{100}/',\n    '/[a-\\N{U+FF}]\\x{100}/' => 'Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or \"a-z\" {#} m/[a-\\N{U+FF}{#}]\\x{100}/',\n    '/[\\N{U+00}-\\a]\\x{100}/' => \"\",\n    '/[\\a-\\N{U+FF}]\\x{100}/' => \"\",\n    '/[\\N{U+FF}-\\x{100}]/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+FF}-\\x{100}{#}]/',\n    '/[\\N{U+100}-\\x{101}]/' => \"\",\n    \"/[%-%]/\" => \"\",\n    \"/[:-\\\\x$colon_hex]\\\\x{100}/\" => \"\\\":-\\\\x$colon_hex\\\" is more clearly written simply as \\\":\\\" {#} m/[:-\\\\x$colon_hex\\{#}]\\\\x{100}/\",\n    \"/[\\\\x$colon_hex-:]\\\\x{100}/\" => \"\\\"\\\\x$colon_hex-:\\\" is more clearly written simply as \\\":\\\" {#} m/[\\\\x$colon_hex\\-:{#}]\\\\x{100}/\",\n    \"/[\\\\t-\\\\x$tab_hex]\\\\x{100}/\" => \"\\\"\\\\t-\\\\x$tab_hex\\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/[\\\\t-\\\\x$tab_hex\\{#}]\\\\x{100}/\",\n    \"/[\\\\x$tab_hex-\\\\t]\\\\x{100}/\" => \"\\\"\\\\x$tab_hex-\\\\t\\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/[\\\\x$tab_hex\\-\\\\t{#}]\\\\x{100}/\",\n    \"/[$B_hex-C]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[$B_hex-C{#}]/\",\n    \"/[A-$B_hex]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[A-$B_hex\\{#}]/\",\n    \"/[$low_mixed_alpha-$high_mixed_alpha]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[$low_mixed_alpha-$high_mixed_alpha\\{#}]/\",\n    \"/[$low_mixed_digit-$high_mixed_digit]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[$low_mixed_digit-$high_mixed_digit\\{#}]/\",\n    '/\\b<GCB}/' => 'Unescaped literal \\'}\\' {#} m/\\b<GCB}{#}/',\n    '/[ ]def]/' => 'Unescaped literal \\']\\' {#} m/[ ]def]{#}/',\n);\n\nmy @warning_utf8_only_under_strict = mark_as_utf8(\n '/\u30cd[\u1a89-\u1a90]/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd[\u1a89-\u1a90{#}]/\",\n '/\u30cd(?[ [ \u1a89 - \u1a90 ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \u1a89 - \u1a90 {#}] ])/\",\n '/\u30cd[\u19d9-\u19da]/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd[\u19d9-\u19da{#}]/\",\n '/\u30cd(?[ [ \u19d9 - \u19da ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \u19d9 - \u19da {#}] ])/\",\n '/\u30cd(?[ [ \ud835\udfd8 - \ud835\udfe1 ] ])/; #no latin1' => \"\",\n '/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff1 ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff1 {#}] ])/\",\n '/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff0 ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff0 {#}] ])/\",\n);\n\npush @warning_only_under_strict, @warning_utf8_only_under_strict;\n\nmy @experimental_regex_sets = (\n    '/(?[ \\t ])/' => 'The regex_sets feature is experimental {#} m/(?[{#} \\t ])/',\n    'use utf8; /utf8 \u30cd (?[ [\\t\u30cd] ])/' => do { use utf8; 'The regex_sets feature is experimental {#} m/utf8 \u30cd (?[{#} [\\t\u30cd] ])/' },\n    '/noutf8 \u30cd (?[ [\\t\u30cd] ])/' => 'The regex_sets feature is experimental {#} m/noutf8 \u30cd (?[{#} [\\t\u30cd] ])/',\n);\n\nmy @deprecated = (\n '/^{/'          => \"\",\n '/foo|{/'       => \"\",\n '/foo|^{/'      => \"\",\n '/foo({bar)/'   => \"\",\n '/foo(:?{bar)/' => \"\",\n '/\\s*{/'        => \"\",\n '/a{3,4}{/'     => \"\",\n '/.{/'         => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/.{{#}/',\n '/[x]{/'       => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/[x]{{#}/',\n '/\\p{Latin}{/' => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/\\p{Latin}{{#}/',\n);\n\nfor my $strict (\"\", \"use re 'strict';\") {\n\n    # First time just use @death; but under strict we add the things that fail\n    # there.  Doing it this way makes sure that 'strict' doesnt change the\n    # things that are already fatal when not under strict.\n    if ($strict) {\n        for (my $i = 0; $i < @death_only_under_strict; $i += 3) {\n            push @death, $death_only_under_strict[$i],    # The regex\n                         $death_only_under_strict[$i+2];  # The fatal msg\n        }\n        for (my $i = 0; $i < @death_utf8_only_under_strict; $i += 3) {\n\n            # Same with the utf8 versions\n            push @death, mark_as_utf8($death_utf8_only_under_strict[$i],\n                                      $death_utf8_only_under_strict[$i+2]);\n        }\n    }\n    for (my $i = 0; $i < @death; $i += 2) {\n        my $regex = $death[$i] =~ s/ default_ (on | off) //rx;\n        my $expect = fixup_expect($death[$i+1], $strict);\n        no warnings 'experimental::regex_sets';\n        no warnings 'experimental::re_strict';\n\n        warning_is(sub {\n                    my $eval_string = \"$strict $regex\";\n                    $_ = \"x\";\n                    eval $eval_string;\n                    my $error= $@;\n                    if ($error =~ qr/\\Q$expect/) {\n                        ok(1,$eval_string);\n                    } else {\n                        ok(0,$eval_string);\n                        diag(\"Have: \" . _qq(add_markers($error)));\n                        diag(\"Want: \" . _qq($death[$i+1]));\n                    }\n                }, undef, \"... and died without any other warnings\");\n    }\n}\n\nfor my $strict (\"\",  \"no warnings 'experimental::re_strict'; use re 'strict';\") {\n    my @warning_tests = @warning;\n\n    # Build the tests for @warning.  Use the strict/non-strict versions\n    # appropriately.\n    if ($strict) {\n        push @warning_tests, @warning_only_under_strict;\n    }\n    else {\n        for (my $i = 0; $i < @warning_only_under_strict; $i += 2) {\n\n            # (?[ ]) are always under strict\n            if ($warning_only_under_strict[$i] =~ /\\Q(?[/) {\n                push @warning_tests, $warning_only_under_strict[$i],  # The regex\n                                    $warning_only_under_strict[$i+1];\n            }\n            else {\n                push @warning_tests, $warning_only_under_strict[$i],  # The regex\n                                    \"\";    # No warning because not strict\n            }\n        }\n        for (my $i = 0; $i < @death_only_under_strict; $i += 3) {\n            push @warning_tests, $death_only_under_strict[$i],    # The regex\n                                 $death_only_under_strict[$i+1];  # The warning\n        }\n        for (my $i = 0; $i < @death_utf8_only_under_strict; $i += 3) {\n            push @warning_tests, mark_as_utf8($death_utf8_only_under_strict[$i],\n                                        $death_utf8_only_under_strict[$i+1]);\n        }\n    }\n\n    foreach my $ref (\\@warning_tests, \\@experimental_regex_sets, \\@deprecated) {\n        my $warning_type;\n        my $turn_off_warnings = \"\";\n        my $default_on;\n        if ($ref == \\@warning_tests) {\n            $warning_type = 'regexp, digit';\n            $turn_off_warnings = \"no warnings 'experimental::regex_sets';\";\n            $default_on = $strict;\n        }\n        elsif ($ref == \\@deprecated) {\n            $warning_type = 'regexp, deprecated';\n            $default_on = 1;\n        }\n        else {\n            $warning_type = 'experimental::regex_sets';\n            $default_on = 1;\n        }\n        for (my $i = 0; $i < @$ref; $i += 2) {\n            my $this_default_on = $default_on;\n            my $regex = $ref->[$i];\n            if ($regex =~ s/ default_ (on | off) //x) {\n                $this_default_on = $1 eq 'on';\n            }\n            my @expect = fixup_expect($ref->[$i+1], $strict);\n\n            # A length-1 array with an empty warning means no warning gets\n            # generated at all.\n            undef @expect if @expect == 1 && $expect[0] eq \"\";\n\n            {\n                $_ = \"x\";\n                #use feature 'unicode_eval';\n                #print STDERR __LINE__, \": \", \"eval '$strict no warnings; $regex'\", \"\\n\";\n                eval \"$strict no warnings; $regex\";\n            }\n            if (is($@, \"\", \"$strict $regex did not die\")) {\n                my @got = capture_warnings(sub {\n                                        $_ = \"x\";\n                                        eval \"$strict $turn_off_warnings $regex\" });\n                my $count = @expect;\n                if (! is(scalar @got, scalar @expect,\n                            \"... and gave expected number ($count) of warnings\"))\n                {\n                    if (@got < @expect) {\n                        $count = @got;\n                        note \"Expected warnings not gotten:\\n\\t\" . join \"\\n\\t\",\n                                                    @expect[$count .. $#expect];\n                    }\n                    else {\n                        note \"Unexpected warnings gotten:\\n\\t\" . join(\"\\n\\t\",\n                                                         @got[$count .. $#got]);\n                    }\n                }\n                foreach my $i (0 .. $count - 1) {\n                    if (! like($got[$i], qr/\\Q$expect[$i]/,\n                                               \"... and gave expected warning\"))\n                    {\n                        chomp($got[$i]);\n                        chomp($expect[$i]);\n                        diag(\"GOT\\n'$got[$i]'\\nEXPECT\\n'$expect[$i]'\");\n                    }\n                    else {\n                        ok (0 == capture_warnings(sub {\n                            $_ = \"x\";\n                            eval \"$strict no warnings '$warning_type'; $regex;\" }\n                           ),\n                           \"... and turning off '$warning_type' warnings suppressed it\");\n\n                        # Test that whether the warning is on by default is\n                        # correct.  This test relies on the fact that we\n                        # are outside the scope of any \u2018use warnings\u2019.\n                        local $^W;\n                        my @warns = capture_warnings(sub { $_ = \"x\";\n                                                        eval \"$strict $regex\" });\n                        # Warning should be on as well if is testing\n                        # '(?[...])' which turns on strict\n                        if ($this_default_on || grep { $_ =~ /\\Q(?[/ } @expect ) {\n                           ok @warns > 0, \"... and the warning is on by default\";\n                        }\n                        else {\n                         ok @warns == 0, \"... and the warning is off by default\";\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\ndone_testing();\n", "#!./perl\n\n# This tests (?[...]).  XXX These are just basic tests, as full ones would be\n# best done with an infrastructure change to allow getting out the inversion\n# list of the constructed set and then comparing it character by character\n# with the expected result.\n\nBEGIN {\n    chdir 't' if -d 't';\n    require './test.pl';\n    require './charset_tools.pl';\n    require './loc_tools.pl';\n    set_up_inc( '../lib','.','../ext/re' );\n}\n\nskip_all_without_unicode_tables();\n\nuse strict;\nuse warnings;\n\n$| = 1;\n\nuse utf8;\nno warnings 'experimental::regex_sets';\n\nlike(\"a\", qr/(?[ [a]      # This is a comment\n                    ])/, 'Can ignore a comment');\nlike(\"a\", qr/(?[ [a]      # [[:notaclass:]]\n                    ])/, 'A comment isn\\'t parsed');\nunlike(uni_to_native(\"\\x85\"), qr/(?[ \\t\u0085 ])/, 'NEL is white space');\nlike(uni_to_native(\"\\x85\"), qr/(?[ \\t + \\\u0085 ])/, 'can escape NEL to match');\nlike(uni_to_native(\"\\x85\"), qr/(?[ [\\\u0085] ])/, '... including within nested []');\nlike(\"\\t\", qr/(?[ \\t + \\\u0085 ])/, 'can do basic union');\nlike(\"\\cK\", qr/(?[ \\s ])/, '\\s matches \\cK');\nunlike(\"\\cK\", qr/(?[ \\s - \\cK ])/, 'can do basic subtraction');\nlike(\" \", qr/(?[ \\s - \\cK ])/, 'can do basic subtraction');\nlike(\":\", qr/(?[ [:] ])/, '[:] is not a posix class');\nunlike(\"\\t\", qr/(?[ ! \\t ])/, 'can do basic complement');\nlike(\"\\t\", qr/(?[ ! [ ^ \\t ] ])/, 'can do basic complement');\nunlike(\"\\r\", qr/(?[ \\t ])/, '\\r doesn\\'t match \\t ');\nlike(\"\\r\", qr/(?[ ! \\t ])/, 'can do basic complement');\nlike(\"0\", qr/(?[ [:word:] & [:digit:] ])/, 'can do basic intersection');\nunlike(\"A\", qr/(?[ [:word:] & [:digit:] ])/, 'can do basic intersection');\nlike(\"0\", qr/(?[[:word:]&[:digit:]])/, 'spaces around internal [] aren\\'t required');\n\nlike(\"a\", qr/(?[ [a] | [b] ])/, '| means union');\nlike(\"b\", qr/(?[ [a] | [b] ])/, '| means union');\nunlike(\"c\", qr/(?[ [a] | [b] ])/, '| means union');\n\nlike(\"a\", qr/(?[ [ab] ^ [bc] ])/, 'basic symmetric difference works');\nunlike(\"b\", qr/(?[ [ab] ^ [bc] ])/, 'basic symmetric difference works');\nlike(\"c\", qr/(?[ [ab] ^ [bc] ])/, 'basic symmetric difference works');\n\nlike(\"2\", qr/(?[ ( ( \\pN & ( [a] + [2] ) ) ) ])/, 'Nesting parens and grouping');\nunlike(\"a\", qr/(?[ ( ( \\pN & ( [a] + [2] ) ) ) ])/, 'Nesting parens and grouping');\n\nunlike(\"\\x{17f}\", qr/(?[ [k] + \\p{Blk=ASCII} ])/i, '/i doesn\\'t affect \\p{}');\nlike(\"\\N{KELVIN SIGN}\", qr/(?[ [k] + \\p{Blk=ASCII} ])/i, '/i does affect literals');\n\nmy $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\nmy $thai_or_lao_digit = qr/(?[ \\p{Digit} & $thai_or_lao ])/;\nlike(\"\\N{THAI DIGIT ZERO}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{THAI DIGIT ZERO}\") - 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nlike(\"\\N{THAI DIGIT NINE}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{THAI DIGIT NINE}\") + 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nlike(\"\\N{LAO DIGIT ZERO}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{LAO DIGIT ZERO}\") - 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nlike(\"\\N{LAO DIGIT NINE}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{LAO DIGIT NINE}\") + 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\n\nmy $ascii_word = qr/(?[ \\w ])/a;\nmy $ascii_digits_plus_all_of_arabic = qr/(?[ \\p{Arabic} + \\p{Digit} & $ascii_word ])/;\nlike(\"9\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for ASCII in the set\");\nunlike(\"A\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for ASCII not in the set\");\nunlike(\"\\N{BENGALI DIGIT ZERO}\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for non-ASCII not in either set\");\nunlike(\"\\N{BENGALI LETTER A}\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for non-ASCII in one set\");\nlike(\"\\N{ARABIC LETTER HAMZA}\", $ascii_digits_plus_all_of_arabic, \"intersection has higher precedence than union\");\nlike(\"\\N{EXTENDED ARABIC-INDIC DIGIT ZERO}\", $ascii_digits_plus_all_of_arabic, \"intersection has higher precedence than union\");\n\nlike(\"\\r\", qr/(?[ \\p{lb=cr} ])/, '\\r matches \\p{lb=cr}');\nunlike(\"\\r\", qr/(?[ ! \\p{lb=cr} ])/, '\\r doesnt match ! \\p{lb=cr}');\nlike(\"\\r\", qr/(?[ ! ! \\p{lb=cr} ])/, 'Two ! ! are the original');\nunlike(\"\\r\", qr/(?[ ! ! ! \\p{lb=cr} ])/, 'Three ! ! ! are the complement');\n# left associatve\n\nmy $kelvin = qr/(?[ \\N{KELVIN SIGN} ])/;\nmy $fold = qr/(?[ $kelvin ])/i;\nlike(\"\\N{KELVIN SIGN}\", $kelvin, '\"\\N{KELVIN SIGN}\" matches compiled qr/(?[ \\N{KELVIN SIGN} ])/');\nunlike(\"K\", $fold, \"/i on outer (?[ ]) doesn't leak to interpolated one\");\nunlike(\"k\", $fold, \"/i on outer (?[ ]) doesn't leak to interpolated one\");\n\nmy $kelvin_fold = qr/(?[ \\N{KELVIN SIGN} ])/i;\nmy $still_fold = qr/(?[ $kelvin_fold ])/;\nlike(\"K\", $still_fold, \"/i on interpolated (?[ ]) is retained in outer without /i\");\nlike(\"k\", $still_fold, \"/i on interpolated (?[ ]) is retained in outer without /i\");\n\neval 'my $x = qr/(?[ [a] ])/; qr/(?[ $x ])/';\nis($@, \"\", 'qr/(?[ [a] ])/ can be interpolated');\n\nlike(\"B\", qr/(?[ [B] | ! ( [^B] ) ])/, \"[perl #125892]\");\n\nlike(\"a\", qr/(?[ (?#comment) [a]])/, \"Can have (?#comments)\");\n\nif (! is_miniperl() && locales_enabled('LC_CTYPE')) {\n    my $utf8_locale = find_utf8_ctype_locale;\n    SKIP: {\n        skip(\"No utf8 locale available on this platform\", 8) unless $utf8_locale;\n\n        setlocale(&POSIX::LC_ALL, \"C\");\n        use locale;\n\n        $kelvin_fold = qr/(?[ \\N{KELVIN SIGN} ])/i;\n        my $single_char_class = qr/(?[ \\: ])/;\n\n        setlocale(&POSIX::LC_ALL, $utf8_locale);\n\n        like(\"\\N{KELVIN SIGN}\", $kelvin_fold,\n             '(?[ \\N{KELVIN SIGN} ]) matches itself under /i in UTF8-locale');\n        like(\"K\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"K\" under /i in UTF8-locale');\n        like(\"k\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"k\" under /i in UTF8-locale');\n        like(\":\", $single_char_class,\n             '(?[ : ]) matches itself in UTF8-locale (a single character class)');\n\n        setlocale(&POSIX::LC_ALL, \"C\");\n\n        # These should generate warnings (the above 4 shouldn't), but like()\n        # suppresses them, so the warnings tests are in t/lib/warnings/regexec\n        $^W = 0;   # Suppress the warnings that occur when run by hand with\n                   # the -w option\n        like(\"\\N{KELVIN SIGN}\", $kelvin_fold,\n             '(?[ \\N{KELVIN SIGN} ]) matches itself under /i in C locale');\n        like(\"K\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"K\" under /i in C locale');\n        like(\"k\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"k\" under /i in C locale');\n        like(\":\", $single_char_class,\n             '(?[ : ]) matches itself in C locale (a single character class)');\n    }\n}\n\n# Tests that no warnings given for valid Unicode digit range.\nmy $arabic_digits = qr/(?[ [ \u0660 - \u0669 ] ])/;\nfor my $char (\"\u0660\", \"\u0665\", \"\u0669\") {\n    use charnames ();\n    my @got = capture_warnings(sub {\n                like(\"\u0660\", $arabic_digits, \"Matches \"\n                                                . charnames::viacode(ord $char));\n            });\n    is (@got, 0, \"... without warnings\");\n}\n\n# RT #126181: \\cX behaves strangely inside (?[])\n{\n\tno warnings qw(syntax regexp);\n\n\teval { $_ = '/(?[(\\c]) /'; qr/$_/ };\n\tlike($@, qr/^Syntax error/, '/(?[(\\c]) / should not panic');\n\teval { $_ = '(?[\\c#]' . \"\\n])\"; qr/$_/ };\n\tlike($@, qr/^Syntax error/, '/(?[(\\c]) / should not panic');\n\teval { $_ = '(?[(\\c])'; qr/$_/ };\n\tlike($@, qr/^Syntax error/, '/(?[(\\c])/ should be a syntax error');\n\teval { $_ = '(?[(\\c]) ]\\b'; qr/$_/ };\n\tlike($@, qr/^Syntax error/, '/(?[(\\c]) ]\\b/ should be a syntax error');\n\teval { $_ = '(?[\\c[]](])'; qr/$_/ };\n\tlike($@, qr/^Syntax error/, '/(?[\\c[]](])/ should be a syntax error');\n\tlike(\"\\c#\", qr/(?[\\c#])/, '\\c# should match itself');\n\tlike(\"\\c[\", qr/(?[\\c[])/, '\\c[ should match itself');\n\tlike(\"\\c\\ \", qr/(?[\\c\\])/, '\\c\\ should match itself');\n\tlike(\"\\c]\", qr/(?[\\c]])/, '\\c] should match itself');\n}\n\n# RT #126481 !! with syntax error panics\n{\n    fresh_perl_like('no warnings \"experimental::regex_sets\"; qr/(?[ ! ! (\\w])/',\n                    qr/^Unmatched \\(/, {},\n                    'qr/(?[ ! ! (\\w])/ doesnt panic');\n\n    # The following didn't panic before, but easy to add this here with a\n    # paren between the !!\n    fresh_perl_like('no warnings \"experimental::regex_sets\";qr/(?[ ! ( ! (\\w)])/',\n                    qr/^Unmatched \\(/, {},\n                    'qr/qr/(?[ ! ( ! (\\w)])/');\n}\n\n{   # RT #129122\n    my $pat = '(?[ ( [ABC] - [B] ) + ( [abc] - [b] ) + [def] ])';\n    like(\"A\", qr/$pat/, \"'A' matches /$pat/\");\n    unlike(\"B\", qr/$pat/, \"'B' doesn't match /$pat/\");\n    like(\"C\", qr/$pat/, \"'C' matches /$pat/\");\n    unlike(\"D\", qr/$pat/, \"'D' doesn't match /$pat/\");\n    like(\"a\", qr/$pat/, \"'a' matches /$pat/\");\n    unlike(\"b\", qr/$pat/, \"'b' doesn't match /$pat/\");\n    like(\"c\", qr/$pat/, \"'c' matches /$pat/\");\n    like(\"d\", qr/$pat/, \"'d' matches /$pat/\");\n    like(\"e\", qr/$pat/, \"'e' matches /$pat/\");\n    like(\"f\", qr/$pat/, \"'f' matches /$pat/\");\n    unlike(\"g\", qr/$pat/, \"'g' doesn't match /$pat/\");\n}\n\n{   # [perl #129322 ]  This crashed perl, so keep after the ones that don't\n    my $pat = '(?[[!]&[0]^[!]&[0]+[a]])';\n    like(\"a\", qr/$pat/, \"/$pat/ compiles and matches 'a'\");\n}\n\ndone_testing();\n\n1;\n"], "fixing_code": ["=head1 NAME\n\nperldiag - various Perl diagnostics\n\n=head1 DESCRIPTION\n\nThese messages are classified as follows (listed in increasing order of\ndesperation):\n\n    (W) A warning (optional).\n    (D) A deprecation (enabled by default).\n    (S) A severe warning (enabled by default).\n    (F) A fatal error (trappable).\n    (P) An internal error you should never see (trappable).\n    (X) A very fatal error (nontrappable).\n    (A) An alien error message (not generated by Perl).\n\nThe majority of messages from the first three classifications above\n(W, D & S) can be controlled using the C<warnings> pragma.\n\nIf a message can be controlled by the C<warnings> pragma, its warning\ncategory is included with the classification letter in the description\nbelow.  E.g. C<(W closed)> means a warning in the C<closed> category.\n\nOptional warnings are enabled by using the C<warnings> pragma or the B<-w>\nand B<-W> switches.  Warnings may be captured by setting C<$SIG{__WARN__}>\nto a reference to a routine that will be called on each warning instead\nof printing it.  See L<perlvar>.\n\nSevere warnings are always enabled, unless they are explicitly disabled\nwith the C<warnings> pragma or the B<-X> switch.\n\nTrappable errors may be trapped using the eval operator.  See\nL<perlfunc/eval>.  In almost all cases, warnings may be selectively\ndisabled or promoted to fatal errors using the C<warnings> pragma.\nSee L<warnings>.\n\nThe messages are in alphabetical order, without regard to upper or\nlower-case.  Some of these messages are generic.  Spots that vary are\ndenoted with a %s or other printf-style escape.  These escapes are\nignored by the alphabetical order, as are all characters other than\nletters.  To look up your message, just ignore anything that is not a\nletter.\n\n=over 4\n\n=item accept() on closed socket %s\n\n(W closed) You tried to do an accept on a closed socket.  Did you forget\nto check the return value of your socket() call?  See\nL<perlfunc/accept>.\n\n=item Aliasing via reference is experimental\n\n(S experimental::refaliasing) This warning is emitted if you use\na reference constructor on the left-hand side of an assignment to\nalias one variable to another.  Simply suppress the warning if you\nwant to use the feature, but know that in doing so you are taking\nthe risk of using an experimental feature which may change or be\nremoved in a future Perl version:\n\n    no warnings \"experimental::refaliasing\";\n    use feature \"refaliasing\";\n    \\$x = \\$y;\n\n=item Allocation too large: %x\n\n(X) You can't allocate more than 64K on an MS-DOS machine.\n\n=item '%c' allowed only after types %s in %s\n\n(F) The modifiers '!', '<' and '>' are allowed in pack() or unpack() only\nafter certain types.  See L<perlfunc/pack>.\n\n=item alpha->numify() is lossy\n\n(W numeric) An alpha version can not be numified without losing\ninformation.\n\n=item Ambiguous call resolved as CORE::%s(), qualify as such or use &\n\n(W ambiguous) A subroutine you have declared has the same name as a Perl\nkeyword, and you have used the name without qualification for calling\none or the other.  Perl decided to call the builtin because the\nsubroutine is not imported.\n\nTo force interpretation as a subroutine call, either put an ampersand\nbefore the subroutine name, or qualify the name with its package.\nAlternatively, you can import the subroutine (or pretend that it's\nimported with the C<use subs> pragma).\n\nTo silently interpret it as the Perl operator, use the C<CORE::> prefix\non the operator (e.g. C<CORE::log($x)>) or declare the subroutine\nto be an object method (see L<perlsub/\"Subroutine Attributes\"> or\nL<attributes>).\n\n=item Ambiguous range in transliteration operator\n\n(F) You wrote something like C<tr/a-z-0//> which doesn't mean anything at\nall.  To include a C<-> character in a transliteration, put it either\nfirst or last.  (In the past, C<tr/a-z-0//> was synonymous with\nC<tr/a-y//>, which was probably not what you would have expected.)\n\n=item Ambiguous use of %s resolved as %s\n\n(S ambiguous) You said something that may not be interpreted the way\nyou thought.  Normally it's pretty easy to disambiguate it by supplying\na missing quote, operator, parenthesis pair or declaration.\n\n=item Ambiguous use of -%s resolved as -&%s()\n\n(S ambiguous) You wrote something like C<-foo>, which might be the\nstring C<\"-foo\">, or a call to the function C<foo>, negated.  If you meant\nthe string, just write C<\"-foo\">.  If you meant the function call,\nwrite C<-foo()>.\n\n=item Ambiguous use of %c resolved as operator %c\n\n(S ambiguous) C<%>, C<&>, and C<*> are both infix operators (modulus,\nbitwise and, and multiplication) I<and> initial special characters\n(denoting hashes, subroutines and typeglobs), and you said something\nlike C<*foo * foo> that might be interpreted as either of them.  We\nassumed you meant the infix operator, but please try to make it more\nclear -- in the example given, you might write C<*foo * foo()> if you\nreally meant to multiply a glob by the result of calling a function.\n\n=item Ambiguous use of %c{%s} resolved to %c%s\n\n(W ambiguous) You wrote something like C<@{foo}>, which might be\nasking for the variable C<@foo>, or it might be calling a function\nnamed foo, and dereferencing it as an array reference.  If you wanted\nthe variable, you can just write C<@foo>.  If you wanted to call the\nfunction, write C<@{foo()}> ... or you could just not have a variable\nand a function with the same name, and save yourself a lot of trouble.\n\n=item Ambiguous use of %c{%s[...]} resolved to %c%s[...]\n\n=item Ambiguous use of %c{%s{...}} resolved to %c%s{...}\n\n(W ambiguous) You wrote something like C<${foo[2]}> (where foo represents\nthe name of a Perl keyword), which might be looking for element number\n2 of the array named C<@foo>, in which case please write C<$foo[2]>, or you\nmight have meant to pass an anonymous arrayref to the function named\nfoo, and then do a scalar deref on the value it returns.  If you meant\nthat, write C<${foo([2])}>.\n\nIn regular expressions, the C<${foo[2]}> syntax is sometimes necessary\nto disambiguate between array subscripts and character classes.\nC</$length[2345]/>, for instance, will be interpreted as C<$length> followed\nby the character class C<[2345]>.  If an array subscript is what you\nwant, you can avoid the warning by changing C</${length[2345]}/> to the\nunsightly C</${\\$length[2345]}/>, by renaming your array to something\nthat does not coincide with a built-in keyword, or by simply turning\noff warnings with C<no warnings 'ambiguous';>.\n\n=item '|' and '<' may not both be specified on command line\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and found that STDIN was a pipe, and that you also tried to\nredirect STDIN using '<'.  Only one STDIN stream to a customer, please.\n\n=item '|' and '>' may not both be specified on command line\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and thinks you tried to redirect stdout both to a file and\ninto a pipe to another command.  You need to choose one or the other,\nthough nothing's stopping you from piping into a program or Perl script\nwhich 'splits' output into two streams, such as\n\n    open(OUT,\">$ARGV[0]\") or die \"Can't write to $ARGV[0]: $!\";\n    while (<STDIN>) {\n        print;\n        print OUT;\n    }\n    close OUT;\n\n=item Applying %s to %s will act on scalar(%s)\n\n(W misc) The pattern match (C<//>), substitution (C<s///>), and\ntransliteration (C<tr///>) operators work on scalar values.  If you apply\none of them to an array or a hash, it will convert the array or hash to\na scalar value (the length of an array, or the population info of a\nhash) and then work on that scalar value.  This is probably not what\nyou meant to do.  See L<perlfunc/grep> and L<perlfunc/map> for\nalternatives.\n\n=item Arg too short for msgsnd\n\n(F) msgsnd() requires a string at least as long as sizeof(long).\n\n=item Argument \"%s\" isn't numeric%s\n\n(W numeric) The indicated string was fed as an argument to an operator\nthat expected a numeric value instead.  If you're fortunate the message\nwill identify which operator was so unfortunate.\n\nNote that for the C<Inf> and C<NaN> (infinity and not-a-number) the\ndefinition of \"numeric\" is somewhat unusual: the strings themselves\n(like \"Inf\") are considered numeric, and anything following them is\nconsidered non-numeric.\n\n=item Argument list not closed for PerlIO layer \"%s\"\n\n(W layer) When pushing a layer with arguments onto the Perl I/O\nsystem you forgot the ) that closes the argument list.  (Layers\ntake care of transforming data between external and internal\nrepresentations.)  Perl stopped parsing the layer list at this\npoint and did not attempt to push this layer.  If your program\ndidn't explicitly request the failing operation, it may be the\nresult of the value of the environment variable PERLIO.\n\n=item Argument \"%s\" treated as 0 in increment (++)\n\n(W numeric) The indicated string was fed as an argument to the C<++>\noperator which expects either a number or a string matching\nC</^[a-zA-Z]*[0-9]*\\z/>.  See L<perlop/Auto-increment and\nAuto-decrement> for details.\n\n=item Array passed to stat will be coerced to a scalar%s\n\n(W syntax) You called stat() on an array, but the array will be\ncoerced to a scalar - the number of elements in the array.\n\n=item A signature parameter must start with '$', '@' or '%'\n\n(F) Each subroutine signature parameter declaration must start with a valid\nsigil; for example:\n\n    sub foo ($a, $, $b = 1, @c) {}\n\n=item A slurpy parameter may not have a default value\n\n(F) Only scalar subroutine signature parameters may have a default value;\nfor example:\n\n    sub foo ($a = 1)        {} # legal\n    sub foo (@a = (1))      {} # invalid\n    sub foo (%a = (a => b)) {} # invalid\n\n=item assertion botched: %s\n\n(X) The malloc package that comes with Perl had an internal failure.\n\n=item Assertion %s failed: file \"%s\", line %d\n\n(X) A general assertion failed.  The file in question must be examined.\n\n=item Assigned value is not a reference\n\n(F) You tried to assign something that was not a reference to an lvalue\nreference (e.g., C<\\$x = $y>).  If you meant to make $x an alias to $y, use\nC<\\$x = \\$y>.\n\n=item Assigned value is not %s reference\n\n(F) You tried to assign a reference to a reference constructor, but the\ntwo references were not of the same type.  You cannot alias a scalar to\nan array, or an array to a hash; the two types must match.\n\n    \\$x = \\@y;  # error\n    \\@x = \\%y;  # error\n     $y = [];\n    \\$x = $y;   # error; did you mean \\$y?\n\n=item Assigning non-zero to $[ is no longer possible\n\n(F) When the \"array_base\" feature is disabled (e.g., under C<use v5.16;>)\nthe special variable C<$[>, which is deprecated, is now a fixed zero value.\n\n=item Assignment to both a list and a scalar\n\n(F) If you assign to a conditional operator, the 2nd and 3rd arguments\nmust either both be scalars or both be lists.  Otherwise Perl won't\nknow which context to supply to the right side.\n\n=item Assuming NOT a POSIX class since %s in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) You had something like these:\n\n [[:alnum]]\n [[:digit:xyz]\n\nThey look like they might have been meant to be the POSIX classes\nC<[:alnum:]> or C<[:digit:]>.  If so, they should be written:\n\n [[:alnum:]]\n [[:digit:]xyz]\n\nSince these aren't legal POSIX class specifications, but are legal\nbracketed character classes, Perl treats them as the latter.  In the\nfirst example, it matches the characters C<\":\">, C<\"[\">, C<\"a\">, C<\"l\">,\nC<\"m\">, C<\"n\">, and C<\"u\">.\n\nIf these weren't meant to be POSIX classes, this warning message is\nspurious, and can be suppressed by reordering things, such as\n\n [[al:num]]\n\nor\n\n [[:munla]]\n\n=item <> at require-statement should be quotes\n\n(F) You wrote C<< require <file> >> when you should have written\nC<require 'file'>.\n\n=item Attempt to access disallowed key '%s' in a restricted hash\n\n(F) The failing code has attempted to get or set a key which is not in\nthe current set of allowed keys of a restricted hash.\n\n=item Attempt to bless into a freed package\n\n(F) You wrote C<bless $foo> with one argument after somehow causing\nthe current package to be freed.  Perl cannot figure out what to\ndo, so it throws up in hands in despair.\n\n=item Attempt to bless into a reference\n\n(F) The CLASSNAME argument to the bless() operator is expected to be\nthe name of the package to bless the resulting object into.  You've\nsupplied instead a reference to something: perhaps you wrote\n\n    bless $self, $proto;\n\nwhen you intended\n\n    bless $self, ref($proto) || $proto;\n\nIf you actually want to bless into the stringified version\nof the reference supplied, you need to stringify it yourself, for\nexample by:\n\n    bless $self, \"$proto\";\n\n=item Attempt to clear deleted array\n\n(S debugging) An array was assigned to when it was being freed.\nFreed values are not supposed to be visible to Perl code.  This\ncan also happen if XS code calls C<av_clear> from a custom magic\ncallback on the array.\n\n=item Attempt to delete disallowed key '%s' from a restricted hash\n\n(F) The failing code attempted to delete from a restricted hash a key\nwhich is not in its key set.\n\n=item Attempt to delete readonly key '%s' from a restricted hash\n\n(F) The failing code attempted to delete a key whose value has been\ndeclared readonly from a restricted hash.\n\n=item Attempt to free non-arena SV: 0x%x\n\n(S internal) All SV objects are supposed to be allocated from arenas\nthat will be garbage collected on exit.  An SV was discovered to be\noutside any of those arenas.\n\n=item Attempt to free nonexistent shared string '%s'%s\n\n(S internal) Perl maintains a reference-counted internal table of\nstrings to optimize the storage and access of hash keys and other\nstrings.  This indicates someone tried to decrement the reference count\nof a string that can no longer be found in the table.\n\n=item Attempt to free temp prematurely: SV 0x%x\n\n(S debugging) Mortalized values are supposed to be freed by the\nfree_tmps() routine.  This indicates that something else is freeing the\nSV before the free_tmps() routine gets a chance, which means that the\nfree_tmps() routine will be freeing an unreferenced scalar when it does\ntry to free it.\n\n=item Attempt to free unreferenced glob pointers\n\n(S internal) The reference counts got screwed up on symbol aliases.\n\n=item Attempt to free unreferenced scalar: SV 0x%x\n\n(S internal) Perl went to decrement the reference count of a scalar to\nsee if it would go to 0, and discovered that it had already gone to 0\nearlier, and should have been freed, and in fact, probably was freed.\nThis could indicate that SvREFCNT_dec() was called too many times, or\nthat SvREFCNT_inc() was called too few times, or that the SV was\nmortalized when it shouldn't have been, or that memory has been\ncorrupted.\n\n=item Attempt to pack pointer to temporary value\n\n(W pack) You tried to pass a temporary value (like the result of a\nfunction, or a computed expression) to the \"p\" pack() template.  This\nmeans the result contains a pointer to a location that could become\ninvalid anytime, even before the end of the current statement.  Use\nliterals or global values as arguments to the \"p\" pack() template to\navoid this warning.\n\n=item Attempt to reload %s aborted.\n\n(F) You tried to load a file with C<use> or C<require> that failed to\ncompile once already.  Perl will not try to compile this file again\nunless you delete its entry from %INC.  See L<perlfunc/require> and\nL<perlvar/%INC>.\n\n=item Attempt to set length of freed array\n\n(W misc) You tried to set the length of an array which has\nbeen freed.  You can do this by storing a reference to the\nscalar representing the last index of an array and later\nassigning through that reference.  For example\n\n    $r = do {my @a; \\$#a};\n    $$r = 503\n\n=item Attempt to use reference as lvalue in substr\n\n(W substr) You supplied a reference as the first argument to substr()\nused as an lvalue, which is pretty strange.  Perhaps you forgot to\ndereference it first.  See L<perlfunc/substr>.\n\n=item Attribute prototype(%s) discards earlier prototype attribute in same sub\n\n(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for\nexample.  Since each sub can only have one prototype, the earlier\ndeclaration(s) are discarded while the last one is applied.\n\n=item av_reify called on tied array\n\n(S debugging) This indicates that something went wrong and Perl got I<very>\nconfused about C<@_> or C<@DB::args> being tied.\n\n=item Bad arg length for %s, is %u, should be %d\n\n(F) You passed a buffer of the wrong size to one of msgctl(), semctl()\nor shmctl().  In C parlance, the correct sizes are, respectively,\nS<sizeof(struct msqid_ds *)>, S<sizeof(struct semid_ds *)>, and\nS<sizeof(struct shmid_ds *)>.\n\n=item Bad evalled substitution pattern\n\n(F) You've used the C</e> switch to evaluate the replacement for a\nsubstitution, but perl found a syntax error in the code to evaluate,\nmost likely an unexpected right brace '}'.\n\n=item Bad filehandle: %s\n\n(F) A symbol was passed to something wanting a filehandle, but the\nsymbol has no filehandle associated with it.  Perhaps you didn't do an\nopen(), or did it in another package.\n\n=item Bad free() ignored\n\n(S malloc) An internal routine called free() on something that had never\nbeen malloc()ed in the first place.  Mandatory, but can be disabled by\nsetting environment variable C<PERL_BADFREE> to 0.\n\nThis message can be seen quite often with DB_File on systems with \"hard\"\ndynamic linking, like C<AIX> and C<OS/2>.  It is a bug of C<Berkeley DB>\nwhich is left unnoticed if C<DB> uses I<forgiving> system malloc().\n\n=item Bad hash\n\n(P) One of the internal hash routines was passed a null HV pointer.\n\n=item Badly placed ()'s\n\n(A) You've accidentally run your script through B<csh> instead\nof Perl.  Check the #! line, or manually feed your script into\nPerl yourself.\n\n=item Bad name after %s\n\n(F) You started to name a symbol by using a package prefix, and then\ndidn't finish the symbol.  In particular, you can't interpolate outside\nof quotes, so\n\n    $var = 'myvar';\n    $sym = mypack::$var;\n\nis not the same as\n\n    $var = 'myvar';\n    $sym = \"mypack::$var\";\n\n=item Bad plugin affecting keyword '%s'\n\n(F) An extension using the keyword plugin mechanism violated the\nplugin API.\n\n=item Bad realloc() ignored\n\n(S malloc) An internal routine called realloc() on something that\nhad never been malloc()ed in the first place.  Mandatory, but can\nbe disabled by setting the environment variable C<PERL_BADFREE> to 1.\n\n=item Bad symbol for array\n\n(P) An internal request asked to add an array entry to something that\nwasn't a symbol table entry.\n\n=item Bad symbol for dirhandle\n\n(P) An internal request asked to add a dirhandle entry to something\nthat wasn't a symbol table entry.\n\n=item Bad symbol for filehandle\n\n(P) An internal request asked to add a filehandle entry to something\nthat wasn't a symbol table entry.\n\n=item Bad symbol for hash\n\n(P) An internal request asked to add a hash entry to something that\nwasn't a symbol table entry.\n\n=item Bad symbol for scalar\n\n(P) An internal request asked to add a scalar entry to something that\nwasn't a symbol table entry.\n\n=item Bareword found in conditional\n\n(W bareword) The compiler found a bareword where it expected a\nconditional, which often indicates that an || or && was parsed as part\nof the last argument of the previous construct, for example:\n\n    open FOO || die;\n\nIt may also indicate a misspelled constant that has been interpreted as\na bareword:\n\n    use constant TYPO => 1;\n    if (TYOP) { print \"foo\" }\n\nThe C<strict> pragma is useful in avoiding such errors.\n\n=item Bareword in require contains \"%s\"\n\n=item Bareword in require maps to disallowed filename \"%s\"\n\n=item Bareword in require maps to empty filename\n\n(F) The bareword form of require has been invoked with a filename which could\nnot have been generated by a valid bareword permitted by the parser.  You\nshouldn't be able to get this error from Perl code, but XS code may throw it\nif it passes an invalid module name to C<Perl_load_module>.\n\n=item Bareword in require must not start with a double-colon: \"%s\"\n\n(F) In C<require Bare::Word>, the bareword is not allowed to start with a\ndouble-colon.  Write C<require ::Foo::Bar> as  C<require Foo::Bar> instead.\n\n=item Bareword \"%s\" not allowed while \"strict subs\" in use\n\n(F) With \"strict subs\" in use, a bareword is only allowed as a\nsubroutine identifier, in curly brackets or to the left of the \"=>\"\nsymbol.  Perhaps you need to predeclare a subroutine?\n\n=item Bareword \"%s\" refers to nonexistent package\n\n(W bareword) You used a qualified bareword of the form C<Foo::>, but the\ncompiler saw no other uses of that namespace before that point.  Perhaps\nyou need to predeclare a package?\n\n=item BEGIN failed--compilation aborted\n\n(F) An untrapped exception was raised while executing a BEGIN\nsubroutine.  Compilation stops immediately and the interpreter is\nexited.\n\n=item BEGIN not safe after errors--compilation aborted\n\n(F) Perl found a C<BEGIN {}> subroutine (or a C<use> directive, which\nimplies a C<BEGIN {}>) after one or more compilation errors had already\noccurred.  Since the intended environment for the C<BEGIN {}> could not\nbe guaranteed (due to the errors), and since subsequent code likely\ndepends on its correct operation, Perl just gave up.\n\n=item \\%d better written as $%d\n\n(W syntax) Outside of patterns, backreferences live on as variables.\nThe use of backslashes is grandfathered on the right-hand side of a\nsubstitution, but stylistically it's better to use the variable form\nbecause other Perl programmers will expect it, and it works better if\nthere are more than 9 backreferences.\n\n=item Binary number > 0b11111111111111111111111111111111 non-portable\n\n(W portable) The binary number you specified is larger than 2**32-1\n(4294967295) and therefore non-portable between systems.  See\nL<perlport> for more on portability concerns.\n\n=item bind() on closed socket %s\n\n(W closed) You tried to do a bind on a closed socket.  Did you forget to\ncheck the return value of your socket() call?  See L<perlfunc/bind>.\n\n=item binmode() on closed filehandle %s\n\n(W unopened) You tried binmode() on a filehandle that was never opened.\nCheck your control flow and number of arguments.\n\n=item Bit vector size > 32 non-portable\n\n(W portable) Using bit vector sizes larger than 32 is non-portable.\n\n=item Bizarre copy of %s\n\n(P) Perl detected an attempt to copy an internal value that is not\ncopiable.\n\n=item Bizarre SvTYPE [%d]\n\n(P) When starting a new thread or returning values from a thread, Perl\nencountered an invalid data type.\n\n=item Both or neither range ends should be Unicode in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nIn a bracketed character class in a regular expression pattern, you\nhad a range which has exactly one end of it specified using C<\\N{}>, and\nthe other end is specified using a non-portable mechanism.  Perl treats\nthe range as a Unicode range, that is, all the characters in it are\nconsidered to be the Unicode characters, and which may be different code\npoints on some platforms Perl runs on.  For example, C<[\\N{U+06}-\\x08]>\nis treated as if you had instead said C<[\\N{U+06}-\\N{U+08}]>, that is it\nmatches the characters whose code points in Unicode are 6, 7, and 8.\nBut that C<\\x08> might indicate that you meant something different, so\nthe warning gets raised.\n\n=item Buffer overflow in prime_env_iter: %s\n\n(W internal) A warning peculiar to VMS.  While Perl was preparing to\niterate over %ENV, it encountered a logical name or symbol definition\nwhich was too long, so it was truncated to the string shown.\n\n=item Callback called exit\n\n(F) A subroutine invoked from an external package via call_sv()\nexited by calling exit.\n\n=item %s() called too early to check prototype\n\n(W prototype) You've called a function that has a prototype before the\nparser saw a definition or declaration for it, and Perl could not check\nthat the call conforms to the prototype.  You need to either add an\nearly prototype declaration for the subroutine in question, or move the\nsubroutine definition ahead of the call to get proper prototype\nchecking.  Alternatively, if you are certain that you're calling the\nfunction correctly, you may put an ampersand before the name to avoid\nthe warning.  See L<perlsub>.\n\n=item Cannot chr %f\n\n(F) You passed an invalid number (like an infinity or not-a-number) to C<chr>.\n\n=item Cannot complete in-place edit of %s: %s\n\n(F) Your perl script appears to have changed directory while\nperforming an in-place edit of a file specified by a relative path,\nand your system doesn't include the directory relative POSIX functions\nneeded to handle that.\n\n=item Cannot compress %f in pack\n\n(F) You tried compressing an infinity or not-a-number as an unsigned\ninteger with BER, which makes no sense.\n\n=item Cannot compress integer in pack\n\n(F) An argument to pack(\"w\",...) was too large to compress.\nThe BER compressed integer format can only be used with positive\nintegers, and you attempted to compress a very large number (> 1e308).\nSee L<perlfunc/pack>.\n\n=item Cannot compress negative numbers in pack\n\n(F) An argument to pack(\"w\",...) was negative.  The BER compressed integer\nformat can only be used with positive integers.  See L<perlfunc/pack>.\n\n=item Cannot convert a reference to %s to typeglob\n\n(F) You manipulated Perl's symbol table directly, stored a reference\nin it, then tried to access that symbol via conventional Perl syntax.\nThe access triggers Perl to autovivify that typeglob, but it there is\nno legal conversion from that type of reference to a typeglob.\n\n=item Cannot copy to %s\n\n(P) Perl detected an attempt to copy a value to an internal type that cannot\nbe directly assigned to.\n\n=item Cannot find encoding \"%s\"\n\n(S io) You tried to apply an encoding that did not exist to a filehandle,\neither with open() or binmode().\n\n=item Cannot open %s as a dirhandle: it is already open as a filehandle\n\n(F) You tried to use opendir() to associate a dirhandle to a symbol (glob\nor scalar) that already holds a filehandle.  Since this idiom might render\nyour code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it\nis a fatal error.\n\n=item Cannot open %s as a filehandle: it is already open as a dirhandle\n\n(F) You tried to use open() to associate a filehandle to a symbol (glob\nor scalar) that already holds a dirhandle.  Since this idiom might render\nyour code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it\nis a fatal error.\n\n=item Cannot pack %f with '%c'\n\n(F) You tried converting an infinity or not-a-number to an integer,\nwhich makes no sense.\n\n=item Cannot printf %f with '%c'\n\n(F) You tried printing an infinity or not-a-number as a character (%c),\nwhich makes no sense.  Maybe you meant '%s', or just stringifying it?\n\n=item Cannot set tied @DB::args\n\n(F) C<caller> tried to set C<@DB::args>, but found it tied.  Tying C<@DB::args>\nis not supported.  (Before this error was added, it used to crash.)\n\n=item Cannot tie unreifiable array\n\n(P) You somehow managed to call C<tie> on an array that does not\nkeep a reference count on its arguments and cannot be made to\ndo so.  Such arrays are not even supposed to be accessible to\nPerl code, but are only used internally.\n\n=item Cannot yet reorder sv_catpvfn() arguments from va_list\n\n(F) Some XS code tried to use C<sv_catpvfn()> or a related function with a\nformat string that specifies explicit indexes for some of the elements, and\nusing a C-style variable-argument list (a C<va_list>).  This is not currently\nsupported.  XS authors wanting to do this must instead construct a C array\nof C<SV*> scalars containing the arguments.\n\n=item Can only compress unsigned integers in pack\n\n(F) An argument to pack(\"w\",...) was not an integer.  The BER compressed\ninteger format can only be used with positive integers, and you attempted\nto compress something else.  See L<perlfunc/pack>.\n\n=item Can't bless non-reference value\n\n(F) Only hard references may be blessed.  This is how Perl \"enforces\"\nencapsulation of objects.  See L<perlobj>.\n\n=item Can't \"break\" in a loop topicalizer\n\n(F) You called C<break>, but you're in a C<foreach> block rather than\na C<given> block.  You probably meant to use C<next> or C<last>.\n\n=item Can't \"break\" outside a given block\n\n(F) You called C<break>, but you're not inside a C<given> block.\n\n=item Can't call method \"%s\" on an undefined value\n\n(F) You used the syntax of a method call, but the slot filled by the\nobject reference or package name contains an undefined value.  Something\nlike this will reproduce the error:\n\n    $BADREF = undef;\n    process $BADREF 1,2,3;\n    $BADREF->process(1,2,3);\n\n=item Can't call method \"%s\" on unblessed reference\n\n(F) A method call must know in what package it's supposed to run.  It\nordinarily finds this out from the object reference you supply, but you\ndidn't supply an object reference in this case.  A reference isn't an\nobject reference until it has been blessed.  See L<perlobj>.\n\n=item Can't call method \"%s\" without a package or object reference\n\n(F) You used the syntax of a method call, but the slot filled by the\nobject reference or package name contains an expression that returns a\ndefined value which is neither an object reference nor a package name.\nSomething like this will reproduce the error:\n\n    $BADREF = 42;\n    process $BADREF 1,2,3;\n    $BADREF->process(1,2,3);\n\n=item Can't call mro_isa_changed_in() on anonymous symbol table\n\n(P) Perl got confused as to whether a hash was a plain hash or a\nsymbol table hash when trying to update @ISA caches.\n\n=item Can't call mro_method_changed_in() on anonymous symbol table\n\n(F) An XS module tried to call C<mro_method_changed_in> on a hash that was\nnot attached to the symbol table.\n\n=item Can't chdir to %s\n\n(F) You called C<perl -x/foo/bar>, but F</foo/bar> is not a directory\nthat you can chdir to, possibly because it doesn't exist.\n\n=item Can't check filesystem of script \"%s\" for nosuid\n\n(P) For some reason you can't check the filesystem of the script for\nnosuid.\n\n=item Can't coerce %s to %s in %s\n\n(F) Certain types of SVs, in particular real symbol table entries\n(typeglobs), can't be forced to stop being what they are.  So you can't\nsay things like:\n\n    *foo += 1;\n\nYou CAN say\n\n    $foo = *foo;\n    $foo += 1;\n\nbut then $foo no longer contains a glob.\n\n=item Can't \"continue\" outside a when block\n\n(F) You called C<continue>, but you're not inside a C<when>\nor C<default> block.\n\n=item Can't create pipe mailbox\n\n(P) An error peculiar to VMS.  The process is suffering from exhausted\nquotas or other plumbing problems.\n\n=item Can't declare %s in \"%s\"\n\n(F) Only scalar, array, and hash variables may be declared as \"my\", \"our\" or\n\"state\" variables.  They must have ordinary identifiers as names.\n\n=item Can't \"default\" outside a topicalizer\n\n(F) You have used a C<default> block that is neither inside a\nC<foreach> loop nor a C<given> block.  (Note that this error is\nissued on exit from the C<default> block, so you won't get the\nerror if you use an explicit C<continue>.)\n\n=item Can't determine class of operator %s, assuming BASEOP\n\n(S) This warning indicates something wrong in the internals of perl.\nPerl was trying to find the class (e.g. LISTOP) of a particular OP,\nand was unable to do so. This is likely to be due to a bug in the perl\ninternals, or due to a bug in XS code which manipulates perl optrees.\n\n=item Can't do inplace edit: %s is not a regular file\n\n(S inplace) You tried to use the B<-i> switch on a special file, such as\na file in /dev, a FIFO or an uneditable directory.  The file was ignored.\n\n=item Can't do inplace edit on %s: %s\n\n(S inplace) The creation of the new file failed for the indicated\nreason.\n\n=item Can't do inplace edit without backup\n\n(F) You're on a system such as MS-DOS that gets confused if you try\nreading from a deleted (but still opened) file.  You have to say\nC<-i.bak>, or some such.\n\n=item Can't do inplace edit: %s would not be unique\n\n(S inplace) Your filesystem does not support filenames longer than 14\ncharacters and Perl was unable to create a unique filename during\ninplace editing with the B<-i> switch.  The file was ignored.\n\n=item Can't do %s(\"%s\") on non-UTF-8 locale; resolved to \"%s\".\n\n(W locale) You are 1) running under \"C<use locale>\"; 2) the current\nlocale is not a UTF-8 one; 3) you tried to do the designated case-change\noperation on the specified Unicode character; and 4) the result of this\noperation would mix Unicode and locale rules, which likely conflict.\nMixing of different rule types is forbidden, so the operation was not\ndone; instead the result is the indicated value, which is the best\navailable that uses entirely Unicode rules.  That turns out to almost\nalways be the original character, unchanged.\n\nIt is generally a bad idea to mix non-UTF-8 locales and Unicode, and\nthis issue is one of the reasons why.  This warning is raised when\nUnicode rules would normally cause the result of this operation to\ncontain a character that is in the range specified by the locale,\n0..255, and hence is subject to the locale's rules, not Unicode's.\n\nIf you are using locale purely for its characteristics related to things\nlike its numeric and time formatting (and not C<LC_CTYPE>), consider\nusing a restricted form of the locale pragma (see L<perllocale/The \"use\nlocale\" pragma>) like \"S<C<use locale ':not_characters'>>\".\n\nNote that failed case-changing operations done as a result of\ncase-insensitive C</i> regular expression matching will show up in this\nwarning as having the C<fc> operation (as that is what the regular\nexpression engine calls behind the scenes.)\n\n=item Can't do waitpid with flags\n\n(F) This machine doesn't have either waitpid() or wait4(), so only\nwaitpid() without flags is emulated.\n\n=item Can't emulate -%s on #! line\n\n(F) The #! line specifies a switch that doesn't make sense at this\npoint.  For example, it'd be kind of silly to put a B<-x> on the #!\nline.\n\n=item Can't %s %s-endian %ss on this platform\n\n(F) Your platform's byte-order is neither big-endian nor little-endian,\nor it has a very strange pointer size.  Packing and unpacking big- or\nlittle-endian floating point values and pointers may not be possible.\nSee L<perlfunc/pack>.\n\n=item Can't exec \"%s\": %s\n\n(W exec) A system(), exec(), or piped open call could not execute the\nnamed program for the indicated reason.  Typical reasons include: the\npermissions were wrong on the file, the file wasn't found in\nC<$ENV{PATH}>, the executable in question was compiled for another\narchitecture, or the #! line in a script points to an interpreter that\ncan't be run for similar reasons.  (Or maybe your system doesn't support\n#! at all.)\n\n=item Can't exec %s\n\n(F) Perl was trying to execute the indicated program for you because\nthat's what the #! line said.  If that's not what you wanted, you may\nneed to mention \"perl\" on the #! line somewhere.\n\n=item Can't execute %s\n\n(F) You used the B<-S> switch, but the copies of the script to execute\nfound in the PATH did not have correct permissions.\n\n=item Can't find an opnumber for \"%s\"\n\n(F) A string of a form C<CORE::word> was given to prototype(), but there\nis no builtin with the name C<word>.\n\n=item Can't find label %s\n\n(F) You said to goto a label that isn't mentioned anywhere that it's\npossible for us to go to.  See L<perlfunc/goto>.\n\n=item Can't find %s on PATH\n\n(F) You used the B<-S> switch, but the script to execute could not be\nfound in the PATH.\n\n=item Can't find %s on PATH, '.' not in PATH\n\n(F) You used the B<-S> switch, but the script to execute could not be\nfound in the PATH, or at least not with the correct permissions.  The\nscript exists in the current directory, but PATH prohibits running it.\n\n=item Can't find string terminator %s anywhere before EOF\n\n(F) Perl strings can stretch over multiple lines.  This message means\nthat the closing delimiter was omitted.  Because bracketed quotes count\nnesting levels, the following is missing its final parenthesis:\n\n    print q(The character '(' starts a side comment.);\n\nIf you're getting this error from a here-document, you may have\nincluded unseen whitespace before or after your closing tag or there\nmay not be a linebreak after it.  A good programmer's editor will have\na way to help you find these characters (or lack of characters).  See\nL<perlop> for the full details on here-documents.\n\n=item Can't find Unicode property definition \"%s\"\n\n=item Can't find Unicode property definition \"%s\" in regex; marked by <-- HERE in m/%s/\n\n(F) The named property which you specified via C<\\p> or C<\\P> is not one\nknown to Perl.  Perhaps you misspelled the name?  See\nL<perluniprops/Properties accessible through \\p{} and \\P{}>\nfor a complete list of available official\nproperties.  If it is a\nL<user-defined property|perlunicode/User-Defined Character Properties>\nit must have been defined by the time the regular expression is\nmatched.\n\nIf you didn't mean to use a Unicode property, escape the C<\\p>, either\nby C<\\\\p> (just the C<\\p>) or by C<\\Q\\p> (the rest of the string, or\nuntil C<\\E>).\n\n=item Can't fork: %s\n\n(F) A fatal error occurred while trying to fork while opening a\npipeline.\n\n=item Can't fork, trying again in 5 seconds\n\n(W pipe) A fork in a piped open failed with EAGAIN and will be retried\nafter five seconds.\n\n=item Can't get filespec - stale stat buffer?\n\n(S) A warning peculiar to VMS.  This arises because of the difference\nbetween access checks under VMS and under the Unix model Perl assumes.\nUnder VMS, access checks are done by filename, rather than by bits in\nthe stat buffer, so that ACLs and other protections can be taken into\naccount.  Unfortunately, Perl assumes that the stat buffer contains all\nthe necessary information, and passes it, instead of the filespec, to\nthe access-checking routine.  It will try to retrieve the filespec using\nthe device name and FID present in the stat buffer, but this works only\nif you haven't made a subsequent call to the CRTL stat() routine,\nbecause the device name is overwritten with each call.  If this warning\nappears, the name lookup failed, and the access-checking routine gave up\nand returned FALSE, just to be conservative.  (Note: The access-checking\nroutine knows about the Perl C<stat> operator and file tests, so you\nshouldn't ever see this warning in response to a Perl command; it arises\nonly if some internal code takes stat buffers lightly.)\n\n=item Can't get pipe mailbox device name\n\n(P) An error peculiar to VMS.  After creating a mailbox to act as a\npipe, Perl can't retrieve its name for later use.\n\n=item Can't get SYSGEN parameter value for MAXBUF\n\n(P) An error peculiar to VMS.  Perl asked $GETSYI how big you want your\nmailbox buffers to be, and didn't get an answer.\n\n=item Can't \"goto\" into the middle of a foreach loop\n\n(F) A \"goto\" statement was executed to jump into the middle of a foreach\nloop.  You can't get there from here.  See L<perlfunc/goto>.\n\n=item Can't \"goto\" out of a pseudo block\n\n(F) A \"goto\" statement was executed to jump out of what might look like\na block, except that it isn't a proper block.  This usually occurs if\nyou tried to jump out of a sort() block or subroutine, which is a no-no.\nSee L<perlfunc/goto>.\n\n=item Can't goto subroutine from an eval-%s\n\n(F) The \"goto subroutine\" call can't be used to jump out of an eval\n\"string\" or block.\n\n=item Can't goto subroutine from a sort sub (or similar callback)\n\n(F) The \"goto subroutine\" call can't be used to jump out of the\ncomparison sub for a sort(), or from a similar callback (such\nas the reduce() function in List::Util).\n\n=item Can't goto subroutine outside a subroutine\n\n(F) The deeply magical \"goto subroutine\" call can only replace one\nsubroutine call for another.  It can't manufacture one out of whole\ncloth.  In general you should be calling it out of only an AUTOLOAD\nroutine anyway.  See L<perlfunc/goto>.\n\n=item Can't ignore signal CHLD, forcing to default\n\n(W signal) Perl has detected that it is being run with the SIGCHLD\nsignal (sometimes known as SIGCLD) disabled.  Since disabling this\nsignal will interfere with proper determination of exit status of child\nprocesses, Perl has reset the signal to its default value.  This\nsituation typically indicates that the parent program under which Perl\nmay be running (e.g. cron) is being very careless.\n\n=item Can't kill a non-numeric process ID\n\n(F) Process identifiers must be (signed) integers.  It is a fatal error to\nattempt to kill() an undefined, empty-string or otherwise non-numeric\nprocess identifier.\n\n=item Can't \"last\" outside a loop block\n\n(F) A \"last\" statement was executed to break out of the current block,\nexcept that there's this itty bitty problem called there isn't a current\nblock.  Note that an \"if\" or \"else\" block doesn't count as a \"loopish\"\nblock, as doesn't a block given to sort(), map() or grep().  You can\nusually double the curlies to get the same effect though, because the\ninner curlies will be considered a block that loops once.  See\nL<perlfunc/last>.\n\n=item Can't linearize anonymous symbol table\n\n(F) Perl tried to calculate the method resolution order (MRO) of a\npackage, but failed because the package stash has no name.\n\n=item Can't load '%s' for module %s\n\n(F) The module you tried to load failed to load a dynamic extension.\nThis may either mean that you upgraded your version of perl to one\nthat is incompatible with your old dynamic extensions (which is known\nto happen between major versions of perl), or (more likely) that your\ndynamic extension was built against an older version of the library\nthat is installed on your system.  You may need to rebuild your old\ndynamic extensions.\n\n=item Can't localize lexical variable %s\n\n(F) You used local on a variable name that was previously declared as a\nlexical variable using \"my\" or \"state\".  This is not allowed.  If you\nwant to localize a package variable of the same name, qualify it with\nthe package name.\n\n=item Can't localize through a reference\n\n(F) You said something like C<local $$ref>, which Perl can't currently\nhandle, because when it goes to restore the old value of whatever $ref\npointed to after the scope of the local() is finished, it can't be sure\nthat $ref will still be a reference.\n\n=item Can't locate %s\n\n(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be found.\nPerl looks for the file in all the locations mentioned in @INC, unless\nthe file name included the full path to the file.  Perhaps you need\nto set the PERL5LIB or PERL5OPT environment variable to say where the\nextra library is, or maybe the script needs to add the library name\nto @INC.  Or maybe you just misspelled the name of the file.  See\nL<perlfunc/require> and L<lib>.\n\n=item Can't locate auto/%s.al in @INC\n\n(F) A function (or method) was called in a package which allows\nautoload, but there is no function to autoload.  Most probable causes\nare a misprint in a function/method name or a failure to C<AutoSplit>\nthe file, say, by doing C<make install>.\n\n=item Can't locate loadable object for module %s in @INC\n\n(F) The module you loaded is trying to load an external library, like\nfor example, F<foo.so> or F<bar.dll>, but the L<DynaLoader> module was\nunable to locate this library.  See L<DynaLoader>.\n\n=item Can't locate object method \"%s\" via package \"%s\"\n\n(F) You called a method correctly, and it correctly indicated a package\nfunctioning as a class, but that package doesn't define that particular\nmethod, nor does any of its base classes.  See L<perlobj>.\n\n=item Can't locate object method \"%s\" via package \"%s\" (perhaps you forgot\nto load \"%s\"?)\n\n(F) You called a method on a class that did not exist, and the method\ncould not be found in UNIVERSAL.  This often means that a method\nrequires a package that has not been loaded.\n\n=item Can't locate package %s for @%s::ISA\n\n(W syntax) The @ISA array contained the name of another package that\ndoesn't seem to exist.\n\n=item Can't locate PerlIO%s\n\n(F) You tried to use in open() a PerlIO layer that does not exist,\ne.g. open(FH, \">:nosuchlayer\", \"somefile\").\n\n=item Can't make list assignment to %ENV on this system\n\n(F) List assignment to %ENV is not supported on some systems, notably\nVMS.\n\n=item Can't make loaded symbols global on this platform while loading %s\n\n(S) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request\nthat symbols from the stated file are made available globally within the\nprocess, but that functionality is not available on this platform.  Whilst\nthe module likely will still work, this may prevent the perl interpreter\nfrom loading other XS-based extensions which need to link directly to\nfunctions defined in the C or XS code in the stated file.\n\n=item Can't modify %s in %s\n\n(F) You aren't allowed to assign to the item indicated, or otherwise try\nto change it, such as with an auto-increment.\n\n=item Can't modify nonexistent substring\n\n(P) The internal routine that does assignment to a substr() was handed\na NULL.\n\n=item Can't modify non-lvalue subroutine call of &%s\n\n=item Can't modify non-lvalue subroutine call of &%s in %s\n\n(F) Subroutines meant to be used in lvalue context should be declared as\nsuch.  See L<perlsub/\"Lvalue subroutines\">.\n\n=item Can't modify reference to %s in %s assignment\n\n(F) Only a limited number of constructs can be used as the argument to a\nreference constructor on the left-hand side of an assignment, and what\nyou used was not one of them.  See L<perlref/Assigning to References>.\n\n=item Can't modify reference to localized parenthesized array in list\nassignment\n\n(F) Assigning to C<\\local(@array)> or C<\\(local @array)> is not supported, as\nit is not clear exactly what it should do.  If you meant to make @array\nrefer to some other array, use C<\\@array = \\@other_array>.  If you want to\nmake the elements of @array aliases of the scalars referenced on the\nright-hand side, use C<\\(@array) = @scalar_refs>.\n\n=item Can't modify reference to parenthesized hash in list assignment\n\n(F) Assigning to C<\\(%hash)> is not supported.  If you meant to make %hash\nrefer to some other hash, use C<\\%hash = \\%other_hash>.  If you want to\nmake the elements of %hash into aliases of the scalars referenced on the\nright-hand side, use a hash slice: C<\\@hash{@keys} = @those_scalar_refs>.\n\n=item Can't msgrcv to read-only var\n\n(F) The target of a msgrcv must be modifiable to be used as a receive\nbuffer.\n\n=item Can't \"next\" outside a loop block\n\n(F) A \"next\" statement was executed to reiterate the current block, but\nthere isn't a current block.  Note that an \"if\" or \"else\" block doesn't\ncount as a \"loopish\" block, as doesn't a block given to sort(), map() or\ngrep().  You can usually double the curlies to get the same effect\nthough, because the inner curlies will be considered a block that loops\nonce.  See L<perlfunc/next>.\n\n=item Can't open %s: %s\n\n(S inplace) The implicit opening of a file through use of the C<< <> >>\nfilehandle, either implicitly under the C<-n> or C<-p> command-line\nswitches, or explicitly, failed for the indicated reason.  Usually\nthis is because you don't have read permission for a file which\nyou named on the command line.\n\n(F) You tried to call perl with the B<-e> switch, but F</dev/null> (or\nyour operating system's equivalent) could not be opened.\n\n=item Can't open a reference\n\n(W io) You tried to open a scalar reference for reading or writing,\nusing the 3-arg open() syntax:\n\n    open FH, '>', $ref;\n\nbut your version of perl is compiled without perlio, and this form of\nopen is not supported.\n\n=item Can't open bidirectional pipe\n\n(W pipe) You tried to say C<open(CMD, \"|cmd|\")>, which is not supported.\nYou can try any of several modules in the Perl library to do this, such\nas IPC::Open2.  Alternately, direct the pipe's output to a file using\n\">\", and then read it in under a different file handle.\n\n=item Can't open error file %s as stderr\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the file specified after '2>' or '2>>' on\nthe command line for writing.\n\n=item Can't open input file %s as stdin\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the file specified after '<' on the\ncommand line for reading.\n\n=item Can't open output file %s as stdout\n\n(F) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the file specified after '>' or '>>' on\nthe command line for writing.\n\n=item Can't open output pipe (name: %s)\n\n(P) An error peculiar to VMS.  Perl does its own command line\nredirection, and couldn't open the pipe into which to send data destined\nfor stdout.\n\n=item Can't open perl script \"%s\": %s\n\n(F) The script you specified can't be opened for the indicated reason.\n\nIf you're debugging a script that uses #!, and normally relies on the\nshell's $PATH search, the -S option causes perl to do that search, so\nyou don't have to type the path or C<`which $scriptname`>.\n\n=item Can't read CRTL environ\n\n(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV\nfrom the CRTL's internal environment array and discovered the array was\nmissing.  You need to figure out where your CRTL misplaced its environ\nor define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not\nsearched.\n\n=item Can't redeclare \"%s\" in \"%s\"\n\n(F) A \"my\", \"our\" or \"state\" declaration was found within another declaration,\nsuch as C<my ($x, my($y), $z)> or C<our (my $x)>.\n\n=item Can't \"redo\" outside a loop block\n\n(F) A \"redo\" statement was executed to restart the current block, but\nthere isn't a current block.  Note that an \"if\" or \"else\" block doesn't\ncount as a \"loopish\" block, as doesn't a block given to sort(), map()\nor grep().  You can usually double the curlies to get the same effect\nthough, because the inner curlies will be considered a block that\nloops once.  See L<perlfunc/redo>.\n\n=item Can't remove %s: %s, skipping file\n\n(S inplace) You requested an inplace edit without creating a backup\nfile.  Perl was unable to remove the original file to replace it with\nthe modified file.  The file was left unmodified.\n\n=item Can't rename in-place work file '%s' to '%s': %s\n\n(F) When closed implicitly, the temporary file for in-place editing\ncouldn't be renamed to the original filename.\n\n=item Can't rename %s to %s: %s, skipping file\n\n(F) The rename done by the B<-i> switch failed for some reason,\nprobably because you don't have write permission to the directory.\n\n=item Can't reopen input pipe (name: %s) in binary mode\n\n(P) An error peculiar to VMS.  Perl thought stdin was a pipe, and tried\nto reopen it to accept binary data.  Alas, it failed.\n\n=item Can't represent character for Ox%X on this platform\n\n(F) There is a hard limit to how big a character code point can be due\nto the fundamental properties of UTF-8, especially on EBCDIC\nplatforms.  The given code point exceeds that.  The only work-around is\nto not use such a large code point.\n\n=item Can't reset %ENV on this system\n\n(F) You called C<reset('E')> or similar, which tried to reset\nall variables in the current package beginning with \"E\".  In\nthe main package, that includes %ENV.  Resetting %ENV is not\nsupported on some systems, notably VMS.\n\n=item Can't resolve method \"%s\" overloading \"%s\" in package \"%s\"\n\n(F)(P) Error resolving overloading specified by a method name (as\nopposed to a subroutine reference): no such method callable via the\npackage.  If the method name is C<???>, this is an internal error.\n\n=item Can't return %s from lvalue subroutine\n\n(F) Perl detected an attempt to return illegal lvalues (such as\ntemporary or readonly values) from a subroutine used as an lvalue.  This\nis not allowed.\n\n=item Can't return outside a subroutine\n\n(F) The return statement was executed in mainline code, that is, where\nthere was no subroutine call to return out of.  See L<perlsub>.\n\n=item Can't return %s to lvalue scalar context\n\n(F) You tried to return a complete array or hash from an lvalue\nsubroutine, but you called the subroutine in a way that made Perl\nthink you meant to return only one value.  You probably meant to\nwrite parentheses around the call to the subroutine, which tell\nPerl that the call should be in list context.\n\n=item Can't stat script \"%s\"\n\n(P) For some reason you can't fstat() the script even though you have it\nopen already.  Bizarre.\n\n=item Can't take log of %g\n\n(F) For ordinary real numbers, you can't take the logarithm of a\nnegative number or zero.  There's a Math::Complex package that comes\nstandard with Perl, though, if you really want to do that for the\nnegative numbers.\n\n=item Can't take sqrt of %g\n\n(F) For ordinary real numbers, you can't take the square root of a\nnegative number.  There's a Math::Complex package that comes standard\nwith Perl, though, if you really want to do that.\n\n=item Can't undef active subroutine\n\n(F) You can't undefine a routine that's currently running.  You can,\nhowever, redefine it while it's running, and you can even undef the\nredefined subroutine while the old routine is running.  Go figure.\n\n=item Can't unweaken a nonreference\n\n(F) You attempted to unweaken something that was not a reference.  Only\nreferences can be unweakened.\n\n=item Can't upgrade %s (%d) to %d\n\n(P) The internal sv_upgrade routine adds \"members\" to an SV, making it\ninto a more specialized kind of SV.  The top several SV types are so\nspecialized, however, that they cannot be interconverted.  This message\nindicates that such a conversion was attempted.\n\n=item Can't use '%c' after -mname\n\n(F) You tried to call perl with the B<-m> switch, but you put something\nother than \"=\" after the module name.\n\n=item Can't use a hash as a reference\n\n(F) You tried to use a hash as a reference, as in\nC<< %foo->{\"bar\"} >> or C<< %$ref->{\"hello\"} >>.  Versions of perl\n<= 5.22.0 used to allow this syntax, but shouldn't\nhave.  This was deprecated in perl 5.6.1.\n\n=item Can't use an array as a reference\n\n(F) You tried to use an array as a reference, as in\nC<< @foo->[23] >> or C<< @$ref->[99] >>.  Versions of perl <= 5.22.0\nused to allow this syntax, but shouldn't have.  This\nwas deprecated in perl 5.6.1.\n\n=item Can't use anonymous symbol table for method lookup\n\n(F) The internal routine that does method lookup was handed a symbol\ntable that doesn't have a name.  Symbol tables can become anonymous\nfor example by undefining stashes: C<undef %Some::Package::>.\n\n=item Can't use an undefined value as %s reference\n\n(F) A value used as either a hard reference or a symbolic reference must\nbe a defined value.  This helps to delurk some insidious errors.\n\n=item Can't use bareword (\"%s\") as %s ref while \"strict refs\" in use\n\n(F) Only hard references are allowed by \"strict refs\".  Symbolic\nreferences are disallowed.  See L<perlref>.\n\n=item Can't use %! because Errno.pm is not available\n\n(F) The first time the C<%!> hash is used, perl automatically loads the\nErrno.pm module.  The Errno module is expected to tie the %! hash to\nprovide symbolic names for C<$!> errno values.\n\n=item Can't use both '<' and '>' after type '%c' in %s\n\n(F) A type cannot be forced to have both big-endian and little-endian\nbyte-order at the same time, so this combination of modifiers is not\nallowed.  See L<perlfunc/pack>.\n\n=item Can't use 'defined(@array)' (Maybe you should just omit the defined()?)\n\n(F) defined() is not useful on arrays because it\nchecks for an undefined I<scalar> value.  If you want to see if the\narray is empty, just use C<if (@array) { # not empty }> for example.\n\n=item Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)\n\n(F) C<defined()> is not usually right on hashes.\n\nAlthough C<defined %hash> is false on a plain not-yet-used hash, it\nbecomes true in several non-obvious circumstances, including iterators,\nweak references, stash names, even remaining true after C<undef %hash>.\nThese things make C<defined %hash> fairly useless in practice, so it now\ngenerates a fatal error.\n\nIf a check for non-empty is what you wanted then just put it in boolean\ncontext (see L<perldata/Scalar values>):\n\n    if (%hash) {\n       # not empty\n    }\n\nIf you had C<defined %Foo::Bar::QUUX> to check whether such a package\nvariable exists then that's never really been reliable, and isn't\na good way to enquire about the features of a package, or whether\nit's loaded, etc.\n\n=item Can't use %s for loop variable\n\n(P) The parser got confused when trying to parse a C<foreach> loop.\n\n=item Can't use global %s in \"%s\"\n\n(F) You tried to declare a magical variable as a lexical variable.  This\nis not allowed, because the magic can be tied to only one location\n(namely the global variable) and it would be incredibly confusing to\nhave variables in your program that looked like magical variables but\nweren't.\n\n=item Can't use '%c' in a group with different byte-order in %s\n\n(F) You attempted to force a different byte-order on a type\nthat is already inside a group with a byte-order modifier.\nFor example you cannot force little-endianness on a type that\nis inside a big-endian group.\n\n=item Can't use \"my %s\" in sort comparison\n\n(F) The global variables $a and $b are reserved for sort comparisons.\nYou mentioned $a or $b in the same line as the <=> or cmp operator,\nand the variable had earlier been declared as a lexical variable.\nEither qualify the sort variable with the package name, or rename the\nlexical variable.\n\n=item Can't use %s ref as %s ref\n\n(F) You've mixed up your reference types.  You have to dereference a\nreference of the type needed.  You can use the ref() function to\ntest the type of the reference, if need be.\n\n=item Can't use string (\"%s\") as %s ref while \"strict refs\" in use\n\n=item Can't use string (\"%s\"...) as %s ref while \"strict refs\" in use\n\n(F) You've told Perl to dereference a string, something which\nC<use strict> blocks to prevent it happening accidentally.  See\nL<perlref/\"Symbolic references\">.  This can be triggered by an C<@> or C<$>\nin a double-quoted string immediately before interpolating a variable,\nfor example in C<\"user @$twitter_id\">, which says to treat the contents\nof C<$twitter_id> as an array reference; use a C<\\> to have a literal C<@>\nsymbol followed by the contents of C<$twitter_id>: C<\"user \\@$twitter_id\">.\n\n=item Can't use subscript on %s\n\n(F) The compiler tried to interpret a bracketed expression as a\nsubscript.  But to the left of the brackets was an expression that\ndidn't look like a hash or array reference, or anything else subscriptable.\n\n=item Can't use \\%c to mean $%c in expression\n\n(W syntax) In an ordinary expression, backslash is a unary operator that\ncreates a reference to its argument.  The use of backslash to indicate a\nbackreference to a matched substring is valid only as part of a regular\nexpression pattern.  Trying to do this in ordinary Perl code produces a\nvalue that prints out looking like SCALAR(0xdecaf).  Use the $1 form\ninstead.\n\n=item Can't weaken a nonreference\n\n(F) You attempted to weaken something that was not a reference.  Only\nreferences can be weakened.\n\n=item Can't \"when\" outside a topicalizer\n\n(F) You have used a when() block that is neither inside a C<foreach>\nloop nor a C<given> block.  (Note that this error is issued on exit\nfrom the C<when> block, so you won't get the error if the match fails,\nor if you use an explicit C<continue>.)\n\n=item Can't x= to read-only value\n\n(F) You tried to repeat a constant value (often the undefined value)\nwith an assignment operator, which implies modifying the value itself.\nPerhaps you need to copy the value to a temporary, and repeat that.\n\n=item Character following \"\\c\" must be printable ASCII\n\n(F) In C<\\cI<X>>, I<X> must be a printable (non-control) ASCII character.\n\nNote that ASCII characters that don't map to control characters are\ndiscouraged, and will generate the warning (when enabled)\nL</\"\"\\c%c\" is more clearly written simply as \"%s\"\">.\n\n=item Character following \\%c must be '{' or a single-character Unicode property name in regex; marked by <-- HERE in m/%s/\n\n(F) (In the above the C<%c> is replaced by either C<p> or C<P>.)  You\nspecified something that isn't a legal Unicode property name.  Most\nUnicode properties are specified by C<\\p{...}>.  But if the name is a\nsingle character one, the braces may be omitted.\n\n=item Character in 'C' format wrapped in pack\n\n(W pack) You said\n\n    pack(\"C\", $x)\n\nwhere $x is either less than 0 or more than 255; the C<\"C\"> format is\nonly for encoding native operating system characters (ASCII, EBCDIC,\nand so on) and not for Unicode characters, so Perl behaved as if you meant\n\n    pack(\"C\", $x & 255)\n\nIf you actually want to pack Unicode codepoints, use the C<\"U\"> format\ninstead.\n\n=item Character in 'c' format wrapped in pack\n\n(W pack) You said\n\n    pack(\"c\", $x)\n\nwhere $x is either less than -128 or more than 127; the C<\"c\"> format\nis only for encoding native operating system characters (ASCII, EBCDIC,\nand so on) and not for Unicode characters, so Perl behaved as if you meant\n\n    pack(\"c\", $x & 255);\n\nIf you actually want to pack Unicode codepoints, use the C<\"U\"> format\ninstead.\n\n=item Character in '%c' format wrapped in unpack\n\n(W unpack) You tried something like\n\n   unpack(\"H\", \"\\x{2a1}\")\n\nwhere the format expects to process a byte (a character with a value\nbelow 256), but a higher value was provided instead.  Perl uses the\nvalue modulus 256 instead, as if you had provided:\n\n   unpack(\"H\", \"\\x{a1}\")\n\n=item Character in 'W' format wrapped in pack\n\n(W pack) You said\n\n    pack(\"U0W\", $x)\n\nwhere $x is either less than 0 or more than 255.  However, C<U0>-mode\nexpects all values to fall in the interval [0, 255], so Perl behaved\nas if you meant:\n\n    pack(\"U0W\", $x & 255)\n\n=item Character(s) in '%c' format wrapped in pack\n\n(W pack) You tried something like\n\n   pack(\"u\", \"\\x{1f3}b\")\n\nwhere the format expects to process a sequence of bytes (character with a\nvalue below 256), but some of the characters had a higher value.  Perl\nuses the character values modulus 256 instead, as if you had provided:\n\n   pack(\"u\", \"\\x{f3}b\")\n\n=item Character(s) in '%c' format wrapped in unpack\n\n(W unpack) You tried something like\n\n   unpack(\"s\", \"\\x{1f3}b\")\n\nwhere the format expects to process a sequence of bytes (character with a\nvalue below 256), but some of the characters had a higher value.  Perl\nuses the character values modulus 256 instead, as if you had provided:\n\n   unpack(\"s\", \"\\x{f3}b\")\n\n=item charnames alias definitions may not contain a sequence of multiple\nspaces; marked by S<<-- HERE> in %s\n\n(F) You defined a character name which had multiple space characters\nin a row.  Change them to single spaces.  Usually these names are\ndefined in the C<:alias> import argument to C<use charnames>, but they\ncould be defined by a translator installed into C<$^H{charnames}>.  See\nL<charnames/CUSTOM ALIASES>.\n\n=item charnames alias definitions may not contain trailing white-space;\nmarked by S<<-- HERE> in %s\n\n(F) You defined a character name which ended in a space\ncharacter.  Remove the trailing space(s).  Usually these names are\ndefined in the C<:alias> import argument to C<use charnames>, but they\ncould be defined by a translator installed into C<$^H{charnames}>.\nSee L<charnames/CUSTOM ALIASES>.\n\n=item chdir() on unopened filehandle %s\n\n(W unopened) You tried chdir() on a filehandle that was never opened.\n\n=item \"\\c%c\" is more clearly written simply as \"%s\"\n\n(W syntax) The C<\\cI<X>> construct is intended to be a way to specify\nnon-printable characters.  You used it for a printable one, which\nis better written as simply itself, perhaps preceded by a backslash\nfor non-word characters.  Doing it the way you did is not portable\nbetween ASCII and EBCDIC platforms.\n\n=item Cloning substitution context is unimplemented\n\n(F) Creating a new thread inside the C<s///> operator is not supported.\n\n=item closedir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you tried to close is either closed or not really\na dirhandle.  Check your control flow.\n\n=item close() on unopened filehandle %s\n\n(W unopened) You tried to close a filehandle that was never opened.\n\n=item Closure prototype called\n\n(F) If a closure has attributes, the subroutine passed to an attribute\nhandler is the prototype that is cloned when a new closure is created.\nThis subroutine cannot be called.\n\n=item \\C no longer supported in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The \\C character class used to allow a match of single byte\nwithin a multi-byte utf-8 character, but was removed in v5.24 as\nit broke encapsulation and its implementation was extremely buggy.\nIf you really need to process the individual bytes, you probably\nwant to convert your string to one where each underlying byte is\nstored as a character, with utf8::encode().\n\n=item Code missing after '/'\n\n(F) You had a (sub-)template that ends with a '/'.  There must be\nanother template code following the slash.  See L<perlfunc/pack>.\n\n=item Code point 0x%X is not Unicode, and not portable\n\n(S non_unicode) You had a code point that has never been in any\nstandard, so it is likely that languages other than Perl will NOT\nunderstand it.  At one time, it was legal in some standards to have code\npoints up to 0x7FFF_FFFF, but not higher, and this code point is higher.\n\nAcceptance of these code points is a Perl extension, and you should\nexpect that nothing other than Perl can handle them; Perl itself on\nEBCDIC platforms before v5.24 does not handle them.\n\nCode points above 0xFFFF_FFFF require larger than a 32 bit word.\n\nPerl also makes no guarantees that the representation of these code\npoints won't change at some point in the future, say when machines\nbecome available that have larger than a 64-bit word.  At that time,\nfiles written by an older Perl would require conversion before being\nreadable by a newer Perl.\n\n=item Code point 0x%X is not Unicode, may not be portable\n\n(S non_unicode) You had a code point above the Unicode maximum\nof U+10FFFF.\n\nPerl allows strings to contain a superset of Unicode code points, but\nthese may not be accepted by other languages/systems.  Further, even if\nthese languages/systems accept these large code points, they may have\nchosen a different representation for them than the UTF-8-like one that\nPerl has, which would mean files are not exchangeable between them and\nPerl.\n\nOn EBCDIC platforms, code points above 0x3FFF_FFFF have a different\nrepresentation in Perl v5.24 than before, so any file containing these\nthat was written before that version will require conversion before\nbeing readable by a later Perl.\n\n=item %s: Command not found\n\n(A) You've accidentally run your script through B<csh> or another shell\ninstead of Perl.  Check the #! line, or manually feed your script into\nPerl yourself.  The #! line at the top of your file could look like\n\n  #!/usr/bin/perl\n\n=item %s: command not found\n\n(A) You've accidentally run your script through B<bash> or another shell\ninstead of Perl.  Check the #! line, or manually feed your script into\nPerl yourself.  The #! line at the top of your file could look like\n\n  #!/usr/bin/perl\n\n=item %s: command not found: %s\n\n(A) You've accidentally run your script through B<zsh> or another shell\ninstead of Perl.  Check the #! line, or manually feed your script into\nPerl yourself.  The #! line at the top of your file could look like\n\n  #!/usr/bin/perl\n\n=item Compilation failed in require\n\n(F) Perl could not compile a file specified in a C<require> statement.\nPerl uses this generic message when none of the errors that it\nencountered were severe enough to halt compilation immediately.\n\n=item Complex regular subexpression recursion limit (%d) exceeded\n\n(W regexp) The regular expression engine uses recursion in complex\nsituations where back-tracking is required.  Recursion depth is limited\nto 32766, or perhaps less in architectures where the stack cannot grow\narbitrarily.  (\"Simple\" and \"medium\" situations are handled without\nrecursion and are not subject to a limit.)  Try shortening the string\nunder examination; looping in Perl code (e.g. with C<while>) rather than\nin the regular expression engine; or rewriting the regular expression so\nthat it is simpler or backtracks less.  (See L<perlfaq2> for information\non I<Mastering Regular Expressions>.)\n\n=item connect() on closed socket %s\n\n(W closed) You tried to do a connect on a closed socket.  Did you forget\nto check the return value of your socket() call?  See\nL<perlfunc/connect>.\n\n=item Constant(%s): Call to &{$^H{%s}} did not return a defined value\n\n(F) The subroutine registered to handle constant overloading\n(see L<overload>) or a custom charnames handler (see\nL<charnames/CUSTOM TRANSLATORS>) returned an undefined value.\n\n=item Constant(%s): $^H{%s} is not defined\n\n(F) The parser found inconsistencies while attempting to define an\noverloaded constant.  Perhaps you forgot to load the corresponding\nL<overload> pragma?\n\n=item Constant is not %s reference\n\n(F) A constant value (perhaps declared using the C<use constant> pragma)\nis being dereferenced, but it amounts to the wrong type of reference.\nThe message indicates the type of reference that was expected.  This\nusually indicates a syntax error in dereferencing the constant value.\nSee L<perlsub/\"Constant Functions\"> and L<constant>.\n\n=item Constants from lexical variables potentially modified elsewhere are\ndeprecated. This will not be allowed in Perl 5.32\n\n(D deprecated) You wrote something like\n\n    my $var;\n    $sub = sub () { $var };\n\nbut $var is referenced elsewhere and could be modified after the C<sub>\nexpression is evaluated.  Either it is explicitly modified elsewhere\n(C<$var = 3>) or it is passed to a subroutine or to an operator like\nC<printf> or C<map>, which may or may not modify the variable.\n\nTraditionally, Perl has captured the value of the variable at that\npoint and turned the subroutine into a constant eligible for inlining.\nIn those cases where the variable can be modified elsewhere, this\nbreaks the behavior of closures, in which the subroutine captures\nthe variable itself, rather than its value, so future changes to the\nvariable are reflected in the subroutine's return value.\n\nThis usage is deprecated, and will no longer be allowed in Perl 5.32,\nmaking it possible to change the behavior in the future.\n\nIf you intended for the subroutine to be eligible for inlining, then\nmake sure the variable is not referenced elsewhere, possibly by\ncopying it:\n\n    my $var2 = $var;\n    $sub = sub () { $var2 };\n\nIf you do want this subroutine to be a closure that reflects future\nchanges to the variable that it closes over, add an explicit C<return>:\n\n    my $var;\n    $sub = sub () { return $var };\n\n=item Constant subroutine %s redefined\n\n(W redefine)(S) You redefined a subroutine which had previously\nbeen eligible for inlining.  See L<perlsub/\"Constant Functions\">\nfor commentary and workarounds.\n\n=item Constant subroutine %s undefined\n\n(W misc) You undefined a subroutine which had previously been eligible\nfor inlining.  See L<perlsub/\"Constant Functions\"> for commentary and\nworkarounds.\n\n=item Constant(%s) unknown\n\n(F) The parser found inconsistencies either while attempting\nto define an overloaded constant, or when trying to find the\ncharacter name specified in the C<\\N{...}> escape.  Perhaps you\nforgot to load the corresponding L<overload> pragma?\n\n=item :const is experimental\n\n(S experimental::const_attr) The \"const\" attribute is experimental.\nIf you want to use the feature, disable the warning with C<no warnings\n'experimental::const_attr'>, but know that in doing so you are taking\nthe risk that your code may break in a future Perl version.\n\n=item :const is not permitted on named subroutines\n\n(F) The \"const\" attribute causes an anonymous subroutine to be run and\nits value captured at the time that it is cloned.  Named subroutines are\nnot cloned like this, so the attribute does not make sense on them.\n\n=item Copy method did not return a reference\n\n(F) The method which overloads \"=\" is buggy.  See\nL<overload/Copy Constructor>.\n\n=item &CORE::%s cannot be called directly\n\n(F) You tried to call a subroutine in the C<CORE::> namespace\nwith C<&foo> syntax or through a reference.  Some subroutines\nin this package cannot yet be called that way, but must be\ncalled as barewords.  Something like this will work:\n\n    BEGIN { *shove = \\&CORE::push; }\n    shove @array, 1,2,3; # pushes on to @array\n\n=item CORE::%s is not a keyword\n\n(F) The CORE:: namespace is reserved for Perl keywords.\n\n=item Corrupted regexp opcode %d > %d\n\n(P) This is either an error in Perl, or, if you're using\none, your L<custom regular expression engine|perlreapi>.  If not the\nlatter, report the problem through the L<perlbug> utility.\n\n=item corrupted regexp pointers\n\n(P) The regular expression engine got confused by what the regular\nexpression compiler gave it.\n\n=item corrupted regexp program\n\n(P) The regular expression engine got passed a regexp program without a\nvalid magic number.\n\n=item Corrupt malloc ptr 0x%x at 0x%x\n\n(P) The malloc package that comes with Perl had an internal failure.\n\n=item Count after length/code in unpack\n\n(F) You had an unpack template indicating a counted-length string, but\nyou have also specified an explicit size for the string.  See\nL<perlfunc/pack>.\n\n=item Declaring references is experimental\n\n(S experimental::declared_refs) This warning is emitted if you use\na reference constructor on the right-hand side of C<my>, C<state>, C<our>, or\nC<local>.  Simply suppress the warning if you want to use the feature, but\nknow that in doing so you are taking the risk of using an experimental\nfeature which may change or be removed in a future Perl version:\n\n    no warnings \"experimental::declared_refs\";\n    use feature \"declared_refs\";\n    $fooref = my \\$foo;\n\n=for comment\nThe following are used in lib/diagnostics.t for testing two =items that\nshare the same description.  Changes here need to be propagated to there\n\n=item Deep recursion on anonymous subroutine\n\n=item Deep recursion on subroutine \"%s\"\n\n(W recursion) This subroutine has called itself (directly or indirectly)\n100 times more than it has returned.  This probably indicates an\ninfinite recursion, unless you're writing strange benchmark programs, in\nwhich case it indicates something else.\n\nThis threshold can be changed from 100, by recompiling the F<perl> binary,\nsetting the C pre-processor macro C<PERL_SUB_DEPTH_WARN> to the desired value.\n\n=item (?(DEFINE)....) does not allow branches in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used something like C<(?(DEFINE)...|..)> which is illegal.  The\nmost likely cause of this error is that you left out a parenthesis inside\nof the C<....> part.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item %s defines neither package nor VERSION--version check failed\n\n(F) You said something like \"use Module 42\" but in the Module file\nthere are neither package declarations nor a C<$VERSION>.\n\n=item delete argument is not a HASH or ARRAY element or slice\n\n(F) The argument to C<delete> must be either a hash or array element,\nsuch as:\n\n    $foo{$bar}\n    $ref->{\"susie\"}[12]\n\nor a hash or array slice, such as:\n\n    @foo[$bar, $baz, $xyzzy]\n    @{$ref->[12]}{\"susie\", \"queue\"}\n\nor a hash key/value or array index/value slice, such as:\n\n    %foo[$bar, $baz, $xyzzy]\n    %{$ref->[12]}{\"susie\", \"queue\"}\n\n=item Delimiter for here document is too long\n\n(F) In a here document construct like C<<<FOO>, the label C<FOO> is too\nlong for Perl to handle.  You have to be seriously twisted to write code\nthat triggers this error.\n\n=item Deprecated use of my() in false conditional. This will be a fatal error in Perl 5.30\n\n(D deprecated) You used a declaration similar to C<my $x if 0>.  There\nhas been a long-standing bug in Perl that causes a lexical variable\nnot to be cleared at scope exit when its declaration includes a false\nconditional.  Some people have exploited this bug to achieve a kind of\nstatic variable.  Since we intend to fix this bug, we don't want people\nrelying on this behavior.  You can achieve a similar static effect by\ndeclaring the variable in a separate block outside the function, eg\n\n    sub f { my $x if 0; return $x++ }\n\nbecomes\n\n    { my $x; sub f { return $x++ } }\n\nBeginning with perl 5.10.0, you can also use C<state> variables to have\nlexicals that are initialized only once (see L<feature>):\n\n    sub f { state $x; return $x++ }\n\nThis use of C<my()> in a false conditional has been deprecated since\nPerl 5.10, and it will become a fatal error in Perl 5.30.\n\n=item DESTROY created new reference to dead object '%s'\n\n(F) A DESTROY() method created a new reference to the object which is\njust being DESTROYed.  Perl is confused, and prefers to abort rather\nthan to create a dangling reference.\n\n=item Did not produce a valid header\n\nSee L</500 Server error>.\n\n=item %s did not return a true value\n\n(F) A required (or used) file must return a true value to indicate that\nit compiled correctly and ran its initialization code correctly.  It's\ntraditional to end such a file with a \"1;\", though any true value would\ndo.  See L<perlfunc/require>.\n\n=item (Did you mean &%s instead?)\n\n(W misc) You probably referred to an imported subroutine &FOO as $FOO or\nsome such.\n\n=item (Did you mean \"local\" instead of \"our\"?)\n\n(W shadow) Remember that \"our\" does not localize the declared global\nvariable.  You have declared it again in the same lexical scope, which\nseems superfluous.\n\n=item (Did you mean $ or @ instead of %?)\n\n(W) You probably said %hash{$key} when you meant $hash{$key} or\n@hash{@keys}.  On the other hand, maybe you just meant %hash and got\ncarried away.\n\n=item Died\n\n(F) You passed die() an empty string (the equivalent of C<die \"\">) or\nyou called it with no args and C<$@> was empty.\n\n=item Document contains no data\n\nSee L</500 Server error>.\n\n=item %s does not define %s::VERSION--version check failed\n\n(F) You said something like \"use Module 42\" but the Module did not\ndefine a C<$VERSION>.\n\n=item '/' does not take a repeat count\n\n(F) You cannot put a repeat count of any kind right after the '/' code.\nSee L<perlfunc/pack>.\n\n=item do \"%s\" failed, '.' is no longer in @INC; did you mean do \"./%s\"?\n\n(D deprecated) Previously C< do \"somefile\"; > would search the current\ndirectory for the specified file.  Since perl v5.26.0, F<.> has been\nremoved from C<@INC> by default, so this is no longer true.  To search the\ncurrent directory (and only the current directory) you can write\nC< do \"./somefile\"; >.\n\n=item Don't know how to get file name\n\n(P) C<PerlIO_getname>, a perl internal I/O function specific to VMS, was\nsomehow called on another platform.  This should not happen.\n\n=item Don't know how to handle magic of type \\%o\n\n(P) The internal handling of magical variables has been cursed.\n\n=item do_study: out of memory\n\n(P) This should have been caught by safemalloc() instead.\n\n=item (Do you need to predeclare %s?)\n\n(S syntax) This is an educated guess made in conjunction with the message\n\"%s found where operator expected\".  It often means a subroutine or module\nname is being referenced that hasn't been declared yet.  This may be\nbecause of ordering problems in your file, or because of a missing\n\"sub\", \"package\", \"require\", or \"use\" statement.  If you're referencing\nsomething that isn't defined yet, you don't actually have to define the\nsubroutine or package before the current location.  You can use an empty\n\"sub foo;\" or \"package FOO;\" to enter a \"forward\" declaration.\n\n=item dump() better written as CORE::dump(). dump() will no longer be available in Perl 5.30\n\n(D deprecated, misc) You used the obsolescent C<dump()> built-in function,\nwithout fully qualifying it as C<CORE::dump()>. Maybe it's a typo.\n\nUse of a unqualified C<dump()> was deprecated in Perl 5.8.0, and this\nwill not be available in Perl 5.30.\n\nSee L<perlfunc/dump>.\n\n=item dump is not supported\n\n(F) Your machine doesn't support dump/undump.\n\n=item Duplicate free() ignored\n\n(S malloc) An internal routine called free() on something that had\nalready been freed.\n\n=item Duplicate modifier '%c' after '%c' in %s\n\n(W unpack) You have applied the same modifier more than once after a\ntype in a pack template.  See L<perlfunc/pack>.\n\n=item elseif should be elsif\n\n(S syntax) There is no keyword \"elseif\" in Perl because Larry thinks\nit's ugly.  Your code will be interpreted as an attempt to call a method\nnamed \"elseif\" for the class returned by the following block.  This is\nunlikely to be what you want.\n\n=item Empty \\%c in regex; marked by S<<-- HERE> in m/%s/\n\n=item Empty \\%c{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) C<\\p> and C<\\P> are used to introduce a named Unicode property, as\ndescribed in L<perlunicode> and L<perlre>.  You used C<\\p> or C<\\P> in\na regular expression without specifying the property name.\n\n=item ${^ENCODING} is no longer supported\n\n(F) The special variable C<${^ENCODING}>, formerly used to implement\nthe C<encoding> pragma, is no longer supported as of Perl 5.26.0.\n\nSetting it to anything other than C<undef> is a fatal error as of Perl\n5.28.\n\n=item entering effective %s failed\n\n(F) While under the C<use filetest> pragma, switching the real and\neffective uids or gids failed.\n\n=item %ENV is aliased to %s\n\n(F) You're running under taint mode, and the C<%ENV> variable has been\naliased to another hash, so it doesn't reflect anymore the state of the\nprogram's environment.  This is potentially insecure.\n\n=item Error converting file specification %s\n\n(F) An error peculiar to VMS.  Because Perl may have to deal with file\nspecifications in either VMS or Unix syntax, it converts them to a\nsingle form when it must operate on them directly.  Either you've passed\nan invalid file specification to Perl, or you've found a case the\nconversion routines don't handle.  Drat.\n\n=item Eval-group in insecure regular expression\n\n(F) Perl detected tainted data when trying to compile a regular\nexpression that contains the C<(?{ ... })> zero-width assertion, which\nis unsafe.  See L<perlre/(?{ code })>, and L<perlsec>.\n\n=item Eval-group not allowed at runtime, use re 'eval' in regex m/%s/\n\n(F) Perl tried to compile a regular expression containing the\nC<(?{ ... })> zero-width assertion at run time, as it would when the\npattern contains interpolated values.  Since that is a security risk,\nit is not allowed.  If you insist, you may still do this by using the\nC<re 'eval'> pragma or by explicitly building the pattern from an\ninterpolated string at run time and using that in an eval().  See\nL<perlre/(?{ code })>.\n\n=item Eval-group not allowed, use re 'eval' in regex m/%s/\n\n(F) A regular expression contained the C<(?{ ... })> zero-width\nassertion, but that construct is only allowed when the C<use re 'eval'>\npragma is in effect.  See L<perlre/(?{ code })>.\n\n=item EVAL without pos change exceeded limit in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used a pattern that nested too many EVAL calls without consuming\nany text.  Restructure the pattern so that text is consumed.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Excessively long <> operator\n\n(F) The contents of a <> operator may not exceed the maximum size of a\nPerl identifier.  If you're just trying to glob a long list of\nfilenames, try using the glob() operator, or put the filenames into a\nvariable and glob that.\n\n=item exec? I'm not *that* kind of operating system\n\n(F) The C<exec> function is not implemented on some systems, e.g., Symbian\nOS.  See L<perlport>.\n\n=item %sExecution of %s aborted due to compilation errors.\n\n(F) The final summary message when a Perl compilation fails.\n\n=item exists argument is not a HASH or ARRAY element or a subroutine\n\n(F) The argument to C<exists> must be a hash or array element or a\nsubroutine with an ampersand, such as:\n\n    $foo{$bar}\n    $ref->{\"susie\"}[12]\n    &do_something\n\n=item exists argument is not a subroutine name\n\n(F) The argument to C<exists> for C<exists &sub> must be a subroutine name,\nand not a subroutine call.  C<exists &sub()> will generate this error.\n\n=item Exiting eval via %s\n\n(W exiting) You are exiting an eval by unconventional means, such as a\ngoto, or a loop control statement.\n\n=item Exiting format via %s\n\n(W exiting) You are exiting a format by unconventional means, such as a\ngoto, or a loop control statement.\n\n=item Exiting pseudo-block via %s\n\n(W exiting) You are exiting a rather special block construct (like a\nsort block or subroutine) by unconventional means, such as a goto, or a\nloop control statement.  See L<perlfunc/sort>.\n\n=item Exiting subroutine via %s\n\n(W exiting) You are exiting a subroutine by unconventional means, such\nas a goto, or a loop control statement.\n\n=item Exiting substitution via %s\n\n(W exiting) You are exiting a substitution by unconventional means, such\nas a return, a goto, or a loop control statement.\n\n=item Expecting close bracket in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You wrote something like\n\n (?13\n\nto denote a capturing group of the form\nL<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>,\nbut omitted the C<\")\">.\n\n=item Expecting '(?flags:(?[...' in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The C<(?[...])> extended character class regular expression construct\nonly allows character classes (including character class escapes like\nC<\\d>), operators, and parentheses.  The one exception is C<(?flags:...)>\ncontaining at least one flag and exactly one C<(?[...])> construct.\nThis allows a regular expression containing just C<(?[...])> to be\ninterpolated.  If you see this error message, then you probably\nhave some other C<(?...)> construct inside your character class.  See\nL<perlrecharclass/Extended Bracketed Character Classes>.\n\n=item Experimental aliasing via reference not enabled\n\n(F) To do aliasing via references, you must first enable the feature:\n\n    no warnings \"experimental::refaliasing\";\n    use feature \"refaliasing\";\n    \\$x = \\$y;\n\n=item Experimental %s on scalar is now forbidden\n\n(F) An experimental feature added in Perl 5.14 allowed C<each>, C<keys>,\nC<push>, C<pop>, C<shift>, C<splice>, C<unshift>, and C<values> to be called with a\nscalar argument.  This experiment is considered unsuccessful, and\nhas been removed.  The C<postderef> feature may meet your needs better.\n\n=item Experimental subroutine signatures not enabled\n\n(F) To use subroutine signatures, you must first enable them:\n\n    no warnings \"experimental::signatures\";\n    use feature \"signatures\";\n    sub foo ($left, $right) { ... }\n\n=item Explicit blessing to '' (assuming package main)\n\n(W misc) You are blessing a reference to a zero length string.  This has\nthe effect of blessing the reference into the package main.  This is\nusually not what you want.  Consider providing a default target package,\ne.g. bless($ref, $p || 'MyPackage');\n\n=item %s: Expression syntax\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item %s failed--call queue aborted\n\n(F) An untrapped exception was raised while executing a UNITCHECK,\nCHECK, INIT, or END subroutine.  Processing of the remainder of the\nqueue of such routines has been prematurely ended.\n\n=item Failed to close in-place work file %s: %s\n\n(F) Closing an output file from in-place editing, as with the C<-i>\ncommand-line switch, failed.\n\n=item False [] range \"%s\" in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp)(F) A character class range must start and end at a literal\ncharacter, not another character class like C<\\d> or C<[:alpha:]>.  The \"-\"\nin your false range is interpreted as a literal \"-\".  In a C<(?[...])>\nconstruct, this is an error, rather than a warning.  Consider quoting\nthe \"-\", \"\\-\".  The S<<-- HERE> shows whereabouts in the regular expression\nthe problem was discovered.  See L<perlre>.\n\n=item Fatal VMS error (status=%d) at %s, line %d\n\n(P) An error peculiar to VMS.  Something untoward happened in a VMS\nsystem service or RTL routine; Perl's exit status should provide more\ndetails.  The filename in \"at %s\" and the line number in \"line %d\" tell\nyou which section of the Perl source code is distressed.\n\n=item fcntl is not implemented\n\n(F) Your machine apparently doesn't implement fcntl().  What is this, a\nPDP-11 or something?\n\n=item FETCHSIZE returned a negative value\n\n(F) A tied array claimed to have a negative number of elements, which\nis not possible.\n\n=item Field too wide in 'u' format in pack\n\n(W pack) Each line in an uuencoded string starts with a length indicator\nwhich can't encode values above 63.  So there is no point in asking for\na line length bigger than that.  Perl will behave as if you specified\nC<u63> as the format.\n\n=item File::Glob::glob() will disappear in perl 5.30. Use File::Glob::bsd_glob() instead.\n\n(D deprecated) C<< File::Glob >> has a function called C<< glob >>, which\njust calls C<< bsd_glob >>. However, its prototype is different from the\nprototype of C<< CORE::glob >>, and hence, C<< File::Glob::glob >> should\nnot be used.\n\nC<< File::Glob::glob() >> was deprecated in perl 5.8.0. A deprecation\nmessage was issued from perl 5.26.0 onwards, and the function will\ndisappear in perl 5.30.0.\n\nCode using C<< File::Glob::glob() >> should call\nC<< File::Glob::bsd_glob() >> instead.\n\n=item Filehandle %s opened only for input\n\n(W io) You tried to write on a read-only filehandle.  If you intended\nit to be a read-write filehandle, you needed to open it with \"+<\" or\n\"+>\" or \"+>>\" instead of with \"<\" or nothing.  If you intended only to\nwrite the file, use \">\" or \">>\".  See L<perlfunc/open>.\n\n=item Filehandle %s opened only for output\n\n(W io) You tried to read from a filehandle opened only for writing, If\nyou intended it to be a read/write filehandle, you needed to open it\nwith \"+<\" or \"+>\" or \"+>>\" instead of with \">\".  If you intended only to\nread from the file, use \"<\".  See L<perlfunc/open>.  Another possibility\nis that you attempted to open filedescriptor 0 (also known as STDIN) for\noutput (maybe you closed STDIN earlier?).\n\n=item Filehandle %s reopened as %s only for input\n\n(W io) You opened for reading a filehandle that got the same filehandle id\nas STDOUT or STDERR.  This occurred because you closed STDOUT or STDERR\npreviously.\n\n=item Filehandle STDIN reopened as %s only for output\n\n(W io) You opened for writing a filehandle that got the same filehandle id\nas STDIN.  This occurred because you closed STDIN previously.\n\n=item Final $ should be \\$ or $name\n\n(F) You must now decide whether the final $ in a string was meant to be\na literal dollar sign, or was meant to introduce a variable name that\nhappens to be missing.  So you have to put either the backslash or the\nname.\n\n=item flock() on closed filehandle %s\n\n(W closed) The filehandle you're attempting to flock() got itself closed\nsome time before now.  Check your control flow.  flock() operates on\nfilehandles.  Are you attempting to call flock() on a dirhandle by the\nsame name?\n\n=item Format not terminated\n\n(F) A format must be terminated by a line with a solitary dot.  Perl got\nto the end of your file without finding such a line.\n\n=item Format %s redefined\n\n(W redefine) You redefined a format.  To suppress this warning, say\n\n    {\n\tno warnings 'redefine';\n\teval \"format NAME =...\";\n    }\n\n=item Found = in conditional, should be ==\n\n(W syntax) You said\n\n    if ($foo = 123)\n\nwhen you meant\n\n    if ($foo == 123)\n\n(or something like that).\n\n=item %s found where operator expected\n\n(S syntax) The Perl lexer knows whether to expect a term or an operator.\nIf it sees what it knows to be a term when it was expecting to see an\noperator, it gives you this warning.  Usually it indicates that an\noperator or delimiter was omitted, such as a semicolon.\n\n=item gdbm store returned %d, errno %d, key \"%s\"\n\n(S) A warning from the GDBM_File extension that a store failed.\n\n=item gethostent not implemented\n\n(F) Your C library apparently doesn't implement gethostent(), probably\nbecause if it did, it'd feel morally obligated to return every hostname\non the Internet.\n\n=item get%sname() on closed socket %s\n\n(W closed) You tried to get a socket or peer socket name on a closed\nsocket.  Did you forget to check the return value of your socket() call?\n\n=item getpwnam returned invalid UIC %#o for user \"%s\"\n\n(S) A warning peculiar to VMS.  The call to C<sys$getuai> underlying the\nC<getpwnam> operator returned an invalid UIC.\n\n=item getsockopt() on closed socket %s\n\n(W closed) You tried to get a socket option on a closed socket.  Did you\nforget to check the return value of your socket() call?  See\nL<perlfunc/getsockopt>.\n\n=item given is experimental\n\n(S experimental::smartmatch) C<given> depends on smartmatch, which\nis experimental, so its behavior may change or even be removed\nin any future release of perl.  See the explanation under\nL<perlsyn/Experimental Details on given and when>.\n\n=item Global symbol \"%s\" requires explicit package name (did you forget to\ndeclare \"my %s\"?)\n\n(F) You've said \"use strict\" or \"use strict vars\", which indicates \nthat all variables must either be lexically scoped (using \"my\" or \"state\"), \ndeclared beforehand using \"our\", or explicitly qualified to say \nwhich package the global variable is in (using \"::\").\n\n=item glob failed (%s)\n\n(S glob) Something went wrong with the external program(s) used\nfor C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a C<glob>\npattern that caused the external program to fail and exit with a\nnonzero status.  If the message indicates that the abnormal exit\nresulted in a coredump, this may also mean that your csh (C shell)\nis broken.  If so, you should change all of the csh-related variables\nin config.sh:  If you have tcsh, make the variables refer to it as\nif it were csh (e.g. C<full_csh='/usr/bin/tcsh'>); otherwise, make them\nall empty (except that C<d_csh> should be C<'undef'>) so that Perl will\nthink csh is missing.  In either case, after editing config.sh, run\nC<./Configure -S> and rebuild Perl.\n\n=item Glob not terminated\n\n(F) The lexer saw a left angle bracket in a place where it was expecting\na term, so it's looking for the corresponding right angle bracket, and\nnot finding it.  Chances are you left some needed parentheses out\nearlier in the line, and you really meant a \"less than\".\n\n=item gmtime(%f) failed\n\n(W overflow) You called C<gmtime> with a number that it could not handle:\ntoo large, too small, or NaN.  The returned value is C<undef>.\n\n=item gmtime(%f) too large\n\n(W overflow) You called C<gmtime> with a number that was larger than\nit can reliably handle and C<gmtime> probably returned the wrong\ndate.  This warning is also triggered with NaN (the special\nnot-a-number value).\n\n=item gmtime(%f) too small\n\n(W overflow) You called C<gmtime> with a number that was smaller than\nit can reliably handle and C<gmtime> probably returned the wrong date.\n\n=item Got an error from DosAllocMem\n\n(P) An error peculiar to OS/2.  Most probably you're using an obsolete\nversion of Perl, and this should not happen anyway.\n\n=item goto must have label\n\n(F) Unlike with \"next\" or \"last\", you're not allowed to goto an\nunspecified destination.  See L<perlfunc/goto>.\n\n=item Goto undefined subroutine%s\n\n(F) You tried to call a subroutine with C<goto &sub> syntax, but\nthe indicated subroutine hasn't been defined, or if it was, it\nhas since been undefined.\n\n=item Group name must start with a non-digit word character in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) Group names must follow the rules for perl identifiers, meaning\nthey must start with a non-digit word character.  A common cause of\nthis error is using (?&0) instead of (?0).  See L<perlre>.\n\n=item ()-group starts with a count\n\n(F) A ()-group started with a count.  A count is supposed to follow\nsomething: a template character or a ()-group.  See L<perlfunc/pack>.\n\n=item %s had compilation errors.\n\n(F) The final summary message when a C<perl -c> fails.\n\n=item Had to create %s unexpectedly\n\n(S internal) A routine asked for a symbol from a symbol table that ought\nto have existed already, but for some reason it didn't, and had to be\ncreated on an emergency basis to prevent a core dump.\n\n=item %s has too many errors\n\n(F) The parser has given up trying to parse the program after 10 errors.\nFurther error messages would likely be uninformative.\n\n=item Hexadecimal float: exponent overflow\n\n(W overflow) The hexadecimal floating point has a larger exponent\nthan the floating point supports.\n\n=item Hexadecimal float: exponent underflow\n\n(W overflow) The hexadecimal floating point has a smaller exponent\nthan the floating point supports.  With the IEEE 754 floating point,\nthis may also mean that the subnormals (formerly known as denormals)\nare being used, which may or may not be an error.\n\n=item Hexadecimal float: internal error (%s)\n\n(F) Something went horribly bad in hexadecimal float handling.\n\n=item Hexadecimal float: mantissa overflow\n\n(W overflow) The hexadecimal floating point literal had more bits in\nthe mantissa (the part between the 0x and the exponent, also known as\nthe fraction or the significand) than the floating point supports.\n\n=item Hexadecimal float: precision loss\n\n(W overflow) The hexadecimal floating point had internally more\ndigits than could be output.  This can be caused by unsupported\nlong double formats, or by 64-bit integers not being available\n(needed to retrieve the digits under some configurations).\n\n=item Hexadecimal float: unsupported long double format\n\n(F) You have configured Perl to use long doubles but\nthe internals of the long double format are unknown;\ntherefore the hexadecimal float output is impossible.\n\n=item Hexadecimal number > 0xffffffff non-portable\n\n(W portable) The hexadecimal number you specified is larger than 2**32-1\n(4294967295) and therefore non-portable between systems.  See\nL<perlport> for more on portability concerns.\n\n=item Identifier too long\n\n(F) Perl limits identifiers (names for variables, functions, etc.) to\nabout 250 characters for simple names, and somewhat more for compound\nnames (like C<$A::B>).  You've exceeded Perl's limits.  Future versions\nof Perl are likely to eliminate these arbitrary limitations.\n\n=item Ignoring zero length \\N{} in character class in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) Named Unicode character escapes (C<\\N{...}>) may return a\nzero-length sequence.  When such an escape is used in a character\nclass its behavior is not well defined.  Check that the correct\nescape has been used, and the correct charname handler is in scope.\n\n=item Illegal binary digit '%c'\n\n(F) You used a digit other than 0 or 1 in a binary number.\n\n=item Illegal binary digit %s ignored\n\n(W digit) You may have tried to use a digit other than 0 or 1 in a\nbinary number.  Interpretation of the binary number stopped before the\noffending digit.\n\n=item Illegal character after '_' in prototype for %s : %s\n\n(W illegalproto) An illegal character was found in a prototype\ndeclaration.  The '_' in a prototype must be followed by a ';',\nindicating the rest of the parameters are optional, or one of '@'\nor '%', since those two will accept 0 or more final parameters.\n\n=item Illegal character \\%o (carriage return)\n\n(F) Perl normally treats carriage returns in the program text as\nit would any other whitespace, which means you should never see\nthis error when Perl was built using standard options.  For some\nreason, your version of Perl appears to have been built without\nthis support.  Talk to your Perl administrator.\n\n=item Illegal character following sigil in a subroutine signature\n\n(F) A parameter in a subroutine signature contained an unexpected character\nfollowing the C<$>, C<@> or C<%> sigil character.  Normally the sigil\nshould be followed by the variable name or C<=> etc.  Perhaps you are\ntrying use a prototype while in the scope of C<use feature 'signatures'>?\nFor example:\n\n    sub foo ($$) {}            # legal - a prototype\n\n    use feature 'signatures;\n    sub foo ($$) {}            # illegal - was expecting a signature\n    sub foo ($a, $b)\n            :prototype($$) {}  # legal\n\n\n=item Illegal character in prototype for %s : %s\n\n(W illegalproto) An illegal character was found in a prototype declaration.\nLegal characters in prototypes are $, @, %, *, ;, [, ], &, \\, and +.\nPerhaps you were trying to write a subroutine signature but didn't enable\nthat feature first (C<use feature 'signatures'>), so your signature was\ninstead interpreted as a bad prototype.\n\n=item Illegal declaration of anonymous subroutine\n\n(F) When using the C<sub> keyword to construct an anonymous subroutine,\nyou must always specify a block of code.  See L<perlsub>.\n\n=item Illegal declaration of subroutine %s\n\n(F) A subroutine was not declared correctly.  See L<perlsub>.\n\n=item Illegal division by zero\n\n(F) You tried to divide a number by 0.  Either something was wrong in\nyour logic, or you need to put a conditional in to guard against\nmeaningless input.\n\n=item Illegal hexadecimal digit %s ignored\n\n(W digit) You may have tried to use a character other than 0 - 9 or\nA - F, a - f in a hexadecimal number.  Interpretation of the hexadecimal\nnumber stopped before the illegal character.\n\n=item Illegal modulus zero\n\n(F) You tried to divide a number by 0 to get the remainder.  Most\nnumbers don't take to this kindly.\n\n=item Illegal number of bits in vec\n\n(F) The number of bits in vec() (the third argument) must be a power of\ntwo from 1 to 32 (or 64, if your platform supports that).\n\n=item Illegal octal digit '%c'\n\n(F) You used an 8 or 9 in an octal number.\n\n=item Illegal octal digit %s ignored\n\n(W digit) You may have tried to use an 8 or 9 in an octal number.\nInterpretation of the octal number stopped before the 8 or 9.\n\n=item Illegal operator following parameter in a subroutine signature\n\n(F) A parameter in a subroutine signature, was followed by something\nother than C<=> introducing a default, C<,> or C<)>.\n\n    use feature 'signatures';\n    sub foo ($=1) {}           # legal\n    sub foo ($a = 1) {}        # legal\n    sub foo ($a += 1) {}       # illegal\n    sub foo ($a == 1) {}       # illegal\n\n=item Illegal pattern in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You wrote something like\n\n (?+foo)\n\nThe C<\"+\"> is valid only when followed by digits, indicating a\ncapturing group.  See\nL<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>.\n\n=item Illegal suidscript\n\n(F) The script run under suidperl was somehow illegal.\n\n=item Illegal switch in PERL5OPT: -%c\n\n(X) The PERL5OPT environment variable may only be used to set the\nfollowing switches: B<-[CDIMUdmtw]>.\n\n=item Illegal user-defined property name\n\n(F) You specified a Unicode-like property name in a regular expression\npattern (using C<\\p{}> or C<\\P{}>) that Perl knows isn't an official\nUnicode property, and was likely meant to be a user-defined property\nname, but it can't be one of those, as they must begin with either C<In>\nor C<Is>.  Check the spelling.  See also\nL</Can't find Unicode property definition \"%s\">.\n\n=item Ill-formed CRTL environ value \"%s\"\n\n(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's\ninternal environ array, and encountered an element without the C<=>\ndelimiter used to separate keys from values.  The element is ignored.\n\n=item Ill-formed message in prime_env_iter: |%s|\n\n(W internal) A warning peculiar to VMS.  Perl tried to read a logical\nname or CLI symbol definition when preparing to iterate over %ENV, and\ndidn't see the expected delimiter between key and value, so the line was\nignored.\n\n=item (in cleanup) %s\n\n(W misc) This prefix usually indicates that a DESTROY() method raised\nthe indicated exception.  Since destructors are usually called by the\nsystem at arbitrary points during execution, and often a vast number of\ntimes, the warning is issued only once for any number of failures that\nwould otherwise result in the same message being repeated.\n\nFailure of user callbacks dispatched using the C<G_KEEPERR> flag could\nalso result in this warning.  See L<perlcall/G_KEEPERR>.\n\n=item Incomplete expression within '(?[ ])' in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) There was a syntax error within the C<(?[ ])>.  This can happen if the\nexpression inside the construct was completely empty, or if there are\ntoo many or few operands for the number of operators.  Perl is not smart\nenough to give you a more precise indication as to what is wrong.\n\n=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on \nparent '%s'\n\n(F) The method resolution order (MRO) of the given class is not\nC3-consistent, and you have enabled the C3 MRO for this class.  See the C3\ndocumentation in L<mro> for more information.\n\n=item Indentation on line %d of here-doc doesn't match delimiter\n\n(F) You have an indented here-document where one or more of its lines\nhave whitespace at the beginning that does not match the closing\ndelimiter.\n\nFor example, line 2 below is wrong because it does not have at least\n2 spaces, but lines 1 and 3 are fine because they have at least 2:\n\n    if ($something) {\n      print <<~EOF;\n        Line 1\n       Line 2 not\n          Line 3\n        EOF\n    }\n\nNote that tabs and spaces are compared strictly, meaning 1 tab will\nnot match 8 spaces.\n\n=item Infinite recursion in regex\n\n(F) You used a pattern that references itself without consuming any input\ntext.  You should check the pattern to ensure that recursive patterns\neither consume text or fail.\n\n=item Infinite recursion via empty pattern\n\n(F) You tried to use the empty pattern inside of a regex code block,\nfor instance C</(?{ s!!! })/>, which resulted in re-executing\nthe same pattern, which is an infinite loop which is broken by\nthrowing an exception.\n\n=item Initialization of state variables in list currently forbidden\n\n(F) C<state> only permits initializing a single variable, specified\nwithout parentheses.  So C<state $a = 42> and C<state @a = qw(a b c)> are\nallowed, but not C<state ($a) = 42> or C<(state $a) = 42>.  To initialize\nmore than one C<state> variable, initialize them one at a time.\n\n=item %%s[%s] in scalar context better written as $%s[%s]\n\n(W syntax) In scalar context, you've used an array index/value slice\n(indicated by %) to select a single element of an array.  Generally\nit's better to ask for a scalar value (indicated by $).  The difference\nis that C<$foo[&bar]> always behaves like a scalar, both in the value it\nreturns and when evaluating its argument, while C<%foo[&bar]> provides\na list context to its subscript, which can do weird things if you're\nexpecting only one subscript.  When called in list context, it also\nreturns the index (what C<&bar> returns) in addition to the value.\n\n=item %%s{%s} in scalar context better written as $%s{%s}\n\n(W syntax) In scalar context, you've used a hash key/value slice\n(indicated by %) to select a single element of a hash.  Generally it's\nbetter to ask for a scalar value (indicated by $).  The difference\nis that C<$foo{&bar}> always behaves like a scalar, both in the value\nit returns and when evaluating its argument, while C<@foo{&bar}> and\nprovides a list context to its subscript, which can do weird things\nif you're expecting only one subscript.  When called in list context,\nit also returns the key in addition to the value.\n\n=item Insecure dependency in %s\n\n(F) You tried to do something that the tainting mechanism didn't like.\nThe tainting mechanism is turned on when you're running setuid or\nsetgid, or when you specify B<-T> to turn it on explicitly.  The\ntainting mechanism labels all data that's derived directly or indirectly\nfrom the user, who is considered to be unworthy of your trust.  If any\nsuch data is used in a \"dangerous\" operation, you get this error.  See\nL<perlsec> for more information.\n\n=item Insecure directory in %s\n\n(F) You can't use system(), exec(), or a piped open in a setuid or\nsetgid script if C<$ENV{PATH}> contains a directory that is writable by\nthe world.  Also, the PATH must not contain any relative directory.\nSee L<perlsec>.\n\n=item Insecure $ENV{%s} while running %s\n\n(F) You can't use system(), exec(), or a piped open in a setuid or\nsetgid script if any of C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>,\nC<$ENV{ENV}>, C<$ENV{BASH_ENV}> or C<$ENV{TERM}> are derived from data\nsupplied (or potentially supplied) by the user.  The script must set\nthe path to a known value, using trustworthy data.  See L<perlsec>.\n\n=item Insecure user-defined property %s\n\n(F) Perl detected tainted data when trying to compile a regular\nexpression that contains a call to a user-defined character property\nfunction, i.e. C<\\p{IsFoo}> or C<\\p{InFoo}>.\nSee L<perlunicode/User-Defined Character Properties> and L<perlsec>.\n\n=item Integer overflow in format string for %s\n\n(F) The indexes and widths specified in the format string of C<printf()>\nor C<sprintf()> are too large.  The numbers must not overflow the size of\nintegers for your architecture.\n\n=item Integer overflow in %s number\n\n(S overflow) The hexadecimal, octal or binary number you have specified\neither as a literal or as an argument to hex() or oct() is too big for\nyour architecture, and has been converted to a floating point number.\nOn a 32-bit architecture the largest hexadecimal, octal or binary number\nrepresentable without overflow is 0xFFFFFFFF, 037777777777, or\n0b11111111111111111111111111111111 respectively.  Note that Perl\ntransparently promotes all numbers to a floating point representation\ninternally--subject to loss of precision errors in subsequent\noperations.\n\n=item Integer overflow in srand\n\n(S overflow) The number you have passed to srand is too big to fit\nin your architecture's integer representation.  The number has been\nreplaced with the largest integer supported (0xFFFFFFFF on 32-bit\narchitectures).  This means you may be getting less randomness than\nyou expect, because different random seeds above the maximum will\nreturn the same sequence of random numbers.\n\n=item Integer overflow in version\n\n=item Integer overflow in version %d\n\n(W overflow) Some portion of a version initialization is too large for\nthe size of integers for your architecture.  This is not a warning\nbecause there is no rational reason for a version to try and use an\nelement larger than typically 2**32.  This is usually caused by trying\nto use some odd mathematical operation as a version, like 100/9.\n\n=item Internal disaster in regex; marked by S<<-- HERE> in m/%s/\n\n(P) Something went badly wrong in the regular expression parser.\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Internal inconsistency in tracking vforks\n\n(S) A warning peculiar to VMS.  Perl keeps track of the number of times\nyou've called C<fork> and C<exec>, to determine whether the current call\nto C<exec> should affect the current script or a subprocess (see\nL<perlvms/\"exec LIST\">).  Somehow, this count has become scrambled, so\nPerl is making a guess and treating this C<exec> as a request to\nterminate the Perl script and execute the specified command.\n\n=item internal %<num>p might conflict with future printf extensions\n\n(S internal) Perl's internal routine that handles C<printf> and C<sprintf>\nformatting follows a slightly different set of rules when called from\nC or XS code.  Specifically, formats consisting of digits followed\nby \"p\" (e.g., \"%7p\") are reserved for future use.  If you see this\nmessage, then an XS module tried to call that routine with one such\nreserved format.\n\n=item Internal urp in regex; marked by S<<-- HERE> in m/%s/\n\n(P) Something went badly awry in the regular expression parser.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item %s (...) interpreted as function\n\n(W syntax) You've run afoul of the rule that says that any list operator\nfollowed by parentheses turns into a function, with all the list\noperators arguments found inside the parentheses.  See\nL<perlop/Terms and List Operators (Leftward)>.\n\n=item In '(?...)', the '(' and '?' must be adjacent in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The two-character sequence C<\"(?\"> in this context in a regular\nexpression pattern should be an indivisible token, with nothing\nintervening between the C<\"(\"> and the C<\"?\">, but you separated them\nwith whitespace.\n\n=item Invalid %s attribute: %s\n\n(F) The indicated attribute for a subroutine or variable was not recognized\nby Perl or by a user-supplied handler.  See L<attributes>.\n\n=item Invalid %s attributes: %s\n\n(F) The indicated attributes for a subroutine or variable were not\nrecognized by Perl or by a user-supplied handler.  See L<attributes>.\n\n=item Invalid character in charnames alias definition; marked by\nS<<-- HERE> in '%s\n\n(F) You tried to create a custom alias for a character name, with\nthe C<:alias> option to C<use charnames> and the specified character in\nthe indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.\n\n=item Invalid \\0 character in %s for %s: %s\\0%s\n\n(W syscalls) Embedded \\0 characters in pathnames or other system call\narguments produce a warning as of 5.20.  The parts after the \\0 were\nformerly ignored by system calls.\n\n=item Invalid character in \\N{...}; marked by S<<-- HERE> in \\N{%s}\n\n(F) Only certain characters are valid for character names.  The\nindicated one isn't.  See L<charnames/CUSTOM ALIASES>.\n\n=item Invalid conversion in %s: \"%s\"\n\n(W printf) Perl does not understand the given format conversion.  See\nL<perlfunc/sprintf>.\n\n=item Invalid escape in the specified encoding in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp)(F) The numeric escape (for example C<\\xHH>) of value < 256\ndidn't correspond to a single character through the conversion\nfrom the encoding specified by the encoding pragma.\nThe escape was replaced with REPLACEMENT CHARACTER (U+FFFD)\ninstead, except within S<C<(?[   ])>>, where it is a fatal error.\nThe S<<-- HERE> shows whereabouts in the regular expression the\nescape was discovered.\n\n=item Invalid hexadecimal number in \\N{U+...}\n\n=item Invalid hexadecimal number in \\N{U+...} in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) The character constant represented by C<...> is not a valid hexadecimal\nnumber.  Either it is empty, or you tried to use a character other than\n0 - 9 or A - F, a - f in a hexadecimal number.\n\n=item Invalid module name %s with -%c option: contains single ':'\n\n(F) The module argument to perl's B<-m> and B<-M> command-line options\ncannot contain single colons in the module name, but only in the\narguments after \"=\".  In other words, B<-MFoo::Bar=:baz> is ok, but\nB<-MFoo:Bar=baz> is not.\n\n=item Invalid mro name: '%s'\n\n(F) You tried to C<mro::set_mro(\"classname\", \"foo\")> or C<use mro 'foo'>,\nwhere C<foo> is not a valid method resolution order (MRO).  Currently,\nthe only valid ones supported are C<dfs> and C<c3>, unless you have loaded\na module that is a MRO plugin.  See L<mro> and L<perlmroapi>.\n\n=item Invalid negative number (%s) in chr\n\n(W utf8) You passed a negative number to C<chr>.  Negative numbers are\nnot valid character numbers, so it returns the Unicode replacement\ncharacter (U+FFFD).\n\n=item Invalid number '%s' for -C option.\n\n(F) You supplied a number to the -C option that either has extra leading\nzeroes or overflows perl's unsigned integer representation.\n\n=item invalid option -D%c, use -D'' to see choices\n\n(S debugging) Perl was called with invalid debugger flags.  Call perl\nwith the B<-D> option with no flags to see the list of acceptable values.\nSee also L<perlrun/-Dletters>.\n\n=item Invalid quantifier in {,} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The pattern looks like a {min,max} quantifier, but the min or max\ncould not be parsed as a valid number - either it has leading zeroes,\nor it represents too big a number to cope with.  The S<<-- HERE> shows\nwhere in the regular expression the problem was discovered.  See L<perlre>.\n\n=item Invalid [] range \"%s\" in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The range specified in a character class had a minimum character\ngreater than the maximum character.  One possibility is that you forgot the\nC<{}> from your ending C<\\x{}> - C<\\x> without the curly braces can go only\nup to C<ff>.  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item Invalid range \"%s\" in transliteration operator\n\n(F) The range specified in the tr/// or y/// operator had a minimum\ncharacter greater than the maximum character.  See L<perlop>.\n\n=item Invalid separator character %s in attribute list\n\n(F) Something other than a colon or whitespace was seen between the\nelements of an attribute list.  If the previous attribute had a\nparenthesised parameter list, perhaps that list was terminated too soon.\nSee L<attributes>.\n\n=item Invalid separator character %s in PerlIO layer specification %s\n\n(W layer) When pushing layers onto the Perl I/O system, something other\nthan a colon or whitespace was seen between the elements of a layer list.\nIf the previous attribute had a parenthesised parameter list, perhaps that\nlist was terminated too soon.\n\n=item Invalid strict version format (%s)\n\n(F) A version number did not meet the \"strict\" criteria for versions.\nA \"strict\" version number is a positive decimal number (integer or\ndecimal-fraction) without exponentiation or else a dotted-decimal\nv-string with a leading 'v' character and at least three components.\nThe parenthesized text indicates which criteria were not met.\nSee the L<version> module for more details on allowed version formats.\n\n=item Invalid type '%s' in %s\n\n(F) The given character is not a valid pack or unpack type.\nSee L<perlfunc/pack>.\n\n(W) The given character is not a valid pack or unpack type but used to be\nsilently ignored.\n\n=item Invalid version format (%s)\n\n(F) A version number did not meet the \"lax\" criteria for versions.\nA \"lax\" version number is a positive decimal number (integer or\ndecimal-fraction) without exponentiation or else a dotted-decimal\nv-string.  If the v-string has fewer than three components, it\nmust have a leading 'v' character.  Otherwise, the leading 'v' is\noptional.  Both decimal and dotted-decimal versions may have a\ntrailing \"alpha\" component separated by an underscore character\nafter a fractional or dotted-decimal component.  The parenthesized\ntext indicates which criteria were not met.  See the L<version> module\nfor more details on allowed version formats.\n\n=item Invalid version object\n\n(F) The internal structure of the version object was invalid.\nPerhaps the internals were modified directly in some way or\nan arbitrary reference was blessed into the \"version\" class.\n\n=item In '(*VERB...)', the '(' and '*' must be adjacent in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The two-character sequence C<\"(*\"> in\nthis context in a regular expression pattern should be an\nindivisible token, with nothing intervening between the C<\"(\">\nand the C<\"*\">, but you separated them.\n\n=item ioctl is not implemented\n\n(F) Your machine apparently doesn't implement ioctl(), which is pretty\nstrange for a machine that supports C.\n\n=item ioctl() on unopened %s\n\n(W unopened) You tried ioctl() on a filehandle that was never opened.\nCheck your control flow and number of arguments.\n\n=item IO layers (like '%s') unavailable\n\n(F) Your Perl has not been configured to have PerlIO, and therefore\nyou cannot use IO layers.  To have PerlIO, Perl must be configured\nwith 'useperlio'.\n\n=item IO::Socket::atmark not implemented on this architecture\n\n(F) Your machine doesn't implement the sockatmark() functionality,\nneither as a system call nor an ioctl call (SIOCATMARK).\n\n=item '%s' is an unknown bound type in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You used C<\\b{...}> or C<\\B{...}> and the C<...> is not known to\nPerl.  The current valid ones are given in\nL<perlrebackslash/\\b{}, \\b, \\B{}, \\B>.\n\n=item %s() is deprecated on :utf8 handles. This will be a fatal error in Perl 5.30\n\n(D deprecated) The sysread(), recv(), syswrite() and send() operators are\ndeprecated on handles that have the C<:utf8> layer, either explicitly, or\nimplicitly, eg., with the C<:encoding(UTF-16LE)> layer.\n\nBoth sysread() and recv() currently use only the C<:utf8> flag for the stream,\nignoring the actual layers.  Since sysread() and recv() do no UTF-8\nvalidation they can end up creating invalidly encoded scalars.\n\nSimilarly, syswrite() and send() use only the C<:utf8> flag, otherwise ignoring\nany layers.  If the flag is set, both write the value UTF-8 encoded, even if\nthe layer is some different encoding, such as the example above.\n\nIdeally, all of these operators would completely ignore the C<:utf8> state,\nworking only with bytes, but this would result in silently breaking existing\ncode.\n\nIn Perl 5.30, it will no longer be possible to use sysread(), recv(),\nsyswrite() or send() to read or send bytes from/to :utf8 handles.\n\n=item \"%s\" is more clearly written simply as \"%s\" in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nYou specified a character that has the given plainer way of writing it, and\nwhich is also portable to platforms running with different character sets.\n\n=item $* is no longer supported. Its use will be fatal in Perl 5.30\n\n(D deprecated, syntax) The special variable C<$*>, deprecated in older\nperls, has been removed as of 5.10.0 and is no longer supported.  In\nprevious versions of perl the use of C<$*> enabled or disabled multi-line\nmatching within a string.\n\nInstead of using C<$*> you should use the C</m> (and maybe C</s>) regexp\nmodifiers.  You can enable C</m> for a lexical scope (even a whole file)\nwith C<use re '/m'>.  (In older versions: when C<$*> was set to a true value\nthen all regular expressions behaved as if they were written using C</m>.)\n\nUse of this variable will be a fatal error in Perl 5.30.\n\n=item $# is no longer supported. Its use will be fatal in Perl 5.30\n\n(D deprecated, syntax) The special variable C<$#>, deprecated in older\nperls, has been removed as of 5.10.0 and is no longer supported.  You\nshould use the printf/sprintf functions instead.\n\nUse of this variable will be a fatal error in Perl 5.30.\n\n=item '%s' is not a code reference\n\n(W overload) The second (fourth, sixth, ...) argument of\noverload::constant needs to be a code reference.  Either\nan anonymous subroutine, or a reference to a subroutine.\n\n=item '%s' is not an overloadable type\n\n(W overload) You tried to overload a constant type the overload package is\nunaware of.\n\n=item -i used with no filenames on the command line, reading from STDIN\n\n(S inplace) The C<-i> option was passed on the command line, indicating\nthat the script is intended to edit files in place, but no files were\ngiven.  This is usually a mistake, since editing STDIN in place doesn't\nmake sense, and can be confusing because it can make perl look like\nit is hanging when it is really just trying to read from STDIN.  You\nshould either pass a filename to edit, or remove C<-i> from the command\nline.  See L<perlrun> for more details.\n\n=item Junk on end of regexp in regex m/%s/\n\n(P) The regular expression parser is confused.\n\n=item Label not found for \"last %s\"\n\n(F) You named a loop to break out of, but you're not currently in a loop\nof that name, not even if you count where you were called from.  See\nL<perlfunc/last>.\n\n=item Label not found for \"next %s\"\n\n(F) You named a loop to continue, but you're not currently in a loop of\nthat name, not even if you count where you were called from.  See\nL<perlfunc/last>.\n\n=item Label not found for \"redo %s\"\n\n(F) You named a loop to restart, but you're not currently in a loop of\nthat name, not even if you count where you were called from.  See\nL<perlfunc/last>.\n\n=item leaving effective %s failed\n\n(F) While under the C<use filetest> pragma, switching the real and\neffective uids or gids failed.\n\n=item length/code after end of string in unpack\n\n(F) While unpacking, the string buffer was already used up when an unpack\nlength/code combination tried to obtain more data.  This results in\nan undefined value for the length.  See L<perlfunc/pack>.\n\n=item length() used on %s (did you mean \"scalar(%s)\"?)\n\n(W syntax) You used length() on either an array or a hash when you\nprobably wanted a count of the items.\n\nArray size can be obtained by doing:\n\n    scalar(@array);\n\nThe number of items in a hash can be obtained by doing:\n\n    scalar(keys %hash);\n\n=item Lexing code attempted to stuff non-Latin-1 character into Latin-1 input\n\n(F) An extension is attempting to insert text into the current parse\n(using L<lex_stuff_pvn|perlapi/lex_stuff_pvn> or similar), but tried to insert a character that\ncouldn't be part of the current input.  This is an inherent pitfall\nof the stuffing mechanism, and one of the reasons to avoid it.  Where\nit is necessary to stuff, stuffing only plain ASCII is recommended.\n\n=item Lexing code internal error (%s)\n\n(F) Lexing code supplied by an extension violated the lexer's API in a\ndetectable way.\n\n=item listen() on closed socket %s\n\n(W closed) You tried to do a listen on a closed socket.  Did you forget\nto check the return value of your socket() call?  See\nL<perlfunc/listen>.\n\n=item List form of piped open not implemented\n\n(F) On some platforms, notably Windows, the three-or-more-arguments\nform of C<open> does not support pipes, such as C<open($pipe, '|-', @args)>.\nUse the two-argument C<open($pipe, '|prog arg1 arg2...')> form instead.\n\n=item %s: loadable library and perl binaries are mismatched (got handshake key %p, needed %p)\n\n(P) A dynamic loading library C<.so> or C<.dll> was being loaded into the\nprocess that was built against a different build of perl than the\nsaid library was compiled against.  Reinstalling the XS module will\nlikely fix this error.\n\n=item Locale '%s' may not work well.%s\n\n(W locale) You are using the named locale, which is a non-UTF-8 one, and\nwhich perl has determined is not fully compatible with what it can\nhandle.  The second C<%s> gives a reason.\n\nBy far the most common reason is that the locale has characters in it\nthat are represented by more than one byte.  The only such locales that\nPerl can handle are the UTF-8 locales.  Most likely the specified locale\nis a non-UTF-8 one for an East Asian language such as Chinese or\nJapanese.  If the locale is a superset of ASCII, the ASCII portion of it\nmay work in Perl.\n\nSome essentially obsolete locales that aren't supersets of ASCII, mainly\nthose in ISO 646 or other 7-bit locales, such as ASMO 449, can also have\nproblems, depending on what portions of the ASCII character set get\nchanged by the locale and are also used by the program.\nThe warning message lists the determinable conflicting characters.\n\nNote that not all incompatibilities are found.\n\nIf this happens to you, there's not much you can do except switch to use a\ndifferent locale or use L<Encode> to translate from the locale into\nUTF-8; if that's impracticable, you have been warned that some things\nmay break.\n\nThis message is output once each time a bad locale is switched into\nwithin the scope of C<S<use locale>>, or on the first possibly-affected\noperation if the C<S<use locale>> inherits a bad one.  It is not raised\nfor any operations from the L<POSIX> module.\n\n=item localtime(%f) failed\n\n(W overflow) You called C<localtime> with a number that it could not handle:\ntoo large, too small, or NaN.  The returned value is C<undef>.\n\n=item localtime(%f) too large\n\n(W overflow) You called C<localtime> with a number that was larger\nthan it can reliably handle and C<localtime> probably returned the\nwrong date.  This warning is also triggered with NaN (the special\nnot-a-number value).\n\n=item localtime(%f) too small\n\n(W overflow) You called C<localtime> with a number that was smaller\nthan it can reliably handle and C<localtime> probably returned the\nwrong date.\n\n=item Lookbehind longer than %d not implemented in regex m/%s/\n\n(F) There is currently a limit on the length of string which lookbehind can\nhandle.  This restriction may be eased in a future release. \n\n=item Lost precision when %s %f by 1\n\n(W imprecision) The value you attempted to increment or decrement by one\nis too large for the underlying floating point representation to store\naccurately, hence the target of C<++> or C<--> is unchanged.  Perl issues this\nwarning because it has already switched from integers to floating point\nwhen values are too large for integers, and now even floating point is\ninsufficient.  You may wish to switch to using L<Math::BigInt> explicitly.\n\n=item lstat() on filehandle%s\n\n(W io) You tried to do an lstat on a filehandle.  What did you mean\nby that?  lstat() makes sense only on filenames.  (Perl did a fstat()\ninstead on the filehandle.)\n\n=item lvalue attribute %s already-defined subroutine\n\n(W misc) Although L<attributes.pm|attributes> allows this, turning the lvalue\nattribute on or off on a Perl subroutine that is already defined\ndoes not always work properly.  It may or may not do what you\nwant, depending on what code is inside the subroutine, with exact\ndetails subject to change between Perl versions.  Only do this\nif you really know what you are doing.\n\n=item lvalue attribute ignored after the subroutine has been defined\n\n(W misc) Using the C<:lvalue> declarative syntax to make a Perl\nsubroutine an lvalue subroutine after it has been defined is\nnot permitted.  To make the subroutine an lvalue subroutine,\nadd the lvalue attribute to the definition, or put the C<sub\nfoo :lvalue;> declaration before the definition.\n\nSee also L<attributes.pm|attributes>.\n\n=item Magical list constants are not supported\n\n(F) You assigned a magical array to a stash element, and then tried\nto use the subroutine from the same slot.  You are asking Perl to do\nsomething it cannot do, details subject to change between Perl versions.\n\n=item Malformed integer in [] in pack\n\n(F) Between the brackets enclosing a numeric repeat count only digits\nare permitted.  See L<perlfunc/pack>.\n\n=item Malformed integer in [] in unpack\n\n(F) Between the brackets enclosing a numeric repeat count only digits\nare permitted.  See L<perlfunc/pack>.\n\n=item Malformed PERLLIB_PREFIX\n\n(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form\n\n    prefix1;prefix2\n\nor\n    prefix1 prefix2\n\nwith nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix of\na builtin library search path, prefix2 is substituted.  The error may\nappear if components are not found, or are too long.  See\n\"PERLLIB_PREFIX\" in L<perlos2>.\n\n=item Malformed prototype for %s: %s\n\n(F) You tried to use a function with a malformed prototype.  The\nsyntax of function prototypes is given a brief compile-time check for\nobvious errors like invalid characters.  A more rigorous check is run\nwhen the function is called.\nPerhaps the function's author was trying to write a subroutine signature\nbut didn't enable that feature first (C<use feature 'signatures'>),\nso the signature was instead interpreted as a bad prototype.\n\n=item Malformed UTF-8 character%s\n\n(S utf8)(F) Perl detected a string that should be UTF-8, but didn't\ncomply with UTF-8 encoding rules, or represents a code point whose\nordinal integer value doesn't fit into the word size of the current\nplatform (overflows).  Details as to the exact malformation are given in\nthe variable, C<%s>, part of the message.\n\nOne possible cause is that you set the UTF8 flag yourself for data that\nyou thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit\ndata).  To guard against this, you can use C<Encode::decode('UTF-8', ...)>.\n\nIf you use the C<:encoding(UTF-8)> PerlIO layer for input, invalid byte\nsequences are handled gracefully, but if you use C<:utf8>, the flag is set\nwithout validating the data, possibly resulting in this error message.\n\nSee also L<Encode/\"Handling Malformed Data\">.\n\n=item Malformed UTF-8 returned by \\N{%s} immediately after '%s'\n\n(F) The charnames handler returned malformed UTF-8.\n\n=item Malformed UTF-8 string in \"%s\"\n\n(F) This message indicates a bug either in the Perl core or in XS\ncode. Such code was trying to find out if a character, allegedly\nstored internally encoded as UTF-8, was of a given type, such as\nbeing punctuation or a digit.  But the character was not encoded\nin legal UTF-8.  The C<%s> is replaced by a string that can be used\nby knowledgeable people to determine what the type being checked\nagainst was.\n\nPassing malformed strings was deprecated in Perl 5.18, and\nbecame fatal in Perl 5.26.\n\n=item Malformed UTF-8 string in '%c' format in unpack\n\n(F) You tried to unpack something that didn't comply with UTF-8 encoding\nrules and perl was unable to guess how to make more progress.\n\n=item Malformed UTF-8 string in pack\n\n(F) You tried to pack something that didn't comply with UTF-8 encoding\nrules and perl was unable to guess how to make more progress.\n\n=item Malformed UTF-8 string in unpack\n\n(F) You tried to unpack something that didn't comply with UTF-8 encoding\nrules and perl was unable to guess how to make more progress.\n\n=item Malformed UTF-16 surrogate\n\n(F) Perl thought it was reading UTF-16 encoded character data but while\ndoing it Perl met a malformed Unicode surrogate.\n\n=item Mandatory parameter follows optional parameter\n\n(F) In a subroutine signature, you wrote something like \"$a = undef,\n$b\", making an earlier parameter optional and a later one mandatory.\nParameters are filled from left to right, so it's impossible for the\ncaller to omit an earlier one and pass a later one.  If you want to act\nas if the parameters are filled from right to left, declare the rightmost\noptional and then shuffle the parameters around in the subroutine's body.\n\n=item Matched non-Unicode code point 0x%X against Unicode property; may\nnot be portable\n\n(S non_unicode) Perl allows strings to contain a superset of\nUnicode code points; each code point may be as large as what is storable\nin an unsigned integer on your system, but these may not be accepted by\nother languages/systems.  This message occurs when you matched a string\ncontaining such a code point against a regular expression pattern, and\nthe code point was matched against a Unicode property, C<\\p{...}> or\nC<\\P{...}>.  Unicode properties are only defined on Unicode code points,\nso the result of this match is undefined by Unicode, but Perl (starting\nin v5.20) treats non-Unicode code points as if they were typical\nunassigned Unicode ones, and matched this one accordingly.  Whether a\ngiven property matches these code points or not is specified in\nL<perluniprops/Properties accessible through \\p{} and \\P{}>.\n\nThis message is suppressed (unless it has been made fatal) if it is\nimmaterial to the results of the match if the code point is Unicode or\nnot.  For example, the property C<\\p{ASCII_Hex_Digit}> only can match\nthe 22 characters C<[0-9A-Fa-f]>, so obviously all other code points,\nUnicode or not, won't match it.  (And C<\\P{ASCII_Hex_Digit}> will match\nevery code point except these 22.)\n\nGetting this message indicates that the outcome of the match arguably\nshould have been the opposite of what actually happened.  If you think\nthat is the case, you may wish to make the C<non_unicode> warnings\ncategory fatal; if you agree with Perl's decision, you may wish to turn\noff this category.\n\nSee L<perlunicode/Beyond Unicode code points> for more information.\n\n=item %s matches null string many times in regex; marked by S<<-- HERE> in\nm/%s/\n\n(W regexp) The pattern you've specified would be an infinite loop if the\nregular expression engine didn't specifically check for that.  The S<<-- HERE>\nshows whereabouts in the regular expression the problem was discovered.\nSee L<perlre>.\n\n=item Maximal count of pending signals (%u) exceeded\n\n(F) Perl aborted due to too high a number of signals pending.  This\nusually indicates that your operating system tried to deliver signals\ntoo fast (with a very high priority), starving the perl process from\nresources it would need to reach a point where it can process signals\nsafely.  (See L<perlipc/\"Deferred Signals (Safe Signals)\">.)\n\n=item \"%s\" may clash with future reserved word\n\n(W) This warning may be due to running a perl5 script through a perl4\ninterpreter, especially if the word that is being warned about is\n\"use\" or \"my\".\n\n=item '%' may not be used in pack\n\n(F) You can't pack a string by supplying a checksum, because the\nchecksumming process loses information, and you can't go the other way.\nSee L<perlfunc/unpack>.\n\n=item Method for operation %s not found in package %s during blessing\n\n(F) An attempt was made to specify an entry in an overloading table that\ndoesn't resolve to a valid subroutine.  See L<overload>.\n\n=item Method %s not permitted\n\nSee L</500 Server error>.\n\n=item Might be a runaway multi-line %s string starting on line %d\n\n(S) An advisory indicating that the previous error may have been caused\nby a missing delimiter on a string or pattern, because it eventually\nended earlier on the current line.\n\n=item Misplaced _ in number\n\n(W syntax) An underscore (underbar) in a numeric constant did not\nseparate two digits.\n\n=item Missing argument for %n in %s\n\n(F) A C<%n> was used in a format string with no corresponding argument for\nperl to write the current string length to.\n\n=item Missing argument in %s\n\n(W missing) You called a function with fewer arguments than other\narguments you supplied indicated would be needed.\n\nCurrently only emitted when a printf-type format required more\narguments than were supplied, but might be used in the future for\nother cases where we can statically determine that arguments to\nfunctions are missing, e.g. for the L<perlfunc/pack> function.\n\n=item Missing argument to -%c\n\n(F) The argument to the indicated command line switch must follow\nimmediately after the switch, without intervening spaces.\n\n=item Missing braces on \\N{}\n\n=item Missing braces on \\N{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Wrong syntax of character name literal C<\\N{charname}> within\ndouble-quotish context.  This can also happen when there is a space\n(or comment) between the C<\\N> and the C<{> in a regex with the C</x> modifier.\nThis modifier does not change the requirement that the brace immediately\nfollow the C<\\N>.\n\n=item Missing braces on \\o{}\n\n(F) A C<\\o> must be followed immediately by a C<{> in double-quotish context.\n\n=item Missing comma after first argument to %s function\n\n(F) While certain functions allow you to specify a filehandle or an\n\"indirect object\" before the argument list, this ain't one of them.\n\n=item Missing command in piped open\n\n(W pipe) You used the C<open(FH, \"| command\")> or\nC<open(FH, \"command |\")> construction, but the command was missing or\nblank.\n\n=item Missing control char name in \\c\n\n(F) A double-quoted string ended with \"\\c\", without the required control\ncharacter name.\n\n=item Missing ']' in prototype for %s : %s\n\n(W illegalproto) A grouping was started with C<[> but never closed with C<]>.\n\n=item Missing name in \"%s sub\"\n\n(F) The syntax for lexically scoped subroutines requires that\nthey have a name with which they can be found.\n\n=item Missing $ on loop variable\n\n(F) Apparently you've been programming in B<csh> too much.  Variables\nare always mentioned with the $ in Perl, unlike in the shells, where it\ncan vary from one line to the next.\n\n=item (Missing operator before %s?)\n\n(S syntax) This is an educated guess made in conjunction with the message\n\"%s found where operator expected\".  Often the missing operator is a comma.\n\n=item Missing or undefined argument to %s\n\n(F) You tried to call require or do with no argument or with an undefined\nvalue as an argument.  Require expects either a package name or a\nfile-specification as an argument; do expects a filename.  See\nL<perlfunc/require EXPR> and L<perlfunc/do EXPR>.\n\n=item Missing right brace on \\%c{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Missing right brace in C<\\x{...}>, C<\\p{...}>, C<\\P{...}>, or C<\\N{...}>.\n\n=item Missing right brace on \\N{}\n\n=item Missing right brace on \\N{} or unescaped left brace after \\N\n\n(F) C<\\N> has two meanings.\n\nThe traditional one has it followed by a name enclosed in braces,\nmeaning the character (or sequence of characters) given by that\nname.  Thus C<\\N{ASTERISK}> is another way of writing C<*>, valid in both\ndouble-quoted strings and regular expression patterns.  In patterns,\nit doesn't have the meaning an unescaped C<*> does.\n\nStarting in Perl 5.12.0, C<\\N> also can have an additional meaning (only)\nin patterns, namely to match a non-newline character.  (This is short\nfor C<[^\\n]>, and like C<.> but is not affected by the C</s> regex modifier.)\n\nThis can lead to some ambiguities.  When C<\\N> is not followed immediately\nby a left brace, Perl assumes the C<[^\\n]> meaning.  Also, if the braces\nform a valid quantifier such as C<\\N{3}> or C<\\N{5,}>, Perl assumes that this\nmeans to match the given quantity of non-newlines (in these examples,\n3; and 5 or more, respectively).  In all other case, where there is a\nC<\\N{> and a matching C<}>, Perl assumes that a character name is desired.\n\nHowever, if there is no matching C<}>, Perl doesn't know if it was\nmistakenly omitted, or if C<[^\\n]{> was desired, and raises this error.\nIf you meant the former, add the right brace; if you meant the latter,\nescape the brace with a backslash, like so: C<\\N\\{>\n\n=item Missing right curly or square bracket\n\n(F) The lexer counted more opening curly or square brackets than closing\nones.  As a general rule, you'll find it's missing near the place you\nwere last editing.\n\n=item (Missing semicolon on previous line?)\n\n(S syntax) This is an educated guess made in conjunction with the message\n\"%s found where operator expected\".  Don't automatically put a semicolon on\nthe previous line just because you saw this message.\n\n=item Modification of a read-only value attempted\n\n(F) You tried, directly or indirectly, to change the value of a\nconstant.  You didn't, of course, try \"2 = 1\", because the compiler\ncatches that.  But an easy way to do the same thing is:\n\n    sub mod { $_[0] = 1 }\n    mod(2);\n\nAnother way is to assign to a substr() that's off the end of the string.\n\nYet another way is to assign to a C<foreach> loop I<VAR> when I<VAR>\nis aliased to a constant in the look I<LIST>:\n\n    $x = 1;\n    foreach my $n ($x, 2) {\n        $n *= 2; # modifies the $x, but fails on attempt to\n    }            # modify the 2\n\n=item Modification of non-creatable array value attempted, %s\n\n(F) You tried to make an array value spring into existence, and the\nsubscript was probably negative, even counting from end of the array\nbackwards.\n\n=item Modification of non-creatable hash value attempted, %s\n\n(P) You tried to make a hash value spring into existence, and it\ncouldn't be created for some peculiar reason.\n\n=item Module name must be constant\n\n(F) Only a bare module name is allowed as the first argument to a \"use\".\n\n=item Module name required with -%c option\n\n(F) The C<-M> or C<-m> options say that Perl should load some module, but\nyou omitted the name of the module.  Consult L<perlrun> for full details\nabout C<-M> and C<-m>.\n\n=item More than one argument to '%s' open\n\n(F) The C<open> function has been asked to open multiple files.  This\ncan happen if you are trying to open a pipe to a command that takes a\nlist of arguments, but have forgotten to specify a piped open mode.\nSee L<perlfunc/open> for details.\n\n=item mprotect for COW string %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see\nL<perlguts/\"Copy on Write\">), but a shared string buffer\ncould not be made read-only.\n\n=item mprotect for %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see L<perlhacktips>),\nbut an op tree could not be made read-only.\n\n=item mprotect RW for COW string %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see\nL<perlguts/\"Copy on Write\">), but a read-only shared string\nbuffer could not be made mutable.\n\n=item mprotect RW for %p %u failed with %d\n\n(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see\nL<perlhacktips>), but a read-only op tree could not be made\nmutable before freeing the ops.\n\n=item msg%s not implemented\n\n(F) You don't have System V message IPC on your system.\n\n=item Multidimensional syntax %s not supported\n\n(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.\nThey're written like C<$foo[1][2][3]>, as in C.\n\n=item Multiple slurpy parameters not allowed\n\n(F) In subroutine signatures, a slurpy parameter (C<@> or C<%>) must be\nthe last parameter, and there must not be more than one of them; for\nexample:\n\n    sub foo ($a, @b)    {} # legal\n    sub foo ($a, @b, %) {} # invalid\n\n=item '/' must follow a numeric type in unpack\n\n(F) You had an unpack template that contained a '/', but this did not\nfollow some unpack specification producing a numeric value.\nSee L<perlfunc/pack>.\n\n=item %s must not be a named sequence in transliteration operator\n\n(F) Transliteration (C<tr///> and C<y///>) transliterates individual\ncharacters.  But a named sequence by definition is more than an\nindividual charater, and hence doing this operation on it doesn't make\nsense.\n\n=item \"my sub\" not yet implemented\n\n(F) Lexically scoped subroutines are not yet implemented.  Don't try\nthat yet.\n\n=item \"my\" subroutine %s can't be in a package\n\n(F) Lexically scoped subroutines aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.\n\n=item \"my %s\" used in sort comparison\n\n(W syntax) The package variables $a and $b are used for sort comparisons.\nYou used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a\nsort comparison block, and the variable had earlier been declared as a\nlexical variable.  Either qualify the sort variable with the package\nname, or rename the lexical variable.\n\n=item \"my\" variable %s can't be in a package\n\n(F) Lexically scoped variables aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.  Use\nlocal() if you want to localize a package variable.\n\n=item Name \"%s::%s\" used only once: possible typo\n\n(W once) Typographical errors often show up as unique variable\nnames.  If you had a good reason for having a unique name, then\njust mention it again somehow to suppress the message.  The C<our>\ndeclaration is also provided for this purpose.\n\nNOTE: This warning detects package symbols that have been used\nonly once.  This means lexical variables will never trigger this\nwarning.  It also means that all of the package variables $c, @c,\n%c, as well as *c, &c, sub c{}, c(), and c (the filehandle or\nformat) are considered the same; if a program uses $c only once\nbut also uses any of the others it will not trigger this warning.\nSymbols beginning with an underscore and symbols using special\nidentifiers (q.v. L<perldata>) are exempt from this warning.\n\n=item Need exactly 3 octal digits in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Within S<C<(?[   ])>>, all constants interpreted as octal need to be\nexactly 3 digits long.  This helps catch some ambiguities.  If your\nconstant is too short, add leading zeros, like\n\n (?[ [ \\078 ] ])     # Syntax error!\n (?[ [ \\0078 ] ])    # Works\n (?[ [ \\007 8 ] ])   # Clearer\n\nThe maximum number this construct can express is C<\\777>.  If you\nneed a larger one, you need to use L<\\o{}|perlrebackslash/Octal escapes> instead.  If you meant\ntwo separate things, you need to separate them:\n\n (?[ [ \\7776 ] ])        # Syntax error!\n (?[ [ \\o{7776} ] ])     # One meaning\n (?[ [ \\777 6 ] ])       # Another meaning\n (?[ [ \\777 \\006 ] ])    # Still another\n\n=item Negative '/' count in unpack\n\n(F) The length count obtained from a length/code unpack operation was\nnegative.  See L<perlfunc/pack>.\n\n=item Negative length\n\n(F) You tried to do a read/write/send/recv operation with a buffer\nlength that is less than 0.  This is difficult to imagine.\n\n=item Negative offset to vec in lvalue context\n\n(F) When C<vec> is called in an lvalue context, the second argument must be\ngreater than or equal to zero.\n\n=item Negative repeat count does nothing\n\n(W numeric) You tried to execute the\nL<C<x>|perlop/Multiplicative Operators> repetition operator fewer than 0\ntimes, which doesn't make sense.\n\n=item Nested quantifiers in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You can't quantify a quantifier without intervening parentheses.\nSo things like ** or +* or ?* are illegal.  The S<<-- HERE> shows\nwhereabouts in the regular expression the problem was discovered.\n\nNote that the minimal matching quantifiers, C<*?>, C<+?>, and\nC<??> appear to be nested quantifiers, but aren't.  See L<perlre>.\n\n=item %s never introduced\n\n(S internal) The symbol in question was declared but somehow went out of\nscope before it could possibly have been used.\n\n=item next::method/next::can/maybe::next::method cannot find enclosing method\n\n(F) C<next::method> needs to be called within the context of a\nreal method in a real package, and it could not find such a context.\nSee L<mro>.\n\n=item \\N in a character class must be a named character: \\N{...} in regex; \nmarked by S<<-- HERE> in m/%s/\n\n(F) The new (as of Perl 5.12) meaning of C<\\N> as C<[^\\n]> is not valid in a\nbracketed character class, for the same reason that C<.> in a character\nclass loses its specialness: it matches almost everything, which is\nprobably not what you want.\n\n=item \\N{} in inverted character class or as a range end-point is restricted to one character in regex; marked by <-- HERE in m/%s/\n\n(F) Named Unicode character escapes (C<\\N{...}>) may return a\nmulti-character sequence.  Even though a character class is\nsupposed to match just one character of input, perl will match the\nwhole thing correctly, except when the class is inverted (C<[^...]>),\nor the escape is the beginning or final end point of a range.  The\nmathematically logical behavior for what matches when inverting\nis very different from what people expect, so we have decided to\nforbid it.  Similarly unclear is what should be generated when the\nC<\\N{...}> is used as one of the end points of the range, such as in\n\n [\\x{41}-\\N{ARABIC SEQUENCE YEH WITH HAMZA ABOVE WITH AE}]\n\nWhat is meant here is unclear, as the C<\\N{...}> escape is a sequence\nof code points, so this is made an error.\n\n=item \\N{NAME} must be resolved by the lexer in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) When compiling a regex pattern, an unresolved named character or\nsequence was encountered.  This can happen in any of several ways that\nbypass the lexer, such as using single-quotish context, or an extra\nbackslash in double-quotish:\n\n    $re = '\\N{SPACE}';\t# Wrong!\n    $re = \"\\\\N{SPACE}\";\t# Wrong!\n    /$re/;\n\nInstead, use double-quotes with a single backslash:\n\n    $re = \"\\N{SPACE}\";\t# ok\n    /$re/;\n\nThe lexer can be bypassed as well by creating the pattern from smaller\ncomponents:\n\n    $re = '\\N';\n    /${re}{SPACE}/;\t# Wrong!\n\nIt's not a good idea to split a construct in the middle like this, and\nit doesn't work here.  Instead use the solution above.\n\nFinally, the message also can happen under the C</x> regex modifier when the\nC<\\N> is separated by spaces from the C<{>, in which case, remove the spaces.\n\n    /\\N {SPACE}/x;\t# Wrong!\n    /\\N{SPACE}/x;\t# ok\n\n=item No %s allowed while running setuid\n\n(F) Certain operations are deemed to be too insecure for a setuid or\nsetgid script to even be allowed to attempt.  Generally speaking there\nwill be another way to do what you want that is, if not secure, at least\nsecurable.  See L<perlsec>.\n\n=item No code specified for -%c\n\n(F) Perl's B<-e> and B<-E> command-line options require an argument.  If\nyou want to run an empty program, pass the empty string as a separate\nargument or run a program consisting of a single 0 or 1:\n\n    perl -e \"\"\n    perl -e0\n    perl -e1\n\n=item No comma allowed after %s\n\n(F) A list operator that has a filehandle or \"indirect object\" is\nnot allowed to have a comma between that and the following arguments.\nOtherwise it'd be just another one of the arguments.\n\nOne possible cause for this is that you expected to have imported\na constant to your name space with B<use> or B<import> while no such\nimporting took place, it may for example be that your operating\nsystem does not support that particular constant.  Hopefully you did\nuse an explicit import list for the constants you expect to see;\nplease see L<perlfunc/use> and L<perlfunc/import>.  While an\nexplicit import list would probably have caught this error earlier\nit naturally does not remedy the fact that your operating system\nstill does not support that constant.  Maybe you have a typo in\nthe constants of the symbol import list of B<use> or B<import> or in the\nconstant name at the line where this error was triggered?\n\n=item No command into which to pipe on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '|' at the end of the command line, so it\ndoesn't know where you want to pipe the output from this command.\n\n=item No DB::DB routine defined\n\n(F) The currently executing code was compiled with the B<-d> switch, but\nfor some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>\nmodule) didn't define a routine to be called at the beginning of each\nstatement.\n\n=item No dbm on this machine\n\n(P) This is counted as an internal error, because every machine should\nsupply dbm nowadays, because Perl comes with SDBM.  See L<SDBM_File>.\n\n=item No DB::sub routine defined\n\n(F) The currently executing code was compiled with the B<-d> switch, but\nfor some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>\nmodule) didn't define a C<DB::sub> routine to be called at the beginning\nof each ordinary subroutine call.\n\n=item No directory specified for -I\n\n(F) The B<-I> command-line switch requires a directory name as part of the\nI<same> argument.  Use B<-Ilib>, for instance.  B<-I lib> won't work.\n\n=item No error file after 2> or 2>> on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '2>' or a '2>>' on the command line, but can't\nfind the name of the file to which to write data destined for stderr.\n\n=item No group ending character '%c' found in template\n\n(F) A pack or unpack template has an opening '(' or '[' without its\nmatching counterpart.  See L<perlfunc/pack>.\n\n=item No input file after < on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '<' on the command line, but can't find the\nname of the file from which to read data for stdin.\n\n=item No next::method '%s' found for %s\n\n(F) C<next::method> found no further instances of this method name\nin the remaining packages of the MRO of this class.  If you don't want\nit throwing an exception, use C<maybe::next::method>\nor C<next::can>.  See L<mro>.\n\n=item Non-finite repeat count does nothing\n\n(W numeric) You tried to execute the\nL<C<x>|perlop/Multiplicative Operators> repetition operator C<Inf> (or\nC<-Inf>) or C<NaN> times, which doesn't make sense.\n\n=item Non-hex character in regex; marked by S<<-- HERE> in m/%s/\n\n(F) In a regular expression, there was a non-hexadecimal character where\na hex one was expected, like\n\n (?[ [ \\xDG ] ])\n (?[ [ \\x{DEKA} ] ])\n\n=item Non-octal character in regex; marked by S<<-- HERE> in m/%s/\n\n(F) In a regular expression, there was a non-octal character where\nan octal one was expected, like\n\n (?[ [ \\o{1278} ] ])\n\n=item Non-octal character '%c'.  Resolved as \"%s\"\n\n(W digit) In parsing an octal numeric constant, a character was\nunexpectedly encountered that isn't octal.  The resulting value\nis as indicated.\n\n=item \"no\" not allowed in expression\n\n(F) The \"no\" keyword is recognized and executed at compile time, and\nreturns no useful value.  See L<perlmod>.\n\n=item Non-string passed as bitmask\n\n(W misc) A number has been passed as a bitmask argument to select().\nUse the vec() function to construct the file descriptor bitmasks for\nselect.  See L<perlfunc/select>.\n\n=item No output file after > on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a lone '>' at the end of the command line, so it\ndoesn't know where you wanted to redirect stdout.\n\n=item No output file after > or >> on command line\n\n(F) An error peculiar to VMS.  Perl handles its own command line\nredirection, and found a '>' or a '>>' on the command line, but can't\nfind the name of the file to which to write data destined for stdout.\n\n=item No package name allowed for subroutine %s in \"our\"\n\n=item No package name allowed for variable %s in \"our\"\n\n(F) Fully qualified subroutine and variable names are not allowed in \"our\"\ndeclarations, because that doesn't make much sense under existing rules.\nSuch syntax is reserved for future extensions.\n\n=item No Perl script found in input\n\n(F) You called C<perl -x>, but no line was found in the file beginning\nwith #! and containing the word \"perl\".\n\n=item No setregid available\n\n(F) Configure didn't find anything resembling the setregid() call for\nyour system.\n\n=item No setreuid available\n\n(F) Configure didn't find anything resembling the setreuid() call for\nyour system.\n\n=item No such class %s\n\n(F) You provided a class qualifier in a \"my\", \"our\" or \"state\"\ndeclaration, but this class doesn't exist at this point in your program.\n\n=item No such class field \"%s\" in variable %s of type %s\n\n(F) You tried to access a key from a hash through the indicated typed\nvariable but that key is not allowed by the package of the same type.\nThe indicated package has restricted the set of allowed keys using the\nL<fields> pragma.\n\n=item No such hook: %s\n\n(F) You specified a signal hook that was not recognized by Perl.\nCurrently, Perl accepts C<__DIE__> and C<__WARN__> as valid signal hooks.\n\n=item No such pipe open\n\n(P) An error peculiar to VMS.  The internal routine my_pclose() tried to\nclose a pipe which hadn't been opened.  This should have been caught\nearlier as an attempt to close an unopened filehandle.\n\n=item No such signal: SIG%s\n\n(W signal) You specified a signal name as a subscript to %SIG that was\nnot recognized.  Say C<kill -l> in your shell to see the valid signal\nnames on your system.\n\n=item Not a CODE reference\n\n(F) Perl was trying to evaluate a reference to a code value (that is, a\nsubroutine), but found a reference to something else instead.  You can\nuse the ref() function to find out what kind of ref it really was.  See\nalso L<perlref>.\n\n=item Not a GLOB reference\n\n(F) Perl was trying to evaluate a reference to a \"typeglob\" (that is, a\nsymbol table entry that looks like C<*foo>), but found a reference to\nsomething else instead.  You can use the ref() function to find out what\nkind of ref it really was.  See L<perlref>.\n\n=item Not a HASH reference\n\n(F) Perl was trying to evaluate a reference to a hash value, but found a\nreference to something else instead.  You can use the ref() function to\nfind out what kind of ref it really was.  See L<perlref>.\n\n=item '#' not allowed immediately following a sigil in a subroutine signature\n\n(F) In a subroutine signature definition, a comment following a sigil\n(C<$>, C<@> or C<%>), needs to be separated by whitespace or a commma etc., in\nparticular to avoid confusion with the C<$#> variable.  For example:\n\n    # bad\n    sub f ($# ignore first arg\n           , $b) {}\n    # good\n    sub f ($, # ignore first arg\n           $b) {}\n\n=item Not an ARRAY reference\n\n(F) Perl was trying to evaluate a reference to an array value, but found\na reference to something else instead.  You can use the ref() function\nto find out what kind of ref it really was.  See L<perlref>.\n\n=item Not a SCALAR reference\n\n(F) Perl was trying to evaluate a reference to a scalar value, but found\na reference to something else instead.  You can use the ref() function\nto find out what kind of ref it really was.  See L<perlref>.\n\n=item Not a subroutine reference\n\n(F) Perl was trying to evaluate a reference to a code value (that is, a\nsubroutine), but found a reference to something else instead.  You can\nuse the ref() function to find out what kind of ref it really was.  See\nalso L<perlref>.\n\n=item Not a subroutine reference in overload table\n\n(F) An attempt was made to specify an entry in an overloading table that\ndoesn't somehow point to a valid subroutine.  See L<overload>.\n\n=item Not enough arguments for %s\n\n(F) The function requires more arguments than you specified.\n\n=item Not enough format arguments\n\n(W syntax) A format specified more picture fields than the next line\nsupplied.  See L<perlform>.\n\n=item %s: not found\n\n(A) You've accidentally run your script through the Bourne shell instead\nof Perl.  Check the #! line, or manually feed your script into Perl\nyourself.\n\n=item (?[...]) not valid in locale in regex; marked by S<<-- HERE> in m/%s/\n\n(F) C<(?[...])> cannot be used within the scope of a C<S<use locale>> or with\nan C</l> regular expression modifier, as that would require deferring\nto run-time the calculation of what it should evaluate to, and it is\nregex compile-time only.\n\n=item no UTC offset information; assuming local time is UTC\n\n(S) A warning peculiar to VMS.  Perl was unable to find the local\ntimezone offset, so it's assuming that local system time is equivalent\nto UTC.  If it's not, define the logical name\nF<SYS$TIMEZONE_DIFFERENTIAL> to translate to the number of seconds which\nneed to be added to UTC to get local time.\n\n=item NULL OP IN RUN\n\n(S debugging) Some internal routine called run() with a null opcode\npointer.\n\n=item Null picture in formline\n\n(F) The first argument to formline must be a valid format picture\nspecification.  It was found to be empty, which probably means you\nsupplied it an uninitialized value.  See L<perlform>.\n\n=item Null realloc\n\n(P) An attempt was made to realloc NULL.\n\n=item NULL regexp argument\n\n(P) The internal pattern matching routines blew it big time.\n\n=item NULL regexp parameter\n\n(P) The internal pattern matching routines are out of their gourd.\n\n=item Number too long\n\n(F) Perl limits the representation of decimal numbers in programs to\nabout 250 characters.  You've exceeded that length.  Future\nversions of Perl are likely to eliminate this arbitrary limitation.  In\nthe meantime, try using scientific notation (e.g. \"1e6\" instead of\n\"1_000_000\").\n\n=item Number with no digits\n\n(F) Perl was looking for a number but found nothing that looked like\na number.  This happens, for example with C<\\o{}>, with no number between\nthe braces.\n\n=item Octal number > 037777777777 non-portable\n\n(W portable) The octal number you specified is larger than 2**32-1\n(4294967295) and therefore non-portable between systems.  See\nL<perlport> for more on portability concerns.\n\n=item Odd name/value argument for subroutine '%s'\n\n(F) A subroutine using a slurpy hash parameter in its signature\nreceived an odd number of arguments to populate the hash.  It requires\nthe arguments to be paired, with the same number of keys as values.\nThe caller of the subroutine is presumably at fault.\n\nThe message attempts to include the name of the called subroutine. If the\nsubroutine has been aliased, the subroutine's original name will be shown,\nregardless of what name the caller used.\n\n=item Odd number of arguments for overload::constant\n\n(W overload) The call to overload::constant contained an odd number of\narguments.  The arguments should come in pairs.\n\n=item Odd number of elements in anonymous hash\n\n(W misc) You specified an odd number of elements to initialize a hash,\nwhich is odd, because hashes come in key/value pairs.\n\n=item Odd number of elements in hash assignment\n\n(W misc) You specified an odd number of elements to initialize a hash,\nwhich is odd, because hashes come in key/value pairs.\n\n=item Offset outside string\n\n(F)(W layer) You tried to do a read/write/send/recv/seek operation\nwith an offset pointing outside the buffer.  This is difficult to\nimagine.  The sole exceptions to this are that zero padding will\ntake place when going past the end of the string when either\nC<sysread()>ing a file, or when seeking past the end of a scalar opened\nfor I/O (in anticipation of future reads and to imitate the behavior\nwith real files).\n\n=item Old package separator used in string\n\n(W syntax) You used the old package separator, \"'\", in a variable\nnamed inside a double-quoted string; e.g., C<\"In $name's house\">.  This\nis equivalent to C<\"In $name::s house\">.  If you meant the former, put\na backslash before the apostrophe (C<\"In $name\\'s house\">).\n\n=item %s() on unopened %s\n\n(W unopened) An I/O operation was attempted on a filehandle that was\nnever initialized.  You need to do an open(), a sysopen(), or a socket()\ncall, or call a constructor from the FileHandle package.\n\n=item -%s on unopened filehandle %s\n\n(W unopened) You tried to invoke a file test operator on a filehandle\nthat isn't open.  Check your control flow.  See also L<perlfunc/-X>.\n\n=item oops: oopsAV\n\n(S internal) An internal warning that the grammar is screwed up.\n\n=item oops: oopsHV\n\n(S internal) An internal warning that the grammar is screwed up.\n\n=item Operand with no preceding operator in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You wrote something like\n\n (?[ \\p{Digit} \\p{Thai} ])\n\nThere are two operands, but no operator giving how you want to combine\nthem.\n\n=item Operation \"%s\": no method found, %s\n\n(F) An attempt was made to perform an overloaded operation for which no\nhandler was defined.  While some handlers can be autogenerated in terms\nof other handlers, there is no default handler for any operation, unless\nthe C<fallback> overloading key is specified to be true.  See L<overload>.\n\n=item Operation \"%s\" returns its argument for non-Unicode code point 0x%X\n\n(S non_unicode) You performed an operation requiring Unicode rules\non a code point that is not in Unicode, so what it should do is not\ndefined.  Perl has chosen to have it do nothing, and warn you.\n\nIf the operation shown is \"ToFold\", it means that case-insensitive\nmatching in a regular expression was done on the code point.\n\nIf you know what you are doing you can turn off this warning by\nC<no warnings 'non_unicode';>.\n\n=item Operation \"%s\" returns its argument for UTF-16 surrogate U+%X\n\n(S surrogate) You performed an operation requiring Unicode\nrules on a Unicode surrogate.  Unicode frowns upon the use\nof surrogates for anything but storing strings in UTF-16, but\nrules are (reluctantly) defined for the surrogates, and\nthey are to do nothing for this operation.  Because the use of\nsurrogates can be dangerous, Perl warns.\n\nIf the operation shown is \"ToFold\", it means that case-insensitive\nmatching in a regular expression was done on the code point.\n\nIf you know what you are doing you can turn off this warning by\nC<no warnings 'surrogate';>.\n\n=item Operator or semicolon missing before %s\n\n(S ambiguous) You used a variable or subroutine call where the parser\nwas expecting an operator.  The parser has assumed you really meant to\nuse an operator, but this is highly likely to be incorrect.  For\nexample, if you say \"*foo *foo\" it will be interpreted as if you said\n\"*foo * 'foo'\".\n\n=item Optional parameter lacks default expression\n\n(F) In a subroutine signature, you wrote something like \"$a =\", making a\nnamed optional parameter without a default value.  A nameless optional\nparameter is permitted to have no default value, but a named one must\nhave a specific default.  You probably want \"$a = undef\".\n\n=item \"our\" variable %s redeclared\n\n(W shadow) You seem to have already declared the same global once before\nin the current lexical scope.\n\n=item Out of memory!\n\n(X) The malloc() function returned 0, indicating there was insufficient\nremaining memory (or virtual memory) to satisfy the request.  Perl has\nno option but to exit immediately.\n\nAt least in Unix you may be able to get past this by increasing your\nprocess datasize limits: in csh/tcsh use C<limit> and\nC<limit datasize n> (where C<n> is the number of kilobytes) to check\nthe current limits and change them, and in ksh/bash/zsh use C<ulimit -a>\nand C<ulimit -d n>, respectively.\n\n=item Out of memory during %s extend\n\n(X) An attempt was made to extend an array, a list, or a string beyond\nthe largest possible memory allocation.\n\n=item Out of memory during \"large\" request for %s\n\n(F) The malloc() function returned 0, indicating there was insufficient\nremaining memory (or virtual memory) to satisfy the request.  However,\nthe request was judged large enough (compile-time default is 64K), so a\npossibility to shut down by trapping this error is granted.\n\n=item Out of memory during request for %s\n\n(X)(F) The malloc() function returned 0, indicating there was\ninsufficient remaining memory (or virtual memory) to satisfy the\nrequest.\n\nThe request was judged to be small, so the possibility to trap it\ndepends on the way perl was compiled.  By default it is not trappable.\nHowever, if compiled for this, Perl may use the contents of C<$^M> as an\nemergency pool after die()ing with this message.  In this case the error\nis trappable I<once>, and the error message will include the line and file\nwhere the failed request happened.\n\n=item Out of memory during ridiculously large request\n\n(F) You can't allocate more than 2^31+\"small amount\" bytes.  This error\nis most likely to be caused by a typo in the Perl program. e.g.,\nC<$arr[time]> instead of C<$arr[$time]>.\n\n=item Out of memory for yacc stack\n\n(F) The yacc parser wanted to grow its stack so it could continue\nparsing, but realloc() wouldn't give it more memory, virtual or\notherwise.\n\n=item '.' outside of string in pack\n\n(F) The argument to a '.' in your template tried to move the working\nposition to before the start of the packed string being built.\n\n=item '@' outside of string in unpack\n\n(F) You had a template that specified an absolute position outside\nthe string being unpacked.  See L<perlfunc/pack>.\n\n=item '@' outside of string with malformed UTF-8 in unpack\n\n(F) You had a template that specified an absolute position outside\nthe string being unpacked.  The string being unpacked was also invalid\nUTF-8.  See L<perlfunc/pack>.\n\n=item overload arg '%s' is invalid\n\n(W overload) The L<overload> pragma was passed an argument it did not\nrecognize.  Did you mistype an operator?\n\n=item Overloaded dereference did not return a reference\n\n(F) An object with an overloaded dereference operator was dereferenced,\nbut the overloaded operation did not return a reference.  See\nL<overload>.\n\n=item Overloaded qr did not return a REGEXP\n\n(F) An object with a C<qr> overload was used as part of a match, but the\noverloaded operation didn't return a compiled regexp.  See L<overload>.\n\n=item %s package attribute may clash with future reserved word: %s\n\n(W reserved) A lowercase attribute name was used that had a\npackage-specific handler.  That name might have a meaning to Perl itself\nsome day, even though it doesn't yet.  Perhaps you should use a\nmixed-case attribute name, instead.  See L<attributes>.\n\n=item pack/unpack repeat count overflow\n\n(F) You can't specify a repeat count so large that it overflows your\nsigned integers.  See L<perlfunc/pack>.\n\n=item page overflow\n\n(W io) A single call to write() produced more lines than can fit on a\npage.  See L<perlform>.\n\n=item panic: %s\n\n(P) An internal error.\n\n=item panic: attempt to call %s in %s\n\n(P) One of the file test operators entered a code branch that calls\nan ACL related-function, but that function is not available on this\nplatform.  Earlier checks mean that it should not be possible to\nenter this branch on this platform.\n\n=item panic: child pseudo-process was never scheduled\n\n(P) A child pseudo-process in the ithreads implementation on Windows\nwas not scheduled within the time period allowed and therefore was not\nable to initialize properly.\n\n=item panic: ck_grep, type=%u\n\n(P) Failed an internal consistency check trying to compile a grep.\n\n=item panic: corrupt saved stack index %ld\n\n(P) The savestack was requested to restore more localized values than\nthere are in the savestack.\n\n=item panic: del_backref\n\n(P) Failed an internal consistency check while trying to reset a weak\nreference.\n\n=item panic: do_subst\n\n(P) The internal pp_subst() routine was called with invalid operational\ndata.\n\n=item panic: do_trans_%s\n\n(P) The internal do_trans routines were called with invalid operational\ndata.\n\n=item panic: fold_constants JMPENV_PUSH returned %d\n\n(P) While attempting folding constants an exception other than an C<eval>\nfailure was caught.\n\n=item panic: frexp: %f\n\n(P) The library function frexp() failed, making printf(\"%f\") impossible.\n\n=item panic: goto, type=%u, ix=%ld\n\n(P) We popped the context stack to a context with the specified label,\nand then discovered it wasn't a context we know how to do a goto in.\n\n=item panic: gp_free failed to free glob pointer\n\n(P) The internal routine used to clear a typeglob's entries tried\nrepeatedly, but each time something re-created entries in the glob.\nMost likely the glob contains an object with a reference back to\nthe glob and a destructor that adds a new object to the glob.\n\n=item panic: INTERPCASEMOD, %s\n\n(P) The lexer got into a bad state at a case modifier.\n\n=item panic: INTERPCONCAT, %s\n\n(P) The lexer got into a bad state parsing a string with brackets.\n\n=item panic: kid popen errno read\n\n(F) A forked child returned an incomprehensible message about its errno.\n\n=item panic: last, type=%u\n\n(P) We popped the context stack to a block context, and then discovered\nit wasn't a block context.\n\n=item panic: leave_scope clearsv\n\n(P) A writable lexical variable became read-only somehow within the\nscope.\n\n=item panic: leave_scope inconsistency %u\n\n(P) The savestack probably got out of sync.  At least, there was an\ninvalid enum on the top of it.\n\n=item panic: magic_killbackrefs\n\n(P) Failed an internal consistency check while trying to reset all weak\nreferences to an object.\n\n=item panic: malloc, %s\n\n(P) Something requested a negative number of bytes of malloc.\n\n=item panic: memory wrap\n\n(P) Something tried to allocate either more memory than possible or a\nnegative amount.\n\n=item panic: pad_alloc, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_free curpad, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_free po\n\n(P) A zero scratch pad offset was detected internally.  An attempt was\nmade to free a target that had not been allocated to begin with.\n\n=item panic: pad_reset curpad, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_sv po\n\n(P) A zero scratch pad offset was detected internally.  Most likely\nan operator needed a target but that target had not been allocated\nfor whatever reason.\n\n=item panic: pad_swipe curpad, %p!=%p\n\n(P) The compiler got confused about which scratch pad it was allocating\nand freeing temporaries and lexicals from.\n\n=item panic: pad_swipe po\n\n(P) An invalid scratch pad offset was detected internally.\n\n=item panic: pp_iter, type=%u\n\n(P) The foreach iterator got called in a non-loop context frame.\n\n=item panic: pp_match%s\n\n(P) The internal pp_match() routine was called with invalid operational\ndata.\n\n=item panic: realloc, %s\n\n(P) Something requested a negative number of bytes of realloc.\n\n=item panic: reference miscount on nsv in sv_replace() (%d != 1)\n\n(P) The internal sv_replace() function was handed a new SV with a\nreference count other than 1.\n\n=item panic: restartop in %s\n\n(P) Some internal routine requested a goto (or something like it), and\ndidn't supply the destination.\n\n=item panic: return, type=%u\n\n(P) We popped the context stack to a subroutine or eval context, and\nthen discovered it wasn't a subroutine or eval context.\n\n=item panic: scan_num, %s\n\n(P) scan_num() got called on something that wasn't a number.\n\n=item panic: Sequence (?{...}): no code block found in regex m/%s/\n\n(P) While compiling a pattern that has embedded (?{}) or (??{}) code\nblocks, perl couldn't locate the code block that should have already been\nseen and compiled by perl before control passed to the regex compiler.\n\n=item panic: strxfrm() gets absurd - a => %u, ab => %u\n\n(P) The interpreter's sanity check of the C function strxfrm() failed.\nIn your current locale the returned transformation of the string \"ab\"\nis shorter than that of the string \"a\", which makes no sense.\n\n=item panic: sv_chop %s\n\n(P) The sv_chop() routine was passed a position that is not within the\nscalar's string buffer.\n\n=item panic: sv_insert, midend=%p, bigend=%p\n\n(P) The sv_insert() routine was told to remove more string than there\nwas string.\n\n=item panic: top_env\n\n(P) The compiler attempted to do a goto, or something weird like that.\n\n=item panic: unimplemented op %s (#%d) called\n\n(P) The compiler is screwed up and attempted to use an op that isn't\npermitted at run time.\n\n=item panic: unknown OA_*: %x\n\n(P) The internal routine that handles arguments to C<&CORE::foo()>\nsubroutine calls was unable to determine what type of arguments\nwere expected.\n\n=item panic: utf16_to_utf8: odd bytelen\n\n(P) Something tried to call utf16_to_utf8 with an odd (as opposed\nto even) byte length.\n\n=item panic: utf16_to_utf8_reversed: odd bytelen\n\n(P) Something tried to call utf16_to_utf8_reversed with an odd (as opposed\nto even) byte length.\n\n=item panic: yylex, %s\n\n(P) The lexer got into a bad state while processing a case modifier.\n\n=item Parentheses missing around \"%s\" list\n\n(W parenthesis) You said something like\n\n    my $foo, $bar = @_;\n\nwhen you meant\n\n    my ($foo, $bar) = @_;\n\nRemember that \"my\", \"our\", \"local\" and \"state\" bind tighter than comma.\n\n=item Parsing code internal error (%s)\n\n(F) Parsing code supplied by an extension violated the parser's API in\na detectable way.\n\n=item Pattern subroutine nesting without pos change exceeded limit in regex\n\n(F) You used a pattern that uses too many nested subpattern calls without\nconsuming any text.  Restructure the pattern so text is consumed before\nthe nesting limit is exceeded.\n\n=item C<-p> destination: %s\n\n(F) An error occurred during the implicit output invoked by the C<-p>\ncommand-line switch.  (This output goes to STDOUT unless you've\nredirected it with select().)\n\n=item Perl API version %s of %s does not match %s\n\n(F) The XS module in question was compiled against a different incompatible\nversion of Perl than the one that has loaded the XS module.\n\n=item Perl folding rules are not up-to-date for 0x%X; please use the perlbug\nutility to report; in regex; marked by S<<-- HERE> in m/%s/\n\n(S regexp) You used a regular expression with case-insensitive matching,\nand there is a bug in Perl in which the built-in regular expression\nfolding rules are not accurate.  This may lead to incorrect results.\nPlease report this as a bug using the L<perlbug> utility.\n\n=item PerlIO layer ':win32' is experimental\n\n(S experimental::win32_perlio) The C<:win32> PerlIO layer is\nexperimental.  If you want to take the risk of using this layer,\nsimply disable this warning:\n\n    no warnings \"experimental::win32_perlio\";\n\n=item Perl_my_%s() not available\n\n(F) Your platform has very uncommon byte-order and integer size,\nso it was not possible to set up some or all fixed-width byte-order\nconversion functions.  This is only a problem when you're using the\n'<' or '>' modifiers in (un)pack templates.  See L<perlfunc/pack>.\n\n=item Perl %s required (did you mean %s?)--this is only %s, stopped\n\n(F) The code you are trying to run has asked for a newer version of\nPerl than you are running.  Perhaps C<use 5.10> was written instead\nof C<use 5.010> or C<use v5.10>.  Without the leading C<v>, the number is\ninterpreted as a decimal, with every three digits after the\ndecimal point representing a part of the version number.  So 5.10\nis equivalent to v5.100.\n\n=item Perl %s required--this is only %s, stopped\n\n(F) The module in question uses features of a version of Perl more\nrecent than the currently running version.  How long has it been since\nyou upgraded, anyway?  See L<perlfunc/require>.\n\n=item PERL_SH_DIR too long\n\n(F) An error peculiar to OS/2.  PERL_SH_DIR is the directory to find the\nC<sh>-shell in.  See \"PERL_SH_DIR\" in L<perlos2>.\n\n=item PERL_SIGNALS illegal: \"%s\"\n\n(X) See L<perlrun/PERL_SIGNALS> for legal values.\n\n=item Perls since %s too modern--this is %s, stopped\n\n(F) The code you are trying to run claims it will not run\non the version of Perl you are using because it is too new.\nMaybe the code needs to be updated, or maybe it is simply\nwrong and the version check should just be removed.\n\n=item perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set\n\n(S) PERL_HASH_SEED should match /^\\s*(?:0x)?[0-9a-fA-F]+\\s*\\z/ but it\ncontained a non hex character.  This could mean you are not using the\nhash seed you think you are.\n\n=item perl: warning: Setting locale failed.\n\n(S) The whole warning message will look something like:\n\n\tperl: warning: Setting locale failed.\n\tperl: warning: Please check that your locale settings:\n\t        LC_ALL = \"En_US\",\n\t        LANG = (unset)\n\t    are supported and installed on your system.\n\tperl: warning: Falling back to the standard locale (\"C\").\n\nExactly what were the failed locale settings varies.  In the above the\nsettings were that the LC_ALL was \"En_US\" and the LANG had no value.\nThis error means that Perl detected that you and/or your operating\nsystem supplier and/or system administrator have set up the so-called\nlocale system but Perl could not use those settings.  This was not\ndead serious, fortunately: there is a \"default locale\" called \"C\" that\nPerl can and will use, and the script will be run.  Before you really\nfix the problem, however, you will get the same error message each\ntime you run Perl.  How to really fix the problem can be found in\nL<perllocale> section B<LOCALE PROBLEMS>.\n\n=item perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'\n\n(S) Perl was run with the environment variable PERL_PERTURB_KEYS defined\nbut containing an unexpected value.  The legal values of this setting\nare as follows.\n\n  Numeric | String        | Result\n  --------+---------------+-----------------------------------------\n  0       | NO            | Disables key traversal randomization\n  1       | RANDOM        | Enables full key traversal randomization\n  2       | DETERMINISTIC | Enables repeatable key traversal\n          |               | randomization\n\nBoth numeric and string values are accepted, but note that string values are\ncase sensitive.  The default for this setting is \"RANDOM\" or 1.\n\n=item pid %x not a child\n\n(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a\nprocess which isn't a subprocess of the current process.  While this is\nfine from VMS' perspective, it's probably not what you intended.\n\n=item 'P' must have an explicit size in unpack\n\n(F) The unpack format P must have an explicit size, not \"*\".\n\n=item POSIX class [:%s:] unknown in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The class in the character class [: :] syntax is unknown.  The S<<-- HERE>\nshows whereabouts in the regular expression the problem was discovered.\nNote that the POSIX character classes do B<not> have the C<is> prefix\nthe corresponding C interfaces have: in other words, it's C<[[:print:]]>,\nnot C<isprint>.  See L<perlre>.\n\n=item POSIX getpgrp can't take an argument\n\n(F) Your system has POSIX getpgrp(), which takes no argument, unlike\nthe BSD version, which takes a pid.\n\n=item POSIX syntax [%c %c] belongs inside character classes%s in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) Perl thinks that you intended to write a POSIX character\nclass, but didn't use enough brackets.  These POSIX class constructs [:\n:], [= =], and [. .]  go I<inside> character classes, the [] are part of\nthe construct, for example: C<qr/[012[:alpha:]345]/>.  What the regular\nexpression pattern compiled to is probably not what you were intending.\nFor example, C<qr/[:alpha:]/> compiles to a regular bracketed character\nclass consisting of the four characters C<\":\">,  C<\"a\">,  C<\"l\">,\nC<\"h\">, and C<\"p\">.  To specify the POSIX class, it should have been\nwritten C<qr/[[:alpha:]]/>.\n\nNote that [= =] and [. .] are not currently\nimplemented; they are simply placeholders for future extensions and\nwill cause fatal errors.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.  See L<perlre>.\n\nIf the specification of the class was not completely valid, the message\nindicates that.\n\n=item POSIX syntax [. .] is reserved for future extensions in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) Within regular expression character classes ([]) the syntax beginning\nwith \"[.\" and ending with \".]\" is reserved for future extensions.  If you\nneed to represent those character sequences inside a regular expression\ncharacter class, just quote the square brackets with the backslash: \"\\[.\"\nand \".\\]\".  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item POSIX syntax [= =] is reserved for future extensions in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) Within regular expression character classes ([]) the syntax beginning\nwith \"[=\" and ending with \"=]\" is reserved for future extensions.  If you\nneed to represent those character sequences inside a regular expression\ncharacter class, just quote the square brackets with the backslash: \"\\[=\"\nand \"=\\]\".  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item Possible attempt to put comments in qw() list\n\n(W qw) qw() lists contain items separated by whitespace; as with literal\nstrings, comment characters are not ignored, but are instead treated as\nliteral data.  (You may have used different delimiters than the\nparentheses shown here; braces are also frequently used.)\n\nYou probably wrote something like this:\n\n    @list = qw(\n\ta # a comment\n        b # another comment\n    );\n\nwhen you should have written this:\n\n    @list = qw(\n\ta\n        b\n    );\n\nIf you really want comments, build your list the\nold-fashioned way, with quotes and commas:\n\n    @list = (\n        'a',    # a comment\n        'b',    # another comment\n    );\n\n=item Possible attempt to separate words with commas\n\n(W qw) qw() lists contain items separated by whitespace; therefore\ncommas aren't needed to separate the items.  (You may have used\ndifferent delimiters than the parentheses shown here; braces are also\nfrequently used.)\n\nYou probably wrote something like this:\n\n    qw! a, b, c !;\n\nwhich puts literal commas into some of the list items.  Write it without\ncommas if you don't want them to appear in your data:\n\n    qw! a b c !;\n\n=item Possible memory corruption: %s overflowed 3rd argument\n\n(F) An ioctl() or fcntl() returned more than Perl was bargaining for.\nPerl guesses a reasonable buffer size, but puts a sentinel byte at the\nend of the buffer just in case.  This sentinel byte got clobbered, and\nPerl assumes that memory is now corrupted.  See L<perlfunc/ioctl>.\n\n=item Possible precedence issue with control flow operator\n\n(W syntax) There is a possible problem with the mixing of a control\nflow operator (e.g. C<return>) and a low-precedence operator like\nC<or>.  Consider:\n\n    sub { return $a or $b; }\n\nThis is parsed as:\n\n    sub { (return $a) or $b; }\n\nWhich is effectively just:\n\n    sub { return $a; }\n\nEither use parentheses or the high-precedence variant of the operator.\n\nNote this may be also triggered for constructs like:\n\n    sub { 1 if die; }\n\n=item Possible precedence problem on bitwise %s operator\n\n(W precedence) Your program uses a bitwise logical operator in conjunction\nwith a numeric comparison operator, like this :\n\n    if ($x & $y == 0) { ... }\n\nThis expression is actually equivalent to C<$x & ($y == 0)>, due to the\nhigher precedence of C<==>.  This is probably not what you want.  (If you\nreally meant to write this, disable the warning, or, better, put the\nparentheses explicitly and write C<$x & ($y == 0)>).\n\n=item Possible unintended interpolation of $\\ in regex\n\n(W ambiguous) You said something like C<m/$\\/> in a regex.\nThe regex C<m/foo$\\s+bar/m> translates to: match the word 'foo', the output\nrecord separator (see L<perlvar/$\\>) and the letter 's' (one time or more)\nfollowed by the word 'bar'.\n\nIf this is what you intended then you can silence the warning by using \nC<m/${\\}/> (for example: C<m/foo${\\}s+bar/>).\n\nIf instead you intended to match the word 'foo' at the end of the line\nfollowed by whitespace and the word 'bar' on the next line then you can use\nC<m/$(?)\\/> (for example: C<m/foo$(?)\\s+bar/>).\n\n=item Possible unintended interpolation of %s in string\n\n(W ambiguous) You said something like '@foo' in a double-quoted string\nbut there was no array C<@foo> in scope at the time.  If you wanted a\nliteral @foo, then write it as \\@foo; otherwise find out what happened\nto the array you apparently lost track of.\n\n=item Precedence problem: open %s should be open(%s)\n\n(S precedence) The old irregular construct\n\n    open FOO || die;\n\nis now misinterpreted as\n\n    open(FOO || die);\n\nbecause of the strict regularization of Perl 5's grammar into unary and\nlist operators.  (The old open was a little of both.)  You must put\nparentheses around the filehandle, or use the new \"or\" operator instead\nof \"||\".\n\n=item Premature end of script headers\n\nSee L</500 Server error>.\n\n=item printf() on closed filehandle %s\n\n(W closed) The filehandle you're writing to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item print() on closed filehandle %s\n\n(W closed) The filehandle you're printing on got itself closed sometime\nbefore now.  Check your control flow.\n\n=item Process terminated by SIG%s\n\n(W) This is a standard message issued by OS/2 applications, while *nix\napplications die in silence.  It is considered a feature of the OS/2\nport.  One can easily disable this by appropriate sighandlers, see\nL<perlipc/\"Signals\">.  See also \"Process terminated by SIGTERM/SIGINT\"\nin L<perlos2>.\n\n=item Prototype after '%c' for %s : %s\n\n(W illegalproto) A character follows % or @ in a prototype.  This is\nuseless, since % and @ gobble the rest of the subroutine arguments.\n\n=item Prototype mismatch: %s vs %s\n\n(S prototype) The subroutine being declared or defined had previously been\ndeclared or defined with a different function prototype.\n\n=item Prototype not terminated\n\n(F) You've omitted the closing parenthesis in a function prototype\ndefinition.\n\n=item Prototype '%s' overridden by attribute 'prototype(%s)' in %s\n\n(W prototype) A prototype was declared in both the parentheses after\nthe sub name and via the prototype attribute.  The prototype in\nparentheses is useless, since it will be replaced by the prototype\nfrom the attribute before it's ever used.\n\n=item Quantifier follows nothing in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You started a regular expression with a quantifier.  Backslash it if\nyou meant it literally.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.  See L<perlre>.\n\n=item Quantifier in {,} bigger than %d in regex; marked by S<<-- HERE> in m/%s/\n\n(F) There is currently a limit to the size of the min and max values of\nthe {min,max} construct.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.  See L<perlre>.\n\n=item Quantifier {n,m} with n > m can't match in regex\n\n=item Quantifier {n,m} with n > m can't match in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) Minima should be less than or equal to maxima.  If you really\nwant your regexp to match something 0 times, just put {0}.\n\n=item Quantifier unexpected on zero-length expression in regex m/%s/\n\n(W regexp) You applied a regular expression quantifier in a place where\nit makes no sense, such as on a zero-width assertion.  Try putting the\nquantifier inside the assertion instead.  For example, the way to match\n\"abc\" provided that it is followed by three repetitions of \"xyz\" is\nC</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.\n\n=item Range iterator outside integer range\n\n(F) One (or both) of the numeric arguments to the range operator \"..\"\nare outside the range which can be represented by integers internally.\nOne possible workaround is to force Perl to use magical string increment\nby prepending \"0\" to your numbers.\n\n=item Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or\n\"a-z\" in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nStricter rules help to find typos and other errors.  Perhaps you didn't\neven intend a range here, if the C<\"-\"> was meant to be some other\ncharacter, or should have been escaped (like C<\"\\-\">).  If you did\nintend a range, the one that was used is not portable between ASCII and\nEBCDIC platforms, and doesn't have an obvious meaning to a casual\nreader.\n\n [3-7]    # OK; Obvious and portable\n [d-g]    # OK; Obvious and portable\n [A-Y]    # OK; Obvious and portable\n [A-z]    # WRONG; Not portable; not clear what is meant\n [a-Z]    # WRONG; Not portable; not clear what is meant\n [%-.]    # WRONG; Not portable; not clear what is meant\n [\\x41-Z] # WRONG; Not portable; not obvious to non-geek\n\n(You can force portability by specifying a Unicode range, which means that\nthe endpoints are specified by\nL<C<\\N{...}>|perlrecharclass/Character Ranges>, but the meaning may\nstill not be obvious.)\nThe stricter rules require that ranges that start or stop with an ASCII\ncharacter that is not a control have all their endpoints be the literal\ncharacter, and not some escape sequence (like C<\"\\x41\">), and the ranges\nmust be all digits, or all uppercase letters, or all lowercase letters.\n\n=item Ranges of digits should be from the same group in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)\n\nStricter rules help to find typos and other errors.  You included a\nrange, and at least one of the end points is a decimal digit.  Under the\nstricter rules, when this happens, both end points should be digits in\nthe same group of 10 consecutive digits.\n\n=item readdir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you're reading from is either closed or not really\na dirhandle.  Check your control flow.\n\n=item readline() on closed filehandle %s\n\n(W closed) The filehandle you're reading from got itself closed sometime\nbefore now.  Check your control flow.\n\n=item read() on closed filehandle %s\n\n(W closed) You tried to read from a closed filehandle.\n\n=item read() on unopened filehandle %s\n\n(W unopened) You tried to read from a filehandle that was never opened.\n\n=item Reallocation too large: %x\n\n(F) You can't allocate more than 64K on an MS-DOS machine.\n\n=item realloc() of freed memory ignored\n\n(S malloc) An internal routine called realloc() on something that had\nalready been freed.\n\n=item Recompile perl with B<-D>DEBUGGING to use B<-D> switch\n\n(S debugging) You can't use the B<-D> option unless the code to produce\nthe desired output is compiled into Perl, which entails some overhead,\nwhich is why it's currently left out of your copy.\n\n=item Recursive call to Perl_load_module in PerlIO_find_layer\n\n(P) It is currently not permitted to load modules when creating\na filehandle inside an %INC hook.  This can happen with C<open my\n$fh, '<', \\$scalar>, which implicitly loads PerlIO::scalar.  Try\nloading PerlIO::scalar explicitly first.\n\n=item Recursive inheritance detected in package '%s'\n\n(F) While calculating the method resolution order (MRO) of a package, Perl\nbelieves it found an infinite loop in the C<@ISA> hierarchy.  This is a\ncrude check that bails out after 100 levels of C<@ISA> depth.\n\n=item Redundant argument in %s\n\n(W redundant) You called a function with more arguments than other\narguments you supplied indicated would be needed.  Currently only\nemitted when a printf-type format required fewer arguments than were\nsupplied, but might be used in the future for e.g. L<perlfunc/pack>.\n\n=item refcnt_dec: fd %d%s\n\n=item refcnt: fd %d%s\n\n=item refcnt_inc: fd %d%s\n\n(P) Perl's I/O implementation failed an internal consistency check.  If\nyou see this message, something is very wrong.\n\n=item Reference found where even-sized list expected\n\n(W misc) You gave a single reference where Perl was expecting a list\nwith an even number of elements (for assignment to a hash).  This\nusually means that you used the anon hash constructor when you meant\nto use parens.  In any case, a hash requires key/value B<pairs>.\n\n    %hash = { one => 1, two => 2, };\t# WRONG\n    %hash = [ qw/ an anon array / ];\t# WRONG\n    %hash = ( one => 1, two => 2, );\t# right\n    %hash = qw( one 1 two 2 );\t\t\t# also fine\n\n=item Reference is already weak\n\n(W misc) You have attempted to weaken a reference that is already weak.\nDoing so has no effect.\n\n=item Reference is not weak\n\n(W misc) You have attempted to unweaken a reference that is not weak.\nDoing so has no effect.\n\n=item Reference to invalid group 0 in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You used C<\\g0> or similar in a regular expression.  You may refer\nto capturing parentheses only with strictly positive integers\n(normal backreferences) or with strictly negative integers (relative\nbackreferences).  Using 0 does not make sense.\n\n=item Reference to nonexistent group in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You used something like C<\\7> in your regular expression, but there are\nnot at least seven sets of capturing parentheses in the expression.  If\nyou wanted to have the character with ordinal 7 inserted into the regular\nexpression, prepend zeroes to make it three digits long: C<\\007>\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Reference to nonexistent named group in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) You used something like C<\\k'NAME'> or C<< \\k<NAME> >> in your regular\nexpression, but there is no corresponding named capturing parentheses\nsuch as C<(?'NAME'...)> or C<< (?<NAME>...) >>.  Check if the name has been\nspelled correctly both in the backreference and the declaration.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Reference to nonexistent or unclosed group in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used something like C<\\g{-7}> in your regular expression, but there\nare not at least seven sets of closed capturing parentheses in the\nexpression before where the C<\\g{-7}> was located.\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item regexp memory corruption\n\n(P) The regular expression engine got confused by what the regular\nexpression compiler gave it.\n\n=item Regexp modifier \"/%c\" may appear a maximum of twice\n\n=item Regexp modifier \"%c\" may appear a maximum of twice in regex; marked\nby S<<-- HERE> in m/%s/\n\n(F) The regular expression pattern had too many occurrences\nof the specified modifier.  Remove the extraneous ones.\n\n=item Regexp modifier \"%c\" may not appear after the \"-\" in regex; marked by <-- \nHERE in m/%s/\n\n(F) Turning off the given modifier has the side effect of turning on\nanother one.  Perl currently doesn't allow this.  Reword the regular\nexpression to use the modifier you want to turn on (and place it before\nthe minus), instead of the one you want to turn off.\n\n=item Regexp modifier \"/%c\" may not appear twice\n\n=item Regexp modifier \"%c\" may not appear twice in regex; marked by <--\nHERE in m/%s/\n\n(F) The regular expression pattern had too many occurrences\nof the specified modifier.  Remove the extraneous ones.\n\n=item Regexp modifiers \"/%c\" and \"/%c\" are mutually exclusive\n\n=item Regexp modifiers \"%c\" and \"%c\" are mutually exclusive in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The regular expression pattern had more than one of these\nmutually exclusive modifiers.  Retain only the modifier that is\nsupposed to be there.\n\n=item Regexp out of space in regex m/%s/\n\n(P) A \"can't happen\" error, because safemalloc() should have caught it\nearlier.\n\n=item Repeated format line will never terminate (~~ and @#)\n\n(F) Your format contains the ~~ repeat-until-blank sequence and a\nnumeric field that will never go blank so that the repetition never\nterminates.  You might use ^# instead.  See L<perlform>.\n\n=item Replacement list is longer than search list\n\n(W misc) You have used a replacement list that is longer than the\nsearch list.  So the additional elements in the replacement list\nare meaningless.\n\n=item '%s' resolved to '\\o{%s}%d'\n\n(W misc, regexp)  You wrote something like C<\\08>, or C<\\179> in a\ndouble-quotish string.  All but the last digit is treated as a single\ncharacter, specified in octal.  The last digit is the next character in\nthe string.  To tell Perl that this is indeed what you want, you can use\nthe C<\\o{ }> syntax, or use exactly three digits to specify the octal\nfor the character.\n\n=item Reversed %s= operator\n\n(W syntax) You wrote your assignment operator backwards.  The = must\nalways come last, to avoid ambiguity with subsequent unary operators.\n\n=item rewinddir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you tried to do a rewinddir() on is either closed\nor not really a dirhandle.  Check your control flow.\n\n=item Scalars leaked: %d\n\n(S internal) Something went wrong in Perl's internal bookkeeping\nof scalars: not all scalar variables were deallocated by the time\nPerl exited.  What this usually indicates is a memory leak, which\nis of course bad, especially if the Perl program is intended to be\nlong-running.\n\n=item Scalar value @%s[%s] better written as $%s[%s]\n\n(W syntax) You've used an array slice (indicated by @) to select a\nsingle element of an array.  Generally it's better to ask for a scalar\nvalue (indicated by $).  The difference is that C<$foo[&bar]> always\nbehaves like a scalar, both when assigning to it and when evaluating its\nargument, while C<@foo[&bar]> behaves like a list when you assign to it,\nand provides a list context to its subscript, which can do weird things\nif you're expecting only one subscript.\n\nOn the other hand, if you were actually hoping to treat the array\nelement as a list, you need to look into how references work, because\nPerl will not magically convert between scalars and lists for you.  See\nL<perlref>.\n\n=item Scalar value @%s{%s} better written as $%s{%s}\n\n(W syntax) You've used a hash slice (indicated by @) to select a single\nelement of a hash.  Generally it's better to ask for a scalar value\n(indicated by $).  The difference is that C<$foo{&bar}> always behaves\nlike a scalar, both when assigning to it and when evaluating its\nargument, while C<@foo{&bar}> behaves like a list when you assign to it,\nand provides a list context to its subscript, which can do weird things\nif you're expecting only one subscript.\n\nOn the other hand, if you were actually hoping to treat the hash element\nas a list, you need to look into how references work, because Perl will\nnot magically convert between scalars and lists for you.  See\nL<perlref>.\n\n=item Search pattern not terminated\n\n(F) The lexer couldn't find the final delimiter of a // or m{}\nconstruct.  Remember that bracketing delimiters count nesting level.\nMissing the leading C<$> from a variable C<$m> may cause this error.\n\nNote that since Perl 5.10.0 a // can also be the I<defined-or>\nconstruct, not just the empty search pattern.  Therefore code written\nin Perl 5.10.0 or later that uses the // as the I<defined-or> can be\nmisparsed by pre-5.10.0 Perls as a non-terminated search pattern.\n\n=item seekdir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you are doing a seekdir() on is either closed or not\nreally a dirhandle.  Check your control flow.\n\n=item %sseek() on unopened filehandle\n\n(W unopened) You tried to use the seek() or sysseek() function on a\nfilehandle that was either never opened or has since been closed.\n\n=item select not implemented\n\n(F) This machine doesn't implement the select() system call.\n\n=item Self-ties of arrays and hashes are not supported\n\n(F) Self-ties are of arrays and hashes are not supported in\nthe current implementation.\n\n=item Semicolon seems to be missing\n\n(W semicolon) A nearby syntax error was probably caused by a missing\nsemicolon, or possibly some other missing operator, such as a comma.\n\n=item semi-panic: attempt to dup freed string\n\n(S internal) The internal newSVsv() routine was called to duplicate a\nscalar that had previously been marked as free.\n\n=item sem%s not implemented\n\n(F) You don't have System V semaphore IPC on your system.\n\n=item send() on closed socket %s\n\n(W closed) The socket you're sending to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item Sequence \"\\c{\" invalid\n\n(F) These three characters may not appear in sequence in a\ndouble-quotish context.  This message is raised only on non-ASCII\nplatforms (a different error message is output on ASCII ones).  If you\nwere intending to specify a control character with this sequence, you'll\nhave to use a different way to specify it.\n\n=item Sequence (? incomplete in regex; marked by S<<-- HERE> in m/%s/\n\n(F) A regular expression ended with an incomplete extension (?.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Sequence (?%c...) not implemented in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) A proposed regular expression extension has the character reserved\nbut has not yet been written.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.  See L<perlre>.\n\n=item Sequence (?%s...) not recognized in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You used a regular expression extension that doesn't make sense.\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  This may happen when using the C<(?^...)> construct to tell\nPerl to use the default regular expression modifiers, and you\nredundantly specify a default modifier.  For other\ncauses, see L<perlre>.\n\n=item Sequence (?#... not terminated in regex m/%s/\n\n(F) A regular expression comment must be terminated by a closing\nparenthesis.  Embedded parentheses aren't allowed.  See\nL<perlre>.\n\n=item Sequence (?&... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) A named reference of the form C<(?&...)> was missing the final\nclosing parenthesis after the name.  The S<<-- HERE> shows whereabouts\nin the regular expression the problem was discovered.\n\n=item Sequence (?%c... not terminated in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) A named group of the form C<(?'...')> or C<< (?<...>) >> was missing the final\nclosing quote or angle bracket.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.\n\n=item Sequence (?(%c... not terminated in regex; marked by S<<-- HERE>\nin m/%s/\n\n(F) A named reference of the form C<(?('...')...)> or C<< (?(<...>)...) >> was\nmissing the final closing quote or angle bracket after the name.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Sequence (?... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) There was no matching closing parenthesis for the '('.  The\nS<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.\n\n=item Sequence \\%s... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) The regular expression expects a mandatory argument following the escape\nsequence and this has been omitted or incorrectly written.\n\n=item Sequence (?{...}) not terminated with ')'\n\n(F) The end of the perl code contained within the {...} must be\nfollowed immediately by a ')'.\n\n=item Sequence (?PE<gt>... not terminated in regex; marked by S<<-- HERE> in m/%s/\n\n(F) A named reference of the form C<(?PE<gt>...)> was missing the final\nclosing parenthesis after the name.  The S<<-- HERE> shows whereabouts\nin the regular expression the problem was discovered.\n\n=item Sequence (?PE<lt>... not terminated in regex; marked by S<<-- HERE> in m/%s/\n\n(F) A named group of the form C<(?PE<lt>...E<gt>')> was missing the final\nclosing angle bracket.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.\n\n=item Sequence ?P=... not terminated in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) A named reference of the form C<(?P=...)> was missing the final\nclosing parenthesis after the name.  The S<<-- HERE> shows whereabouts\nin the regular expression the problem was discovered.\n\n=item Sequence (?R) not terminated in regex m/%s/\n\n(F) An C<(?R)> or C<(?0)> sequence in a regular expression was missing the\nfinal parenthesis.\n\n=item Z<>500 Server error\n\n(A) This is the error message generally seen in a browser window\nwhen trying to run a CGI program (including SSI) over the web.  The\nactual error text varies widely from server to server.  The most\nfrequently-seen variants are \"500 Server error\", \"Method (something)\nnot permitted\", \"Document contains no data\", \"Premature end of script\nheaders\", and \"Did not produce a valid header\".\n\nB<This is a CGI error, not a Perl error>.\n\nYou need to make sure your script is executable, is accessible by\nthe user CGI is running the script under (which is probably not the\nuser account you tested it under), does not rely on any environment\nvariables (like PATH) from the user it isn't running under, and isn't\nin a location where the CGI server can't find it, basically, more or\nless.  Please see the following for more information:\n\n\thttp://www.perl.org/CGI_MetaFAQ.html\n\thttp://www.htmlhelp.org/faq/cgifaq.html\n\thttp://www.w3.org/Security/Faq/\n\nYou should also look at L<perlfaq9>.\n\n=item setegid() not implemented\n\n(F) You tried to assign to C<$)>, and your operating system doesn't\nsupport the setegid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item seteuid() not implemented\n\n(F) You tried to assign to C<< $> >>, and your operating system doesn't\nsupport the seteuid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item setpgrp can't take arguments\n\n(F) Your system has the setpgrp() from BSD 4.2, which takes no\narguments, unlike POSIX setpgid(), which takes a process ID and process\ngroup ID.\n\n=item setrgid() not implemented\n\n(F) You tried to assign to C<$(>, and your operating system doesn't\nsupport the setrgid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item setruid() not implemented\n\n(F) You tried to assign to C<$<>, and your operating system doesn't\nsupport the setruid() system call (or equivalent), or at least Configure\ndidn't think so.\n\n=item setsockopt() on closed socket %s\n\n(W closed) You tried to set a socket option on a closed socket.  Did you\nforget to check the return value of your socket() call?  See\nL<perlfunc/setsockopt>.\n\n=item Setting $/ to a reference to %s is forbidden\n\n(F) You assigned a reference to a scalar to C<$/> where the referenced item is\nnot a positive integer.  In older perls this B<appeared> to work the same as\nsetting it to C<undef> but was in fact internally different, less efficient\nand with very bad luck could have resulted in your file being split by a\nstringified form of the reference.\n\nIn Perl 5.20.0 this was changed so that it would be B<exactly> the same as\nsetting C<$/> to undef, with the exception that this warning would be thrown.\n\nYou are recommended to change your code to set C<$/> to C<undef> explicitly if\nyou wish to slurp the file.  As of Perl 5.28 assigning C<$/> to a reference\nto an integer which isn't positive is a fatal error.\n\n=item Setting $/ to %s reference is forbidden\n\n(F) You tried to assign a reference to a non integer to C<$/>.  In older\nPerls this would have behaved similarly to setting it to a reference to\na positive integer, where the integer was the address of the reference.\nAs of Perl 5.20.0 this is a fatal error, to allow future versions of Perl\nto use non-integer refs for more interesting purposes.\n\n=item shm%s not implemented\n\n(F) You don't have System V shared memory IPC on your system.\n\n=item !=~ should be !~\n\n(W syntax) The non-matching operator is !~, not !=~.  !=~ will be\ninterpreted as the != (numeric not equal) and ~ (1's complement)\noperators: probably not what you intended.\n\n=item /%s/ should probably be written as \"%s\"\n\n(W syntax) You have used a pattern where Perl expected to find a string,\nas in the first argument to C<join>.  Perl will treat the true or false\nresult of matching the pattern against $_ as the string, which is\nprobably not what you had in mind.\n\n=item shutdown() on closed socket %s\n\n(W closed) You tried to do a shutdown on a closed socket.  Seems a bit\nsuperfluous.\n\n=item SIG%s handler \"%s\" not defined\n\n(W signal) The signal handler named in %SIG doesn't, in fact, exist.\nPerhaps you put it into the wrong package?\n\n=item Slab leaked from cv %p\n\n(S) If you see this message, then something is seriously wrong with the\ninternal bookkeeping of op trees.  An op tree needed to be freed after\na compilation error, but could not be found, so it was leaked instead.\n\n=item sleep(%u) too large\n\n(W overflow) You called C<sleep> with a number that was larger than\nit can reliably handle and C<sleep> probably slept for less time than\nrequested.\n\n=item Slurpy parameter not last\n\n(F) In a subroutine signature, you put something after a slurpy (array or\nhash) parameter.  The slurpy parameter takes all the available arguments,\nso there can't be any left to fill later parameters.\n\n=item Smart matching a non-overloaded object breaks encapsulation\n\n(F) You should not use the C<~~> operator on an object that does not\noverload it: Perl refuses to use the object's underlying structure\nfor the smart match.\n\n=item Smartmatch is experimental\n\n(S experimental::smartmatch) This warning is emitted if you\nuse the smartmatch (C<~~>) operator.  This is currently an experimental\nfeature, and its details are subject to change in future releases of\nPerl.  Particularly, its current behavior is noticed for being\nunnecessarily complex and unintuitive, and is very likely to be\noverhauled.\n\n=item Sorry, hash keys must be smaller than 2**31 bytes\n\n(F) You tried to create a hash containing a very large key, where \"very\nlarge\" means that it needs at least 2 gigabytes to store. Unfortunately,\nPerl doesn't yet handle such large hash keys. You should\nreconsider your design to avoid hashing such a long string directly.\n\n=item sort is now a reserved word\n\n(F) An ancient error message that almost nobody ever runs into anymore.\nBut before sort was a keyword, people sometimes used it as a filehandle.\n\n=item Source filters apply only to byte streams\n\n(F) You tried to activate a source filter (usually by loading a\nsource filter module) within a string passed to C<eval>.  This is\nnot permitted under the C<unicode_eval> feature.  Consider using\nC<evalbytes> instead.  See L<feature>.\n\n=item splice() offset past end of array\n\n(W misc) You attempted to specify an offset that was past the end of\nthe array passed to splice().  Splicing will instead commence at the\nend of the array, rather than past it.  If this isn't what you want,\ntry explicitly pre-extending the array by assigning $#array = $offset.\nSee L<perlfunc/splice>.\n\n=item Split loop\n\n(P) The split was looping infinitely.  (Obviously, a split shouldn't\niterate more times than there are characters of input, which is what\nhappened.)  See L<perlfunc/split>.\n\n=item Statement unlikely to be reached\n\n(W exec) You did an exec() with some statement after it other than a\ndie().  This is almost always an error, because exec() never returns\nunless there was a failure.  You probably wanted to use system()\ninstead, which does return.  To suppress this warning, put the exec() in\na block by itself.\n\n=item \"state\" subroutine %s can't be in a package\n\n(F) Lexically scoped subroutines aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.\n\n=item \"state %s\" used in sort comparison\n\n(W syntax) The package variables $a and $b are used for sort comparisons.\nYou used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a\nsort comparison block, and the variable had earlier been declared as a\nlexical variable.  Either qualify the sort variable with the package\nname, or rename the lexical variable.\n\n=item \"state\" variable %s can't be in a package\n\n(F) Lexically scoped variables aren't in a package, so it doesn't make\nsense to try to declare one with a package qualifier on the front.  Use\nlocal() if you want to localize a package variable.\n\n=item stat() on unopened filehandle %s\n\n(W unopened) You tried to use the stat() function on a filehandle that\nwas either never opened or has since been closed.\n\n=item Strings with code points over 0xFF may not be mapped into in-memory file handles\n\n(W utf8) You tried to open a reference to a scalar for read or append\nwhere the scalar contained code points over 0xFF.  In-memory files\nmodel on-disk files and can only contain bytes.\n\n=item Stub found while resolving method \"%s\" overloading \"%s\" in package \"%s\"\n\n(P) Overloading resolution over @ISA tree may be broken by importation\nstubs.  Stubs should never be implicitly created, but explicit calls to\nC<can> may break this.\n\n=item Subroutine \"&%s\" is not available\n\n(W closure) During compilation, an inner named subroutine or eval is\nattempting to capture an outer lexical subroutine that is not currently\navailable.  This can happen for one of two reasons.  First, the lexical\nsubroutine may be declared in an outer anonymous subroutine that has\nnot yet been created.  (Remember that named subs are created at compile\ntime, while anonymous subs are created at run-time.)  For example,\n\n    sub { my sub a {...} sub f { \\&a } }\n\nAt the time that f is created, it can't capture the current \"a\" sub,\nsince the anonymous subroutine hasn't been created yet.  Conversely, the\nfollowing won't give a warning since the anonymous subroutine has by now\nbeen created and is live:\n\n    sub { my sub a {...} eval 'sub f { \\&a }' }->();\n\nThe second situation is caused by an eval accessing a lexical subroutine\nthat has gone out of scope, for example,\n\n    sub f {\n\tmy sub a {...}\n\tsub { eval '\\&a' }\n    }\n    f()->();\n\nHere, when the '\\&a' in the eval is being compiled, f() is not currently\nbeing executed, so its &a is not available for capture.\n\n=item \"%s\" subroutine &%s masks earlier declaration in same %s\n\n(W shadow) A \"my\" or \"state\" subroutine has been redeclared in the\ncurrent scope or statement, effectively eliminating all access to\nthe previous instance.  This is almost always a typographical error.\nNote that the earlier subroutine will still exist until the end of\nthe scope or until all closure references to it are destroyed.\n\n=item Subroutine %s redefined\n\n(W redefine) You redefined a subroutine.  To suppress this warning, say\n\n    {\n\tno warnings 'redefine';\n\teval \"sub name { ... }\";\n    }\n\n=item Subroutine \"%s\" will not stay shared\n\n(W closure) An inner (nested) I<named> subroutine is referencing a \"my\"\nsubroutine defined in an outer named subroutine.\n\nWhen the inner subroutine is called, it will see the value of the outer\nsubroutine's lexical subroutine as it was before and during the *first*\ncall to the outer subroutine; in this case, after the first call to the\nouter subroutine is complete, the inner and outer subroutines will no\nlonger share a common value for the lexical subroutine.  In other words,\nit will no longer be shared.  This will especially make a difference\nif the lexical subroutines accesses lexical variables declared in its\nsurrounding scope.\n\nThis problem can usually be solved by making the inner subroutine\nanonymous, using the C<sub {}> syntax.  When inner anonymous subs that\nreference lexical subroutines in outer subroutines are created, they\nare automatically rebound to the current values of such lexical subs.\n\n=item Substitution loop\n\n(P) The substitution was looping infinitely.  (Obviously, a substitution\nshouldn't iterate more times than there are characters of input, which\nis what happened.)  See the discussion of substitution in\nL<perlop/\"Regexp Quote-Like Operators\">.\n\n=item Substitution pattern not terminated\n\n(F) The lexer couldn't find the interior delimiter of an s/// or s{}{}\nconstruct.  Remember that bracketing delimiters count nesting level.\nMissing the leading C<$> from variable C<$s> may cause this error.\n\n=item Substitution replacement not terminated\n\n(F) The lexer couldn't find the final delimiter of an s/// or s{}{}\nconstruct.  Remember that bracketing delimiters count nesting level.\nMissing the leading C<$> from variable C<$s> may cause this error.\n\n=item substr outside of string\n\n(W substr)(F) You tried to reference a substr() that pointed outside of\na string.  That is, the absolute value of the offset was larger than the\nlength of the string.  See L<perlfunc/substr>.  This warning is fatal if\nsubstr is used in an lvalue context (as the left hand side of an\nassignment or as a subroutine argument for example).\n\n=item sv_upgrade from type %d down to type %d\n\n(P) Perl tried to force the upgrade of an SV to a type which was actually\ninferior to its current type.\n\n=item SWASHNEW didn't return an HV ref\n\n(P) Something went wrong internally when Perl was trying to look up\nUnicode characters.\n\n=item Switch (?(condition)... contains too many branches in regex; marked by \nS<<-- HERE> in m/%s/\n\n(F) A (?(condition)if-clause|else-clause) construct can have at most\ntwo branches (the if-clause and the else-clause).  If you want one or\nboth to contain alternation, such as using C<this|that|other>, enclose\nit in clustering parentheses:\n\n    (?(condition)(?:this|that|other)|else-clause)\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem\nwas discovered.  See L<perlre>.\n\n=item Switch condition not recognized in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) The condition part of a (?(condition)if-clause|else-clause) construct\nis not known.  The condition must be one of the following:\n\n (1) (2) ...        true if 1st, 2nd, etc., capture matched\n (<NAME>) ('NAME')  true if named capture matched\n (?=...) (?<=...)   true if subpattern matches\n (?!...) (?<!...)   true if subpattern fails to match\n (?{ CODE })        true if code returns a true value\n (R)                true if evaluating inside recursion\n (R1) (R2) ...      true if directly inside capture group 1, 2, etc.\n (R&NAME)           true if directly inside named capture\n (DEFINE)           always false; for defining named subpatterns\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Switch (?(condition)... not terminated in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You omitted to close a (?(condition)...) block somewhere\nin the pattern.  Add a closing parenthesis in the appropriate\nposition.  See L<perlre>.\n\n=item switching effective %s is not implemented\n\n(F) While under the C<use filetest> pragma, we cannot switch the real\nand effective uids or gids.\n\n=item syntax error\n\n(F) Probably means you had a syntax error.  Common reasons include:\n\n    A keyword is misspelled.\n    A semicolon is missing.\n    A comma is missing.\n    An opening or closing parenthesis is missing.\n    An opening or closing brace is missing.\n    A closing quote is missing.\n\nOften there will be another error message associated with the syntax\nerror giving more information.  (Sometimes it helps to turn on B<-w>.)\nThe error message itself often tells you where it was in the line when\nit decided to give up.  Sometimes the actual error is several tokens\nbefore this, because Perl is good at understanding random input.\nOccasionally the line number may be misleading, and once in a blue moon\nthe only way to figure out what's triggering the error is to call\nC<perl -c> repeatedly, chopping away half the program each time to see\nif the error went away.  Sort of the cybernetic version of S<20 questions>.\n\n=item syntax error at line %d: '%s' unexpected\n\n(A) You've accidentally run your script through the Bourne shell instead\nof Perl.  Check the #! line, or manually feed your script into Perl\nyourself.\n\n=item syntax error in file %s at line %d, next 2 tokens \"%s\"\n\n(F) This error is likely to occur if you run a perl5 script through\na perl4 interpreter, especially if the next 2 tokens are \"use strict\"\nor \"my $var\" or \"our $var\".\n\n=item Syntax error in (?[...]) in regex; marked by <-- HERE in m/%s/\n\n(F) Perl could not figure out what you meant inside this construct; this\nnotifies you that it is giving up trying.\n\n=item %s syntax OK\n\n(F) The final summary message when a C<perl -c> succeeds.\n\n=item sysread() on closed filehandle %s\n\n(W closed) You tried to read from a closed filehandle.\n\n=item sysread() on unopened filehandle %s\n\n(W unopened) You tried to read from a filehandle that was never opened.\n\n=item System V %s is not implemented on this machine\n\n(F) You tried to do something with a function beginning with \"sem\",\n\"shm\", or \"msg\" but that System V IPC is not implemented in your\nmachine.  In some machines the functionality can exist but be\nunconfigured.  Consult your system support.\n\n=item syswrite() on closed filehandle %s\n\n(W closed) The filehandle you're writing to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item C<-T> and C<-B> not implemented on filehandles\n\n(F) Perl can't peek at the stdio buffer of filehandles when it doesn't\nknow about your kind of stdio.  You'll have to use a filename instead.\n\n=item Target of goto is too deeply nested\n\n(F) You tried to use C<goto> to reach a label that was too deeply nested\nfor Perl to reach.  Perl is doing you a favor by refusing.\n\n=item telldir() attempted on invalid dirhandle %s\n\n(W io) The dirhandle you tried to telldir() is either closed or not really\na dirhandle.  Check your control flow.\n\n=item tell() on unopened filehandle\n\n(W unopened) You tried to use the tell() function on a filehandle that\nwas either never opened or has since been closed.\n\n=item That use of $[ is unsupported\n\n(F) Assignment to C<$[> is now strictly circumscribed, and interpreted\nas a compiler directive.  You may say only one of\n\n    $[ = 0;\n    $[ = 1;\n    ...\n    local $[ = 0;\n    local $[ = 1;\n    ...\n\nThis is to prevent the problem of one module changing the array base out\nfrom under another module inadvertently.  See L<perlvar/$[> and L<arybase>.\n\n=item The bitwise feature is experimental\n\n(S experimental::bitwise) This warning is emitted if you use bitwise\noperators (C<& | ^ ~ &. |. ^. ~.>) with the \"bitwise\" feature enabled.\nSimply suppress the warning if you want to use the feature, but know\nthat in doing so you are taking the risk of using an experimental\nfeature which may change or be removed in a future Perl version:\n\n    no warnings \"experimental::bitwise\";\n    use feature \"bitwise\";\n    $x |.= $y;\n\n=item The crypt() function is unimplemented due to excessive paranoia.\n\n(F) Configure couldn't find the crypt() function on your machine,\nprobably because your vendor didn't supply it, probably because they\nthink the U.S. Government thinks it's a secret, or at least that they\nwill continue to pretend that it is.  And if you quote me on that, I\nwill deny it.\n\n=item The experimental declared_refs feature is not enabled\n\n(F) To declare references to variables, as in C<my \\%x>, you must first enable\nthe feature:\n\n    no warnings \"experimental::declared_refs\";\n    use feature \"declared_refs\";\n\n=item The %s function is unimplemented\n\n(F) The function indicated isn't implemented on this architecture,\naccording to the probings of Configure.\n\n=item The regex_sets feature is experimental\n\n(S experimental::regex_sets) This warning is emitted if you\nuse the syntax S<C<(?[   ])>> in a regular expression.\nThe details of this feature are subject to change.\nif you want to use it, but know that in doing so you\nare taking the risk of using an experimental feature which may\nchange in a future Perl version, you can do this to silence the\nwarning:\n\n    no warnings \"experimental::regex_sets\";\n\n=item The signatures feature is experimental\n\n(S experimental::signatures) This warning is emitted if you unwrap a\nsubroutine's arguments using a signature.  Simply suppress the warning\nif you want to use the feature, but know that in doing so you are taking\nthe risk of using an experimental feature which may change or be removed\nin a future Perl version:\n\n    no warnings \"experimental::signatures\";\n    use feature \"signatures\";\n    sub foo ($left, $right) { ... }\n\n=item The stat preceding %s wasn't an lstat\n\n(F) It makes no sense to test the current stat buffer for symbolic\nlinkhood if the last stat that wrote to the stat buffer already went\npast the symlink to get to the real file.  Use an actual filename\ninstead.\n\n=item The 'unique' attribute may only be applied to 'our' variables\n\n(F) This attribute was never supported on C<my> or C<sub> declarations.\n\n=item This Perl can't reset CRTL environ elements (%s)\n\n=item This Perl can't set CRTL environ elements (%s=%s)\n\n(W internal) Warnings peculiar to VMS.  You tried to change or delete an\nelement of the CRTL's internal environ array, but your copy of Perl\nwasn't built with a CRTL that contained the setenv() function.  You'll\nneed to rebuild Perl with a CRTL that does, or redefine\nF<PERL_ENV_TABLES> (see L<perlvms>) so that the environ array isn't the\ntarget of the change to\n%ENV which produced the warning.\n\n=item This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().\n\n(F) Something has attempted to use an internal API call which\ndepends on Perl being compiled with the default support for randomized hash\nkey traversal, but this Perl has been compiled without it.  You should\nreport this warning to the relevant upstream party, or recompile perl\nwith default options.\n\n=item times not implemented\n\n(F) Your version of the C library apparently doesn't do times().  I\nsuspect you're not running on Unix.\n\n=item \"-T\" is on the #! line, it must also be used on the command line\n\n(X) The #! line (or local equivalent) in a Perl script contains\nthe B<-T> option (or the B<-t> option), but Perl was not invoked with\nB<-T> in its command line.  This is an error because, by the time\nPerl discovers a B<-T> in a script, it's too late to properly taint\neverything from the environment.  So Perl gives up.\n\nIf the Perl script is being executed as a command using the #!\nmechanism (or its local equivalent), this error can usually be\nfixed by editing the #! line so that the B<-%c> option is a part of\nPerl's first argument: e.g. change C<perl -n -%c> to C<perl -%c -n>.\n\nIf the Perl script is being executed as C<perl scriptname>, then the\nB<-%c> option must appear on the command line: C<perl -%c scriptname>.\n\n=item To%s: illegal mapping '%s'\n\n(F) You tried to define a customized To-mapping for lc(), lcfirst,\nuc(), or ucfirst() (or their string-inlined versions), but you\nspecified an illegal mapping.\nSee L<perlunicode/\"User-Defined Character Properties\">.\n\n=item Too deeply nested ()-groups\n\n(F) Your template contains ()-groups with a ridiculously deep nesting level.\n\n=item Too few args to syscall\n\n(F) There has to be at least one argument to syscall() to specify the\nsystem call to call, silly dilly.\n\n=item Too few arguments for subroutine '%s'\n\n(F) A subroutine using a signature fewer arguments than required by the\nsignature.  The caller of the subroutine is presumably at fault.\n\nThe message attempts to include the name of the called subroutine.  If\nthe subroutine has been aliased, the subroutine's original name will be\nshown, regardless of what name the caller used.\n\n=item Too late for \"-%s\" option\n\n(X) The #! line (or local equivalent) in a Perl script contains the\nB<-M>, B<-m> or B<-C> option.\n\nIn the case of B<-M> and B<-m>, this is an error because those options\nare not intended for use inside scripts.  Use the C<use> pragma instead.\n\nThe B<-C> option only works if it is specified on the command line as\nwell (with the same sequence of letters or numbers following).  Either\nspecify this option on the command line, or, if your system supports\nit, make your script executable and run it directly instead of passing\nit to perl.\n\n=item Too late to run %s block\n\n(W void) A CHECK or INIT block is being defined during run time proper,\nwhen the opportunity to run them has already passed.  Perhaps you are\nloading a file with C<require> or C<do> when you should be using C<use>\ninstead.  Or perhaps you should put the C<require> or C<do> inside a\nBEGIN block.\n\n=item Too many args to syscall\n\n(F) Perl supports a maximum of only 14 args to syscall().\n\n=item Too many arguments for %s\n\n(F) The function requires fewer arguments than you specified.\n\n=item Too many arguments for subroutine '%s'\n\n(F) A subroutine using a signature received more arguments than permitted\nby the signature.  The caller of the subroutine is presumably at fault.\n\nThe message attempts to include the name of the called subroutine. If the\nsubroutine has been aliased, the subroutine's original name will be shown,\nregardless of what name the caller used.\n\n=item Too many )'s\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item Too many ('s\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item Trailing \\ in regex m/%s/\n\n(F) The regular expression ends with an unbackslashed backslash.\nBackslash it.   See L<perlre>.\n\n=item Transliteration pattern not terminated\n\n(F) The lexer couldn't find the interior delimiter of a tr/// or tr[][]\nor y/// or y[][] construct.  Missing the leading C<$> from variables\nC<$tr> or C<$y> may cause this error.\n\n=item Transliteration replacement not terminated\n\n(F) The lexer couldn't find the final delimiter of a tr///, tr[][],\ny/// or y[][] construct.\n\n=item '%s' trapped by operation mask\n\n(F) You tried to use an operator from a Safe compartment in which it's\ndisallowed.  See L<Safe>.\n\n=item truncate not implemented\n\n(F) Your machine doesn't implement a file truncation mechanism that\nConfigure knows about.\n\n=item Type of arg %d to &CORE::%s must be %s\n\n(F) The subroutine in question in the CORE package requires its argument\nto be a hard reference to data of the specified type.  Overloading is\nignored, so a reference to an object that is not the specified type, but\nnonetheless has overloading to handle it, will still not be accepted.\n\n=item Type of arg %d to %s must be %s (not %s)\n\n(F) This function requires the argument in that position to be of a\ncertain type.  Arrays must be @NAME or C<@{EXPR}>.  Hashes must be\n%NAME or C<%{EXPR}>.  No implicit dereferencing is allowed--use the\n{EXPR} forms as an explicit dereference.  See L<perlref>.\n\n=item umask not implemented\n\n(F) Your machine doesn't implement the umask function and you tried to\nuse it to restrict permissions for yourself (EXPR & 0700).\n\n=item Unbalanced context: %d more PUSHes than POPs\n\n(S internal) The exit code detected an internal inconsistency in how\nmany execution contexts were entered and left.\n\n=item Unbalanced saves: %d more saves than restores\n\n(S internal) The exit code detected an internal inconsistency in how\nmany values were temporarily localized.\n\n=item Unbalanced scopes: %d more ENTERs than LEAVEs\n\n(S internal) The exit code detected an internal inconsistency in how\nmany blocks were entered and left.\n\n=item Unbalanced string table refcount: (%d) for \"%s\"\n\n(S internal) On exit, Perl found some strings remaining in the shared\nstring table used for copy on write and for hash keys.  The entries\nshould have been freed, so this indicates a bug somewhere.\n\n=item Unbalanced tmps: %d more allocs than frees\n\n(S internal) The exit code detected an internal inconsistency in how\nmany mortal scalars were allocated and freed.\n\n=item Undefined format \"%s\" called\n\n(F) The format indicated doesn't seem to exist.  Perhaps it's really in\nanother package?  See L<perlform>.\n\n=item Undefined sort subroutine \"%s\" called\n\n(F) The sort comparison routine specified doesn't seem to exist.\nPerhaps it's in a different package?  See L<perlfunc/sort>.\n\n=item Undefined subroutine &%s called\n\n(F) The subroutine indicated hasn't been defined, or if it was, it has\nsince been undefined.\n\n=item Undefined subroutine called\n\n(F) The anonymous subroutine you're trying to call hasn't been defined,\nor if it was, it has since been undefined.\n\n=item Undefined subroutine in sort\n\n(F) The sort comparison routine specified is declared but doesn't seem\nto have been defined yet.  See L<perlfunc/sort>.\n\n=item Undefined top format \"%s\" called\n\n(F) The format indicated doesn't seem to exist.  Perhaps it's really in\nanother package?  See L<perlform>.\n\n=item Undefined value assigned to typeglob\n\n(W misc) An undefined value was assigned to a typeglob, a la\nC<*foo = undef>.  This does nothing.  It's possible that you really mean\nC<undef *foo>.\n\n=item %s: Undefined variable\n\n(A) You've accidentally run your script through B<csh> instead of Perl.\nCheck the #! line, or manually feed your script into Perl yourself.\n\n=item Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through in regex; marked by S<<-- HERE> in m/%s/\n\n(D deprecated, regexp)  The simple rule to remember, if you want to\nmatch a literal C<{> character (U+007B C<LEFT CURLY BRACKET>) in a\nregular expression pattern, is to escape each literal instance of it in\nsome way.  Generally easiest is to precede it with a backslash, like\nC<\\{> or enclose it in square brackets (C<[{]>).  If the pattern\ndelimiters are also braces, any matching right brace (C<}>) should\nalso be escaped to avoid confusing the parser, for example,\n\n qr{abc\\{def\\}ghi}\n\nForcing literal C<{> characters to be escaped will enable the Perl\nlanguage to be extended in various ways in future releases.  To avoid\nneedlessly breaking existing code, the restriction is is not enforced in\ncontexts where there are unlikely to ever be extensions that could\nconflict with the use there of C<{> as a literal.\n\nIn this release of Perl, some literal uses of C<{> are fatal, and some\nstill just deprecated.  This is because of an oversight:  some uses of a\nliteral C<{> that should have raised a deprecation warning starting in\nv5.20 did not warn until v5.26.  By making the already-warned uses fatal\nnow, some of the planned extensions can be made to the language sooner.\nThe cases which are still allowed will be fatal in Perl 5.30.\n\nThe contexts where no warnings or errors are raised are:\n\n=over 4\n\n=item *\n\nas the first character in a pattern, or following C<^> indicating to\nanchor the match to the beginning of a line.\n\n=item *\n\nas the first character following a C<|> indicating alternation.\n\n=item *\n\nas the first character in a parenthesized grouping like\n\n /foo({bar)/\n /foo(?:{bar)/\n\n=item *\n\nas the first character following a quantifier\n\n /\\s*{/\n\n=back\n\n=for comment\nThe text of the message above is duplicated below to allow splain (and\n'use diagnostics') to work.  Since one is fatal, and one not, they can't\nbe combined as one message.  And since the non-fatal one is temporary,\nthere's no real need to enhance perldiag to handle this transient case.\n\n=item Unescaped left brace in regex is illegal here in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) The simple rule to remember, if you want to\nmatch a literal C<\"{\"> character (U+007B C<LEFT CURLY BRACKET>) in a\nregular expression pattern, is to escape each literal instance of it in\nsome way.  Generally easiest is to precede it with a backslash, like\nC<\"\\{\"> or enclose it in square brackets (C<\"[{]\">).  If the pattern\ndelimiters are also braces, any matching right brace (C<\"}\">) should\nalso be escaped to avoid confusing the parser, for example,\n\n qr{abc\\{def\\}ghi}\n\nForcing literal C<\"{\"> characters to be escaped will enable the Perl\nlanguage to be extended in various ways in future releases.  To avoid\nneedlessly breaking existing code, the restriction is is not enforced in\ncontexts where there are unlikely to ever be extensions that could\nconflict with the use there of C<\"{\"> as a literal.\n\nIn this release of Perl, some literal uses of C<\"{\"> are fatal, and some\nstill just deprecated.  This is because of an oversight:  some uses of a\nliteral C<\"{\"> that should have raised a deprecation warning starting in\nv5.20 did not warn until v5.26.  By making the already-warned uses fatal\nnow, some of the planned extensions can be made to the language sooner.\n\nThe contexts where no warnings or errors are raised are:\n\n=over 4\n\n=item *\n\nas the first character in a pattern, or following C<\"^\"> indicating to\nanchor the match to the beginning of a line.\n\n=item *\n\nas the first character following a C<\"|\"> indicating alternation.\n\n=item *\n\nas the first character in a parenthesized grouping like\n\n /foo({bar)/\n /foo(?:{bar)/\n\n=item *\n\nas the first character following a quantifier\n\n /\\s*{/\n\n=back\n\n=item Unescaped literal '%c' in regex; marked by <-- HERE in m/%s/\n\n(W regexp) (only under C<S<use re 'strict'>>)\n\nWithin the scope of C<S<use re 'strict'>> in a regular expression\npattern, you included an unescaped C<}> or C<]> which was interpreted\nliterally.  These two characters are sometimes metacharacters, and\nsometimes literals, depending on what precedes them in the\npattern.  This is unlike the similar C<)> which is always a\nmetacharacter unless escaped.\n\nThis action at a distance, perhaps a large distance, can lead to Perl\nsilently misinterpreting what you meant, so when you specify that you\nwant extra checking by C<S<use re 'strict'>>, this warning is generated.\nIf you meant the character as a literal, simply confirm that to Perl by\npreceding the character with a backslash, or make it into a bracketed\ncharacter class (like C<[}]>).  If you meant it as closing a\ncorresponding C<[> or C<{>, you'll need to look back through the pattern\nto find out why that isn't happening.\n\n=item unexec of %s into %s failed!\n\n(F) The unexec() routine failed for some reason.  See your local FSF\nrepresentative, who probably put it there in the first place.\n\n=item Unexpected ']' with no following ')' in (?[... in regex; marked by <-- HERE in m/%s/\n\n(F) While parsing an extended character class a ']' character was encountered\nat a point in the definition where the only legal use of ']' is to close the\ncharacter class definition as part of a '])', you may have forgotten the close\nparen, or otherwise confused the parser.\n\n=item Expecting close paren for nested extended charclass in regex; marked by <-- HERE in m/%s/\n\n(F) While parsing a nested extended character class like:\n\n    (?[ ... (?flags:(?[ ... ])) ... ])\n                             ^\n\nwe expected to see a close paren ')' (marked by ^) but did not.\n\n=item Expecting close paren for wrapper for nested extended charclass in regex; marked by <-- HERE in m/%s/\n\n(F) While parsing a nested extended character class like:\n\n    (?[ ... (?flags:(?[ ... ])) ... ])\n                              ^\n\nwe expected to see a close paren ')' (marked by ^) but did not.\n\n=item Unexpected binary operator '%c' with no preceding operand in regex;\nmarked by S<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ | \\p{Digit} ])\n\nwhere the C<\"|\"> is a binary operator with an operand on the right, but\nno operand on the left.\n\n=item Unexpected character in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ z ])\n\nWithin C<(?[ ])>, no literal characters are allowed unless they are\nwithin an inner pair of square brackets, like\n\n (?[ [ z ] ])\n\nAnother possibility is that you forgot a backslash.  Perl isn't smart\nenough to figure out what you really meant.\n\n=item Unexpected constant lvalue entersub entry via type/targ %d:%d\n\n(P) When compiling a subroutine call in lvalue context, Perl failed an\ninternal consistency check.  It encountered a malformed op tree.\n\n=item Unexpected exit %u\n\n(S) exit() was called or the script otherwise finished gracefully when\nC<PERL_EXIT_WARN> was set in C<PL_exit_flags>.\n\n=item Unexpected exit failure %d\n\n(S) An uncaught die() was called when C<PERL_EXIT_WARN> was set in\nC<PL_exit_flags>.\n\n=item Unexpected ')' in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ ( \\p{Digit} + ) ])\n\nThe C<\")\"> is out-of-place.  Something apparently was supposed to\nbe combined with the digits, or the C<\"+\"> shouldn't be there, or\nsomething like that.  Perl can't figure out what was intended.\n\n=item Unexpected '(' with no preceding operator in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You had something like this:\n\n (?[ \\p{Digit} ( \\p{Lao} + \\p{Thai} ) ])\n\nThere should be an operator before the C<\"(\">, as there's\nno indication as to how the digits are to be combined\nwith the characters in the Lao and Thai scripts.\n\n=item Unicode non-character U+%X is not recommended for open interchange\n\n(S nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are\ndefined by the Unicode standard to be non-characters.  Those\nare legal codepoints, but are reserved for internal use; so,\napplications shouldn't attempt to exchange them.  An application\nmay not be expecting any of these characters at all, and receiving\nthem may lead to bugs.  If you know what you are doing you can\nturn off this warning by C<no warnings 'nonchar';>.\n\nThis is not really a \"severe\" error, but it is supposed to be\nraised by default even if warnings are not enabled, and currently\nthe only way to do that in Perl is to mark it as serious.\n\n=item Unicode surrogate U+%X is illegal in UTF-8\n\n(S surrogate) You had a UTF-16 surrogate in a context where they are\nnot considered acceptable.  These code points, between U+D800 and\nU+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl\ninternally allows all unsigned integer code points (up to the size limit\navailable on your platform), including surrogates.  But these can cause\nproblems when being input or output, which is likely where this message\ncame from.  If you really really know what you are doing you can turn\noff this warning by C<no warnings 'surrogate';>.\n\n=item Unknown charname '%s'\n\n(F) The name you used inside C<\\N{}> is unknown to Perl.  Check the\nspelling.  You can say C<use charnames \":loose\"> to not have to be\nso precise about spaces, hyphens, and capitalization on standard Unicode\nnames.  (Any custom aliases that have been created must be specified\nexactly, regardless of whether C<:loose> is used or not.)  This error may\nalso happen if the C<\\N{}> is not in the scope of the corresponding\nC<S<use charnames>>.\n\n=item Unknown error\n\n(P) Perl was about to print an error message in C<$@>, but the C<$@> variable\ndid not exist, even after an attempt to create it.\n\n=item Unknown open() mode '%s'\n\n(F) The second argument of 3-argument open() is not among the list\nof valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,\nC<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.\n\n=item Unknown PerlIO layer \"%s\"\n\n(W layer) An attempt was made to push an unknown layer onto the Perl I/O\nsystem.  (Layers take care of transforming data between external and\ninternal representations.)  Note that some layers, such as C<mmap>,\nare not supported in all environments.  If your program didn't\nexplicitly request the failing operation, it may be the result of the\nvalue of the environment variable PERLIO.\n\n=item Unknown process %x sent message to prime_env_iter: %s\n\n(P) An error peculiar to VMS.  Perl was reading values for %ENV before\niterating over it, and someone else stuck a message in the stream of\ndata Perl expected.  Someone's very confused, or perhaps trying to\nsubvert Perl's population of %ENV for nefarious purposes.\n\n=item Unknown regexp modifier \"/%s\"\n\n(F) Alphanumerics immediately following the closing delimiter\nof a regular expression pattern are interpreted by Perl as modifier\nflags for the regex.  One of the ones you specified is invalid.  One way\nthis can happen is if you didn't put in white space between the end of\nthe regex and a following alphanumeric operator:\n\n if ($a =~ /foo/and $bar == 3) { ... }\n\nThe C<\"a\"> is a valid modifier flag, but the C<\"n\"> is not, and raises\nthis error.  Likely what was meant instead was:\n\n if ($a =~ /foo/ and $bar == 3) { ... }\n\n=item Unknown \"re\" subpragma '%s' (known ones are: %s)\n\n(W) You tried to use an unknown subpragma of the \"re\" pragma.\n\n=item Unknown switch condition (?(...)) in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) The condition part of a (?(condition)if-clause|else-clause) construct\nis not known.  The condition must be one of the following:\n\n (1) (2) ...        true if 1st, 2nd, etc., capture matched\n (<NAME>) ('NAME')  true if named capture matched\n (?=...) (?<=...)   true if subpattern matches\n (?!...) (?<!...)   true if subpattern fails to match\n (?{ CODE })        true if code returns a true value\n (R)                true if evaluating inside recursion\n (R1) (R2) ...      true if directly inside capture group 1, 2, etc.\n (R&NAME)           true if directly inside named capture\n (DEFINE)           always false; for defining named subpatterns\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Unknown Unicode option letter '%c'\n\n(F) You specified an unknown Unicode option.  See L<perlrun> documentation\nof the C<-C> switch for the list of known options.\n\n=item Unknown Unicode option value %d\n\n(F) You specified an unknown Unicode option.  See L<perlrun> documentation\nof the C<-C> switch for the list of known options.\n\n=item Unknown verb pattern '%s' in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You either made a typo or have incorrectly put a C<*> quantifier\nafter an open brace in your pattern.  Check the pattern and review\nL<perlre> for details on legal verb patterns.\n\n=item Unknown warnings category '%s'\n\n(F) An error issued by the C<warnings> pragma.  You specified a warnings\ncategory that is unknown to perl at this point.\n\nNote that if you want to enable a warnings category registered by a\nmodule (e.g. C<use warnings 'File::Find'>), you must have loaded this\nmodule first.\n\n=item Unmatched [ in regex; marked by S<<-- HERE> in m/%s/\n\n(F) The brackets around a character class must match.  If you wish to\ninclude a closing bracket in a character class, backslash it or put it\nfirst.  The S<<-- HERE> shows whereabouts in the regular expression the\nproblem was discovered.  See L<perlre>.\n\n=item Unmatched ( in regex; marked by S<<-- HERE> in m/%s/\n\n=item Unmatched ) in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Unbackslashed parentheses must always be balanced in regular\nexpressions.  If you're a vi user, the % key is valuable for finding\nthe matching parenthesis.  The S<<-- HERE> shows whereabouts in the\nregular expression the problem was discovered.  See L<perlre>.\n\n=item Unmatched right %s bracket\n\n(F) The lexer counted more closing curly or square brackets than opening\nones, so you're probably missing a matching opening bracket.  As a\ngeneral rule, you'll find the missing one (so to speak) near the place\nyou were last editing.\n\n=item Unquoted string \"%s\" may clash with future reserved word\n\n(W reserved) You used a bareword that might someday be claimed as a\nreserved word.  It's best to put such a word in quotes, or capitalize it\nsomehow, or insert an underbar into it.  You might also declare it as a\nsubroutine.\n\n=item Unrecognized character %s; marked by S<<-- HERE> after %s near column\n%d\n\n(F) The Perl parser has no idea what to do with the specified character\nin your Perl script (or eval) near the specified column.  Perhaps you\ntried  to run a compressed script, a binary program, or a directory as\na Perl program.\n\n=item Unrecognized escape \\%c in character class in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) You used a backslash-character combination which is not\nrecognized by Perl inside character classes.  This is a fatal\nerror when the character class is used within C<(?[ ])>.\n\n=item Unrecognized escape \\%c in character class passed through in regex; \nmarked by S<<-- HERE> in m/%s/\n\n(W regexp) You used a backslash-character combination which is not\nrecognized by Perl inside character classes.  The character was\nunderstood literally, but this may change in a future version of Perl.\nThe S<<-- HERE> shows whereabouts in the regular expression the\nescape was discovered.\n\n=item Unrecognized escape \\%c passed through\n\n(W misc) You used a backslash-character combination which is not\nrecognized by Perl.  The character was understood literally, but this may\nchange in a future version of Perl.\n\n=item Unrecognized escape \\%s passed through in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) You used a backslash-character combination which is not\nrecognized by Perl.  The character(s) were understood literally, but\nthis may change in a future version of Perl.  The S<<-- HERE> shows\nwhereabouts in the regular expression the escape was discovered.\n\n=item Unrecognized signal name \"%s\"\n\n(F) You specified a signal name to the kill() function that was not\nrecognized.  Say C<kill -l> in your shell to see the valid signal names\non your system.\n\n=item Unrecognized switch: -%s  (-h will show valid options)\n\n(F) You specified an illegal option to Perl.  Don't do that.  (If you\nthink you didn't do that, check the #! line to see if it's supplying the\nbad switch on your behalf.)\n\n=item Unsuccessful %s on filename containing newline\n\n(W newline) A file operation was attempted on a filename, and that\noperation failed, PROBABLY because the filename contained a newline,\nPROBABLY because you forgot to chomp() it off.  See L<perlfunc/chomp>.\n\n=item Unsupported directory function \"%s\" called\n\n(F) Your machine doesn't support opendir() and readdir().\n\n=item Unsupported function %s\n\n(F) This machine doesn't implement the indicated function, apparently.\nAt least, Configure doesn't think so.\n\n=item Unsupported function fork\n\n(F) Your version of executable does not support forking.\n\nNote that under some systems, like OS/2, there may be different flavors\nof Perl executables, some of which may support fork, some not.  Try\nchanging the name you call Perl by to C<perl_>, C<perl__>, and so on.\n\n=item Unsupported script encoding %s\n\n(F) Your program file begins with a Unicode Byte Order Mark (BOM) which\ndeclares it to be in a Unicode encoding that Perl cannot read.\n\n=item Unsupported socket function \"%s\" called\n\n(F) Your machine doesn't support the Berkeley socket mechanism, or at\nleast that's what Configure thought.\n\n=item Unterminated attribute list\n\n(F) The lexer found something other than a simple identifier at the\nstart of an attribute, and it wasn't a semicolon or the start of a\nblock.  Perhaps you terminated the parameter list of the previous\nattribute too soon.  See L<attributes>.\n\n=item Unterminated attribute parameter in attribute list\n\n(F) The lexer saw an opening (left) parenthesis character while parsing\nan attribute list, but the matching closing (right) parenthesis\ncharacter was not found.  You may need to add (or remove) a backslash\ncharacter to get your parentheses to balance.  See L<attributes>.\n\n=item Unterminated compressed integer\n\n(F) An argument to unpack(\"w\",...) was incompatible with the BER\ncompressed integer format and could not be converted to an integer.\nSee L<perlfunc/pack>.\n\n=item Unterminated delimiter for here document\n\n(F) This message occurs when a here document label has an initial\nquotation mark but the final quotation mark is missing.  Perhaps\nyou wrote:\n\n    <<\"foo\n\ninstead of:\n\n    <<\"foo\"\n\n=item Unterminated \\g... pattern in regex; marked by S<<-- HERE> in m/%s/\n\n=item Unterminated \\g{...} pattern in regex; marked by S<<-- HERE> in m/%s/\n\n(F) In a regular expression, you had a C<\\g> that wasn't followed by a\nproper group reference.  In the case of C<\\g{>, the closing brace is\nmissing; otherwise the C<\\g> must be followed by an integer.  Fix the\npattern and retry.\n\n=item Unterminated <> operator\n\n(F) The lexer saw a left angle bracket in a place where it was expecting\na term, so it's looking for the corresponding right angle bracket, and\nnot finding it.  Chances are you left some needed parentheses out\nearlier in the line, and you really meant a \"less than\".\n\n=item Unterminated verb pattern argument in regex; marked by S<<-- HERE> in\nm/%s/\n\n(F) You used a pattern of the form C<(*VERB:ARG)> but did not terminate\nthe pattern with a C<)>.  Fix the pattern and retry.\n\n=item Unterminated verb pattern in regex; marked by S<<-- HERE> in m/%s/\n\n(F) You used a pattern of the form C<(*VERB)> but did not terminate\nthe pattern with a C<)>.  Fix the pattern and retry.\n\n=item untie attempted while %d inner references still exist\n\n(W untie) A copy of the object returned from C<tie> (or C<tied>) was\nstill valid when C<untie> was called.\n\n=item Usage: POSIX::%s(%s)\n\n(F) You called a POSIX function with incorrect arguments.\nSee L<POSIX/FUNCTIONS> for more information.\n\n=item Usage: Win32::%s(%s)\n\n(F) You called a Win32 function with incorrect arguments.\nSee L<Win32> for more information.\n\n=item $[ used in %s (did you mean $] ?)\n\n(W syntax) You used C<$[> in a comparison, such as:\n\n    if ($[ > 5.006) {\n\t...\n    }\n\nYou probably meant to use C<$]> instead.  C<$[> is the base for indexing\narrays.  C<$]> is the Perl version number in decimal.\n\n=item Use \"%s\" instead of \"%s\"\n\n(F) The second listed construct is no longer legal.  Use the first one\ninstead.\n\n=item Useless assignment to a temporary\n\n(W misc) You assigned to an lvalue subroutine, but what\nthe subroutine returned was a temporary scalar about to\nbe discarded, so the assignment had no effect.\n\n=item Useless (?-%s) - don't use /%s modifier in regex; marked by\nS<<-- HERE> in m/%s/\n\n(W regexp) You have used an internal modifier such as (?-o) that has no\nmeaning unless removed from the entire regexp:\n\n    if ($string =~ /(?-o)$pattern/o) { ... }\n\nmust be written as\n\n    if ($string =~ /$pattern/) { ... }\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Useless localization of %s\n\n(W syntax) The localization of lvalues such as C<local($x=10)> is legal,\nbut in fact the local() currently has no effect.  This may change at\nsome point in the future, but in the meantime such code is discouraged.\n\n=item Useless (?%s) - use /%s modifier in regex; marked by S<<-- HERE> in\nm/%s/\n\n(W regexp) You have used an internal modifier such as (?o) that has no\nmeaning unless applied to the entire regexp:\n\n    if ($string =~ /(?o)$pattern/) { ... }\n\nmust be written as\n\n    if ($string =~ /$pattern/o) { ... }\n\nThe S<<-- HERE> shows whereabouts in the regular expression the problem was\ndiscovered.  See L<perlre>.\n\n=item Useless use of attribute \"const\"\n\n(W misc) The C<const> attribute has no effect except\non anonymous closure prototypes.  You applied it to\na subroutine via L<attributes.pm|attributes>.  This is only useful\ninside an attribute handler for an anonymous subroutine.\n\n=item Useless use of /d modifier in transliteration operator\n\n(W misc) You have used the /d modifier where the searchlist has the\nsame length as the replacelist.  See L<perlop> for more information\nabout the /d modifier.\n\n=item Useless use of \\E\n\n(W misc) You have a \\E in a double-quotish string without a C<\\U>,\nC<\\L> or C<\\Q> preceding it.\n\n=item Useless use of greediness modifier '%c' in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) You specified something like these:\n\n qr/a{3}?/\n qr/b{1,1}+/\n\nThe C<\"?\"> and C<\"+\"> don't have any effect, as they modify whether to\nmatch more or fewer when there is a choice, and by specifying to match\nexactly a given numer, there is no room left for a choice.\n\n=item Useless use of %s in void context\n\n(W void) You did something without a side effect in a context that does\nnothing with the return value, such as a statement that doesn't return a\nvalue from a block, or the left side of a scalar comma operator.  Very\noften this points not to stupidity on your part, but a failure of Perl\nto parse your program the way you thought it would.  For example, you'd\nget this if you mixed up your C precedence with Python precedence and\nsaid\n\n    $one, $two = 1, 2;\n\nwhen you meant to say\n\n    ($one, $two) = (1, 2);\n\nAnother common error is to use ordinary parentheses to construct a list\nreference when you should be using square or curly brackets, for\nexample, if you say\n\n    $array = (1,2);\n\nwhen you should have said\n\n    $array = [1,2];\n\nThe square brackets explicitly turn a list value into a scalar value,\nwhile parentheses do not.  So when a parenthesized list is evaluated in\na scalar context, the comma is treated like C's comma operator, which\nthrows away the left argument, which is not what you want.  See\nL<perlref> for more on this.\n\nThis warning will not be issued for numerical constants equal to 0 or 1\nsince they are often used in statements like\n\n    1 while sub_with_side_effects();\n\nString constants that would normally evaluate to 0 or 1 are warned\nabout.\n\n=item Useless use of (?-p) in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) The C<p> modifier cannot be turned off once set.  Trying to do\nso is futile.\n\n=item Useless use of \"re\" pragma\n\n(W) You did C<use re;> without any arguments.  That isn't very useful.\n\n=item Useless use of sort in scalar context\n\n(W void) You used sort in scalar context, as in :\n\n    my $x = sort @y;\n\nThis is not very useful, and perl currently optimizes this away.\n\n=item Useless use of %s with no values\n\n(W syntax) You used the push() or unshift() function with no arguments\napart from the array, like C<push(@x)> or C<unshift(@foo)>.  That won't\nusually have any effect on the array, so is completely useless.  It's\npossible in principle that push(@tied_array) could have some effect\nif the array is tied to a class which implements a PUSH method.  If so,\nyou can write it as C<push(@tied_array,())> to avoid this warning.\n\n=item \"use\" not allowed in expression\n\n(F) The \"use\" keyword is recognized and executed at compile time, and\nreturns no useful value.  See L<perlmod>.\n\n=item Use of assignment to $[ is deprecated, and will be fatal in 5.30\n\n(D deprecated) The C<$[> variable (index of the first element in an array)\nis deprecated since Perl 5.12, and setting it to a non-zero value will be\nfatal as of Perl 5.30.\nSee L<perlvar/\"$[\">.\n\n=item Use of bare << to mean <<\"\" is forbidden\n\n(F) You are now required to use the explicitly quoted form if you wish\nto use an empty line as the terminator of the here-document.\n\nUse of a bare terminator was deprecated in Perl 5.000, and is a fatal\nerror as of Perl 5.28.\n\n=item Use of /c modifier is meaningless in s///\n\n(W regexp) You used the /c modifier in a substitution.  The /c\nmodifier is not presently meaningful in substitutions.\n\n=item Use of /c modifier is meaningless without /g\n\n(W regexp) You used the /c modifier with a regex operand, but didn't\nuse the /g modifier.  Currently, /c is meaningful only when /g is\nused.  (This may change in the future.)\n\n=item Use of code point 0x%s is not allowed; the permissible max is 0x%s.\n\n(F) You used a code point that is not allowed, because it is too large.\nUnicode only allows code points up to 0x10FFFF, but Perl allows much\nlarger ones. Earlier versions of Perl allowed code points above IV_MAX\n(0x7FFFFFF on 32-bit platforms, 0x7FFFFFFFFFFFFFFF on 64-bit platforms),\nhowever, this could possibly break the perl interpreter in some constructs,\nincluding causing it to hang in a few cases.\n\nIf your code is to run on various platforms, keep in mind that the upper\nlimit depends on the platform.  It is much larger on 64-bit word sizes\nthan 32-bit ones.\n\nThe use of out of range code points was deprecated in Perl 5.24, and\nbecame a fatal error in Perl 5.28.\n\n=item Use of each() on hash after insertion without resetting hash iterator results in undefined behavior\n\n(S internal) The behavior of C<each()> after insertion is undefined;\nit may skip items, or visit items more than once.  Consider using\nC<keys()> instead of C<each()>.\n\n=item Use of := for an empty attribute list is not allowed\n\n(F) The construction C<my $x := 42> used to parse as equivalent to\nC<my $x : = 42> (applying an empty attribute list to C<$x>).\nThis construct was deprecated in 5.12.0, and has now been made a syntax\nerror, so C<:=> can be reclaimed as a new operator in the future.\n\nIf you need an empty attribute list, for example in a code generator, add\na space before the C<=>.\n\n=item Use of %s for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale\n\n(W locale)  You are matching a regular expression using locale rules,\nand the specified construct was encountered.  This construct is only\nvalid for UTF-8 locales, which the current locale isn't.  This doesn't\nmake sense.  Perl will continue, assuming a Unicode (UTF-8) locale, but\nthe results are likely to be wrong.\n\n=item Use of freed value in iteration\n\n(F) Perhaps you modified the iterated array within the loop?\nThis error is typically caused by code like the following:\n\n    @a = (3,4);\n    @a = () for (1,2,@a);\n\nYou are not supposed to modify arrays while they are being iterated over.\nFor speed and efficiency reasons, Perl internally does not do full\nreference-counting of iterated items, hence deleting such an item in the\nmiddle of an iteration causes Perl to see a freed value.\n\n=item Use of /g modifier is meaningless in split\n\n(W regexp) You used the /g modifier on the pattern for a C<split>\noperator.  Since C<split> always tries to match the pattern\nrepeatedly, the C</g> has no effect.\n\n=item Use of \"goto\" to jump into a construct is deprecated\n\n(D deprecated) Using C<goto> to jump from an outer scope into an inner\nscope is deprecated and should be avoided.\n\nThis was deprecated in Perl 5.12.\n\n=item Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed\n\n(F) As an accidental feature, C<AUTOLOAD> subroutines were looked up as\nmethods (using the C<@ISA> hierarchy), even when the subroutines to be\nautoloaded were called as plain functions (e.g. C<Foo::bar()>), not as\nmethods (e.g. C<< Foo->bar() >> or C<< $obj->bar() >>).\n\nThis was deprecated in Perl 5.004, and was made fatal in Perl 5.28.\n\n=item Use of %s in printf format not supported\n\n(F) You attempted to use a feature of printf that is accessible from\nonly C.  This usually means there's a better way to do it in Perl.\n\n=item Use of -l on filehandle%s\n\n(W io) A filehandle represents an opened file, and when you opened the file\nit already went past any symlink you are presumably trying to look for.\nThe operation returned C<undef>.  Use a filename instead.\n\n=item Use of reference \"%s\" as array index\n\n(W misc) You tried to use a reference as an array index; this probably\nisn't what you mean, because references in numerical context tend\nto be huge numbers, and so usually indicates programmer error.\n\nIf you really do mean it, explicitly numify your reference, like so:\nC<$array[0+$ref]>.  This warning is not given for overloaded objects,\nhowever, because you can overload the numification and stringification\noperators and then you presumably know what you are doing.\n\n=item Use of strings with code points over 0xFF as arguments to %s\noperator is not allowed\n\n(F) You tried to use one of the string bitwise operators (C<&> or C<|> or C<^> or\nC<~>) on a string containing a code point over 0xFF.  The string bitwise\noperators treat their operands as strings of bytes, and values beyond\n0xFF are nonsensical in this context.\n\nThis became fatal in Perl 5.28.\n\n=item Use of strings with code points over 0xFF as arguments to C<vec>\nis deprecated. This will be a fatal error in Perl 5.32\n\n(D deprecated) You tried to use L<C<vec>|perlfunc/vec EXPR,OFFSET,BITS>\non a string containing a code point over 0xFF, which is nonsensical here.\n\nSuch usage will be a fatal error in Perl 5.32.\n\n=item Use of tainted arguments in %s is deprecated\n\n(W taint, deprecated) You have supplied C<system()> or C<exec()> with multiple\narguments and at least one of them is tainted.  This used to be allowed\nbut will become a fatal error in a future version of perl.  Untaint your\narguments.  See L<perlsec>.\n\n=item Use of unassigned code point or non-standalone grapheme for a\ndelimiter will be a fatal error starting in Perl 5.30\n\n(D deprecated)\nA grapheme is what appears to a native-speaker of a language to be a\ncharacter.  In Unicode (and hence Perl) a grapheme may actually be\nseveral adjacent characters that together form a complete grapheme.  For\nexample, there can be a base character, like \"R\" and an accent, like a\ncircumflex \"^\", that appear when displayed to be a single character with\nthe circumflex hovering over the \"R\".  Perl currently allows things like\nthat circumflex to be delimiters of strings, patterns, I<etc>.  When\ndisplayed, the circumflex would look like it belongs to the character\njust to the left of it.  In order to move the language to be able to\naccept graphemes as delimiters, we have to deprecate the use of\ndelimiters which aren't graphemes by themselves.  Also, a delimiter must\nalready be assigned (or known to be never going to be assigned) to try\nto future-proof code, for otherwise code that works today would fail to\ncompile if the currently unassigned delimiter ends up being something\nthat isn't a stand-alone grapheme.  Because Unicode is never going to\nassign\nL<non-character code points|perlunicode/Noncharacter code points>, nor\nL<code points that are above the legal Unicode maximum|\nperlunicode/Beyond Unicode code points>, those can be delimiters, and\ntheir use won't raise this warning.\n\n=item Use of uninitialized value%s\n\n(W uninitialized) An undefined value was used as if it were already\ndefined.  It was interpreted as a \"\" or a 0, but maybe it was a mistake.\nTo suppress this warning assign a defined value to your variables.\n\nTo help you figure out what was undefined, perl will try to tell you\nthe name of the variable (if any) that was undefined.  In some cases\nit cannot do this, so it also tells you what operation you used the\nundefined value in.  Note, however, that perl optimizes your program\nand the operation displayed in the warning may not necessarily appear\nliterally in your program.  For example, C<\"that $foo\"> is usually\noptimized into C<\"that \" . $foo>, and the warning will refer to the\nC<concatenation (.)> operator, even though there is no C<.> in\nyour program.\n\n=item \"use re 'strict'\" is experimental\n\n(S experimental::re_strict) The things that are different when a regular\nexpression pattern is compiled under C<'strict'> are subject to change\nin future Perl releases in incompatible ways.  This means that a pattern\nthat compiles today may not in a future Perl release.  This warning is\nto alert you to that risk.\n\n=item Use \\x{...} for more than two hex characters in regex; marked by\nS<<-- HERE> in m/%s/\n\n(F) In a regular expression, you said something like\n\n (?[ [ \\xBEEF ] ])\n\nPerl isn't sure if you meant this\n\n (?[ [ \\x{BEEF} ] ])\n\nor if you meant this\n\n (?[ [ \\x{BE} E F ] ])\n\nYou need to add either braces or blanks to disambiguate.\n\n=item Using just the first character returned by \\N{} in character class in \nregex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) Named Unicode character escapes C<(\\N{...})> may return\na multi-character sequence.  Even though a character class is\nsupposed to match just one character of input, perl will match\nthe whole thing correctly, except when the class is inverted\n(C<[^...]>), or the escape is the beginning or final end point of\na range.  For these, what should happen isn't clear at all.  In\nthese circumstances, Perl discards all but the first character\nof the returned sequence, which is not likely what you want.\n\n=item Using /u for '%s' instead of /%s in regex; marked by S<<-- HERE> in m/%s/\n\n(W regexp) You used a Unicode boundary (C<\\b{...}> or C<\\B{...}>) in a\nportion of a regular expression where the character set modifiers C</a>\nor C</aa> are in effect.  These two modifiers indicate an ASCII\ninterpretation, and this doesn't make sense for a Unicode defintion.\nThe generated regular expression will compile so that the boundary uses\nall of Unicode.  No other portion of the regular expression is affected.\n\n=item Using !~ with %s doesn't make sense\n\n(F) Using the C<!~> operator with C<s///r>, C<tr///r> or C<y///r> is\ncurrently reserved for future use, as the exact behavior has not\nbeen decided.  (Simply returning the boolean opposite of the\nmodified string is usually not particularly useful.)\n\n=item UTF-16 surrogate U+%X\n\n(S surrogate) You had a UTF-16 surrogate in a context where they are\nnot considered acceptable.  These code points, between U+D800 and\nU+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl\ninternally allows all unsigned integer code points (up to the size limit\navailable on your platform), including surrogates.  But these can cause\nproblems when being input or output, which is likely where this message\ncame from.  If you really really know what you are doing you can turn\noff this warning by C<no warnings 'surrogate';>.\n\n=item Value of %s can be \"0\"; test with defined()\n\n(W misc) In a conditional expression, you used <HANDLE>, <*> (glob),\nC<each()>, or C<readdir()> as a boolean value.  Each of these constructs\ncan return a value of \"0\"; that would make the conditional expression\nfalse, which is probably not what you intended.  When using these\nconstructs in conditional expressions, test their values with the\nC<defined> operator.\n\n=item Value of CLI symbol \"%s\" too long\n\n(W misc) A warning peculiar to VMS.  Perl tried to read the value of an\n%ENV element from a CLI symbol table, and found a resultant string\nlonger than 1024 characters.  The return value has been truncated to\n1024 characters.\n\n=item Variable \"%s\" is not available\n\n(W closure) During compilation, an inner named subroutine or eval is\nattempting to capture an outer lexical that is not currently available.\nThis can happen for one of two reasons.  First, the outer lexical may be\ndeclared in an outer anonymous subroutine that has not yet been created.\n(Remember that named subs are created at compile time, while anonymous\nsubs are created at run-time.)  For example,\n\n    sub { my $a; sub f { $a } }\n\nAt the time that f is created, it can't capture the current value of $a,\nsince the anonymous subroutine hasn't been created yet.  Conversely,\nthe following won't give a warning since the anonymous subroutine has by\nnow been created and is live:\n\n    sub { my $a; eval 'sub f { $a }' }->();\n\nThe second situation is caused by an eval accessing a variable that has\ngone out of scope, for example,\n\n    sub f {\n\tmy $a;\n\tsub { eval '$a' }\n    }\n    f()->();\n\nHere, when the '$a' in the eval is being compiled, f() is not currently\nbeing executed, so its $a is not available for capture.\n\n=item Variable \"%s\" is not imported%s\n\n(S misc) With \"use strict\" in effect, you referred to a global variable\nthat you apparently thought was imported from another module, because\nsomething else of the same name (usually a subroutine) is exported by\nthat module.  It usually means you put the wrong funny character on the\nfront of your variable.\n\n=item Variable length lookbehind not implemented in regex m/%s/\n\n(F) Lookbehind is allowed only for subexpressions whose length is fixed and\nknown at compile time.  For positive lookbehind, you can use the C<\\K>\nregex construct as a way to get the equivalent functionality.  See\nL<(?<=pattern) and \\K in perlre|perlre/\\K>.\n\nStarting in Perl 5.18, there are non-obvious Unicode rules under C</i>\nthat can match variably, but which you might not think could.  For\nexample, the substring C<\"ss\"> can match the single character LATIN\nSMALL LETTER SHARP S.  Here's a complete list of the current ones\naffecting ASCII characters:\n\n   ASCII\n  sequence      Matches single letter under /i\n    FF          U+FB00 LATIN SMALL LIGATURE FF\n    FFI         U+FB03 LATIN SMALL LIGATURE FFI\n    FFL         U+FB04 LATIN SMALL LIGATURE FFL\n    FI          U+FB01 LATIN SMALL LIGATURE FI\n    FL          U+FB02 LATIN SMALL LIGATURE FL\n    SS          U+00DF LATIN SMALL LETTER SHARP S\n                U+1E9E LATIN CAPITAL LETTER SHARP S\n    ST          U+FB06 LATIN SMALL LIGATURE ST\n                U+FB05 LATIN SMALL LIGATURE LONG S T\n\nThis list is subject to change, but is quite unlikely to.\nEach ASCII sequence can be any combination of upper- and lowercase.\n\nYou can avoid this by using a bracketed character class in the\nlookbehind assertion, like\n\n (?<![sS]t)\n (?<![fF]f[iI])\n\nThis fools Perl into not matching the ligatures.\n\nAnother option for Perls starting with 5.16, if you only care about\nASCII matches, is to add the C</aa> modifier to the regex.  This will\nexclude all these non-obvious matches, thus getting rid of this message.\nYou can also say\n\n use if $] ge 5.016, re => '/aa';\n\nto apply C</aa> to all regular expressions compiled within its scope.\nSee L<re>.\n\n=item \"%s\" variable %s masks earlier declaration in same %s\n\n(W shadow) A \"my\", \"our\" or \"state\" variable has been redeclared in the\ncurrent scope or statement, effectively eliminating all access to the\nprevious instance.  This is almost always a typographical error.  Note\nthat the earlier variable will still exist until the end of the scope\nor until all closure references to it are destroyed.\n\n=item Variable syntax\n\n(A) You've accidentally run your script through B<csh> instead\nof Perl.  Check the #! line, or manually feed your script into\nPerl yourself.\n\n=item Variable \"%s\" will not stay shared\n\n(W closure) An inner (nested) I<named> subroutine is referencing a\nlexical variable defined in an outer named subroutine.\n\nWhen the inner subroutine is called, it will see the value of\nthe outer subroutine's variable as it was before and during the *first*\ncall to the outer subroutine; in this case, after the first call to the\nouter subroutine is complete, the inner and outer subroutines will no\nlonger share a common value for the variable.  In other words, the\nvariable will no longer be shared.\n\nThis problem can usually be solved by making the inner subroutine\nanonymous, using the C<sub {}> syntax.  When inner anonymous subs that\nreference variables in outer subroutines are created, they\nare automatically rebound to the current values of such variables.\n\n=item vector argument not supported with alpha versions\n\n(S printf) The %vd (s)printf format does not support version objects\nwith alpha parts.\n\n=item Verb pattern '%s' has a mandatory argument in regex; marked by\nS<<-- HERE> in m/%s/ \n\n(F) You used a verb pattern that requires an argument.  Supply an\nargument or check that you are using the right verb.\n\n=item Verb pattern '%s' may not have an argument in regex; marked by\nS<<-- HERE> in m/%s/ \n\n(F) You used a verb pattern that is not allowed an argument.  Remove the \nargument or check that you are using the right verb.\n\n=item Version control conflict marker\n\n(F) The parser found a line starting with C<E<lt><<<<<<>,\nC<E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>>, or C<=======>.  These may be left by a\nversion control system to mark conflicts after a failed merge operation.\n\n=item Version number must be a constant number\n\n(P) The attempt to translate a C<use Module n.n LIST> statement into\nits equivalent C<BEGIN> block found an internal inconsistency with\nthe version number.\n\n=item Version string '%s' contains invalid data; ignoring: '%s'\n\n(W misc) The version string contains invalid characters at the end, which\nare being ignored.\n\n=item Warning: something's wrong\n\n(W) You passed warn() an empty string (the equivalent of C<warn \"\">) or\nyou called it with no args and C<$@> was empty.\n\n=item Warning: unable to close filehandle %s properly\n\n(S) The implicit close() done by an open() got an error indication on\nthe close().  This usually indicates your file system ran out of disk\nspace.\n\n=item Warning: unable to close filehandle properly: %s\n\n=item Warning: unable to close filehandle %s properly: %s\n\n(S io) There were errors during the implicit close() done on a filehandle\nwhen its reference count reached zero while it was still open, e.g.:\n\n    {\n        open my $fh, '>', $file  or die \"open: '$file': $!\\n\";\n        print $fh $data or die \"print: $!\";\n    } # implicit close here\n\nBecause various errors may only be detected by close() (e.g. buffering could\nallow the C<print> in this example to return true even when the disk is full),\nit is dangerous to ignore its result.  So when it happens implicitly, perl\nwill signal errors by warning.\n\nB<Prior to version 5.22.0, perl ignored such errors>, so the common idiom shown\nabove was liable to cause B<silent data loss>.\n\n=item Warning: Use of \"%s\" without parentheses is ambiguous\n\n(S ambiguous) You wrote a unary operator followed by something that\nlooks like a binary operator that could also have been interpreted as a\nterm or unary operator.  For instance, if you know that the rand\nfunction has a default argument of 1.0, and you write\n\n    rand + 5;\n\nyou may THINK you wrote the same thing as\n\n    rand() + 5;\n\nbut in actual fact, you got\n\n    rand(+5);\n\nSo put in parentheses to say what you really mean.\n\n=item when is experimental\n\n(S experimental::smartmatch) C<when> depends on smartmatch, which is\nexperimental.  Additionally, it has several special cases that may\nnot be immediately obvious, and their behavior may change or\neven be removed in any future release of perl.  See the explanation\nunder L<perlsyn/Experimental Details on given and when>.\n\n=item Wide character in %s\n\n(S utf8) Perl met a wide character (>255) when it wasn't expecting\none.  This warning is by default on for I/O (like print).  The easiest\nway to quiet this warning is simply to add the C<:utf8> layer to the\noutput, e.g. C<binmode STDOUT, ':utf8'>.  Another way to turn off the\nwarning is to add C<no warnings 'utf8';> but that is often closer to\ncheating.  In general, you are supposed to explicitly mark the\nfilehandle with an encoding, see L<open> and L<perlfunc/binmode>.\n\n=item Wide character (U+%X) in %s\n\n(W locale) While in a single-byte locale (I<i.e.>, a non-UTF-8\none), a multi-byte character was encountered.   Perl considers this\ncharacter to be the specified Unicode code point.  Combining non-UTF-8\nlocales and Unicode is dangerous.  Almost certainly some characters\nwill have two different representations.  For example, in the ISO 8859-7\n(Greek) locale, the code point 0xC3 represents a Capital Gamma.  But so\nalso does 0x393.  This will make string comparisons unreliable.\n\nYou likely need to figure out how this multi-byte character got mixed up\nwith your single-byte locale (or perhaps you thought you had a UTF-8\nlocale, but Perl disagrees).\n\n=item Within []-length '%c' not allowed\n\n(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]>\nonly if C<TEMPLATE> always matches the same amount of packed bytes that\ncan be determined from the template alone.  This is not possible if\nit contains any of the codes @, /, U, u, w or a *-length.  Redesign\nthe template.\n\n=item %s() with negative argument\n\n(S misc) Certain operations make no sense with negative arguments.\nWarning is given and the operation is not done.\n\n=item write() on closed filehandle %s\n\n(W closed) The filehandle you're writing to got itself closed sometime\nbefore now.  Check your control flow.\n\n=item %s \"\\x%X\" does not map to Unicode\n\n(S utf8) When reading in different encodings, Perl tries to\nmap everything into Unicode characters.  The bytes you read\nin are not legal in this encoding.  For example\n\n    utf8 \"\\xE4\" does not map to Unicode\n\nif you try to read in the a-diaereses Latin-1 as UTF-8.\n\n=item 'X' outside of string\n\n(F) You had a (un)pack template that specified a relative position before\nthe beginning of the string being (un)packed.  See L<perlfunc/pack>.\n\n=item 'x' outside of string in unpack\n\n(F) You had a pack template that specified a relative position after\nthe end of the string being unpacked.  See L<perlfunc/pack>.\n\n=item YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\n(F) And you probably never will, because you probably don't have the\nsources to your kernel, and your vendor probably doesn't give a rip\nabout what you want.  Your best bet is to put a setuid C wrapper around\nyour script.\n\n=item You need to quote \"%s\"\n\n(W syntax) You assigned a bareword as a signal handler name.\nUnfortunately, you already have a subroutine of that name declared,\nwhich means that Perl 5 will try to call the subroutine when the\nassignment is executed, which is probably not what you want.  (If it IS\nwhat you want, put an & in front.)\n\n=item Your random numbers are not that random\n\n(F) When trying to initialize the random seed for hashes, Perl could\nnot get any randomness out of your system.  This usually indicates\nSomething Very Wrong.\n\n=item Zero length \\N{} in regex; marked by S<<-- HERE> in m/%s/\n\n(F) Named Unicode character escapes (C<\\N{...}>) may return a zero-length\nsequence.  Such an escape was used in an extended character class, i.e.\nC<(?[...])>, or under C<use re 'strict'>, which is not permitted.  Check\nthat the correct escape has been used, and the correct charnames handler\nis in scope.  The S<<-- HERE> shows whereabouts in the regular\nexpression the problem was discovered.\n\n=back\n\n=head1 SEE ALSO\n\nL<warnings>, L<diagnostics>.\n\n=cut\n", "=head1 NAME\nX<character class>\n\nperlrecharclass - Perl Regular Expression Character Classes\n\n=head1 DESCRIPTION\n\nThe top level documentation about Perl regular expressions\nis found in L<perlre>.\n\nThis manual page discusses the syntax and use of character\nclasses in Perl regular expressions.\n\nA character class is a way of denoting a set of characters\nin such a way that one character of the set is matched.\nIt's important to remember that: matching a character class\nconsumes exactly one character in the source string. (The source\nstring is the string the regular expression is matched against.)\n\nThere are three types of character classes in Perl regular\nexpressions: the dot, backslash sequences, and the form enclosed in square\nbrackets.  Keep in mind, though, that often the term \"character class\" is used\nto mean just the bracketed form.  Certainly, most Perl documentation does that.\n\n=head2 The dot\n\nThe dot (or period), C<.> is probably the most used, and certainly\nthe most well-known character class. By default, a dot matches any\ncharacter, except for the newline. That default can be changed to\nadd matching the newline by using the I<single line> modifier:\nfor the entire regular expression with the C</s> modifier, or\nlocally with C<(?s)>  (and even globally within the scope of\nL<C<use re '/s'>|re/'E<sol>flags' mode>).  (The C<L</\\N>> backslash\nsequence, described\nbelow, matches any character except newline without regard to the\nI<single line> modifier.)\n\nHere are some examples:\n\n \"a\"  =~  /./       # Match\n \".\"  =~  /./       # Match\n \"\"   =~  /./       # No match (dot has to match a character)\n \"\\n\" =~  /./       # No match (dot does not match a newline)\n \"\\n\" =~  /./s      # Match (global 'single line' modifier)\n \"\\n\" =~  /(?s:.)/  # Match (local 'single line' modifier)\n \"ab\" =~  /^.$/     # No match (dot matches one character)\n\n=head2 Backslash sequences\nX<\\w> X<\\W> X<\\s> X<\\S> X<\\d> X<\\D> X<\\p> X<\\P>\nX<\\N> X<\\v> X<\\V> X<\\h> X<\\H>\nX<word> X<whitespace>\n\nA backslash sequence is a sequence of characters, the first one of which is a\nbackslash.  Perl ascribes special meaning to many such sequences, and some of\nthese are character classes.  That is, they match a single character each,\nprovided that the character belongs to the specific set of characters defined\nby the sequence.\n\nHere's a list of the backslash sequences that are character classes.  They\nare discussed in more detail below.  (For the backslash sequences that aren't\ncharacter classes, see L<perlrebackslash>.)\n\n \\d             Match a decimal digit character.\n \\D             Match a non-decimal-digit character.\n \\w             Match a \"word\" character.\n \\W             Match a non-\"word\" character.\n \\s             Match a whitespace character.\n \\S             Match a non-whitespace character.\n \\h             Match a horizontal whitespace character.\n \\H             Match a character that isn't horizontal whitespace.\n \\v             Match a vertical whitespace character.\n \\V             Match a character that isn't vertical whitespace.\n \\N             Match a character that isn't a newline.\n \\pP, \\p{Prop}  Match a character that has the given Unicode property.\n \\PP, \\P{Prop}  Match a character that doesn't have the Unicode property\n\n=head3 \\N\n\nC<\\N>, available starting in v5.12, like the dot, matches any\ncharacter that is not a newline. The difference is that C<\\N> is not influenced\nby the I<single line> regular expression modifier (see L</The dot> above).  Note\nthat the form C<\\N{...}> may mean something completely different.  When the\nC<{...}> is a L<quantifier|perlre/Quantifiers>, it means to match a non-newline\ncharacter that many times.  For example, C<\\N{3}> means to match 3\nnon-newlines; C<\\N{5,}> means to match 5 or more non-newlines.  But if C<{...}>\nis not a legal quantifier, it is presumed to be a named character.  See\nL<charnames> for those.  For example, none of C<\\N{COLON}>, C<\\N{4F}>, and\nC<\\N{F4}> contain legal quantifiers, so Perl will try to find characters whose\nnames are respectively C<COLON>, C<4F>, and C<F4>.\n\n=head3 Digits\n\nC<\\d> matches a single character considered to be a decimal I<digit>.\nIf the C</a> regular expression modifier is in effect, it matches [0-9].\nOtherwise, it\nmatches anything that is matched by C<\\p{Digit}>, which includes [0-9].\n(An unlikely possible exception is that under locale matching rules, the\ncurrent locale might not have C<[0-9]> matched by C<\\d>, and/or might match\nother characters whose code point is less than 256.  The only such locale\ndefinitions that are legal would be to match C<[0-9]> plus another set of\n10 consecutive digit characters;  anything else would be in violation of\nthe C language standard, but Perl doesn't currently assume anything in\nregard to this.)\n\nWhat this means is that unless the C</a> modifier is in effect C<\\d> not\nonly matches the digits '0' - '9', but also Arabic, Devanagari, and\ndigits from other languages.  This may cause some confusion, and some\nsecurity issues.\n\nSome digits that C<\\d> matches look like some of the [0-9] ones, but\nhave different values.  For example, BENGALI DIGIT FOUR (U+09EA) looks\nvery much like an ASCII DIGIT EIGHT (U+0038).  An application that\nis expecting only the ASCII digits might be misled, or if the match is\nC<\\d+>, the matched string might contain a mixture of digits from\ndifferent writing systems that look like they signify a number different\nthan they actually do.  L<Unicode::UCD/num()> can\nbe used to safely\ncalculate the value, returning C<undef> if the input string contains\nsuch a mixture.\n\nWhat C<\\p{Digit}> means (and hence C<\\d> except under the C</a>\nmodifier) is C<\\p{General_Category=Decimal_Number}>, or synonymously,\nC<\\p{General_Category=Digit}>.  Starting with Unicode version 4.1, this\nis the same set of characters matched by C<\\p{Numeric_Type=Decimal}>.\nBut Unicode also has a different property with a similar name,\nC<\\p{Numeric_Type=Digit}>, which matches a completely different set of\ncharacters.  These characters are things such as C<CIRCLED DIGIT ONE>\nor subscripts, or are from writing systems that lack all ten digits.\n\nThe design intent is for C<\\d> to exactly match the set of characters\nthat can safely be used with \"normal\" big-endian positional decimal\nsyntax, where, for example 123 means one 'hundred', plus two 'tens',\nplus three 'ones'.  This positional notation does not necessarily apply\nto characters that match the other type of \"digit\",\nC<\\p{Numeric_Type=Digit}>, and so C<\\d> doesn't match them.\n\nThe Tamil digits (U+0BE6 - U+0BEF) can also legally be\nused in old-style Tamil numbers in which they would appear no more than\none in a row, separated by characters that mean \"times 10\", \"times 100\",\netc.  (See L<http://www.unicode.org/notes/tn21>.)\n\nAny character not matched by C<\\d> is matched by C<\\D>.\n\n=head3 Word characters\n\nA C<\\w> matches a single alphanumeric character (an alphabetic character, or a\ndecimal digit); or a connecting punctuation character, such as an\nunderscore (\"_\"); or a \"mark\" character (like some sort of accent) that\nattaches to one of those.  It does not match a whole word.  To match a\nwhole word, use C<\\w+>.  This isn't the same thing as matching an\nEnglish word, but in the ASCII range it is the same as a string of\nPerl-identifier characters.\n\n=over\n\n=item If the C</a> modifier is in effect ...\n\nC<\\w> matches the 63 characters [a-zA-Z0-9_].\n\n=item otherwise ...\n\n=over\n\n=item For code points above 255 ...\n\nC<\\w> matches the same as C<\\p{Word}> matches in this range.  That is,\nit matches Thai letters, Greek letters, etc.  This includes connector\npunctuation (like the underscore) which connect two words together, or\ndiacritics, such as a C<COMBINING TILDE> and the modifier letters, which\nare generally used to add auxiliary markings to letters.\n\n=item For code points below 256 ...\n\n=over\n\n=item if locale rules are in effect ...\n\nC<\\w> matches the platform's native underscore character plus whatever\nthe locale considers to be alphanumeric.\n\n=item if, instead, Unicode rules are in effect ...\n\nC<\\w> matches exactly what C<\\p{Word}> matches.\n\n=item otherwise ...\n\nC<\\w> matches [a-zA-Z0-9_].\n\n=back\n\n=back\n\n=back\n\nWhich rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.\n\nThere are a number of security issues with the full Unicode list of word\ncharacters.  See L<http://unicode.org/reports/tr36>.\n\nAlso, for a somewhat finer-grained set of characters that are in programming\nlanguage identifiers beyond the ASCII range, you may wish to instead use the\nmore customized L</Unicode Properties>, C<\\p{ID_Start}>,\nC<\\p{ID_Continue}>, C<\\p{XID_Start}>, and C<\\p{XID_Continue}>.  See\nL<http://unicode.org/reports/tr31>.\n\nAny character not matched by C<\\w> is matched by C<\\W>.\n\n=head3 Whitespace\n\nC<\\s> matches any single character considered whitespace.\n\n=over\n\n=item If the C</a> modifier is in effect ...\n\nIn all Perl versions, C<\\s> matches the 5 characters [\\t\\n\\f\\r ]; that\nis, the horizontal tab,\nthe newline, the form feed, the carriage return, and the space.\nStarting in Perl v5.18, it also matches the vertical tab, C<\\cK>.\nSee note C<[1]> below for a discussion of this.\n\n=item otherwise ...\n\n=over\n\n=item For code points above 255 ...\n\nC<\\s> matches exactly the code points above 255 shown with an \"s\" column\nin the table below.\n\n=item For code points below 256 ...\n\n=over\n\n=item if locale rules are in effect ...\n\nC<\\s> matches whatever the locale considers to be whitespace.\n\n=item if, instead, Unicode rules are in effect ...\n\nC<\\s> matches exactly the characters shown with an \"s\" column in the\ntable below.\n\n=item otherwise ...\n\nC<\\s> matches [\\t\\n\\f\\r ] and, starting in Perl\nv5.18, the vertical tab, C<\\cK>.\n(See note C<[1]> below for a discussion of this.)\nNote that this list doesn't include the non-breaking space.\n\n=back\n\n=back\n\n=back\n\nWhich rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.\n\nAny character not matched by C<\\s> is matched by C<\\S>.\n\nC<\\h> matches any character considered horizontal whitespace;\nthis includes the platform's space and tab characters and several others\nlisted in the table below.  C<\\H> matches any character\nnot considered horizontal whitespace.  They use the platform's native\ncharacter set, and do not consider any locale that may otherwise be in\nuse.\n\nC<\\v> matches any character considered vertical whitespace;\nthis includes the platform's carriage return and line feed characters (newline)\nplus several other characters, all listed in the table below.\nC<\\V> matches any character not considered vertical whitespace.\nThey use the platform's native character set, and do not consider any\nlocale that may otherwise be in use.\n\nC<\\R> matches anything that can be considered a newline under Unicode\nrules. It can match a multi-character sequence. It cannot be used inside\na bracketed character class; use C<\\v> instead (vertical whitespace).\nIt uses the platform's\nnative character set, and does not consider any locale that may\notherwise be in use.\nDetails are discussed in L<perlrebackslash>.\n\nNote that unlike C<\\s> (and C<\\d> and C<\\w>), C<\\h> and C<\\v> always match\nthe same characters, without regard to other factors, such as the active\nlocale or whether the source string is in UTF-8 format.\n\nOne might think that C<\\s> is equivalent to C<[\\h\\v]>. This is indeed true\nstarting in Perl v5.18, but prior to that, the sole difference was that the\nvertical tab (C<\"\\cK\">) was not matched by C<\\s>.\n\nThe following table is a complete listing of characters matched by\nC<\\s>, C<\\h> and C<\\v> as of Unicode 6.3.\n\nThe first column gives the Unicode code point of the character (in hex format),\nthe second column gives the (Unicode) name. The third column indicates\nby which class(es) the character is matched (assuming no locale is in\neffect that changes the C<\\s> matching).\n\n 0x0009        CHARACTER TABULATION   h s\n 0x000a              LINE FEED (LF)    vs\n 0x000b             LINE TABULATION    vs  [1]\n 0x000c              FORM FEED (FF)    vs\n 0x000d        CARRIAGE RETURN (CR)    vs\n 0x0020                       SPACE   h s\n 0x0085             NEXT LINE (NEL)    vs  [2]\n 0x00a0              NO-BREAK SPACE   h s  [2]\n 0x1680            OGHAM SPACE MARK   h s\n 0x2000                     EN QUAD   h s\n 0x2001                     EM QUAD   h s\n 0x2002                    EN SPACE   h s\n 0x2003                    EM SPACE   h s\n 0x2004          THREE-PER-EM SPACE   h s\n 0x2005           FOUR-PER-EM SPACE   h s\n 0x2006            SIX-PER-EM SPACE   h s\n 0x2007                FIGURE SPACE   h s\n 0x2008           PUNCTUATION SPACE   h s\n 0x2009                  THIN SPACE   h s\n 0x200a                  HAIR SPACE   h s\n 0x2028              LINE SEPARATOR    vs\n 0x2029         PARAGRAPH SEPARATOR    vs\n 0x202f       NARROW NO-BREAK SPACE   h s\n 0x205f   MEDIUM MATHEMATICAL SPACE   h s\n 0x3000           IDEOGRAPHIC SPACE   h s\n\n=over 4\n\n=item [1]\n\nPrior to Perl v5.18, C<\\s> did not match the vertical tab.\nC<[^\\S\\cK]> (obscurely) matches what C<\\s> traditionally did.\n\n=item [2]\n\nNEXT LINE and NO-BREAK SPACE may or may not match C<\\s> depending\non the rules in effect.  See\nL<the beginning of this section|/Whitespace>.\n\n=back\n\n=head3 Unicode Properties\n\nC<\\pP> and C<\\p{Prop}> are character classes to match characters that fit given\nUnicode properties.  One letter property names can be used in the C<\\pP> form,\nwith the property name following the C<\\p>, otherwise, braces are required.\nWhen using braces, there is a single form, which is just the property name\nenclosed in the braces, and a compound form which looks like C<\\p{name=value}>,\nwhich means to match if the property \"name\" for the character has that particular\n\"value\".\nFor instance, a match for a number can be written as C</\\pN/> or as\nC</\\p{Number}/>, or as C</\\p{Number=True}/>.\nLowercase letters are matched by the property I<Lowercase_Letter> which\nhas the short form I<Ll>. They need the braces, so are written as C</\\p{Ll}/> or\nC</\\p{Lowercase_Letter}/>, or C</\\p{General_Category=Lowercase_Letter}/>\n(the underscores are optional).\nC</\\pLl/> is valid, but means something different.\nIt matches a two character string: a letter (Unicode property C<\\pL>),\nfollowed by a lowercase C<l>.\n\nIf locale rules are not in effect, the use of\na Unicode property will force the regular expression into using Unicode\nrules, if it isn't already.\n\nNote that almost all properties are immune to case-insensitive matching.\nThat is, adding a C</i> regular expression modifier does not change what\nthey match.  There are two sets that are affected.  The first set is\nC<Uppercase_Letter>,\nC<Lowercase_Letter>,\nand C<Titlecase_Letter>,\nall of which match C<Cased_Letter> under C</i> matching.\nThe second set is\nC<Uppercase>,\nC<Lowercase>,\nand C<Titlecase>,\nall of which match C<Cased> under C</i> matching.\n(The difference between these sets is that some things, such as Roman\nnumerals, come in both upper and lower case, so they are C<Cased>, but\naren't considered to be letters, so they aren't C<Cased_Letter>s. They're\nactually C<Letter_Number>s.)\nThis set also includes its subsets C<PosixUpper> and C<PosixLower>, both\nof which under C</i> match C<PosixAlpha>.\n\nFor more details on Unicode properties, see L<perlunicode/Unicode\nCharacter Properties>; for a\ncomplete list of possible properties, see\nL<perluniprops/Properties accessible through \\p{} and \\P{}>,\nwhich notes all forms that have C</i> differences.\nIt is also possible to define your own properties. This is discussed in\nL<perlunicode/User-Defined Character Properties>.\n\nUnicode properties are defined (surprise!) only on Unicode code points.\nStarting in v5.20, when matching against C<\\p> and C<\\P>, Perl treats\nnon-Unicode code points (those above the legal Unicode maximum of\n0x10FFFF) as if they were typical unassigned Unicode code points.\n\nPrior to v5.20, Perl raised a warning and made all matches fail on\nnon-Unicode code points.  This could be somewhat surprising:\n\n chr(0x110000) =~ \\p{ASCII_Hex_Digit=True}     # Fails on Perls < v5.20.\n chr(0x110000) =~ \\p{ASCII_Hex_Digit=False}    # Also fails on Perls\n                                               # < v5.20\n\nEven though these two matches might be thought of as complements, until\nv5.20 they were so only on Unicode code points.\n\n=head4 Examples\n\n \"a\"  =~  /\\w/      # Match, \"a\" is a 'word' character.\n \"7\"  =~  /\\w/      # Match, \"7\" is a 'word' character as well.\n \"a\"  =~  /\\d/      # No match, \"a\" isn't a digit.\n \"7\"  =~  /\\d/      # Match, \"7\" is a digit.\n \" \"  =~  /\\s/      # Match, a space is whitespace.\n \"a\"  =~  /\\D/      # Match, \"a\" is a non-digit.\n \"7\"  =~  /\\D/      # No match, \"7\" is not a non-digit.\n \" \"  =~  /\\S/      # No match, a space is not non-whitespace.\n\n \" \"  =~  /\\h/      # Match, space is horizontal whitespace.\n \" \"  =~  /\\v/      # No match, space is not vertical whitespace.\n \"\\r\" =~  /\\v/      # Match, a return is vertical whitespace.\n\n \"a\"  =~  /\\pL/     # Match, \"a\" is a letter.\n \"a\"  =~  /\\p{Lu}/  # No match, /\\p{Lu}/ matches upper case letters.\n\n \"\\x{0e0b}\" =~ /\\p{Thai}/  # Match, \\x{0e0b} is the character\n                           # 'THAI CHARACTER SO SO', and that's in\n                           # Thai Unicode class.\n \"a\"  =~  /\\P{Lao}/ # Match, as \"a\" is not a Laotian character.\n\nIt is worth emphasizing that C<\\d>, C<\\w>, etc, match single characters, not\ncomplete numbers or words. To match a number (that consists of digits),\nuse C<\\d+>; to match a word, use C<\\w+>.  But be aware of the security\nconsiderations in doing so, as mentioned above.\n\n=head2 Bracketed Character Classes\n\nThe third form of character class you can use in Perl regular expressions\nis the bracketed character class.  In its simplest form, it lists the characters\nthat may be matched, surrounded by square brackets, like this: C<[aeiou]>.\nThis matches one of C<a>, C<e>, C<i>, C<o> or C<u>.  Like the other\ncharacter classes, exactly one character is matched.* To match\na longer string consisting of characters mentioned in the character\nclass, follow the character class with a L<quantifier|perlre/Quantifiers>.  For\ninstance, C<[aeiou]+> matches one or more lowercase English vowels.\n\nRepeating a character in a character class has no\neffect; it's considered to be in the set only once.\n\nExamples:\n\n \"e\"  =~  /[aeiou]/        # Match, as \"e\" is listed in the class.\n \"p\"  =~  /[aeiou]/        # No match, \"p\" is not listed in the class.\n \"ae\" =~  /^[aeiou]$/      # No match, a character class only matches\n                           # a single character.\n \"ae\" =~  /^[aeiou]+$/     # Match, due to the quantifier.\n\n -------\n\n* There are two exceptions to a bracketed character class matching a\nsingle character only.  Each requires special handling by Perl to make\nthings work:\n\n=over\n\n=item *\n\nWhen the class is to match caselessly under C</i> matching rules, and a\ncharacter that is explicitly mentioned inside the class matches a\nmultiple-character sequence caselessly under Unicode rules, the class\nwill also match that sequence.  For example, Unicode says that the\nletter C<LATIN SMALL LETTER SHARP S> should match the sequence C<ss>\nunder C</i> rules.  Thus,\n\n 'ss' =~ /\\A\\N{LATIN SMALL LETTER SHARP S}\\z/i             # Matches\n 'ss' =~ /\\A[aeioust\\N{LATIN SMALL LETTER SHARP S}]\\z/i    # Matches\n\nFor this to happen, the class must not be inverted (see L</Negation>)\nand the character must be explicitly specified, and not be part of a\nmulti-character range (not even as one of its endpoints).  (L</Character\nRanges> will be explained shortly.) Therefore,\n\n 'ss' =~ /\\A[\\0-\\x{ff}]\\z/ui       # Doesn't match\n 'ss' =~ /\\A[\\0-\\N{LATIN SMALL LETTER SHARP S}]\\z/ui   # No match\n 'ss' =~ /\\A[\\xDF-\\xDF]\\z/ui   # Matches on ASCII platforms, since\n                               # \\xDF is LATIN SMALL LETTER SHARP S,\n                               # and the range is just a single\n                               # element\n\nNote that it isn't a good idea to specify these types of ranges anyway.\n\n=item *\n\nSome names known to C<\\N{...}> refer to a sequence of multiple characters,\ninstead of the usual single character.  When one of these is included in\nthe class, the entire sequence is matched.  For example,\n\n  \"\\N{TAMIL LETTER KA}\\N{TAMIL VOWEL SIGN AU}\"\n                              =~ / ^ [\\N{TAMIL SYLLABLE KAU}]  $ /x;\n\nmatches, because C<\\N{TAMIL SYLLABLE KAU}> is a named sequence\nconsisting of the two characters matched against.  Like the other\ninstance where a bracketed class can match multiple characters, and for\nsimilar reasons, the class must not be inverted, and the named sequence\nmay not appear in a range, even one where it is both endpoints.  If\nthese happen, it is a fatal error if the character class is within the\nscope of L<C<use re 'strict>|re/'strict' mode>, or within an extended\nL<C<(?[...])>|/Extended Bracketed Character Classes> class; otherwise\nonly the first code point is used (with a C<regexp>-type warning\nraised).\n\n=back\n\n=head3 Special Characters Inside a Bracketed Character Class\n\nMost characters that are meta characters in regular expressions (that\nis, characters that carry a special meaning like C<.>, C<*>, or C<(>) lose\ntheir special meaning and can be used inside a character class without\nthe need to escape them. For instance, C<[()]> matches either an opening\nparenthesis, or a closing parenthesis, and the parens inside the character\nclass don't group or capture.  Be aware that, unless the pattern is\nevaluated in single-quotish context, variable interpolation will take\nplace before the bracketed class is parsed:\n\n $, = \"\\t| \";\n $a =~ m'[$,]';        # single-quotish: matches '$' or ','\n $a =~ q{[$,]}'        # same\n $a =~ m/[$,]/;        # double-quotish: matches \"\\t\", \"|\", or \" \"\n\nCharacters that may carry a special meaning inside a character class are:\nC<\\>, C<^>, C<->, C<[> and C<]>, and are discussed below. They can be\nescaped with a backslash, although this is sometimes not needed, in which\ncase the backslash may be omitted.\n\nThe sequence C<\\b> is special inside a bracketed character class. While\noutside the character class, C<\\b> is an assertion indicating a point\nthat does not have either two word characters or two non-word characters\non either side, inside a bracketed character class, C<\\b> matches a\nbackspace character.\n\nThe sequences\nC<\\a>,\nC<\\c>,\nC<\\e>,\nC<\\f>,\nC<\\n>,\nC<\\N{I<NAME>}>,\nC<\\N{U+I<hex char>}>,\nC<\\r>,\nC<\\t>,\nand\nC<\\x>\nare also special and have the same meanings as they do outside a\nbracketed character class.\n\nAlso, a backslash followed by two or three octal digits is considered an octal\nnumber.\n\nA C<[> is not special inside a character class, unless it's the start of a\nPOSIX character class (see L</POSIX Character Classes> below). It normally does\nnot need escaping.\n\nA C<]> is normally either the end of a POSIX character class (see\nL</POSIX Character Classes> below), or it signals the end of the bracketed\ncharacter class.  If you want to include a C<]> in the set of characters, you\nmust generally escape it.\n\nHowever, if the C<]> is the I<first> (or the second if the first\ncharacter is a caret) character of a bracketed character class, it\ndoes not denote the end of the class (as you cannot have an empty class)\nand is considered part of the set of characters that can be matched without\nescaping.\n\nExamples:\n\n \"+\"   =~ /[+?*]/     #  Match, \"+\" in a character class is not special.\n \"\\cH\" =~ /[\\b]/      #  Match, \\b inside in a character class\n                      #  is equivalent to a backspace.\n \"]\"   =~ /[][]/      #  Match, as the character class contains\n                      #  both [ and ].\n \"[]\"  =~ /[[]]/      #  Match, the pattern contains a character class\n                      #  containing just [, and the character class is\n                      #  followed by a ].\n\n=head3 Bracketed Character Classes and the C</xx> pattern modifier\n\nNormally SPACE and TAB characters have no special meaning inside a\nbracketed character class; they are just added to the list of characters\nmatched by the class.  But if the L<C</xx>|perlre/E<sol>x and E<sol>xx>\npattern modifier is in effect, they are generally ignored and can be\nadded to improve readability.  They can't be added in the middle of a\nsingle construct:\n\n / [ \\x{10 FFFF} ] /xx  # WRONG!\n\nThe SPACE in the middle of the hex constant is illegal.\n\nTo specify a literal SPACE character, you can escape it with a\nbackslash, like:\n\n /[ a e i o u \\  ]/xx\n\nThis matches the English vowels plus the SPACE character.\n\nFor clarity, you should already have been using C<\\t> to specify a\nliteral tab, and C<\\t> is unaffected by C</xx>.\n\n=head3 Character Ranges\n\nIt is not uncommon to want to match a range of characters. Luckily, instead\nof listing all characters in the range, one may use the hyphen (C<->).\nIf inside a bracketed character class you have two characters separated\nby a hyphen, it's treated as if all characters between the two were in\nthe class. For instance, C<[0-9]> matches any ASCII digit, and C<[a-m]>\nmatches any lowercase letter from the first half of the ASCII alphabet.\n\nNote that the two characters on either side of the hyphen are not\nnecessarily both letters or both digits. Any character is possible,\nalthough not advisable.  C<['-?]> contains a range of characters, but\nmost people will not know which characters that means.  Furthermore,\nsuch ranges may lead to portability problems if the code has to run on\na platform that uses a different character set, such as EBCDIC.\n\nIf a hyphen in a character class cannot syntactically be part of a range, for\ninstance because it is the first or the last character of the character class,\nor if it immediately follows a range, the hyphen isn't special, and so is\nconsidered a character to be matched literally.  If you want a hyphen in\nyour set of characters to be matched and its position in the class is such\nthat it could be considered part of a range, you must escape that hyphen\nwith a backslash.\n\nExamples:\n\n [a-z]       #  Matches a character that is a lower case ASCII letter.\n [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or\n             #  the letter 'z'.\n [-z]        #  Matches either a hyphen ('-') or the letter 'z'.\n [a-f-m]     #  Matches any letter between 'a' and 'f' (inclusive), the\n             #  hyphen ('-'), or the letter 'm'.\n ['-?]       #  Matches any of the characters  '()*+,-./0123456789:;<=>?\n             #  (But not on an EBCDIC platform).\n [\\N{APOSTROPHE}-\\N{QUESTION MARK}]\n             #  Matches any of the characters  '()*+,-./0123456789:;<=>?\n             #  even on an EBCDIC platform.\n [\\N{U+27}-\\N{U+3F}] # Same. (U+27 is \"'\", and U+3F is \"?\")\n\nAs the final two examples above show, you can achieve portablity to\nnon-ASCII platforms by using the C<\\N{...}> form for the range\nendpoints.  These indicate that the specified range is to be interpreted\nusing Unicode values, so C<[\\N{U+27}-\\N{U+3F}]> means to match\nC<\\N{U+27}>, C<\\N{U+28}>, C<\\N{U+29}>, ..., C<\\N{U+3D}>, C<\\N{U+3E}>,\nand C<\\N{U+3F}>, whatever the native code point versions for those are.\nThese are called \"Unicode\" ranges.  If either end is of the C<\\N{...}>\nform, the range is considered Unicode.  A C<regexp> warning is raised\nunder C<S<\"use re 'strict'\">> if the other endpoint is specified\nnon-portably:\n\n [\\N{U+00}-\\x09]    # Warning under re 'strict'; \\x09 is non-portable\n [\\N{U+00}-\\t]      # No warning;\n\nBoth of the above match the characters C<\\N{U+00}> C<\\N{U+01}>, ...\nC<\\N{U+08}>, C<\\N{U+09}>, but the C<\\x09> looks like it could be a\nmistake so the warning is raised (under C<re 'strict'>) for it.\n\nPerl also guarantees that the ranges C<A-Z>, C<a-z>, C<0-9>, and any\nsubranges of these match what an English-only speaker would expect them\nto match on any platform.  That is, C<[A-Z]> matches the 26 ASCII\nuppercase letters;\nC<[a-z]> matches the 26 lowercase letters; and C<[0-9]> matches the 10\ndigits.  Subranges, like C<[h-k]>, match correspondingly, in this case\njust the four letters C<\"h\">, C<\"i\">, C<\"j\">, and C<\"k\">.  This is the\nnatural behavior on ASCII platforms where the code points (ordinal\nvalues) for C<\"h\"> through C<\"k\"> are consecutive integers (0x68 through\n0x6B).  But special handling to achieve this may be needed on platforms\nwith a non-ASCII native character set.  For example, on EBCDIC\nplatforms, the code point for C<\"h\"> is 0x88, C<\"i\"> is 0x89, C<\"j\"> is\n0x91, and C<\"k\"> is 0x92.   Perl specially treats C<[h-k]> to exclude the\nseven code points in the gap: 0x8A through 0x90.  This special handling is\nonly invoked when the range is a subrange of one of the ASCII uppercase,\nlowercase, and digit ranges, AND each end of the range is expressed\neither as a literal, like C<\"A\">, or as a named character (C<\\N{...}>,\nincluding the C<\\N{U+...> form).\n\nEBCDIC Examples:\n\n [i-j]               #  Matches either \"i\" or \"j\"\n [i-\\N{LATIN SMALL LETTER J}]  # Same\n [i-\\N{U+6A}]        #  Same\n [\\N{U+69}-\\N{U+6A}] #  Same\n [\\x{89}-\\x{91}]     #  Matches 0x89 (\"i\"), 0x8A .. 0x90, 0x91 (\"j\")\n [i-\\x{91}]          #  Same\n [\\x{89}-j]          #  Same\n [i-J]               #  Matches, 0x89 (\"i\") .. 0xC1 (\"J\"); special\n                     #  handling doesn't apply because range is mixed\n                     #  case\n\n=head3 Negation\n\nIt is also possible to instead list the characters you do not want to\nmatch. You can do so by using a caret (C<^>) as the first character in the\ncharacter class. For instance, C<[^a-z]> matches any character that is not a\nlowercase ASCII letter, which therefore includes more than a million\nUnicode code points.  The class is said to be \"negated\" or \"inverted\".\n\nThis syntax make the caret a special character inside a bracketed character\nclass, but only if it is the first character of the class. So if you want\nthe caret as one of the characters to match, either escape the caret or\nelse don't list it first.\n\nIn inverted bracketed character classes, Perl ignores the Unicode rules\nthat normally say that named sequence, and certain characters should\nmatch a sequence of multiple characters use under caseless C</i>\nmatching.  Following those rules could lead to highly confusing\nsituations:\n\n \"ss\" =~ /^[^\\xDF]+$/ui;   # Matches!\n\nThis should match any sequences of characters that aren't C<\\xDF> nor\nwhat C<\\xDF> matches under C</i>.  C<\"s\"> isn't C<\\xDF>, but Unicode\nsays that C<\"ss\"> is what C<\\xDF> matches under C</i>.  So which one\n\"wins\"? Do you fail the match because the string has C<ss> or accept it\nbecause it has an C<s> followed by another C<s>?  Perl has chosen the\nlatter.  (See note in L</Bracketed Character Classes> above.)\n\nExamples:\n\n \"e\"  =~  /[^aeiou]/   #  No match, the 'e' is listed.\n \"x\"  =~  /[^aeiou]/   #  Match, as 'x' isn't a lowercase vowel.\n \"^\"  =~  /[^^]/       #  No match, matches anything that isn't a caret.\n \"^\"  =~  /[x^]/       #  Match, caret is not special here.\n\n=head3 Backslash Sequences\n\nYou can put any backslash sequence character class (with the exception of\nC<\\N> and C<\\R>) inside a bracketed character class, and it will act just\nas if you had put all characters matched by the backslash sequence inside the\ncharacter class. For instance, C<[a-f\\d]> matches any decimal digit, or any\nof the lowercase letters between 'a' and 'f' inclusive.\n\nC<\\N> within a bracketed character class must be of the forms C<\\N{I<name>}>\nor C<\\N{U+I<hex char>}>, and NOT be the form that matches non-newlines,\nfor the same reason that a dot C<.> inside a bracketed character class loses\nits special meaning: it matches nearly anything, which generally isn't what you\nwant to happen.\n\n\nExamples:\n\n /[\\p{Thai}\\d]/     # Matches a character that is either a Thai\n                    # character, or a digit.\n /[^\\p{Arabic}()]/  # Matches a character that is neither an Arabic\n                    # character, nor a parenthesis.\n\nBackslash sequence character classes cannot form one of the endpoints\nof a range.  Thus, you can't say:\n\n /[\\p{Thai}-\\d]/     # Wrong!\n\n=head3 POSIX Character Classes\nX<character class> X<\\p> X<\\p{}>\nX<alpha> X<alnum> X<ascii> X<blank> X<cntrl> X<digit> X<graph>\nX<lower> X<print> X<punct> X<space> X<upper> X<word> X<xdigit>\n\nPOSIX character classes have the form C<[:class:]>, where I<class> is the\nname, and the C<[:> and C<:]> delimiters. POSIX character classes only appear\nI<inside> bracketed character classes, and are a convenient and descriptive\nway of listing a group of characters.\n\nBe careful about the syntax,\n\n # Correct:\n $string =~ /[[:alpha:]]/\n\n # Incorrect (will warn):\n $string =~ /[:alpha:]/\n\nThe latter pattern would be a character class consisting of a colon,\nand the letters C<a>, C<l>, C<p> and C<h>.\n\nPOSIX character classes can be part of a larger bracketed character class.\nFor example,\n\n [01[:alpha:]%]\n\nis valid and matches '0', '1', any alphabetic character, and the percent sign.\n\nPerl recognizes the following POSIX character classes:\n\n alpha  Any alphabetical character (\"[A-Za-z]\").\n alnum  Any alphanumeric character (\"[A-Za-z0-9]\").\n ascii  Any character in the ASCII character set.\n blank  A GNU extension, equal to a space or a horizontal tab (\"\\t\").\n cntrl  Any control character.  See Note [2] below.\n digit  Any decimal digit (\"[0-9]\"), equivalent to \"\\d\".\n graph  Any printable character, excluding a space.  See Note [3] below.\n lower  Any lowercase character (\"[a-z]\").\n print  Any printable character, including a space.  See Note [4] below.\n punct  Any graphical character excluding \"word\" characters.  Note [5].\n space  Any whitespace character. \"\\s\" including the vertical tab\n        (\"\\cK\").\n upper  Any uppercase character (\"[A-Z]\").\n word   A Perl extension (\"[A-Za-z0-9_]\"), equivalent to \"\\w\".\n xdigit Any hexadecimal digit (\"[0-9a-fA-F]\").\n\nLike the L<Unicode properties|/Unicode Properties>, most of the POSIX\nproperties match the same regardless of whether case-insensitive (C</i>)\nmatching is in effect or not.  The two exceptions are C<[:upper:]> and\nC<[:lower:]>.  Under C</i>, they each match the union of C<[:upper:]> and\nC<[:lower:]>.\n\nMost POSIX character classes have two Unicode-style C<\\p> property\ncounterparts.  (They are not official Unicode properties, but Perl extensions\nderived from official Unicode properties.)  The table below shows the relation\nbetween POSIX character classes and these counterparts.\n\nOne counterpart, in the column labelled \"ASCII-range Unicode\" in\nthe table, matches only characters in the ASCII character set.\n\nThe other counterpart, in the column labelled \"Full-range Unicode\", matches any\nappropriate characters in the full Unicode character set.  For example,\nC<\\p{Alpha}> matches not just the ASCII alphabetic characters, but any\ncharacter in the entire Unicode character set considered alphabetic.\nAn entry in the column labelled \"backslash sequence\" is a (short)\nequivalent.\n\n [[:...:]]      ASCII-range          Full-range  backslash  Note\n                 Unicode              Unicode     sequence\n -----------------------------------------------------\n   alpha      \\p{PosixAlpha}       \\p{XPosixAlpha}\n   alnum      \\p{PosixAlnum}       \\p{XPosixAlnum}\n   ascii      \\p{ASCII}\n   blank      \\p{PosixBlank}       \\p{XPosixBlank}  \\h      [1]\n                                   or \\p{HorizSpace}        [1]\n   cntrl      \\p{PosixCntrl}       \\p{XPosixCntrl}          [2]\n   digit      \\p{PosixDigit}       \\p{XPosixDigit}  \\d\n   graph      \\p{PosixGraph}       \\p{XPosixGraph}          [3]\n   lower      \\p{PosixLower}       \\p{XPosixLower}\n   print      \\p{PosixPrint}       \\p{XPosixPrint}          [4]\n   punct      \\p{PosixPunct}       \\p{XPosixPunct}          [5]\n              \\p{PerlSpace}        \\p{XPerlSpace}   \\s      [6]\n   space      \\p{PosixSpace}       \\p{XPosixSpace}          [6]\n   upper      \\p{PosixUpper}       \\p{XPosixUpper}\n   word       \\p{PosixWord}        \\p{XPosixWord}   \\w\n   xdigit     \\p{PosixXDigit}      \\p{XPosixXDigit}\n\n=over 4\n\n=item [1]\n\nC<\\p{Blank}> and C<\\p{HorizSpace}> are synonyms.\n\n=item [2]\n\nControl characters don't produce output as such, but instead usually control\nthe terminal somehow: for example, newline and backspace are control characters.\nOn ASCII platforms, in the ASCII range, characters whose code points are\nbetween 0 and 31 inclusive, plus 127 (C<DEL>) are control characters; on\nEBCDIC platforms, their counterparts are control characters.\n\n=item [3]\n\nAny character that is I<graphical>, that is, visible. This class consists\nof all alphanumeric characters and all punctuation characters.\n\n=item [4]\n\nAll printable characters, which is the set of all graphical characters\nplus those whitespace characters which are not also controls.\n\n=item [5]\n\nC<\\p{PosixPunct}> and C<[[:punct:]]> in the ASCII range match all\nnon-controls, non-alphanumeric, non-space characters:\nC<[-!\"#$%&'()*+,./:;<=E<gt>?@[\\\\\\]^_`{|}~]> (although if a locale is in effect,\nit could alter the behavior of C<[[:punct:]]>).\n\nThe similarly named property, C<\\p{Punct}>, matches a somewhat different\nset in the ASCII range, namely\nC<[-!\"#%&'()*,./:;?@[\\\\\\]_{}]>.  That is, it is missing the nine\ncharacters C<[$+E<lt>=E<gt>^`|~]>.\nThis is because Unicode splits what POSIX considers to be punctuation into two\ncategories, Punctuation and Symbols.\n\nC<\\p{XPosixPunct}> and (under Unicode rules) C<[[:punct:]]>, match what\nC<\\p{PosixPunct}> matches in the ASCII range, plus what C<\\p{Punct}>\nmatches.  This is different than strictly matching according to\nC<\\p{Punct}>.  Another way to say it is that\nif Unicode rules are in effect, C<[[:punct:]]> matches all characters\nthat Unicode considers punctuation, plus all ASCII-range characters that\nUnicode considers symbols.\n\n=item [6]\n\nC<\\p{XPerlSpace}> and C<\\p{Space}> match identically starting with Perl\nv5.18.  In earlier versions, these differ only in that in non-locale\nmatching, C<\\p{XPerlSpace}> did not match the vertical tab, C<\\cK>.\nSame for the two ASCII-only range forms.\n\n=back\n\nThere are various other synonyms that can be used besides the names\nlisted in the table.  For example, C<\\p{XPosixAlpha}> can be written as\nC<\\p{Alpha}>.  All are listed in\nL<perluniprops/Properties accessible through \\p{} and \\P{}>.\n\nBoth the C<\\p> counterparts always assume Unicode rules are in effect.\nOn ASCII platforms, this means they assume that the code points from 128\nto 255 are Latin-1, and that means that using them under locale rules is\nunwise unless the locale is guaranteed to be Latin-1 or UTF-8.  In contrast, the\nPOSIX character classes are useful under locale rules.  They are\naffected by the actual rules in effect, as follows:\n\n=over\n\n=item If the C</a> modifier, is in effect ...\n\nEach of the POSIX classes matches exactly the same as their ASCII-range\ncounterparts.\n\n=item otherwise ...\n\n=over\n\n=item For code points above 255 ...\n\nThe POSIX class matches the same as its Full-range counterpart.\n\n=item For code points below 256 ...\n\n=over\n\n=item if locale rules are in effect ...\n\nThe POSIX class matches according to the locale, except:\n\n=over\n\n=item C<word>\n\nalso includes the platform's native underscore character, no matter what\nthe locale is.\n\n=item C<ascii>\n\non platforms that don't have the POSIX C<ascii> extension, this matches\njust the platform's native ASCII-range characters.\n\n=item C<blank>\n\non platforms that don't have the POSIX C<blank> extension, this matches\njust the platform's native tab and space characters.\n\n=back\n\n=item if, instead, Unicode rules are in effect ...\n\nThe POSIX class matches the same as the Full-range counterpart.\n\n=item otherwise ...\n\nThe POSIX class matches the same as the ASCII range counterpart.\n\n=back\n\n=back\n\n=back\n\nWhich rules apply are determined as described in\nL<perlre/Which character set modifier is in effect?>.\n\nIt is proposed to change this behavior in a future release of Perl so that\nwhether or not Unicode rules are in effect would not change the\nbehavior:  Outside of locale, the POSIX classes\nwould behave like their ASCII-range counterparts.  If you wish to\ncomment on this proposal, send email to C<perl5-porters@perl.org>.\n\n=head4 Negation of POSIX character classes\nX<character class, negation>\n\nA Perl extension to the POSIX character class is the ability to\nnegate it. This is done by prefixing the class name with a caret (C<^>).\nSome examples:\n\n     POSIX         ASCII-range     Full-range  backslash\n                    Unicode         Unicode    sequence\n -----------------------------------------------------\n [[:^digit:]]   \\P{PosixDigit}  \\P{XPosixDigit}   \\D\n [[:^space:]]   \\P{PosixSpace}  \\P{XPosixSpace}\n                \\P{PerlSpace}   \\P{XPerlSpace}    \\S\n [[:^word:]]    \\P{PerlWord}    \\P{XPosixWord}    \\W\n\nThe backslash sequence can mean either ASCII- or Full-range Unicode,\ndepending on various factors as described in L<perlre/Which character set modifier is in effect?>.\n\n=head4 [= =] and [. .]\n\nPerl recognizes the POSIX character classes C<[=class=]> and\nC<[.class.]>, but does not (yet?) support them.  Any attempt to use\neither construct raises an exception.\n\n=head4 Examples\n\n /[[:digit:]]/            # Matches a character that is a digit.\n /[01[:lower:]]/          # Matches a character that is either a\n                          # lowercase letter, or '0' or '1'.\n /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything\n                          # except the letters 'a' to 'f' and 'A' to\n                          # 'F'.  This is because the main character\n                          # class is composed of two POSIX character\n                          # classes that are ORed together, one that\n                          # matches any digit, and the other that\n                          # matches anything that isn't a hex digit.\n                          # The OR adds the digits, leaving only the\n                          # letters 'a' to 'f' and 'A' to 'F' excluded.\n\n=head3 Extended Bracketed Character Classes\nX<character class>\nX<set operations>\n\nThis is a fancy bracketed character class that can be used for more\nreadable and less error-prone classes, and to perform set operations,\nsuch as intersection. An example is\n\n /(?[ \\p{Thai} & \\p{Digit} ])/\n\nThis will match all the digit characters that are in the Thai script.\n\nThis is an experimental feature available starting in 5.18, and is\nsubject to change as we gain field experience with it.  Any attempt to\nuse it will raise a warning, unless disabled via\n\n no warnings \"experimental::regex_sets\";\n\nComments on this feature are welcome; send email to\nC<perl5-porters@perl.org>.\n\nThe rules used by L<C<use re 'strict>|re/'strict' mode> apply to this\nconstruct.\n\nWe can extend the example above:\n\n /(?[ ( \\p{Thai} + \\p{Lao} ) & \\p{Digit} ])/\n\nThis matches digits that are in either the Thai or Laotian scripts.\n\nNotice the white space in these examples.  This construct always has\nthe C<E<sol>xx> modifier turned on within it.\n\nThe available binary operators are:\n\n &    intersection\n +    union\n |    another name for '+', hence means union\n -    subtraction (the result matches the set consisting of those\n      code points matched by the first operand, excluding any that\n      are also matched by the second operand)\n ^    symmetric difference (the union minus the intersection).  This\n      is like an exclusive or, in that the result is the set of code\n      points that are matched by either, but not both, of the\n      operands.\n\nThere is one unary operator:\n\n !    complement\n\nAll the binary operators left associate; C<\"&\"> is higher precedence\nthan the others, which all have equal precedence.  The unary operator\nright associates, and has highest precedence.  Thus this follows the\nnormal Perl precedence rules for logical operators.  Use parentheses to\noverride the default precedence and associativity.\n\nThe main restriction is that everything is a metacharacter.  Thus,\nyou cannot refer to single characters by doing something like this:\n\n /(?[ a + b ])/ # Syntax error!\n\nThe easiest way to specify an individual typable character is to enclose\nit in brackets:\n\n /(?[ [a] + [b] ])/\n\n(This is the same thing as C<[ab]>.)  You could also have said the\nequivalent:\n\n /(?[[ a b ]])/\n\n(You can, of course, specify single characters by using, C<\\x{...}>,\nC<\\N{...}>, etc.)\n\nThis last example shows the use of this construct to specify an ordinary\nbracketed character class without additional set operations.  Note the\nwhite space within it.  This is allowed because C<E<sol>xx> is\nautomatically turned on within this construct.\n\nAll the other escapes accepted by normal bracketed character classes are\naccepted here as well.\n\nBecause this construct compiles under\nL<C<use re 'strict>|re/'strict' mode>,  unrecognized escapes that\ngenerate warnings in normal classes are fatal errors here, as well as\nall other warnings from these class elements, as well as some\npractices that don't currently warn outside C<re 'strict'>.  For example\nyou cannot say\n\n /(?[ [ \\xF ] ])/     # Syntax error!\n\nYou have to have two hex digits after a braceless C<\\x> (use a leading\nzero to make two).  These restrictions are to lower the incidence of\ntypos causing the class to not match what you thought it would.\n\nIf a regular bracketed character class contains a C<\\p{}> or C<\\P{}> and\nis matched against a non-Unicode code point, a warning may be\nraised, as the result is not Unicode-defined.  No such warning will come\nwhen using this extended form.\n\nThe final difference between regular bracketed character classes and\nthese, is that it is not possible to get these to match a\nmulti-character fold.  Thus,\n\n /(?[ [\\xDF] ])/iu\n\ndoes not match the string C<ss>.\n\nYou don't have to enclose POSIX class names inside double brackets,\nhence both of the following work:\n\n /(?[ [:word:] - [:lower:] ])/\n /(?[ [[:word:]] - [[:lower:]] ])/\n\nAny contained POSIX character classes, including things like C<\\w> and C<\\D>\nrespect the C<E<sol>a> (and C<E<sol>aa>) modifiers.\n\nNote that C<< (?[ ]) >> is a regex-compile-time construct.  Any attempt\nto use something which isn't knowable at the time the containing regular\nexpression is compiled is a fatal error.  In practice, this means\njust three limitations:\n\n=over 4\n\n=item 1\n\nWhen compiled within the scope of C<use locale> (or the C<E<sol>l> regex\nmodifier), this construct assumes that the execution-time locale will be\na UTF-8 one, and the generated pattern always uses Unicode rules.  What\ngets matched or not thus isn't dependent on the actual runtime locale, so\ntainting is not enabled.  But a C<locale> category warning is raised\nif the runtime locale turns out to not be UTF-8.\n\n=item 2\n\nAny\nL<user-defined property|perlunicode/\"User-Defined Character Properties\">\nused must be already defined by the time the regular expression is\ncompiled (but note that this construct can be used instead of such\nproperties).\n\n=item 3\n\nA regular expression that otherwise would compile\nusing C<E<sol>d> rules, and which uses this construct will instead\nuse C<E<sol>u>.  Thus this construct tells Perl that you don't want\nC<E<sol>d> rules for the entire regular expression containing it.\n\n=back\n\nNote that skipping white space applies only to the interior of this\nconstruct.  There must not be any space between any of the characters\nthat form the initial C<(?[>.  Nor may there be space between the\nclosing C<])> characters.\n\nJust as in all regular expressions, the pattern can be built up by\nincluding variables that are interpolated at regex compilation time.\nCare must be taken to ensure that you are getting what you expect.  For\nexample:\n\n my $thai_or_lao = '\\p{Thai} + \\p{Lao}';\n ...\n qr/(?[ \\p{Digit} & $thai_or_lao ])/;\n\ncompiles to\n\n qr/(?[ \\p{Digit} & \\p{Thai} + \\p{Lao} ])/;\n\nBut this does not have the effect that someone reading the code would\nlikely expect, as the intersection applies just to C<\\p{Thai}>,\nexcluding the Laotian.  Pitfalls like this can be avoided by\nparenthesizing the component pieces:\n\n my $thai_or_lao = '( \\p{Thai} + \\p{Lao} )';\n\nBut any modifiers will still apply to all the components:\n\n my $lower = '\\p{Lower} + \\p{Digit}';\n qr/(?[ \\p{Greek} & $lower ])/i;\n\nmatches upper case things.  You can avoid surprises by making the\ncomponents into instances of this construct by compiling them:\n\n my $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\n my $lower = qr/(?[ \\p{Lower} + \\p{Digit} ])/;\n\nWhen these are embedded in another pattern, what they match does not\nchange, regardless of parenthesization or what modifiers are in effect\nin that outer pattern.\n\nDue to the way that Perl parses things, your parentheses and brackets\nmay need to be balanced, even including comments.  If you run into any\nexamples, please send them to C<perlbug@perl.org>, so that we can have a\nconcrete example for this man page.\n\nWe may change it so that things that remain legal uses in normal bracketed\ncharacter classes might become illegal within this experimental\nconstruct.  One proposal, for example, is to forbid adjacent uses of the\nsame character, as in C<(?[ [aa] ])>.  The motivation for such a change\nis that this usage is likely a typo, as the second \"a\" adds nothing.\n", "/*    regcomp.c\n */\n\n/*\n * 'A fair jaw-cracker dwarf-language must be.'            --Samwise Gamgee\n *\n *     [p.285 of _The Lord of the Rings_, II/iii: \"The Ring Goes South\"]\n */\n\n/* This file contains functions for compiling a regular expression.  See\n * also regexec.c which funnily enough, contains functions for executing\n * a regular expression.\n *\n * This file is also copied at build time to ext/re/re_comp.c, where\n * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.\n * This causes the main functions to be compiled under new names and with\n * debugging support added, which makes \"use re 'debug'\" work.\n */\n\n/* NOTE: this is derived from Henry Spencer's regexp code, and should not\n * confused with the original package (see point 3 below).  Thanks, Henry!\n */\n\n/* Additional note: this code is very heavily munged from Henry's version\n * in places.  In some spots I've traded clarity for efficiency, so don't\n * blame Henry for some of the lack of readability.\n */\n\n/* The names of the functions have been changed from regcomp and\n * regexec to pregcomp and pregexec in order to avoid conflicts\n * with the POSIX routines of the same names.\n*/\n\n#ifdef PERL_EXT_RE_BUILD\n#include \"re_top.h\"\n#endif\n\n/*\n * pregcomp and pregexec -- regsub and regerror are not used in perl\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n *\n ****    Alterations to Henry's code are...\n ****\n ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n ****    by Larry Wall and others\n ****\n ****    You may distribute under the terms of either the GNU General Public\n ****    License or the Artistic License, as specified in the README file.\n\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n */\n#include \"EXTERN.h\"\n#define PERL_IN_REGCOMP_C\n#include \"perl.h\"\n\n#ifndef PERL_IN_XSUB_RE\n#  include \"INTERN.h\"\n#endif\n\n#define REG_COMP_C\n#ifdef PERL_IN_XSUB_RE\n#  include \"re_comp.h\"\nEXTERN_C const struct regexp_engine my_reg_engine;\n#else\n#  include \"regcomp.h\"\n#endif\n\n#include \"dquote_inline.h\"\n#include \"invlist_inline.h\"\n#include \"unicode_constants.h\"\n\n#define HAS_NONLATIN1_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(i) \\\n _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)\n#define IS_NON_FINAL_FOLD(c) _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n#define IS_IN_SOME_FOLD_L1(c) _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\n#ifndef STATIC\n#define\tSTATIC\tstatic\n#endif\n\n/* this is a chain of data about sub patterns we are processing that\n   need to be handled separately/specially in study_chunk. Its so\n   we can simulate recursion without losing state.  */\nstruct scan_frame;\ntypedef struct scan_frame {\n    regnode *last_regnode;      /* last node to process in this frame */\n    regnode *next_regnode;      /* next node to process when last is reached */\n    U32 prev_recursed_depth;\n    I32 stopparen;              /* what stopparen do we use */\n\n    struct scan_frame *this_prev_frame; /* this previous frame */\n    struct scan_frame *prev_frame;      /* previous frame */\n    struct scan_frame *next_frame;      /* next frame */\n} scan_frame;\n\n/* Certain characters are output as a sequence with the first being a\n * backslash. */\n#define isBACKSLASHED_PUNCT(c)  strchr(\"-[]\\\\^\", c)\n\n\nstruct RExC_state_t {\n    U32\t\tflags;\t\t\t/* RXf_* are we folding, multilining? */\n    U32\t\tpm_flags;\t\t/* PMf_* stuff from the calling PMOP */\n    char\t*precomp;\t\t/* uncompiled string. */\n    char\t*precomp_end;\t\t/* pointer to end of uncompiled string. */\n    REGEXP\t*rx_sv;\t\t\t/* The SV that is the regexp. */\n    regexp\t*rx;                    /* perl core regexp structure */\n    regexp_internal\t*rxi;           /* internal data for regexp object\n                                           pprivate field */\n    char\t*start;\t\t\t/* Start of input for compile */\n    char\t*end;\t\t\t/* End of input for compile */\n    char\t*parse;\t\t\t/* Input-scan pointer. */\n    char        *adjusted_start;        /* 'start', adjusted.  See code use */\n    STRLEN      precomp_adj;            /* an offset beyond precomp.  See code use */\n    SSize_t\twhilem_seen;\t\t/* number of WHILEM in this expr */\n    regnode\t*emit_start;\t\t/* Start of emitted-code area */\n    regnode\t*emit_bound;\t\t/* First regnode outside of the\n                                           allocated space */\n    regnode\t*emit;\t\t\t/* Code-emit pointer; if = &emit_dummy,\n                                           implies compiling, so don't emit */\n    regnode_ssc\temit_dummy;\t\t/* placeholder for emit to point to;\n                                           large enough for the largest\n                                           non-EXACTish node, so can use it as\n                                           scratch in pass1 */\n    I32\t\tnaughty;\t\t/* How bad is this pattern? */\n    I32\t\tsawback;\t\t/* Did we see \\1, ...? */\n    U32\t\tseen;\n    SSize_t\tsize;\t\t\t/* Code size. */\n    I32                npar;            /* Capture buffer count, (OPEN) plus\n                                           one. (\"par\" 0 is the whole\n                                           pattern)*/\n    I32\t\tnestroot;\t\t/* root parens we are in - used by\n                                           accept */\n    I32\t\textralen;\n    I32\t\tseen_zerolen;\n    regnode\t**open_parens;\t\t/* pointers to open parens */\n    regnode\t**close_parens;\t\t/* pointers to close parens */\n    regnode     *end_op;                /* END node in program */\n    I32\t\tutf8;\t\t/* whether the pattern is utf8 or not */\n    I32\t\torig_utf8;\t/* whether the pattern was originally in utf8 */\n\t\t\t\t/* XXX use this for future optimisation of case\n\t\t\t\t * where pattern must be upgraded to utf8. */\n    I32\t\tuni_semantics;\t/* If a d charset modifier should use unicode\n\t\t\t\t   rules, even if the pattern is not in\n\t\t\t\t   utf8 */\n    HV\t\t*paren_names;\t\t/* Paren names */\n\n    regnode\t**recurse;\t\t/* Recurse regops */\n    I32                recurse_count;                /* Number of recurse regops we have generated */\n    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved\n                                           through */\n    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */\n    I32\t\tin_lookbehind;\n    I32\t\tcontains_locale;\n    I32\t\toverride_recoding;\n#ifdef EBCDIC\n    I32\t\trecode_x_to_native;\n#endif\n    I32\t\tin_multi_char_class;\n    struct reg_code_blocks *code_blocks;/* positions of literal (?{})\n\t\t\t\t\t    within pattern */\n    int\t\tcode_index;\t\t/* next code_blocks[] slot */\n    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */\n    scan_frame *frame_head;\n    scan_frame *frame_last;\n    U32         frame_count;\n    AV         *warn_text;\n#ifdef ADD_TO_REGEXEC\n    char \t*starttry;\t\t/* -Dr: where regtry was called. */\n#define RExC_starttry\t(pRExC_state->starttry)\n#endif\n    SV\t\t*runtime_code_qr;\t/* qr with the runtime code blocks */\n#ifdef DEBUGGING\n    const char  *lastparse;\n    I32         lastnum;\n    AV          *paren_name_list;       /* idx -> name */\n    U32         study_chunk_recursed_count;\n    SV          *mysv1;\n    SV          *mysv2;\n#define RExC_lastparse\t(pRExC_state->lastparse)\n#define RExC_lastnum\t(pRExC_state->lastnum)\n#define RExC_paren_name_list    (pRExC_state->paren_name_list)\n#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)\n#define RExC_mysv\t(pRExC_state->mysv1)\n#define RExC_mysv1\t(pRExC_state->mysv1)\n#define RExC_mysv2\t(pRExC_state->mysv2)\n\n#endif\n    bool        seen_unfolded_sharp_s;\n    bool        strict;\n    bool        study_started;\n};\n\n#define RExC_flags\t(pRExC_state->flags)\n#define RExC_pm_flags\t(pRExC_state->pm_flags)\n#define RExC_precomp\t(pRExC_state->precomp)\n#define RExC_precomp_adj (pRExC_state->precomp_adj)\n#define RExC_adjusted_start  (pRExC_state->adjusted_start)\n#define RExC_precomp_end (pRExC_state->precomp_end)\n#define RExC_rx_sv\t(pRExC_state->rx_sv)\n#define RExC_rx\t\t(pRExC_state->rx)\n#define RExC_rxi\t(pRExC_state->rxi)\n#define RExC_start\t(pRExC_state->start)\n#define RExC_end\t(pRExC_state->end)\n#define RExC_parse\t(pRExC_state->parse)\n#define RExC_whilem_seen\t(pRExC_state->whilem_seen)\n\n/* Set during the sizing pass when there is a LATIN SMALL LETTER SHARP S in any\n * EXACTF node, hence was parsed under /di rules.  If later in the parse,\n * something forces the pattern into using /ui rules, the sharp s should be\n * folded into the sequence 'ss', which takes up more space than previously\n * calculated.  This means that the sizing pass needs to be restarted.  (The\n * node also becomes an EXACTFU_SS.)  For all other characters, an EXACTF node\n * that gets converted to /ui (and EXACTFU) occupies the same amount of space,\n * so there is no need to resize [perl #125990]. */\n#define RExC_seen_unfolded_sharp_s (pRExC_state->seen_unfolded_sharp_s)\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n#define RExC_offsets\t(pRExC_state->rxi->u.offsets) /* I am not like the\n                                                         others */\n#endif\n#define RExC_emit\t(pRExC_state->emit)\n#define RExC_emit_dummy\t(pRExC_state->emit_dummy)\n#define RExC_emit_start\t(pRExC_state->emit_start)\n#define RExC_emit_bound\t(pRExC_state->emit_bound)\n#define RExC_sawback\t(pRExC_state->sawback)\n#define RExC_seen\t(pRExC_state->seen)\n#define RExC_size\t(pRExC_state->size)\n#define RExC_maxlen        (pRExC_state->maxlen)\n#define RExC_npar\t(pRExC_state->npar)\n#define RExC_nestroot   (pRExC_state->nestroot)\n#define RExC_extralen\t(pRExC_state->extralen)\n#define RExC_seen_zerolen\t(pRExC_state->seen_zerolen)\n#define RExC_utf8\t(pRExC_state->utf8)\n#define RExC_uni_semantics\t(pRExC_state->uni_semantics)\n#define RExC_orig_utf8\t(pRExC_state->orig_utf8)\n#define RExC_open_parens\t(pRExC_state->open_parens)\n#define RExC_close_parens\t(pRExC_state->close_parens)\n#define RExC_end_op\t(pRExC_state->end_op)\n#define RExC_paren_names\t(pRExC_state->paren_names)\n#define RExC_recurse\t(pRExC_state->recurse)\n#define RExC_recurse_count\t(pRExC_state->recurse_count)\n#define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed)\n#define RExC_study_chunk_recursed_bytes  \\\n                                   (pRExC_state->study_chunk_recursed_bytes)\n#define RExC_in_lookbehind\t(pRExC_state->in_lookbehind)\n#define RExC_contains_locale\t(pRExC_state->contains_locale)\n#ifdef EBCDIC\n#   define RExC_recode_x_to_native (pRExC_state->recode_x_to_native)\n#endif\n#define RExC_in_multi_char_class (pRExC_state->in_multi_char_class)\n#define RExC_frame_head (pRExC_state->frame_head)\n#define RExC_frame_last (pRExC_state->frame_last)\n#define RExC_frame_count (pRExC_state->frame_count)\n#define RExC_strict (pRExC_state->strict)\n#define RExC_study_started      (pRExC_state->study_started)\n#define RExC_warn_text (pRExC_state->warn_text)\n\n/* Heuristic check on the complexity of the pattern: if TOO_NAUGHTY, we set\n * a flag to disable back-off on the fixed/floating substrings - if it's\n * a high complexity pattern we assume the benefit of avoiding a full match\n * is worth the cost of checking for the substrings even if they rarely help.\n */\n#define RExC_naughty\t(pRExC_state->naughty)\n#define TOO_NAUGHTY (10)\n#define MARK_NAUGHTY(add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += (add)\n#define MARK_NAUGHTY_EXP(exp, add) \\\n    if (RExC_naughty < TOO_NAUGHTY) \\\n        RExC_naughty += RExC_naughty / (exp) + (add)\n\n#define\tISMULT1(c)\t((c) == '*' || (c) == '+' || (c) == '?')\n#define\tISMULT2(s)\t((*s) == '*' || (*s) == '+' || (*s) == '?' || \\\n\t((*s) == '{' && regcurly(s)))\n\n/*\n * Flags to be passed up and down.\n */\n#define\tWORST\t\t0\t/* Worst case. */\n#define\tHASWIDTH\t0x01\t/* Known to match non-null strings. */\n\n/* Simple enough to be STAR/PLUS operand; in an EXACTish node must be a single\n * character.  (There needs to be a case: in the switch statement in regexec.c\n * for any node marked SIMPLE.)  Note that this is not the same thing as\n * REGNODE_SIMPLE */\n#define\tSIMPLE\t\t0x02\n#define\tSPSTART\t\t0x04\t/* Starts with * or + */\n#define POSTPONED\t0x08    /* (?1),(?&name), (??{...}) or similar */\n#define TRYAGAIN\t0x10\t/* Weeded out a declaration. */\n#define RESTART_PASS1   0x20    /* Need to restart sizing pass */\n#define NEED_UTF8       0x40    /* In conjunction with RESTART_PASS1, need to\n                                   calcuate sizes as UTF-8 */\n\n#define REG_NODE_NUM(x) ((x) ? (int)((x)-RExC_emit_start) : -1)\n\n/* whether trie related optimizations are enabled */\n#if PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION\n#define TRIE_STUDY_OPT\n#define FULL_TRIE_STUDY\n#define TRIE_STCLASS\n#endif\n\n\n\n#define PBYTE(u8str,paren) ((U8*)(u8str))[(paren) >> 3]\n#define PBITVAL(paren) (1 << ((paren) & 7))\n#define PAREN_TEST(u8str,paren) ( PBYTE(u8str,paren) & PBITVAL(paren))\n#define PAREN_SET(u8str,paren) PBYTE(u8str,paren) |= PBITVAL(paren)\n#define PAREN_UNSET(u8str,paren) PBYTE(u8str,paren) &= (~PBITVAL(paren))\n\n#define REQUIRE_UTF8(flagp) STMT_START {                                   \\\n                                     if (!UTF) {                           \\\n                                         assert(PASS1);                    \\\n                                         *flagp = RESTART_PASS1|NEED_UTF8; \\\n                                         return NULL;                      \\\n                                     }                                     \\\n                             } STMT_END\n\n/* Change from /d into /u rules, and restart the parse if we've already seen\n * something whose size would increase as a result, by setting *flagp and\n * returning 'restart_retval'.  RExC_uni_semantics is a flag that indicates\n * we've change to /u during the parse.  */\n#define REQUIRE_UNI_RULES(flagp, restart_retval)                            \\\n    STMT_START {                                                            \\\n            if (DEPENDS_SEMANTICS) {                                        \\\n                assert(PASS1);                                              \\\n                set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);      \\\n                RExC_uni_semantics = 1;                                     \\\n                if (RExC_seen_unfolded_sharp_s) {                           \\\n                    *flagp |= RESTART_PASS1;                                \\\n                    return restart_retval;                                  \\\n                }                                                           \\\n            }                                                               \\\n    } STMT_END\n\n/* This converts the named class defined in regcomp.h to its equivalent class\n * number defined in handy.h. */\n#define namedclass_to_classnum(class)  ((int) ((class) / 2))\n#define classnum_to_namedclass(classnum)  ((classnum) * 2)\n\n#define _invlist_union_complement_2nd(a, b, output) \\\n                        _invlist_union_maybe_complement_2nd(a, b, TRUE, output)\n#define _invlist_intersection_complement_2nd(a, b, output) \\\n                 _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)\n\n/* About scan_data_t.\n\n  During optimisation we recurse through the regexp program performing\n  various inplace (keyhole style) optimisations. In addition study_chunk\n  and scan_commit populate this data structure with information about\n  what strings MUST appear in the pattern. We look for the longest\n  string that must appear at a fixed location, and we look for the\n  longest string that may appear at a floating location. So for instance\n  in the pattern:\n\n    /FOO[xX]A.*B[xX]BAR/\n\n  Both 'FOO' and 'A' are fixed strings. Both 'B' and 'BAR' are floating\n  strings (because they follow a .* construct). study_chunk will identify\n  both FOO and BAR as being the longest fixed and floating strings respectively.\n\n  The strings can be composites, for instance\n\n     /(f)(o)(o)/\n\n  will result in a composite fixed substring 'foo'.\n\n  For each string some basic information is maintained:\n\n  - min_offset\n    This is the position the string must appear at, or not before.\n    It also implicitly (when combined with minlenp) tells us how many\n    characters must match before the string we are searching for.\n    Likewise when combined with minlenp and the length of the string it\n    tells us how many characters must appear after the string we have\n    found.\n\n  - max_offset\n    Only used for floating strings. This is the rightmost point that\n    the string can appear at. If set to SSize_t_MAX it indicates that the\n    string can occur infinitely far to the right.\n    For fixed strings, it is equal to min_offset.\n\n  - minlenp\n    A pointer to the minimum number of characters of the pattern that the\n    string was found inside. This is important as in the case of positive\n    lookahead or positive lookbehind we can have multiple patterns\n    involved. Consider\n\n    /(?=FOO).*F/\n\n    The minimum length of the pattern overall is 3, the minimum length\n    of the lookahead part is 3, but the minimum length of the part that\n    will actually match is 1. So 'FOO's minimum length is 3, but the\n    minimum length for the F is 1. This is important as the minimum length\n    is used to determine offsets in front of and behind the string being\n    looked for.  Since strings can be composites this is the length of the\n    pattern at the time it was committed with a scan_commit. Note that\n    the length is calculated by study_chunk, so that the minimum lengths\n    are not known until the full pattern has been compiled, thus the\n    pointer to the value.\n\n  - lookbehind\n\n    In the case of lookbehind the string being searched for can be\n    offset past the start point of the final matching string.\n    If this value was just blithely removed from the min_offset it would\n    invalidate some of the calculations for how many chars must match\n    before or after (as they are derived from min_offset and minlen and\n    the length of the string being searched for).\n    When the final pattern is compiled and the data is moved from the\n    scan_data_t structure into the regexp structure the information\n    about lookbehind is factored in, with the information that would\n    have been lost precalculated in the end_shift field for the\n    associated string.\n\n  The fields pos_min and pos_delta are used to store the minimum offset\n  and the delta to the maximum offset at the current point in the pattern.\n\n*/\n\nstruct scan_data_substrs {\n    SV      *str;       /* longest substring found in pattern */\n    SSize_t min_offset; /* earliest point in string it can appear */\n    SSize_t max_offset; /* latest point in string it can appear */\n    SSize_t *minlenp;   /* pointer to the minlen relevant to the string */\n    SSize_t lookbehind; /* is the pos of the string modified by LB */\n    I32 flags;          /* per substring SF_* and SCF_* flags */\n};\n\ntypedef struct scan_data_t {\n    /*I32 len_min;      unused */\n    /*I32 len_delta;    unused */\n    SSize_t pos_min;\n    SSize_t pos_delta;\n    SV *last_found;\n    SSize_t last_end;\t    /* min value, <0 unless valid. */\n    SSize_t last_start_min;\n    SSize_t last_start_max;\n    U8      cur_is_floating; /* whether the last_* values should be set as\n                              * the next fixed (0) or floating (1)\n                              * substring */\n\n    /* [0] is longest fixed substring so far, [1] is longest float so far */\n    struct scan_data_substrs  substrs[2];\n\n    I32 flags;             /* common SF_* and SCF_* flags */\n    I32 whilem_c;\n    SSize_t *last_closep;\n    regnode_ssc *start_class;\n} scan_data_t;\n\n/*\n * Forward declarations for pregcomp()'s friends.\n */\n\nstatic const scan_data_t zero_scan_data = {\n    0, 0, NULL, 0, 0, 0, 0,\n    {\n        { NULL, 0, 0, 0, 0, 0 },\n        { NULL, 0, 0, 0, 0, 0 },\n    },\n    0, 0, NULL, NULL\n};\n\n/* study flags */\n\n#define SF_BEFORE_SEOL\t\t0x0001\n#define SF_BEFORE_MEOL\t\t0x0002\n#define SF_BEFORE_EOL\t\t(SF_BEFORE_SEOL|SF_BEFORE_MEOL)\n\n#define SF_IS_INF\t\t0x0040\n#define SF_HAS_PAR\t\t0x0080\n#define SF_IN_PAR\t\t0x0100\n#define SF_HAS_EVAL\t\t0x0200\n\n\n/* SCF_DO_SUBSTR is the flag that tells the regexp analyzer to track the\n * longest substring in the pattern. When it is not set the optimiser keeps\n * track of position, but does not keep track of the actual strings seen,\n *\n * So for instance /foo/ will be parsed with SCF_DO_SUBSTR being true, but\n * /foo/i will not.\n *\n * Similarly, /foo.*(blah|erm|huh).*fnorble/ will have \"foo\" and \"fnorble\"\n * parsed with SCF_DO_SUBSTR on, but while processing the (...) it will be\n * turned off because of the alternation (BRANCH). */\n#define SCF_DO_SUBSTR\t\t0x0400\n\n#define SCF_DO_STCLASS_AND\t0x0800\n#define SCF_DO_STCLASS_OR\t0x1000\n#define SCF_DO_STCLASS\t\t(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR)\n#define SCF_WHILEM_VISITED_POS\t0x2000\n\n#define SCF_TRIE_RESTUDY        0x4000 /* Do restudy? */\n#define SCF_SEEN_ACCEPT         0x8000\n#define SCF_TRIE_DOING_RESTUDY 0x10000\n#define SCF_IN_DEFINE          0x20000\n\n\n\n\n#define UTF cBOOL(RExC_utf8)\n\n/* The enums for all these are ordered so things work out correctly */\n#define LOC (get_regex_charset(RExC_flags) == REGEX_LOCALE_CHARSET)\n#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags)                    \\\n                                                     == REGEX_DEPENDS_CHARSET)\n#define UNI_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_UNICODE_CHARSET)\n#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags)                \\\n                                                     >= REGEX_UNICODE_CHARSET)\n#define ASCII_RESTRICTED (get_regex_charset(RExC_flags)                      \\\n                                            == REGEX_ASCII_RESTRICTED_CHARSET)\n#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags)             \\\n                                            >= REGEX_ASCII_RESTRICTED_CHARSET)\n#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags)                 \\\n                                        == REGEX_ASCII_MORE_RESTRICTED_CHARSET)\n\n#define FOLD cBOOL(RExC_flags & RXf_PMf_FOLD)\n\n/* For programs that want to be strictly Unicode compatible by dying if any\n * attempt is made to match a non-Unicode code point against a Unicode\n * property.  */\n#define ALWAYS_WARN_SUPER  ckDEAD(packWARN(WARN_NON_UNICODE))\n\n#define OOB_NAMEDCLASS\t\t-1\n\n/* There is no code point that is out-of-bounds, so this is problematic.  But\n * its only current use is to initialize a variable that is always set before\n * looked at. */\n#define OOB_UNICODE\t\t0xDEADBEEF\n\n#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))\n\n\n/* length of regex to show in messages that don't mark a position within */\n#define RegexLengthToShowInErrorMessages 127\n\n/*\n * If MARKER[12] are adjusted, be sure to adjust the constants at the top\n * of t/op/regmesg.t, the tests in t/op/re_tests, and those in\n * op/pragma/warn/regcomp.\n */\n#define MARKER1 \"<-- HERE\"    /* marker as it appears in the description */\n#define MARKER2 \" <-- HERE \"  /* marker as it appears within the regex */\n\n#define REPORT_LOCATION \" in regex; marked by \" MARKER1    \\\n                        \" in m/%\" UTF8f MARKER2 \"%\" UTF8f \"/\"\n\n/* The code in this file in places uses one level of recursion with parsing\n * rebased to an alternate string constructed by us in memory.  This can take\n * the form of something that is completely different from the input, or\n * something that uses the input as part of the alternate.  In the first case,\n * there should be no possibility of an error, as we are in complete control of\n * the alternate string.  But in the second case we don't control the input\n * portion, so there may be errors in that.  Here's an example:\n *      /[abc\\x{DF}def]/ui\n * is handled specially because \\x{df} folds to a sequence of more than one\n * character, 'ss'.  What is done is to create and parse an alternate string,\n * which looks like this:\n *      /(?:\\x{DF}|[abc\\x{DF}def])/ui\n * where it uses the input unchanged in the middle of something it constructs,\n * which is a branch for the DF outside the character class, and clustering\n * parens around the whole thing. (It knows enough to skip the DF inside the\n * class while in this substitute parse.) 'abc' and 'def' may have errors that\n * need to be reported.  The general situation looks like this:\n *\n *              sI                       tI               xI       eI\n * Input:       ----------------------------------------------------\n * Constructed:         ---------------------------------------------------\n *                      sC               tC               xC       eC     EC\n *\n * The input string sI..eI is the input pattern.  The string sC..EC is the\n * constructed substitute parse string.  The portions sC..tC and eC..EC are\n * constructed by us.  The portion tC..eC is an exact duplicate of the input\n * pattern tI..eI.  In the diagram, these are vertically aligned.  Suppose that\n * while parsing, we find an error at xC.  We want to display a message showing\n * the real input string.  Thus we need to find the point xI in it which\n * corresponds to xC.  xC >= tC, since the portion of the string sC..tC has\n * been constructed by us, and so shouldn't have errors.  We get:\n *\n *      xI = sI + (tI - sI) + (xC - tC)\n *\n * and, the offset into sI is:\n *\n *      (xI - sI) = (tI - sI) + (xC - tC)\n *\n * When the substitute is constructed, we save (tI -sI) as RExC_precomp_adj,\n * and we save tC as RExC_adjusted_start.\n *\n * During normal processing of the input pattern, everything points to that,\n * with RExC_precomp_adj set to 0, and RExC_adjusted_start set to sI.\n */\n\n#define tI_sI           RExC_precomp_adj\n#define tC              RExC_adjusted_start\n#define sC              RExC_precomp\n#define xI_offset(xC)   ((IV) (tI_sI + (xC - tC)))\n#define xI(xC)          (sC + xI_offset(xC))\n#define eC              RExC_precomp_end\n\n#define REPORT_LOCATION_ARGS(xC)                                            \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eC) /* Don't run off end */                          \\\n              ? eC - sC   /* Length before the <--HERE */                   \\\n              : ( __ASSERT_(xI_offset(xC) >= 0) xI_offset(xC) ),            \\\n             sC),         /* The input pattern printed up to the <--HERE */ \\\n    UTF8fARG(UTF,                                                           \\\n             (xI(xC) > eC) ? 0 : eC - xI(xC), /* Length after <--HERE */    \\\n             (xI(xC) > eC) ? eC : xI(xC))     /* pattern after <--HERE */\n\n/* Used to point after bad bytes for an error message, but avoid skipping\n * past a nul byte. */\n#define SKIP_IF_CHAR(s) (!*(s) ? 0 : UTF ? UTF8SKIP(s) : 1)\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given\n * arg. Show regex, up to a maximum length. If it's too long, chop and add\n * \"...\".\n */\n#define _FAIL(code) STMT_START {\t\t\t\t\t\\\n    const char *ellipses = \"\";\t\t\t\t\t\t\\\n    IV len = RExC_precomp_end - RExC_precomp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\t\t\\\n    if (len > RegexLengthToShowInErrorMessages) {\t\t\t\\\n\t/* chop 10 shorter than the max, to ensure meaning of \"...\" */\t\\\n\tlen = RegexLengthToShowInErrorMessages - 10;\t\t\t\\\n\tellipses = \"...\";\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    code;                                                               \\\n} STMT_END\n\n#define\tFAIL(msg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ \"%s in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n#define\tFAIL2(msg,arg) _FAIL(\t\t\t    \\\n    Perl_croak(aTHX_ msg \" in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    arg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n\n/*\n * Simple_vFAIL -- like FAIL, but marks the current location in the scan\n */\n#define\tSimple_vFAIL(m) STMT_START {\t\t\t\t\t\\\n    Perl_croak(aTHX_ \"%s\" REPORT_LOCATION,\t\t\t\t\\\n\t    m, REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL()\n */\n#define\tvFAIL(m) STMT_START {\t\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL(m);\t\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts two arguments.\n */\n#define\tSimple_vFAIL2(m,a1) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,\t\t\\\n                      REPORT_LOCATION_ARGS(RExC_parse));\t\\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL2().\n */\n#define\tvFAIL2(m,a1) STMT_START {\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL2(m, a1);\t\t\t\t\\\n} STMT_END\n\n\n/*\n * Like Simple_vFAIL(), but accepts three arguments.\n */\n#define\tSimple_vFAIL3(m, a1, a2) STMT_START {\t\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,\t\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n/*\n * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL3().\n */\n#define\tvFAIL3(m,a1,a2) STMT_START {\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL3(m, a1, a2);\t\t\t\t\\\n} STMT_END\n\n/*\n * Like Simple_vFAIL(), but accepts four arguments.\n */\n#define\tSimple_vFAIL4(m, a1, a2, a3) STMT_START {\t\t\\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,\t\\\n\t    REPORT_LOCATION_ARGS(RExC_parse));\t                \\\n} STMT_END\n\n#define\tvFAIL4(m,a1,a2,a3) STMT_START {\t\t\t\\\n    if (!SIZE_ONLY)\t\t\t\t\t\\\n\tSAVEFREESV(RExC_rx_sv);\t\t\t\t\\\n    Simple_vFAIL4(m, a1, a2, a3);\t\t\t\\\n} STMT_END\n\n/* A specialized version of vFAIL2 that works with UTF8f */\n#define vFAIL2utf8f(m, a1) STMT_START {             \\\n    if (!SIZE_ONLY)                                 \\\n        SAVEFREESV(RExC_rx_sv);                     \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));      \\\n} STMT_END\n\n#define vFAIL3utf8f(m, a1, a2) STMT_START {             \\\n    if (!SIZE_ONLY)                                     \\\n        SAVEFREESV(RExC_rx_sv);                         \\\n    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,  \\\n            REPORT_LOCATION_ARGS(RExC_parse));          \\\n} STMT_END\n\n/* These have asserts in them because of [perl #122671] Many warnings in\n * regcomp.c can occur twice.  If they get output in pass1 and later in that\n * pass, the pattern has to be converted to UTF-8 and the pass restarted, they\n * would get output again.  So they should be output in pass2, and these\n * asserts make sure new warnings follow that paradigm. */\n\n/* m is not necessarily a \"literal string\", in this macro */\n#define reg_warn_non_literal_string(loc, m) STMT_START {                \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       \"%s\" REPORT_LOCATION,            \\\n                                  m, REPORT_LOCATION_ARGS(loc));        \\\n} STMT_END\n\n#define\tckWARNreg(loc,m) STMT_START {\t\t\t\t\t\\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \\\n                                          m REPORT_LOCATION,\t        \\\n\t                                  REPORT_LOCATION_ARGS(loc));   \\\n} STMT_END\n\n#define\tvWARN(loc, m) STMT_START {\t\t\t\t        \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       m REPORT_LOCATION,               \\\n                                       REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n#define\tvWARN_dep(loc, m) STMT_START {\t\t\t\t        \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),       \\\n                                       m REPORT_LOCATION,               \\\n\t                               REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n#define\tckWARNdep(loc,m) STMT_START {\t\t\t\t        \\\n    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),  \\\n\t                                    m REPORT_LOCATION,          \\\n\t                                    REPORT_LOCATION_ARGS(loc)); \\\n} STMT_END\n\n#define\tckWARNregdep(loc,m) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,      \\\n                                                      WARN_REGEXP),         \\\n\t                                     m REPORT_LOCATION,             \\\n\t                                     REPORT_LOCATION_ARGS(loc));    \\\n} STMT_END\n\n#define\tckWARN2reg_d(loc,m, a1) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),          \\\n\t                                    m REPORT_LOCATION,              \\\n\t                                    a1, REPORT_LOCATION_ARGS(loc)); \\\n} STMT_END\n\n#define\tckWARN2reg(loc, m, a1) STMT_START {                                 \\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \\\n                                          m REPORT_LOCATION,\t            \\\n                                          a1, REPORT_LOCATION_ARGS(loc));   \\\n} STMT_END\n\n#define\tvWARN3(loc, m, a1, a2) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),               \\\n                                       m REPORT_LOCATION,                   \\\n\t                               a1, a2, REPORT_LOCATION_ARGS(loc));  \\\n} STMT_END\n\n#define\tckWARN3reg(loc, m, a1, a2) STMT_START {\t\t\t\t    \\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \\\n                                          m REPORT_LOCATION,                \\\n\t                                  a1, a2,                           \\\n                                          REPORT_LOCATION_ARGS(loc));       \\\n} STMT_END\n\n#define\tvWARN4(loc, m, a1, a2, a3) STMT_START {\t\t\t\t\\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       m REPORT_LOCATION,               \\\n\t                               a1, a2, a3,                      \\\n                                       REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n#define\tckWARN4reg(loc, m, a1, a2, a3) STMT_START {\t\t\t\\\n    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \\\n                                          m REPORT_LOCATION,            \\\n\t                                  a1, a2, a3,                   \\\n                                          REPORT_LOCATION_ARGS(loc));   \\\n} STMT_END\n\n#define\tvWARN5(loc, m, a1, a2, a3, a4) STMT_START {\t\t\t\\\n    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \\\n                                       m REPORT_LOCATION,\t\t\\\n\t                               a1, a2, a3, a4,                  \\\n                                       REPORT_LOCATION_ARGS(loc));      \\\n} STMT_END\n\n/* Macros for recording node offsets.   20001227 mjd@plover.com\n * Nodes are numbered 1, 2, 3, 4.  Node #n's position is recorded in\n * element 2*n-1 of the array.  Element #2n holds the byte length node #n.\n * Element 0 holds the number n.\n * Position is 1 indexed.\n */\n#ifndef RE_TRACK_PATTERN_OFFSETS\n#define Set_Node_Offset_To_R(node,byte)\n#define Set_Node_Offset(node,byte)\n#define Set_Cur_Node_Offset\n#define Set_Node_Length_To_R(node,len)\n#define Set_Node_Length(node,len)\n#define Set_Node_Cur_Length(node,start)\n#define Node_Offset(n)\n#define Node_Length(n)\n#define Set_Node_Offset_Length(node,offset,len)\n#define ProgLen(ri) ri->u.proglen\n#define SetProgLen(ri,x) ri->u.proglen = x\n#else\n#define ProgLen(ri) ri->u.offsets[0]\n#define SetProgLen(ri,x) ri->u.offsets[0] = x\n#define Set_Node_Offset_To_R(node,byte) STMT_START {\t\t\t\\\n    if (! SIZE_ONLY) {\t\t\t\t\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) offset of node %d is %d.\\n\",\t\t\\\n\t\t    __LINE__, (int)(node), (int)(byte)));\t\t\\\n\tif((node) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Offset macro\",     \\\n                                         (int)(node));                  \\\n\t} else {\t\t\t\t\t\t\t\\\n\t    RExC_offsets[2*(node)-1] = (byte);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Offset(node,byte) \\\n    Set_Node_Offset_To_R((node)-RExC_emit_start, (byte)-RExC_start)\n#define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)\n\n#define Set_Node_Length_To_R(node,len) STMT_START {\t\t\t\\\n    if (! SIZE_ONLY) {\t\t\t\t\t\t\t\\\n\tMJD_OFFSET_DEBUG((\"** (%d) size of node %d is %d.\\n\",\t\t\\\n\t\t__LINE__, (int)(node), (int)(len)));\t\t\t\\\n\tif((node) < 0) {\t\t\t\t\t\t\\\n\t    Perl_croak(aTHX_ \"value of node is %d in Length macro\",     \\\n                                         (int)(node));                  \\\n\t} else {\t\t\t\t\t\t\t\\\n\t    RExC_offsets[2*(node)] = (len);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} STMT_END\n\n#define Set_Node_Length(node,len) \\\n    Set_Node_Length_To_R((node)-RExC_emit_start, len)\n#define Set_Node_Cur_Length(node, start)                \\\n    Set_Node_Length(node, RExC_parse - start)\n\n/* Get offsets and lengths */\n#define Node_Offset(n) (RExC_offsets[2*((n)-RExC_emit_start)-1])\n#define Node_Length(n) (RExC_offsets[2*((n)-RExC_emit_start)])\n\n#define Set_Node_Offset_Length(node,offset,len) STMT_START {\t\\\n    Set_Node_Offset_To_R((node)-RExC_emit_start, (offset));\t\\\n    Set_Node_Length_To_R((node)-RExC_emit_start, (len));\t\\\n} STMT_END\n#endif\n\n#if PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS\n#define EXPERIMENTAL_INPLACESCAN\n#endif /*PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS*/\n\n#ifdef DEBUGGING\nint\nPerl_re_printf(pTHX_ const char *fmt, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_PRINTF;\n    va_start(ap, fmt);\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n\nint\nPerl_re_indentf(pTHX_ const char *fmt, U32 depth, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_INDENTF;\n    va_start(ap, depth);\n    PerlIO_printf(f, \"%*s\", ( (int)depth % 20 ) * 2, \"\");\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;\n}\n#endif /* DEBUGGING */\n\n#define DEBUG_RExC_seen()                                                   \\\n        DEBUG_OPTIMISE_MORE_r({                                             \\\n            Perl_re_printf( aTHX_ \"RExC_seen: \");                                       \\\n                                                                            \\\n            if (RExC_seen & REG_ZERO_LEN_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_ZERO_LEN_SEEN \");                            \\\n                                                                            \\\n            if (RExC_seen & REG_LOOKBEHIND_SEEN)                            \\\n                Perl_re_printf( aTHX_ \"REG_LOOKBEHIND_SEEN \");                          \\\n                                                                            \\\n            if (RExC_seen & REG_GPOS_SEEN)                                  \\\n                Perl_re_printf( aTHX_ \"REG_GPOS_SEEN \");                                \\\n                                                                            \\\n            if (RExC_seen & REG_RECURSE_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_RECURSE_SEEN \");                             \\\n                                                                            \\\n            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                    \\\n                Perl_re_printf( aTHX_ \"REG_TOP_LEVEL_BRANCHES_SEEN \");                  \\\n                                                                            \\\n            if (RExC_seen & REG_VERBARG_SEEN)                               \\\n                Perl_re_printf( aTHX_ \"REG_VERBARG_SEEN \");                             \\\n                                                                            \\\n            if (RExC_seen & REG_CUTGROUP_SEEN)                              \\\n                Perl_re_printf( aTHX_ \"REG_CUTGROUP_SEEN \");                            \\\n                                                                            \\\n            if (RExC_seen & REG_RUN_ON_COMMENT_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_RUN_ON_COMMENT_SEEN \");                      \\\n                                                                            \\\n            if (RExC_seen & REG_UNFOLDED_MULTI_SEEN)                        \\\n                Perl_re_printf( aTHX_ \"REG_UNFOLDED_MULTI_SEEN \");                      \\\n                                                                            \\\n            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                  \\\n                Perl_re_printf( aTHX_ \"REG_UNBOUNDED_QUANTIFIER_SEEN \");                \\\n                                                                            \\\n            Perl_re_printf( aTHX_ \"\\n\");                                                \\\n        });\n\n#define DEBUG_SHOW_STUDY_FLAG(flags,flag) \\\n  if ((flags) & flag) Perl_re_printf( aTHX_  \"%s \", #flag)\n\n\n#ifdef DEBUGGING\nstatic void\nS_debug_show_study_flags(pTHX_ U32 flags, const char *open_str,\n                                    const char *close_str)\n{\n    if (!flags)\n        return;\n\n    Perl_re_printf( aTHX_  \"%s\", open_str);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_SEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_BEFORE_MEOL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IS_INF);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_IN_PAR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SF_HAS_EVAL);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_SUBSTR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_AND);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS_OR);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_DO_STCLASS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_WHILEM_VISITED_POS);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_SEEN_ACCEPT);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_TRIE_DOING_RESTUDY);\n    DEBUG_SHOW_STUDY_FLAG(flags, SCF_IN_DEFINE);\n    Perl_re_printf( aTHX_  \"%s\", close_str);\n}\n\n\nstatic void\nS_debug_studydata(pTHX_ const char *where, scan_data_t *data,\n                    U32 depth, int is_inf)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_MORE_r({\n        if (!data)\n            return;\n        Perl_re_indentf(aTHX_  \"%s: Pos:%\" IVdf \"/%\" IVdf \" Flags: 0x%\" UVXf,\n            depth,\n            where,\n            (IV)data->pos_min,\n            (IV)data->pos_delta,\n            (UV)data->flags\n        );\n\n        S_debug_show_study_flags(aTHX_ data->flags,\" [\",\"]\");\n\n        Perl_re_printf( aTHX_\n            \" Whilem_c: %\" IVdf \" Lcp: %\" IVdf \" %s\",\n            (IV)data->whilem_c,\n            (IV)(data->last_closep ? *((data)->last_closep) : -1),\n            is_inf ? \"INF \" : \"\"\n        );\n\n        if (data->last_found) {\n            int i;\n            Perl_re_printf(aTHX_\n                \"Last:'%s' %\" IVdf \":%\" IVdf \"/%\" IVdf,\n                    SvPVX_const(data->last_found),\n                    (IV)data->last_end,\n                    (IV)data->last_start_min,\n                    (IV)data->last_start_max\n            );\n\n            for (i = 0; i < 2; i++) {\n                Perl_re_printf(aTHX_\n                    \" %s%s: '%s' @ %\" IVdf \"/%\" IVdf,\n                    data->cur_is_floating == i ? \"*\" : \"\",\n                    i ? \"Float\" : \"Fixed\",\n                    SvPVX_const(data->substrs[i].str),\n                    (IV)data->substrs[i].min_offset,\n                    (IV)data->substrs[i].max_offset\n                );\n                S_debug_show_study_flags(aTHX_ data->substrs[i].flags,\" [\",\"]\");\n            }\n        }\n\n        Perl_re_printf( aTHX_ \"\\n\");\n    });\n}\n\n\nstatic void\nS_debug_peep(pTHX_ const char *str, const RExC_state_t *pRExC_state,\n                regnode *scan, U32 depth, U32 flags)\n{\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_OPTIMISE_r({\n        regnode *Next;\n\n        if (!scan)\n            return;\n        Next = regnext(scan);\n        regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n        Perl_re_indentf( aTHX_   \"%s>%3d: %s (%d)\",\n            depth,\n            str,\n            REG_NODE_NUM(scan), SvPV_nolen_const(RExC_mysv),\n            Next ? (REG_NODE_NUM(Next)) : 0 );\n        S_debug_show_study_flags(aTHX_ flags,\" [ \",\"]\");\n        Perl_re_printf( aTHX_  \"\\n\");\n   });\n}\n\n\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) \\\n                    S_debug_studydata(aTHX_ where, data, depth, is_inf)\n\n#  define DEBUG_PEEP(str, scan, depth, flags)   \\\n                    S_debug_peep(aTHX_ str, pRExC_state, scan, depth, flags)\n\n#else\n#  define DEBUG_STUDYDATA(where, data, depth, is_inf) NOOP\n#  define DEBUG_PEEP(str, scan, depth, flags)         NOOP\n#endif\n\n\n/* =========================================================\n * BEGIN edit_distance stuff.\n *\n * This calculates how many single character changes of any type are needed to\n * transform a string into another one.  It is taken from version 3.1 of\n *\n * https://metacpan.org/pod/Text::Levenshtein::Damerau::XS\n */\n\n/* Our unsorted dictionary linked list.   */\n/* Note we use UVs, not chars. */\n\nstruct dictionary{\n  UV key;\n  UV value;\n  struct dictionary* next;\n};\ntypedef struct dictionary item;\n\n\nPERL_STATIC_INLINE item*\npush(UV key,item* curr)\n{\n    item* head;\n    Newx(head, 1, item);\n    head->key = key;\n    head->value = 0;\n    head->next = curr;\n    return head;\n}\n\n\nPERL_STATIC_INLINE item*\nfind(item* head, UV key)\n{\n    item* iterator = head;\n    while (iterator){\n        if (iterator->key == key){\n            return iterator;\n        }\n        iterator = iterator->next;\n    }\n\n    return NULL;\n}\n\nPERL_STATIC_INLINE item*\nuniquePush(item* head,UV key)\n{\n    item* iterator = head;\n\n    while (iterator){\n        if (iterator->key == key) {\n            return head;\n        }\n        iterator = iterator->next;\n    }\n\n    return push(key,head);\n}\n\nPERL_STATIC_INLINE void\ndict_free(item* head)\n{\n    item* iterator = head;\n\n    while (iterator) {\n        item* temp = iterator;\n        iterator = iterator->next;\n        Safefree(temp);\n    }\n\n    head = NULL;\n}\n\n/* End of Dictionary Stuff */\n\n/* All calculations/work are done here */\nSTATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             /* length of src[] */\n                const STRLEN y,             /* length of tgt[] */\n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount,swapScore,targetCharCount,i,j;\n    UV *scores;\n    UV score_ceil = x + y;\n\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n\n    /* intialize matrix start values */\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head,src[0]),tgt[0]);\n\n    /* work loops    */\n    /* i = src index */\n    /* j = tgt index */\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head,src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head,tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n\n            targetCharCount = find(head,tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n\n        find(head,src[i-1])->value = i;\n    }\n\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }\n}\n\n/* END of edit_distance() stuff\n * ========================================================= */\n\n/* is c a control character for which we have a mnemonic? */\n#define isMNEMONIC_CNTRL(c) _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)\n\nSTATIC const char *\nS_cntrl_to_mnemonic(const U8 c)\n{\n    /* Returns the mnemonic string that represents character 'c', if one\n     * exists; NULL otherwise.  The only ones that exist for the purposes of\n     * this routine are a few control characters */\n\n    switch (c) {\n        case '\\a':       return \"\\\\a\";\n        case '\\b':       return \"\\\\b\";\n        case ESC_NATIVE: return \"\\\\e\";\n        case '\\f':       return \"\\\\f\";\n        case '\\n':       return \"\\\\n\";\n        case '\\r':       return \"\\\\r\";\n        case '\\t':       return \"\\\\t\";\n    }\n\n    return NULL;\n}\n\n/* Mark that we cannot extend a found fixed substring at this point.\n   Update the longest found anchored substring or the longest found\n   floating substrings if needed. */\n\nSTATIC void\nS_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data,\n                    SSize_t *minlenp, int is_inf)\n{\n    const STRLEN l = CHR_SVLEN(data->last_found);\n    SV * const longest_sv = data->substrs[data->cur_is_floating].str;\n    const STRLEN old_l = CHR_SVLEN(longest_sv);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_SCAN_COMMIT;\n\n    if ((l >= old_l) && ((l > old_l) || (data->flags & SF_BEFORE_EOL))) {\n        const U8 i = data->cur_is_floating;\n\tSvSetMagicSV(longest_sv, data->last_found);\n        data->substrs[i].min_offset = l ? data->last_start_min : data->pos_min;\n\n\tif (!i) /* fixed */\n\t    data->substrs[0].max_offset = data->substrs[0].min_offset;\n\telse { /* float */\n\t    data->substrs[1].max_offset = (l\n                          ? data->last_start_max\n                          : (data->pos_delta > SSize_t_MAX - data->pos_min\n\t\t\t\t\t ? SSize_t_MAX\n\t\t\t\t\t : data->pos_min + data->pos_delta));\n\t    if (is_inf\n\t\t || (STRLEN)data->substrs[1].max_offset > (STRLEN)SSize_t_MAX)\n\t\tdata->substrs[1].max_offset = SSize_t_MAX;\n        }\n\n        if (data->flags & SF_BEFORE_EOL)\n            data->substrs[i].flags |= (data->flags & SF_BEFORE_EOL);\n        else\n            data->substrs[i].flags &= ~SF_BEFORE_EOL;\n        data->substrs[i].minlenp = minlenp;\n        data->substrs[i].lookbehind = 0;\n    }\n\n    SvCUR_set(data->last_found, 0);\n    {\n\tSV * const sv = data->last_found;\n\tif (SvUTF8(sv) && SvMAGICAL(sv)) {\n\t    MAGIC * const mg = mg_find(sv, PERL_MAGIC_utf8);\n\t    if (mg)\n\t\tmg->mg_len = 0;\n\t}\n    }\n    data->last_end = -1;\n    data->flags &= ~SF_BEFORE_EOL;\n    DEBUG_STUDYDATA(\"commit\", data, 0, is_inf);\n}\n\n/* An SSC is just a regnode_charclass_posix with an extra field: the inversion\n * list that describes which code points it matches */\n\nSTATIC void\nS_ssc_anything(pTHX_ regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to match an empty string or any code point */\n\n    PERL_ARGS_ASSERT_SSC_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* mortalize so won't leak */\n    ssc->invlist = sv_2mortal(_add_range_to_invlist(NULL, 0, UV_MAX));\n    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;  /* Plus matches empty */\n}\n\nSTATIC int\nS_ssc_is_anything(const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' can match the empty string and any code\n     * point; FALSE otherwise.  Thus, this is used to see if using 'ssc' buys\n     * us anything: if the function returns TRUE, 'ssc' hasn't been restricted\n     * in any way, so there's no point in using it */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    if (! (ANYOF_FLAGS(ssc) & SSC_MATCHES_EMPTY_STRING)) {\n        return FALSE;\n    }\n\n    /* See if the list consists solely of the range 0 - Infinity */\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (ret) {\n        return TRUE;\n    }\n\n    /* If e.g., both \\w and \\W are set, matches everything */\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        int i;\n        for (i = 0; i < ANYOF_POSIXL_MAX; i += 2) {\n            if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i+1)) {\n                return TRUE;\n            }\n        }\n    }\n\n    return FALSE;\n}\n\nSTATIC void\nS_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* Initializes the SSC 'ssc'.  This includes setting it to match an empty\n     * string, any code point, or any posix class under locale */\n\n    PERL_ARGS_ASSERT_SSC_INIT;\n\n    Zero(ssc, 1, regnode_ssc);\n    set_ANYOF_SYNTHETIC(ssc);\n    ARG_SET(ssc, ANYOF_ONLY_HAS_BITMAP);\n    ssc_anything(ssc);\n\n    /* If any portion of the regex is to operate under locale rules that aren't\n     * fully known at compile time, initialization includes it.  The reason\n     * this isn't done for all regexes is that the optimizer was written under\n     * the assumption that locale was all-or-nothing.  Given the complexity and\n     * lack of documentation in the optimizer, and that there are inadequate\n     * test cases for locale, many parts of it may not work properly, it is\n     * safest to avoid locale unless necessary. */\n    if (RExC_contains_locale) {\n\tANYOF_POSIXL_SETALL(ssc);\n    }\n    else {\n\tANYOF_POSIXL_ZERO(ssc);\n    }\n}\n\nSTATIC int\nS_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state,\n                        const regnode_ssc *ssc)\n{\n    /* Returns TRUE if the SSC 'ssc' is in its initial state with regard only\n     * to the list of code points matched, and locale posix classes; hence does\n     * not check its flags) */\n\n    UV start, end;\n    bool ret;\n\n    PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    invlist_iterinit(ssc->invlist);\n    ret = invlist_iternext(ssc->invlist, &start, &end)\n          && start == 0\n          && end == UV_MAX;\n\n    invlist_iterfinish(ssc->invlist);\n\n    if (! ret) {\n        return FALSE;\n    }\n\n    if (RExC_contains_locale && ! ANYOF_POSIXL_SSC_TEST_ALL_SET(ssc)) {\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\nSTATIC SV*\nS_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state,\n                               const regnode_charclass* const node)\n{\n    /* Returns a mortal inversion list defining which code points are matched\n     * by 'node', which is of type ANYOF.  Handles complementing the result if\n     * appropriate.  If some code points aren't knowable at this time, the\n     * returned list must, and will, contain every code point that is a\n     * possibility. */\n\n    SV* invlist = NULL;\n    SV* only_utf8_locale_invlist = NULL;\n    unsigned int i;\n    const U32 n = ARG(node);\n    bool new_node_has_latin1 = FALSE;\n\n    PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC;\n\n    /* Look at the data structure created by S_set_ANYOF_arg() */\n    if (n != ANYOF_ONLY_HAS_BITMAP) {\n        SV * const rv = MUTABLE_SV(RExC_rxi->data->data[n]);\n        AV * const av = MUTABLE_AV(SvRV(rv));\n        SV **const ary = AvARRAY(av);\n        assert(RExC_rxi->data->what[n] == 's');\n\n        if (ary[1] && ary[1] != &PL_sv_undef) { /* Has compile-time swash */\n            invlist = sv_2mortal(invlist_clone(_get_swash_invlist(ary[1])));\n        }\n        else if (ary[0] && ary[0] != &PL_sv_undef) {\n\n            /* Here, no compile-time swash, and there are things that won't be\n             * known until runtime -- we have to assume it could be anything */\n            invlist = sv_2mortal(_new_invlist(1));\n            return _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else if (ary[3] && ary[3] != &PL_sv_undef) {\n\n            /* Here no compile-time swash, and no run-time only data.  Use the\n             * node's inversion list */\n            invlist = sv_2mortal(invlist_clone(ary[3]));\n        }\n\n        /* Get the code points valid only under UTF-8 locales */\n        if ((ANYOF_FLAGS(node) & ANYOFL_FOLD)\n            && ary[2] && ary[2] != &PL_sv_undef)\n        {\n            only_utf8_locale_invlist = ary[2];\n        }\n    }\n\n    if (! invlist) {\n        invlist = sv_2mortal(_new_invlist(0));\n    }\n\n    /* An ANYOF node contains a bitmap for the first NUM_ANYOF_CODE_POINTS\n     * code points, and an inversion list for the others, but if there are code\n     * points that should match only conditionally on the target string being\n     * UTF-8, those are placed in the inversion list, and not the bitmap.\n     * Since there are circumstances under which they could match, they are\n     * included in the SSC.  But if the ANYOF node is to be inverted, we have\n     * to exclude them here, so that when we invert below, the end result\n     * actually does include them.  (Think about \"\\xe0\" =~ /[^\\xc0]/di;).  We\n     * have to do this here before we add the unconditionally matched code\n     * points */\n    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {\n        _invlist_intersection_complement_2nd(invlist,\n                                             PL_UpperLatin1,\n                                             &invlist);\n    }\n\n    /* Add in the points from the bit map */\n    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n        if (ANYOF_BITMAP_TEST(node, i)) {\n            unsigned int start = i++;\n\n            for (; i < NUM_ANYOF_CODE_POINTS && ANYOF_BITMAP_TEST(node, i); ++i) {\n                /* empty */\n            }\n            invlist = _add_range_to_invlist(invlist, start, i-1);\n            new_node_has_latin1 = TRUE;\n        }\n    }\n\n    /* If this can match all upper Latin1 code points, have to add them\n     * as well.  But don't add them if inverting, as when that gets done below,\n     * it would exclude all these characters, including the ones it shouldn't\n     * that were added just above */\n    if (! (ANYOF_FLAGS(node) & ANYOF_INVERT) && OP(node) == ANYOFD\n        && (ANYOF_FLAGS(node) & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))\n    {\n        _invlist_union(invlist, PL_UpperLatin1, &invlist);\n    }\n\n    /* Similarly for these */\n    if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n        _invlist_union_complement_2nd(invlist, PL_InBitmap, &invlist);\n    }\n\n    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {\n        _invlist_invert(invlist);\n    }\n    else if (new_node_has_latin1 && ANYOF_FLAGS(node) & ANYOFL_FOLD) {\n\n        /* Under /li, any 0-255 could fold to any other 0-255, depending on the\n         * locale.  We can skip this if there are no 0-255 at all. */\n        _invlist_union(invlist, PL_Latin1, &invlist);\n    }\n\n    /* Similarly add the UTF-8 locale possible matches.  These have to be\n     * deferred until after the non-UTF-8 locale ones are taken care of just\n     * above, or it leads to wrong results under ANYOF_INVERT */\n    if (only_utf8_locale_invlist) {\n        _invlist_union_maybe_complement_2nd(invlist,\n                                            only_utf8_locale_invlist,\n                                            ANYOF_FLAGS(node) & ANYOF_INVERT,\n                                            &invlist);\n    }\n\n    return invlist;\n}\n\n/* These two functions currently do the exact same thing */\n#define ssc_init_zero\t\tssc_init\n\n#define ssc_add_cp(ssc, cp)   ssc_add_range((ssc), (cp), (cp))\n#define ssc_match_all_cp(ssc) ssc_add_range(ssc, 0, UV_MAX)\n\n/* 'AND' a given class with another one.  Can create false positives.  'ssc'\n * should not be inverted.  'and_with->flags & ANYOF_MATCHES_POSIXL' should be\n * 0 if 'and_with' is a regnode_charclass instead of a regnode_ssc. */\n\nSTATIC void\nS_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n                const regnode_charclass *and_with)\n{\n    /* Accumulate into SSC 'ssc' its 'AND' with 'and_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives. */\n\n    SV* anded_cp_list;\n    U8  anded_flags;\n\n    PERL_ARGS_ASSERT_SSC_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'and_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(and_with)) {\n        anded_cp_list = ((regnode_ssc *)and_with)->invlist;\n        anded_flags = ANYOF_FLAGS(and_with);\n\n        /* XXX This is a kludge around what appears to be deficiencies in the\n         * optimizer.  If we make S_ssc_anything() add in the WARN_SUPER flag,\n         * there are paths through the optimizer where it doesn't get weeded\n         * out when it should.  And if we don't make some extra provision for\n         * it like the code just below, it doesn't get added when it should.\n         * This solution is to add it only when AND'ing, which is here, and\n         * only when what is being AND'ed is the pristine, original node\n         * matching anything.  Thus it is like adding it to ssc_anything() but\n         * only when the result is to be AND'ed.  Probably the same solution\n         * could be adopted for the same problem we have with /l matching,\n         * which is solved differently in S_ssc_init(), and that would lead to\n         * fewer false positives than that solution has.  But if this solution\n         * creates bugs, the consequences are only that a warning isn't raised\n         * that should be; while the consequences for having /l bugs is\n         * incorrect matches */\n        if (ssc_is_anything((regnode_ssc *)and_with)) {\n            anded_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n        }\n    }\n    else {\n        anded_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, and_with);\n        if (OP(and_with) == ANYOFD) {\n            anded_flags = ANYOF_FLAGS(and_with) & ANYOF_COMMON_FLAGS;\n        }\n        else {\n            anded_flags = ANYOF_FLAGS(and_with)\n            &( ANYOF_COMMON_FLAGS\n              |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n              |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(and_with))) {\n                anded_flags &=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) &= anded_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'and-with'; P2, its posix classes.\n     * 'and_with' may be inverted.  When not inverted, we have the situation of\n     * computing:\n     *  (C1 | P1) & (C2 | P2)\n     *                     =  (C1 & (C2 | P2)) | (P1 & (C2 | P2))\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |       P2)) | ( P1       | (P1 & P2))\n     *                    <=  ((C1 & C2) | P1 | P2)\n     * Alternatively, the last few steps could be:\n     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))\n     *                    <=  ((C1 & C2) |  C1      ) | (      C2  | (P1 & P2))\n     *                    <=  (C1 | C2 | (P1 & P2))\n     * We favor the second approach if either P1 or P2 is non-empty.  This is\n     * because these components are a barrier to doing optimizations, as what\n     * they match cannot be known until the moment of matching as they are\n     * dependent on the current locale, 'AND\"ing them likely will reduce or\n     * eliminate them.\n     * But we can do better if we know that C1,P1 are in their initial state (a\n     * frequent occurrence), each matching everything:\n     *  (<everything>) & (C2 | P2) =  C2 | P2\n     * Similarly, if C2,P2 are in their initial state (again a frequent\n     * occurrence), the result is a no-op\n     *  (C1 | P1) & (<everything>) =  C1 | P1\n     *\n     * Inverted, we have\n     *  (C1 | P1) & ~(C2 | P2)  =  (C1 | P1) & (~C2 & ~P2)\n     *                          =  (C1 & (~C2 & ~P2)) | (P1 & (~C2 & ~P2))\n     *                         <=  (C1 & ~C2) | (P1 & ~P2)\n     * */\n\n    if ((ANYOF_FLAGS(and_with) & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(and_with))\n    {\n        unsigned int i;\n\n        ssc_intersection(ssc,\n                         anded_cp_list,\n                         FALSE /* Has already been inverted */\n                         );\n\n        /* If either P1 or P2 is empty, the intersection will be also; can skip\n         * the loop */\n        if (! (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL)) {\n            ANYOF_POSIXL_ZERO(ssc);\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n\n            /* Note that the Posix class component P from 'and_with' actually\n             * looks like:\n             *      P = Pa | Pb | ... | Pn\n             * where each component is one posix class, such as in [\\w\\s].\n             * Thus\n             *      ~P = ~(Pa | Pb | ... | Pn)\n             *         = ~Pa & ~Pb & ... & ~Pn\n             *        <= ~Pa | ~Pb | ... | ~Pn\n             * The last is something we can easily calculate, but unfortunately\n             * is likely to have many false positives.  We could do better\n             * in some (but certainly not all) instances if two classes in\n             * P have known relationships.  For example\n             *      :lower: <= :alpha: <= :alnum: <= \\w <= :graph: <= :print:\n             * So\n             *      :lower: & :print: = :lower:\n             * And similarly for classes that must be disjoint.  For example,\n             * since \\s and \\w can have no elements in common based on rules in\n             * the POSIX standard,\n             *      \\w & ^\\S = nothing\n             * Unfortunately, some vendor locales do not meet the Posix\n             * standard, in particular almost everything by Microsoft.\n             * The loop below just changes e.g., \\w into \\W and vice versa */\n\n            regnode_charclass_posixl temp;\n            int add = 1;    /* To calculate the index of the complement */\n\n            Zero(&temp, 1, regnode_charclass_posixl);\n            ANYOF_POSIXL_ZERO(&temp);\n            for (i = 0; i < ANYOF_MAX; i++) {\n                assert(i % 2 != 0\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)\n                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i + 1));\n\n                if (ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)) {\n                    ANYOF_POSIXL_SET(&temp, i + add);\n                }\n                add = 0 - add; /* 1 goes to -1; -1 goes to 1 */\n            }\n            ANYOF_POSIXL_AND(&temp, ssc);\n\n        } /* else ssc already has no posixes */\n    } /* else: Not inverted.  This routine is a no-op if 'and_with' is an SSC\n         in its initial state */\n    else if (! is_ANYOF_SYNTHETIC(and_with)\n             || ! ssc_is_cp_posixl_init(pRExC_state, (regnode_ssc *)and_with))\n    {\n        /* But if 'ssc' is in its initial state, the result is just 'and_with';\n         * copy it over 'ssc' */\n        if (ssc_is_cp_posixl_init(pRExC_state, ssc)) {\n            if (is_ANYOF_SYNTHETIC(and_with)) {\n                StructCopy(and_with, ssc, regnode_ssc);\n            }\n            else {\n                ssc->invlist = anded_cp_list;\n                ANYOF_POSIXL_ZERO(ssc);\n                if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {\n                    ANYOF_POSIXL_OR((regnode_charclass_posixl*) and_with, ssc);\n                }\n            }\n        }\n        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)\n                 || (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL))\n        {\n            /* One or the other of P1, P2 is non-empty. */\n            if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {\n                ANYOF_POSIXL_AND((regnode_charclass_posixl*) and_with, ssc);\n            }\n            ssc_union(ssc, anded_cp_list, FALSE);\n        }\n        else { /* P1 = P2 = empty */\n            ssc_intersection(ssc, anded_cp_list, FALSE);\n        }\n    }\n}\n\nSTATIC void\nS_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,\n               const regnode_charclass *or_with)\n{\n    /* Accumulate into SSC 'ssc' its 'OR' with 'or_with', which is either\n     * another SSC or a regular ANYOF class.  Can create false positives if\n     * 'or_with' is to be inverted. */\n\n    SV* ored_cp_list;\n    U8 ored_flags;\n\n    PERL_ARGS_ASSERT_SSC_OR;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* 'or_with' is used as-is if it too is an SSC; otherwise have to extract\n     * the code point inversion list and just the relevant flags */\n    if (is_ANYOF_SYNTHETIC(or_with)) {\n        ored_cp_list = ((regnode_ssc*) or_with)->invlist;\n        ored_flags = ANYOF_FLAGS(or_with);\n    }\n    else {\n        ored_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, or_with);\n        ored_flags = ANYOF_FLAGS(or_with) & ANYOF_COMMON_FLAGS;\n        if (OP(or_with) != ANYOFD) {\n            ored_flags\n            |= ANYOF_FLAGS(or_with)\n             & ( ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n                |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);\n            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(or_with))) {\n                ored_flags |=\n                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n            }\n        }\n    }\n\n    ANYOF_FLAGS(ssc) |= ored_flags;\n\n    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.\n     * C2 is the list of code points in 'or-with'; P2, its posix classes.\n     * 'or_with' may be inverted.  When not inverted, we have the simple\n     * situation of computing:\n     *  (C1 | P1) | (C2 | P2)  =  (C1 | C2) | (P1 | P2)\n     * If P1|P2 yields a situation with both a class and its complement are\n     * set, like having both \\w and \\W, this matches all code points, and we\n     * can delete these from the P component of the ssc going forward.  XXX We\n     * might be able to delete all the P components, but I (khw) am not certain\n     * about this, and it is better to be safe.\n     *\n     * Inverted, we have\n     *  (C1 | P1) | ~(C2 | P2)  =  (C1 | P1) | (~C2 & ~P2)\n     *                         <=  (C1 | P1) | ~C2\n     *                         <=  (C1 | ~C2) | P1\n     * (which results in actually simpler code than the non-inverted case)\n     * */\n\n    if ((ANYOF_FLAGS(or_with) & ANYOF_INVERT)\n        && ! is_ANYOF_SYNTHETIC(or_with))\n    {\n        /* We ignore P2, leaving P1 going forward */\n    }   /* else  Not inverted */\n    else if (ANYOF_FLAGS(or_with) & ANYOF_MATCHES_POSIXL) {\n        ANYOF_POSIXL_OR((regnode_charclass_posixl*)or_with, ssc);\n        if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n            unsigned int i;\n            for (i = 0; i < ANYOF_MAX; i += 2) {\n                if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i + 1))\n                {\n                    ssc_match_all_cp(ssc);\n                    ANYOF_POSIXL_CLEAR(ssc, i);\n                    ANYOF_POSIXL_CLEAR(ssc, i+1);\n                }\n            }\n        }\n    }\n\n    ssc_union(ssc,\n              ored_cp_list,\n              FALSE /* Already has been inverted */\n              );\n}\n\nPERL_STATIC_INLINE void\nS_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_UNION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_union_maybe_complement_2nd(ssc->invlist,\n                                        invlist,\n                                        invert2nd,\n                                        &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_intersection(pTHX_ regnode_ssc *ssc,\n                         SV* const invlist,\n                         const bool invert2nd)\n{\n    PERL_ARGS_ASSERT_SSC_INTERSECTION;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    _invlist_intersection_maybe_complement_2nd(ssc->invlist,\n                                               invlist,\n                                               invert2nd,\n                                               &ssc->invlist);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_add_range(pTHX_ regnode_ssc *ssc, const UV start, const UV end)\n{\n    PERL_ARGS_ASSERT_SSC_ADD_RANGE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ssc->invlist = _add_range_to_invlist(ssc->invlist, start, end);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_cp_and(pTHX_ regnode_ssc *ssc, const UV cp)\n{\n    /* AND just the single code point 'cp' into the SSC 'ssc' */\n\n    SV* cp_list = _new_invlist(2);\n\n    PERL_ARGS_ASSERT_SSC_CP_AND;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    cp_list = add_cp_to_invlist(cp_list, cp);\n    ssc_intersection(ssc, cp_list,\n                     FALSE /* Not inverted */\n                     );\n    SvREFCNT_dec_NN(cp_list);\n}\n\nPERL_STATIC_INLINE void\nS_ssc_clear_locale(regnode_ssc *ssc)\n{\n    /* Set the SSC 'ssc' to not match any locale things */\n    PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    ANYOF_POSIXL_ZERO(ssc);\n    ANYOF_FLAGS(ssc) &= ~ANYOF_LOCALE_FLAGS;\n}\n\n#define NON_OTHER_COUNT   NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC bool\nS_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc)\n{\n    /* The synthetic start class is used to hopefully quickly winnow down\n     * places where a pattern could start a match in the target string.  If it\n     * doesn't really narrow things down that much, there isn't much point to\n     * having the overhead of using it.  This function uses some very crude\n     * heuristics to decide if to use the ssc or not.\n     *\n     * It returns TRUE if 'ssc' rules out more than half what it considers to\n     * be the \"likely\" possible matches, but of course it doesn't know what the\n     * actual things being matched are going to be; these are only guesses\n     *\n     * For /l matches, it assumes that the only likely matches are going to be\n     *      in the 0-255 range, uniformly distributed, so half of that is 127\n     * For /a and /d matches, it assumes that the likely matches will be just\n     *      the ASCII range, so half of that is 63\n     * For /u and there isn't anything matching above the Latin1 range, it\n     *      assumes that that is the only range likely to be matched, and uses\n     *      half that as the cut-off: 127.  If anything matches above Latin1,\n     *      it assumes that all of Unicode could match (uniformly), except for\n     *      non-Unicode code points and things in the General Category \"Other\"\n     *      (unassigned, private use, surrogates, controls and formats).  This\n     *      is a much large number. */\n\n    U32 count = 0;      /* Running total of number of code points matched by\n                           'ssc' */\n    UV start, end;      /* Start and end points of current range in inversion\n                           list */\n    const U32 max_code_points = (LOC)\n                                ?  256\n                                : ((   ! UNI_SEMANTICS\n                                     || invlist_highest(ssc->invlist) < 256)\n                                  ? 128\n                                  : NON_OTHER_COUNT);\n    const U32 max_match = max_code_points / 2;\n\n    PERL_ARGS_ASSERT_IS_SSC_WORTH_IT;\n\n    invlist_iterinit(ssc->invlist);\n    while (invlist_iternext(ssc->invlist, &start, &end)) {\n        if (start >= max_code_points) {\n            break;\n        }\n        end = MIN(end, max_code_points - 1);\n        count += end - start + 1;\n        if (count >= max_match) {\n            invlist_iterfinish(ssc->invlist);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\nSTATIC void\nS_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc)\n{\n    /* The inversion list in the SSC is marked mortal; now we need a more\n     * permanent copy, which is stored the same way that is done in a regular\n     * ANYOF node, with the first NUM_ANYOF_CODE_POINTS code points in a bit\n     * map */\n\n    SV* invlist = invlist_clone(ssc->invlist);\n\n    PERL_ARGS_ASSERT_SSC_FINALIZE;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    /* The code in this file assumes that all but these flags aren't relevant\n     * to the SSC, except SSC_MATCHES_EMPTY_STRING, which should be cleared\n     * by the time we reach here */\n    assert(! (ANYOF_FLAGS(ssc)\n        & ~( ANYOF_COMMON_FLAGS\n            |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER\n            |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)));\n\n    populate_ANYOF_from_invlist( (regnode *) ssc, &invlist);\n\n    set_ANYOF_arg(pRExC_state, (regnode *) ssc, invlist,\n                                NULL, NULL, NULL, FALSE);\n\n    /* Make sure is clone-safe */\n    ssc->invlist = NULL;\n\n    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {\n        ANYOF_FLAGS(ssc) |= ANYOF_MATCHES_POSIXL;\n    }\n\n    if (RExC_contains_locale) {\n        OP(ssc) = ANYOFL;\n    }\n\n    assert(! (ANYOF_FLAGS(ssc) & ANYOF_LOCALE_FLAGS) || RExC_contains_locale);\n}\n\n#define TRIE_LIST_ITEM(state,idx) (trie->states[state].trans.list)[ idx ]\n#define TRIE_LIST_CUR(state)  ( TRIE_LIST_ITEM( state, 0 ).forid )\n#define TRIE_LIST_LEN(state) ( TRIE_LIST_ITEM( state, 0 ).newstate )\n#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list         \\\n                               ? (TRIE_LIST_CUR( idx ) - 1)           \\\n                               : 0 )\n\n\n#ifdef DEBUGGING\n/*\n   dump_trie(trie,widecharmap,revcharmap)\n   dump_trie_interim_list(trie,widecharmap,revcharmap,next_alloc)\n   dump_trie_interim_table(trie,widecharmap,revcharmap,next_alloc)\n\n   These routines dump out a trie in a somewhat readable format.\n   The _interim_ variants are used for debugging the interim\n   tables that are used to generate the final compressed\n   representation which is what dump_trie expects.\n\n   Part of the reason for their existence is to provide a form\n   of documentation as to how the different representations function.\n\n*/\n\n/*\n  Dumps the final compressed table form of the trie to Perl_debug_log.\n  Used for debugging make_trie().\n*/\n\nSTATIC void\nS_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV *widecharmap,\n\t    AV *revcharmap, U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    U16 word;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE;\n\n    Perl_re_indentf( aTHX_  \"Char : %-6s%-6s%-4s \",\n        depth+1, \"Match\",\"Base\",\"Ofs\" );\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, state, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n    Perl_re_printf( aTHX_  \"\\n\");\n    Perl_re_indentf( aTHX_ \"State|-----------------------\", depth+1);\n\n    for( state = 0 ; state < trie->uniquecharcount ; state++ )\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth, \"--------\");\n    Perl_re_printf( aTHX_  \"\\n\");\n\n    for( state = 1 ; state < trie->statecount ; state++ ) {\n\tconst U32 base = trie->states[ state ].trans.base;\n\n        Perl_re_indentf( aTHX_  \"#%4\" UVXf \"|\", depth+1, (UV)state);\n\n        if ( trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \" W%4X\", trie->states[ state ].wordnum );\n        } else {\n            Perl_re_printf( aTHX_  \"%6s\", \"\" );\n        }\n\n        Perl_re_printf( aTHX_  \" @%4\" UVXf \" \", (UV)base );\n\n        if ( base ) {\n            U32 ofs = 0;\n\n            while( ( base + ofs  < trie->uniquecharcount ) ||\n                   ( base + ofs - trie->uniquecharcount < trie->lasttrans\n                     && trie->trans[ base + ofs - trie->uniquecharcount ].check\n                                                                    != state))\n                    ofs++;\n\n            Perl_re_printf( aTHX_  \"+%2\" UVXf \"[ \", (UV)ofs);\n\n            for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                if ( ( base + ofs >= trie->uniquecharcount )\n                        && ( base + ofs - trie->uniquecharcount\n                                                        < trie->lasttrans )\n                        && trie->trans[ base + ofs\n                                    - trie->uniquecharcount ].check == state )\n                {\n                   Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth,\n                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next\n                   );\n                } else {\n                    Perl_re_printf( aTHX_  \"%*s\",colwidth,\"   .\" );\n                }\n            }\n\n            Perl_re_printf( aTHX_  \"]\");\n\n        }\n        Perl_re_printf( aTHX_  \"\\n\" );\n    }\n    Perl_re_indentf( aTHX_  \"word_info N:(prev,len)=\",\n                                depth);\n    for (word=1; word <= trie->wordcount; word++) {\n        Perl_re_printf( aTHX_  \" %d:(%d,%d)\",\n\t    (int)word, (int)(trie->wordinfo[word].prev),\n\t    (int)(trie->wordinfo[word].len));\n    }\n    Perl_re_printf( aTHX_  \"\\n\" );\n}\n/*\n  Dumps a fully constructed but uncompressed trie in list form.\n  List tries normally only are used for construction when the number of\n  possible chars (trie->uniquecharcount) is very high.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t U32 depth)\n{\n    U32 state;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST;\n\n    /* print out the table precompression.  */\n    Perl_re_indentf( aTHX_  \"State :Word | Transition Data\\n\",\n            depth+1 );\n    Perl_re_indentf( aTHX_  \"%s\",\n            depth+1, \"------:-----+-----------------\\n\" );\n\n    for( state=1 ; state < next_alloc ; state ++ ) {\n        U16 charid;\n\n        Perl_re_indentf( aTHX_  \" %4\" UVXf \" :\",\n            depth+1, (UV)state  );\n        if ( ! trie->states[ state ].wordnum ) {\n            Perl_re_printf( aTHX_  \"%5s| \",\"\");\n        } else {\n            Perl_re_printf( aTHX_  \"W%4x| \",\n                trie->states[ state ].wordnum\n            );\n        }\n        for( charid = 1 ; charid <= TRIE_LIST_USED( state ) ; charid++ ) {\n\t    SV ** const tmp = av_fetch( revcharmap,\n                                        TRIE_LIST_ITEM(state,charid).forid, 0);\n\t    if ( tmp ) {\n                Perl_re_printf( aTHX_  \"%*s:%3X=%4\" UVXf \" | \",\n                    colwidth,\n                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp),\n                              colwidth,\n                              PL_colors[0], PL_colors[1],\n                              (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)\n                              | PERL_PV_ESCAPE_FIRSTCHAR\n                    ) ,\n                    TRIE_LIST_ITEM(state,charid).forid,\n                    (UV)TRIE_LIST_ITEM(state,charid).newstate\n                );\n                if (!(charid % 10))\n                    Perl_re_printf( aTHX_  \"\\n%*s| \",\n                        (int)((depth * 2) + 14), \"\");\n            }\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    }\n}\n\n/*\n  Dumps a fully constructed but uncompressed trie in table form.\n  This is the normal DFA style state transition table, with a few\n  twists to facilitate compression later.\n  Used for debugging make_trie().\n*/\nSTATIC void\nS_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie,\n\t\t\t  HV *widecharmap, AV *revcharmap, U32 next_alloc,\n\t\t\t  U32 depth)\n{\n    U32 state;\n    U16 charid;\n    SV *sv=sv_newmortal();\n    int colwidth= widecharmap ? 6 : 4;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE;\n\n    /*\n       print out the table precompression so that we can do a visual check\n       that they are identical.\n     */\n\n    Perl_re_indentf( aTHX_  \"Char : \", depth+1 );\n\n    for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n\tSV ** const tmp = av_fetch( revcharmap, charid, 0);\n        if ( tmp ) {\n            Perl_re_printf( aTHX_  \"%*s\",\n                colwidth,\n                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,\n\t                    PL_colors[0], PL_colors[1],\n\t                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                    PERL_PV_ESCAPE_FIRSTCHAR\n                )\n            );\n        }\n    }\n\n    Perl_re_printf( aTHX_ \"\\n\");\n    Perl_re_indentf( aTHX_  \"State+-\", depth+1 );\n\n    for( charid=0 ; charid < trie->uniquecharcount ; charid++ ) {\n        Perl_re_printf( aTHX_  \"%.*s\", colwidth,\"--------\");\n    }\n\n    Perl_re_printf( aTHX_  \"\\n\" );\n\n    for( state=1 ; state < next_alloc ; state += trie->uniquecharcount ) {\n\n        Perl_re_indentf( aTHX_  \"%4\" UVXf \" : \",\n            depth+1,\n            (UV)TRIE_NODENUM( state ) );\n\n        for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {\n            UV v=(UV)SAFE_TRIE_NODENUM( trie->trans[ state + charid ].next );\n            if (v)\n                Perl_re_printf( aTHX_  \"%*\" UVXf, colwidth, v );\n            else\n                Perl_re_printf( aTHX_  \"%*s\", colwidth, \".\" );\n        }\n        if ( ! trie->states[ TRIE_NODENUM( state ) ].wordnum ) {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \")\\n\",\n                                            (UV)trie->trans[ state ].check );\n        } else {\n            Perl_re_printf( aTHX_  \" (%4\" UVXf \") W%4X\\n\",\n                                            (UV)trie->trans[ state ].check,\n            trie->states[ TRIE_NODENUM( state ) ].wordnum );\n        }\n    }\n}\n\n#endif\n\n\n/* make_trie(startbranch,first,last,tail,word_count,flags,depth)\n  startbranch: the first branch in the whole branch sequence\n  first      : start branch of sequence of branch-exact nodes.\n\t       May be the same as startbranch\n  last       : Thing following the last branch.\n\t       May be the same as tail.\n  tail       : item following the branch sequence\n  count      : words in the sequence\n  flags      : currently the OP() type we will be building one of /EXACT(|F|FA|FU|FU_SS|L|FLU8)/\n  depth      : indent depth\n\nInplace optimizes a sequence of 2 or more Branch-Exact nodes into a TRIE node.\n\nA trie is an N'ary tree where the branches are determined by digital\ndecomposition of the key. IE, at the root node you look up the 1st character and\nfollow that branch repeat until you find the end of the branches. Nodes can be\nmarked as \"accepting\" meaning they represent a complete word. Eg:\n\n  /he|she|his|hers/\n\nwould convert into the following structure. Numbers represent states, letters\nfollowing numbers represent valid transitions on the letter from that state, if\nthe number is in square brackets it represents an accepting state, otherwise it\nwill be in parenthesis.\n\n      +-h->+-e->[3]-+-r->(8)-+-s->[9]\n      |    |\n      |   (2)\n      |    |\n     (1)   +-i->(6)-+-s->[7]\n      |\n      +-s->(3)-+-h->(4)-+-e->[5]\n\n      Accept Word Mapping: 3=>1 (he),5=>2 (she), 7=>3 (his), 9=>4 (hers)\n\nThis shows that when matching against the string 'hers' we will begin at state 1\nread 'h' and move to state 2, read 'e' and move to state 3 which is accepting,\nthen read 'r' and go to state 8 followed by 's' which takes us to state 9 which\nis also accepting. Thus we know that we can match both 'he' and 'hers' with a\nsingle traverse. We store a mapping from accepting to state to which word was\nmatched, and then when we have multiple possibilities we try to complete the\nrest of the regex in the order in which they occurred in the alternation.\n\nThe only prior NFA like behaviour that would be changed by the TRIE support is\nthe silent ignoring of duplicate alternations which are of the form:\n\n / (DUPE|DUPE) X? (?{ ... }) Y /x\n\nThus EVAL blocks following a trie may be called a different number of times with\nand without the optimisation. With the optimisations dupes will be silently\nignored. This inconsistent behaviour of EVAL type nodes is well established as\nthe following demonstrates:\n\n 'words'=~/(word|word|word)(?{ print $1 })[xyz]/\n\nwhich prints out 'word' three times, but\n\n 'words'=~/(word|word|word)(?{ print $1 })S/\n\nwhich doesnt print it out at all. This is due to other optimisations kicking in.\n\nExample of what happens on a structural level:\n\nThe regexp /(ac|ad|ab)+/ will produce the following debug output:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   BRANCH(8)\n   6:     EXACT <ac>(16)\n   8:   BRANCH(11)\n   9:     EXACT <ad>(16)\n  11:   BRANCH(14)\n  12:     EXACT <ab>(16)\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nThis would be optimizable with startbranch=5, first=5, last=16, tail=16\nand should turn into:\n\n   1: CURLYM[1] {1,32767}(18)\n   5:   TRIE(16)\n\t[Words:3 Chars Stored:6 Unique Chars:4 States:5 NCP:1]\n\t  <ac>\n\t  <ad>\n\t  <ab>\n  16:   SUCCEED(0)\n  17:   NOTHING(18)\n  18: END(0)\n\nCases where tail != last would be like /(?foo|bar)baz/:\n\n   1: BRANCH(4)\n   2:   EXACT <foo>(8)\n   4: BRANCH(7)\n   5:   EXACT <bar>(8)\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\nwhich would be optimizable with startbranch=1, first=1, last=7, tail=8\nand would end up looking like:\n\n    1: TRIE(8)\n      [Words:2 Chars Stored:6 Unique Chars:5 States:7 NCP:1]\n\t<foo>\n\t<bar>\n   7: TAIL(8)\n   8: EXACT <baz>(10)\n  10: END(0)\n\n    d = uvchr_to_utf8_flags(d, uv, 0);\n\nis the recommended Unicode-aware way of saying\n\n    *(d++) = uv;\n*/\n\n#define TRIE_STORE_REVCHAR(val)                                            \\\n    STMT_START {                                                           \\\n\tif (UTF) {\t\t\t\t\t\t\t   \\\n            SV *zlopp = newSV(UTF8_MAXBYTES);\t\t\t\t   \\\n\t    unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp);\t   \\\n            unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, val); \\\n\t    SvCUR_set(zlopp, kapow - flrbbbbb);\t\t\t\t   \\\n\t    SvPOK_on(zlopp);\t\t\t\t\t\t   \\\n\t    SvUTF8_on(zlopp);\t\t\t\t\t\t   \\\n\t    av_push(revcharmap, zlopp);\t\t\t\t\t   \\\n\t} else {\t\t\t\t\t\t\t   \\\n            char ooooff = (char)val;                                           \\\n\t    av_push(revcharmap, newSVpvn(&ooooff, 1));\t\t\t   \\\n\t}\t\t\t\t\t\t\t\t   \\\n        } STMT_END\n\n/* This gets the next character from the input, folding it if not already\n * folded. */\n#define TRIE_READ_CHAR STMT_START {                                           \\\n    wordlen++;                                                                \\\n    if ( UTF ) {                                                              \\\n        /* if it is UTF then it is either already folded, or does not need    \\\n         * folding */                                                         \\\n        uvc = valid_utf8_to_uvchr( (const U8*) uc, &len);                     \\\n    }                                                                         \\\n    else if (folder == PL_fold_latin1) {                                      \\\n        /* This folder implies Unicode rules, which in the range expressible  \\\n         *  by not UTF is the lower case, with the two exceptions, one of     \\\n         *  which should have been taken care of before calling this */       \\\n        assert(*uc != LATIN_SMALL_LETTER_SHARP_S);                            \\\n        uvc = toLOWER_L1(*uc);                                                \\\n        if (UNLIKELY(uvc == MICRO_SIGN)) uvc = GREEK_SMALL_LETTER_MU;         \\\n        len = 1;                                                              \\\n    } else {                                                                  \\\n        /* raw data, will be folded later if needed */                        \\\n        uvc = (U32)*uc;                                                       \\\n        len = 1;                                                              \\\n    }                                                                         \\\n} STMT_END\n\n\n\n#define TRIE_LIST_PUSH(state,fid,ns) STMT_START {               \\\n    if ( TRIE_LIST_CUR( state ) >=TRIE_LIST_LEN( state ) ) {    \\\n\tU32 ging = TRIE_LIST_LEN( state ) * 2;                  \\\n\tRenew( trie->states[ state ].trans.list, ging, reg_trie_trans_le ); \\\n        TRIE_LIST_LEN( state ) = ging;                          \\\n    }                                                           \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).forid = fid;     \\\n    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).newstate = ns;   \\\n    TRIE_LIST_CUR( state )++;                                   \\\n} STMT_END\n\n#define TRIE_LIST_NEW(state) STMT_START {                       \\\n    Newx( trie->states[ state ].trans.list,                     \\\n\t4, reg_trie_trans_le );                                 \\\n     TRIE_LIST_CUR( state ) = 1;                                \\\n     TRIE_LIST_LEN( state ) = 4;                                \\\n} STMT_END\n\n#define TRIE_HANDLE_WORD(state) STMT_START {                    \\\n    U16 dupe= trie->states[ state ].wordnum;                    \\\n    regnode * const noper_next = regnext( noper );              \\\n                                                                \\\n    DEBUG_r({                                                   \\\n        /* store the word for dumping */                        \\\n        SV* tmp;                                                \\\n        if (OP(noper) != NOTHING)                               \\\n            tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), UTF);\t\\\n        else                                                    \\\n            tmp = newSVpvn_utf8( \"\", 0, UTF );\t\t\t\\\n        av_push( trie_words, tmp );                             \\\n    });                                                         \\\n                                                                \\\n    curword++;                                                  \\\n    trie->wordinfo[curword].prev   = 0;                         \\\n    trie->wordinfo[curword].len    = wordlen;                   \\\n    trie->wordinfo[curword].accept = state;                     \\\n                                                                \\\n    if ( noper_next < tail ) {                                  \\\n        if (!trie->jump)                                        \\\n            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, \\\n                                                 sizeof(U16) ); \\\n        trie->jump[curword] = (U16)(noper_next - convert);      \\\n        if (!jumper)                                            \\\n            jumper = noper_next;                                \\\n        if (!nextbranch)                                        \\\n            nextbranch= regnext(cur);                           \\\n    }                                                           \\\n                                                                \\\n    if ( dupe ) {                                               \\\n        /* It's a dupe. Pre-insert into the wordinfo[].prev   */\\\n        /* chain, so that when the bits of chain are later    */\\\n        /* linked together, the dups appear in the chain      */\\\n\ttrie->wordinfo[curword].prev = trie->wordinfo[dupe].prev; \\\n\ttrie->wordinfo[dupe].prev = curword;                    \\\n    } else {                                                    \\\n        /* we haven't inserted this word yet.                */ \\\n        trie->states[ state ].wordnum = curword;                \\\n    }                                                           \\\n} STMT_END\n\n\n#define TRIE_TRANS_STATE(state,base,ucharcount,charid,special)\t\t\\\n     ( ( base + charid >=  ucharcount\t\t\t\t\t\\\n         && base + charid < ubound\t\t\t\t\t\\\n         && state == trie->trans[ base - ucharcount + charid ].check\t\\\n         && trie->trans[ base - ucharcount + charid ].next )\t\t\\\n           ? trie->trans[ base - ucharcount + charid ].next\t\t\\\n           : ( state==1 ? special : 0 )\t\t\t\t\t\\\n      )\n\n#define TRIE_BITMAP_SET_FOLDED(trie, uvc, folder)           \\\nSTMT_START {                                                \\\n    TRIE_BITMAP_SET(trie, uvc);                             \\\n    /* store the folded codepoint */                        \\\n    if ( folder )                                           \\\n        TRIE_BITMAP_SET(trie, folder[(U8) uvc ]);           \\\n                                                            \\\n    if ( !UTF ) {                                           \\\n        /* store first byte of utf8 representation of */    \\\n        /* variant codepoints */                            \\\n        if (! UVCHR_IS_INVARIANT(uvc)) {                    \\\n            TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(uvc));   \\\n        }                                                   \\\n    }                                                       \\\n} STMT_END\n#define MADE_TRIE       1\n#define MADE_JUMP_TRIE  2\n#define MADE_EXACT_TRIE 4\n\nSTATIC I32\nS_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch,\n                  regnode *first, regnode *last, regnode *tail,\n                  U32 word_count, U32 flags, U32 depth)\n{\n    /* first pass, loop through and scan words */\n    reg_trie_data *trie;\n    HV *widecharmap = NULL;\n    AV *revcharmap = newAV();\n    regnode *cur;\n    STRLEN len = 0;\n    UV uvc = 0;\n    U16 curword = 0;\n    U32 next_alloc = 0;\n    regnode *jumper = NULL;\n    regnode *nextbranch = NULL;\n    regnode *convert = NULL;\n    U32 *prev_states; /* temp array mapping each state to previous one */\n    /* we just use folder as a flag in utf8 */\n    const U8 * folder = NULL;\n\n    /* in the below add_data call we are storing either 'tu' or 'tuaa'\n     * which stands for one trie structure, one hash, optionally followed\n     * by two arrays */\n#ifdef DEBUGGING\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tuaa\"));\n    AV *trie_words = NULL;\n    /* along with revcharmap, this only used during construction but both are\n     * useful during debugging so we store them in the struct when debugging.\n     */\n#else\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"tu\"));\n    STRLEN trie_charcount=0;\n#endif\n    SV *re_trie_maxbuff;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_MAKE_TRIE;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    switch (flags) {\n        case EXACT: case EXACTL: break;\n\tcase EXACTFA:\n        case EXACTFU_SS:\n\tcase EXACTFU:\n\tcase EXACTFLU8: folder = PL_fold_latin1; break;\n\tcase EXACTF:  folder = PL_fold; break;\n        default: Perl_croak( aTHX_ \"panic! In trie construction, unknown node type %u %s\", (unsigned) flags, PL_reg_name[flags] );\n    }\n\n    trie = (reg_trie_data *) PerlMemShared_calloc( 1, sizeof(reg_trie_data) );\n    trie->refcount = 1;\n    trie->startstate = 1;\n    trie->wordcount = word_count;\n    RExC_rxi->data->data[ data_slot ] = (void*)trie;\n    trie->charmap = (U16 *) PerlMemShared_calloc( 256, sizeof(U16) );\n    if (flags == EXACT || flags == EXACTL)\n\ttrie->bitmap = (char *) PerlMemShared_calloc( ANYOF_BITMAP_SIZE, 1 );\n    trie->wordinfo = (reg_trie_wordinfo *) PerlMemShared_calloc(\n                       trie->wordcount+1, sizeof(reg_trie_wordinfo));\n\n    DEBUG_r({\n        trie_words = newAV();\n    });\n\n    re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n    assert(re_trie_maxbuff);\n    if (!SvIOK(re_trie_maxbuff)) {\n        sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n    }\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_\n          \"make_trie start==%d, first==%d, last==%d, tail==%d depth=%d\\n\",\n          depth+1,\n          REG_NODE_NUM(startbranch),REG_NODE_NUM(first),\n          REG_NODE_NUM(last), REG_NODE_NUM(tail), (int)depth);\n    });\n\n   /* Find the node we are going to overwrite */\n    if ( first == startbranch && OP( last ) != BRANCH ) {\n        /* whole branch chain */\n        convert = first;\n    } else {\n        /* branch sub-chain */\n        convert = NEXTOPER( first );\n    }\n\n    /*  -- First loop and Setup --\n\n       We first traverse the branches and scan each word to determine if it\n       contains widechars, and how many unique chars there are, this is\n       important as we have to build a table with at least as many columns as we\n       have unique chars.\n\n       We use an array of integers to represent the character codes 0..255\n       (trie->charmap) and we use a an HV* to store Unicode characters. We use\n       the native representation of the character value as the key and IV's for\n       the coded index.\n\n       *TODO* If we keep track of how many times each character is used we can\n       remap the columns so that the table compression later on is more\n       efficient in terms of memory by ensuring the most common value is in the\n       middle and the least common are on the outside.  IMO this would be better\n       than a most to least common mapping as theres a decent chance the most\n       common letter will share a node with the least common, meaning the node\n       will not be compressible. With a middle is most common approach the worst\n       case is when we have the least common nodes twice.\n\n     */\n\n    for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n        regnode *noper = NEXTOPER( cur );\n        const U8 *uc;\n        const U8 *e;\n        int foldlen = 0;\n        U32 wordlen      = 0;         /* required init */\n        STRLEN minchars = 0;\n        STRLEN maxchars = 0;\n        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the\n                                               bitmap?*/\n\n        if (OP(noper) == NOTHING) {\n            /* skip past a NOTHING at the start of an alternation\n             * eg, /(?:)a|(?:b)/ should be the same as /a|b/\n             */\n            regnode *noper_next= regnext(noper);\n            if (noper_next < tail)\n                noper= noper_next;\n        }\n\n        if ( noper < tail &&\n                (\n                    OP(noper) == flags ||\n                    (\n                        flags == EXACTFU &&\n                        OP(noper) == EXACTFU_SS\n                    )\n                )\n        ) {\n            uc= (U8*)STRING(noper);\n            e= uc + STR_LEN(noper);\n        } else {\n            trie->minlen= 0;\n            continue;\n        }\n\n\n        if ( set_bit ) { /* bitmap only alloced when !(UTF&&Folding) */\n            TRIE_BITMAP_SET(trie,*uc); /* store the raw first byte\n                                          regardless of encoding */\n            if (OP( noper ) == EXACTFU_SS) {\n                /* false positives are ok, so just set this */\n                TRIE_BITMAP_SET(trie, LATIN_SMALL_LETTER_SHARP_S);\n            }\n        }\n\n        for ( ; uc < e ; uc += len ) {  /* Look at each char in the current\n                                           branch */\n            TRIE_CHARCOUNT(trie)++;\n            TRIE_READ_CHAR;\n\n            /* TRIE_READ_CHAR returns the current character, or its fold if /i\n             * is in effect.  Under /i, this character can match itself, or\n             * anything that folds to it.  If not under /i, it can match just\n             * itself.  Most folds are 1-1, for example k, K, and KELVIN SIGN\n             * all fold to k, and all are single characters.   But some folds\n             * expand to more than one character, so for example LATIN SMALL\n             * LIGATURE FFI folds to the three character sequence 'ffi'.  If\n             * the string beginning at 'uc' is 'ffi', it could be matched by\n             * three characters, or just by the one ligature character. (It\n             * could also be matched by two characters: LATIN SMALL LIGATURE FF\n             * followed by 'i', or by 'f' followed by LATIN SMALL LIGATURE FI).\n             * (Of course 'I' and/or 'F' instead of 'i' and 'f' can also\n             * match.)  The trie needs to know the minimum and maximum number\n             * of characters that could match so that it can use size alone to\n             * quickly reject many match attempts.  The max is simple: it is\n             * the number of folded characters in this branch (since a fold is\n             * never shorter than what folds to it. */\n\n            maxchars++;\n\n            /* And the min is equal to the max if not under /i (indicated by\n             * 'folder' being NULL), or there are no multi-character folds.  If\n             * there is a multi-character fold, the min is incremented just\n             * once, for the character that folds to the sequence.  Each\n             * character in the sequence needs to be added to the list below of\n             * characters in the trie, but we count only the first towards the\n             * min number of characters needed.  This is done through the\n             * variable 'foldlen', which is returned by the macros that look\n             * for these sequences as the number of bytes the sequence\n             * occupies.  Each time through the loop, we decrement 'foldlen' by\n             * how many bytes the current char occupies.  Only when it reaches\n             * 0 do we increment 'minchars' or look for another multi-character\n             * sequence. */\n            if (folder == NULL) {\n                minchars++;\n            }\n            else if (foldlen > 0) {\n                foldlen -= (UTF) ? UTF8SKIP(uc) : 1;\n            }\n            else {\n                minchars++;\n\n                /* See if *uc is the beginning of a multi-character fold.  If\n                 * so, we decrement the length remaining to look at, to account\n                 * for the current character this iteration.  (We can use 'uc'\n                 * instead of the fold returned by TRIE_READ_CHAR because for\n                 * non-UTF, the latin1_safe macro is smart enough to account\n                 * for all the unfolded characters, and because for UTF, the\n                 * string will already have been folded earlier in the\n                 * compilation process */\n                if (UTF) {\n                    if ((foldlen = is_MULTI_CHAR_FOLD_utf8_safe(uc, e))) {\n                        foldlen -= UTF8SKIP(uc);\n                    }\n                }\n                else if ((foldlen = is_MULTI_CHAR_FOLD_latin1_safe(uc, e))) {\n                    foldlen--;\n                }\n            }\n\n            /* The current character (and any potential folds) should be added\n             * to the possible matching characters for this position in this\n             * branch */\n            if ( uvc < 256 ) {\n                if ( folder ) {\n                    U8 folded= folder[ (U8) uvc ];\n                    if ( !trie->charmap[ folded ] ) {\n                        trie->charmap[ folded ]=( ++trie->uniquecharcount );\n                        TRIE_STORE_REVCHAR( folded );\n                    }\n                }\n                if ( !trie->charmap[ uvc ] ) {\n                    trie->charmap[ uvc ]=( ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR( uvc );\n                }\n                if ( set_bit ) {\n\t\t    /* store the codepoint in the bitmap, and its folded\n\t\t     * equivalent. */\n                    TRIE_BITMAP_SET_FOLDED(trie, uvc, folder);\n                    set_bit = 0; /* We've done our bit :-) */\n                }\n            } else {\n\n                /* XXX We could come up with the list of code points that fold\n                 * to this using PL_utf8_foldclosures, except not for\n                 * multi-char folds, as there may be multiple combinations\n                 * there that could work, which needs to wait until runtime to\n                 * resolve (The comment about LIGATURE FFI above is such an\n                 * example */\n\n                SV** svpp;\n                if ( !widecharmap )\n                    widecharmap = newHV();\n\n                svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 1 );\n\n                if ( !svpp )\n                    Perl_croak( aTHX_ \"error creating/fetching widecharmap entry for 0x%\" UVXf, uvc );\n\n                if ( !SvTRUE( *svpp ) ) {\n                    sv_setiv( *svpp, ++trie->uniquecharcount );\n                    TRIE_STORE_REVCHAR(uvc);\n                }\n            }\n        } /* end loop through characters in this branch of the trie */\n\n        /* We take the min and max for this branch and combine to find the min\n         * and max for all branches processed so far */\n        if( cur == first ) {\n            trie->minlen = minchars;\n            trie->maxlen = maxchars;\n        } else if (minchars < trie->minlen) {\n            trie->minlen = minchars;\n        } else if (maxchars > trie->maxlen) {\n            trie->maxlen = maxchars;\n        }\n    } /* end first pass */\n    DEBUG_TRIE_COMPILE_r(\n        Perl_re_indentf( aTHX_\n                \"TRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\\n\",\n                depth+1,\n                ( widecharmap ? \"UTF8\" : \"NATIVE\" ), (int)word_count,\n\t\t(int)TRIE_CHARCOUNT(trie), trie->uniquecharcount,\n\t\t(int)trie->minlen, (int)trie->maxlen )\n    );\n\n    /*\n        We now know what we are dealing with in terms of unique chars and\n        string sizes so we can calculate how much memory a naive\n        representation using a flat table  will take. If it's over a reasonable\n        limit (as specified by ${^RE_TRIE_MAXBUF}) we use a more memory\n        conservative but potentially much slower representation using an array\n        of lists.\n\n        At the end we convert both representations into the same compressed\n        form that will be used in regexec.c for matching with. The latter\n        is a form that cannot be used to construct with but has memory\n        properties similar to the list form and access properties similar\n        to the table form making it both suitable for fast searches and\n        small enough that its feasable to store for the duration of a program.\n\n        See the comment in the code where the compressed table is produced\n        inplace from the flat tabe representation for an explanation of how\n        the compression works.\n\n    */\n\n\n    Newx(prev_states, TRIE_CHARCOUNT(trie) + 2, U32);\n    prev_states[1] = 0;\n\n    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1)\n                                                    > SvIV(re_trie_maxbuff) )\n    {\n        /*\n            Second Pass -- Array Of Lists Representation\n\n            Each state will be represented by a list of charid:state records\n            (reg_trie_trans_le) the first such element holds the CUR and LEN\n            points of the allocated array. (See defines above).\n\n            We build the initial structure using the lists, and then convert\n            it into the compressed table form which allows faster lookups\n            (but cant be modified once converted).\n        */\n\n        STRLEN transcount = 1;\n\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using list compiler\\n\",\n            depth+1));\n\n\ttrie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        TRIE_LIST_NEW(1);\n        next_alloc = 2;\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\t    U32 state        = 1;         /* required init */\n\t    U16 charid       = 0;         /* sanity init */\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n            }\n\n            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n\t\t    } else {\n                        SV** const svpp = hv_fetch( widecharmap,\n                                                    (char*)&uvc,\n                                                    sizeof( UV ),\n                                                    0);\n                        if ( !svpp ) {\n                            charid = 0;\n                        } else {\n                            charid=(U16)SvIV( *svpp );\n                        }\n\t\t    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                    if ( charid ) {\n\n                        U16 check;\n                        U32 newstate = 0;\n\n                        charid--;\n                        if ( !trie->states[ state ].trans.list ) {\n                            TRIE_LIST_NEW( state );\n\t\t\t}\n                        for ( check = 1;\n                              check <= TRIE_LIST_USED( state );\n                              check++ )\n                        {\n                            if ( TRIE_LIST_ITEM( state, check ).forid\n                                                                    == charid )\n                            {\n                                newstate = TRIE_LIST_ITEM( state, check ).newstate;\n                                break;\n                            }\n                        }\n                        if ( ! newstate ) {\n                            newstate = next_alloc++;\n\t\t\t    prev_states[newstate] = state;\n                            TRIE_LIST_PUSH( state, charid, newstate );\n                            transcount++;\n                        }\n                        state = newstate;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n\t\t    }\n\t\t}\n\t    }\n            TRIE_HANDLE_WORD(state);\n\n        } /* end second pass */\n\n        /* next alloc is the NEXT state to be allocated */\n        trie->statecount = next_alloc;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states,\n\t\t\t\t   next_alloc\n\t\t\t\t   * sizeof(reg_trie_state) );\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_list(trie, widecharmap,\n\t\t\t\t\t\t\t revcharmap, next_alloc,\n\t\t\t\t\t\t\t depth+1)\n        );\n\n        trie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( transcount, sizeof(reg_trie_trans) );\n        {\n            U32 state;\n            U32 tp = 0;\n            U32 zp = 0;\n\n\n            for( state=1 ; state < next_alloc ; state ++ ) {\n                U32 base=0;\n\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \"tp: %d zp: %d \",tp,zp)\n                );\n                */\n\n                if (trie->states[state].trans.list) {\n                    U16 minid=TRIE_LIST_ITEM( state, 1).forid;\n                    U16 maxid=minid;\n\t\t    U16 idx;\n\n                    for( idx = 2 ; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n\t\t\tconst U16 forid = TRIE_LIST_ITEM( state, idx).forid;\n\t\t\tif ( forid < minid ) {\n\t\t\t    minid=forid;\n\t\t\t} else if ( forid > maxid ) {\n\t\t\t    maxid=forid;\n\t\t\t}\n                    }\n                    if ( transcount < tp + maxid - minid + 1) {\n                        transcount *= 2;\n\t\t\ttrie->trans = (reg_trie_trans *)\n\t\t\t    PerlMemShared_realloc( trie->trans,\n\t\t\t\t\t\t     transcount\n\t\t\t\t\t\t     * sizeof(reg_trie_trans) );\n                        Zero( trie->trans + (transcount / 2),\n                              transcount / 2,\n                              reg_trie_trans );\n                    }\n                    base = trie->uniquecharcount + tp - minid;\n                    if ( maxid == minid ) {\n                        U32 set = 0;\n                        for ( ; zp < tp ; zp++ ) {\n                            if ( ! trie->trans[ zp ].next ) {\n                                base = trie->uniquecharcount + zp - minid;\n                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                                trie->trans[ zp ].check = state;\n                                set = 1;\n                                break;\n                            }\n                        }\n                        if ( !set ) {\n                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state,\n                                                                   1).newstate;\n                            trie->trans[ tp ].check = state;\n                            tp++;\n                            zp = tp;\n                        }\n                    } else {\n                        for ( idx=1; idx <= TRIE_LIST_USED( state ) ; idx++ ) {\n                            const U32 tid = base\n                                           - trie->uniquecharcount\n                                           + TRIE_LIST_ITEM( state, idx ).forid;\n                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state,\n                                                                idx ).newstate;\n                            trie->trans[ tid ].check = state;\n                        }\n                        tp += ( maxid - minid + 1 );\n                    }\n                    Safefree(trie->states[ state ].trans.list);\n                }\n                /*\n                DEBUG_TRIE_COMPILE_MORE_r(\n                    Perl_re_printf( aTHX_  \" base: %d\\n\",base);\n                );\n                */\n                trie->states[ state ].trans.base=base;\n            }\n            trie->lasttrans = tp + 1;\n        }\n    } else {\n        /*\n           Second Pass -- Flat Table Representation.\n\n           we dont use the 0 slot of either trans[] or states[] so we add 1 to\n           each.  We know that we will need Charcount+1 trans at most to store\n           the data (one row per char at worst case) So we preallocate both\n           structures assuming worst case.\n\n           We then construct the trie using only the .next slots of the entry\n           structs.\n\n           We use the .check field of the first entry of the node temporarily\n           to make compression both faster and easier by keeping track of how\n           many non zero fields are in the node.\n\n           Since trans are numbered from 1 any 0 pointer in the table is a FAIL\n           transition.\n\n           There are two terms at use here: state as a TRIE_NODEIDX() which is\n           a number representing the first entry of the node, and state as a\n           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1)\n           and TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3)\n           if there are 2 entrys per node. eg:\n\n             A B       A B\n          1. 2 4    1. 3 7\n          2. 0 3    3. 0 5\n          3. 0 0    5. 0 0\n          4. 0 0    7. 0 0\n\n           The table is internally in the right hand, idx form. However as we\n           also have to deal with the states array which is indexed by nodenum\n           we have to use TRIE_NODENUM() to convert.\n\n        */\n        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  \"Compiling trie using table compiler\\n\",\n            depth+1));\n\n\ttrie->trans = (reg_trie_trans *)\n\t    PerlMemShared_calloc( ( TRIE_CHARCOUNT(trie) + 1 )\n\t\t\t\t  * trie->uniquecharcount + 1,\n\t\t\t\t  sizeof(reg_trie_trans) );\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,\n\t\t\t\t  sizeof(reg_trie_state) );\n        next_alloc = trie->uniquecharcount + 1;\n\n\n        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {\n\n            regnode *noper   = NEXTOPER( cur );\n\n            U32 state        = 1;         /* required init */\n\n            U16 charid       = 0;         /* sanity init */\n            U32 accept_state = 0;         /* sanity init */\n\n            U32 wordlen      = 0;         /* required init */\n\n            if (OP(noper) == NOTHING) {\n                regnode *noper_next= regnext(noper);\n                if (noper_next < tail)\n                    noper= noper_next;\n            }\n\n            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {\n                const U8 *uc= (U8*)STRING(noper);\n                const U8 *e= uc + STR_LEN(noper);\n\n                for ( ; uc < e ; uc += len ) {\n\n                    TRIE_READ_CHAR;\n\n                    if ( uvc < 256 ) {\n                        charid = trie->charmap[ uvc ];\n                    } else {\n                        SV* const * const svpp = hv_fetch( widecharmap,\n                                                           (char*)&uvc,\n                                                           sizeof( UV ),\n                                                           0);\n                        charid = svpp ? (U16)SvIV(*svpp) : 0;\n                    }\n                    if ( charid ) {\n                        charid--;\n                        if ( !trie->trans[ state + charid ].next ) {\n                            trie->trans[ state + charid ].next = next_alloc;\n                            trie->trans[ state ].check++;\n\t\t\t    prev_states[TRIE_NODENUM(next_alloc)]\n\t\t\t\t    = TRIE_NODENUM(state);\n                            next_alloc += trie->uniquecharcount;\n                        }\n                        state = trie->trans[ state + charid ].next;\n                    } else {\n                        Perl_croak( aTHX_ \"panic! In trie construction, no char mapping for %\" IVdf, uvc );\n                    }\n                    /* charid is now 0 if we dont know the char read, or\n                     * nonzero if we do */\n                }\n            }\n            accept_state = TRIE_NODENUM( state );\n            TRIE_HANDLE_WORD(accept_state);\n\n        } /* end second pass */\n\n        /* and now dump it out before we compress it */\n        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_table(trie, widecharmap,\n\t\t\t\t\t\t\t  revcharmap,\n\t\t\t\t\t\t\t  next_alloc, depth+1));\n\n        {\n        /*\n           * Inplace compress the table.*\n\n           For sparse data sets the table constructed by the trie algorithm will\n           be mostly 0/FAIL transitions or to put it another way mostly empty.\n           (Note that leaf nodes will not contain any transitions.)\n\n           This algorithm compresses the tables by eliminating most such\n           transitions, at the cost of a modest bit of extra work during lookup:\n\n           - Each states[] entry contains a .base field which indicates the\n           index in the state[] array wheres its transition data is stored.\n\n           - If .base is 0 there are no valid transitions from that node.\n\n           - If .base is nonzero then charid is added to it to find an entry in\n           the trans array.\n\n           -If trans[states[state].base+charid].check!=state then the\n           transition is taken to be a 0/Fail transition. Thus if there are fail\n           transitions at the front of the node then the .base offset will point\n           somewhere inside the previous nodes data (or maybe even into a node\n           even earlier), but the .check field determines if the transition is\n           valid.\n\n           XXX - wrong maybe?\n           The following process inplace converts the table to the compressed\n           table: We first do not compress the root node 1,and mark all its\n           .check pointers as 1 and set its .base pointer as 1 as well. This\n           allows us to do a DFA construction from the compressed table later,\n           and ensures that any .base pointers we calculate later are greater\n           than 0.\n\n           - We set 'pos' to indicate the first entry of the second node.\n\n           - We then iterate over the columns of the node, finding the first and\n           last used entry at l and m. We then copy l..m into pos..(pos+m-l),\n           and set the .check pointers accordingly, and advance pos\n           appropriately and repreat for the next node. Note that when we copy\n           the next pointers we have to convert them from the original\n           NODEIDX form to NODENUM form as the former is not valid post\n           compression.\n\n           - If a node has no transitions used we mark its base as 0 and do not\n           advance the pos pointer.\n\n           - If a node only has one transition we use a second pointer into the\n           structure to fill in allocated fail transitions from other states.\n           This pointer is independent of the main pointer and scans forward\n           looking for null transitions that are allocated to a state. When it\n           finds one it writes the single transition into the \"hole\".  If the\n           pointer doesnt find one the single transition is appended as normal.\n\n           - Once compressed we can Renew/realloc the structures to release the\n           excess space.\n\n           See \"Table-Compression Methods\" in sec 3.9 of the Red Dragon,\n           specifically Fig 3.47 and the associated pseudocode.\n\n           demq\n        */\n        const U32 laststate = TRIE_NODENUM( next_alloc );\n\tU32 state, charid;\n        U32 pos = 0, zp=0;\n        trie->statecount = laststate;\n\n        for ( state = 1 ; state < laststate ; state++ ) {\n            U8 flag = 0;\n\t    const U32 stateidx = TRIE_NODEIDX( state );\n\t    const U32 o_used = trie->trans[ stateidx ].check;\n\t    U32 used = trie->trans[ stateidx ].check;\n            trie->trans[ stateidx ].check = 0;\n\n            for ( charid = 0;\n                  used && charid < trie->uniquecharcount;\n                  charid++ )\n            {\n                if ( flag || trie->trans[ stateidx + charid ].next ) {\n                    if ( trie->trans[ stateidx + charid ].next ) {\n                        if (o_used == 1) {\n                            for ( ; zp < pos ; zp++ ) {\n                                if ( ! trie->trans[ zp ].next ) {\n                                    break;\n                                }\n                            }\n                            trie->states[ state ].trans.base\n                                                    = zp\n                                                      + trie->uniquecharcount\n                                                      - charid ;\n                            trie->trans[ zp ].next\n                                = SAFE_TRIE_NODENUM( trie->trans[ stateidx\n                                                             + charid ].next );\n                            trie->trans[ zp ].check = state;\n                            if ( ++zp > pos ) pos = zp;\n                            break;\n                        }\n                        used--;\n                    }\n                    if ( !flag ) {\n                        flag = 1;\n                        trie->states[ state ].trans.base\n                                       = pos + trie->uniquecharcount - charid ;\n                    }\n                    trie->trans[ pos ].next\n                        = SAFE_TRIE_NODENUM(\n                                       trie->trans[ stateidx + charid ].next );\n                    trie->trans[ pos ].check = state;\n                    pos++;\n                }\n            }\n        }\n        trie->lasttrans = pos + 1;\n        trie->states = (reg_trie_state *)\n\t    PerlMemShared_realloc( trie->states, laststate\n\t\t\t\t   * sizeof(reg_trie_state) );\n        DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Alloc: %d Orig: %\" IVdf \" elements, Final:%\" IVdf \". Savings of %%%5.2f\\n\",\n                depth+1,\n                (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount\n                       + 1 ),\n                (IV)next_alloc,\n                (IV)pos,\n                ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );\n            );\n\n        } /* end table compress */\n    }\n    DEBUG_TRIE_COMPILE_MORE_r(\n            Perl_re_indentf( aTHX_  \"Statecount:%\" UVxf \" Lasttrans:%\" UVxf \"\\n\",\n                depth+1,\n                (UV)trie->statecount,\n                (UV)trie->lasttrans)\n    );\n    /* resize the trans array to remove unused space */\n    trie->trans = (reg_trie_trans *)\n\tPerlMemShared_realloc( trie->trans, trie->lasttrans\n\t\t\t       * sizeof(reg_trie_trans) );\n\n    {   /* Modify the program and insert the new TRIE node */\n        U8 nodetype =(U8)(flags & 0xFF);\n        char *str=NULL;\n\n#ifdef DEBUGGING\n        regnode *optimize = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n\n        U32 mjd_offset = 0;\n        U32 mjd_nodelen = 0;\n#endif /* RE_TRACK_PATTERN_OFFSETS */\n#endif /* DEBUGGING */\n        /*\n           This means we convert either the first branch or the first Exact,\n           depending on whether the thing following (in 'last') is a branch\n           or not and whther first is the startbranch (ie is it a sub part of\n           the alternation or is it the whole thing.)\n           Assuming its a sub part we convert the EXACT otherwise we convert\n           the whole branch sequence, including the first.\n         */\n        /* Find the node we are going to overwrite */\n        if ( first != startbranch || OP( last ) == BRANCH ) {\n            /* branch sub-chain */\n            NEXT_OFF( first ) = (U16)(last - first);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n            DEBUG_r({\n                mjd_offset= Node_Offset((convert));\n                mjd_nodelen= Node_Length((convert));\n            });\n#endif\n            /* whole branch chain */\n        }\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        else {\n            DEBUG_r({\n                const  regnode *nop = NEXTOPER( convert );\n                mjd_offset= Node_Offset((nop));\n                mjd_nodelen= Node_Length((nop));\n            });\n        }\n        DEBUG_OPTIMISE_r(\n            Perl_re_indentf( aTHX_  \"MJD offset:%\" UVuf \" MJD length:%\" UVuf \"\\n\",\n                depth+1,\n                (UV)mjd_offset, (UV)mjd_nodelen)\n        );\n#endif\n        /* But first we check to see if there is a common prefix we can\n           split out as an EXACT and put in front of the TRIE node.  */\n        trie->startstate= 1;\n        if ( trie->bitmap && !widecharmap && !trie->jump  ) {\n            /* we want to find the first state that has more than\n             * one transition, if that state is not the first state\n             * then we have a common prefix which we can remove.\n             */\n            U32 state;\n            for ( state = 1 ; state < trie->statecount-1 ; state++ ) {\n                U32 ofs = 0;\n                I32 first_ofs = -1; /* keeps track of the ofs of the first\n                                       transition, -1 means none */\n                U32 count = 0;\n                const U32 base = trie->states[ state ].trans.base;\n\n                /* does this state terminate an alternation? */\n                if ( trie->states[state].wordnum )\n                        count = 1;\n\n                for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {\n                    if ( ( base + ofs >= trie->uniquecharcount ) &&\n                         ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&\n                         trie->trans[ base + ofs - trie->uniquecharcount ].check == state )\n                    {\n                        if ( ++count > 1 ) {\n                            /* we have more than one transition */\n                            SV **tmp;\n                            U8 *ch;\n                            /* if this is the first state there is no common prefix\n                             * to extract, so we can exit */\n                            if ( state == 1 ) break;\n                            tmp = av_fetch( revcharmap, ofs, 0);\n                            ch = (U8*)SvPV_nolen_const( *tmp );\n\n                            /* if we are on count 2 then we need to initialize the\n                             * bitmap, and store the previous char if there was one\n                             * in it*/\n                            if ( count == 2 ) {\n                                /* clear the bitmap */\n                                Zero(trie->bitmap, ANYOF_BITMAP_SIZE, char);\n                                DEBUG_OPTIMISE_r(\n                                    Perl_re_indentf( aTHX_  \"New Start State=%\" UVuf \" Class: [\",\n                                        depth+1,\n                                        (UV)state));\n                                if (first_ofs >= 0) {\n                                    SV ** const tmp = av_fetch( revcharmap, first_ofs, 0);\n\t\t\t\t    const U8 * const ch = (U8*)SvPV_nolen_const( *tmp );\n\n                                    TRIE_BITMAP_SET_FOLDED(trie,*ch,folder);\n                                    DEBUG_OPTIMISE_r(\n                                        Perl_re_printf( aTHX_  \"%s\", (char*)ch)\n                                    );\n\t\t\t\t}\n\t\t\t    }\n                            /* store the current firstchar in the bitmap */\n                            TRIE_BITMAP_SET_FOLDED(trie,*ch,folder);\n                            DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"%s\", ch));\n\t\t\t}\n                        first_ofs = ofs;\n\t\t    }\n                }\n                if ( count == 1 ) {\n                    /* This state has only one transition, its transition is part\n                     * of a common prefix - we need to concatenate the char it\n                     * represents to what we have so far. */\n                    SV **tmp = av_fetch( revcharmap, first_ofs, 0);\n                    STRLEN len;\n                    char *ch = SvPV( *tmp, len );\n                    DEBUG_OPTIMISE_r({\n                        SV *sv=sv_newmortal();\n                        Perl_re_indentf( aTHX_  \"Prefix State: %\" UVuf \" Ofs:%\" UVuf \" Char='%s'\\n\",\n                            depth+1,\n                            (UV)state, (UV)first_ofs,\n                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6,\n\t                        PL_colors[0], PL_colors[1],\n\t                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |\n\t                        PERL_PV_ESCAPE_FIRSTCHAR\n                            )\n                        );\n                    });\n                    if ( state==1 ) {\n                        OP( convert ) = nodetype;\n                        str=STRING(convert);\n                        STR_LEN(convert)=0;\n                    }\n                    STR_LEN(convert) += len;\n                    while (len--)\n                        *str++ = *ch++;\n\t\t} else {\n#ifdef DEBUGGING\n\t\t    if (state>1)\n                        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"]\\n\"));\n#endif\n\t\t    break;\n\t\t}\n\t    }\n\t    trie->prefixlen = (state-1);\n            if (str) {\n                regnode *n = convert+NODE_SZ_STR(convert);\n                NEXT_OFF(convert) = NODE_SZ_STR(convert);\n                trie->startstate = state;\n                trie->minlen -= (state - 1);\n                trie->maxlen -= (state - 1);\n#ifdef DEBUGGING\n               /* At least the UNICOS C compiler choked on this\n                * being argument to DEBUG_r(), so let's just have\n                * it right here. */\n               if (\n#ifdef PERL_EXT_RE_BUILD\n                   1\n#else\n                   DEBUG_r_TEST\n#endif\n                   ) {\n                   regnode *fix = convert;\n                   U32 word = trie->wordcount;\n                   mjd_nodelen++;\n                   Set_Node_Offset_Length(convert, mjd_offset, state - 1);\n                   while( ++fix < n ) {\n                       Set_Node_Offset_Length(fix, 0, 0);\n                   }\n                   while (word--) {\n                       SV ** const tmp = av_fetch( trie_words, word, 0 );\n                       if (tmp) {\n                           if ( STR_LEN(convert) <= SvCUR(*tmp) )\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + STR_LEN(convert));\n                           else\n                               sv_chop(*tmp, SvPV_nolen(*tmp) + SvCUR(*tmp));\n                       }\n                   }\n               }\n#endif\n                if (trie->maxlen) {\n                    convert = n;\n\t\t} else {\n                    NEXT_OFF(convert) = (U16)(tail - convert);\n                    DEBUG_r(optimize= n);\n                }\n            }\n        }\n        if (!jumper)\n            jumper = last;\n        if ( trie->maxlen ) {\n\t    NEXT_OFF( convert ) = (U16)(tail - convert);\n\t    ARG_SET( convert, data_slot );\n\t    /* Store the offset to the first unabsorbed branch in\n\t       jump[0], which is otherwise unused by the jump logic.\n\t       We use this when dumping a trie and during optimisation. */\n\t    if (trie->jump)\n\t        trie->jump[0] = (U16)(nextbranch - convert);\n\n            /* If the start state is not accepting (meaning there is no empty string/NOTHING)\n\t     *   and there is a bitmap\n\t     *   and the first \"jump target\" node we found leaves enough room\n\t     * then convert the TRIE node into a TRIEC node, with the bitmap\n\t     * embedded inline in the opcode - this is hypothetically faster.\n\t     */\n            if ( !trie->states[trie->startstate].wordnum\n\t\t && trie->bitmap\n\t\t && ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )\n            {\n                OP( convert ) = TRIEC;\n                Copy(trie->bitmap, ((struct regnode_charclass *)convert)->bitmap, ANYOF_BITMAP_SIZE, char);\n                PerlMemShared_free(trie->bitmap);\n                trie->bitmap= NULL;\n            } else\n                OP( convert ) = TRIE;\n\n            /* store the type in the flags */\n            convert->flags = nodetype;\n            DEBUG_r({\n            optimize = convert\n                      + NODE_STEP_REGNODE\n                      + regarglen[ OP( convert ) ];\n            });\n            /* XXX We really should free up the resource in trie now,\n                   as we won't use them - (which resources?) dmq */\n        }\n        /* needed for dumping*/\n        DEBUG_r(if (optimize) {\n            regnode *opt = convert;\n\n            while ( ++opt < optimize) {\n                Set_Node_Offset_Length(opt,0,0);\n            }\n            /*\n                Try to clean up some of the debris left after the\n                optimisation.\n             */\n            while( optimize < jumper ) {\n                mjd_nodelen += Node_Length((optimize));\n                OP( optimize ) = OPTIMIZED;\n                Set_Node_Offset_Length(optimize,0,0);\n                optimize++;\n            }\n            Set_Node_Offset_Length(convert,mjd_offset,mjd_nodelen);\n        });\n    } /* end node insert */\n\n    /*  Finish populating the prev field of the wordinfo array.  Walk back\n     *  from each accept state until we find another accept state, and if\n     *  so, point the first word's .prev field at the second word. If the\n     *  second already has a .prev field set, stop now. This will be the\n     *  case either if we've already processed that word's accept state,\n     *  or that state had multiple words, and the overspill words were\n     *  already linked up earlier.\n     */\n    {\n\tU16 word;\n\tU32 state;\n\tU16 prev;\n\n\tfor (word=1; word <= trie->wordcount; word++) {\n\t    prev = 0;\n\t    if (trie->wordinfo[word].prev)\n\t\tcontinue;\n\t    state = trie->wordinfo[word].accept;\n\t    while (state) {\n\t\tstate = prev_states[state];\n\t\tif (!state)\n\t\t    break;\n\t\tprev = trie->states[state].wordnum;\n\t\tif (prev)\n\t\t    break;\n\t    }\n\t    trie->wordinfo[word].prev = prev;\n\t}\n\tSafefree(prev_states);\n    }\n\n\n    /* and now dump out the compressed format */\n    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));\n\n    RExC_rxi->data->data[ data_slot + 1 ] = (void*)widecharmap;\n#ifdef DEBUGGING\n    RExC_rxi->data->data[ data_slot + TRIE_WORDS_OFFSET ] = (void*)trie_words;\n    RExC_rxi->data->data[ data_slot + 3 ] = (void*)revcharmap;\n#else\n    SvREFCNT_dec_NN(revcharmap);\n#endif\n    return trie->jump\n           ? MADE_JUMP_TRIE\n           : trie->startstate>1\n             ? MADE_EXACT_TRIE\n             : MADE_TRIE;\n}\n\nSTATIC regnode *\nS_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth)\n{\n/* The Trie is constructed and compressed now so we can build a fail array if\n * it's needed\n\n   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and\n   3.32 in the\n   \"Red Dragon\" -- Compilers, principles, techniques, and tools. Aho, Sethi,\n   Ullman 1985/88\n   ISBN 0-201-10088-6\n\n   We find the fail state for each state in the trie, this state is the longest\n   proper suffix of the current state's 'word' that is also a proper prefix of\n   another word in our trie. State 1 represents the word '' and is thus the\n   default fail state. This allows the DFA not to have to restart after its\n   tried and failed a word at a given point, it simply continues as though it\n   had been matching the other word in the first place.\n   Consider\n      'abcdgu'=~/abcdefg|cdgu/\n   When we get to 'd' we are still matching the first word, we would encounter\n   'g' which would fail, which would bring us to the state representing 'd' in\n   the second word where we would try 'g' and succeed, proceeding to match\n   'cdgu'.\n */\n /* add a fail transition */\n    const U32 trie_offset = ARG(source);\n    reg_trie_data *trie=(reg_trie_data *)RExC_rxi->data->data[trie_offset];\n    U32 *q;\n    const U32 ucharcount = trie->uniquecharcount;\n    const U32 numstates = trie->statecount;\n    const U32 ubound = trie->lasttrans + ucharcount;\n    U32 q_read = 0;\n    U32 q_write = 0;\n    U32 charid;\n    U32 base = trie->states[ 1 ].trans.base;\n    U32 *fail;\n    reg_ac_data *aho;\n    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN(\"T\"));\n    regnode *stclass;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE;\n    PERL_UNUSED_CONTEXT;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    if ( OP(source) == TRIE ) {\n        struct regnode_1 *op = (struct regnode_1 *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_1));\n        StructCopy(source,op,struct regnode_1);\n        stclass = (regnode *)op;\n    } else {\n        struct regnode_charclass *op = (struct regnode_charclass *)\n            PerlMemShared_calloc(1, sizeof(struct regnode_charclass));\n        StructCopy(source,op,struct regnode_charclass);\n        stclass = (regnode *)op;\n    }\n    OP(stclass)+=2; /* convert the TRIE type to its AHO-CORASICK equivalent */\n\n    ARG_SET( stclass, data_slot );\n    aho = (reg_ac_data *) PerlMemShared_calloc( 1, sizeof(reg_ac_data) );\n    RExC_rxi->data->data[ data_slot ] = (void*)aho;\n    aho->trie=trie_offset;\n    aho->states=(reg_trie_state *)PerlMemShared_malloc( numstates * sizeof(reg_trie_state) );\n    Copy( trie->states, aho->states, numstates, reg_trie_state );\n    Newx( q, numstates, U32);\n    aho->fail = (U32 *) PerlMemShared_calloc( numstates, sizeof(U32) );\n    aho->refcount = 1;\n    fail = aho->fail;\n    /* initialize fail[0..1] to be 1 so that we always have\n       a valid final fail state */\n    fail[ 0 ] = fail[ 1 ] = 1;\n\n    for ( charid = 0; charid < ucharcount ; charid++ ) {\n\tconst U32 newstate = TRIE_TRANS_STATE( 1, base, ucharcount, charid, 0 );\n\tif ( newstate ) {\n            q[ q_write ] = newstate;\n            /* set to point at the root */\n            fail[ q[ q_write++ ] ]=1;\n        }\n    }\n    while ( q_read < q_write) {\n\tconst U32 cur = q[ q_read++ % numstates ];\n        base = trie->states[ cur ].trans.base;\n\n        for ( charid = 0 ; charid < ucharcount ; charid++ ) {\n\t    const U32 ch_state = TRIE_TRANS_STATE( cur, base, ucharcount, charid, 1 );\n\t    if (ch_state) {\n                U32 fail_state = cur;\n                U32 fail_base;\n                do {\n                    fail_state = fail[ fail_state ];\n                    fail_base = aho->states[ fail_state ].trans.base;\n                } while ( !TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 ) );\n\n                fail_state = TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 );\n                fail[ ch_state ] = fail_state;\n                if ( !aho->states[ ch_state ].wordnum && aho->states[ fail_state ].wordnum )\n                {\n                        aho->states[ ch_state ].wordnum =  aho->states[ fail_state ].wordnum;\n                }\n                q[ q_write++ % numstates] = ch_state;\n            }\n        }\n    }\n    /* restore fail[0..1] to 0 so that we \"fall out\" of the AC loop\n       when we fail in state 1, this allows us to use the\n       charclass scan to find a valid start char. This is based on the principle\n       that theres a good chance the string being searched contains lots of stuff\n       that cant be a start char.\n     */\n    fail[ 0 ] = fail[ 1 ] = 0;\n    DEBUG_TRIE_COMPILE_r({\n        Perl_re_indentf( aTHX_  \"Stclass Failtable (%\" UVuf \" states): 0\",\n                      depth, (UV)numstates\n        );\n        for( q_read=1; q_read<numstates; q_read++ ) {\n            Perl_re_printf( aTHX_  \", %\" UVuf, (UV)fail[q_read]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n    Safefree(q);\n    /*RExC_seen |= REG_TRIEDFA_SEEN;*/\n    return stclass;\n}\n\n\n/* The below joins as many adjacent EXACTish nodes as possible into a single\n * one.  The regop may be changed if the node(s) contain certain sequences that\n * require special handling.  The joining is only done if:\n * 1) there is room in the current conglomerated node to entirely contain the\n *    next one.\n * 2) they are the exact same node type\n *\n * The adjacent nodes actually may be separated by NOTHING-kind nodes, and\n * these get optimized out\n *\n * XXX khw thinks this should be enhanced to fill EXACT (at least) nodes as full\n * as possible, even if that means splitting an existing node so that its first\n * part is moved to the preceeding node.  This would maximise the efficiency of\n * memEQ during matching.  Elsewhere in this file, khw proposes splitting\n * EXACTFish nodes into portions that don't change under folding vs those that\n * do.  Those portions that don't change may be the only things in the pattern that\n * could be used to find fixed and floating strings.\n *\n * If a node is to match under /i (folded), the number of characters it matches\n * can be different than its character length if it contains a multi-character\n * fold.  *min_subtract is set to the total delta number of characters of the\n * input nodes.\n *\n * And *unfolded_multi_char is set to indicate whether or not the node contains\n * an unfolded multi-char fold.  This happens when whether the fold is valid or\n * not won't be known until runtime; namely for EXACTF nodes that contain LATIN\n * SMALL LETTER SHARP S, as only if the target string being matched against\n * turns out to be UTF-8 is that fold valid; and also for EXACTFL nodes whose\n * folding rules depend on the locale in force at runtime.  (Multi-char folds\n * whose components are all above the Latin1 range are not run-time locale\n * dependent, and have already been folded by the time this function is\n * called.)\n *\n * This is as good a place as any to discuss the design of handling these\n * multi-character fold sequences.  It's been wrong in Perl for a very long\n * time.  There are three code points in Unicode whose multi-character folds\n * were long ago discovered to mess things up.  The previous designs for\n * dealing with these involved assigning a special node for them.  This\n * approach doesn't always work, as evidenced by this example:\n *      \"\\xDFs\" =~ /s\\xDF/ui    # Used to fail before these patches\n * Both sides fold to \"sss\", but if the pattern is parsed to create a node that\n * would match just the \\xDF, it won't be able to handle the case where a\n * successful match would have to cross the node's boundary.  The new approach\n * that hopefully generally solves the problem generates an EXACTFU_SS node\n * that is \"sss\" in this case.\n *\n * It turns out that there are problems with all multi-character folds, and not\n * just these three.  Now the code is general, for all such cases.  The\n * approach taken is:\n * 1)   This routine examines each EXACTFish node that could contain multi-\n *      character folded sequences.  Since a single character can fold into\n *      such a sequence, the minimum match length for this node is less than\n *      the number of characters in the node.  This routine returns in\n *      *min_subtract how many characters to subtract from the the actual\n *      length of the string to get a real minimum match length; it is 0 if\n *      there are no multi-char foldeds.  This delta is used by the caller to\n *      adjust the min length of the match, and the delta between min and max,\n *      so that the optimizer doesn't reject these possibilities based on size\n *      constraints.\n * 2)   For the sequence involving the Sharp s (\\xDF), the node type EXACTFU_SS\n *      is used for an EXACTFU node that contains at least one \"ss\" sequence in\n *      it.  For non-UTF-8 patterns and strings, this is the only case where\n *      there is a possible fold length change.  That means that a regular\n *      EXACTFU node without UTF-8 involvement doesn't have to concern itself\n *      with length changes, and so can be processed faster.  regexec.c takes\n *      advantage of this.  Generally, an EXACTFish node that is in UTF-8 is\n *      pre-folded by regcomp.c (except EXACTFL, some of whose folds aren't\n *      known until runtime).  This saves effort in regex matching.  However,\n *      the pre-folding isn't done for non-UTF8 patterns because the fold of\n *      the MICRO SIGN requires UTF-8, and we don't want to slow things down by\n *      forcing the pattern into UTF8 unless necessary.  Also what EXACTF (and,\n *      again, EXACTFL) nodes fold to isn't known until runtime.  The fold\n *      possibilities for the non-UTF8 patterns are quite simple, except for\n *      the sharp s.  All the ones that don't involve a UTF-8 target string are\n *      members of a fold-pair, and arrays are set up for all of them so that\n *      the other member of the pair can be found quickly.  Code elsewhere in\n *      this file makes sure that in EXACTFU nodes, the sharp s gets folded to\n *      'ss', even if the pattern isn't UTF-8.  This avoids the issues\n *      described in the next item.\n * 3)   A problem remains for unfolded multi-char folds. (These occur when the\n *      validity of the fold won't be known until runtime, and so must remain\n *      unfolded for now.  This happens for the sharp s in EXACTF and EXACTFA\n *      nodes when the pattern isn't in UTF-8.  (Note, BTW, that there cannot\n *      be an EXACTF node with a UTF-8 pattern.)  They also occur for various\n *      folds in EXACTFL nodes, regardless of the UTF-ness of the pattern.)\n *      The reason this is a problem is that the optimizer part of regexec.c\n *      (probably unwittingly, in Perl_regexec_flags()) makes an assumption\n *      that a character in the pattern corresponds to at most a single\n *      character in the target string.  (And I do mean character, and not byte\n *      here, unlike other parts of the documentation that have never been\n *      updated to account for multibyte Unicode.)  sharp s in EXACTF and\n *      EXACTFL nodes can match the two character string 'ss'; in EXACTFA nodes\n *      it can match \"\\x{17F}\\x{17F}\".  These, along with other ones in EXACTFL\n *      nodes, violate the assumption, and they are the only instances where it\n *      is violated.  I'm reluctant to try to change the assumption, as the\n *      code involved is impenetrable to me (khw), so instead the code here\n *      punts.  This routine examines EXACTFL nodes, and (when the pattern\n *      isn't UTF-8) EXACTF and EXACTFA for such unfolded folds, and returns a\n *      boolean indicating whether or not the node contains such a fold.  When\n *      it is true, the caller sets a flag that later causes the optimizer in\n *      this file to not set values for the floating and fixed string lengths,\n *      and thus avoids the optimizer code in regexec.c that makes the invalid\n *      assumption.  Thus, there is no optimization based on string lengths for\n *      EXACTFL nodes that contain these few folds, nor for non-UTF8-pattern\n *      EXACTF and EXACTFA nodes that contain the sharp s.  (The reason the\n *      assumption is wrong only in these cases is that all other non-UTF-8\n *      folds are 1-1; and, for UTF-8 patterns, we pre-fold all other folds to\n *      their expanded versions.  (Again, we can't prefold sharp s to 'ss' in\n *      EXACTF nodes because we don't know at compile time if it actually\n *      matches 'ss' or not.  For EXACTF nodes it will match iff the target\n *      string is in UTF-8.  This is in contrast to EXACTFU nodes, where it\n *      always matches; and EXACTFA where it never does.  In an EXACTFA node in\n *      a UTF-8 pattern, sharp s is folded to \"\\x{17F}\\x{17F}, avoiding the\n *      problem; but in a non-UTF8 pattern, folding it to that above-Latin1\n *      string would require the pattern to be forced into UTF-8, the overhead\n *      of which we want to avoid.  Similarly the unfolded multi-char folds in\n *      EXACTFL nodes will match iff the locale at the time of match is a UTF-8\n *      locale.)\n *\n *      Similarly, the code that generates tries doesn't currently handle\n *      not-already-folded multi-char folds, and it looks like a pain to change\n *      that.  Therefore, trie generation of EXACTFA nodes with the sharp s\n *      doesn't work.  Instead, such an EXACTFA is turned into a new regnode,\n *      EXACTFA_NO_TRIE, which the trie code knows not to handle.  Most people\n *      using /iaa matching will be doing so almost entirely with ASCII\n *      strings, so this should rarely be encountered in practice */\n\n#define JOIN_EXACT(scan,min_subtract,unfolded_multi_char, flags) \\\n    if (PL_regkind[OP(scan)] == EXACT) \\\n        join_exact(pRExC_state,(scan),(min_subtract),unfolded_multi_char, (flags),NULL,depth+1)\n\nSTATIC U32\nS_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan,\n                   UV *min_subtract, bool *unfolded_multi_char,\n                   U32 flags,regnode *val, U32 depth)\n{\n    /* Merge several consecutive EXACTish nodes into one. */\n    regnode *n = regnext(scan);\n    U32 stringok = 1;\n    regnode *next = scan + NODE_SZ_STR(scan);\n    U32 merged = 0;\n    U32 stopnow = 0;\n#ifdef DEBUGGING\n    regnode *stop = scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n#else\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    PERL_ARGS_ASSERT_JOIN_EXACT;\n#ifndef EXPERIMENTAL_INPLACESCAN\n    PERL_UNUSED_ARG(flags);\n    PERL_UNUSED_ARG(val);\n#endif\n    DEBUG_PEEP(\"join\", scan, depth, 0);\n\n    /* Look through the subsequent nodes in the chain.  Skip NOTHING, merge\n     * EXACT ones that are mergeable to the current one. */\n    while (n\n           && (PL_regkind[OP(n)] == NOTHING\n               || (stringok && OP(n) == OP(scan)))\n           && NEXT_OFF(n)\n           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX)\n    {\n\n        if (OP(n) == TAIL || n > next)\n            stringok = 0;\n        if (PL_regkind[OP(n)] == NOTHING) {\n            DEBUG_PEEP(\"skip:\", n, depth, 0);\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            next = n + NODE_STEP_REGNODE;\n#ifdef DEBUGGING\n            if (stringok)\n                stop = n;\n#endif\n            n = regnext(n);\n        }\n        else if (stringok) {\n            const unsigned int oldl = STR_LEN(scan);\n            regnode * const nnext = regnext(n);\n\n            /* XXX I (khw) kind of doubt that this works on platforms (should\n             * Perl ever run on one) where U8_MAX is above 255 because of lots\n             * of other assumptions */\n            /* Don't join if the sum can't fit into a single node */\n            if (oldl + STR_LEN(n) > U8_MAX)\n                break;\n\n            DEBUG_PEEP(\"merg\", n, depth, 0);\n            merged++;\n\n            NEXT_OFF(scan) += NEXT_OFF(n);\n            STR_LEN(scan) += STR_LEN(n);\n            next = n + NODE_SZ_STR(n);\n            /* Now we can overwrite *n : */\n            Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);\n#ifdef DEBUGGING\n            stop = next - 1;\n#endif\n            n = nnext;\n            if (stopnow) break;\n        }\n\n#ifdef EXPERIMENTAL_INPLACESCAN\n\tif (flags && !NEXT_OFF(n)) {\n\t    DEBUG_PEEP(\"atch\", val, depth, 0);\n\t    if (reg_off_by_arg[OP(n)]) {\n\t\tARG_SET(n, val - n);\n\t    }\n\t    else {\n\t\tNEXT_OFF(n) = val - n;\n\t    }\n\t    stopnow = 1;\n\t}\n#endif\n    }\n\n    *min_subtract = 0;\n    *unfolded_multi_char = FALSE;\n\n    /* Here, all the adjacent mergeable EXACTish nodes have been merged.  We\n     * can now analyze for sequences of problematic code points.  (Prior to\n     * this final joining, sequences could have been split over boundaries, and\n     * hence missed).  The sequences only happen in folding, hence for any\n     * non-EXACT EXACTish node */\n    if (OP(scan) != EXACT && OP(scan) != EXACTL) {\n        U8* s0 = (U8*) STRING(scan);\n        U8* s = s0;\n        U8* s_end = s0 + STR_LEN(scan);\n\n        int total_count_delta = 0;  /* Total delta number of characters that\n                                       multi-char folds expand to */\n\n\t/* One pass is made over the node's string looking for all the\n\t * possibilities.  To avoid some tests in the loop, there are two main\n\t * cases, for UTF-8 patterns (which can't have EXACTF nodes) and\n\t * non-UTF-8 */\n\tif (UTF) {\n            U8* folded = NULL;\n\n            if (OP(scan) == EXACTFL) {\n                U8 *d;\n\n                /* An EXACTFL node would already have been changed to another\n                 * node type unless there is at least one character in it that\n                 * is problematic; likely a character whose fold definition\n                 * won't be known until runtime, and so has yet to be folded.\n                 * For all but the UTF-8 locale, folds are 1-1 in length, but\n                 * to handle the UTF-8 case, we need to create a temporary\n                 * folded copy using UTF-8 locale rules in order to analyze it.\n                 * This is because our macros that look to see if a sequence is\n                 * a multi-char fold assume everything is folded (otherwise the\n                 * tests in those macros would be too complicated and slow).\n                 * Note that here, the non-problematic folds will have already\n                 * been done, so we can just copy such characters.  We actually\n                 * don't completely fold the EXACTFL string.  We skip the\n                 * unfolded multi-char folds, as that would just create work\n                 * below to figure out the size they already are */\n\n                Newx(folded, UTF8_MAX_FOLD_CHAR_EXPAND * STR_LEN(scan) + 1, U8);\n                d = folded;\n                while (s < s_end) {\n                    STRLEN s_len = UTF8SKIP(s);\n                    if (! is_PROBLEMATIC_LOCALE_FOLD_utf8(s)) {\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (is_FOLDS_TO_MULTI_utf8(s)) {\n                        *unfolded_multi_char = TRUE;\n                        Copy(s, d, s_len, U8);\n                        d += s_len;\n                    }\n                    else if (isASCII(*s)) {\n                        *(d++) = toFOLD(*s);\n                    }\n                    else {\n                        STRLEN len;\n                        _toFOLD_utf8_flags(s, s_end, d, &len, FOLD_FLAGS_FULL);\n                        d += len;\n                    }\n                    s += s_len;\n                }\n\n                /* Point the remainder of the routine to look at our temporary\n                 * folded copy */\n                s = folded;\n                s_end = d;\n            } /* End of creating folded copy of EXACTFL string */\n\n            /* Examine the string for a multi-character fold sequence.  UTF-8\n             * patterns have all characters pre-folded by the time this code is\n             * executed */\n            while (s < s_end - 1) /* Can stop 1 before the end, as minimum\n                                     length sequence we are looking for is 2 */\n\t    {\n                int count = 0;  /* How many characters in a multi-char fold */\n                int len = is_MULTI_CHAR_FOLD_utf8_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold: get next char */\n                    s += UTF8SKIP(s);\n                    continue;\n                }\n\n                /* Nodes with 'ss' require special handling, except for\n                 * EXACTFA-ish for which there is no multi-char fold to this */\n                if (len == 2 && *s == 's' && *(s+1) == 's'\n                    && OP(scan) != EXACTFA\n                    && OP(scan) != EXACTFA_NO_TRIE)\n                {\n                    count = 2;\n                    if (OP(scan) != EXACTFL) {\n                        OP(scan) = EXACTFU_SS;\n                    }\n                    s += 2;\n                }\n                else { /* Here is a generic multi-char fold. */\n                    U8* multi_end  = s + len;\n\n                    /* Count how many characters are in it.  In the case of\n                     * /aa, no folds which contain ASCII code points are\n                     * allowed, so check for those, and skip if found. */\n                    if (OP(scan) != EXACTFA && OP(scan) != EXACTFA_NO_TRIE) {\n                        count = utf8_length(s, multi_end);\n                        s = multi_end;\n                    }\n                    else {\n                        while (s < multi_end) {\n                            if (isASCII(*s)) {\n                                s++;\n                                goto next_iteration;\n                            }\n                            else {\n                                s += UTF8SKIP(s);\n                            }\n                            count++;\n                        }\n                    }\n                }\n\n                /* The delta is how long the sequence is minus 1 (1 is how long\n                 * the character that folds to the sequence is) */\n                total_count_delta += count - 1;\n              next_iteration: ;\n\t    }\n\n            /* We created a temporary folded copy of the string in EXACTFL\n             * nodes.  Therefore we need to be sure it doesn't go below zero,\n             * as the real string could be shorter */\n            if (OP(scan) == EXACTFL) {\n                int total_chars = utf8_length((U8*) STRING(scan),\n                                           (U8*) STRING(scan) + STR_LEN(scan));\n                if (total_count_delta > total_chars) {\n                    total_count_delta = total_chars;\n                }\n            }\n\n            *min_subtract += total_count_delta;\n            Safefree(folded);\n\t}\n\telse if (OP(scan) == EXACTFA) {\n\n            /* Non-UTF-8 pattern, EXACTFA node.  There can't be a multi-char\n             * fold to the ASCII range (and there are no existing ones in the\n             * upper latin1 range).  But, as outlined in the comments preceding\n             * this function, we need to flag any occurrences of the sharp s.\n             * This character forbids trie formation (because of added\n             * complexity) */\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n\t    while (s < s_end) {\n                if (*s == LATIN_SMALL_LETTER_SHARP_S) {\n                    OP(scan) = EXACTFA_NO_TRIE;\n                    *unfolded_multi_char = TRUE;\n                    break;\n                }\n                s++;\n            }\n        }\n\telse {\n\n            /* Non-UTF-8 pattern, not EXACTFA node.  Look for the multi-char\n             * folds that are all Latin1.  As explained in the comments\n             * preceding this function, we look also for the sharp s in EXACTF\n             * and EXACTFL nodes; it can be in the final position.  Otherwise\n             * we can stop looking 1 byte earlier because have to find at least\n             * two characters for a multi-fold */\n\t    const U8* upper = (OP(scan) == EXACTF || OP(scan) == EXACTFL)\n                              ? s_end\n                              : s_end -1;\n\n\t    while (s < upper) {\n                int len = is_MULTI_CHAR_FOLD_latin1_safe(s, s_end);\n                if (! len) {    /* Not a multi-char fold. */\n                    if (*s == LATIN_SMALL_LETTER_SHARP_S\n                        && (OP(scan) == EXACTF || OP(scan) == EXACTFL))\n                    {\n                        *unfolded_multi_char = TRUE;\n                    }\n                    s++;\n                    continue;\n                }\n\n                if (len == 2\n                    && isALPHA_FOLD_EQ(*s, 's')\n                    && isALPHA_FOLD_EQ(*(s+1), 's'))\n                {\n\n                    /* EXACTF nodes need to know that the minimum length\n                     * changed so that a sharp s in the string can match this\n                     * ss in the pattern, but they remain EXACTF nodes, as they\n                     * won't match this unless the target string is is UTF-8,\n                     * which we don't know until runtime.  EXACTFL nodes can't\n                     * transform into EXACTFU nodes */\n                    if (OP(scan) != EXACTF && OP(scan) != EXACTFL) {\n                        OP(scan) = EXACTFU_SS;\n                    }\n\t\t}\n\n                *min_subtract += len - 1;\n                s += len;\n\t    }\n#endif\n\t}\n    }\n\n#ifdef DEBUGGING\n    /* Allow dumping but overwriting the collection of skipped\n     * ops and/or strings with fake optimized ops */\n    n = scan + NODE_SZ_STR(scan);\n    while (n <= stop) {\n\tOP(n) = OPTIMIZED;\n\tFLAGS(n) = 0;\n\tNEXT_OFF(n) = 0;\n        n++;\n    }\n#endif\n    DEBUG_OPTIMISE_r(if (merged){DEBUG_PEEP(\"finl\", scan, depth, 0);});\n    return stopnow;\n}\n\n/* REx optimizer.  Converts nodes into quicker variants \"in place\".\n   Finds fixed substrings.  */\n\n/* Stops at toplevel WHILEM as well as at \"last\". At end *scanp is set\n   to the position after last scanned or to NULL. */\n\n#define INIT_AND_WITHP \\\n    assert(!and_withp); \\\n    Newx(and_withp,1, regnode_ssc); \\\n    SAVEFREEPV(and_withp)\n\n\nstatic void\nS_unwind_scan_frames(pTHX_ const void *p)\n{\n    scan_frame *f= (scan_frame *)p;\n    do {\n        scan_frame *n= f->next_frame;\n        Safefree(f);\n        f= n;\n    } while (f);\n}\n\n\nSTATIC SSize_t\nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth)\n\t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    /* There must be at least this number of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i = 0 ; i < (U32)RExC_npar ; i++ ) {\n                    if (\n                        PAREN_TEST(RExC_study_chunk_recursed +\n                                   ( j * RExC_study_chunk_recursed_bytes), i )\n                        && (\n                            !j ||\n                            !PAREN_TEST(RExC_study_chunk_recursed +\n                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                        )\n                    ) {\n                        Perl_re_printf( aTHX_ \" %d\",(int)i);\n                        break;\n                    }\n                }\n                if ( j + 1 < recursed_depth ) {\n                    Perl_re_printf( aTHX_  \",\");\n                }\n            }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum\n                                   node length to get a real minimum (because\n                                   the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n\t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT\n         * parsing code, as each (?:..) is handled by a different invocation of\n         * reg() -- Yves\n         */\n        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n\n\t/* Follow the next-chain of the current node and optimize\n\t   away all the NOTHINGs from it.  */\n\tif (OP(scan) != CURLYX) {\n\t    const int max = (reg_off_by_arg[OP(scan)]\n\t\t       ? I32_MAX\n\t\t       /* I32 may be smaller than U16 on CRAYs! */\n\t\t       : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));\n\t    int off = (reg_off_by_arg[OP(scan)] ? ARG(scan) : NEXT_OFF(scan));\n\t    int noff;\n\t    regnode *n = scan;\n\n\t    /* Skip NOTHING and LONGJMP. */\n\t    while ((n = regnext(n))\n\t\t   && ((PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))\n\t\t       || ((OP(n) == LONGJMP) && (noff = ARG(n))))\n\t\t   && off + noff < max)\n\t\toff += noff;\n\t    if (reg_off_by_arg[OP(scan)])\n\t\tARG(scan) = off;\n\t    else\n\t\tNEXT_OFF(scan) = off;\n\t}\n\n\t/* The principal pseudo-switch.  Cannot be a switch, since we\n\t   look into several different things.  */\n        if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n            SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n            I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan) == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"next\", next, depth, flags);\n\n            /* we suppose the run is continuous, last=next...\n             * NOTE we dont use the return here! */\n            /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state, &scan, &minlen,\n                              &deltanext, next, &data_fake, stopparen,\n                              recursed_depth, NULL, f, depth+1);\n\n            scan = next;\n        } else\n        if (\n            OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n            OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\n             * IFTHEN is special as it might not appear in pairs.\n             * Not sure whether BRANCH-BRANCHJ is possible, regardless\n             * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN) {\n                /* NOTE - There is similar code to this block below for\n                 * handling TRIE nodes on a re-study.  If you change stuff here\n                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge strings after this. */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\tssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous, last=next...*/\n                    /* recurse study_chunk() for each BRANCH in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                      &deltanext, next, &data_fake, stopparen,\n                                      recursed_depth, NULL, f,depth+1);\n\n\t\t    if (min1 > minnext)\n\t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf = is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin > minnext)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 != min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION &&\n                        OP( startbranch ) == BRANCH )\n                {\n\t\t/* demq.\n\n                   Assuming this was/is a branch we are dealing with: 'scan'\n                   now points at the item that follows the branch sequence,\n                   whatever it is. We now start at the beginning of the\n                   sequence and look for subsequences of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n                   which would be constructed from a pattern like\n                   /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need to turn the first\n\t\t   element into a trie and then add the subsequent branch exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n                     1. patterns where the whole set of branches can be\n                        converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE; BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t    if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0  ) {\n                        regnode *cur;\n                        regnode *first = (regnode *)NULL;\n                        regnode *last = (regnode *)NULL;\n                        regnode *tail = scan;\n                        U8 trietype = 0;\n                        U32 count=0;\n\n                        /* var tail is used because there may be a TAIL\n                           regop in the way. Ie, the exacts will point to the\n                           thing following the TAIL, but the last branch will\n                           point at the TAIL. So we advance tail. If we\n                           have nested (?:) we may have to move through several\n                           tails.\n                         */\n\n                        while ( OP( tail ) == TAIL ) {\n                            /* this is the TAIL generated by (?:) */\n                            tail = regnext( tail );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                              depth+1,\n                              \"Looking for TRIE'able sequences. Tail node is \",\n                              (UV)(tail - RExC_emit_start),\n                              SvPV_nolen_const( RExC_mysv )\n                            );\n                        });\n\n                        /*\n\n                            Step through the branches\n                                cur represents each branch,\n                                noper is the first thing to be matched as part\n                                      of that branch\n                                noper_next is the regnext() of that node.\n\n                            We normally handle a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump trie\" but we also\n                            support building with NOJUMPTRIE, which restricts\n                            the trie logic to structures like /FOO|BAR/.\n\n                            If noper is a trieable nodetype then the branch is\n                            a possible optimization target. If we are building\n                            under NOJUMPTRIE then we require that noper_next is\n                            the same as scan (our current position in the regex\n                            program).\n\n                            Once we have two or more consecutive such branches\n                            we can create a trie of the EXACT's contents and\n                            stitch it in place into the program.\n\n                            If the sequence represents all of the branches in\n                            the alternation we replace the entire thing with a\n                            single TRIE node.\n\n                            Otherwise when it is a subsequence we need to\n                            stitch it in place and replace only the relevant\n                            branches. This means the first branch has to remain\n                            as it is used by the alternation logic, and its\n                            next pointer, and needs to be repointed at the item\n                            on the branch chain following the last branch we\n                            have optimized away.\n\n                            This could be either a BRANCH, in which case the\n                            subsequence is internal, or it could be the item\n                            following the branch sequence in which case the\n                            subsequence is at the end (which does not\n                            necessarily mean the first node is the start of the\n                            alternation).\n\n                            TRIE_TYPE(X) is a define which maps the optype to a\n                            trietype.\n\n                                optype          |  trietype\n                                ----------------+-----------\n                                NOTHING         | NOTHING\n                                EXACT           | EXACT\n                                EXACTFU         | EXACTFU\n                                EXACTFU_SS      | EXACTFU\n                                EXACTFA         | EXACTFA\n                                EXACTL          | EXACTL\n                                EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                       ? NOTHING                                            \\\n                       : ( EXACT == (X) )                                   \\\n                         ? EXACT                                            \\\n                         : ( EXACTFU == (X) || EXACTFU_SS == (X) )          \\\n                           ? EXACTFU                                        \\\n                           : ( EXACTFA == (X) )                             \\\n                             ? EXACTFA                                      \\\n                             : ( EXACTL == (X) )                            \\\n                               ? EXACTL                                     \\\n                               : ( EXACTFLU8 == (X) )                        \\\n                                 ? EXACTFLU8                                 \\\n                                 : 0 )\n\n                        /* dont use tail as the end marker for this traverse */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                            regnode * const noper = NEXTOPER( cur );\n                            U8 noper_type = OP( noper );\n                            U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                            regnode * const noper_next = regnext( noper );\n                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                   depth+1,\n                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\n                                if ( noper_next ) {\n                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                  Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                }\n                                Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\t\t\t\t);\n                            });\n\n                            /* Is noper a trieable nodetype that can be merged\n                             * with the current trie (if there is one)? */\n                            if ( noper_trietype\n                                  &&\n                                  (\n                                        ( noper_trietype == NOTHING )\n                                        || ( trietype == NOTHING )\n                                        || ( trietype == noper_trietype )\n                                  )\n#ifdef NOJUMPTRIE\n                                  && noper_next >= tail\n#endif\n                                  && count < U16_MAX)\n                            {\n                                /* Handle mergable triable node Either we are\n                                 * the first node in a new trieable sequence,\n                                 * in which case we do some bookkeeping,\n                                 * otherwise we update the end pointer. */\n                                if ( !first ) {\n                                    first = cur;\n\t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                                        if ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n                                        } else if (noper_next_type)  {\n                                            /* a NOTHING regop is 1 regop wide.\n                                             * We need at least two for a trie\n                                             * so we can't merge this in */\n                                            first = NULL;\n                                        }\n                                    } else {\n                                        trietype = noper_trietype;\n                                    }\n                                } else {\n                                    if ( trietype == NOTHING )\n                                        trietype = noper_trietype;\n                                    last = cur;\n                                }\n\t\t\t\tif (first)\n\t\t\t\t    count++;\n                            } /* end handle mergable triable node */\n                            else {\n                                /* handle unmergable node -\n                                 * noper may either be a triable node which can\n                                 * not be tried together with the current trie,\n                                 * or a non triable node */\n                                if ( last ) {\n                                    /* If last is set and trietype is not\n                                     * NOTHING then we have found at least two\n                                     * triable branch sequences in a row of a\n                                     * similar trietype so we can turn them\n                                     * into a trie. If/when we allow NOTHING to\n                                     * start a trie sequence this condition\n                                     * will be required, and it isn't expensive\n                                     * so we leave it in for now. */\n                                    if ( trietype && trietype != NOTHING )\n                                        make_trie( pRExC_state,\n                                                startbranch, first, cur, tail,\n                                                count, trietype, depth+1 );\n                                    last = NULL; /* note: we clear/update\n                                                    first, trietype etc below,\n                                                    so we dont do it here */\n                                }\n                                if ( noper_trietype\n#ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n#endif\n                                ){\n                                    /* noper is triable, so we can start a new\n                                     * trie sequence */\n                                    count = 1;\n                                    first = cur;\n                                    trietype = noper_trietype;\n                                } else if (first) {\n                                    /* if we already saw a first but the\n                                     * current node is not triable then we have\n                                     * to reset the first information. */\n                                    count = 0;\n                                    first = NULL;\n                                    trietype = 0;\n                                }\n                            } /* end handle unmergable node */\n                        } /* loop over branches */\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1, SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));\n                            Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                               PL_reg_name[trietype]\n                            );\n\n                        });\n                        if ( last && trietype ) {\n                            if ( trietype != NOTHING ) {\n                                /* the last branch of the sequence was part of\n                                 * a trie, so we have to construct it here\n                                 * outside of the loop */\n                                made= make_trie( pRExC_state, startbranch,\n                                                 first, scan, tail, count,\n                                                 trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n                                if ( ((made == MADE_EXACT_TRIE &&\n                                     startbranch == first)\n                                     || ( first_non_open == first )) &&\n                                     depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n                                    if ( startbranch == first\n                                         && scan >= tail )\n                                    {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                    }\n                                }\n#endif\n                            } else {\n                                /* at this point we know whatever we have is a\n                                 * NOTHING sequence/branch AND if 'startbranch'\n                                 * is 'first' then we can turn the whole thing\n                                 * into a NOTHING\n                                 */\n                                if ( startbranch == first ) {\n                                    regnode *opt;\n                                    /* the entire thing is a NOTHING sequence,\n                                     * something like this: (?:|) So we can\n                                     * turn it into a plain NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                        Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                          depth+1,\n                                          SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));\n\n                                    });\n                                    OP(startbranch)= NOTHING;\n                                    NEXT_OFF(startbranch)= tail - startbranch;\n                                    for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                        OP(opt)= OPTIMIZED;\n                                }\n                            }\n                        } /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ ) {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n            I32 paren = 0;\n            regnode *start = NULL;\n            regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup, note this code has side effects beyond\n                 * the rest of this block. Specifically setting\n                 * RExC_recurse[] must happen at least once during\n                 * study_chunk(). */\n                paren = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n                start = RExC_open_parens[paren];\n                end   = RExC_close_parens[paren];\n\n                /* NOTE we MUST always execute the above code, even\n                 * if we do nothing with a GOSUB */\n                if (\n                    ( flags & SCF_IN_DEFINE )\n                    ||\n                    (\n                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                        &&\n                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n                ) {\n                    /* no need to do anything here if we are in a define. */\n                    /* or we are after some kind of infinite construct\n                     * so we can skip recursing into this item.\n                     * Since it is infinite we will not change the maxlen\n                     * or delta, and if we miss something that might raise\n                     * the minlen it will merely pessimise a little.\n                     *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n                     * might result in a minlen of 1 and not of 4,\n                     * but this doesn't make us mismatch, just try a bit\n                     * harder than we should.\n                     * */\n                    scan= regnext(scan);\n                    continue;\n                }\n\n                if (\n                    !recursed_depth\n                    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n                    /* it is quite possible that there are more efficient ways\n                     * to do this. We maintain a bitmap per level of recursion\n                     * of which patterns we have entered so we can detect if a\n                     * pattern creates a possible infinite loop. When we\n                     * recurse down a level we copy the previous levels bitmap\n                     * down. When we are at recursion level 0 we zero the top\n                     * level bitmap. It would be nice to implement a different\n                     * more efficient way of doing this. In particular the top\n                     * level bitmap may be unnecessary.\n                     */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed_bytes, U8);\n                    }\n                    /* we havent recursed into this paren yet, so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth= recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite recursion, assume infinite length\n                     * */\n                    if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n                    }\n                    is_inf = is_inf_internal = 1;\n                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n                        ssc_anything(data->start_class);\n                    flags &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we dont recurse later on. */\n\t        }\n            } else {\n\t        paren = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\t    }\n            if (start) {\n                scan_frame *newframe;\n                assert(end);\n                if (!RExC_frame_last) {\n                    Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                    RExC_frame_head= newframe;\n                    RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame) {\n                    Newxz(newframe,1,scan_frame);\n                    RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame= RExC_frame_last;\n                    RExC_frame_count++;\n                } else {\n                    newframe= RExC_frame_last->next_frame;\n                }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode = regnext(scan);\n                newframe->last_regnode = last;\n                newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth = recursed_depth;\n                newframe->this_prev_frame= frame;\n\n                DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan, depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t        stopparen = paren;\n\t        last = end;\n                depth = depth + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\t    }\n\t}\n\telse if (OP(scan) == EXACT || OP(scan) == EXACTL) {\n\t    SSize_t l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset, later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t    data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                              (U8*)STRING(scan)+STR_LEN(scan));\n\t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n            /* ANDing the code point leaves at most it, and not in locale, and\n             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND) {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class, uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)] == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /* Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n            delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan) != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                    ANYOF_POSIXL_ZERO(data->start_class);\n                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                flags &= ~SCF_DO_STCLASS;\n                SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan))) {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)* . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\t\t    if (OP(next) == EXACT\n                        || OP(next) == EXACTL\n                        || (flags & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX) {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear cache processing any {n,m}\n\t\t   regops for which the combination of input pos and regex\n\t\t   pos is not enough information to determine if a match\n\t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t/* This will finish on WHILEM, setting scan, or on NULL: */\n                /* recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                  last, data, stopparen, recursed_depth, NULL,\n                                  (mincount == 0\n                                   ? (f & ~SCF_DO_SUBSTR)\n                                   : f)\n                                  ,depth+1);\n\n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n                                                |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan = next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                    && maxcount <= REG_INFTY/3) /* Complement check for big\n                                                   count */\n\t\t{\n\t\t    /* Fatal warnings may leak the regexp without this: */\n\t\t    SAVEFREESV(RExC_rx_sv);\n\t\t    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n\t\t\t\"Quantifier unexpected on zero-length expression \"\n\t\t\t\"in regex m/%\" UTF8f \"/\",\n\t\t\t UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp));\n\t\t    (void)ReREFCNT_inc(RExC_rx_sv);\n\t\t}\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext == SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext + deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf) {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta += (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext == 1 ) {\n\t\t    /* Try to optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n#endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens) {\n                        RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/\n                        RExC_close_parens[ARG(nxt1)]=nxt+2; /*close->while*/\n\t\t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t/* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t}\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t      && minnext != 0\t/* CURLYM can't handle zero width */\n\n                         /* Nor characters whose fold at run-time may be\n                          * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\t\t) {\n\t\t    /* XXXX How to optimize if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif (RExC_open_parens) {\n                            RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/\n                            RExC_close_parens[ARG(nxt1)]=nxt2+1; /*close->NOTHING*/\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t    }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n                        /* recurse study_chunk() on optimised CURLYX => CURLYM */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                    NULL, stopparen, recursed_depth, NULL, 0,depth+1);\n\t\t    }\n\t\t    else\n\t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair. */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n                    if (nxt->flags & 0xf) {\n                        /* we've already set whilem count on this node */\n                    } else if (++data->whilem_c < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n                        nxt->flags = (U8)(data->whilem_c\n                            | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                    if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                                                                  string. */\n\t\t\tSSize_t b = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\t\t\tSSize_t old = b - data->last_start_min;\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop((U8*)s, old) - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                        last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                            (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str), l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\tSvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                                last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t    data->last_start_max =\n                              is_inf\n                               ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n                                 (maxcount - 1) * (minnext + data->pos_delta);\n\t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\nPerl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\t\t\t    the group.  */\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /* float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data && (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\t\tif (OP(oscan) != CURLYX) {\n\t\t    while (PL_regkind[OP(next = regnext(oscan))] == NOTHING\n\t\t\t   && NEXT_OFF(next))\n\t\t\tNEXT_OFF(oscan) += NEXT_OFF(next);\n\t\t}\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                    OP(scan));\n#endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    /* Cannot expect anything... */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n                        /* Actually is any start char, but very few code points\n                         * aren't start characters */\n                        ssc_match_all_cp(data->start_class);\n                    }\n                    else {\n                        ssc_anything(data->start_class);\n                    }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS) {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                    ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n                              PL_XPosix_ptrs[_CC_VERTSPACE],\n                              FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg for\n                     * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n            if (delta != SSize_t_MAX)\n                delta++;    /* Because of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n\t        data->pos_delta += 1;\n\t\tdata->cur_is_floating = 1; /* float */\n    \t    }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                     OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t    break;\n\n\t\tcase REG_ANY:\n                    {\n                        SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                            '\\n');\n                        if (flags & SCF_DO_STCLASS_OR) {\n                            ssc_union(data->start_class,\n                                      REG_ANY_invlist,\n                                      TRUE /* TRUE => invert, hence all but \\n\n                                            */\n                                      );\n                        }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n                            ssc_intersection(data->start_class,\n                                             REG_ANY_invlist,\n                                             TRUE  /* TRUE => invert */\n                                             );\n                            ssc_clear_locale(data->start_class);\n                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case ANYOFL:\n                case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class,\n                                (regnode_charclass *) scan);\n\t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                                                          (regnode_charclass *) scan);\n\t\t    break;\n\n\t\tcase NPOSIXL:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        bool was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n                                                                 namedclass));\n                        ANYOF_POSIXL_ZERO(data->start_class);\n                        if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                        /* No individual code points can now match */\n                        data->start_class->invlist\n                                                = sv_2mortal(_new_invlist(0));\n                    }\n                    else {\n                        int complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this class was already there,\n                         * the result is that they match all code points,\n                         * (\\d + \\D == everything).  Remove the classes from\n                         * future consideration.  Locale is not relevant in\n                         * this case */\n                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                            ssc_match_all_cp(data->start_class);\n                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                            ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                        }\n                        else {  /* The usual case; just add this class to the\n                                   existing set */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                    }\n                    break;\n\n                case NPOSIXA:   /* For these, we always know the exact set of\n                                   what's matched */\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n                    if (FLAGS(scan) == _CC_ASCII) {\n                        my_invlist = invlist_clone(PL_XPosix_ptrs[_CC_ASCII]);\n                    }\n                    else {\n                        _invlist_intersection(PL_XPosix_ptrs[FLAGS(scan)],\n                                              PL_XPosix_ptrs[_CC_ASCII],\n                                              &my_invlist);\n                    }\n                    goto join_posix;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)]);\n\n                    /* NPOSIXD matches all upper Latin1 code points unless the\n                     * target string being matched is UTF-8, which is\n                     * unknowable until match time.  Since we are going to\n                     * invert, we want to get rid of all of them so that the\n                     * inversion will match all */\n                    if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                          &my_invlist);\n                    }\n\n                  join_posix:\n\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n                    }\n                    else {\n                        assert(flags & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class, my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t}\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) == UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n                   In this case we can't do fixed string optimisation.\n                */\n\n                SSize_t deltanext, minnext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                if (data) {\n                    data_fake.whilem_c = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\t\t}\n                else\n                    data_fake.last_closep = &fake;\n\t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk() for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                      last, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n                if (scan->flags) {\n                    if (deltanext) {\n\t\t\tFAIL(\"Variable length lookbehind not implemented\");\n                    }\n                    else if (minnext > (I32)U8_MAX) {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n                    scan->flags = (U8)minnext;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after: ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t    }  else {\n                        /* AND before and after: combine and continue.  These\n                         * assertions are zero-length, so can match an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n                                                   |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n            else {\n                /* Positive Lookahead/lookbehind\n                   In this case we can do fixed string optimisation,\n                   but we must be careful about it. Note in the case of\n                   lookbehind the positions will be offset by the minimum\n                   length of the pattern, something we won't know about\n                   until after the recurse.\n                */\n                SSize_t deltanext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n                /* We use SAVEFREEPV so that when the full compile\n                    is finished perl will clean up the allocated\n                    minlens when it's all done. This way we don't\n                    have to worry about freeing them when we know\n                    they wont be used, which would be a pain.\n                 */\n                SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n                SAVEFREEPV(minnextp);\n\n                if (data) {\n                    StructCopy(data, &data_fake, scan_data_t);\n                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |= SCF_DO_SUBSTR;\n                        if (scan->flags)\n                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                        data_fake.last_found=newSVsv(data->last_found);\n                    }\n                }\n                else\n                    data_fake.last_closep = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* positive lookahead study_chunk() recursion */\n                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                        &deltanext, last, &data_fake,\n                                        stopparen, recursed_depth, NULL,\n                                        f,depth+1);\n                if (scan->flags) {\n                    if (deltanext) {\n\t\t\tFAIL(\"Variable length lookbehind not implemented\");\n                    }\n                    else if (*minnextp > (I32)U8_MAX) {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n                    scan->flags = (U8)*minnextp;\n                }\n\n                *minnextp += min;\n\n                if (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n                            RExC_rx->minlen=*minnextp;\n                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                        SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp != minlenp) {\n                                data->substrs[i].min_offset =\n                                            data_fake.substrs[i].min_offset;\n                                data->substrs[i].max_offset =\n                                            data_fake.substrs[i].max_offset;\n                                data->substrs[i].minlenp =\n                                            data_fake.substrs[i].minlenp;\n                                data->substrs[i].lookbehind += scan->flags;\n                            }\n                        }\n                    }\n                }\n\t    }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen == (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par) {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL) {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t        if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n                RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n        else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is similar code to this block above for handling\n               BRANCH nodes on the initial study.  If you change stuff here\n               check there too. */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump) {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n            } else {\n                const regnode *nextbranch= NULL;\n                U32 word;\n\n                for ( word=1 ; word <= trie->wordcount ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0, f = 0, fake;\n                    regnode_ssc this_class;\n\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                    if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n                        data_fake.last_closep = data->last_closep;\n                    }\n                    else\n                        data_fake.last_closep = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n                        data_fake.start_class = &this_class;\n                        f = SCF_DO_STCLASS_AND;\n                    }\n                    if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n                            nextbranch = trie_node + trie->jump[0];\n                        scan= trie_node + trie->jump[word];\n                        /* We go from the jump point to the branch that follows\n                           it. Note this means we need the vestigal unused\n                           branches even though they arent otherwise used. */\n                        /* optimise study_chunk() for TRIE */\n                        minnext = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext, (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth, NULL, f,depth+1);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode*)nextbranch);\n\n                    if (min1 > (SSize_t)(minnext + trie->minlen))\n                        min1 = minnext + trie->minlen;\n                    if (deltanext == SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n                        max1 = SSize_t_MAX;\n                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1 = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin > min + min1)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n                            data->flags |= SF_HAS_EVAL;\n                        data->whilem_c = data_fake.whilem_c;\n                    }\n                    if (flags & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                }\n            }\n            if (flags & SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta += max1 - min1;\n                if (max1 != min1 || is_inf)\n                    data->cur_is_floating = 1; /* float */\n            }\n            min += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n                else\n                    delta = SSize_t_MAX;\n            }\n            if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n                else {\n                    /* Switch to OR mode: cache the old value of\n                     * data->start_class */\n\t\t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp, regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n                    StructCopy(&accum, data->start_class, regnode_ssc);\n                    flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n            scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)] == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth, flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ? SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n                RExC_maxlen = final_minlen + delta;\n        }\n        return final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */\n}\n\nSTATIC U32\nS_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)\n{\n    U32 count = RExC_rxi->data ? RExC_rxi->data->count : 0;\n\n    PERL_ARGS_ASSERT_ADD_DATA;\n\n    Renewc(RExC_rxi->data,\n\t   sizeof(*RExC_rxi->data) + sizeof(void*) * (count + n - 1),\n\t   char, struct reg_data);\n    if(count)\n\tRenew(RExC_rxi->data->what, count + n, U8);\n    else\n\tNewx(RExC_rxi->data->what, n, U8);\n    RExC_rxi->data->count = count + n;\n    Copy(s, RExC_rxi->data->what + count, n, U8);\n    return count;\n}\n\n/*XXX: todo make this not included in a non debugging perl, but appears to be\n * used anyway there, in 'use re' */\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_reginitcolors(pTHX)\n{\n    const char * const s = PerlEnv_getenv(\"PERL_RE_COLORS\");\n    if (s) {\n\tchar *t = savepv(s);\n\tint i = 0;\n\tPL_colors[0] = t;\n\twhile (++i < 6) {\n\t    t = strchr(t, '\\t');\n\t    if (t) {\n\t\t*t = '\\0';\n\t\tPL_colors[i] = ++t;\n\t    }\n\t    else\n\t\tPL_colors[i] = t = (char *)\"\";\n\t}\n    } else {\n\tint i = 0;\n\twhile (i < 6)\n\t    PL_colors[i++] = (char *)\"\";\n    }\n    PL_colorset = 1;\n}\n#endif\n\n\n#ifdef TRIE_STUDY_OPT\n#define CHECK_RESTUDY_GOTO_butfirst(dOsomething)            \\\n    STMT_START {                                            \\\n        if (                                                \\\n              (data.flags & SCF_TRIE_RESTUDY)               \\\n              && ! restudied++                              \\\n        ) {                                                 \\\n            dOsomething;                                    \\\n            goto reStudy;                                   \\\n        }                                                   \\\n    } STMT_END\n#else\n#define CHECK_RESTUDY_GOTO_butfirst\n#endif\n\n/*\n * pregcomp - compile a regular expression into internal code\n *\n * Decides which engine's compiler to call based on the hint currently in\n * scope\n */\n\n#ifndef PERL_IN_XSUB_RE\n\n/* return the currently in-scope regex engine (or the default if none)  */\n\nregexp_engine const *\nPerl_current_re_engine(pTHX)\n{\n    if (IN_PERL_COMPILETIME) {\n\tHV * const table = GvHV(PL_hintgv);\n\tSV **ptr;\n\n\tif (!table || !(PL_hints & HINT_LOCALIZE_HH))\n\t    return &PL_core_reg_engine;\n\tptr = hv_fetchs(table, \"regcomp\", FALSE);\n\tif ( !(ptr && SvIOK(*ptr) && SvIV(*ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*,SvIV(*ptr));\n    }\n    else {\n\tSV *ptr;\n\tif (!PL_curcop->cop_hints_hash)\n\t    return &PL_core_reg_engine;\n\tptr = cop_hints_fetch_pvs(PL_curcop, \"regcomp\", 0);\n\tif ( !(ptr && SvIOK(ptr) && SvIV(ptr)))\n\t    return &PL_core_reg_engine;\n\treturn INT2PTR(regexp_engine*,SvIV(ptr));\n    }\n}\n\n\nREGEXP *\nPerl_pregcomp(pTHX_ SV * const pattern, const U32 flags)\n{\n    regexp_engine const *eng = current_re_engine();\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGCOMP;\n\n    /* Dispatch a request to compile a regexp to correct regexp engine. */\n    DEBUG_COMPILE_r({\n        Perl_re_printf( aTHX_  \"Using engine %\" UVxf \"\\n\",\n\t\t\tPTR2UV(eng));\n    });\n    return CALLREGCOMP_ENG(eng, pattern, flags);\n}\n#endif\n\n/* public(ish) entry point for the perl core's own regex compiling code.\n * It's actually a wrapper for Perl_re_op_compile that only takes an SV\n * pattern rather than a list of OPs, and uses the internal engine rather\n * than the current one */\n\nREGEXP *\nPerl_re_compile(pTHX_ SV * const pattern, U32 rx_flags)\n{\n    SV *pat = pattern; /* defeat constness! */\n    PERL_ARGS_ASSERT_RE_COMPILE;\n    return Perl_re_op_compile(aTHX_ &pat, 1, NULL,\n#ifdef PERL_IN_XSUB_RE\n                                &my_reg_engine,\n#else\n                                &PL_core_reg_engine,\n#endif\n                                NULL, NULL, rx_flags, 0);\n}\n\n\nstatic void\nS_free_codeblocks(pTHX_ struct reg_code_blocks *cbs)\n{\n    int n;\n\n    if (--cbs->refcnt > 0)\n        return;\n    for (n = 0; n < cbs->count; n++) {\n        REGEXP *rx = cbs->cb[n].src_regex;\n        cbs->cb[n].src_regex = NULL;\n        SvREFCNT_dec(rx);\n    }\n    Safefree(cbs->cb);\n    Safefree(cbs);\n}\n\n\nstatic struct reg_code_blocks *\nS_alloc_code_blocks(pTHX_  int ncode)\n{\n     struct reg_code_blocks *cbs;\n    Newx(cbs, 1, struct reg_code_blocks);\n    cbs->count = ncode;\n    cbs->refcnt = 1;\n    SAVEDESTRUCTOR_X(S_free_codeblocks, cbs);\n    if (ncode)\n        Newx(cbs->cb, ncode, struct reg_code_block);\n    else\n        cbs->cb = NULL;\n    return cbs;\n}\n\n\n/* upgrade pattern pat_p of length plen_p to UTF8, and if there are code\n * blocks, recalculate the indices. Update pat_p and plen_p in-place to\n * point to the realloced string and length.\n *\n * This is essentially a copy of Perl_bytes_to_utf8() with the code index\n * stuff added */\n\nstatic void\nS_pat_upgrade_to_utf8(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char **pat_p, STRLEN *plen_p, int num_code_blocks)\n{\n    U8 *const src = (U8*)*pat_p;\n    U8 *dst, *d;\n    int n=0;\n    STRLEN s = 0;\n    bool do_end = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"UTF8 mismatch! Converting to utf8 for resizing and compile\\n\"));\n\n    Newx(dst, *plen_p * 2 + 1, U8);\n    d = dst;\n\n    while (s < *plen_p) {\n        append_utf8_from_native_byte(src[s], &d);\n\n        if (n < num_code_blocks) {\n            assert(pRExC_state->code_blocks);\n            if (!do_end && pRExC_state->code_blocks->cb[n].start == s) {\n                pRExC_state->code_blocks->cb[n].start = d - dst - 1;\n                assert(*(d - 1) == '(');\n                do_end = 1;\n            }\n            else if (do_end && pRExC_state->code_blocks->cb[n].end == s) {\n                pRExC_state->code_blocks->cb[n].end = d - dst - 1;\n                assert(*(d - 1) == ')');\n                do_end = 0;\n                n++;\n            }\n        }\n        s++;\n    }\n    *d = '\\0';\n    *plen_p = d - dst;\n    *pat_p = (char*) dst;\n    SAVEFREEPV(*pat_p);\n    RExC_orig_utf8 = RExC_utf8 = 1;\n}\n\n\n\n/* S_concat_pat(): concatenate a list of args to the pattern string pat,\n * while recording any code block indices, and handling overloading,\n * nested qr// objects etc.  If pat is null, it will allocate a new\n * string, or just return the first arg, if there's only one.\n *\n * Returns the malloced/updated pat.\n * patternp and pat_count is the array of SVs to be concatted;\n * oplist is the optional list of ops that generated the SVs;\n * recompile_p is a pointer to a boolean that will be set if\n *   the regex will need to be recompiled.\n * delim, if non-null is an SV that will be inserted between each element\n */\n\nstatic SV*\nS_concat_pat(pTHX_ RExC_state_t * const pRExC_state,\n                SV *pat, SV ** const patternp, int pat_count,\n                OP *oplist, bool *recompile_p, SV *delim)\n{\n    SV **svp;\n    int n = 0;\n    bool use_delim = FALSE;\n    bool alloced = FALSE;\n\n    /* if we know we have at least two args, create an empty string,\n     * then concatenate args to that. For no args, return an empty string */\n    if (!pat && pat_count != 1) {\n        pat = newSVpvs(\"\");\n        SAVEFREESV(pat);\n        alloced = TRUE;\n    }\n\n    for (svp = patternp; svp < patternp + pat_count; svp++) {\n        SV *sv;\n        SV *rx  = NULL;\n        STRLEN orig_patlen = 0;\n        bool code = 0;\n        SV *msv = use_delim ? delim : *svp;\n        if (!msv) msv = &PL_sv_undef;\n\n        /* if we've got a delimiter, we go round the loop twice for each\n         * svp slot (except the last), using the delimiter the second\n         * time round */\n        if (use_delim) {\n            svp--;\n            use_delim = FALSE;\n        }\n        else if (delim)\n            use_delim = TRUE;\n\n        if (SvTYPE(msv) == SVt_PVAV) {\n            /* we've encountered an interpolated array within\n             * the pattern, e.g. /...@a..../. Expand the list of elements,\n             * then recursively append elements.\n             * The code in this block is based on S_pushav() */\n\n            AV *const av = (AV*)msv;\n            const SSize_t maxarg = AvFILL(av) + 1;\n            SV **array;\n\n            if (oplist) {\n                assert(oplist->op_type == OP_PADAV\n                    || oplist->op_type == OP_RV2AV);\n                oplist = OpSIBLING(oplist);\n            }\n\n            if (SvRMAGICAL(av)) {\n                SSize_t i;\n\n                Newx(array, maxarg, SV*);\n                SAVEFREEPV(array);\n                for (i=0; i < maxarg; i++) {\n                    SV ** const svp = av_fetch(av, i, FALSE);\n                    array[i] = svp ? *svp : &PL_sv_undef;\n                }\n            }\n            else\n                array = AvARRAY(av);\n\n            pat = S_concat_pat(aTHX_ pRExC_state, pat,\n                                array, maxarg, NULL, recompile_p,\n                                /* $\" */\n                                GvSV((gv_fetchpvs(\"\\\"\", GV_ADDMULTI, SVt_PV))));\n\n            continue;\n        }\n\n\n        /* we make the assumption here that each op in the list of\n         * op_siblings maps to one SV pushed onto the stack,\n         * except for code blocks, with have both an OP_NULL and\n         * and OP_CONST.\n         * This allows us to match up the list of SVs against the\n         * list of OPs to find the next code block.\n         *\n         * Note that       PUSHMARK PADSV PADSV ..\n         * is optimised to\n         *                 PADRANGE PADSV  PADSV  ..\n         * so the alignment still works. */\n\n        if (oplist) {\n            if (oplist->op_type == OP_NULL\n                && (oplist->op_flags & OPf_SPECIAL))\n            {\n                assert(n < pRExC_state->code_blocks->count);\n                pRExC_state->code_blocks->cb[n].start = pat ? SvCUR(pat) : 0;\n                pRExC_state->code_blocks->cb[n].block = oplist;\n                pRExC_state->code_blocks->cb[n].src_regex = NULL;\n                n++;\n                code = 1;\n                oplist = OpSIBLING(oplist); /* skip CONST */\n                assert(oplist);\n            }\n            oplist = OpSIBLING(oplist);;\n        }\n\n\t/* apply magic and QR overloading to arg */\n\n        SvGETMAGIC(msv);\n        if (SvROK(msv) && SvAMAGIC(msv)) {\n            SV *sv = AMG_CALLunary(msv, regexp_amg);\n            if (sv) {\n                if (SvROK(sv))\n                    sv = SvRV(sv);\n                if (SvTYPE(sv) != SVt_REGEXP)\n                    Perl_croak(aTHX_ \"Overloaded qr did not return a REGEXP\");\n                msv = sv;\n            }\n        }\n\n        /* try concatenation overload ... */\n        if (pat && (SvAMAGIC(pat) || SvAMAGIC(msv)) &&\n                (sv = amagic_call(pat, msv, concat_amg, AMGf_assign)))\n        {\n            sv_setsv(pat, sv);\n            /* overloading involved: all bets are off over literal\n             * code. Pretend we haven't seen it */\n            if (n)\n                pRExC_state->code_blocks->count -= n;\n            n = 0;\n        }\n        else  {\n            /* ... or failing that, try \"\" overload */\n            while (SvAMAGIC(msv)\n                    && (sv = AMG_CALLunary(msv, string_amg))\n                    && sv != msv\n                    &&  !(   SvROK(msv)\n                          && SvROK(sv)\n                          && SvRV(msv) == SvRV(sv))\n            ) {\n                msv = sv;\n                SvGETMAGIC(msv);\n            }\n            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)\n                msv = SvRV(msv);\n\n            if (pat) {\n                /* this is a partially unrolled\n                 *     sv_catsv_nomg(pat, msv);\n                 * that allows us to adjust code block indices if\n                 * needed */\n                STRLEN dlen;\n                char *dst = SvPV_force_nomg(pat, dlen);\n                orig_patlen = dlen;\n                if (SvUTF8(msv) && !SvUTF8(pat)) {\n                    S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &dst, &dlen, n);\n                    sv_setpvn(pat, dst, dlen);\n                    SvUTF8_on(pat);\n                }\n                sv_catsv_nomg(pat, msv);\n                rx = msv;\n            }\n            else {\n                /* We have only one SV to process, but we need to verify\n                 * it is properly null terminated or we will fail asserts\n                 * later. In theory we probably shouldn't get such SV's,\n                 * but if we do we should handle it gracefully. */\n                if ( SvTYPE(msv) != SVt_PV || (SvLEN(msv) > SvCUR(msv) && *(SvEND(msv)) == 0) ) {\n                    /* not a string, or a string with a trailing null */\n                    pat = msv;\n                } else {\n                    /* a string with no trailing null, we need to copy it\n                     * so it we have a trailing null */\n                    pat = newSVsv(msv);\n                }\n            }\n\n            if (code)\n                pRExC_state->code_blocks->cb[n-1].end = SvCUR(pat)-1;\n        }\n\n        /* extract any code blocks within any embedded qr//'s */\n        if (rx && SvTYPE(rx) == SVt_REGEXP\n            && RX_ENGINE((REGEXP*)rx)->op_comp)\n        {\n\n            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);\n            if (ri->code_blocks && ri->code_blocks->count) {\n                int i;\n                /* the presence of an embedded qr// with code means\n                 * we should always recompile: the text of the\n                 * qr// may not have changed, but it may be a\n                 * different closure than last time */\n                *recompile_p = 1;\n                if (pRExC_state->code_blocks) {\n                    int new_count = pRExC_state->code_blocks->count\n                            + ri->code_blocks->count;\n                    Renew(pRExC_state->code_blocks->cb,\n                            new_count, struct reg_code_block);\n                    pRExC_state->code_blocks->count = new_count;\n                }\n                else\n                    pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_\n                                                    ri->code_blocks->count);\n\n                for (i=0; i < ri->code_blocks->count; i++) {\n                    struct reg_code_block *src, *dst;\n                    STRLEN offset =  orig_patlen\n                        + ReANY((REGEXP *)rx)->pre_prefix;\n                    assert(n < pRExC_state->code_blocks->count);\n                    src = &ri->code_blocks->cb[i];\n                    dst = &pRExC_state->code_blocks->cb[n];\n                    dst->start\t    = src->start + offset;\n                    dst->end\t    = src->end   + offset;\n                    dst->block\t    = src->block;\n                    dst->src_regex  = (REGEXP*) SvREFCNT_inc( (SV*)\n                                            src->src_regex\n                                                ? src->src_regex\n                                                : (REGEXP*)rx);\n                    n++;\n                }\n            }\n        }\n    }\n    /* avoid calling magic multiple times on a single element e.g. =~ $qr */\n    if (alloced)\n        SvSETMAGIC(pat);\n\n    return pat;\n}\n\n\n\n/* see if there are any run-time code blocks in the pattern.\n * False positives are allowed */\n\nstatic bool\nS_has_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char *pat, STRLEN plen)\n{\n    int n = 0;\n    STRLEN s;\n    \n    PERL_UNUSED_CONTEXT;\n\n    for (s = 0; s < plen; s++) {\n\tif (   pRExC_state->code_blocks\n            && n < pRExC_state->code_blocks->count\n\t    && s == pRExC_state->code_blocks->cb[n].start)\n\t{\n\t    s = pRExC_state->code_blocks->cb[n].end;\n\t    n++;\n\t    continue;\n\t}\n\t/* TODO ideally should handle [..], (#..), /#.../x to reduce false\n\t * positives here */\n\tif (pat[s] == '(' && s+2 <= plen && pat[s+1] == '?' &&\n\t    (pat[s+2] == '{'\n                || (s + 2 <= plen && pat[s+2] == '?' && pat[s+3] == '{'))\n\t)\n\t    return 1;\n    }\n    return 0;\n}\n\n/* Handle run-time code blocks. We will already have compiled any direct\n * or indirect literal code blocks. Now, take the pattern 'pat' and make a\n * copy of it, but with any literal code blocks blanked out and\n * appropriate chars escaped; then feed it into\n *\n *    eval \"qr'modified_pattern'\"\n *\n * For example,\n *\n *       a\\bc(?{\"this was literal\"})def'ghi\\\\jkl(?{\"this is runtime\"})mno\n *\n * becomes\n *\n *    qr'a\\\\bc_______________________def\\'ghi\\\\\\\\jkl(?{\"this is runtime\"})mno'\n *\n * After eval_sv()-ing that, grab any new code blocks from the returned qr\n * and merge them with any code blocks of the original regexp.\n *\n * If the pat is non-UTF8, while the evalled qr is UTF8, don't merge;\n * instead, just save the qr and return FALSE; this tells our caller that\n * the original pattern needs upgrading to utf8.\n */\n\nstatic bool\nS_compile_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n    char *pat, STRLEN plen)\n{\n    SV *qr;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    if (pRExC_state->runtime_code_qr) {\n\t/* this is the second time we've been called; this should\n\t * only happen if the main pattern got upgraded to utf8\n\t * during compilation; re-use the qr we compiled first time\n\t * round (which should be utf8 too)\n\t */\n\tqr = pRExC_state->runtime_code_qr;\n\tpRExC_state->runtime_code_qr = NULL;\n\tassert(RExC_utf8 && SvUTF8(qr));\n    }\n    else {\n\tint n = 0;\n\tSTRLEN s;\n\tchar *p, *newpat;\n\tint newlen = plen + 7; /* allow for \"qr''xx\\0\" extra chars */\n\tSV *sv, *qr_ref;\n\tdSP;\n\n\t/* determine how many extra chars we need for ' and \\ escaping */\n\tfor (s = 0; s < plen; s++) {\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\tnewlen++;\n\t}\n\n\tNewx(newpat, newlen, char);\n\tp = newpat;\n\t*p++ = 'q'; *p++ = 'r'; *p++ = '\\'';\n\n\tfor (s = 0; s < plen; s++) {\n\t    if (   pRExC_state->code_blocks\n\t        && n < pRExC_state->code_blocks->count\n\t\t&& s == pRExC_state->code_blocks->cb[n].start)\n\t    {\n\t\t/* blank out literal code block */\n\t\tassert(pat[s] == '(');\n\t\twhile (s <= pRExC_state->code_blocks->cb[n].end) {\n\t\t    *p++ = '_';\n\t\t    s++;\n\t\t}\n\t\ts--;\n\t\tn++;\n\t\tcontinue;\n\t    }\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\t*p++ = '\\\\';\n\t    *p++ = pat[s];\n\t}\n\t*p++ = '\\'';\n\tif (pRExC_state->pm_flags & RXf_PMf_EXTENDED) {\n\t    *p++ = 'x';\n            if (pRExC_state->pm_flags & RXf_PMf_EXTENDED_MORE) {\n                *p++ = 'x';\n            }\n        }\n\t*p++ = '\\0';\n\tDEBUG_COMPILE_r({\n            Perl_re_printf( aTHX_\n\t\t\"%sre-parsing pattern for runtime code:%s %s\\n\",\n\t\tPL_colors[4],PL_colors[5],newpat);\n\t});\n\n\tsv = newSVpvn_flags(newpat, p-newpat-1, RExC_utf8 ? SVf_UTF8 : 0);\n\tSafefree(newpat);\n\n\tENTER;\n\tSAVETMPS;\n\tsave_re_context();\n\tPUSHSTACKi(PERLSI_REQUIRE);\n        /* G_RE_REPARSING causes the toker to collapse \\\\ into \\ when\n         * parsing qr''; normally only q'' does this. It also alters\n         * hints handling */\n\teval_sv(sv, G_SCALAR|G_RE_REPARSING);\n\tSvREFCNT_dec_NN(sv);\n\tSPAGAIN;\n\tqr_ref = POPs;\n\tPUTBACK;\n\t{\n\t    SV * const errsv = ERRSV;\n\t    if (SvTRUE_NN(errsv))\n                /* use croak_sv ? */\n\t\tPerl_croak_nocontext(\"%\" SVf, SVfARG(errsv));\n\t}\n\tassert(SvROK(qr_ref));\n\tqr = SvRV(qr_ref);\n\tassert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);\n\t/* the leaving below frees the tmp qr_ref.\n\t * Give qr a life of its own */\n\tSvREFCNT_inc(qr);\n\tPOPSTACK;\n\tFREETMPS;\n\tLEAVE;\n\n    }\n\n    if (!RExC_utf8 && SvUTF8(qr)) {\n\t/* first time through; the pattern got upgraded; save the\n\t * qr for the next time through */\n\tassert(!pRExC_state->runtime_code_qr);\n\tpRExC_state->runtime_code_qr = qr;\n\treturn 0;\n    }\n\n\n    /* extract any code blocks within the returned qr//  */\n\n\n    /* merge the main (r1) and run-time (r2) code blocks into one */\n    {\n\tRXi_GET_DECL(ReANY((REGEXP *)qr), r2);\n\tstruct reg_code_block *new_block, *dst;\n\tRExC_state_t * const r1 = pRExC_state; /* convenient alias */\n\tint i1 = 0, i2 = 0;\n        int r1c, r2c;\n\n\tif (!r2->code_blocks || !r2->code_blocks->count) /* we guessed wrong */\n\t{\n\t    SvREFCNT_dec_NN(qr);\n\t    return 1;\n\t}\n\n        if (!r1->code_blocks)\n            r1->code_blocks = S_alloc_code_blocks(aTHX_ 0);\n\n        r1c = r1->code_blocks->count;\n        r2c = r2->code_blocks->count;\n\n\tNewx(new_block, r1c + r2c, struct reg_code_block);\n\n\tdst = new_block;\n\n\twhile (i1 < r1c || i2 < r2c) {\n\t    struct reg_code_block *src;\n\t    bool is_qr = 0;\n\n\t    if (i1 == r1c) {\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t    }\n\t    else if (i2 == r2c)\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t    else if (  r1->code_blocks->cb[i1].start\n\t             < r2->code_blocks->cb[i2].start)\n\t    {\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t\tassert(src->end < r2->code_blocks->cb[i2].start);\n\t    }\n\t    else {\n\t\tassert(  r1->code_blocks->cb[i1].start\n\t\t       > r2->code_blocks->cb[i2].start);\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t\tassert(src->end < r1->code_blocks->cb[i1].start);\n\t    }\n\n\t    assert(pat[src->start] == '(');\n\t    assert(pat[src->end]   == ')');\n\t    dst->start\t    = src->start;\n\t    dst->end\t    = src->end;\n\t    dst->block\t    = src->block;\n\t    dst->src_regex  = is_qr ? (REGEXP*) SvREFCNT_inc( (SV*) qr)\n\t\t\t\t    : src->src_regex;\n\t    dst++;\n\t}\n\tr1->code_blocks->count += r2c;\n\tSafefree(r1->code_blocks->cb);\n\tr1->code_blocks->cb = new_block;\n    }\n\n    SvREFCNT_dec_NN(qr);\n    return 1;\n}\n\n\nSTATIC bool\nS_setup_longest(pTHX_ RExC_state_t *pRExC_state,\n                      struct reg_substr_datum  *rsd,\n                      struct scan_data_substrs *sub,\n                      STRLEN longest_length)\n{\n    /* This is the common code for setting up the floating and fixed length\n     * string data extracted from Perl_re_op_compile() below.  Returns a boolean\n     * as to whether succeeded or not */\n\n    I32 t;\n    SSize_t ml;\n    bool eol  = cBOOL(sub->flags & SF_BEFORE_EOL);\n    bool meol = cBOOL(sub->flags & SF_BEFORE_MEOL);\n\n    if (! (longest_length\n           || (eol /* Can't have SEOL and MULTI */\n               && (! meol || (RExC_flags & RXf_PMf_MULTILINE)))\n          )\n            /* See comments for join_exact for why REG_UNFOLDED_MULTI_SEEN */\n        || (RExC_seen & REG_UNFOLDED_MULTI_SEEN))\n    {\n        return FALSE;\n    }\n\n    /* copy the information about the longest from the reg_scan_data\n        over to the program. */\n    if (SvUTF8(sub->str)) {\n        rsd->substr      = NULL;\n        rsd->utf8_substr = sub->str;\n    } else {\n        rsd->substr      = sub->str;\n        rsd->utf8_substr = NULL;\n    }\n    /* end_shift is how many chars that must be matched that\n        follow this item. We calculate it ahead of time as once the\n        lookbehind offset is added in we lose the ability to correctly\n        calculate it.*/\n    ml = sub->minlenp ? *(sub->minlenp) : (SSize_t)longest_length;\n    rsd->end_shift = ml - sub->min_offset\n        - longest_length\n            /* XXX SvTAIL is always false here - did you mean FBMcf_TAIL\n             * intead? - DAPM\n            + (SvTAIL(sub->str) != 0)\n            */\n        + sub->lookbehind;\n\n    t = (eol/* Can't have SEOL and MULTI */\n         && (! meol || (RExC_flags & RXf_PMf_MULTILINE)));\n    fbm_compile(sub->str, t ? FBMcf_TAIL : 0);\n\n    return TRUE;\n}\n\n/*\n * Perl_re_op_compile - the perl internal RE engine's function to compile a\n * regular expression into internal code.\n * The pattern may be passed either as:\n *    a list of SVs (patternp plus pat_count)\n *    a list of OPs (expr)\n * If both are passed, the SV list is used, but the OP list indicates\n * which SVs are actually pre-compiled code blocks\n *\n * The SVs in the list have magic and qr overloading applied to them (and\n * the list may be modified in-place with replacement SVs in the latter\n * case).\n *\n * If the pattern hasn't changed from old_re, then old_re will be\n * returned.\n *\n * eng is the current engine. If that engine has an op_comp method, then\n * handle directly (i.e. we assume that op_comp was us); otherwise, just\n * do the initial concatenation of arguments and pass on to the external\n * engine.\n *\n * If is_bare_re is not null, set it to a boolean indicating whether the\n * arg list reduced (after overloading) to a single bare regex which has\n * been returned (i.e. /$qr/).\n *\n * orig_rx_flags contains RXf_* flags. See perlreapi.pod for more details.\n *\n * pm_flags contains the PMf_* flags, typically based on those from the\n * pm_flags field of the related PMOP. Currently we're only interested in\n * PMf_HAS_CV, PMf_IS_QR, PMf_USE_RE_EVAL.\n *\n * We can't allocate space until we know how big the compiled form will be,\n * but we can't compile it (and thus know how big it is) until we've got a\n * place to put the code.  So we cheat:  we compile it twice, once with code\n * generation turned off and size counting turned on, and once \"for real\".\n * This also means that we don't allocate space until we are sure that the\n * thing really will compile successfully, and we never have to move the\n * code and thus invalidate pointers into it.  (Note that it has to be in\n * one piece because free() must be able to free it all.) [NB: not true in perl]\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.  [I'll say.]\n */\n\nREGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags)\n{\n    REGEXP *rx;\n    struct regexp *r;\n    regexp_internal *ri;\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_AboveLatin1) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n\tPL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);\n\tPL_Latin1 = _new_invlist_C_array(Latin1_invlist);\n\tPL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);\n        PL_utf8_foldable = _new_invlist_C_array(_Perl_Any_Folds_invlist);\n        PL_HasMultiCharFold =\n                       _new_invlist_C_array(_Perl_Folds_To_Multi_Char_invlist);\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n\n    RExC_uni_semantics = 0;\n    RExC_seen_unfolded_sharp_s = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4],PL_colors[5],s);\n        });\n\n  redo_first_pass:\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    rx_flags = orig_rx_flags;\n\n    if (   initial_charset == REGEX_DEPENDS_CHARSET\n        && (RExC_utf8 ||RExC_uni_semantics))\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    RExC_precomp = exp;\n    RExC_precomp_adj = 0;\n    RExC_flags = rx_flags;\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_first_pass;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n    RExC_extralen = 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    /* First pass: determine size, legality. */\n    RExC_parse = exp;\n    RExC_start = RExC_adjusted_start = exp;\n    RExC_end = exp + plen;\n    RExC_precomp_end = RExC_end;\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_nestroot = 0;\n    RExC_size = 0L;\n    RExC_emit = (regnode *) &RExC_emit_dummy;\n    RExC_whilem_seen = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_end_op = NULL;\n    RExC_paren_names = NULL;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    DEBUG_PARSE_r(\n        Perl_re_printf( aTHX_  \"Starting first pass (sizing)\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    );\n\n    if (reg(pRExC_state, 0, &flags,1) == NULL) {\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & RESTART_PASS1) {\n            if (flags & NEED_UTF8) {\n                S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            }\n            else {\n                DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Need to redo pass 1\\n\"));\n            }\n\n            goto redo_first_pass;\n        }\n        Perl_croak(aTHX_ \"panic: reg returned NULL to re_op_compile for sizing pass, flags=%#\" UVxf, (UV) flags);\n    }\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\"\n            \"Starting second pass (creation)\\n\",\n            (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* The first pass could have found things that force Unicode semantics */\n    if ((RExC_utf8 || RExC_uni_semantics)\n\t && get_regex_charset(rx_flags) == REGEX_DEPENDS_CHARSET)\n    {\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    /* Small enough for pointer-storage convention?\n       If extralen==0, this means that we will not need long jumps. */\n    if (RExC_size >= 0x10000L && RExC_extralen)\n        RExC_size += RExC_extralen;\n    else\n\tRExC_extralen = 0;\n    if (RExC_whilem_seen > 15)\n\tRExC_whilem_seen = 15;\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    r = ReANY(rx);\n    Newxc(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),\n\t char, regexp_internal);\n    if ( r == NULL || ri == NULL )\n\tFAIL(\"Regexp out of space\");\n#ifdef DEBUGGING\n    /* avoid reading uninitialized memory in DEBUGGING code in study_chunk() */\n    Zero(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),\n         char);\n#else\n    /* bulk initialize base fields with 0. */\n    Zero(ri, sizeof(regexp_internal), char);\n#endif\n\n    /* non-zero initialization begins here */\n    RXi_SET( r, ri );\n    r->engine= eng;\n    r->extflags = rx_flags;\n    RXp_COMPFLAGS(r) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tri->code_blocks = pRExC_state->code_blocks;\n\tif (ri->code_blocks)\n            ri->code_blocks->refcnt++;\n    }\n\n    {\n        bool has_p     = ((r->extflags & RXf_PMf_KEEPCOPY) == RXf_PMf_KEEPCOPY);\n        bool has_charset = (get_regex_charset(r->extflags)\n                                                    != REGEX_DEPENDS_CHARSET);\n\n        /* The caret is output if there are any defaults: if not all the STD\n         * flags are set, or if no character set specifier is needed */\n        bool has_default =\n                    (((r->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD)\n                    || ! has_charset);\n        bool has_runon = ((RExC_seen & REG_RUN_ON_COMMENT_SEEN)\n                                                   == REG_RUN_ON_COMMENT_SEEN);\n\tU8 reganch = (U8)((r->extflags & RXf_PMf_STD_PMMOD)\n\t\t\t    >> RXf_PMf_STD_PMMOD_SHIFT);\n\tconst char *fptr = STD_PAT_MODS;        /*\"msixxn\"*/\n\tchar *p;\n\n        /* We output all the necessary flags; we never output a minus, as all\n         * those are defaults, so are\n         * covered by the caret */\n\tconst STRLEN wraplen = plen + has_p + has_runon\n            + has_default       /* If needs a caret */\n            + PL_bitcount[reganch] /* 1 char for each set standard flag */\n\n\t\t/* If needs a character set specifier */\n\t    + ((has_charset) ? MAX_CHARSET_NAME_LENGTH : 0)\n            + (sizeof(\"(?:)\") - 1);\n\n        /* make sure PL_bitcount bounds not exceeded */\n        assert(sizeof(STD_PAT_MODS) <= 8);\n\n        p = sv_grow(MUTABLE_SV(rx), wraplen + 1); /* +1 for the ending NUL */\n        SvPOK_on(rx);\n\tif (RExC_utf8)\n\t    SvFLAGS(rx) |= SVf_UTF8;\n        *p++='('; *p++='?';\n\n        /* If a default, cover it using the caret */\n        if (has_default) {\n            *p++= DEFAULT_PAT_MOD;\n        }\n        if (has_charset) {\n\t    STRLEN len;\n\t    const char* const name = get_regex_charset_name(r->extflags, &len);\n\t    Copy(name, p, len, char);\n\t    p += len;\n        }\n        if (has_p)\n            *p++ = KEEPCOPY_PAT_MOD; /*'p'*/\n        {\n            char ch;\n            while((ch = *fptr++)) {\n                if(reganch & 1)\n                    *p++ = ch;\n                reganch >>= 1;\n            }\n        }\n\n        *p++ = ':';\n        Copy(RExC_precomp, p, plen, char);\n\tassert ((RX_WRAPPED(rx) - p) < 16);\n\tr->pre_prefix = p - RX_WRAPPED(rx);\n        p += plen;\n        if (has_runon)\n            *p++ = '\\n';\n        *p++ = ')';\n        *p = 0;\n\tSvCUR_set(rx, p - RX_WRAPPED(rx));\n    }\n\n    r->intflags = 0;\n    r->nparens = RExC_npar - 1;\t/* set early to validate backrefs */\n\n    /* Useful during FAIL. */\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    Newxz(ri->u.offsets, 2*RExC_size+1, U32); /* MJD 20001228 */\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          ri->u.offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((2*RExC_size+1) * sizeof(U32))));\n#endif\n    SetProgLen(ri,RExC_size);\n    RExC_rx_sv = rx;\n    RExC_rx = r;\n    RExC_rxi = ri;\n\n    /* Second pass: emit code. */\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_pm_flags = pm_flags;\n    RExC_parse = exp;\n    RExC_end = exp + plen;\n    RExC_naughty = 0;\n    RExC_emit_start = ri->program;\n    RExC_emit = ri->program;\n    RExC_emit_bound = ri->program + RExC_size + 1;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit++) = (char) REG_MAGIC;\n    /* setup various meta data about recursion, this all requires\n     * RExC_npar to be correctly set, and a bit later on we clear it */\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n            \"%*s%*s Setting up open/close parens\\n\",\n                  22, \"|    |\", (int)(0 * 2 + 1), \"\"));\n\n        /* setup RExC_open_parens, which holds the address of each\n         * OPEN tag, and to make things simpler for the 0 index\n         * the start of the program - this is used later for offsets */\n        Newxz(RExC_open_parens, RExC_npar,regnode *);\n        SAVEFREEPV(RExC_open_parens);\n        RExC_open_parens[0] = RExC_emit;\n\n        /* setup RExC_close_parens, which holds the address of each\n         * CLOSE tag, and to make things simpler for the 0 index\n         * the end of the program - this is used later for offsets */\n        Newxz(RExC_close_parens, RExC_npar,regnode *);\n        SAVEFREEPV(RExC_close_parens);\n        /* we dont know where end op starts yet, so we dont\n         * need to set RExC_close_parens[0] like we do RExC_open_parens[0] above */\n\n        /* Note, RExC_npar is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_npar >> 3) +\n                                         ((RExC_npar & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_npar, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n    RExC_npar = 1;\n    if (reg(pRExC_state, 0, &flags,1) == NULL) {\n\tReREFCNT_dec(rx);\n        Perl_croak(aTHX_ \"panic: reg returned NULL to re_op_compile for generation pass, flags=%#\" UVxf, (UV) flags);\n    }\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(r->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse,RExC_recurse_count,regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n  reStudy:\n    r->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(r->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_npar, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    r->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(rx);\t/* Unicode in it? */\n    ri->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tr->intflags |= PREGf_NAUGHTY;\n    scan = ri->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (OP(first) == EXACT || OP(first) == EXACTL)\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n\t    else\n\t\tri->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)ri->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            ri->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    ri->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    ri->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            r->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            r->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(r->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            r->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    r->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!ri->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_npar == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    r->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen,0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(r->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                r->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                r->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    r->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                r->substrs->data[i].substr      = NULL;\n                r->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (ri->regstclass\n\t    && (OP(ri->regstclass) == REG_ANY || OP(ri->regstclass) == SANY))\n\t    ri->regstclass = NULL;\n\n\tif ((!(r->substrs->data[0].substr || r->substrs->data[0].utf8_substr)\n              || r->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    ri->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    r->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        r->substrs->check_ix = i;\n        r->check_end_shift  = r->substrs->data[i].end_shift;\n        r->check_substr     = r->substrs->data[i].substr;\n        r->check_utf8       = r->substrs->data[i].utf8_substr;\n        r->check_offset_min = r->substrs->data[i].min_offset;\n        r->check_offset_max = r->substrs->data[i].max_offset;\n        if (!i && (r->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            r->intflags |= PREGf_NOSCAN;\n\n\tif ((r->check_substr || r->check_utf8) ) {\n\t    r->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(r->check_substr ? r->check_substr : r->check_utf8))\n\t\tr->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = ri->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tr->check_substr = NULL;\n        r->check_utf8 = NULL;\n        r->substrs->data[0].substr      = NULL;\n        r->substrs->data[0].utf8_substr = NULL;\n        r->substrs->data[1].substr      = NULL;\n        r->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    ri->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    r->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        r->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        r->maxlen = REG_INFTY;\n    }\n    else {\n        r->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" r->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)r->minlen, (IV)RExC_maxlen);\n    });\n    r->minlenret = minlen;\n    if (r->minlen < minlen)\n        r->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        r->intflags |= PREGf_RECURSE_SEEN;\n        Newx(r->recurse_locinput, r->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        r->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        r->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tr->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tr->intflags |= PREGf_VERBARG_SEEN;\n        r->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tr->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tr->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(r) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(r) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (r->intflags & PREGf_ANCH)\n        r->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = ri->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            r->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            r->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            r->extflags |= RXf_WHITE;\n        else if ( r->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            r->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(r) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        ri->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        ri->data->data[ri->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    ri->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - scan );\n    }\n\n    Newxz(r->offs, RExC_npar, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(r);\n    });\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(if (ri->u.offsets) {\n        const STRLEN len = ri->u.offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)ri->u.offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (ri->u.offsets[i*2-1] || ri->u.offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)ri->u.offsets[i*2-1], (UV)ri->u.offsets[i*2]);\n            }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n#endif\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(rx);\n#endif\n    return rx;\n}\n\n\nSV*\nPerl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value,\n                    const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF;\n\n    PERL_UNUSED_ARG(value);\n\n    if (flags & RXapif_FETCH) {\n        return reg_named_buff_fetch(rx, key, flags);\n    } else if (flags & (RXapif_STORE | RXapif_DELETE | RXapif_CLEAR)) {\n        Perl_croak_no_modify();\n        return NULL;\n    } else if (flags & RXapif_EXISTS) {\n        return reg_named_buff_exists(rx, key, flags)\n            ? &PL_sv_yes\n            : &PL_sv_no;\n    } else if (flags & RXapif_REGNAMES) {\n        return reg_named_buff_all(rx, flags);\n    } else if (flags & (RXapif_SCALAR | RXapif_REGNAMES_COUNT)) {\n        return reg_named_buff_scalar(rx, flags);\n    } else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff\", (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey,\n                         const U32 flags)\n{\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER;\n    PERL_UNUSED_ARG(lastkey);\n\n    if (flags & RXapif_FIRSTKEY)\n        return reg_named_buff_firstkey(rx, flags);\n    else if (flags & RXapif_NEXTKEY)\n        return reg_named_buff_nextkey(rx, flags);\n    else {\n        Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_iter\",\n                                            (int)flags);\n        return NULL;\n    }\n}\n\nSV*\nPerl_reg_named_buff_fetch(pTHX_ REGEXP * const r, SV * const namesv,\n\t\t\t  const U32 flags)\n{\n    SV *ret;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HE *he_str = hv_fetch_ent( RXp_PAREN_NAMES(rx), namesv, 0, 0 );\n        if (he_str) {\n            IV i;\n            SV* sv_dat=HeVAL(he_str);\n            I32 *nums=(I32*)SvPVX(sv_dat);\n            AV * const retarray = (flags & RXapif_ALL) ? newAV() : NULL;\n            for ( i=0; i<SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->nparens) >= nums[i]\n                    && rx->offs[nums[i]].start != -1\n                    && rx->offs[nums[i]].end != -1)\n                {\n                    ret = newSVpvs(\"\");\n                    CALLREG_NUMBUF_FETCH(r,nums[i],ret);\n                    if (!retarray)\n                        return ret;\n                } else {\n                    if (retarray)\n                        ret = newSVsv(&PL_sv_undef);\n                }\n                if (retarray)\n                    av_push(retarray, ret);\n            }\n            if (retarray)\n                return newRV_noinc(MUTABLE_SV(retarray));\n        }\n    }\n    return NULL;\n}\n\nbool\nPerl_reg_named_buff_exists(pTHX_ REGEXP * const r, SV * const key,\n                           const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & RXapif_ALL) {\n            return hv_exists_ent(RXp_PAREN_NAMES(rx), key, 0);\n        } else {\n\t    SV *sv = CALLREG_NAMED_BUFF_FETCH(r, key, flags);\n            if (sv) {\n\t\tSvREFCNT_dec_NN(sv);\n                return TRUE;\n            } else {\n                return FALSE;\n            }\n        }\n    } else {\n        return FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_firstkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY;\n\n    if ( rx && RXp_PAREN_NAMES(rx) ) {\n\t(void)hv_iterinit(RXp_PAREN_NAMES(rx));\n\n\treturn CALLREG_NAMED_BUFF_NEXTKEY(r, NULL, flags & ~RXapif_FIRSTKEY);\n    } else {\n\treturn FALSE;\n    }\n}\n\nSV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv,0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;\n}\n\nSV*\nPerl_reg_named_buff_scalar(pTHX_ REGEXP * const r, const U32 flags)\n{\n    SV *ret;\n    AV *av;\n    SSize_t length;\n    struct regexp *const rx = ReANY(r);\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        if (flags & (RXapif_ALL | RXapif_REGNAMES_COUNT)) {\n            return newSViv(HvTOTALKEYS(RXp_PAREN_NAMES(rx)));\n        } else if (flags & RXapif_ONE) {\n            ret = CALLREG_NAMED_BUFF_ALL(r, (flags | RXapif_REGNAMES));\n            av = MUTABLE_AV(SvRV(ret));\n            length = av_tindex(av);\n\t    SvREFCNT_dec_NN(ret);\n            return newSViv(length + 1);\n        } else {\n            Perl_croak(aTHX_ \"panic: Unknown flags %d in named_buff_scalar\",\n                                                (int)flags);\n            return NULL;\n        }\n    }\n    return &PL_sv_undef;\n}\n\nSV*\nPerl_reg_named_buff_all(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    AV *av = newAV();\n\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL;\n\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv= RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        (void)hv_iterinit(hv);\n        while ( (temphe = hv_iternext_flags(hv,0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n                av_push(av, newSVhek(HeKEY_hek(temphe)));\n            }\n        }\n    }\n\n    return newRV_noinc(MUTABLE_SV(av));\n}\n\nvoid\nPerl_reg_numbered_buff_fetch(pTHX_ REGEXP * const r, const I32 paren,\n\t\t\t     SV * const sv)\n{\n    struct regexp *const rx = ReANY(r);\n    char *s = NULL;\n    SSize_t i = 0;\n    SSize_t s1, t1;\n    I32 n = paren;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH;\n\n    if (      n == RX_BUFF_IDX_CARET_PREMATCH\n           || n == RX_BUFF_IDX_CARET_FULLMATCH\n           || n == RX_BUFF_IDX_CARET_POSTMATCH\n       )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto ret_undef;\n    }\n\n    if (!rx->subbeg)\n        goto ret_undef;\n\n    if (n == RX_BUFF_IDX_CARET_FULLMATCH)\n        /* no need to distinguish between them any more */\n        n = RX_BUFF_IDX_FULLMATCH;\n\n    if ((n == RX_BUFF_IDX_PREMATCH || n == RX_BUFF_IDX_CARET_PREMATCH)\n        && rx->offs[0].start != -1)\n    {\n        /* $`, ${^PREMATCH} */\n\ti = rx->offs[0].start;\n\ts = rx->subbeg;\n    }\n    else\n    if ((n == RX_BUFF_IDX_POSTMATCH || n == RX_BUFF_IDX_CARET_POSTMATCH)\n        && rx->offs[0].end != -1)\n    {\n        /* $', ${^POSTMATCH} */\n\ts = rx->subbeg - rx->suboffset + rx->offs[0].end;\n\ti = rx->sublen + rx->suboffset - rx->offs[0].end;\n    }\n    else\n    if ( 0 <= n && n <= (I32)rx->nparens &&\n        (s1 = rx->offs[n].start) != -1 &&\n        (t1 = rx->offs[n].end) != -1)\n    {\n        /* $&, ${^MATCH},  $1 ... */\n        i = t1 - s1;\n        s = rx->subbeg + s1 - rx->suboffset;\n    } else {\n        goto ret_undef;\n    }\n\n    assert(s >= rx->subbeg);\n    assert((STRLEN)rx->sublen >= (STRLEN)((s - rx->subbeg) + i) );\n    if (i >= 0) {\n#ifdef NO_TAINT_SUPPORT\n        sv_setpvn(sv, s, i);\n#else\n        const int oldtainted = TAINT_get;\n        TAINT_NOT;\n        sv_setpvn(sv, s, i);\n        TAINT_set(oldtainted);\n#endif\n        if (RXp_MATCH_UTF8(rx))\n            SvUTF8_on(sv);\n        else\n            SvUTF8_off(sv);\n        if (TAINTING_get) {\n            if (RXp_MATCH_TAINTED(rx)) {\n                if (SvTYPE(sv) >= SVt_PVMG) {\n                    MAGIC* const mg = SvMAGIC(sv);\n                    MAGIC* mgt;\n                    TAINT;\n                    SvMAGIC_set(sv, mg->mg_moremagic);\n                    SvTAINT(sv);\n                    if ((mgt = SvMAGIC(sv))) {\n                        mg->mg_moremagic = mgt;\n                        SvMAGIC_set(sv, mg);\n                    }\n                } else {\n                    TAINT;\n                    SvTAINT(sv);\n                }\n            } else\n                SvTAINTED_off(sv);\n        }\n    } else {\n      ret_undef:\n        sv_set_undef(sv);\n        return;\n    }\n}\n\nvoid\nPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,\n\t\t\t\t\t\t\t SV const * const value)\n{\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;\n\n    PERL_UNUSED_ARG(rx);\n    PERL_UNUSED_ARG(paren);\n    PERL_UNUSED_ARG(value);\n\n    if (!PL_localizing)\n        Perl_croak_no_modify();\n}\n\nI32\nPerl_reg_numbered_buff_length(pTHX_ REGEXP * const r, const SV * const sv,\n                              const I32 paren)\n{\n    struct regexp *const rx = ReANY(r);\n    I32 i;\n    I32 s1, t1;\n\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH;\n\n    if (   paren == RX_BUFF_IDX_CARET_PREMATCH\n        || paren == RX_BUFF_IDX_CARET_FULLMATCH\n        || paren == RX_BUFF_IDX_CARET_POSTMATCH\n    )\n    {\n        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);\n        if (!keepcopy) {\n            /* on something like\n             *    $r = qr/.../;\n             *    /$qr/p;\n             * the KEEPCOPY is set on the PMOP rather than the regex */\n            if (PL_curpm && r == PM_GETRE(PL_curpm))\n                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);\n        }\n        if (!keepcopy)\n            goto warn_undef;\n    }\n\n    /* Some of this code was originally in C<Perl_magic_len> in F<mg.c> */\n    switch (paren) {\n      case RX_BUFF_IDX_CARET_PREMATCH: /* ${^PREMATCH} */\n      case RX_BUFF_IDX_PREMATCH:       /* $` */\n        if (rx->offs[0].start != -1) {\n\t\t\ti = rx->offs[0].start;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = 0;\n\t\t\t\tt1 = i;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      case RX_BUFF_IDX_CARET_POSTMATCH: /* ${^POSTMATCH} */\n      case RX_BUFF_IDX_POSTMATCH:       /* $' */\n\t    if (rx->offs[0].end != -1) {\n\t\t\ti = rx->sublen - rx->offs[0].end;\n\t\t\tif (i > 0) {\n\t\t\t\ts1 = rx->offs[0].end;\n\t\t\t\tt1 = rx->sublen;\n\t\t\t\tgoto getlen;\n\t\t\t}\n\t    }\n        return 0;\n\n      default: /* $& / ${^MATCH}, $1, $2, ... */\n\t    if (paren <= (I32)rx->nparens &&\n            (s1 = rx->offs[paren].start) != -1 &&\n            (t1 = rx->offs[paren].end) != -1)\n\t    {\n            i = t1 - s1;\n            goto getlen;\n        } else {\n          warn_undef:\n            if (ckWARN(WARN_UNINITIALIZED))\n                report_uninit((const SV *)sv);\n            return 0;\n        }\n    }\n  getlen:\n    if (i > 0 && RXp_MATCH_UTF8(rx)) {\n        const char * const s = rx->subbeg - rx->suboffset + s1;\n        const U8 *ep;\n        STRLEN el;\n\n        i = t1 - s1;\n        if (is_utf8_string_loclen((U8*)s, i, &ep, &el))\n\t\t\ti = el;\n    }\n    return i;\n}\n\nSV*\nPerl_reg_qr_package(pTHX_ REGEXP * const rx)\n{\n    PERL_ARGS_ASSERT_REG_QR_PACKAGE;\n\tPERL_UNUSED_ARG(rx);\n\tif (0)\n\t    return NULL;\n\telse\n\t    return newSVpvs(\"Regexp\");\n}\n\n/* Scans the name of a named buffer from the pattern.\n * If flags is REG_RSN_RETURN_NULL returns null.\n * If flags is REG_RSN_RETURN_NAME returns an SV* containing the name\n * If flags is REG_RSN_RETURN_DATA returns the data SV* corresponding\n * to the parsed name as looked up in the RExC_paren_names hash.\n * If there is an error throws a vFAIL().. type exception.\n */\n\n#define REG_RSN_RETURN_NULL    0\n#define REG_RSN_RETURN_NAME    1\n#define REG_RSN_RETURN_DATA    2\n\nSTATIC SV*\nS_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags)\n{\n    char *name_start = RExC_parse;\n\n    PERL_ARGS_ASSERT_REG_SCAN_NAME;\n\n    assert (RExC_parse <= RExC_end);\n    if (RExC_parse == RExC_end) NOOP;\n    else if (isIDFIRST_lazy_if_safe(RExC_parse, RExC_end, UTF)) {\n         /* Note that the code here assumes well-formed UTF-8.  Skip IDFIRST by\n          * using do...while */\n\tif (UTF)\n\t    do {\n\t\tRExC_parse += UTF8SKIP(RExC_parse);\n\t    } while (   RExC_parse < RExC_end\n                     && isWORDCHAR_utf8_safe((U8*)RExC_parse, (U8*) RExC_end));\n\telse\n\t    do {\n\t\tRExC_parse++;\n\t    } while (RExC_parse < RExC_end && isWORDCHAR(*RExC_parse));\n    } else {\n        RExC_parse++; /* so the <- from the vFAIL is after the offending\n                         character */\n        vFAIL(\"Group name must start with a non-digit word character\");\n    }\n    if ( flags ) {\n        SV* sv_name\n\t    = newSVpvn_flags(name_start, (int)(RExC_parse - name_start),\n\t\t\t     SVs_TEMP | (UTF ? SVf_UTF8 : 0));\n        if ( flags == REG_RSN_RETURN_NAME)\n            return sv_name;\n        else if (flags==REG_RSN_RETURN_DATA) {\n            HE *he_str = NULL;\n            SV *sv_dat = NULL;\n            if ( ! sv_name )      /* should not happen*/\n                Perl_croak(aTHX_ \"panic: no svname in reg_scan_name\");\n            if (RExC_paren_names)\n                he_str = hv_fetch_ent( RExC_paren_names, sv_name, 0, 0 );\n            if ( he_str )\n                sv_dat = HeVAL(he_str);\n            if ( ! sv_dat )\n                vFAIL(\"Reference to nonexistent named group\");\n            return sv_dat;\n        }\n        else {\n            Perl_croak(aTHX_ \"panic: bad flag %lx in reg_scan_name\",\n\t\t       (unsigned long) flags);\n        }\n        NOT_REACHED; /* NOTREACHED */\n    }\n    return NULL;\n}\n\n#define DEBUG_PARSE_MSG(funcname)     DEBUG_PARSE_r({           \\\n    int num;                                                    \\\n    if (RExC_lastparse!=RExC_parse) {                           \\\n        Perl_re_printf( aTHX_  \"%s\",                                        \\\n            Perl_pv_pretty(aTHX_ RExC_mysv1, RExC_parse,        \\\n                RExC_end - RExC_parse, 16,                      \\\n                \"\", \"\",                                         \\\n                PERL_PV_ESCAPE_UNI_DETECT |                     \\\n                PERL_PV_PRETTY_ELLIPSES   |                     \\\n                PERL_PV_PRETTY_LTGT       |                     \\\n                PERL_PV_ESCAPE_RE         |                     \\\n                PERL_PV_PRETTY_EXACTSIZE                        \\\n            )                                                   \\\n        );                                                      \\\n    } else                                                      \\\n        Perl_re_printf( aTHX_ \"%16s\",\"\");                                   \\\n                                                                \\\n    if (SIZE_ONLY)                                              \\\n       num = RExC_size + 1;                                     \\\n    else                                                        \\\n       num=REG_NODE_NUM(RExC_emit);                             \\\n    if (RExC_lastnum!=num)                                      \\\n       Perl_re_printf( aTHX_ \"|%4d\",num);                                   \\\n    else                                                        \\\n       Perl_re_printf( aTHX_ \"|%4s\",\"\");                                    \\\n    Perl_re_printf( aTHX_ \"|%*s%-4s\",                                       \\\n        (int)((depth*2)), \"\",                                   \\\n        (funcname)                                              \\\n    );                                                          \\\n    RExC_lastnum=num;                                           \\\n    RExC_lastparse=RExC_parse;                                  \\\n})\n\n\n\n#define DEBUG_PARSE(funcname)     DEBUG_PARSE_r({           \\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ \"%4s\",\"\\n\");                                  \\\n})\n#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({\\\n    DEBUG_PARSE_MSG((funcname));                            \\\n    Perl_re_printf( aTHX_ fmt \"\\n\",args);                               \\\n})\n\n/* This section of code defines the inversion list object and its methods.  The\n * interfaces are highly subject to change, so as much as possible is static to\n * this file.  An inversion list is here implemented as a malloc'd C UV array\n * as an SVt_INVLIST scalar.\n *\n * An inversion list for Unicode is an array of code points, sorted by ordinal\n * number.  Each element gives the code point that begins a range that extends\n * up-to but not including the code point given by the next element.  The final\n * element gives the first code point of a range that extends to the platform's\n * infinity.  The even-numbered elements (invlist[0], invlist[2], invlist[4],\n * ...) give ranges whose code points are all in the inversion list.  We say\n * that those ranges are in the set.  The odd-numbered elements give ranges\n * whose code points are not in the inversion list, and hence not in the set.\n * Thus, element [0] is the first code point in the list.  Element [1]\n * is the first code point beyond that not in the list; and element [2] is the\n * first code point beyond that that is in the list.  In other words, the first\n * range is invlist[0]..(invlist[1]-1), and all code points in that range are\n * in the inversion list.  The second range is invlist[1]..(invlist[2]-1), and\n * all code points in that range are not in the inversion list.  The third\n * range invlist[2]..(invlist[3]-1) gives code points that are in the inversion\n * list, and so forth.  Thus every element whose index is divisible by two\n * gives the beginning of a range that is in the list, and every element whose\n * index is not divisible by two gives the beginning of a range not in the\n * list.  If the final element's index is divisible by two, the inversion list\n * extends to the platform's infinity; otherwise the highest code point in the\n * inversion list is the contents of that element minus 1.\n *\n * A range that contains just a single code point N will look like\n *  invlist[i]   == N\n *  invlist[i+1] == N+1\n *\n * If N is UV_MAX (the highest representable code point on the machine), N+1 is\n * impossible to represent, so element [i+1] is omitted.  The single element\n * inversion list\n *  invlist[0] == UV_MAX\n * contains just UV_MAX, but is interpreted as matching to infinity.\n *\n * Taking the complement (inverting) an inversion list is quite simple, if the\n * first element is 0, remove it; otherwise add a 0 element at the beginning.\n * This implementation reserves an element at the beginning of each inversion\n * list to always contain 0; there is an additional flag in the header which\n * indicates if the list begins at the 0, or is offset to begin at the next\n * element.  This means that the inversion list can be inverted without any\n * copying; just flip the flag.\n *\n * More about inversion lists can be found in \"Unicode Demystified\"\n * Chapter 13 by Richard Gillam, published by Addison-Wesley.\n *\n * The inversion list data structure is currently implemented as an SV pointing\n * to an array of UVs that the SV thinks are bytes.  This allows us to have an\n * array of UV whose memory management is automatically handled by the existing\n * facilities for SV's.\n *\n * Some of the methods should always be private to the implementation, and some\n * should eventually be made public */\n\n/* The header definitions are in F<invlist_inline.h> */\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV*\nS__invlist_array_init(SV* const invlist, const bool will_have_0)\n{\n    /* Returns a pointer to the first element in the inversion list's array.\n     * This is called upon initialization of an inversion list.  Where the\n     * array begins depends on whether the list has the code point U+0000 in it\n     * or not.  The other parameter tells it whether the code that follows this\n     * call is about to put a 0 in the inversion list or not.  The first\n     * element is either the element reserved for 0, if TRUE, or the element\n     * after it, if FALSE */\n\n    bool* offset = get_invlist_offset_addr(invlist);\n    UV* zero_addr = (UV *) SvPVX(invlist);\n\n    PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT;\n\n    /* Must be empty */\n    assert(! _invlist_len(invlist));\n\n    *zero_addr = 0;\n\n    /* 1^1 = 0; 1^0 = 1 */\n    *offset = 1 ^ will_have_0;\n    return zero_addr + *offset;\n}\n\n#endif\n\nPERL_STATIC_INLINE void\nS_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset)\n{\n    /* Sets the current number of elements stored in the inversion list.\n     * Updates SvCUR correspondingly */\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INVLIST_SET_LEN;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    SvCUR_set(invlist,\n              (len == 0)\n               ? 0\n               : TO_INTERNAL_SIZE(len + offset));\n    assert(SvLEN(invlist) == 0 || SvCUR(invlist) <= SvLEN(invlist));\n}\n\n#ifndef PERL_IN_XSUB_RE\n\nSTATIC void\nS_invlist_replace_list_destroys_src(pTHX_ SV * dest, SV * src)\n{\n    /* Replaces the inversion list in 'dest' with the one from 'src'.  It\n     * steals the list from 'src', so 'src' is made to have a NULL list.  This\n     * is similar to what SvSetMagicSV() would do, if it were implemented on\n     * inversion lists, though this routine avoids a copy */\n\n    const UV src_len          = _invlist_len(src);\n    const bool src_offset     = *get_invlist_offset_addr(src);\n    const STRLEN src_byte_len = SvLEN(src);\n    char * array              = SvPVX(src);\n\n    const int oldtainted = TAINT_get;\n\n    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;\n\n    assert(SvTYPE(src) == SVt_INVLIST);\n    assert(SvTYPE(dest) == SVt_INVLIST);\n    assert(! invlist_is_iterating(src));\n    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));\n\n    /* Make sure it ends in the right place with a NUL, as our inversion list\n     * manipulations aren't careful to keep this true, but sv_usepvn_flags()\n     * asserts it */\n    array[src_byte_len - 1] = '\\0';\n\n    TAINT_NOT;      /* Otherwise it breaks */\n    sv_usepvn_flags(dest,\n                    (char *) array,\n                    src_byte_len - 1,\n\n                    /* This flag is documented to cause a copy to be avoided */\n                    SV_HAS_TRAILING_NUL);\n    TAINT_set(oldtainted);\n    SvPV_set(src, 0);\n    SvLEN_set(src, 0);\n    SvCUR_set(src, 0);\n\n    /* Finish up copying over the other fields in an inversion list */\n    *get_invlist_offset_addr(dest) = src_offset;\n    invlist_set_len(dest, src_len, src_offset);\n    *get_invlist_previous_index_addr(dest) = 0;\n    invlist_iterfinish(dest);\n}\n\nPERL_STATIC_INLINE IV*\nS_get_invlist_previous_index_addr(SV* invlist)\n{\n    /* Return the address of the IV that is reserved to hold the cached index\n     * */\n    PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    return &(((XINVLIST*) SvANY(invlist))->prev_index);\n}\n\nPERL_STATIC_INLINE IV\nS_invlist_previous_index(SV* const invlist)\n{\n    /* Returns cached index of previous search */\n\n    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;\n\n    return *get_invlist_previous_index_addr(invlist);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_set_previous_index(SV* const invlist, const IV index)\n{\n    /* Caches <index> for later retrieval */\n\n    PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX;\n\n    assert(index == 0 || index < (int) _invlist_len(invlist));\n\n    *get_invlist_previous_index_addr(invlist) = index;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_trim(SV* invlist)\n{\n    /* Free the not currently-being-used space in an inversion list */\n\n    /* But don't free up the space needed for the 0 UV that is always at the\n     * beginning of the list, nor the trailing NUL */\n    const UV min_size = TO_INTERNAL_SIZE(1) + 1;\n\n    PERL_ARGS_ASSERT_INVLIST_TRIM;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    SvPV_renew(invlist, MAX(min_size, SvCUR(invlist) + 1));\n}\n\nPERL_STATIC_INLINE void\nS_invlist_clear(pTHX_ SV* invlist)    /* Empty the inversion list */\n{\n    PERL_ARGS_ASSERT_INVLIST_CLEAR;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    invlist_set_len(invlist, 0, 0);\n    invlist_trim(invlist);\n}\n\n#endif /* ifndef PERL_IN_XSUB_RE */\n\nPERL_STATIC_INLINE bool\nS_invlist_is_iterating(SV* const invlist)\n{\n    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;\n\n    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;\n}\n\n#ifndef PERL_IN_XSUB_RE\n\nPERL_STATIC_INLINE UV\nS_invlist_max(SV* const invlist)\n{\n    /* Returns the maximum number of elements storable in the inversion list's\n     * array, without having to realloc() */\n\n    PERL_ARGS_ASSERT_INVLIST_MAX;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    /* Assumes worst case, in which the 0 element is not counted in the\n     * inversion list, so subtracts 1 for that */\n    return SvLEN(invlist) == 0  /* This happens under _new_invlist_C_array */\n           ? FROM_INTERNAL_SIZE(SvCUR(invlist)) - 1\n           : FROM_INTERNAL_SIZE(SvLEN(invlist)) - 1;\n}\nSV*\nPerl__new_invlist(pTHX_ IV initial_size)\n{\n\n    /* Return a pointer to a newly constructed inversion list, with enough\n     * space to store 'initial_size' elements.  If that number is negative, a\n     * system default is used instead */\n\n    SV* new_list;\n\n    if (initial_size < 0) {\n\tinitial_size = 10;\n    }\n\n    /* Allocate the initial space */\n    new_list = newSV_type(SVt_INVLIST);\n\n    /* First 1 is in case the zero element isn't in the list; second 1 is for\n     * trailing NUL */\n    SvGROW(new_list, TO_INTERNAL_SIZE(initial_size + 1) + 1);\n    invlist_set_len(new_list, 0, 0);\n\n    /* Force iterinit() to be used to get iteration to work */\n    *get_invlist_iter_addr(new_list) = (STRLEN) UV_MAX;\n\n    *get_invlist_previous_index_addr(new_list) = 0;\n\n    return new_list;\n}\n\nSV*\nPerl__new_invlist_C_array(pTHX_ const UV* const list)\n{\n    /* Return a pointer to a newly constructed inversion list, initialized to\n     * point to <list>, which has to be in the exact correct inversion list\n     * form, including internal fields.  Thus this is a dangerous routine that\n     * should not be used in the wrong hands.  The passed in 'list' contains\n     * several header fields at the beginning that are not part of the\n     * inversion list body proper */\n\n    const STRLEN length = (STRLEN) list[0];\n    const UV version_id =          list[1];\n    const bool offset   =    cBOOL(list[2]);\n#define HEADER_LENGTH 3\n    /* If any of the above changes in any way, you must change HEADER_LENGTH\n     * (if appropriate) and regenerate INVLIST_VERSION_ID by running\n     *      perl -E 'say int(rand 2**31-1)'\n     */\n#define INVLIST_VERSION_ID 148565664 /* This is a combination of a version and\n                                        data structure type, so that one being\n                                        passed in can be validated to be an\n                                        inversion list of the correct vintage.\n                                       */\n\n    SV* invlist = newSV_type(SVt_INVLIST);\n\n    PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY;\n\n    if (version_id != INVLIST_VERSION_ID) {\n        Perl_croak(aTHX_ \"panic: Incorrect version for previously generated inversion list\");\n    }\n\n    /* The generated array passed in includes header elements that aren't part\n     * of the list proper, so start it just after them */\n    SvPV_set(invlist, (char *) (list + HEADER_LENGTH));\n\n    SvLEN_set(invlist, 0);  /* Means we own the contents, and the system\n\t\t\t       shouldn't touch it */\n\n    *(get_invlist_offset_addr(invlist)) = offset;\n\n    /* The 'length' passed to us is the physical number of elements in the\n     * inversion list.  But if there is an offset the logical number is one\n     * less than that */\n    invlist_set_len(invlist, length  - offset, offset);\n\n    invlist_set_previous_index(invlist, 0);\n\n    /* Initialize the iteration pointer. */\n    invlist_iterfinish(invlist);\n\n    SvREADONLY_on(invlist);\n\n    return invlist;\n}\n\nSTATIC void\nS_invlist_extend(pTHX_ SV* const invlist, const UV new_max)\n{\n    /* Grow the maximum size of an inversion list */\n\n    PERL_ARGS_ASSERT_INVLIST_EXTEND;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    /* Add one to account for the zero element at the beginning which may not\n     * be counted by the calling parameters */\n    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max + 1));\n}\n\nSTATIC void\nS__append_range_to_invlist(pTHX_ SV* const invlist,\n                                 const UV start, const UV end)\n{\n   /* Subject to change or removal.  Append the range from 'start' to 'end' at\n    * the end of the inversion list.  The range must be above any existing\n    * ones. */\n\n    UV* array;\n    UV max = invlist_max(invlist);\n    UV len = _invlist_len(invlist);\n    bool offset;\n\n    PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST;\n\n    if (len == 0) { /* Empty lists must be initialized */\n        offset = start != 0;\n        array = _invlist_array_init(invlist, ! offset);\n    }\n    else {\n\t/* Here, the existing list is non-empty. The current max entry in the\n\t * list is generally the first value not in the set, except when the\n\t * set extends to the end of permissible values, in which case it is\n\t * the first entry in that final set, and so this call is an attempt to\n\t * append out-of-order */\n\n\tUV final_element = len - 1;\n\tarray = invlist_array(invlist);\n\tif (   array[final_element] > start\n\t    || ELEMENT_RANGE_MATCHES_INVLIST(final_element))\n\t{\n\t    Perl_croak(aTHX_ \"panic: attempting to append to an inversion list, but wasn't at the end of the list, final=%\" UVuf \", start=%\" UVuf \", match=%c\",\n\t\t     array[final_element], start,\n\t\t     ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');\n\t}\n\n        /* Here, it is a legal append.  If the new range begins 1 above the end\n         * of the range below it, it is extending the range below it, so the\n         * new first value not in the set is one greater than the newly\n         * extended range.  */\n        offset = *get_invlist_offset_addr(invlist);\n\tif (array[final_element] == start) {\n\t    if (end != UV_MAX) {\n\t\tarray[final_element] = end + 1;\n\t    }\n\t    else {\n\t\t/* But if the end is the maximum representable on the machine,\n                 * assume that infinity was actually what was meant.  Just let\n                 * the range that this would extend to have no end */\n\t\tinvlist_set_len(invlist, len - 1, offset);\n\t    }\n\t    return;\n\t}\n    }\n\n    /* Here the new range doesn't extend any existing set.  Add it */\n\n    len += 2;\t/* Includes an element each for the start and end of range */\n\n    /* If wll overflow the existing space, extend, which may cause the array to\n     * be moved */\n    if (max < len) {\n\tinvlist_extend(invlist, len);\n\n        /* Have to set len here to avoid assert failure in invlist_array() */\n        invlist_set_len(invlist, len, offset);\n\n\tarray = invlist_array(invlist);\n    }\n    else {\n\tinvlist_set_len(invlist, len, offset);\n    }\n\n    /* The next item on the list starts the range, the one after that is\n     * one past the new range.  */\n    array[len - 2] = start;\n    if (end != UV_MAX) {\n\tarray[len - 1] = end + 1;\n    }\n    else {\n\t/* But if the end is the maximum representable on the machine, just let\n\t * the range have no end */\n\tinvlist_set_len(invlist, len - 1, offset);\n    }\n}\n\nSSize_t\nPerl__invlist_search(SV* const invlist, const UV cp)\n{\n    /* Searches the inversion list for the entry that contains the input code\n     * point <cp>.  If <cp> is not in the list, -1 is returned.  Otherwise, the\n     * return value is the index into the list's array of the range that\n     * contains <cp>, that is, 'i' such that\n     *\tarray[i] <= cp < array[i+1]\n     */\n\n    IV low = 0;\n    IV mid;\n    IV high = _invlist_len(invlist);\n    const IV highest_element = high - 1;\n    const UV* array;\n\n    PERL_ARGS_ASSERT__INVLIST_SEARCH;\n\n    /* If list is empty, return failure. */\n    if (high == 0) {\n\treturn -1;\n    }\n\n    /* (We can't get the array unless we know the list is non-empty) */\n    array = invlist_array(invlist);\n\n    mid = invlist_previous_index(invlist);\n    assert(mid >=0);\n    if (mid > highest_element) {\n        mid = highest_element;\n    }\n\n    /* <mid> contains the cache of the result of the previous call to this\n     * function (0 the first time).  See if this call is for the same result,\n     * or if it is for mid-1.  This is under the theory that calls to this\n     * function will often be for related code points that are near each other.\n     * And benchmarks show that caching gives better results.  We also test\n     * here if the code point is within the bounds of the list.  These tests\n     * replace others that would have had to be made anyway to make sure that\n     * the array bounds were not exceeded, and these give us extra information\n     * at the same time */\n    if (cp >= array[mid]) {\n        if (cp >= array[highest_element]) {\n            return highest_element;\n        }\n\n        /* Here, array[mid] <= cp < array[highest_element].  This means that\n         * the final element is not the answer, so can exclude it; it also\n         * means that <mid> is not the final element, so can refer to 'mid + 1'\n         * safely */\n        if (cp < array[mid + 1]) {\n            return mid;\n        }\n        high--;\n        low = mid + 1;\n    }\n    else { /* cp < aray[mid] */\n        if (cp < array[0]) { /* Fail if outside the array */\n            return -1;\n        }\n        high = mid;\n        if (cp >= array[mid - 1]) {\n            goto found_entry;\n        }\n    }\n\n    /* Binary search.  What we are looking for is <i> such that\n     *\tarray[i] <= cp < array[i+1]\n     * The loop below converges on the i+1.  Note that there may not be an\n     * (i+1)th element in the array, and things work nonetheless */\n    while (low < high) {\n\tmid = (low + high) / 2;\n        assert(mid <= highest_element);\n\tif (array[mid] <= cp) { /* cp >= array[mid] */\n\t    low = mid + 1;\n\n\t    /* We could do this extra test to exit the loop early.\n\t    if (cp < array[low]) {\n\t\treturn mid;\n\t    }\n\t    */\n\t}\n\telse { /* cp < array[mid] */\n\t    high = mid;\n\t}\n    }\n\n  found_entry:\n    high--;\n    invlist_set_previous_index(invlist, high);\n    return high;\n}\n\nvoid\nPerl__invlist_populate_swatch(SV* const invlist,\n                              const UV start, const UV end, U8* swatch)\n{\n    /* populates a swatch of a swash the same way swatch_get() does in utf8.c,\n     * but is used when the swash has an inversion list.  This makes this much\n     * faster, as it uses a binary search instead of a linear one.  This is\n     * intimately tied to that function, and perhaps should be in utf8.c,\n     * except it is intimately tied to inversion lists as well.  It assumes\n     * that <swatch> is all 0's on input */\n\n    UV current = start;\n    const IV len = _invlist_len(invlist);\n    IV i;\n    const UV * array;\n\n    PERL_ARGS_ASSERT__INVLIST_POPULATE_SWATCH;\n\n    if (len == 0) { /* Empty inversion list */\n        return;\n    }\n\n    array = invlist_array(invlist);\n\n    /* Find which element it is */\n    i = _invlist_search(invlist, start);\n\n    /* We populate from <start> to <end> */\n    while (current < end) {\n        UV upper;\n\n\t/* The inversion list gives the results for every possible code point\n\t * after the first one in the list.  Only those ranges whose index is\n\t * even are ones that the inversion list matches.  For the odd ones,\n\t * and if the initial code point is not in the list, we have to skip\n\t * forward to the next element */\n        if (i == -1 || ! ELEMENT_RANGE_MATCHES_INVLIST(i)) {\n            i++;\n            if (i >= len) { /* Finished if beyond the end of the array */\n                return;\n            }\n            current = array[i];\n\t    if (current >= end) {   /* Finished if beyond the end of what we\n\t\t\t\t       are populating */\n                if (LIKELY(end < UV_MAX)) {\n                    return;\n                }\n\n                /* We get here when the upper bound is the maximum\n                 * representable on the machine, and we are looking for just\n                 * that code point.  Have to special case it */\n                i = len;\n                goto join_end_of_list;\n            }\n        }\n        assert(current >= start);\n\n\t/* The current range ends one below the next one, except don't go past\n\t * <end> */\n        i++;\n        upper = (i < len && array[i] < end) ? array[i] : end;\n\n\t/* Here we are in a range that matches.  Populate a bit in the 3-bit U8\n\t * for each code point in it */\n        for (; current < upper; current++) {\n            const STRLEN offset = (STRLEN)(current - start);\n            swatch[offset >> 3] |= 1 << (offset & 7);\n        }\n\n      join_end_of_list:\n\n\t/* Quit if at the end of the list */\n        if (i >= len) {\n\n\t    /* But first, have to deal with the highest possible code point on\n\t     * the platform.  The previous code assumes that <end> is one\n\t     * beyond where we want to populate, but that is impossible at the\n\t     * platform's infinity, so have to handle it specially */\n            if (UNLIKELY(end == UV_MAX && ELEMENT_RANGE_MATCHES_INVLIST(len-1)))\n\t    {\n                const STRLEN offset = (STRLEN)(end - start);\n                swatch[offset >> 3] |= 1 << (offset & 7);\n            }\n            return;\n        }\n\n\t/* Advance to the next range, which will be for code points not in the\n\t * inversion list */\n        current = array[i];\n    }\n\n    return;\n}\n\nvoid\nPerl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                         const bool complement_b, SV** output)\n{\n    /* Take the union of two inversion lists and point '*output' to it.  On\n     * input, '*output' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the union.  The first list, 'a', may be\n     * NULL, in which case a copy of the second list is placed in '*output'.\n     * If 'complement_b' is TRUE, the union is taken of the complement\n     * (inversion) of 'b' instead of b itself.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.\n     *\n     * The algorithm is like a merge sort. */\n\n    const UV* array_a;    /* a's array */\n    const UV* array_b;\n    UV len_a;\t    /* length of a's array */\n    UV len_b;\n\n    SV* u;\t\t\t/* the resulting union */\n    UV* array_u;\n    UV len_u = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_u = 0;\n\n    /* running count, as explained in the algorithm source book; items are\n     * stopped accumulating and are output when the count changes to/from 0.\n     * The count is incremented when we start a range that's in an input's set,\n     * and decremented when we start a range that's not in a set.  So this\n     * variable can be 0, 1, or 2.  When it is 0 neither input is in their set,\n     * and hence nothing goes into the union; 1, just one of the inputs is in\n     * its set (and its current range gets added to the union); and 2 when both\n     * inputs are in their sets.  */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*output == NULL || SvTYPE(*output) == SVt_INVLIST);\n\n    len_b = _invlist_len(b);\n    if (len_b == 0) {\n\n        /* Here, 'b' is empty, hence it's complement is all possible code\n         * points.  So if the union includes the complement of 'b', it includes\n         * everything, and we need not even look at 'a'.  It's easiest to\n         * create a new inversion list that matches everything.  */\n        if (complement_b) {\n            SV* everything = _add_range_to_invlist(NULL, 0, UV_MAX);\n\n            if (*output == NULL) { /* If the output didn't exist, just point it\n                                      at the new list */\n                *output = everything;\n            }\n            else { /* Otherwise, replace its contents with the new list */\n                invlist_replace_list_destroys_src(*output, everything);\n                SvREFCNT_dec_NN(everything);\n            }\n\n            return;\n        }\n\n        /* Here, we don't want the complement of 'b', and since 'b' is empty,\n         * the union will come entirely from 'a'.  If 'a' is NULL or empty, the\n         * output will be empty */\n\n        if (a == NULL || _invlist_len(a) == 0) {\n            if (*output == NULL) {\n                *output = _new_invlist(0);\n            }\n            else {\n                invlist_clear(*output);\n            }\n            return;\n        }\n\n        /* Here, 'a' is not empty, but 'b' is, so 'a' entirely determines the\n         * union.  We can just return a copy of 'a' if '*output' doesn't point\n         * to an existing list */\n        if (*output == NULL) {\n            *output = invlist_clone(a);\n            return;\n        }\n\n        /* If the output is to overwrite 'a', we have a no-op, as it's\n         * already in 'a' */\n        if (*output == a) {\n            return;\n        }\n\n        /* Here, '*output' is to be overwritten by 'a' */\n        u = invlist_clone(a);\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n\n        return;\n    }\n\n    /* Here 'b' is not empty.  See about 'a' */\n\n    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {\n\n        /* Here, 'a' is empty (and b is not).  That means the union will come\n         * entirely from 'b'.  If '*output' is NULL, we can directly return a\n         * clone of 'b'.  Otherwise, we replace the contents of '*output' with\n         * the clone */\n\n        SV ** dest = (*output == NULL) ? output : &u;\n        *dest = invlist_clone(b);\n        if (complement_b) {\n            _invlist_invert(*dest);\n        }\n\n        if (dest == &u) {\n            invlist_replace_list_destroys_src(*output, u);\n            SvREFCNT_dec_NN(u);\n        }\n\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the union of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the union for the worst case: that the sets are completely\n     * disjoint */\n    u = _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 if either component does */\n    array_u = _invlist_array_init(u, (    len_a > 0 && array_a[0] == 0)\n                                      || (len_b > 0 && array_b[0] == 0));\n\n    /* Go through each input list item by item, stopping when have exhausted\n     * one of them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the union's array */\n\tbool cp_in_set;   /* is it in the the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the union.\n\t * Since we are merging two sorted lists, we take the smaller of the\n         * next items.  In case of a tie, we take first the one that is in its\n         * set.  If we first took the one not in its set, it would decrement\n         * the count, possibly to 0 which would cause it to be output as ending\n         * the range, and the next time through we would take the same number,\n         * and output it again as beginning the next range.  By doing it the\n         * opposite way, there is no possibility that the count will be\n         * momentarily decremented to 0, and thus the two adjoining ranges will\n         * be seamlessly merged.  (In a tie and both are in the set or both not\n         * in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp = array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 0, which marks the\n\t * beginning/end of a range that's in the set */\n\tif (cp_in_set) {\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t    count++;\n\t}\n\telse {\n\t    count--;\n\t    if (count == 0) {\n\t\tarray_u[i_u++] = cp;\n\t    }\n\t}\n    }\n\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We decrement 'count', as explained below, if\n     * that list is in its set.  (i_a and i_b each currently index the element\n     * beyond the one we care about.) */\n    if (   (i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n\t|| (i_b != len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount--;\n    }\n\n    /* Above we decremented 'count' if the list that had unexamined elements in\n     * it was in its set.  This has made it so that 'count' being non-zero\n     * means there isn't anything left to output; and 'count' equal to 0 means\n     * that what is left to output is precisely that which is left in the\n     * non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to add to the union.  If it was in its set at its end, that means\n     * the set extends from here to the platform's infinity, and hence so does\n     * the union and the non-exhausted set is irrelevant.  The exhausted set\n     * also contributed 1 to 'count'.  If 'count' was 2, it got decremented to\n     * 1, but if it was 1, the non-exhausted set wasn't in its set, and so\n     * 'count' remains at 1.  This is consistent with the decremented 'count'\n     * != 0 meaning there's nothing left to add to the union.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the rest of the union will be whatever the other input is.\n     * If 'count' was 0, neither list was in its set, and 'count' remains 0;\n     * otherwise it gets decremented to 0.  This is consistent with 'count'\n     * == 0 meaning the remainder of the union is whatever is left in the\n     * non-exhausted list. */\n    if (count != 0) {\n        len_u = i_u;\n    }\n    else {\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* The non-exhausted input is 'a' */\n\t    Copy(array_a + i_a, array_u + i_u, copy_count, UV);\n        }\n        else { /* The non-exhausted input is b */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_u + i_u, copy_count, UV);\n        }\n        len_u = i_u + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_u, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_u != _invlist_len(u)) {\n\tinvlist_set_len(u, len_u, *get_invlist_offset_addr(u));\n\tinvlist_trim(u);\n\tarray_u = invlist_array(u);\n    }\n\n    if (*output == NULL) {  /* Simply return the new inversion list */\n        *output = u;\n    }\n    else {\n        /* Otherwise, overwrite the inversion list that was in '*output'.  We\n         * could instead free '*output', and then set it to 'u', but experience\n         * has shown [perl #127392] that if the input is a mortal, we can get a\n         * huge build-up of these during regex compilation before they get\n         * freed. */\n        invlist_replace_list_destroys_src(*output, u);\n        SvREFCNT_dec_NN(u);\n    }\n\n    return;\n}\n\nvoid\nPerl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,\n                                               const bool complement_b, SV** i)\n{\n    /* Take the intersection of two inversion lists and point '*i' to it.  On\n     * input, '*i' MUST POINT TO NULL OR TO AN SV* INVERSION LIST (possibly\n     * even 'a' or 'b').  If to an inversion list, the contents of the original\n     * list will be replaced by the intersection.  The first list, 'a', may be\n     * NULL, in which case '*i' will be an empty list.  If 'complement_b' is\n     * TRUE, the result will be the intersection of 'a' and the complement (or\n     * inversion) of 'b' instead of 'b' directly.\n     *\n     * The basis for this comes from \"Unicode Demystified\" Chapter 13 by\n     * Richard Gillam, published by Addison-Wesley, and explained at some\n     * length there.  The preface says to incorporate its examples into your\n     * code at your own risk.  In fact, it had bugs\n     *\n     * The algorithm is like a merge sort, and is essentially the same as the\n     * union above\n     */\n\n    const UV* array_a;\t\t/* a's array */\n    const UV* array_b;\n    UV len_a;\t/* length of a's array */\n    UV len_b;\n\n    SV* r;\t\t     /* the resulting intersection */\n    UV* array_r;\n    UV len_r = 0;\n\n    UV i_a = 0;\t\t    /* current index into a's array */\n    UV i_b = 0;\n    UV i_r = 0;\n\n    /* running count of how many of the two inputs are postitioned at ranges\n     * that are in their sets.  As explained in the algorithm source book,\n     * items are stopped accumulating and are output when the count changes\n     * to/from 2.  The count is incremented when we start a range that's in an\n     * input's set, and decremented when we start a range that's not in a set.\n     * Only when it is 2 are we in the intersection. */\n    UV count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND;\n    assert(a != b);\n    assert(*i == NULL || SvTYPE(*i) == SVt_INVLIST);\n\n    /* Special case if either one is empty */\n    len_a = (a == NULL) ? 0 : _invlist_len(a);\n    if ((len_a == 0) || ((len_b = _invlist_len(b)) == 0)) {\n        if (len_a != 0 && complement_b) {\n\n            /* Here, 'a' is not empty, therefore from the enclosing 'if', 'b'\n             * must be empty.  Here, also we are using 'b's complement, which\n             * hence must be every possible code point.  Thus the intersection\n             * is simply 'a'. */\n\n            if (*i == a) {  /* No-op */\n                return;\n            }\n\n            if (*i == NULL) {\n                *i = invlist_clone(a);\n                return;\n            }\n\n            r = invlist_clone(a);\n            invlist_replace_list_destroys_src(*i, r);\n            SvREFCNT_dec_NN(r);\n            return;\n        }\n\n        /* Here, 'a' or 'b' is empty and not using the complement of 'b'.  The\n         * intersection must be empty */\n        if (*i == NULL) {\n            *i = _new_invlist(0);\n            return;\n        }\n\n        invlist_clear(*i);\n\treturn;\n    }\n\n    /* Here both lists exist and are non-empty */\n    array_a = invlist_array(a);\n    array_b = invlist_array(b);\n\n    /* If are to take the intersection of 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n\t/* To complement, we invert: if the first element is 0, remove it.  To\n\t * do this, we just pretend the array starts one later */\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    /* Size the intersection for the worst case: that the intersection ends up\n     * fragmenting everything to be completely disjoint */\n    r= _new_invlist(len_a + len_b);\n\n    /* Will contain U+0000 iff both components do */\n    array_r = _invlist_array_init(r,    len_a > 0 && array_a[0] == 0\n                                     && len_b > 0 && array_b[0] == 0);\n\n    /* Go through each list item by item, stopping when have exhausted one of\n     * them */\n    while (i_a < len_a && i_b < len_b) {\n\tUV cp;\t    /* The element to potentially add to the intersection's\n\t\t       array */\n\tbool cp_in_set;\t/* Is it in the input list's set or not */\n\n\t/* We need to take one or the other of the two inputs for the\n\t * intersection.  Since we are merging two sorted lists, we take the\n         * smaller of the next items.  In case of a tie, we take first the one\n         * that is not in its set (a difference from the union algorithm).  If\n         * we first took the one in its set, it would increment the count,\n         * possibly to 2 which would cause it to be output as starting a range\n         * in the intersection, and the next time through we would take that\n         * same number, and output it again as ending the set.  By doing the\n         * opposite of this, there is no possibility that the count will be\n         * momentarily incremented to 2.  (In a tie and both are in the set or\n         * both not in the set, it doesn't matter which we take first.) */\n\tif (       array_a[i_a] < array_b[i_b]\n\t    || (   array_a[i_a] == array_b[i_b]\n\t\t&& ! ELEMENT_RANGE_MATCHES_INVLIST(i_a)))\n\t{\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);\n\t    cp = array_a[i_a++];\n\t}\n\telse {\n\t    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);\n\t    cp= array_b[i_b++];\n\t}\n\n\t/* Here, have chosen which of the two inputs to look at.  Only output\n\t * if the running count changes to/from 2, which marks the\n\t * beginning/end of a range that's in the intersection */\n\tif (cp_in_set) {\n\t    count++;\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t}\n\telse {\n\t    if (count == 2) {\n\t\tarray_r[i_r++] = cp;\n\t    }\n\t    count--;\n\t}\n\n    }\n\n    /* The loop above increments the index into exactly one of the input lists\n     * each iteration, and ends when either index gets to its list end.  That\n     * means the other index is lower than its end, and so something is\n     * remaining in that one.  We increment 'count', as explained below, if the\n     * exhausted list was in its set.  (i_a and i_b each currently index the\n     * element beyond the one we care about.) */\n    if (   (i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))\n        || (i_b == len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))\n    {\n\tcount++;\n    }\n\n    /* Above we incremented 'count' if the exhausted list was in its set.  This\n     * has made it so that 'count' being below 2 means there is nothing left to\n     * output; otheriwse what's left to add to the intersection is precisely\n     * that which is left in the non-exhausted input list.\n     *\n     * To see why, note first that the exhausted input obviously has nothing\n     * left to affect the intersection.  If it was in its set at its end, that\n     * means the set extends from here to the platform's infinity, and hence\n     * anything in the non-exhausted's list will be in the intersection, and\n     * anything not in it won't be.  Hence, the rest of the intersection is\n     * precisely what's in the non-exhausted list  The exhausted set also\n     * contributed 1 to 'count', meaning 'count' was at least 1.  Incrementing\n     * it means 'count' is now at least 2.  This is consistent with the\n     * incremented 'count' being >= 2 means to add the non-exhausted list to\n     * the intersection.\n     *\n     * But if the exhausted input wasn't in its set, it contributed 0 to\n     * 'count', and the intersection can't include anything further; the\n     * non-exhausted set is irrelevant.  'count' was at most 1, and doesn't get\n     * incremented.  This is consistent with 'count' being < 2 meaning nothing\n     * further to add to the intersection. */\n    if (count < 2) { /* Nothing left to put in the intersection. */\n        len_r = i_r;\n    }\n    else { /* copy the non-exhausted list, unchanged. */\n        IV copy_count = len_a - i_a;\n        if (copy_count > 0) {   /* a is the one with stuff left */\n\t    Copy(array_a + i_a, array_r + i_r, copy_count, UV);\n        }\n        else {  /* b is the one with stuff left */\n            copy_count = len_b - i_b;\n\t    Copy(array_b + i_b, array_r + i_r, copy_count, UV);\n        }\n        len_r = i_r + copy_count;\n    }\n\n    /* Set the result to the final length, which can change the pointer to\n     * array_r, so re-find it.  (Note that it is unlikely that this will\n     * change, as we are shrinking the space, not enlarging it) */\n    if (len_r != _invlist_len(r)) {\n\tinvlist_set_len(r, len_r, *get_invlist_offset_addr(r));\n\tinvlist_trim(r);\n\tarray_r = invlist_array(r);\n    }\n\n    if (*i == NULL) { /* Simply return the calculated intersection */\n        *i = r;\n    }\n    else { /* Otherwise, replace the existing inversion list in '*i'.  We could\n              instead free '*i', and then set it to 'r', but experience has\n              shown [perl #127392] that if the input is a mortal, we can get a\n              huge build-up of these during regex compilation before they get\n              freed. */\n        if (len_r) {\n            invlist_replace_list_destroys_src(*i, r);\n        }\n        else {\n            invlist_clear(*i);\n        }\n        SvREFCNT_dec_NN(r);\n    }\n\n    return;\n}\n\nSV*\nPerl__add_range_to_invlist(pTHX_ SV* invlist, UV start, UV end)\n{\n    /* Add the range from 'start' to 'end' inclusive to the inversion list's\n     * set.  A pointer to the inversion list is returned.  This may actually be\n     * a new list, in which case the passed in one has been destroyed.  The\n     * passed-in inversion list can be NULL, in which case a new one is created\n     * with just the one range in it.  The new list is not necessarily\n     * NUL-terminated.  Space is not freed if the inversion list shrinks as a\n     * result of this function.  The gain would not be large, and in many\n     * cases, this is called multiple times on a single inversion list, so\n     * anything freed may almost immediately be needed again.\n     *\n     * This used to mostly call the 'union' routine, but that is much more\n     * heavyweight than really needed for a single range addition */\n\n    UV* array;              /* The array implementing the inversion list */\n    UV len;                 /* How many elements in 'array' */\n    SSize_t i_s;            /* index into the invlist array where 'start'\n                               should go */\n    SSize_t i_e = 0;        /* And the index where 'end' should go */\n    UV cur_highest;         /* The highest code point in the inversion list\n                               upon entry to this function */\n\n    /* This range becomes the whole inversion list if none already existed */\n    if (invlist == NULL) {\n\tinvlist = _new_invlist(2);\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Likewise, if the inversion list is currently empty */\n    len = _invlist_len(invlist);\n    if (len == 0) {\n        _append_range_to_invlist(invlist, start, end);\n        return invlist;\n    }\n\n    /* Starting here, we have to know the internals of the list */\n    array = invlist_array(invlist);\n\n    /* If the new range ends higher than the current highest ... */\n    cur_highest = invlist_highest(invlist);\n    if (end > cur_highest) {\n\n        /* If the whole range is higher, we can just append it */\n        if (start > cur_highest) {\n            _append_range_to_invlist(invlist, start, end);\n            return invlist;\n        }\n\n        /* Otherwise, add the portion that is higher ... */\n        _append_range_to_invlist(invlist, cur_highest + 1, end);\n\n        /* ... and continue on below to handle the rest.  As a result of the\n         * above append, we know that the index of the end of the range is the\n         * final even numbered one of the array.  Recall that the final element\n         * always starts a range that extends to infinity.  If that range is in\n         * the set (meaning the set goes from here to infinity), it will be an\n         * even index, but if it isn't in the set, it's odd, and the final\n         * range in the set is one less, which is even. */\n        if (end == UV_MAX) {\n            i_e = len;\n        }\n        else {\n            i_e = len - 2;\n        }\n    }\n\n    /* We have dealt with appending, now see about prepending.  If the new\n     * range starts lower than the current lowest ... */\n    if (start < array[0]) {\n\n        /* Adding something which has 0 in it is somewhat tricky, and uncommon.\n         * Let the union code handle it, rather than having to know the\n         * trickiness in two code places.  */\n        if (UNLIKELY(start == 0)) {\n            SV* range_invlist;\n\n            range_invlist = _new_invlist(2);\n            _append_range_to_invlist(range_invlist, start, end);\n\n            _invlist_union(invlist, range_invlist, &invlist);\n\n            SvREFCNT_dec_NN(range_invlist);\n\n            return invlist;\n        }\n\n        /* If the whole new range comes before the first entry, and doesn't\n         * extend it, we have to insert it as an additional range */\n        if (end < array[0] - 1) {\n            i_s = i_e = -1;\n            goto splice_in_new_range;\n        }\n\n        /* Here the new range adjoins the existing first range, extending it\n         * downwards. */\n        array[0] = start;\n\n        /* And continue on below to handle the rest.  We know that the index of\n         * the beginning of the range is the first one of the array */\n        i_s = 0;\n    }\n    else { /* Not prepending any part of the new range to the existing list.\n            * Find where in the list it should go.  This finds i_s, such that:\n            *     invlist[i_s] <= start < array[i_s+1]\n            */\n        i_s = _invlist_search(invlist, start);\n    }\n\n    /* At this point, any extending before the beginning of the inversion list\n     * and/or after the end has been done.  This has made it so that, in the\n     * code below, each endpoint of the new range is either in a range that is\n     * in the set, or is in a gap between two ranges that are.  This means we\n     * don't have to worry about exceeding the array bounds.\n     *\n     * Find where in the list the new range ends (but we can skip this if we\n     * have already determined what it is, or if it will be the same as i_s,\n     * which we already have computed) */\n    if (i_e == 0) {\n        i_e = (start == end)\n              ? i_s\n              : _invlist_search(invlist, end);\n    }\n\n    /* Here generally invlist[i_e] <= end < array[i_e+1].  But if invlist[i_e]\n     * is a range that goes to infinity there is no element at invlist[i_e+1],\n     * so only the first relation holds. */\n\n    if ( ! ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n\n        /* Here, the ranges on either side of the beginning of the new range\n         * are in the set, and this range starts in the gap between them.\n         *\n         * The new range extends the range above it downwards if the new range\n         * ends at or above that range's start */\n        const bool extends_the_range_above = (   end == UV_MAX\n                                              || end + 1 >= array[i_s+1]);\n\n        /* The new range extends the range below it upwards if it begins just\n         * after where that range ends */\n        if (start == array[i_s]) {\n\n            /* If the new range fills the entire gap between the other ranges,\n             * they will get merged together.  Other ranges may also get\n             * merged, depending on how many of them the new range spans.  In\n             * the general case, we do the merge later, just once, after we\n             * figure out how many to merge.  But in the case where the new\n             * range exactly spans just this one gap (possibly extending into\n             * the one above), we do the merge here, and an early exit.  This\n             * is done here to avoid having to special case later. */\n            if (i_e - i_s <= 1) {\n\n                /* If i_e - i_s == 1, it means that the new range terminates\n                 * within the range above, and hence 'extends_the_range_above'\n                 * must be true.  (If the range above it extends to infinity,\n                 * 'i_s+2' will be above the array's limit, but 'len-i_s-2'\n                 * will be 0, so no harm done.) */\n                if (extends_the_range_above) {\n                    Move(array + i_s + 2, array + i_s, len - i_s - 2, UV);\n                    invlist_set_len(invlist,\n                                    len - 2,\n                                    *(get_invlist_offset_addr(invlist)));\n                    return invlist;\n                }\n\n                /* Here, i_e must == i_s.  We keep them in sync, as they apply\n                 * to the same range, and below we are about to decrement i_s\n                 * */\n                i_e--;\n            }\n\n            /* Here, the new range is adjacent to the one below.  (It may also\n             * span beyond the range above, but that will get resolved later.)\n             * Extend the range below to include this one. */\n            array[i_s] = (end == UV_MAX) ? UV_MAX : end + 1;\n            i_s--;\n            start = array[i_s];\n        }\n        else if (extends_the_range_above) {\n\n            /* Here the new range only extends the range above it, but not the\n             * one below.  It merges with the one above.  Again, we keep i_e\n             * and i_s in sync if they point to the same range */\n            if (i_e == i_s) {\n                i_e++;\n            }\n            i_s++;\n            array[i_s] = start;\n        }\n    }\n\n    /* Here, we've dealt with the new range start extending any adjoining\n     * existing ranges.\n     *\n     * If the new range extends to infinity, it is now the final one,\n     * regardless of what was there before */\n    if (UNLIKELY(end == UV_MAX)) {\n        invlist_set_len(invlist, i_s + 1, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* If i_e started as == i_s, it has also been dealt with,\n     * and been updated to the new i_s, which will fail the following if */\n    if (! ELEMENT_RANGE_MATCHES_INVLIST(i_e)) {\n\n        /* Here, the ranges on either side of the end of the new range are in\n         * the set, and this range ends in the gap between them.\n         *\n         * If this range is adjacent to (hence extends) the range above it, it\n         * becomes part of that range; likewise if it extends the range below,\n         * it becomes part of that range */\n        if (end + 1 == array[i_e+1]) {\n            i_e++;\n            array[i_e] = start;\n        }\n        else if (start <= array[i_e]) {\n            array[i_e] = end + 1;\n            i_e--;\n        }\n    }\n\n    if (i_s == i_e) {\n\n        /* If the range fits entirely in an existing range (as possibly already\n         * extended above), it doesn't add anything new */\n        if (ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {\n            return invlist;\n        }\n\n        /* Here, no part of the range is in the list.  Must add it.  It will\n         * occupy 2 more slots */\n      splice_in_new_range:\n\n        invlist_extend(invlist, len + 2);\n        array = invlist_array(invlist);\n        /* Move the rest of the array down two slots. Don't include any\n         * trailing NUL */\n        Move(array + i_e + 1, array + i_e + 3, len - i_e - 1, UV);\n\n        /* Do the actual splice */\n        array[i_e+1] = start;\n        array[i_e+2] = end + 1;\n        invlist_set_len(invlist, len + 2, *(get_invlist_offset_addr(invlist)));\n        return invlist;\n    }\n\n    /* Here the new range crossed the boundaries of a pre-existing range.  The\n     * code above has adjusted things so that both ends are in ranges that are\n     * in the set.  This means everything in between must also be in the set.\n     * Just squash things together */\n    Move(array + i_e + 1, array + i_s + 1, len - i_e - 1, UV);\n    invlist_set_len(invlist,\n                    len - i_e + i_s,\n                    *(get_invlist_offset_addr(invlist)));\n\n    return invlist;\n}\n\nSV*\nPerl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0,\n                                 UV** other_elements_ptr)\n{\n    /* Create and return an inversion list whose contents are to be populated\n     * by the caller.  The caller gives the number of elements (in 'size') and\n     * the very first element ('element0').  This function will set\n     * '*other_elements_ptr' to an array of UVs, where the remaining elements\n     * are to be placed.\n     *\n     * Obviously there is some trust involved that the caller will properly\n     * fill in the other elements of the array.\n     *\n     * (The first element needs to be passed in, as the underlying code does\n     * things differently depending on whether it is zero or non-zero) */\n\n    SV* invlist = _new_invlist(size);\n    bool offset;\n\n    PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST;\n\n    invlist = add_cp_to_invlist(invlist, element0);\n    offset = *get_invlist_offset_addr(invlist);\n\n    invlist_set_len(invlist, size, offset);\n    *other_elements_ptr = invlist_array(invlist) + 1;\n    return invlist;\n}\n\n#endif\n\nPERL_STATIC_INLINE SV*\nS_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp) {\n    return _add_range_to_invlist(invlist, cp, cp);\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_invert(pTHX_ SV* const invlist)\n{\n    /* Complement the input inversion list.  This adds a 0 if the list didn't\n     * have a zero; removes it otherwise.  As described above, the data\n     * structure is set up so that this is very efficient */\n\n    PERL_ARGS_ASSERT__INVLIST_INVERT;\n\n    assert(! invlist_is_iterating(invlist));\n\n    /* The inverse of matching nothing is matching everything */\n    if (_invlist_len(invlist) == 0) {\n\t_append_range_to_invlist(invlist, 0, UV_MAX);\n\treturn;\n    }\n\n    *get_invlist_offset_addr(invlist) = ! *get_invlist_offset_addr(invlist);\n}\n\n#endif\n\nPERL_STATIC_INLINE SV*\nS_invlist_clone(pTHX_ SV* const invlist)\n{\n\n    /* Return a new inversion list that is a copy of the input one, which is\n     * unchanged.  The new list will not be mortal even if the old one was. */\n\n    /* Need to allocate extra space to accommodate Perl's addition of a\n     * trailing NUL to SvPV's, since it thinks they are always strings */\n    SV* new_invlist = _new_invlist(_invlist_len(invlist) + 1);\n    STRLEN physical_length = SvCUR(invlist);\n    bool offset = *(get_invlist_offset_addr(invlist));\n\n    PERL_ARGS_ASSERT_INVLIST_CLONE;\n\n    *(get_invlist_offset_addr(new_invlist)) = offset;\n    invlist_set_len(new_invlist, _invlist_len(invlist), offset);\n    Copy(SvPVX(invlist), SvPVX(new_invlist), physical_length, char);\n\n    return new_invlist;\n}\n\nPERL_STATIC_INLINE STRLEN*\nS_get_invlist_iter_addr(SV* invlist)\n{\n    /* Return the address of the UV that contains the current iteration\n     * position */\n\n    PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR;\n\n    assert(SvTYPE(invlist) == SVt_INVLIST);\n\n    return &(((XINVLIST*) SvANY(invlist))->iterator);\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterinit(SV* invlist)\t/* Initialize iterator for invlist */\n{\n    PERL_ARGS_ASSERT_INVLIST_ITERINIT;\n\n    *get_invlist_iter_addr(invlist) = 0;\n}\n\nPERL_STATIC_INLINE void\nS_invlist_iterfinish(SV* invlist)\n{\n    /* Terminate iterator for invlist.  This is to catch development errors.\n     * Any iteration that is interrupted before completed should call this\n     * function.  Functions that add code points anywhere else but to the end\n     * of an inversion list assert that they are not in the middle of an\n     * iteration.  If they were, the addition would make the iteration\n     * problematical: if the iteration hadn't reached the place where things\n     * were being added, it would be ok */\n\n    PERL_ARGS_ASSERT_INVLIST_ITERFINISH;\n\n    *get_invlist_iter_addr(invlist) = (STRLEN) UV_MAX;\n}\n\nSTATIC bool\nS_invlist_iternext(SV* invlist, UV* start, UV* end)\n{\n    /* An C<invlist_iterinit> call on <invlist> must be used to set this up.\n     * This call sets in <*start> and <*end>, the next range in <invlist>.\n     * Returns <TRUE> if successful and the next call will return the next\n     * range; <FALSE> if was already at the end of the list.  If the latter,\n     * <*start> and <*end> are unchanged, and the next call to this function\n     * will start over at the beginning of the list */\n\n    STRLEN* pos = get_invlist_iter_addr(invlist);\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_ITERNEXT;\n\n    if (*pos >= len) {\n\t*pos = (STRLEN) UV_MAX;\t/* Force iterinit() to be required next time */\n\treturn FALSE;\n    }\n\n    array = invlist_array(invlist);\n\n    *start = array[(*pos)++];\n\n    if (*pos >= len) {\n\t*end = UV_MAX;\n    }\n    else {\n\t*end = array[(*pos)++] - 1;\n    }\n\n    return TRUE;\n}\n\nPERL_STATIC_INLINE UV\nS_invlist_highest(SV* const invlist)\n{\n    /* Returns the highest code point that matches an inversion list.  This API\n     * has an ambiguity, as it returns 0 under either the highest is actually\n     * 0, or if the list is empty.  If this distinction matters to you, check\n     * for emptiness before calling this function */\n\n    UV len = _invlist_len(invlist);\n    UV *array;\n\n    PERL_ARGS_ASSERT_INVLIST_HIGHEST;\n\n    if (len == 0) {\n\treturn 0;\n    }\n\n    array = invlist_array(invlist);\n\n    /* The last element in the array in the inversion list always starts a\n     * range that goes to infinity.  That range may be for code points that are\n     * matched in the inversion list, or it may be for ones that aren't\n     * matched.  In the latter case, the highest code point in the set is one\n     * less than the beginning of this range; otherwise it is the final element\n     * of this range: infinity */\n    return (ELEMENT_RANGE_MATCHES_INVLIST(len - 1))\n           ? UV_MAX\n           : array[len - 1] - 1;\n}\n\nSTATIC SV *\nS_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)\n{\n    /* Get the contents of an inversion list into a string SV so that they can\n     * be printed out.  If 'traditional_style' is TRUE, it uses the format\n     * traditionally done for debug tracing; otherwise it uses a format\n     * suitable for just copying to the output, with blanks between ranges and\n     * a dash between range components */\n\n    UV start, end;\n    SV* output;\n    const char intra_range_delimiter = (traditional_style ? '\\t' : '-');\n    const char inter_range_delimiter = (traditional_style ? '\\n' : ' ');\n\n    if (traditional_style) {\n        output = newSVpvs(\"\\n\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    PERL_ARGS_ASSERT_INVLIST_CONTENTS;\n\n    assert(! invlist_is_iterating(invlist));\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%cINFINITY%c\",\n                                          start, intra_range_delimiter,\n                                                 inter_range_delimiter);\n\t}\n\telse if (end != start) {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c%04\" UVXf \"%c\",\n\t\t                          start,\n                                                   intra_range_delimiter,\n                                                  end, inter_range_delimiter);\n\t}\n\telse {\n\t    Perl_sv_catpvf(aTHX_ output, \"%04\" UVXf \"%c\",\n                                          start, inter_range_delimiter);\n\t}\n    }\n\n    if (SvCUR(output) && ! traditional_style) {/* Get rid of trailing blank */\n        SvCUR_set(output, SvCUR(output) - 1);\n    }\n\n    return output;\n}\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl__invlist_dump(pTHX_ PerlIO *file, I32 level,\n                         const char * const indent, SV* const invlist)\n{\n    /* Designed to be called only by do_sv_dump().  Dumps out the ranges of the\n     * inversion list 'invlist' to 'file' at 'level'  Each line is prefixed by\n     * the string 'indent'.  The output looks like this:\n         [0] 0x000A .. 0x000D\n         [2] 0x0085\n         [4] 0x2028 .. 0x2029\n         [6] 0x3104 .. INFINITY\n     * This means that the first range of code points matched by the list are\n     * 0xA through 0xD; the second range contains only the single code point\n     * 0x85, etc.  An inversion list is an array of UVs.  Two array elements\n     * are used to define each range (except if the final range extends to\n     * infinity, only a single element is needed).  The array index of the\n     * first element for the corresponding range is given in brackets. */\n\n    UV start, end;\n    STRLEN count = 0;\n\n    PERL_ARGS_ASSERT__INVLIST_DUMP;\n\n    if (invlist_is_iterating(invlist)) {\n        Perl_dump_indent(aTHX_ level, file,\n             \"%sCan't dump inversion list because is in middle of iterating\\n\",\n             indent);\n        return;\n    }\n\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                       \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. INFINITY\\n\",\n                                   indent, (UV)count, start);\n\t}\n\telse if (end != start) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                    \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. 0x%04\" UVXf \"\\n\",\n\t\t                indent, (UV)count, start,         end);\n\t}\n\telse {\n\t    Perl_dump_indent(aTHX_ level, file, \"%s[%\" UVuf \"] 0x%04\" UVXf \"\\n\",\n                                            indent, (UV)count, start);\n\t}\n        count += 2;\n    }\n}\n\nvoid\nPerl__load_PL_utf8_foldclosures (pTHX)\n{\n    assert(! PL_utf8_foldclosures);\n\n    /* If the folds haven't been read in, call a fold function\n     * to force that */\n    if (! PL_utf8_tofold) {\n        U8 dummy[UTF8_MAXBYTES_CASE+1];\n        const U8 hyphen[] = HYPHEN_UTF8;\n\n        /* This string is just a short named one above \\xff */\n        toFOLD_utf8_safe(hyphen, hyphen + sizeof(hyphen) - 1, dummy, NULL);\n        assert(PL_utf8_tofold); /* Verify that worked */\n    }\n    PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);\n}\n#endif\n\n#if defined(PERL_ARGS_ASSERT__INVLISTEQ) && !defined(PERL_IN_XSUB_RE)\nbool\nPerl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)\n{\n    /* Return a boolean as to if the two passed in inversion lists are\n     * identical.  The final argument, if TRUE, says to take the complement of\n     * the second inversion list before doing the comparison */\n\n    const UV* array_a = invlist_array(a);\n    const UV* array_b = invlist_array(b);\n    UV len_a = _invlist_len(a);\n    UV len_b = _invlist_len(b);\n\n    PERL_ARGS_ASSERT__INVLISTEQ;\n\n    /* If are to compare 'a' with the complement of b, set it\n     * up so are looking at b's complement. */\n    if (complement_b) {\n\n        /* The complement of nothing is everything, so <a> would have to have\n         * just one element, starting at zero (ending at infinity) */\n        if (len_b == 0) {\n            return (len_a == 1 && array_a[0] == 0);\n        }\n        else if (array_b[0] == 0) {\n\n            /* Otherwise, to complement, we invert.  Here, the first element is\n             * 0, just remove it.  To do this, we just pretend the array starts\n             * one later */\n\n            array_b++;\n            len_b--;\n        }\n        else {\n\n            /* But if the first element is not zero, we pretend the list starts\n             * at the 0 that is always stored immediately before the array. */\n            array_b--;\n            len_b++;\n        }\n    }\n\n    return    len_a == len_b\n           && memEQ(array_a, array_b, len_a * sizeof(array_a[0]));\n\n}\n#endif\n\n/*\n * As best we can, determine the characters that can match the start of\n * the given EXACTF-ish node.\n *\n * Returns the invlist as a new SV*; it is the caller's responsibility to\n * call SvREFCNT_dec() when done with it.\n */\nSTATIC SV*\nS__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)\n{\n    const U8 * s = (U8*)STRING(node);\n    SSize_t bytelen = STR_LEN(node);\n    UV uc;\n    /* Start out big enough for 2 separate code points */\n    SV* invlist = _new_invlist(4);\n\n    PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST;\n\n    if (! UTF) {\n        uc = *s;\n\n        /* We punt and assume can match anything if the node begins\n         * with a multi-character fold.  Things are complicated.  For\n         * example, /ffi/i could match any of:\n         *  \"\\N{LATIN SMALL LIGATURE FFI}\"\n         *  \"\\N{LATIN SMALL LIGATURE FF}I\"\n         *  \"F\\N{LATIN SMALL LIGATURE FI}\"\n         *  plus several other things; and making sure we have all the\n         *  possibilities is hard. */\n        if (is_MULTI_CHAR_FOLD_latin1_safe(s, s + bytelen)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {\n            /* Any Latin1 range character can potentially match any\n             * other depending on the locale */\n            if (OP(node) == EXACTFL) {\n                _invlist_union(invlist, PL_Latin1, &invlist);\n            }\n            else {\n                /* But otherwise, it matches at least itself.  We can\n                 * quickly tell if it has a distinct fold, and if so,\n                 * it matches that as well */\n                invlist = add_cp_to_invlist(invlist, uc);\n                if (IS_IN_SOME_FOLD_L1(uc))\n                    invlist = add_cp_to_invlist(invlist, PL_fold_latin1[uc]);\n            }\n\n            /* Some characters match above-Latin1 ones under /i.  This\n             * is true of EXACTFL ones when the locale is UTF-8 */\n            if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(uc)\n                && (! isASCII(uc) || (OP(node) != EXACTFA\n                                    && OP(node) != EXACTFA_NO_TRIE)))\n            {\n                add_above_Latin1_folds(pRExC_state, (U8) uc, &invlist);\n            }\n        }\n    }\n    else {  /* Pattern is UTF-8 */\n        U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\\0' };\n        STRLEN foldlen = UTF8SKIP(s);\n        const U8* e = s + bytelen;\n        SV** listp;\n\n        uc = utf8_to_uvchr_buf(s, s + bytelen, NULL);\n\n        /* The only code points that aren't folded in a UTF EXACTFish\n         * node are are the problematic ones in EXACTFL nodes */\n        if (OP(node) == EXACTFL && is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(uc)) {\n            /* We need to check for the possibility that this EXACTFL\n             * node begins with a multi-char fold.  Therefore we fold\n             * the first few characters of it so that we can make that\n             * check */\n            U8 *d = folded;\n            int i;\n\n            for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < e; i++) {\n                if (isASCII(*s)) {\n                    *(d++) = (U8) toFOLD(*s);\n                    s++;\n                }\n                else {\n                    STRLEN len;\n                    toFOLD_utf8_safe(s, e, d, &len);\n                    d += len;\n                    s += UTF8SKIP(s);\n                }\n            }\n\n            /* And set up so the code below that looks in this folded\n             * buffer instead of the node's string */\n            e = d;\n            foldlen = UTF8SKIP(folded);\n            s = folded;\n        }\n\n        /* When we reach here 's' points to the fold of the first\n         * character(s) of the node; and 'e' points to far enough along\n         * the folded string to be just past any possible multi-char\n         * fold. 'foldlen' is the length in bytes of the first\n         * character in 's'\n         *\n         * Unlike the non-UTF-8 case, the macro for determining if a\n         * string is a multi-char fold requires all the characters to\n         * already be folded.  This is because of all the complications\n         * if not.  Note that they are folded anyway, except in EXACTFL\n         * nodes.  Like the non-UTF case above, we punt if the node\n         * begins with a multi-char fold  */\n\n        if (is_MULTI_CHAR_FOLD_utf8_safe(s, e)) {\n            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);\n        }\n        else {  /* Single char fold */\n\n            /* It matches all the things that fold to it, which are\n             * found in PL_utf8_foldclosures (including itself) */\n            invlist = add_cp_to_invlist(invlist, uc);\n            if (! PL_utf8_foldclosures)\n                _load_PL_utf8_foldclosures();\n            if ((listp = hv_fetch(PL_utf8_foldclosures,\n                                (char *) s, foldlen, FALSE)))\n            {\n                AV* list = (AV*) *listp;\n                IV k;\n                for (k = 0; k <= av_tindex_skip_len_mg(list); k++) {\n                    SV** c_p = av_fetch(list, k, FALSE);\n                    UV c;\n                    assert(c_p);\n\n                    c = SvUV(*c_p);\n\n                    /* /aa doesn't allow folds between ASCII and non- */\n                    if ((OP(node) == EXACTFA || OP(node) == EXACTFA_NO_TRIE)\n                        && isASCII(c) != isASCII(uc))\n                    {\n                        continue;\n                    }\n\n                    invlist = add_cp_to_invlist(invlist, c);\n                }\n            }\n        }\n    }\n\n    return invlist;\n}\n\n#undef HEADER_LENGTH\n#undef TO_INTERNAL_SIZE\n#undef FROM_INTERNAL_SIZE\n#undef INVLIST_VERSION_ID\n\n/* End of inversion list object */\n\nSTATIC void\nS_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)\n{\n    /* This parses the flags that are in either the '(?foo)' or '(?foo:bar)'\n     * constructs, and updates RExC_flags with them.  On input, RExC_parse\n     * should point to the first flag; it is updated on output to point to the\n     * final ')' or ':'.  There needs to be at least one flag, or this will\n     * abort */\n\n    /* for (?g), (?gc), and (?o) warnings; warning\n       about (?c) will warn about (?g) -- japhy    */\n\n#define WASTED_O  0x01\n#define WASTED_G  0x02\n#define WASTED_C  0x04\n#define WASTED_GC (WASTED_G|WASTED_C)\n    I32 wastedflags = 0x00;\n    U32 posflags = 0, negflags = 0;\n    U32 *flagsp = &posflags;\n    char has_charset_modifier = '\\0';\n    regex_charset cs;\n    bool has_use_defaults = FALSE;\n    const char* const seqstart = RExC_parse - 1; /* Point to the '?' */\n    int x_mod_count = 0;\n\n    PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS;\n\n    /* '^' as an initial flag sets certain defaults */\n    if (UCHARAT(RExC_parse) == '^') {\n        RExC_parse++;\n        has_use_defaults = TRUE;\n        STD_PMMOD_FLAGS_CLEAR(&RExC_flags);\n        set_regex_charset(&RExC_flags, (RExC_utf8 || RExC_uni_semantics)\n                                        ? REGEX_UNICODE_CHARSET\n                                        : REGEX_DEPENDS_CHARSET);\n    }\n\n    cs = get_regex_charset(RExC_flags);\n    if (cs == REGEX_DEPENDS_CHARSET\n        && (RExC_utf8 || RExC_uni_semantics))\n    {\n        cs = REGEX_UNICODE_CHARSET;\n    }\n\n    while (RExC_parse < RExC_end) {\n        /* && strchr(\"iogcmsx\", *RExC_parse) */\n        /* (?g), (?gc) and (?o) are useless here\n           and must be globally applied -- japhy */\n        switch (*RExC_parse) {\n\n            /* Code for the imsxn flags */\n            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp, x_mod_count);\n\n            case LOCALE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_LOCALE_CHARSET;\n                has_charset_modifier = LOCALE_PAT_MOD;\n                break;\n            case UNICODE_PAT_MOD:\n                if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                cs = REGEX_UNICODE_CHARSET;\n                has_charset_modifier = UNICODE_PAT_MOD;\n                break;\n            case ASCII_RESTRICT_PAT_MOD:\n                if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                if (has_charset_modifier) {\n                    if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {\n                        goto excess_modifier;\n                    }\n                    /* Doubled modifier implies more restricted */\n                    cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;\n                }\n                else {\n                    cs = REGEX_ASCII_RESTRICTED_CHARSET;\n                }\n                has_charset_modifier = ASCII_RESTRICT_PAT_MOD;\n                break;\n            case DEPENDS_PAT_MOD:\n                if (has_use_defaults) {\n                    goto fail_modifiers;\n                }\n                else if (flagsp == &negflags) {\n                    goto neg_modifier;\n                }\n                else if (has_charset_modifier) {\n                    goto excess_modifier;\n                }\n\n                /* The dual charset means unicode semantics if the\n                 * pattern (or target, not known until runtime) are\n                 * utf8, or something in the pattern indicates unicode\n                 * semantics */\n                cs = (RExC_utf8 || RExC_uni_semantics)\n                     ? REGEX_UNICODE_CHARSET\n                     : REGEX_DEPENDS_CHARSET;\n                has_charset_modifier = DEPENDS_PAT_MOD;\n                break;\n              excess_modifier:\n                RExC_parse++;\n                if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may appear a maximum of twice\", ASCII_RESTRICT_PAT_MOD);\n                }\n                else if (has_charset_modifier == *(RExC_parse - 1)) {\n                    vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear twice\",\n                                        *(RExC_parse - 1));\n                }\n                else {\n                    vFAIL3(\"Regexp modifiers \\\"%c\\\" and \\\"%c\\\" are mutually exclusive\", has_charset_modifier, *(RExC_parse - 1));\n                }\n                NOT_REACHED; /*NOTREACHED*/\n              neg_modifier:\n                RExC_parse++;\n                vFAIL2(\"Regexp modifier \\\"%c\\\" may not appear after the \\\"-\\\"\",\n                                    *(RExC_parse - 1));\n                NOT_REACHED; /*NOTREACHED*/\n            case ONCE_PAT_MOD: /* 'o' */\n            case GLOBAL_PAT_MOD: /* 'g' */\n                if (PASS2 && ckWARN(WARN_REGEXP)) {\n                    const I32 wflagbit = *RExC_parse == 'o'\n                                         ? WASTED_O\n                                         : WASTED_G;\n                    if (! (wastedflags & wflagbit) ) {\n                        wastedflags |= wflagbit;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN5(\n                            RExC_parse + 1,\n                            \"Useless (%s%c) - %suse /%c modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            *RExC_parse,\n                            flagsp == &negflags ? \"don't \" : \"\",\n                            *RExC_parse\n                        );\n                    }\n                }\n                break;\n\n            case CONTINUE_PAT_MOD: /* 'c' */\n                if (PASS2 && ckWARN(WARN_REGEXP)) {\n                    if (! (wastedflags & WASTED_C) ) {\n                        wastedflags |= WASTED_GC;\n\t\t\t/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */\n                        vWARN3(\n                            RExC_parse + 1,\n                            \"Useless (%sc) - %suse /gc modifier\",\n                            flagsp == &negflags ? \"?-\" : \"?\",\n                            flagsp == &negflags ? \"don't \" : \"\"\n                        );\n                    }\n                }\n                break;\n            case KEEPCOPY_PAT_MOD: /* 'p' */\n                if (flagsp == &negflags) {\n                    if (PASS2)\n                        ckWARNreg(RExC_parse + 1,\"Useless use of (?-p)\");\n                } else {\n                    *flagsp |= RXf_PMf_KEEPCOPY;\n                }\n                break;\n            case '-':\n                /* A flag is a default iff it is following a minus, so\n                 * if there is a minus, it means will be trying to\n                 * re-specify a default which is an error */\n                if (has_use_defaults || flagsp == &negflags) {\n                    goto fail_modifiers;\n                }\n                flagsp = &negflags;\n                wastedflags = 0;  /* reset so (?g-c) warns twice */\n                x_mod_count = 0;\n                break;\n            case ':':\n            case ')':\n\n                if ((posflags & (RXf_PMf_EXTENDED|RXf_PMf_EXTENDED_MORE)) == RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags |= posflags;\n\n                if (negflags & RXf_PMf_EXTENDED) {\n                    negflags |= RXf_PMf_EXTENDED_MORE;\n                }\n                RExC_flags &= ~negflags;\n                set_regex_charset(&RExC_flags, cs);\n\n                return;\n            default:\n              fail_modifiers:\n                RExC_parse += SKIP_IF_CHAR(RExC_parse);\n\t\t/* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                vFAIL2utf8f(\"Sequence (%\" UTF8f \"...) not recognized\",\n                      UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n                NOT_REACHED; /*NOTREACHED*/\n        }\n\n        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n    }\n\n    vFAIL(\"Sequence (?... not terminated\");\n}\n\n/*\n - reg - regular expression, i.e. main body or parenthesized thing\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\n#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)\n#ifdef DEBUGGING\n#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)\n#else\n#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)\n#endif\n\nPERL_STATIC_INLINE regnode *\nS_handle_named_backref(pTHX_ RExC_state_t *pRExC_state,\n                             I32 *flagp,\n                             char * parse_start,\n                             char ch\n                      )\n{\n    regnode *ret;\n    char* name_start = RExC_parse;\n    U32 num = 0;\n    SV *sv_dat = reg_scan_name(pRExC_state, SIZE_ONLY\n                                            ? REG_RSN_RETURN_NULL\n                                            : REG_RSN_RETURN_DATA);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF;\n\n    if (RExC_parse == name_start || *RExC_parse != ch) {\n        /* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n        vFAIL2(\"Sequence %.3s... not terminated\",parse_start);\n    }\n\n    if (!SIZE_ONLY) {\n        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n        RExC_rxi->data->data[num]=(void*)sv_dat;\n        SvREFCNT_inc_simple_void(sv_dat);\n    }\n    RExC_sawback = 1;\n    ret = reganode(pRExC_state,\n                   ((! FOLD)\n                     ? NREF\n                     : (ASCII_FOLD_RESTRICTED)\n                       ? NREFFA\n                       : (AT_LEAST_UNI_SEMANTICS)\n                         ? NREFFU\n                         : (LOC)\n                           ? NREFFL\n                           : NREFF),\n                    num);\n    *flagp |= HASWIDTH;\n\n    Set_Node_Offset(ret, parse_start+1);\n    Set_Node_Cur_Length(ret, parse_start);\n\n    nextchar(pRExC_state);\n    return ret;\n}\n\n/* Returns NULL, setting *flagp to TRYAGAIN at the end of (?) that only sets\n   flags. Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan\n   needs to be restarted, or'd with NEED_UTF8 if the pattern needs to be\n   upgraded to UTF-8.  Otherwise would only return NULL if regbranch() returns\n   NULL, which cannot happen.  */\nSTATIC regnode *\nS_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp,U32 depth)\n    /* paren: Parenthesized? 0=top; 1,2=inside '(': changed to letter.\n     * 2 is like 1, but indicates that nextchar() has been called to advance\n     * RExC_parse beyond the '('.  Things like '(?' are indivisible tokens, and\n     * this flag alerts us to the need to check for that */\n{\n    regnode *ret;\t\t/* Will be the head of the group. */\n    regnode *br;\n    regnode *lastbr;\n    regnode *ender = NULL;\n    I32 parno = 0;\n    I32 flags;\n    U32 oregflags = RExC_flags;\n    bool have_branch = 0;\n    bool is_open = 0;\n    I32 freeze_paren = 0;\n    I32 after_freeze = 0;\n    I32 num; /* numeric backreferences */\n\n    char * parse_start = RExC_parse; /* MJD */\n    char * const oregcomp_parse = RExC_parse;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REG;\n    DEBUG_PARSE(\"reg \");\n\n    *flagp = 0;\t\t\t\t/* Tentatively. */\n\n    /* Having this true makes it feasible to have a lot fewer tests for the\n     * parse pointer being in scope.  For example, we can write\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     * instead of\n     *      while(RExC_parse < RExC_end && isFOO(*RExC_parse)) RExC_parse++;\n     */\n    assert(*RExC_end == '\\0');\n\n    /* Make an OPEN node, if parenthesized. */\n    if (paren) {\n\n        /* Under /x, space and comments can be gobbled up between the '(' and\n         * here (if paren ==2).  The forms '(*VERB' and '(?...' disallow such\n         * intervening space, as the sequence is a token, and a token should be\n         * indivisible */\n        bool has_intervening_patws = paren == 2 && *(RExC_parse - 1) != '(';\n\n        if (RExC_parse >= RExC_end) {\n\t    vFAIL(\"Unmatched (\");\n        }\n\n        if ( *RExC_parse == '*') { /* (*VERB:ARG) */\n\t    char *start_verb = RExC_parse + 1;\n\t    STRLEN verb_len;\n\t    char *start_arg = NULL;\n\t    unsigned char op = 0;\n            int arg_required = 0;\n            int internal_argval = -1; /* if >-1 we are not allowed an argument*/\n\n            if (has_intervening_patws) {\n                RExC_parse++;   /* past the '*' */\n                vFAIL(\"In '(*VERB...)', the '(' and '*' must be adjacent\");\n            }\n\t    while (RExC_parse < RExC_end && *RExC_parse != ')' ) {\n\t        if ( *RExC_parse == ':' ) {\n\t            start_arg = RExC_parse + 1;\n\t            break;\n\t        }\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t    }\n\t    verb_len = RExC_parse - start_verb;\n\t    if ( start_arg ) {\n                if (RExC_parse >= RExC_end) {\n                    goto unterminated_verb_pattern;\n                }\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t        while ( RExC_parse < RExC_end && *RExC_parse != ')' )\n                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )\n                  unterminated_verb_pattern:\n\t            vFAIL(\"Unterminated verb pattern argument\");\n\t        if ( RExC_parse == start_arg )\n\t            start_arg = NULL;\n\t    } else {\n\t        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )\n\t            vFAIL(\"Unterminated verb pattern\");\n\t    }\n\n            /* Here, we know that RExC_parse < RExC_end */\n\n\t    switch ( *start_verb ) {\n            case 'A':  /* (*ACCEPT) */\n                if ( memEQs(start_verb,verb_len,\"ACCEPT\") ) {\n\t\t    op = ACCEPT;\n\t\t    internal_argval = RExC_nestroot;\n\t\t}\n\t\tbreak;\n            case 'C':  /* (*COMMIT) */\n                if ( memEQs(start_verb,verb_len,\"COMMIT\") )\n                    op = COMMIT;\n                break;\n            case 'F':  /* (*FAIL) */\n                if ( verb_len==1 || memEQs(start_verb,verb_len,\"FAIL\") ) {\n\t\t    op = OPFAIL;\n\t\t}\n\t\tbreak;\n            case ':':  /* (*:NAME) */\n\t    case 'M':  /* (*MARK:NAME) */\n\t        if ( verb_len==0 || memEQs(start_verb,verb_len,\"MARK\") ) {\n                    op = MARKPOINT;\n                    arg_required = 1;\n                }\n                break;\n            case 'P':  /* (*PRUNE) */\n                if ( memEQs(start_verb,verb_len,\"PRUNE\") )\n                    op = PRUNE;\n                break;\n            case 'S':   /* (*SKIP) */\n                if ( memEQs(start_verb,verb_len,\"SKIP\") )\n                    op = SKIP;\n                break;\n            case 'T':  /* (*THEN) */\n                /* [19:06] <TimToady> :: is then */\n                if ( memEQs(start_verb,verb_len,\"THEN\") ) {\n                    op = CUTGROUP;\n                    RExC_seen |= REG_CUTGROUP_SEEN;\n                }\n                break;\n\t    }\n\t    if ( ! op ) {\n\t        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                vFAIL2utf8f(\n                    \"Unknown verb pattern '%\" UTF8f \"'\",\n                    UTF8fARG(UTF, verb_len, start_verb));\n\t    }\n            if ( arg_required && !start_arg ) {\n                vFAIL3(\"Verb pattern '%.*s' has a mandatory argument\",\n                    verb_len, start_verb);\n            }\n            if (internal_argval == -1) {\n                ret = reganode(pRExC_state, op, 0);\n            } else {\n                ret = reg2Lanode(pRExC_state, op, 0, internal_argval);\n            }\n            RExC_seen |= REG_VERBARG_SEEN;\n            if ( ! SIZE_ONLY ) {\n                if (start_arg) {\n                    SV *sv = newSVpvn( start_arg,\n                                       RExC_parse - start_arg);\n                    ARG(ret) = add_data( pRExC_state,\n                                         STR_WITH_LEN(\"S\"));\n                    RExC_rxi->data->data[ARG(ret)]=(void*)sv;\n                    ret->flags = 1;\n                } else {\n                    ret->flags = 0;\n                }\n                if ( internal_argval != -1 )\n                    ARG2L_SET(ret, internal_argval);\n            }\n\t    nextchar(pRExC_state);\n\t    return ret;\n        }\n        else if (*RExC_parse == '?') { /* (?...) */\n\t    bool is_logical = 0;\n\t    const char * const seqstart = RExC_parse;\n            const char * endptr;\n            if (has_intervening_patws) {\n                RExC_parse++;\n                vFAIL(\"In '(?...)', the '(' and '?' must be adjacent\");\n            }\n\n\t    RExC_parse++;           /* past the '?' */\n            paren = *RExC_parse;    /* might be a trailing NUL, if not\n                                       well-formed */\n            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n            if (RExC_parse > RExC_end) {\n                paren = '\\0';\n            }\n\t    ret = NULL;\t\t\t/* For look-ahead/behind. */\n\t    switch (paren) {\n\n\t    case 'P':\t/* (?P...) variants for those used to PCRE/Python */\n\t        paren = *RExC_parse;\n\t\tif ( paren == '<') {    /* (?P<...>) named capture */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P<... not terminated\");\n                    }\n\t\t    goto named_capture;\n                }\n                else if (paren == '>') {   /* (?P>name) named recursion */\n                    RExC_parse++;\n                    if (RExC_parse >= RExC_end) {\n                        vFAIL(\"Sequence (?P>... not terminated\");\n                    }\n                    goto named_recursion;\n                }\n                else if (paren == '=') {   /* (?P=...)  named backref */\n                    RExC_parse++;\n                    return handle_named_backref(pRExC_state, flagp,\n                                                parse_start, ')');\n                }\n                RExC_parse += SKIP_IF_CHAR(RExC_parse);\n                /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n\t\tvFAIL3(\"Sequence (%.*s...) not recognized\",\n                                RExC_parse-seqstart, seqstart);\n\t\tNOT_REACHED; /*NOTREACHED*/\n            case '<':           /* (?<...) */\n\t\tif (*RExC_parse == '!')\n\t\t    paren = ',';\n\t\telse if (*RExC_parse != '=')\n              named_capture:\n\t\t{               /* (?<...>) */\n\t\t    char *name_start;\n\t\t    SV *svname;\n\t\t    paren= '>';\n                /* FALLTHROUGH */\n            case '\\'':          /* (?'...') */\n                    name_start = RExC_parse;\n                    svname = reg_scan_name(pRExC_state,\n                        SIZE_ONLY    /* reverse test from the others */\n                        ? REG_RSN_RETURN_NAME\n                        : REG_RSN_RETURN_NULL);\n\t\t    if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != paren)\n                    {\n\t\t        vFAIL2(\"Sequence (?%c... not terminated\",\n\t\t            paren=='>' ? '<' : paren);\n                    }\n\t\t    if (SIZE_ONLY) {\n\t\t\tHE *he_str;\n\t\t\tSV *sv_dat = NULL;\n                        if (!svname) /* shouldn't happen */\n                            Perl_croak(aTHX_\n                                \"panic: reg_scan_name returned NULL\");\n                        if (!RExC_paren_names) {\n                            RExC_paren_names= newHV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_names));\n#ifdef DEBUGGING\n                            RExC_paren_name_list= newAV();\n                            sv_2mortal(MUTABLE_SV(RExC_paren_name_list));\n#endif\n                        }\n                        he_str = hv_fetch_ent( RExC_paren_names, svname, 1, 0 );\n                        if ( he_str )\n                            sv_dat = HeVAL(he_str);\n                        if ( ! sv_dat ) {\n                            /* croak baby croak */\n                            Perl_croak(aTHX_\n                                \"panic: paren_name hash element allocation failed\");\n                        } else if ( SvPOK(sv_dat) ) {\n                            /* (?|...) can mean we have dupes so scan to check\n                               its already been stored. Maybe a flag indicating\n                               we are inside such a construct would be useful,\n                               but the arrays are likely to be quite small, so\n                               for now we punt -- dmq */\n                            IV count = SvIV(sv_dat);\n                            I32 *pv = (I32*)SvPVX(sv_dat);\n                            IV i;\n                            for ( i = 0 ; i < count ; i++ ) {\n                                if ( pv[i] == RExC_npar ) {\n                                    count = 0;\n                                    break;\n                                }\n                            }\n                            if ( count ) {\n                                pv = (I32*)SvGROW(sv_dat,\n                                                SvCUR(sv_dat) + sizeof(I32)+1);\n                                SvCUR_set(sv_dat, SvCUR(sv_dat) + sizeof(I32));\n                                pv[count] = RExC_npar;\n                                SvIV_set(sv_dat, SvIVX(sv_dat) + 1);\n                            }\n                        } else {\n                            (void)SvUPGRADE(sv_dat,SVt_PVNV);\n                            sv_setpvn(sv_dat, (char *)&(RExC_npar),\n                                                                sizeof(I32));\n                            SvIOK_on(sv_dat);\n                            SvIV_set(sv_dat, 1);\n                        }\n#ifdef DEBUGGING\n                        /* Yes this does cause a memory leak in debugging Perls\n                         * */\n                        if (!av_store(RExC_paren_name_list,\n                                      RExC_npar, SvREFCNT_inc(svname)))\n                            SvREFCNT_dec_NN(svname);\n#endif\n\n                        /*sv_dump(sv_dat);*/\n                    }\n                    nextchar(pRExC_state);\n\t\t    paren = 1;\n\t\t    goto capturing_parens;\n\t\t}\n                RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t\tRExC_in_lookbehind++;\n\t\tRExC_parse++;\n                if (RExC_parse >= RExC_end) {\n                    vFAIL(\"Sequence (?... not terminated\");\n                }\n\n                /* FALLTHROUGH */\n\t    case '=':           /* (?=...) */\n\t\tRExC_seen_zerolen++;\n                break;\n\t    case '!':           /* (?!...) */\n\t\tRExC_seen_zerolen++;\n\t\t/* check if we're really just a \"FAIL\" assertion */\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t        if (*RExC_parse == ')') {\n                    ret=reganode(pRExC_state, OPFAIL, 0);\n\t            nextchar(pRExC_state);\n\t            return ret;\n\t        }\n\t        break;\n\t    case '|':           /* (?|...) */\n\t        /* branch reset, behave like a (?:...) except that\n\t           buffers in alternations share the same numbers */\n\t        paren = ':';\n\t        after_freeze = freeze_paren = RExC_npar;\n\t        break;\n\t    case ':':           /* (?:...) */\n\t    case '>':           /* (?>...) */\n\t\tbreak;\n\t    case '$':           /* (?$...) */\n\t    case '@':           /* (?@...) */\n\t\tvFAIL2(\"Sequence (?%c...) not implemented\", (int)paren);\n\t\tbreak;\n\t    case '0' :           /* (?0) */\n\t    case 'R' :           /* (?R) */\n                if (RExC_parse == RExC_end || *RExC_parse != ')')\n\t\t    FAIL(\"Sequence (?R) not terminated\");\n                num = 0;\n                RExC_seen |= REG_RECURSE_SEEN;\n\t\t*flagp |= POSTPONED;\n                goto gen_recurse_regop;\n\t\t/*notreached*/\n            /* named and numeric backreferences */\n            case '&':            /* (?&NAME) */\n                parse_start = RExC_parse - 1;\n              named_recursion:\n                {\n    \t\t    SV *sv_dat = reg_scan_name(pRExC_state,\n    \t\t        SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);\n    \t\t     num = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;\n                }\n                if (RExC_parse >= RExC_end || *RExC_parse != ')')\n                    vFAIL(\"Sequence (?&... not terminated\");\n                goto gen_recurse_regop;\n                /* NOTREACHED */\n            case '+':\n                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {\n                    RExC_parse++;\n                    vFAIL(\"Illegal pattern\");\n                }\n                goto parse_recursion;\n                /* NOTREACHED*/\n            case '-': /* (?-1) */\n                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {\n                    RExC_parse--; /* rewind to let it be handled later */\n                    goto parse_flags;\n                }\n                /* FALLTHROUGH */\n            case '1': case '2': case '3': case '4': /* (?1) */\n\t    case '5': case '6': case '7': case '8': case '9':\n\t        RExC_parse = (char *) seqstart + 1;  /* Point to the digit */\n              parse_recursion:\n                {\n                    bool is_neg = FALSE;\n                    UV unum;\n                    parse_start = RExC_parse - 1; /* MJD */\n                    if (*RExC_parse == '-') {\n                        RExC_parse++;\n                        is_neg = TRUE;\n                    }\n                    if (grok_atoUV(RExC_parse, &unum, &endptr)\n                        && unum <= I32_MAX\n                    ) {\n                        num = (I32)unum;\n                        RExC_parse = (char*)endptr;\n                    } else\n                        num = I32_MAX;\n                    if (is_neg) {\n                        /* Some limit for num? */\n                        num = -num;\n                    }\n                }\n\t        if (*RExC_parse!=')')\n\t            vFAIL(\"Expecting close bracket\");\n\n              gen_recurse_regop:\n                if ( paren == '-' ) {\n                    /*\n                    Diagram of capture buffer numbering.\n                    Top line is the normal capture buffer numbers\n                    Bottom line is the negative indexing as from\n                    the X (the (?-2))\n\n                    +   1 2    3 4 5 X          6 7\n                       /(a(x)y)(a(b(c(?-2)d)e)f)(g(h))/\n                    -   5 4    3 2 1 X          x x\n\n                    */\n                    num = RExC_npar + num;\n                    if (num < 1)  {\n                        RExC_parse++;\n                        vFAIL(\"Reference to nonexistent group\");\n                    }\n                } else if ( paren == '+' ) {\n                    num = RExC_npar + num - 1;\n                }\n                /* We keep track how many GOSUB items we have produced.\n                   To start off the ARG2L() of the GOSUB holds its \"id\",\n                   which is used later in conjunction with RExC_recurse\n                   to calculate the offset we need to jump for the GOSUB,\n                   which it will store in the final representation.\n                   We have to defer the actual calculation until much later\n                   as the regop may move.\n                 */\n\n                ret = reg2Lanode(pRExC_state, GOSUB, num, RExC_recurse_count);\n                if (!SIZE_ONLY) {\n\t\t    if (num > (I32)RExC_rx->nparens) {\n\t\t\tRExC_parse++;\n\t\t\tvFAIL(\"Reference to nonexistent group\");\n\t            }\n\t            RExC_recurse_count++;\n                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Recurse #%\" UVuf \" to %\" IVdf \"\\n\",\n                              22, \"|    |\", (int)(depth * 2 + 1), \"\",\n                              (UV)ARG(ret), (IV)ARG2L(ret)));\n                }\n                RExC_seen |= REG_RECURSE_SEEN;\n\n                Set_Node_Length(ret, 1 + regarglen[OP(ret)]); /* MJD */\n\t\tSet_Node_Offset(ret, parse_start); /* MJD */\n\n                *flagp |= POSTPONED;\n                assert(*RExC_parse == ')');\n                nextchar(pRExC_state);\n                return ret;\n\n            /* NOTREACHED */\n\n\t    case '?':           /* (??...) */\n\t\tis_logical = 1;\n\t\tif (*RExC_parse != '{') {\n                    RExC_parse += SKIP_IF_CHAR(RExC_parse);\n                    /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */\n                    vFAIL2utf8f(\n                        \"Sequence (%\" UTF8f \"...) not recognized\",\n                        UTF8fARG(UTF, RExC_parse-seqstart, seqstart));\n\t\t    NOT_REACHED; /*NOTREACHED*/\n\t\t}\n\t\t*flagp |= POSTPONED;\n\t\tparen = '{';\n                RExC_parse++;\n\t\t/* FALLTHROUGH */\n\t    case '{':           /* (?{...}) */\n\t    {\n\t\tU32 n = 0;\n\t\tstruct reg_code_block *cb;\n\n\t\tRExC_seen_zerolen++;\n\n\t\tif (   !pRExC_state->code_blocks\n\t\t    || pRExC_state->code_index\n                                        >= pRExC_state->code_blocks->count\n\t\t    || pRExC_state->code_blocks->cb[pRExC_state->code_index].start\n\t\t\t!= (STRLEN)((RExC_parse -3 - (is_logical ? 1 : 0))\n\t\t\t    - RExC_start)\n\t\t) {\n\t\t    if (RExC_pm_flags & PMf_USE_RE_EVAL)\n\t\t\tFAIL(\"panic: Sequence (?{...}): no code block found\\n\");\n\t\t    FAIL(\"Eval-group not allowed at runtime, use re 'eval'\");\n\t\t}\n\t\t/* this is a pre-compiled code block (?{...}) */\n\t\tcb = &pRExC_state->code_blocks->cb[pRExC_state->code_index];\n\t\tRExC_parse = RExC_start + cb->end;\n\t\tif (!SIZE_ONLY) {\n\t\t    OP *o = cb->block;\n\t\t    if (cb->src_regex) {\n\t\t\tn = add_data(pRExC_state, STR_WITH_LEN(\"rl\"));\n\t\t\tRExC_rxi->data->data[n] =\n\t\t\t    (void*)SvREFCNT_inc((SV*)cb->src_regex);\n\t\t\tRExC_rxi->data->data[n+1] = (void*)o;\n\t\t    }\n\t\t    else {\n\t\t\tn = add_data(pRExC_state,\n\t\t\t       (RExC_pm_flags & PMf_HAS_CV) ? \"L\" : \"l\", 1);\n\t\t\tRExC_rxi->data->data[n] = (void*)o;\n\t\t    }\n\t\t}\n\t\tpRExC_state->code_index++;\n\t\tnextchar(pRExC_state);\n\n\t\tif (is_logical) {\n                    regnode *eval;\n\t\t    ret = reg_node(pRExC_state, LOGICAL);\n\n                    eval = reg2Lanode(pRExC_state, EVAL,\n                                       n,\n\n                                       /* for later propagation into (??{})\n                                        * return value */\n                                       RExC_flags & RXf_PMf_COMPILETIME\n                                      );\n\t\t    if (!SIZE_ONLY) {\n\t\t\tret->flags = 2;\n                    }\n                    REGTAIL(pRExC_state, ret, eval);\n                    /* deal with the length of this later - MJD */\n\t\t    return ret;\n\t\t}\n\t\tret = reg2Lanode(pRExC_state, EVAL, n, 0);\n\t\tSet_Node_Length(ret, RExC_parse - parse_start + 1);\n\t\tSet_Node_Offset(ret, parse_start);\n\t\treturn ret;\n\t    }\n\t    case '(':           /* (?(?{...})...) and (?(?=...)...) */\n\t    {\n\t        int is_define= 0;\n                const int DEFINE_len = sizeof(\"DEFINE\") - 1;\n\t\tif (RExC_parse[0] == '?') {        /* (?(?...)) */\n                    if (   RExC_parse < RExC_end - 1\n                        && (   RExC_parse[1] == '='\n                            || RExC_parse[1] == '!'\n                            || RExC_parse[1] == '<'\n                            || RExC_parse[1] == '{')\n                    ) { /* Lookahead or eval. */\n\t\t\tI32 flag;\n                        regnode *tail;\n\n\t\t\tret = reg_node(pRExC_state, LOGICAL);\n\t\t\tif (!SIZE_ONLY)\n\t\t\t    ret->flags = 1;\n\n                        tail = reg(pRExC_state, 1, &flag, depth+1);\n                        if (flag & (RESTART_PASS1|NEED_UTF8)) {\n                            *flagp = flag & (RESTART_PASS1|NEED_UTF8);\n                            return NULL;\n                        }\n                        REGTAIL(pRExC_state, ret, tail);\n\t\t\tgoto insert_if;\n\t\t    }\n\t\t    /* Fall through to \u2018Unknown switch condition\u2019 at the\n\t\t       end of the if/else chain. */\n\t\t}\n\t\telse if ( RExC_parse[0] == '<'     /* (?(<NAME>)...) */\n\t\t         || RExC_parse[0] == '\\'' ) /* (?('NAME')...) */\n\t        {\n\t            char ch = RExC_parse[0] == '<' ? '>' : '\\'';\n\t            char *name_start= RExC_parse++;\n\t            U32 num = 0;\n\t            SV *sv_dat=reg_scan_name(pRExC_state,\n\t                SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);\n\t            if (   RExC_parse == name_start\n                        || RExC_parse >= RExC_end\n                        || *RExC_parse != ch)\n                    {\n                        vFAIL2(\"Sequence (?(%c... not terminated\",\n                            (ch == '>' ? '<' : ch));\n                    }\n                    RExC_parse++;\n\t            if (!SIZE_ONLY) {\n                        num = add_data( pRExC_state, STR_WITH_LEN(\"S\"));\n                        RExC_rxi->data->data[num]=(void*)sv_dat;\n                        SvREFCNT_inc_simple_void(sv_dat);\n                    }\n                    ret = reganode(pRExC_state,NGROUPP,num);\n                    goto insert_if_check_paren;\n\t\t}\n\t\telse if (memBEGINs(RExC_parse,\n                                   (STRLEN) (RExC_end - RExC_parse),\n                                   \"DEFINE\"))\n                {\n\t\t    ret = reganode(pRExC_state,DEFINEP,0);\n\t\t    RExC_parse += DEFINE_len;\n\t\t    is_define = 1;\n\t\t    goto insert_if_check_paren;\n\t\t}\n\t\telse if (RExC_parse[0] == 'R') {\n\t\t    RExC_parse++;\n                    /* parno == 0 => /(?(R)YES|NO)/  \"in any form of recursion OR eval\"\n                     * parno == 1 => /(?(R0)YES|NO)/ \"in GOSUB (?0) / (?R)\"\n                     * parno == 2 => /(?(R1)YES|NO)/ \"in GOSUB (?1) (parno-1)\"\n                     */\n\t\t    parno = 0;\n                    if (RExC_parse[0] == '0') {\n                        parno = 1;\n                        RExC_parse++;\n                    }\n                    else if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {\n                        UV uv;\n                        if (grok_atoUV(RExC_parse, &uv, &endptr)\n                            && uv <= I32_MAX\n                        ) {\n                            parno = (I32)uv + 1;\n                            RExC_parse = (char*)endptr;\n                        }\n                        /* else \"Switch condition not recognized\" below */\n\t\t    } else if (RExC_parse[0] == '&') {\n\t\t        SV *sv_dat;\n\t\t        RExC_parse++;\n\t\t        sv_dat = reg_scan_name(pRExC_state,\n                            SIZE_ONLY\n                            ? REG_RSN_RETURN_NULL\n                            : REG_RSN_RETURN_DATA);\n\n                        /* we should only have a false sv_dat when\n                         * SIZE_ONLY is true, and we always have false\n                         * sv_dat when SIZE_ONLY is true.\n                         * reg_scan_name() will VFAIL() if the name is\n                         * unknown when SIZE_ONLY is false, and otherwise\n                         * will return something, and when SIZE_ONLY is\n                         * true, reg_scan_name() just parses the string,\n                         * and doesnt return anything. (in theory) */\n                        assert(SIZE_ONLY ? !sv_dat : !!sv_dat);\n\n                        if (sv_dat)\n                            parno = 1 + *((I32 *)SvPVX(sv_dat));\n\t\t    }\n\t\t    ret = reganode(pRExC_state,INSUBP,parno);\n\t\t    goto insert_if_check_paren;\n\t\t}\n\t\telse if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {\n                    /* (?(1)...) */\n\t\t    char c;\n                    UV uv;\n                    if (grok_atoUV(RExC_parse, &uv, &endptr)\n                        && uv <= I32_MAX\n                    ) {\n                        parno = (I32)uv;\n                        RExC_parse = (char*)endptr;\n                    }\n                    else {\n                        vFAIL(\"panic: grok_atoUV returned FALSE\");\n                    }\n                    ret = reganode(pRExC_state, GROUPP, parno);\n\n                 insert_if_check_paren:\n\t\t    if (UCHARAT(RExC_parse) != ')') {\n                        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n\t\t\tvFAIL(\"Switch condition not recognized\");\n\t\t    }\n\t\t    nextchar(pRExC_state);\n\t\t  insert_if:\n                    REGTAIL(pRExC_state, ret, reganode(pRExC_state, IFTHEN, 0));\n                    br = regbranch(pRExC_state, &flags, 1,depth+1);\n\t\t    if (br == NULL) {\n                        if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                            *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                            return NULL;\n                        }\n                        FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf,\n                              (UV) flags);\n                    } else\n                        REGTAIL(pRExC_state, br, reganode(pRExC_state,\n                                                          LONGJMP, 0));\n\t\t    c = UCHARAT(RExC_parse);\n                    nextchar(pRExC_state);\n\t\t    if (flags&HASWIDTH)\n\t\t\t*flagp |= HASWIDTH;\n\t\t    if (c == '|') {\n\t\t        if (is_define)\n\t\t            vFAIL(\"(?(DEFINE)....) does not allow branches\");\n\n                        /* Fake one for optimizer.  */\n                        lastbr = reganode(pRExC_state, IFTHEN, 0);\n\n                        if (!regbranch(pRExC_state, &flags, 1,depth+1)) {\n                            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                                return NULL;\n                            }\n                            FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf,\n                                  (UV) flags);\n                        }\n                        REGTAIL(pRExC_state, ret, lastbr);\n\t\t \tif (flags&HASWIDTH)\n\t\t\t    *flagp |= HASWIDTH;\n                        c = UCHARAT(RExC_parse);\n                        nextchar(pRExC_state);\n\t\t    }\n\t\t    else\n\t\t\tlastbr = NULL;\n                    if (c != ')') {\n                        if (RExC_parse >= RExC_end)\n                            vFAIL(\"Switch (?(condition)... not terminated\");\n                        else\n                            vFAIL(\"Switch (?(condition)... contains too many branches\");\n                    }\n\t\t    ender = reg_node(pRExC_state, TAIL);\n                    REGTAIL(pRExC_state, br, ender);\n\t\t    if (lastbr) {\n                        REGTAIL(pRExC_state, lastbr, ender);\n                        REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);\n\t\t    }\n\t\t    else\n                        REGTAIL(pRExC_state, ret, ender);\n                    RExC_size++; /* XXX WHY do we need this?!!\n                                    For large programs it seems to be required\n                                    but I can't figure out why. -- dmq*/\n\t\t    return ret;\n\t\t}\n                RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                vFAIL(\"Unknown switch condition (?(...))\");\n\t    }\n\t    case '[':           /* (?[ ... ]) */\n                return handle_regex_sets(pRExC_state, NULL, flagp, depth+1,\n                                         oregcomp_parse);\n            case 0: /* A NUL */\n\t\tRExC_parse--; /* for vFAIL to print correctly */\n                vFAIL(\"Sequence (? incomplete\");\n                break;\n\t    default: /* e.g., (?i) */\n\t        RExC_parse = (char *) seqstart + 1;\n              parse_flags:\n\t\tparse_lparen_question_flags(pRExC_state);\n                if (UCHARAT(RExC_parse) != ':') {\n                    if (RExC_parse < RExC_end)\n                        nextchar(pRExC_state);\n                    *flagp = TRYAGAIN;\n                    return NULL;\n                }\n                paren = ':';\n                nextchar(pRExC_state);\n                ret = NULL;\n                goto parse_rest;\n            } /* end switch */\n\t}\n\telse if (!(RExC_flags & RXf_PMf_NOCAPTURE)) {   /* (...) */\n\t  capturing_parens:\n\t    parno = RExC_npar;\n\t    RExC_npar++;\n\n\t    ret = reganode(pRExC_state, OPEN, parno);\n\t    if (!SIZE_ONLY ){\n\t        if (!RExC_nestroot)\n\t            RExC_nestroot = parno;\n                if (RExC_open_parens && !RExC_open_parens[parno])\n\t        {\n                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting open paren #%\" IVdf \" to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\",\n\t\t\t(IV)parno, REG_NODE_NUM(ret)));\n                    RExC_open_parens[parno]= ret;\n\t        }\n\t    }\n            Set_Node_Length(ret, 1); /* MJD */\n            Set_Node_Offset(ret, RExC_parse); /* MJD */\n\t    is_open = 1;\n\t} else {\n            /* with RXf_PMf_NOCAPTURE treat (...) as (?:...) */\n            paren = ':';\n\t    ret = NULL;\n\t}\n    }\n    else                        /* ! paren */\n\tret = NULL;\n\n   parse_rest:\n    /* Pick up the branches, linking them together. */\n    parse_start = RExC_parse;   /* MJD */\n    br = regbranch(pRExC_state, &flags, 1,depth+1);\n\n    /*     branch_len = (paren != 0); */\n\n    if (br == NULL) {\n        if (flags & (RESTART_PASS1|NEED_UTF8)) {\n            *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n            return NULL;\n        }\n        FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf, (UV) flags);\n    }\n    if (*RExC_parse == '|') {\n\tif (!SIZE_ONLY && RExC_extralen) {\n\t    reginsert(pRExC_state, BRANCHJ, br, depth+1);\n\t}\n\telse {                  /* MJD */\n\t    reginsert(pRExC_state, BRANCH, br, depth+1);\n            Set_Node_Length(br, paren != 0);\n            Set_Node_Offset_To_R(br-RExC_emit_start, parse_start-RExC_start);\n        }\n\thave_branch = 1;\n\tif (SIZE_ONLY)\n\t    RExC_extralen += 1;\t\t/* For BRANCHJ-BRANCH. */\n    }\n    else if (paren == ':') {\n\t*flagp |= flags&SIMPLE;\n    }\n    if (is_open) {\t\t\t\t/* Starts with OPEN. */\n        REGTAIL(pRExC_state, ret, br);          /* OPEN -> first. */\n    }\n    else if (paren != '?')\t\t/* Not Conditional */\n\tret = br;\n    *flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    lastbr = br;\n    while (*RExC_parse == '|') {\n\tif (!SIZE_ONLY && RExC_extralen) {\n\t    ender = reganode(pRExC_state, LONGJMP,0);\n\n            /* Append to the previous. */\n            REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);\n\t}\n\tif (SIZE_ONLY)\n\t    RExC_extralen += 2;\t\t/* Account for LONGJMP. */\n\tnextchar(pRExC_state);\n\tif (freeze_paren) {\n\t    if (RExC_npar > after_freeze)\n\t        after_freeze = RExC_npar;\n            RExC_npar = freeze_paren;\n        }\n        br = regbranch(pRExC_state, &flags, 0, depth+1);\n\n\tif (br == NULL) {\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return NULL;\n            }\n            FAIL2(\"panic: regbranch returned NULL, flags=%#\" UVxf, (UV) flags);\n        }\n        REGTAIL(pRExC_state, lastbr, br);               /* BRANCH -> BRANCH. */\n\tlastbr = br;\n\t*flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);\n    }\n\n    if (have_branch || paren != ':') {\n\t/* Make a closing node, and hook it on the end. */\n\tswitch (paren) {\n\tcase ':':\n\t    ender = reg_node(pRExC_state, TAIL);\n\t    break;\n\tcase 1: case 2:\n\t    ender = reganode(pRExC_state, CLOSE, parno);\n            if ( RExC_close_parens ) {\n                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting close paren #%\" IVdf \" to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\", (IV)parno, REG_NODE_NUM(ender)));\n                RExC_close_parens[parno]= ender;\n\t        if (RExC_nestroot == parno)\n\t            RExC_nestroot = 0;\n\t    }\n            Set_Node_Offset(ender,RExC_parse+1); /* MJD */\n            Set_Node_Length(ender,1); /* MJD */\n\t    break;\n\tcase '<':\n\tcase ',':\n\tcase '=':\n\tcase '!':\n\t    *flagp &= ~HASWIDTH;\n\t    /* FALLTHROUGH */\n\tcase '>':\n\t    ender = reg_node(pRExC_state, SUCCEED);\n\t    break;\n\tcase 0:\n\t    ender = reg_node(pRExC_state, END);\n\t    if (!SIZE_ONLY) {\n                assert(!RExC_end_op); /* there can only be one! */\n                RExC_end_op = ender;\n                if (RExC_close_parens) {\n                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_\n                        \"%*s%*s Setting close paren #0 (END) to %d\\n\",\n                        22, \"|    |\", (int)(depth * 2 + 1), \"\", REG_NODE_NUM(ender)));\n\n                    RExC_close_parens[0]= ender;\n                }\n            }\n\t    break;\n\t}\n        DEBUG_PARSE_r(if (!SIZE_ONLY) {\n            DEBUG_PARSE_MSG(\"lsbr\");\n            regprop(RExC_rx, RExC_mysv1, lastbr, NULL, pRExC_state);\n            regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ tying lastbr %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                          SvPV_nolen_const(RExC_mysv1),\n                          (IV)REG_NODE_NUM(lastbr),\n                          SvPV_nolen_const(RExC_mysv2),\n                          (IV)REG_NODE_NUM(ender),\n                          (IV)(ender - lastbr)\n            );\n        });\n        REGTAIL(pRExC_state, lastbr, ender);\n\n\tif (have_branch && !SIZE_ONLY) {\n            char is_nothing= 1;\n\t    if (depth==1)\n                RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n\n\t    /* Hook the tails of the branches to the closing node. */\n\t    for (br = ret; br; br = regnext(br)) {\n\t\tconst U8 op = PL_regkind[OP(br)];\n\t\tif (op == BRANCH) {\n                    REGTAIL_STUDY(pRExC_state, NEXTOPER(br), ender);\n                    if ( OP(NEXTOPER(br)) != NOTHING\n                         || regnext(NEXTOPER(br)) != ender)\n                        is_nothing= 0;\n\t\t}\n\t\telse if (op == BRANCHJ) {\n                    REGTAIL_STUDY(pRExC_state, NEXTOPER(NEXTOPER(br)), ender);\n                    /* for now we always disable this optimisation * /\n                    if ( OP(NEXTOPER(NEXTOPER(br))) != NOTHING\n                         || regnext(NEXTOPER(NEXTOPER(br))) != ender)\n                    */\n                        is_nothing= 0;\n\t\t}\n\t    }\n            if (is_nothing) {\n                br= PL_regkind[OP(ret)] != BRANCH ? regnext(ret) : ret;\n                DEBUG_PARSE_r(if (!SIZE_ONLY) {\n                    DEBUG_PARSE_MSG(\"NADA\");\n                    regprop(RExC_rx, RExC_mysv1, ret, NULL, pRExC_state);\n                    regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);\n                    Perl_re_printf( aTHX_  \"~ converting ret %s (%\" IVdf \") to ender %s (%\" IVdf \") offset %\" IVdf \"\\n\",\n                                  SvPV_nolen_const(RExC_mysv1),\n                                  (IV)REG_NODE_NUM(ret),\n                                  SvPV_nolen_const(RExC_mysv2),\n                                  (IV)REG_NODE_NUM(ender),\n                                  (IV)(ender - ret)\n                    );\n                });\n                OP(br)= NOTHING;\n                if (OP(ender) == TAIL) {\n                    NEXT_OFF(br)= 0;\n                    RExC_emit= br + 1;\n                } else {\n                    regnode *opt;\n                    for ( opt= br + 1; opt < ender ; opt++ )\n                        OP(opt)= OPTIMIZED;\n                    NEXT_OFF(br)= ender - br;\n                }\n            }\n\t}\n    }\n\n    {\n        const char *p;\n        static const char parens[] = \"=!<,>\";\n\n\tif (paren && (p = strchr(parens, paren))) {\n\t    U8 node = ((p - parens) % 2) ? UNLESSM : IFMATCH;\n\t    int flag = (p - parens) > 1;\n\n\t    if (paren == '>')\n\t\tnode = SUSPEND, flag = 0;\n\t    reginsert(pRExC_state, node,ret, depth+1);\n            Set_Node_Cur_Length(ret, parse_start);\n\t    Set_Node_Offset(ret, parse_start + 1);\n\t    ret->flags = flag;\n            REGTAIL_STUDY(pRExC_state, ret, reg_node(pRExC_state, TAIL));\n\t}\n    }\n\n    /* Check for proper termination. */\n    if (paren) {\n        /* restore original flags, but keep (?p) and, if we've changed from /d\n         * rules to /u, keep the /u */\n\tRExC_flags = oregflags | (RExC_flags & RXf_PMf_KEEPCOPY);\n        if (DEPENDS_SEMANTICS && RExC_uni_semantics) {\n            set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n        }\n\tif (RExC_parse >= RExC_end || UCHARAT(RExC_parse) != ')') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched (\");\n\t}\n\tnextchar(pRExC_state);\n    }\n    else if (!paren && RExC_parse < RExC_end) {\n\tif (*RExC_parse == ')') {\n\t    RExC_parse++;\n\t    vFAIL(\"Unmatched )\");\n\t}\n\telse\n\t    FAIL(\"Junk on end of regexp\");\t/* \"Can't happen\". */\n\tNOT_REACHED; /* NOTREACHED */\n    }\n\n    if (RExC_in_lookbehind) {\n\tRExC_in_lookbehind--;\n    }\n    if (after_freeze > RExC_npar)\n        RExC_npar = after_freeze;\n    return(ret);\n}\n\n/*\n - regbranch - one alternative of an | operator\n *\n * Implements the concatenation operator.\n *\n * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be\n * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n */\nSTATIC regnode *\nS_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth)\n{\n    regnode *ret;\n    regnode *chain = NULL;\n    regnode *latest;\n    I32 flags = 0, c = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGBRANCH;\n\n    DEBUG_PARSE(\"brnc\");\n\n    if (first)\n\tret = NULL;\n    else {\n\tif (!SIZE_ONLY && RExC_extralen)\n\t    ret = reganode(pRExC_state, BRANCHJ,0);\n\telse {\n\t    ret = reg_node(pRExC_state, BRANCH);\n            Set_Node_Length(ret, 1);\n        }\n    }\n\n    if (!first && SIZE_ONLY)\n\tRExC_extralen += 1;\t\t\t/* BRANCHJ */\n\n    *flagp = WORST;\t\t\t/* Tentatively. */\n\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                            FALSE /* Don't force to /x */ );\n    while (RExC_parse < RExC_end && *RExC_parse != '|' && *RExC_parse != ')') {\n\tflags &= ~TRYAGAIN;\n        latest = regpiece(pRExC_state, &flags,depth+1);\n\tif (latest == NULL) {\n\t    if (flags & TRYAGAIN)\n\t\tcontinue;\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return NULL;\n            }\n            FAIL2(\"panic: regpiece returned NULL, flags=%#\" UVxf, (UV) flags);\n\t}\n\telse if (ret == NULL)\n            ret = latest;\n\t*flagp |= flags&(HASWIDTH|POSTPONED);\n\tif (chain == NULL) \t/* First piece. */\n\t    *flagp |= flags&SPSTART;\n\telse {\n\t    /* FIXME adding one for every branch after the first is probably\n\t     * excessive now we have TRIE support. (hv) */\n\t    MARK_NAUGHTY(1);\n            REGTAIL(pRExC_state, chain, latest);\n\t}\n\tchain = latest;\n\tc++;\n    }\n    if (chain == NULL) {\t/* Loop ran zero times. */\n\tchain = reg_node(pRExC_state, NOTHING);\n\tif (ret == NULL)\n\t    ret = chain;\n    }\n    if (c == 1) {\n\t*flagp |= flags&SIMPLE;\n    }\n\n    return ret;\n}\n\n/*\n - regpiece - something followed by possible quantifier * + ? {n,m}\n *\n * Note that the branching code sequences used for ? and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n *\n * Returns NULL, setting *flagp to TRYAGAIN if regatom() returns NULL with\n * TRYAGAIN.\n * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be\n * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n */\nSTATIC regnode *\nS_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    regnode *ret;\n    char op;\n    char *next;\n    I32 flags;\n    const char * const origparse = RExC_parse;\n    I32 min;\n    I32 max = REG_INFTY;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    char *parse_start;\n#endif\n    const char *maxpos = NULL;\n    UV uv;\n\n    /* Save the original in case we change the emitted regop to a FAIL. */\n    regnode * const orig_emit = RExC_emit;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPIECE;\n\n    DEBUG_PARSE(\"piec\");\n\n    ret = regatom(pRExC_state, &flags,depth+1);\n    if (ret == NULL) {\n\tif (flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8))\n\t    *flagp |= flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8);\n        else\n            FAIL2(\"panic: regatom returned NULL, flags=%#\" UVxf, (UV) flags);\n\treturn(NULL);\n    }\n\n    op = *RExC_parse;\n\n    if (op == '{' && regcurly(RExC_parse)) {\n\tmaxpos = NULL;\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        parse_start = RExC_parse; /* MJD */\n#endif\n\tnext = RExC_parse + 1;\n\twhile (isDIGIT(*next) || *next == ',') {\n\t    if (*next == ',') {\n\t\tif (maxpos)\n\t\t    break;\n\t\telse\n\t\t    maxpos = next;\n\t    }\n\t    next++;\n\t}\n\tif (*next == '}') {\t\t/* got one */\n            const char* endptr;\n\t    if (!maxpos)\n\t\tmaxpos = next;\n\t    RExC_parse++;\n            if (isDIGIT(*RExC_parse)) {\n                if (!grok_atoUV(RExC_parse, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                min = (I32)uv;\n            } else {\n                min = 0;\n            }\n\t    if (*maxpos == ',')\n\t\tmaxpos++;\n\t    else\n\t\tmaxpos = RExC_parse;\n            if (isDIGIT(*maxpos)) {\n                if (!grok_atoUV(maxpos, &uv, &endptr))\n                    vFAIL(\"Invalid quantifier in {,}\");\n                if (uv >= REG_INFTY)\n                    vFAIL2(\"Quantifier in {,} bigger than %d\", REG_INFTY - 1);\n                max = (I32)uv;\n            } else {\n\t\tmax = REG_INFTY;\t\t/* meaning \"infinity\" */\n            }\n\t    RExC_parse = next;\n\t    nextchar(pRExC_state);\n            if (max < min) {    /* If can't match, warn and optimize to fail\n                                   unconditionally */\n                reginsert(pRExC_state, OPFAIL, orig_emit, depth+1);\n                if (PASS2) {\n                    ckWARNreg(RExC_parse, \"Quantifier {n,m} with n > m can't match\");\n                    NEXT_OFF(orig_emit)= regarglen[OPFAIL] + NODE_STEP_REGNODE;\n                }\n                return ret;\n            }\n            else if (min == max && *RExC_parse == '?')\n            {\n                if (PASS2) {\n                    ckWARN2reg(RExC_parse + 1,\n                               \"Useless use of greediness modifier '%c'\",\n                               *RExC_parse);\n                }\n            }\n\n\t  do_curly:\n\t    if ((flags&SIMPLE)) {\n                if (min == 0 && max == REG_INFTY) {\n                    reginsert(pRExC_state, STAR, ret, depth+1);\n                    MARK_NAUGHTY(4);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                if (min == 1 && max == REG_INFTY) {\n                    reginsert(pRExC_state, PLUS, ret, depth+1);\n                    MARK_NAUGHTY(3);\n                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n                    goto nest_check;\n                }\n                MARK_NAUGHTY_EXP(2, 2);\n\t\treginsert(pRExC_state, CURLY, ret, depth+1);\n                Set_Node_Offset(ret, parse_start+1); /* MJD */\n                Set_Node_Cur_Length(ret, parse_start);\n\t    }\n\t    else {\n\t\tregnode * const w = reg_node(pRExC_state, WHILEM);\n\n\t\tw->flags = 0;\n                REGTAIL(pRExC_state, ret, w);\n\t\tif (!SIZE_ONLY && RExC_extralen) {\n\t\t    reginsert(pRExC_state, LONGJMP,ret, depth+1);\n\t\t    reginsert(pRExC_state, NOTHING,ret, depth+1);\n\t\t    NEXT_OFF(ret) = 3;\t/* Go over LONGJMP. */\n\t\t}\n\t\treginsert(pRExC_state, CURLYX,ret, depth+1);\n                                /* MJD hk */\n                Set_Node_Offset(ret, parse_start+1);\n                Set_Node_Length(ret,\n                                op == '{' ? (RExC_parse - parse_start) : 1);\n\n\t\tif (!SIZE_ONLY && RExC_extralen)\n\t\t    NEXT_OFF(ret) = 3;\t/* Go over NOTHING to LONGJMP. */\n                REGTAIL(pRExC_state, ret, reg_node(pRExC_state, NOTHING));\n\t\tif (SIZE_ONLY)\n\t\t    RExC_whilem_seen++, RExC_extralen += 3;\n                MARK_NAUGHTY_EXP(1, 4);     /* compound interest */\n\t    }\n\t    ret->flags = 0;\n\n\t    if (min > 0)\n\t\t*flagp = WORST;\n\t    if (max > 0)\n\t\t*flagp |= HASWIDTH;\n\t    if (!SIZE_ONLY) {\n\t\tARG1_SET(ret, (U16)min);\n\t\tARG2_SET(ret, (U16)max);\n\t    }\n            if (max == REG_INFTY)\n                RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;\n\n\t    goto nest_check;\n\t}\n    }\n\n    if (!ISMULT1(op)) {\n\t*flagp = flags;\n\treturn(ret);\n    }\n\n#if 0\t\t\t\t/* Now runtime fix should be reliable. */\n\n    /* if this is reinstated, don't forget to put this back into perldiag:\n\n\t    =item Regexp *+ operand could be empty at {#} in regex m/%s/\n\n\t   (F) The part of the regexp subject to either the * or + quantifier\n           could match an empty string. The {#} shows in the regular\n           expression about where the problem was discovered.\n\n    */\n\n    if (!(flags&HASWIDTH) && op != '?')\n      vFAIL(\"Regexp *+ operand could be empty\");\n#endif\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    parse_start = RExC_parse;\n#endif\n    nextchar(pRExC_state);\n\n    *flagp = (op != '+') ? (WORST|SPSTART|HASWIDTH) : (WORST|HASWIDTH);\n\n    if (op == '*') {\n\tmin = 0;\n\tgoto do_curly;\n    }\n    else if (op == '+') {\n\tmin = 1;\n\tgoto do_curly;\n    }\n    else if (op == '?') {\n\tmin = 0; max = 1;\n\tgoto do_curly;\n    }\n  nest_check:\n    if (!SIZE_ONLY && !(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3) {\n\tSAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */\n\tckWARN2reg(RExC_parse,\n\t\t   \"%\" UTF8f \" matches null string many times\",\n\t\t   UTF8fARG(UTF, (RExC_parse >= origparse\n                                 ? RExC_parse - origparse\n                                 : 0),\n\t\t   origparse));\n\t(void)ReREFCNT_inc(RExC_rx_sv);\n    }\n\n    if (*RExC_parse == '?') {\n\tnextchar(pRExC_state);\n\treginsert(pRExC_state, MINMOD, ret, depth+1);\n        REGTAIL(pRExC_state, ret, ret + NODE_STEP_REGNODE);\n    }\n    else if (*RExC_parse == '+') {\n        regnode *ender;\n        nextchar(pRExC_state);\n        ender = reg_node(pRExC_state, SUCCEED);\n        REGTAIL(pRExC_state, ret, ender);\n        reginsert(pRExC_state, SUSPEND, ret, depth+1);\n        ender = reg_node(pRExC_state, TAIL);\n        REGTAIL(pRExC_state, ret, ender);\n    }\n\n    if (ISMULT2(RExC_parse)) {\n\tRExC_parse++;\n\tvFAIL(\"Nested quantifiers\");\n    }\n\n    return(ret);\n}\n\nSTATIC bool\nS_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,\n                regnode ** node_p,\n                UV * code_point_p,\n                int * cp_count,\n                I32 * flagp,\n                const bool strict,\n                const U32 depth\n    )\n{\n /* This routine teases apart the various meanings of \\N and returns\n  * accordingly.  The input parameters constrain which meaning(s) is/are valid\n  * in the current context.\n  *\n  * Exactly one of <node_p> and <code_point_p> must be non-NULL.\n  *\n  * If <code_point_p> is not NULL, the context is expecting the result to be a\n  * single code point.  If this \\N instance turns out to a single code point,\n  * the function returns TRUE and sets *code_point_p to that code point.\n  *\n  * If <node_p> is not NULL, the context is expecting the result to be one of\n  * the things representable by a regnode.  If this \\N instance turns out to be\n  * one such, the function generates the regnode, returns TRUE and sets *node_p\n  * to point to that regnode.\n  *\n  * If this instance of \\N isn't legal in any context, this function will\n  * generate a fatal error and not return.\n  *\n  * On input, RExC_parse should point to the first char following the \\N at the\n  * time of the call.  On successful return, RExC_parse will have been updated\n  * to point to just after the sequence identified by this routine.  Also\n  * *flagp has been updated as needed.\n  *\n  * When there is some problem with the current context and this \\N instance,\n  * the function returns FALSE, without advancing RExC_parse, nor setting\n  * *node_p, nor *code_point_p, nor *flagp.\n  *\n  * If <cp_count> is not NULL, the caller wants to know the length (in code\n  * points) that this \\N sequence matches.  This is set even if the function\n  * returns FALSE, as detailed below.\n  *\n  * There are 5 possibilities here, as detailed in the next 5 paragraphs.\n  *\n  * Probably the most common case is for the \\N to specify a single code point.\n  * *cp_count will be set to 1, and *code_point_p will be set to that code\n  * point.\n  *\n  * Another possibility is for the input to be an empty \\N{}, which for\n  * backwards compatibility we accept.  *cp_count will be set to 0. *node_p\n  * will be set to a generated NOTHING node.\n  *\n  * Still another possibility is for the \\N to mean [^\\n]. *cp_count will be\n  * set to 0. *node_p will be set to a generated REG_ANY node.\n  *\n  * The fourth possibility is that \\N resolves to a sequence of more than one\n  * code points.  *cp_count will be set to the number of code points in the\n  * sequence. *node_p * will be set to a generated node returned by this\n  * function calling S_reg().\n  *\n  * The final possibility is that it is premature to be calling this function;\n  * that pass1 needs to be restarted.  This can happen when this changes from\n  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The\n  * latter occurs only when the fourth possibility would otherwise be in\n  * effect, and is because one of those code points requires the pattern to be\n  * recompiled as UTF-8.  The function returns FALSE, and sets the\n  * RESTART_PASS1 and NEED_UTF8 flags in *flagp, as appropriate.  When this\n  * happens, the caller needs to desist from continuing parsing, and return\n  * this information to its caller.  This is not set for when there is only one\n  * code point, as this can be called as part of an ANYOF node, and they can\n  * store above-Latin1 code points without the pattern having to be in UTF-8.\n  *\n  * For non-single-quoted regexes, the tokenizer has resolved character and\n  * sequence names inside \\N{...} into their Unicode values, normalizing the\n  * result into what we should see here: '\\N{U+c1.c2...}', where c1... are the\n  * hex-represented code points in the sequence.  This is done there because\n  * the names can vary based on what charnames pragma is in scope at the time,\n  * so we need a way to take a snapshot of what they resolve to at the time of\n  * the original parse. [perl #56444].\n  *\n  * That parsing is skipped for single-quoted regexes, so we may here get\n  * '\\N{NAME}'.  This is a fatal error.  These names have to be resolved by the\n  * parser.  But if the single-quoted regex is something like '\\N{U+41}', that\n  * is legal and handled here.  The code point is Unicode, and has to be\n  * translated into the native character set for non-ASCII platforms.\n  */\n\n    char * endbrace;    /* points to '}' following the name */\n    char *endchar;\t/* Points to '.' or '}' ending cur char in the input\n                           stream */\n    char* p = RExC_parse; /* Temporary */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_GROK_BSLASH_N;\n\n    GET_RE_DEBUG_FLAGS;\n\n    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */\n    assert(! (node_p && cp_count));               /* At most 1 should be set */\n\n    if (cp_count) {     /* Initialize return for the most common case */\n        *cp_count = 1;\n    }\n\n    /* The [^\\n] meaning of \\N ignores spaces and comments under the /x\n     * modifier.  The other meanings do not, so use a temporary until we find\n     * out which we are being called with */\n    skip_to_be_ignored_text(pRExC_state, &p,\n                            FALSE /* Don't force to /x */ );\n\n    /* Disambiguate between \\N meaning a named character versus \\N meaning\n     * [^\\n].  The latter is assumed when the {...} following the \\N is a legal\n     * quantifier, or there is no '{' at all */\n    if (*p != '{' || regcurly(p)) {\n\tRExC_parse = p;\n        if (cp_count) {\n            *cp_count = -1;\n        }\n\n\tif (! node_p) {\n            return FALSE;\n        }\n\n\t*node_p = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(*node_p, 1); /* MJD */\n\treturn TRUE;\n    }\n\n    /* Here, we have decided it should be a named character or sequence */\n\n    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t/* Skip past the '{' */\n\n    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t/* nothing between the {} */\n               || memBEGINs(RExC_parse,   /* U+ (bad hex is checked below\n                                                   for a  better error msg) */\n                                  (STRLEN) (RExC_end - RExC_parse),\n                                 \"U+\")))\n    {\n\tRExC_parse = endbrace;\t/* position msg's '<--HERE' */\n\tvFAIL(\"\\\\N{NAME} must be resolved by the lexer\");\n    }\n\n    REQUIRE_UNI_RULES(flagp, FALSE); /* Unicode named chars imply Unicode\n                                        semantics */\n\n    if (endbrace == RExC_parse) {   /* empty: \\N{} */\n        if (strict) {\n            RExC_parse++;   /* Position after the \"}\" */\n            vFAIL(\"Zero length \\\\N{}\");\n        }\n        if (cp_count) {\n            *cp_count = 0;\n        }\n        nextchar(pRExC_state);\n\tif (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state,NOTHING);\n        return TRUE;\n    }\n\n    RExC_parse += 2;\t/* Skip past the 'U+' */\n\n    /* Because toke.c has generated a special construct for us guaranteed not\n     * to have NULs, we can use a str function */\n    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n    /* Code points are separated by dots.  If none, there is only one code\n     * point, and is terminated by the brace */\n\n    if (endchar >= endbrace) {\n\tSTRLEN length_of_hex;\n\tI32 grok_hex_flags;\n\n        /* Here, exactly one code point.  If that isn't what is wanted, fail */\n        if (! code_point_p) {\n            RExC_parse = p;\n            return FALSE;\n        }\n\n        /* Convert code point from hex */\n\tlength_of_hex = (STRLEN)(endchar - RExC_parse);\n\tgrok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES\n                       | PERL_SCAN_DISALLOW_PREFIX\n\n                           /* No errors in the first pass (See [perl\n                            * #122671].)  We let the code below find the\n                            * errors when there are multiple chars. */\n                       | ((SIZE_ONLY)\n                          ? PERL_SCAN_SILENT_ILLDIGIT\n                          : 0);\n\n        /* This routine is the one place where both single- and double-quotish\n         * \\N{U+xxxx} are evaluated.  The value is a Unicode code point which\n         * must be converted to native. */\n\t*code_point_p = UNI_TO_NATIVE(grok_hex(RExC_parse,\n                                               &length_of_hex,\n                                               &grok_hex_flags,\n                                               NULL));\n\n\t/* The tokenizer should have guaranteed validity, but it's possible to\n         * bypass it by using single quoting, so check.  Don't do the check\n         * here when there are multiple chars; we do it below anyway. */\n        if (length_of_hex == 0\n            || length_of_hex != (STRLEN)(endchar - RExC_parse) )\n        {\n            RExC_parse += length_of_hex;\t/* Includes all the valid */\n            RExC_parse += (RExC_orig_utf8)\t/* point to after 1st invalid */\n                            ? UTF8SKIP(RExC_parse)\n                            : 1;\n            /* Guard against malformed utf8 */\n            if (RExC_parse >= endchar) {\n                RExC_parse = endchar;\n            }\n            vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n        }\n\n        RExC_parse = endbrace + 1;\n        return TRUE;\n    }\n    else {  /* Is a multiple character sequence */\n\tSV * substitute_parse;\n\tSTRLEN len;\n\tchar *orig_end = RExC_end;\n\tchar *save_start = RExC_start;\n        I32 flags;\n\n        /* Count the code points, if desired, in the sequence */\n        if (cp_count) {\n            *cp_count = 0;\n            while (RExC_parse < endbrace) {\n                /* Point to the beginning of the next character in the sequence. */\n                RExC_parse = endchar + 1;\n                endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n                (*cp_count)++;\n            }\n        }\n\n        /* Fail if caller doesn't want to handle a multi-code-point sequence.\n         * But don't backup up the pointer if the caller wants to know how many\n         * code points there are (they can then handle things) */\n        if (! node_p) {\n            if (! cp_count) {\n                RExC_parse = p;\n            }\n            return FALSE;\n        }\n\n\t/* What is done here is to convert this to a sub-pattern of the form\n         * \\x{char1}\\x{char2}...  and then call reg recursively to parse it\n         * (enclosing in \"(?: ... )\" ).  That way, it retains its atomicness,\n         * while not having to worry about special handling that some code\n         * points may have. */\n\n\tsubstitute_parse = newSVpvs(\"?:\");\n\n\twhile (RExC_parse < endbrace) {\n\n\t    /* Convert to notation the rest of the code understands */\n\t    sv_catpv(substitute_parse, \"\\\\x{\");\n\t    sv_catpvn(substitute_parse, RExC_parse, endchar - RExC_parse);\n\t    sv_catpv(substitute_parse, \"}\");\n\n\t    /* Point to the beginning of the next character in the sequence. */\n\t    RExC_parse = endchar + 1;\n\t    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n\t}\n        sv_catpv(substitute_parse, \")\");\n\n        len = SvCUR(substitute_parse);\n\n\t/* Don't allow empty number */\n\tif (len < (STRLEN) 8) {\n            RExC_parse = endbrace;\n\t    vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n\t}\n\n        RExC_parse = RExC_start = RExC_adjusted_start\n                                              = SvPV_nolen(substitute_parse);\n\tRExC_end = RExC_parse + len;\n\n        /* The values are Unicode, and therefore not subject to recoding, but\n         * have to be converted to native on a non-Unicode (meaning non-ASCII)\n         * platform. */\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 1;\n#endif\n\n        *node_p = reg(pRExC_state, 1, &flags, depth+1);\n\n        /* Restore the saved values */\n\tRExC_start = RExC_adjusted_start = save_start;\n\tRExC_parse = endbrace;\n\tRExC_end = orig_end;\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 0;\n#endif\n        SvREFCNT_dec_NN(substitute_parse);\n\n        if (! *node_p) {\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return FALSE;\n            }\n            FAIL2(\"panic: reg returned NULL to grok_bslash_N, flags=%#\" UVxf,\n                (UV) flags);\n        }\n        *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\n        nextchar(pRExC_state);\n\n        return TRUE;\n    }\n}\n\n\nPERL_STATIC_INLINE U8\nS_compute_EXACTish(RExC_state_t *pRExC_state)\n{\n    U8 op;\n\n    PERL_ARGS_ASSERT_COMPUTE_EXACTISH;\n\n    if (! FOLD) {\n        return (LOC)\n                ? EXACTL\n                : EXACT;\n    }\n\n    op = get_regex_charset(RExC_flags);\n    if (op >= REGEX_ASCII_RESTRICTED_CHARSET) {\n        op--; /* /a is same as /u, and map /aa's offset to what /a's would have\n                 been, so there is no hole */\n    }\n\n    return op + EXACTF;\n}\n\nPERL_STATIC_INLINE void\nS_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state,\n                         regnode *node, I32* flagp, STRLEN len, UV code_point,\n                         bool downgradable)\n{\n    /* This knows the details about sizing an EXACTish node, setting flags for\n     * it (by setting <*flagp>, and potentially populating it with a single\n     * character.\n     *\n     * If <len> (the length in bytes) is non-zero, this function assumes that\n     * the node has already been populated, and just does the sizing.  In this\n     * case <code_point> should be the final code point that has already been\n     * placed into the node.  This value will be ignored except that under some\n     * circumstances <*flagp> is set based on it.\n     *\n     * If <len> is zero, the function assumes that the node is to contain only\n     * the single character given by <code_point> and calculates what <len>\n     * should be.  In pass 1, it sizes the node appropriately.  In pass 2, it\n     * additionally will populate the node's STRING with <code_point> or its\n     * fold if folding.\n     *\n     * In both cases <*flagp> is appropriately set\n     *\n     * It knows that under FOLD, the Latin Sharp S and UTF characters above\n     * 255, must be folded (the former only when the rules indicate it can\n     * match 'ss')\n     *\n     * When it does the populating, it looks at the flag 'downgradable'.  If\n     * true with a node that folds, it checks if the single code point\n     * participates in a fold, and if not downgrades the node to an EXACT.\n     * This helps the optimizer */\n\n    bool len_passed_in = cBOOL(len != 0);\n    U8 character[UTF8_MAXBYTES_CASE+1];\n\n    PERL_ARGS_ASSERT_ALLOC_MAYBE_POPULATE_EXACT;\n\n    /* Don't bother to check for downgrading in PASS1, as it doesn't make any\n     * sizing difference, and is extra work that is thrown away */\n    if (downgradable && ! PASS2) {\n        downgradable = FALSE;\n    }\n\n    if (! len_passed_in) {\n        if (UTF) {\n            if (UVCHR_IS_INVARIANT(code_point)) {\n                if (LOC || ! FOLD) {    /* /l defers folding until runtime */\n                    *character = (U8) code_point;\n                }\n                else { /* Here is /i and not /l. (toFOLD() is defined on just\n                          ASCII, which isn't the same thing as INVARIANT on\n                          EBCDIC, but it works there, as the extra invariants\n                          fold to themselves) */\n                    *character = toFOLD((U8) code_point);\n\n                    /* We can downgrade to an EXACT node if this character\n                     * isn't a folding one.  Note that this assumes that\n                     * nothing above Latin1 folds to some other invariant than\n                     * one of these alphabetics; otherwise we would also have\n                     * to check:\n                     *  && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)\n                     *      || ASCII_FOLD_RESTRICTED))\n                     */\n                    if (downgradable && PL_fold[code_point] == code_point) {\n                        OP(node) = EXACT;\n                    }\n                }\n                len = 1;\n            }\n            else if (FOLD && (! LOC\n                              || ! is_PROBLEMATIC_LOCALE_FOLD_cp(code_point)))\n            {   /* Folding, and ok to do so now */\n                UV folded = _to_uni_fold_flags(\n                                   code_point,\n                                   character,\n                                   &len,\n                                   FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)\n                                                      ? FOLD_FLAGS_NOMIX_ASCII\n                                                      : 0));\n                if (downgradable\n                    && folded == code_point /* This quickly rules out many\n                                               cases, avoiding the\n                                               _invlist_contains_cp() overhead\n                                               for those.  */\n                    && ! _invlist_contains_cp(PL_utf8_foldable, code_point))\n                {\n                    OP(node) = (LOC)\n                               ? EXACTL\n                               : EXACT;\n                }\n            }\n            else if (code_point <= MAX_UTF8_TWO_BYTE) {\n\n                /* Not folding this cp, and can output it directly */\n                *character = UTF8_TWO_BYTE_HI(code_point);\n                *(character + 1) = UTF8_TWO_BYTE_LO(code_point);\n                len = 2;\n            }\n            else {\n                uvchr_to_utf8( character, code_point);\n                len = UTF8SKIP(character);\n            }\n        } /* Else pattern isn't UTF8.  */\n        else if (! FOLD) {\n            *character = (U8) code_point;\n            len = 1;\n        } /* Else is folded non-UTF8 */\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n        else if (LIKELY(code_point != LATIN_SMALL_LETTER_SHARP_S)) {\n#else\n        else if (1) {\n#endif\n            /* We don't fold any non-UTF8 except possibly the Sharp s  (see\n             * comments at join_exact()); */\n            *character = (U8) code_point;\n            len = 1;\n\n            /* Can turn into an EXACT node if we know the fold at compile time,\n             * and it folds to itself and doesn't particpate in other folds */\n            if (downgradable\n                && ! LOC\n                && PL_fold_latin1[code_point] == code_point\n                && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)\n                    || (isASCII(code_point) && ASCII_FOLD_RESTRICTED)))\n            {\n                OP(node) = EXACT;\n            }\n        } /* else is Sharp s.  May need to fold it */\n        else if (AT_LEAST_UNI_SEMANTICS && ! ASCII_FOLD_RESTRICTED) {\n            *character = 's';\n            *(character + 1) = 's';\n            len = 2;\n        }\n        else {\n            *character = LATIN_SMALL_LETTER_SHARP_S;\n            len = 1;\n        }\n    }\n\n    if (SIZE_ONLY) {\n        RExC_size += STR_SZ(len);\n    }\n    else {\n        RExC_emit += STR_SZ(len);\n        STR_LEN(node) = len;\n        if (! len_passed_in) {\n            Copy((char *) character, STRING(node), len, char);\n        }\n    }\n\n    *flagp |= HASWIDTH;\n\n    /* A single character node is SIMPLE, except for the special-cased SHARP S\n     * under /di. */\n    if ((len == 1 || (UTF && len == UVCHR_SKIP(code_point)))\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n        && ( code_point != LATIN_SMALL_LETTER_SHARP_S\n            || ! FOLD || ! DEPENDS_SEMANTICS)\n#endif\n    ) {\n        *flagp |= SIMPLE;\n    }\n\n    /* The OP may not be well defined in PASS1 */\n    if (PASS2 && OP(node) == EXACTFL) {\n        RExC_contains_locale = 1;\n    }\n}\n\nSTATIC bool\nS_new_regcurly(const char *s, const char *e)\n{\n    /* This is a temporary function designed to match the most lenient form of\n     * a {m,n} quantifier we ever envision, with either number omitted, and\n     * spaces anywhere between/before/after them.\n     *\n     * If this function fails, then the string it matches is very unlikely to\n     * ever be considered a valid quantifier, so we can allow the '{' that\n     * begins it to be considered as a literal */\n\n    bool has_min = FALSE;\n    bool has_max = FALSE;\n\n    PERL_ARGS_ASSERT_NEW_REGCURLY;\n\n    if (s >= e || *s++ != '{')\n\treturn FALSE;\n\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n    while (s < e && isDIGIT(*s)) {\n        has_min = TRUE;\n        s++;\n    }\n    while (s < e && isSPACE(*s)) {\n        s++;\n    }\n\n    if (*s == ',') {\n\ts++;\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n        while (s < e && isDIGIT(*s)) {\n            has_max = TRUE;\n            s++;\n        }\n        while (s < e && isSPACE(*s)) {\n            s++;\n        }\n    }\n\n    return s < e && *s == '}' && (has_min || has_max);\n}\n\n/* Parse backref decimal value, unless it's too big to sensibly be a backref,\n * in which case return I32_MAX (rather than possibly 32-bit wrapping) */\n\nstatic I32\nS_backref_value(char *p)\n{\n    const char* endptr;\n    UV val;\n    if (grok_atoUV(p, &val, &endptr) && val <= I32_MAX)\n        return (I32)val;\n    return I32_MAX;\n}\n\n\n/*\n - regatom - the lowest level\n\n   Try to identify anything special at the start of the current parse position.\n   If there is, then handle it as required. This may involve generating a\n   single regop, such as for an assertion; or it may involve recursing, such as\n   to handle a () structure.\n\n   If the string doesn't start with something special then we gobble up\n   as much literal text as we can.  If we encounter a quantifier, we have to\n   back off the final literal character, as that quantifier applies to just it\n   and not to the whole string of literals.\n\n   Once we have been able to handle whatever type of thing started the\n   sequence, we return.\n\n   Note: we have to be careful with escapes, as they can be both literal\n   and special, and in the case of \\10 and friends, context determines which.\n\n   A summary of the code structure is:\n\n   switch (first_byte) {\n\tcases for each special:\n\t    handle this special;\n\t    break;\n\tcase '\\\\':\n\t    switch (2nd byte) {\n\t\tcases for each unambiguous special:\n\t\t    handle this special;\n\t\t    break;\n\t\tcases for each ambigous special/literal:\n\t\t    disambiguate;\n\t\t    if (special)  handle here\n\t\t    else goto defchar;\n\t\tdefault: // unambiguously literal:\n\t\t    goto defchar;\n\t    }\n\tdefault:  // is a literal char\n\t    // FALL THROUGH\n\tdefchar:\n\t    create EXACTish node for literal;\n\t    while (more input and node isn't full) {\n\t\tswitch (input_byte) {\n\t\t   cases for each special;\n                       make sure parse pointer is set so that the next call to\n                           regatom will see this special first\n                       goto loopdone; // EXACTish node terminated by prev. char\n\t\t   default:\n\t\t       append char to EXACTISH node;\n\t\t}\n\t        get next input byte;\n\t    }\n        loopdone:\n   }\n   return the generated node;\n\n   Specifically there are two separate switches for handling\n   escape sequences, with the one for handling literal escapes requiring\n   a dummy entry for all of the special escapes that are actually handled\n   by the other.\n\n   Returns NULL, setting *flagp to TRYAGAIN if reg() returns NULL with\n   TRYAGAIN.\n   Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be\n   restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8\n   Otherwise does not return NULL.\n*/\n\nSTATIC regnode *\nS_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n{\n    regnode *ret = NULL;\n    I32 flags = 0;\n    char *parse_start;\n    U8 op;\n    int invert = 0;\n    U8 arg;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    *flagp = WORST;\t\t/* Tentatively. */\n\n    DEBUG_PARSE(\"atom\");\n\n    PERL_ARGS_ASSERT_REGATOM;\n\n  tryagain:\n    parse_start = RExC_parse;\n    assert(RExC_parse < RExC_end);\n    switch ((U8)*RExC_parse) {\n    case '^':\n\tRExC_seen_zerolen++;\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MBOL);\n\telse\n\t    ret = reg_node(pRExC_state, SBOL);\n        Set_Node_Length(ret, 1); /* MJD */\n\tbreak;\n    case '$':\n\tnextchar(pRExC_state);\n\tif (*RExC_parse)\n\t    RExC_seen_zerolen++;\n\tif (RExC_flags & RXf_PMf_MULTILINE)\n\t    ret = reg_node(pRExC_state, MEOL);\n\telse\n\t    ret = reg_node(pRExC_state, SEOL);\n        Set_Node_Length(ret, 1); /* MJD */\n\tbreak;\n    case '.':\n\tnextchar(pRExC_state);\n\tif (RExC_flags & RXf_PMf_SINGLELINE)\n\t    ret = reg_node(pRExC_state, SANY);\n\telse\n\t    ret = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(ret, 1); /* MJD */\n\tbreak;\n    case '[':\n    {\n\tchar * const oregcomp_parse = ++RExC_parse;\n        ret = regclass(pRExC_state, flagp,depth+1,\n                       FALSE, /* means parse the whole char class */\n                       TRUE, /* allow multi-char folds */\n                       FALSE, /* don't silence non-portable warnings. */\n                       (bool) RExC_strict,\n                       TRUE, /* Allow an optimized regnode result */\n                       NULL,\n                       NULL);\n        if (ret == NULL) {\n            if (*flagp & (RESTART_PASS1|NEED_UTF8))\n                return NULL;\n            FAIL2(\"panic: regclass returned NULL to regatom, flags=%#\" UVxf,\n                  (UV) *flagp);\n        }\n\tif (*RExC_parse != ']') {\n\t    RExC_parse = oregcomp_parse;\n\t    vFAIL(\"Unmatched [\");\n\t}\n\tnextchar(pRExC_state);\n        Set_Node_Length(ret, RExC_parse - oregcomp_parse + 1); /* MJD */\n\tbreak;\n    }\n    case '(':\n\tnextchar(pRExC_state);\n        ret = reg(pRExC_state, 2, &flags,depth+1);\n\tif (ret == NULL) {\n\t\tif (flags & TRYAGAIN) {\n\t\t    if (RExC_parse >= RExC_end) {\n\t\t\t /* Make parent create an empty node if needed. */\n\t\t\t*flagp |= TRYAGAIN;\n\t\t\treturn(NULL);\n\t\t    }\n\t\t    goto tryagain;\n\t\t}\n                if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                    *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                    return NULL;\n                }\n                FAIL2(\"panic: reg returned NULL to regatom, flags=%#\" UVxf,\n                                                                 (UV) flags);\n\t}\n\t*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\tbreak;\n    case '|':\n    case ')':\n\tif (flags & TRYAGAIN) {\n\t    *flagp |= TRYAGAIN;\n\t    return NULL;\n\t}\n\tvFAIL(\"Internal urp\");\n\t\t\t\t/* Supposed to be caught earlier. */\n\tbreak;\n    case '?':\n    case '+':\n    case '*':\n\tRExC_parse++;\n\tvFAIL(\"Quantifier follows nothing\");\n\tbreak;\n    case '\\\\':\n\t/* Special Escapes\n\n\t   This switch handles escape sequences that resolve to some kind\n\t   of special regop and not to literal text. Escape sequnces that\n\t   resolve to literal text are handled below in the switch marked\n\t   \"Literal Escapes\".\n\n\t   Every entry in this switch *must* have a corresponding entry\n\t   in the literal escape switch. However, the opposite is not\n\t   required, as the default for this switch is to jump to the\n\t   literal text handling code.\n\t*/\n\tRExC_parse++;\n\tswitch ((U8)*RExC_parse) {\n\t/* Special Escapes */\n\tcase 'A':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, SBOL);\n            /* SBOL is shared with /^/ so we set the flags so we can tell\n             * /\\A/ from /^/ in split. We check ret because first pass we\n             * have no regop struct to set the flags on. */\n            if (PASS2)\n                ret->flags = 1;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'G':\n\t    ret = reg_node(pRExC_state, GPOS);\n            RExC_seen |= REG_GPOS_SEEN;\n\t    *flagp |= SIMPLE;\n\t    goto finish_meta_pat;\n\tcase 'K':\n\t    RExC_seen_zerolen++;\n\t    ret = reg_node(pRExC_state, KEEPS);\n\t    *flagp |= SIMPLE;\n\t    /* XXX:dmq : disabling in-place substitution seems to\n\t     * be necessary here to avoid cases of memory corruption, as\n\t     * with: C<$_=\"x\" x 80; s/x\\K/y/> -- rgs\n\t     */\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    goto finish_meta_pat;\n\tcase 'Z':\n\t    ret = reg_node(pRExC_state, SEOL);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'z':\n\t    ret = reg_node(pRExC_state, EOS);\n\t    *flagp |= SIMPLE;\n\t    RExC_seen_zerolen++;\t\t/* Do not optimize RE away */\n\t    goto finish_meta_pat;\n\tcase 'C':\n\t    vFAIL(\"\\\\C no longer supported\");\n\tcase 'X':\n\t    ret = reg_node(pRExC_state, CLUMP);\n\t    *flagp |= HASWIDTH;\n\t    goto finish_meta_pat;\n\n\tcase 'W':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'w':\n            arg = ANYOF_WORDCHAR;\n            goto join_posix;\n\n\tcase 'B':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'b':\n          {\n\t    regex_charset charset = get_regex_charset(RExC_flags);\n\n\t    RExC_seen_zerolen++;\n            RExC_seen |= REG_LOOKBEHIND_SEEN;\n\t    op = BOUND + charset;\n\n            if (op == BOUNDL) {\n                RExC_contains_locale = 1;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n\t    *flagp |= SIMPLE;\n\t    if (RExC_parse >= RExC_end || *(RExC_parse + 1) != '{') {\n                FLAGS(ret) = TRADITIONAL_BOUND;\n                if (PASS2 && op > BOUNDA) {  /* /aa is same as /a */\n                    OP(ret) = BOUNDA;\n                }\n            }\n            else {\n                STRLEN length;\n                char name = *RExC_parse;\n                char * endbrace = NULL;\n                RExC_parse += 2;\n                if (RExC_parse < RExC_end) {\n                    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n                }\n\n                if (! endbrace) {\n                    vFAIL2(\"Missing right brace on \\\\%c{}\", name);\n                }\n                /* XXX Need to decide whether to take spaces or not.  Should be\n                 * consistent with \\p{}, but that currently is SPACE, which\n                 * means vertical too, which seems wrong\n                 * while (isBLANK(*RExC_parse)) {\n                    RExC_parse++;\n                }*/\n                if (endbrace == RExC_parse) {\n                    RExC_parse++;  /* After the '}' */\n                    vFAIL2(\"Empty \\\\%c{}\", name);\n                }\n                length = endbrace - RExC_parse;\n                /*while (isBLANK(*(RExC_parse + length - 1))) {\n                    length--;\n                }*/\n                switch (*RExC_parse) {\n                    case 'g':\n                        if (    length != 1\n                            && (memNEs(RExC_parse + 1, length - 1, \"cb\")))\n                        {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = GCB_BOUND;\n                        break;\n                    case 'l':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = LB_BOUND;\n                        break;\n                    case 's':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = SB_BOUND;\n                        break;\n                    case 'w':\n                        if (length != 2 || *(RExC_parse + 1) != 'b') {\n                            goto bad_bound_type;\n                        }\n                        FLAGS(ret) = WB_BOUND;\n                        break;\n                    default:\n                      bad_bound_type:\n                        RExC_parse = endbrace;\n\t\t\tvFAIL2utf8f(\n                            \"'%\" UTF8f \"' is an unknown bound type\",\n\t\t\t    UTF8fARG(UTF, length, endbrace - length));\n                        NOT_REACHED; /*NOTREACHED*/\n                }\n                RExC_parse = endbrace;\n                REQUIRE_UNI_RULES(flagp, NULL);\n\n                if (PASS2 && op >= BOUNDA) {  /* /aa is same as /a */\n                    OP(ret) = BOUNDU;\n                    length += 4;\n\n                    /* Don't have to worry about UTF-8, in this message because\n                     * to get here the contents of the \\b must be ASCII */\n                    ckWARN4reg(RExC_parse + 1,  /* Include the '}' in msg */\n                              \"Using /u for '%.*s' instead of /%s\",\n                              (unsigned) length,\n                              endbrace - length + 1,\n                              (charset == REGEX_ASCII_RESTRICTED_CHARSET)\n                              ? ASCII_RESTRICT_PAT_MODS\n                              : ASCII_MORE_RESTRICT_PAT_MODS);\n                }\n\t    }\n\n            if (PASS2 && invert) {\n                OP(ret) += NBOUND - BOUND;\n            }\n\t    goto finish_meta_pat;\n          }\n\n\tcase 'D':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'd':\n            arg = ANYOF_DIGIT;\n            if (! DEPENDS_SEMANTICS) {\n                goto join_posix;\n            }\n\n            /* \\d doesn't have any matches in the upper Latin1 range, hence /d\n             * is equivalent to /u.  Changing to /u saves some branches at\n             * runtime */\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'R':\n\t    ret = reg_node(pRExC_state, LNBREAK);\n\t    *flagp |= HASWIDTH|SIMPLE;\n\t    goto finish_meta_pat;\n\n\tcase 'H':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'h':\n\t    arg = ANYOF_BLANK;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'V':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 'v':\n\t    arg = ANYOF_VERTWS;\n            op = POSIXU;\n            goto join_posix_op_known;\n\n\tcase 'S':\n            invert = 1;\n            /* FALLTHROUGH */\n\tcase 's':\n            arg = ANYOF_SPACE;\n\n          join_posix:\n\n\t    op = POSIXD + get_regex_charset(RExC_flags);\n            if (op > POSIXA) {  /* /aa is same as /a */\n                op = POSIXA;\n            }\n            else if (op == POSIXL) {\n                RExC_contains_locale = 1;\n            }\n\n          join_posix_op_known:\n\n            if (invert) {\n                op += NPOSIXD - POSIXD;\n            }\n\n\t    ret = reg_node(pRExC_state, op);\n            if (! SIZE_ONLY) {\n                FLAGS(ret) = namedclass_to_classnum(arg);\n            }\n\n\t    *flagp |= HASWIDTH|SIMPLE;\n            /* FALLTHROUGH */\n\n          finish_meta_pat:\n            if (   UCHARAT(RExC_parse + 1) == '{'\n                && UNLIKELY(! new_regcurly(RExC_parse + 1, RExC_end)))\n            {\n                RExC_parse += 2;\n                vFAIL(\"Unescaped left brace in regex is illegal here\");\n            }\n\t    nextchar(pRExC_state);\n            Set_Node_Length(ret, 2); /* MJD */\n\t    break;\n\tcase 'p':\n\tcase 'P':\n            RExC_parse--;\n\n            ret = regclass(pRExC_state, flagp,depth+1,\n                           TRUE, /* means just parse this element */\n                           FALSE, /* don't allow multi-char folds */\n                           FALSE, /* don't silence non-portable warnings.  It\n                                     would be a bug if these returned\n                                     non-portables */\n                           (bool) RExC_strict,\n                           TRUE, /* Allow an optimized regnode result */\n                           NULL,\n                           NULL);\n            if (*flagp & RESTART_PASS1)\n                return NULL;\n            /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if\n             * multi-char folds are allowed.  */\n            if (!ret)\n                FAIL2(\"panic: regclass returned NULL to regatom, flags=%#\" UVxf,\n                      (UV) *flagp);\n\n            RExC_parse--;\n\n            Set_Node_Offset(ret, parse_start);\n            Set_Node_Cur_Length(ret, parse_start - 2);\n            nextchar(pRExC_state);\n\t    break;\n        case 'N':\n            /* Handle \\N, \\N{} and \\N{NAMED SEQUENCE} (the latter meaning the\n             * \\N{...} evaluates to a sequence of more than one code points).\n             * The function call below returns a regnode, which is our result.\n             * The parameters cause it to fail if the \\N{} evaluates to a\n             * single code point; we handle those like any other literal.  The\n             * reason that the multicharacter case is handled here and not as\n             * part of the EXACtish code is because of quantifiers.  In\n             * /\\N{BLAH}+/, the '+' applies to the whole thing, and doing it\n             * this way makes that Just Happen. dmq.\n             * join_exact() will join this up with adjacent EXACTish nodes\n             * later on, if appropriate. */\n            ++RExC_parse;\n            if (grok_bslash_N(pRExC_state,\n                              &ret,     /* Want a regnode returned */\n                              NULL,     /* Fail if evaluates to a single code\n                                           point */\n                              NULL,     /* Don't need a count of how many code\n                                           points */\n                              flagp,\n                              RExC_strict,\n                              depth)\n            ) {\n                break;\n            }\n\n            if (*flagp & RESTART_PASS1)\n                return NULL;\n\n            /* Here, evaluates to a single code point.  Go get that */\n            RExC_parse = parse_start;\n            goto defchar;\n\n\tcase 'k':    /* Handle \\k<NAME> and \\k'NAME' */\n      parse_named_seq:\n        {\n            char ch;\n            if (   RExC_parse >= RExC_end - 1\n                || ((   ch = RExC_parse[1]) != '<'\n                                      && ch != '\\''\n                                      && ch != '{'))\n            {\n\t        RExC_parse++;\n\t\t/* diag_listed_as: Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/ */\n\t        vFAIL2(\"Sequence %.2s... not terminated\",parse_start);\n\t    } else {\n\t\tRExC_parse += 2;\n                ret = handle_named_backref(pRExC_state,\n                                           flagp,\n                                           parse_start,\n                                           (ch == '<')\n                                           ? '>'\n                                           : (ch == '{')\n                                             ? '}'\n                                             : '\\'');\n            }\n            break;\n\t}\n\tcase 'g':\n\tcase '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t    {\n\t\tI32 num;\n\t\tbool hasbrace = 0;\n\n\t\tif (*RExC_parse == 'g') {\n                    bool isrel = 0;\n\n\t\t    RExC_parse++;\n\t\t    if (*RExC_parse == '{') {\n\t\t        RExC_parse++;\n\t\t        hasbrace = 1;\n\t\t    }\n\t\t    if (*RExC_parse == '-') {\n\t\t        RExC_parse++;\n\t\t        isrel = 1;\n\t\t    }\n\t\t    if (hasbrace && !isDIGIT(*RExC_parse)) {\n\t\t        if (isrel) RExC_parse--;\n                        RExC_parse -= 2;\n\t\t        goto parse_named_seq;\n                    }\n\n                    if (RExC_parse >= RExC_end) {\n                        goto unterminated_g;\n                    }\n                    num = S_backref_value(RExC_parse);\n                    if (num == 0)\n                        vFAIL(\"Reference to invalid group 0\");\n                    else if (num == I32_MAX) {\n                         if (isDIGIT(*RExC_parse))\n\t\t\t    vFAIL(\"Reference to nonexistent group\");\n                        else\n                          unterminated_g:\n                            vFAIL(\"Unterminated \\\\g... pattern\");\n                    }\n\n                    if (isrel) {\n                        num = RExC_npar - num;\n                        if (num < 1)\n                            vFAIL(\"Reference to nonexistent or unclosed group\");\n                    }\n                }\n                else {\n                    num = S_backref_value(RExC_parse);\n                    /* bare \\NNN might be backref or octal - if it is larger\n                     * than or equal RExC_npar then it is assumed to be an\n                     * octal escape. Note RExC_npar is +1 from the actual\n                     * number of parens. */\n                    /* Note we do NOT check if num == I32_MAX here, as that is\n                     * handled by the RExC_npar check */\n\n                    if (\n                        /* any numeric escape < 10 is always a backref */\n                        num > 9\n                        /* any numeric escape < RExC_npar is a backref */\n                        && num >= RExC_npar\n                        /* cannot be an octal escape if it starts with 8 */\n                        && *RExC_parse != '8'\n                        /* cannot be an octal escape it it starts with 9 */\n                        && *RExC_parse != '9'\n                    )\n                    {\n                        /* Probably not a backref, instead likely to be an\n                         * octal character escape, e.g. \\35 or \\777.\n                         * The above logic should make it obvious why using\n                         * octal escapes in patterns is problematic. - Yves */\n                        RExC_parse = parse_start;\n                        goto defchar;\n                    }\n                }\n\n                /* At this point RExC_parse points at a numeric escape like\n                 * \\12 or \\88 or something similar, which we should NOT treat\n                 * as an octal escape. It may or may not be a valid backref\n                 * escape. For instance \\88888888 is unlikely to be a valid\n                 * backref. */\n                while (isDIGIT(*RExC_parse))\n                    RExC_parse++;\n                if (hasbrace) {\n                    if (*RExC_parse != '}')\n                        vFAIL(\"Unterminated \\\\g{...} pattern\");\n                    RExC_parse++;\n                }\n                if (!SIZE_ONLY) {\n                    if (num > (I32)RExC_rx->nparens)\n                        vFAIL(\"Reference to nonexistent group\");\n                }\n                RExC_sawback = 1;\n                ret = reganode(pRExC_state,\n                               ((! FOLD)\n                                 ? REF\n                                 : (ASCII_FOLD_RESTRICTED)\n                                   ? REFFA\n                                   : (AT_LEAST_UNI_SEMANTICS)\n                                     ? REFFU\n                                     : (LOC)\n                                       ? REFFL\n                                       : REFF),\n                                num);\n                *flagp |= HASWIDTH;\n\n                /* override incorrect value set in reganode MJD */\n                Set_Node_Offset(ret, parse_start);\n                Set_Node_Cur_Length(ret, parse_start-1);\n                skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                        FALSE /* Don't force to /x */ );\n\t    }\n\t    break;\n\tcase '\\0':\n\t    if (RExC_parse >= RExC_end)\n\t\tFAIL(\"Trailing \\\\\");\n\t    /* FALLTHROUGH */\n\tdefault:\n\t    /* Do not generate \"unrecognized\" warnings here, we fall\n\t       back into the quick-grab loop below */\n            RExC_parse = parse_start;\n\t    goto defchar;\n\t} /* end of switch on a \\foo sequence */\n\tbreak;\n\n    case '#':\n\n        /* '#' comments should have been spaced over before this function was\n         * called */\n        assert((RExC_flags & RXf_PMf_EXTENDED) == 0);\n\t/*\n        if (RExC_flags & RXf_PMf_EXTENDED) {\n\t    RExC_parse = reg_skipcomment( pRExC_state, RExC_parse );\n\t    if (RExC_parse < RExC_end)\n\t\tgoto tryagain;\n\t}\n        */\n\n\t/* FALLTHROUGH */\n\n    default:\n\t  defchar: {\n\n            /* Here, we have determined that the next thing is probably a\n             * literal character.  RExC_parse points to the first byte of its\n             * definition.  (It still may be an escape sequence that evaluates\n             * to a single character) */\n\n\t    STRLEN len = 0;\n\t    UV ender = 0;\n\t    char *p;\n\t    char *s;\n#define MAX_NODE_STRING_SIZE 127\n\t    char foldbuf[MAX_NODE_STRING_SIZE+UTF8_MAXBYTES_CASE];\n\t    char *s0;\n\t    U8 upper_parse = MAX_NODE_STRING_SIZE;\n            U8 node_type = compute_EXACTish(pRExC_state);\n            bool next_is_quantifier;\n            char * oldp = NULL;\n\n            /* We can convert EXACTF nodes to EXACTFU if they contain only\n             * characters that match identically regardless of the target\n             * string's UTF8ness.  The reason to do this is that EXACTF is not\n             * trie-able, EXACTFU is.\n             *\n             * Similarly, we can convert EXACTFL nodes to EXACTFLU8 if they\n             * contain only above-Latin1 characters (hence must be in UTF8),\n             * which don't participate in folds with Latin1-range characters,\n             * as the latter's folds aren't known until runtime.  (We don't\n             * need to figure this out until pass 2) */\n            bool maybe_exactfu = PASS2\n                               && (node_type == EXACTF || node_type == EXACTFL);\n\n            /* If a folding node contains only code points that don't\n             * participate in folds, it can be changed into an EXACT node,\n             * which allows the optimizer more things to look for */\n            bool maybe_exact;\n\n\t    ret = reg_node(pRExC_state, node_type);\n\n            /* In pass1, folded, we use a temporary buffer instead of the\n             * actual node, as the node doesn't exist yet */\n\t    s = (SIZE_ONLY && FOLD) ? foldbuf : STRING(ret);\n\n            s0 = s;\n\n\t  reparse:\n\n            /* We look for the EXACTFish to EXACT node optimizaton only if\n             * folding.  (And we don't need to figure this out until pass 2).\n             * XXX It might actually make sense to split the node into portions\n             * that are exact and ones that aren't, so that we could later use\n             * the exact ones to find the longest fixed and floating strings.\n             * One would want to join them back into a larger node.  One could\n             * use a pseudo regnode like 'EXACT_ORIG_FOLD' */\n            maybe_exact = FOLD && PASS2;\n\n\t    /* XXX The node can hold up to 255 bytes, yet this only goes to\n             * 127.  I (khw) do not know why.  Keeping it somewhat less than\n             * 255 allows us to not have to worry about overflow due to\n             * converting to utf8 and fold expansion, but that value is\n             * 255-UTF8_MAXBYTES_CASE.  join_exact() may join adjacent nodes\n             * split up by this limit into a single one using the real max of\n             * 255.  Even at 127, this breaks under rare circumstances.  If\n             * folding, we do not want to split a node at a character that is a\n             * non-final in a multi-char fold, as an input string could just\n             * happen to want to match across the node boundary.  The join\n             * would solve that problem if the join actually happens.  But a\n             * series of more than two nodes in a row each of 127 would cause\n             * the first join to succeed to get to 254, but then there wouldn't\n             * be room for the next one, which could at be one of those split\n             * multi-char folds.  I don't know of any fool-proof solution.  One\n             * could back off to end with only a code point that isn't such a\n             * non-final, but it is possible for there not to be any in the\n             * entire node. */\n\n            assert(   ! UTF     /* Is at the beginning of a character */\n                   || UTF8_IS_INVARIANT(UCHARAT(RExC_parse))\n                   || UTF8_IS_START(UCHARAT(RExC_parse)));\n\n            /* Here, we have a literal character.  Find the maximal string of\n             * them in the input that we can fit into a single EXACTish node.\n             * We quit at the first non-literal or when the node gets full */\n\t    for (p = RExC_parse;\n\t         len < upper_parse && p < RExC_end;\n\t         len++)\n\t    {\n\t\toldp = p;\n\n                /* White space has already been ignored */\n                assert(   (RExC_flags & RXf_PMf_EXTENDED) == 0\n                       || ! is_PATWS_safe((p), RExC_end, UTF));\n\n\t\tswitch ((U8)*p) {\n\t\tcase '^':\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '[':\n\t\tcase '(':\n\t\tcase ')':\n\t\tcase '|':\n\t\t    goto loopdone;\n\t\tcase '\\\\':\n\t\t    /* Literal Escapes Switch\n\n\t\t       This switch is meant to handle escape sequences that\n\t\t       resolve to a literal character.\n\n\t\t       Every escape sequence that represents something\n\t\t       else, like an assertion or a char class, is handled\n\t\t       in the switch marked 'Special Escapes' above in this\n\t\t       routine, but also has an entry here as anything that\n\t\t       isn't explicitly mentioned here will be treated as\n\t\t       an unescaped equivalent literal.\n\t\t    */\n\n\t\t    switch ((U8)*++p) {\n\t\t    /* These are all the special escapes. */\n\t\t    case 'A':             /* Start assertion */\n\t\t    case 'b': case 'B':   /* Word-boundary assertion*/\n\t\t    case 'C':             /* Single char !DANGEROUS! */\n\t\t    case 'd': case 'D':   /* digit class */\n\t\t    case 'g': case 'G':   /* generic-backref, pos assertion */\n\t\t    case 'h': case 'H':   /* HORIZWS */\n\t\t    case 'k': case 'K':   /* named backref, keep marker */\n\t\t    case 'p': case 'P':   /* Unicode property */\n\t\t              case 'R':   /* LNBREAK */\n\t\t    case 's': case 'S':   /* space class */\n\t\t    case 'v': case 'V':   /* VERTWS */\n\t\t    case 'w': case 'W':   /* word class */\n                    case 'X':             /* eXtended Unicode \"combining\n                                             character sequence\" */\n\t\t    case 'z': case 'Z':   /* End of line/string assertion */\n\t\t\t--p;\n\t\t\tgoto loopdone;\n\n\t            /* Anything after here is an escape that resolves to a\n\t               literal. (Except digits, which may or may not)\n\t             */\n\t\t    case 'n':\n\t\t\tender = '\\n';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'N': /* Handle a single-code point named character. */\n                        RExC_parse = p + 1;\n                        if (! grok_bslash_N(pRExC_state,\n                                            NULL,   /* Fail if evaluates to\n                                                       anything other than a\n                                                       single code point */\n                                            &ender, /* The returned single code\n                                                       point */\n                                            NULL,   /* Don't need a count of\n                                                       how many code points */\n                                            flagp,\n                                            RExC_strict,\n                                            depth)\n                        ) {\n                            if (*flagp & NEED_UTF8)\n                                FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n                            if (*flagp & RESTART_PASS1)\n                                return NULL;\n\n                            /* Here, it wasn't a single code point.  Go close\n                             * up this EXACTish node.  The switch() prior to\n                             * this switch handles the other cases */\n                            RExC_parse = p = oldp;\n                            goto loopdone;\n                        }\n                        p = RExC_parse;\n                        RExC_parse = parse_start;\n                        if (ender > 0xff) {\n                            REQUIRE_UTF8(flagp);\n                        }\n                        break;\n\t\t    case 'r':\n\t\t\tender = '\\r';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 't':\n\t\t\tender = '\\t';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'f':\n\t\t\tender = '\\f';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'e':\n\t\t\tender = ESC_NATIVE;\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'a':\n\t\t\tender = '\\a';\n\t\t\tp++;\n\t\t\tbreak;\n\t\t    case 'o':\n\t\t\t{\n\t\t\t    UV result;\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_o(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n\t\t\t\t\t\t       PASS2, /* out warnings */\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Output warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            ender = result;\n\t\t\t    if (ender > 0xff) {\n\t\t\t\tREQUIRE_UTF8(flagp);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'x':\n\t\t\t{\n                            UV result = UV_MAX; /* initialize to erroneous\n                                                   value */\n\t\t\t    const char* error_msg;\n\n\t\t\t    bool valid = grok_bslash_x(&p,\n                                                       RExC_end,\n\t\t\t\t\t\t       &result,\n\t\t\t\t\t\t       &error_msg,\n\t\t\t\t\t\t       PASS2, /* out warnings */\n                                                       (bool) RExC_strict,\n                                                       TRUE, /* Silence warnings\n                                                                for non-\n                                                                portables */\n                                                       UTF);\n\t\t\t    if (! valid) {\n\t\t\t\tRExC_parse = p;\t/* going to die anyway; point\n\t\t\t\t\t\t   to exact spot of failure */\n\t\t\t\tvFAIL(error_msg);\n\t\t\t    }\n                            ender = result;\n\n                            if (ender < 0x100) {\n#ifdef EBCDIC\n                                if (RExC_recode_x_to_native) {\n                                    ender = LATIN1_TO_NATIVE(ender);\n                                }\n#endif\n\t\t\t    }\n                            else {\n\t\t\t\tREQUIRE_UTF8(flagp);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    case 'c':\n\t\t\tp++;\n\t\t\tender = grok_bslash_c(*p++, PASS2);\n\t\t\tbreak;\n                    case '8': case '9': /* must be a backreference */\n                        --p;\n                        /* we have an escape like \\8 which cannot be an octal escape\n                         * so we exit the loop, and let the outer loop handle this\n                         * escape which may or may not be a legitimate backref. */\n                        goto loopdone;\n                    case '1': case '2': case '3':case '4':\n\t\t    case '5': case '6': case '7':\n                        /* When we parse backslash escapes there is ambiguity\n                         * between backreferences and octal escapes. Any escape\n                         * from \\1 - \\9 is a backreference, any multi-digit\n                         * escape which does not start with 0 and which when\n                         * evaluated as decimal could refer to an already\n                         * parsed capture buffer is a back reference. Anything\n                         * else is octal.\n                         *\n                         * Note this implies that \\118 could be interpreted as\n                         * 118 OR as \"\\11\" . \"8\" depending on whether there\n                         * were 118 capture buffers defined already in the\n                         * pattern.  */\n\n                        /* NOTE, RExC_npar is 1 more than the actual number of\n                         * parens we have seen so far, hence the < RExC_npar below. */\n\n                        if ( !isDIGIT(p[1]) || S_backref_value(p) < RExC_npar)\n                        {  /* Not to be treated as an octal constant, go\n                                   find backref */\n                            --p;\n                            goto loopdone;\n                        }\n                        /* FALLTHROUGH */\n                    case '0':\n\t\t\t{\n\t\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n\t\t\t    STRLEN numlen = 3;\n\t\t\t    ender = grok_oct(p, &numlen, &flags, NULL);\n\t\t\t    if (ender > 0xff) {\n\t\t\t\tREQUIRE_UTF8(flagp);\n\t\t\t    }\n\t\t\t    p += numlen;\n                            if (PASS2   /* like \\08, \\178 */\n                                && numlen < 3\n                                && isDIGIT(*p) && ckWARN(WARN_REGEXP))\n                            {\n\t\t\t\treg_warn_non_literal_string(\n                                         p + 1,\n                                         form_short_octal_warning(p, numlen));\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case '\\0':\n\t\t\tif (p >= RExC_end)\n\t\t\t    FAIL(\"Trailing \\\\\");\n\t\t\t/* FALLTHROUGH */\n\t\t    default:\n\t\t\tif (!SIZE_ONLY&& isALPHANUMERIC(*p)) {\n\t\t\t    /* Include any left brace following the alpha to emphasize\n\t\t\t     * that it could be part of an escape at some point\n\t\t\t     * in the future */\n\t\t\t    int len = (isALPHA(*p) && *(p + 1) == '{') ? 2 : 1;\n\t\t\t    ckWARN3reg(p + len, \"Unrecognized escape \\\\%.*s passed through\", len, p);\n\t\t\t}\n\t\t\tgoto normal_default;\n\t\t    } /* End of switch on '\\' */\n\t\t    break;\n\t\tcase '{':\n                    /* Currently we allow an lbrace at the start of a construct\n                     * without raising a warning.  This is because we think we\n                     * will never want such a brace to be meant to be other\n                     * than taken literally. */\n\t\t    if (len || (p > RExC_start && isALPHA_A(*(p - 1)))) {\n\n                        /* But, we raise a fatal warning otherwise, as the\n                         * deprecation cycle has come and gone.  Except that it\n                         * turns out that some heavily-relied on upstream\n                         * software, notably GNU Autoconf, have failed to fix\n                         * their uses.  For these, don't make it fatal unless\n                         * we anticipate using the '{' for something else.\n                         * This happens after any alpha, and for a looser {m,n}\n                         * quantifier specification */\n                        if (      RExC_strict\n                            || (  p > parse_start + 1\n                                && isALPHA_A(*(p - 1))\n                                && *(p - 2) == '\\\\')\n                            || new_regcurly(p, RExC_end))\n                        {\n                            RExC_parse = p + 1;\n                            vFAIL(\"Unescaped left brace in regex is \"\n                                  \"illegal here\");\n                        }\n                        if (PASS2) {\n                            ckWARNregdep(p + 1,\n                                        \"Unescaped left brace in regex is \"\n                                        \"deprecated here (and will be fatal \"\n                                        \"in Perl 5.30), passed through\");\n                        }\n\t\t    }\n\t\t    goto normal_default;\n                case '}':\n                case ']':\n                    if (PASS2 && p > RExC_parse && RExC_strict) {\n                        ckWARN2reg(p + 1, \"Unescaped literal '%c'\", *p);\n                    }\n\t\t    /*FALLTHROUGH*/\n\t\tdefault:    /* A literal character */\n\t\t  normal_default:\n\t\t    if (! UTF8_IS_INVARIANT(*p) && UTF) {\n\t\t\tSTRLEN numlen;\n\t\t\tender = utf8n_to_uvchr((U8*)p, RExC_end - p,\n\t\t\t\t\t       &numlen, UTF8_ALLOW_DEFAULT);\n\t\t\tp += numlen;\n\t\t    }\n\t\t    else\n\t\t\tender = (U8) *p++;\n\t\t    break;\n\t\t} /* End of switch on the literal */\n\n\t\t/* Here, have looked at the literal character and <ender>\n                 * contains its ordinal, <p> points to the character after it.\n                 * We need to check if the next non-ignored thing is a\n                 * quantifier.  Move <p> to after anything that should be\n                 * ignored, which, as a side effect, positions <p> for the next\n                 * loop iteration */\n                skip_to_be_ignored_text(pRExC_state, &p,\n                                        FALSE /* Don't force to /x */ );\n\n                /* If the next thing is a quantifier, it applies to this\n                 * character only, which means that this character has to be in\n                 * its own node and can't just be appended to the string in an\n                 * existing node, so if there are already other characters in\n                 * the node, close the node with just them, and set up to do\n                 * this character again next time through, when it will be the\n                 * only thing in its new node */\n\n                next_is_quantifier =    LIKELY(p < RExC_end)\n                                     && UNLIKELY(ISMULT2(p));\n\n                if (next_is_quantifier && LIKELY(len)) {\n                    p = oldp;\n                    goto loopdone;\n                }\n\n                /* Ready to add 'ender' to the node */\n\n                if (! FOLD) {  /* The simple case, just append the literal */\n\n                    /* In the sizing pass, we need only the size of the\n                     * character we are appending, hence we can delay getting\n                     * its representation until PASS2. */\n                    if (SIZE_ONLY) {\n                        if (UTF && ! UVCHR_IS_INVARIANT(ender)) {\n                            const STRLEN unilen = UVCHR_SKIP(ender);\n                            s += unilen;\n\n                            /* We have to subtract 1 just below (and again in\n                             * the corresponding PASS2 code) because the loop\n                             * increments <len> each time, as all but this path\n                             * (and one other) through it add a single byte to\n                             * the EXACTish node.  But these paths would change\n                             * len to be the correct final value, so cancel out\n                             * the increment that follows */\n                            len += unilen - 1;\n                        }\n                        else {\n                            s++;\n                        }\n                    } else { /* PASS2 */\n                      not_fold_common:\n                        if (UTF && ! UVCHR_IS_INVARIANT(ender)) {\n                            U8 * new_s = uvchr_to_utf8((U8*)s, ender);\n                            len += (char *) new_s - s - 1;\n                            s = (char *) new_s;\n                        }\n                        else {\n                            *(s++) = (char) ender;\n                        }\n                    }\n                }\n                else if (LOC && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)) {\n\n                    /* Here are folding under /l, and the code point is\n                     * problematic.  First, we know we can't simplify things */\n                    maybe_exact = FALSE;\n                    maybe_exactfu = FALSE;\n\n                    /* A problematic code point in this context means that its\n                     * fold isn't known until runtime, so we can't fold it now.\n                     * (The non-problematic code points are the above-Latin1\n                     * ones that fold to also all above-Latin1.  Their folds\n                     * don't vary no matter what the locale is.) But here we\n                     * have characters whose fold depends on the locale.\n                     * Unlike the non-folding case above, we have to keep track\n                     * of these in the sizing pass, so that we can make sure we\n                     * don't split too-long nodes in the middle of a potential\n                     * multi-char fold.  And unlike the regular fold case\n                     * handled in the else clauses below, we don't actually\n                     * fold and don't have special cases to consider.  What we\n                     * do for both passes is the PASS2 code for non-folding */\n                    goto not_fold_common;\n                }\n                else /* A regular FOLD code point */\n                    if (! (   UTF\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n                            /* See comments for join_exact() as to why we fold\n                             * this non-UTF at compile time */\n                            || (   node_type == EXACTFU\n                                && ender == LATIN_SMALL_LETTER_SHARP_S)\n#endif\n                )) {\n                    /* Here, are folding and are not UTF-8 encoded; therefore\n                     * the character must be in the range 0-255, and is not /l\n                     * (Not /l because we already handled these under /l in\n                     * is_PROBLEMATIC_LOCALE_FOLD_cp) */\n                    if (IS_IN_SOME_FOLD_L1(ender)) {\n                        maybe_exact = FALSE;\n\n                        /* See if the character's fold differs between /d and\n                         * /u.  This includes the multi-char fold SHARP S to\n                         * 'ss' */\n                        if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {\n                            RExC_seen_unfolded_sharp_s = 1;\n                            maybe_exactfu = FALSE;\n                        }\n                        else if (maybe_exactfu\n                            && (PL_fold[ender] != PL_fold_latin1[ender]\n#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \\\n   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \\\n                                      || UNICODE_DOT_DOT_VERSION > 0)\n                                || (   len > 0\n                                    && isALPHA_FOLD_EQ(ender, 's')\n                                    && isALPHA_FOLD_EQ(*(s-1), 's'))\n#endif\n                        )) {\n                            maybe_exactfu = FALSE;\n                        }\n                    }\n\n                    /* Even when folding, we store just the input character, as\n                     * we have an array that finds its fold quickly */\n                    *(s++) = (char) ender;\n                }\n                else {  /* FOLD, and UTF (or sharp s) */\n                    /* Unlike the non-fold case, we do actually have to\n                     * calculate the results here in pass 1.  This is for two\n                     * reasons, the folded length may be longer than the\n                     * unfolded, and we have to calculate how many EXACTish\n                     * nodes it will take; and we may run out of room in a node\n                     * in the middle of a potential multi-char fold, and have\n                     * to back off accordingly.  */\n\n                    UV folded;\n                    if (isASCII_uni(ender)) {\n                        folded = toFOLD(ender);\n                        *(s)++ = (U8) folded;\n                    }\n                    else {\n                        STRLEN foldlen;\n\n                        folded = _to_uni_fold_flags(\n                                     ender,\n                                     (U8 *) s,\n                                     &foldlen,\n                                     FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)\n                                                        ? FOLD_FLAGS_NOMIX_ASCII\n                                                        : 0));\n                        s += foldlen;\n\n                        /* The loop increments <len> each time, as all but this\n                         * path (and one other) through it add a single byte to\n                         * the EXACTish node.  But this one has changed len to\n                         * be the correct final value, so subtract one to\n                         * cancel out the increment that follows */\n                        len += foldlen - 1;\n                    }\n                    /* If this node only contains non-folding code points so\n                     * far, see if this new one is also non-folding */\n                    if (maybe_exact) {\n                        if (folded != ender) {\n                            maybe_exact = FALSE;\n                        }\n                        else {\n                            /* Here the fold is the original; we have to check\n                             * further to see if anything folds to it */\n                            if (_invlist_contains_cp(PL_utf8_foldable,\n                                                        ender))\n                            {\n                                maybe_exact = FALSE;\n                            }\n                        }\n                    }\n                    ender = folded;\n\t\t}\n\n\t\tif (next_is_quantifier) {\n\n                    /* Here, the next input is a quantifier, and to get here,\n                     * the current character is the only one in the node.\n                     * Also, here <len> doesn't include the final byte for this\n                     * character */\n                    len++;\n                    goto loopdone;\n\t\t}\n\n\t    } /* End of loop through literal characters */\n\n            /* Here we have either exhausted the input or ran out of room in\n             * the node.  (If we encountered a character that can't be in the\n             * node, transfer is made directly to <loopdone>, and so we\n             * wouldn't have fallen off the end of the loop.)  In the latter\n             * case, we artificially have to split the node into two, because\n             * we just don't have enough space to hold everything.  This\n             * creates a problem if the final character participates in a\n             * multi-character fold in the non-final position, as a match that\n             * should have occurred won't, due to the way nodes are matched,\n             * and our artificial boundary.  So back off until we find a non-\n             * problematic character -- one that isn't at the beginning or\n             * middle of such a fold.  (Either it doesn't participate in any\n             * folds, or appears only in the final position of all the folds it\n             * does participate in.)  A better solution with far fewer false\n             * positives, and that would fill the nodes more completely, would\n             * be to actually have available all the multi-character folds to\n             * test against, and to back-off only far enough to be sure that\n             * this node isn't ending with a partial one.  <upper_parse> is set\n             * further below (if we need to reparse the node) to include just\n             * up through that final non-problematic character that this code\n             * identifies, so when it is set to less than the full node, we can\n             * skip the rest of this */\n            if (FOLD && p < RExC_end && upper_parse == MAX_NODE_STRING_SIZE) {\n\n                const STRLEN full_len = len;\n\n\t\tassert(len >= MAX_NODE_STRING_SIZE);\n\n                /* Here, <s> points to the final byte of the final character.\n                 * Look backwards through the string until find a non-\n                 * problematic character */\n\n\t\tif (! UTF) {\n\n                    /* This has no multi-char folds to non-UTF characters */\n                    if (ASCII_FOLD_RESTRICTED) {\n                        goto loopdone;\n                    }\n\n                    while (--s >= s0 && IS_NON_FINAL_FOLD(*s)) { }\n                    len = s - s0 + 1;\n\t\t}\n                else {\n                    if (!  PL_NonL1NonFinalFold) {\n                        PL_NonL1NonFinalFold = _new_invlist_C_array(\n                                        NonL1_Perl_Non_Final_Folds_invlist);\n                    }\n\n                    /* Point to the first byte of the final character */\n                    s = (char *) utf8_hop((U8 *) s, -1);\n\n                    while (s >= s0) {   /* Search backwards until find\n                                           non-problematic char */\n                        if (UTF8_IS_INVARIANT(*s)) {\n\n                            /* There are no ascii characters that participate\n                             * in multi-char folds under /aa.  In EBCDIC, the\n                             * non-ascii invariants are all control characters,\n                             * so don't ever participate in any folds. */\n                            if (ASCII_FOLD_RESTRICTED\n                                || ! IS_NON_FINAL_FOLD(*s))\n                            {\n                                break;\n                            }\n                        }\n                        else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {\n                            if (! IS_NON_FINAL_FOLD(EIGHT_BIT_UTF8_TO_NATIVE(\n                                                                  *s, *(s+1))))\n                            {\n                                break;\n                            }\n                        }\n                        else if (! _invlist_contains_cp(\n                                        PL_NonL1NonFinalFold,\n                                        valid_utf8_to_uvchr((U8 *) s, NULL)))\n                        {\n                            break;\n                        }\n\n                        /* Here, the current character is problematic in that\n                         * it does occur in the non-final position of some\n                         * fold, so try the character before it, but have to\n                         * special case the very first byte in the string, so\n                         * we don't read outside the string */\n                        s = (s == s0) ? s -1 : (char *) utf8_hop((U8 *) s, -1);\n                    } /* End of loop backwards through the string */\n\n                    /* If there were only problematic characters in the string,\n                     * <s> will point to before s0, in which case the length\n                     * should be 0, otherwise include the length of the\n                     * non-problematic character just found */\n                    len = (s < s0) ? 0 : s - s0 + UTF8SKIP(s);\n\t\t}\n\n                /* Here, have found the final character, if any, that is\n                 * non-problematic as far as ending the node without splitting\n                 * it across a potential multi-char fold.  <len> contains the\n                 * number of bytes in the node up-to and including that\n                 * character, or is 0 if there is no such character, meaning\n                 * the whole node contains only problematic characters.  In\n                 * this case, give up and just take the node as-is.  We can't\n                 * do any better */\n                if (len == 0) {\n                    len = full_len;\n\n                    /* If the node ends in an 's' we make sure it stays EXACTF,\n                     * as if it turns into an EXACTFU, it could later get\n                     * joined with another 's' that would then wrongly match\n                     * the sharp s */\n                    if (maybe_exactfu && isALPHA_FOLD_EQ(ender, 's'))\n                    {\n                        maybe_exactfu = FALSE;\n                    }\n                } else {\n\n                    /* Here, the node does contain some characters that aren't\n                     * problematic.  If one such is the final character in the\n                     * node, we are done */\n                    if (len == full_len) {\n                        goto loopdone;\n                    }\n                    else if (len + ((UTF) ? UTF8SKIP(s) : 1) == full_len) {\n\n                        /* If the final character is problematic, but the\n                         * penultimate is not, back-off that last character to\n                         * later start a new node with it */\n                        p = oldp;\n                        goto loopdone;\n                    }\n\n                    /* Here, the final non-problematic character is earlier\n                     * in the input than the penultimate character.  What we do\n                     * is reparse from the beginning, going up only as far as\n                     * this final ok one, thus guaranteeing that the node ends\n                     * in an acceptable character.  The reason we reparse is\n                     * that we know how far in the character is, but we don't\n                     * know how to correlate its position with the input parse.\n                     * An alternate implementation would be to build that\n                     * correlation as we go along during the original parse,\n                     * but that would entail extra work for every node, whereas\n                     * this code gets executed only when the string is too\n                     * large for the node, and the final two characters are\n                     * problematic, an infrequent occurrence.  Yet another\n                     * possible strategy would be to save the tail of the\n                     * string, and the next time regatom is called, initialize\n                     * with that.  The problem with this is that unless you\n                     * back off one more character, you won't be guaranteed\n                     * regatom will get called again, unless regbranch,\n                     * regpiece ... are also changed.  If you do back off that\n                     * extra character, so that there is input guaranteed to\n                     * force calling regatom, you can't handle the case where\n                     * just the first character in the node is acceptable.  I\n                     * (khw) decided to try this method which doesn't have that\n                     * pitfall; if performance issues are found, we can do a\n                     * combination of the current approach plus that one */\n                    upper_parse = len;\n                    len = 0;\n                    s = s0;\n                    goto reparse;\n                }\n\t    }   /* End of verifying node ends with an appropriate char */\n\n          loopdone:   /* Jumped to when encounters something that shouldn't be\n                         in the node */\n\n            /* I (khw) don't know if you can get here with zero length, but the\n             * old code handled this situation by creating a zero-length EXACT\n             * node.  Might as well be NOTHING instead */\n            if (len == 0) {\n                OP(ret) = NOTHING;\n            }\n            else {\n                if (FOLD) {\n                    /* If 'maybe_exact' is still set here, means there are no\n                     * code points in the node that participate in folds;\n                     * similarly for 'maybe_exactfu' and code points that match\n                     * differently depending on UTF8ness of the target string\n                     * (for /u), or depending on locale for /l */\n                    if (maybe_exact) {\n                        OP(ret) = (LOC)\n                                  ? EXACTL\n                                  : EXACT;\n                    }\n                    else if (maybe_exactfu) {\n                        OP(ret) = (LOC)\n                                  ? EXACTFLU8\n                                  : EXACTFU;\n                    }\n                }\n                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, len, ender,\n                                           FALSE /* Don't look to see if could\n                                                    be turned into an EXACT\n                                                    node, as we have already\n                                                    computed that */\n                                          );\n            }\n\n\t    RExC_parse = p - 1;\n            Set_Node_Cur_Length(ret, parse_start);\n\t    RExC_parse = p;\n\t    {\n\t\t/* len is STRLEN which is unsigned, need to copy to signed */\n\t\tIV iv = len;\n\t\tif (iv < 0)\n\t\t    vFAIL(\"Internal disaster\");\n\t    }\n\n\t} /* End of label 'defchar:' */\n\tbreak;\n    } /* End of giant switch on input character */\n\n    /* Position parse to next real character */\n    skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                            FALSE /* Don't force to /x */ );\n    if (PASS2 && *RExC_parse == '{' && OP(ret) != SBOL && ! regcurly(RExC_parse)) {\n        ckWARNregdep(RExC_parse + 1, \"Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through\");\n    }\n\n    return(ret);\n}\n\n\nSTATIC void\nS_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)\n{\n    /* Uses the inversion list '*invlist_ptr' to populate the ANYOF 'node'.  It\n     * sets up the bitmap and any flags, removing those code points from the\n     * inversion list, setting it to NULL should it become completely empty */\n\n    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;\n    assert(PL_regkind[OP(node)] == ANYOF);\n\n    ANYOF_BITMAP_ZERO(node);\n    if (*invlist_ptr) {\n\n\t/* This gets set if we actually need to modify things */\n\tbool change_invlist = FALSE;\n\n\tUV start, end;\n\n\t/* Start looking through *invlist_ptr */\n\tinvlist_iterinit(*invlist_ptr);\n\twhile (invlist_iternext(*invlist_ptr, &start, &end)) {\n\t    UV high;\n\t    int i;\n\n            if (end == UV_MAX && start <= NUM_ANYOF_CODE_POINTS) {\n                ANYOF_FLAGS(node) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;\n            }\n\n\t    /* Quit if are above what we should change */\n\t    if (start >= NUM_ANYOF_CODE_POINTS) {\n\t\tbreak;\n\t    }\n\n\t    change_invlist = TRUE;\n\n\t    /* Set all the bits in the range, up to the max that we are doing */\n\t    high = (end < NUM_ANYOF_CODE_POINTS - 1)\n                   ? end\n                   : NUM_ANYOF_CODE_POINTS - 1;\n\t    for (i = start; i <= (int) high; i++) {\n\t\tif (! ANYOF_BITMAP_TEST(node, i)) {\n\t\t    ANYOF_BITMAP_SET(node, i);\n\t\t}\n\t    }\n\t}\n\tinvlist_iterfinish(*invlist_ptr);\n\n        /* Done with loop; remove any code points that are in the bitmap from\n         * *invlist_ptr; similarly for code points above the bitmap if we have\n         * a flag to match all of them anyways */\n\tif (change_invlist) {\n\t    _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n        if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n\t    _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n\n\t/* If have completely emptied it, remove it completely */\n\tif (_invlist_len(*invlist_ptr) == 0) {\n\t    SvREFCNT_dec_NN(*invlist_ptr);\n\t    *invlist_ptr = NULL;\n\t}\n    }\n}\n\n/* Parse POSIX character classes: [[:foo:]], [[=foo=]], [[.foo.]].\n   Character classes ([:foo:]) can also be negated ([:^foo:]).\n   Returns a named class id (ANYOF_XXX) if successful, -1 otherwise.\n   Equivalence classes ([=foo=]) and composites ([.foo.]) are parsed,\n   but trigger failures because they are currently unimplemented. */\n\n#define POSIXCC_DONE(c)   ((c) == ':')\n#define POSIXCC_NOTYET(c) ((c) == '=' || (c) == '.')\n#define POSIXCC(c) (POSIXCC_DONE(c) || POSIXCC_NOTYET(c))\n#define MAYBE_POSIXCC(c) (POSIXCC(c) || (c) == '^' || (c) == ';')\n\n#define WARNING_PREFIX              \"Assuming NOT a POSIX class since \"\n#define NO_BLANKS_POSIX_WARNING     \"no blanks are allowed in one\"\n#define SEMI_COLON_POSIX_WARNING    \"a semi-colon was found instead of a colon\"\n\n#define NOT_MEANT_TO_BE_A_POSIX_CLASS (OOB_NAMEDCLASS - 1)\n\n/* 'posix_warnings' and 'warn_text' are names of variables in the following\n * routine. q.v. */\n#define ADD_POSIX_WARNING(p, text)  STMT_START {                            \\\n        if (posix_warnings) {                                               \\\n            if (! RExC_warn_text ) RExC_warn_text = (AV *) sv_2mortal((SV *) newAV()); \\\n            av_push(RExC_warn_text, Perl_newSVpvf(aTHX_                          \\\n                                             WARNING_PREFIX                 \\\n                                             text                           \\\n                                             REPORT_LOCATION,               \\\n                                             REPORT_LOCATION_ARGS(p)));     \\\n        }                                                                   \\\n    } STMT_END\n#define CLEAR_POSIX_WARNINGS()                                              \\\n    STMT_START {                                                            \\\n        if (posix_warnings && RExC_warn_text)                               \\\n            av_clear(RExC_warn_text);                                       \\\n    } STMT_END\n\n#define CLEAR_POSIX_WARNINGS_AND_RETURN(ret)                                \\\n    STMT_START {                                                            \\\n        CLEAR_POSIX_WARNINGS();                                             \\\n        return ret;                                                         \\\n    } STMT_END\n\nSTATIC int\nS_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state,\n\n    const char * const s,      /* Where the putative posix class begins.\n                                  Normally, this is one past the '['.  This\n                                  parameter exists so it can be somewhere\n                                  besides RExC_parse. */\n    char ** updated_parse_ptr, /* Where to set the updated parse pointer, or\n                                  NULL */\n    AV ** posix_warnings,      /* Where to place any generated warnings, or\n                                  NULL */\n    const bool check_only      /* Don't die if error */\n)\n{\n    /* This parses what the caller thinks may be one of the three POSIX\n     * constructs:\n     *  1) a character class, like [:blank:]\n     *  2) a collating symbol, like [. .]\n     *  3) an equivalence class, like [= =]\n     * In the latter two cases, it croaks if it finds a syntactically legal\n     * one, as these are not handled by Perl.\n     *\n     * The main purpose is to look for a POSIX character class.  It returns:\n     *  a) the class number\n     *      if it is a completely syntactically and semantically legal class.\n     *      'updated_parse_ptr', if not NULL, is set to point to just after the\n     *      closing ']' of the class\n     *  b) OOB_NAMEDCLASS\n     *      if it appears that one of the three POSIX constructs was meant, but\n     *      its specification was somehow defective.  'updated_parse_ptr', if\n     *      not NULL, is set to point to the character just after the end\n     *      character of the class.  See below for handling of warnings.\n     *  c) NOT_MEANT_TO_BE_A_POSIX_CLASS\n     *      if it  doesn't appear that a POSIX construct was intended.\n     *      'updated_parse_ptr' is not changed.  No warnings nor errors are\n     *      raised.\n     *\n     * In b) there may be errors or warnings generated.  If 'check_only' is\n     * TRUE, then any errors are discarded.  Warnings are returned to the\n     * caller via an AV* created into '*posix_warnings' if it is not NULL.  If\n     * instead it is NULL, warnings are suppressed.  This is done in all\n     * passes.  The reason for this is that the rest of the parsing is heavily\n     * dependent on whether this routine found a valid posix class or not.  If\n     * it did, the closing ']' is absorbed as part of the class.  If no class,\n     * or an invalid one is found, any ']' will be considered the terminator of\n     * the outer bracketed character class, leading to very different results.\n     * In particular, a '(?[ ])' construct will likely have a syntax error if\n     * the class is parsed other than intended, and this will happen in pass1,\n     * before the warnings would normally be output.  This mechanism allows the\n     * caller to output those warnings in pass1 just before dieing, giving a\n     * much better clue as to what is wrong.\n     *\n     * The reason for this function, and its complexity is that a bracketed\n     * character class can contain just about anything.  But it's easy to\n     * mistype the very specific posix class syntax but yielding a valid\n     * regular bracketed class, so it silently gets compiled into something\n     * quite unintended.\n     *\n     * The solution adopted here maintains backward compatibility except that\n     * it adds a warning if it looks like a posix class was intended but\n     * improperly specified.  The warning is not raised unless what is input\n     * very closely resembles one of the 14 legal posix classes.  To do this,\n     * it uses fuzzy parsing.  It calculates how many single-character edits it\n     * would take to transform what was input into a legal posix class.  Only\n     * if that number is quite small does it think that the intention was a\n     * posix class.  Obviously these are heuristics, and there will be cases\n     * where it errs on one side or another, and they can be tweaked as\n     * experience informs.\n     *\n     * The syntax for a legal posix class is:\n     *\n     * qr/(?xa: \\[ : \\^? [[:lower:]]{4,6} : \\] )/\n     *\n     * What this routine considers syntactically to be an intended posix class\n     * is this (the comments indicate some restrictions that the pattern\n     * doesn't show):\n     *\n     *  qr/(?x: \\[?                         # The left bracket, possibly\n     *                                      # omitted\n     *          \\h*                         # possibly followed by blanks\n     *          (?: \\^ \\h* )?               # possibly a misplaced caret\n     *          [:;]?                       # The opening class character,\n     *                                      # possibly omitted.  A typo\n     *                                      # semi-colon can also be used.\n     *          \\h*\n     *          \\^?                         # possibly a correctly placed\n     *                                      # caret, but not if there was also\n     *                                      # a misplaced one\n     *          \\h*\n     *          .{3,15}                     # The class name.  If there are\n     *                                      # deviations from the legal syntax,\n     *                                      # its edit distance must be close\n     *                                      # to a real class name in order\n     *                                      # for it to be considered to be\n     *                                      # an intended posix class.\n     *          \\h*\n     *          [[:punct:]]?                # The closing class character,\n     *                                      # possibly omitted.  If not a colon\n     *                                      # nor semi colon, the class name\n     *                                      # must be even closer to a valid\n     *                                      # one\n     *          \\h*\n     *          \\]?                         # The right bracket, possibly\n     *                                      # omitted.\n     *     )/\n     *\n     * In the above, \\h must be ASCII-only.\n     *\n     * These are heuristics, and can be tweaked as field experience dictates.\n     * There will be cases when someone didn't intend to specify a posix class\n     * that this warns as being so.  The goal is to minimize these, while\n     * maximizing the catching of things intended to be a posix class that\n     * aren't parsed as such.\n     */\n\n    const char* p             = s;\n    const char * const e      = RExC_end;\n    unsigned complement       = 0;      /* If to complement the class */\n    bool found_problem        = FALSE;  /* Assume OK until proven otherwise */\n    bool has_opening_bracket  = FALSE;\n    bool has_opening_colon    = FALSE;\n    int class_number          = OOB_NAMEDCLASS; /* Out-of-bounds until find\n                                                   valid class */\n    const char * possible_end = NULL;   /* used for a 2nd parse pass */\n    const char* name_start;             /* ptr to class name first char */\n\n    /* If the number of single-character typos the input name is away from a\n     * legal name is no more than this number, it is considered to have meant\n     * the legal name */\n    int max_distance          = 2;\n\n    /* to store the name.  The size determines the maximum length before we\n     * decide that no posix class was intended.  Should be at least\n     * sizeof(\"alphanumeric\") */\n    UV input_text[15];\n    STATIC_ASSERT_DECL(C_ARRAY_LENGTH(input_text) >= sizeof \"alphanumeric\");\n\n    PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX;\n\n    CLEAR_POSIX_WARNINGS();\n\n    if (p >= e) {\n        return NOT_MEANT_TO_BE_A_POSIX_CLASS;\n    }\n\n    if (*(p - 1) != '[') {\n        ADD_POSIX_WARNING(p, \"it doesn't start with a '['\");\n        found_problem = TRUE;\n    }\n    else {\n        has_opening_bracket = TRUE;\n    }\n\n    /* They could be confused and think you can put spaces between the\n     * components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    /* For [. .] and [= =].  These are quite different internally from [: :],\n     * so they are handled separately.  */\n    if (POSIXCC_NOTYET(*p) && p < e - 3) /* 1 for the close, and 1 for the ']'\n                                            and 1 for at least one char in it\n                                          */\n    {\n        const char open_char  = *p;\n        const char * temp_ptr = p + 1;\n\n        /* These two constructs are not handled by perl, and if we find a\n         * syntactically valid one, we croak.  khw, who wrote this code, finds\n         * this explanation of them very unclear:\n         * http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap09.html\n         * And searching the rest of the internet wasn't very helpful either.\n         * It looks like just about any byte can be in these constructs,\n         * depending on the locale.  But unless the pattern is being compiled\n         * under /l, which is very rare, Perl runs under the C or POSIX locale.\n         * In that case, it looks like [= =] isn't allowed at all, and that\n         * [. .] could be any single code point, but for longer strings the\n         * constituent characters would have to be the ASCII alphabetics plus\n         * the minus-hyphen.  Any sensible locale definition would limit itself\n         * to these.  And any portable one definitely should.  Trying to parse\n         * the general case is a nightmare (see [perl #127604]).  So, this code\n         * looks only for interiors of these constructs that match:\n         *      qr/.|[-\\w]{2,}/\n         * Using \\w relaxes the apparent rules a little, without adding much\n         * danger of mistaking something else for one of these constructs.\n         *\n         * [. .] in some implementations described on the internet is usable to\n         * escape a character that otherwise is special in bracketed character\n         * classes.  For example [.].] means a literal right bracket instead of\n         * the ending of the class\n         *\n         * [= =] can legitimately contain a [. .] construct, but we don't\n         * handle this case, as that [. .] construct will later get parsed\n         * itself and croak then.  And [= =] is checked for even when not under\n         * /l, as Perl has long done so.\n         *\n         * The code below relies on there being a trailing NUL, so it doesn't\n         * have to keep checking if the parse ptr < e.\n         */\n        if (temp_ptr[1] == open_char) {\n            temp_ptr++;\n        }\n        else while (    temp_ptr < e\n                    && (isWORDCHAR(*temp_ptr) || *temp_ptr == '-'))\n        {\n            temp_ptr++;\n        }\n\n        if (*temp_ptr == open_char) {\n            temp_ptr++;\n            if (*temp_ptr == ']') {\n                temp_ptr++;\n                if (! found_problem && ! check_only) {\n                    RExC_parse = (char *) temp_ptr;\n                    vFAIL3(\"POSIX syntax [%c %c] is reserved for future \"\n                            \"extensions\", open_char, open_char);\n                }\n\n                /* Here, the syntax wasn't completely valid, or else the call\n                 * is to check-only */\n                if (updated_parse_ptr) {\n                    *updated_parse_ptr = (char *) temp_ptr;\n                }\n\n                CLEAR_POSIX_WARNINGS_AND_RETURN(OOB_NAMEDCLASS);\n            }\n        }\n\n        /* If we find something that started out to look like one of these\n         * constructs, but isn't, we continue below so that it can be checked\n         * for being a class name with a typo of '.' or '=' instead of a colon.\n         * */\n    }\n\n    /* Here, we think there is a possibility that a [: :] class was meant, and\n     * we have the first real character.  It could be they think the '^' comes\n     * first */\n    if (*p == '^') {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p + 1, \"the '^' must come after the colon\");\n        complement = 1;\n        p++;\n\n        if (isBLANK(*p)) {\n            found_problem = TRUE;\n\n            do {\n                p++;\n            } while (p < e && isBLANK(*p));\n\n            ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n        }\n    }\n\n    /* But the first character should be a colon, which they could have easily\n     * mistyped on a qwerty keyboard as a semi-colon (and which may be hard to\n     * distinguish from a colon, so treat that as a colon).  */\n    if (*p == ':') {\n        p++;\n        has_opening_colon = TRUE;\n    }\n    else if (*p == ';') {\n        found_problem = TRUE;\n        p++;\n        ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        has_opening_colon = TRUE;\n    }\n    else {\n        found_problem = TRUE;\n        ADD_POSIX_WARNING(p, \"there must be a starting ':'\");\n\n        /* Consider an initial punctuation (not one of the recognized ones) to\n         * be a left terminator */\n        if (*p != '^' && *p != ']' && isPUNCT(*p)) {\n            p++;\n        }\n    }\n\n    /* They may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == '^') {\n\n        /* We consider something like [^:^alnum:]] to not have been intended to\n         * be a posix class, but XXX maybe we should */\n        if (complement) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        complement = 1;\n        p++;\n    }\n\n    /* Again, they may think that you can put spaces between the components */\n    if (isBLANK(*p)) {\n        found_problem = TRUE;\n\n        do {\n            p++;\n        } while (p < e && isBLANK(*p));\n\n        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n    }\n\n    if (*p == ']') {\n\n        /* XXX This ']' may be a typo, and something else was meant.  But\n         * treating it as such creates enough complications, that that\n         * possibility isn't currently considered here.  So we assume that the\n         * ']' is what is intended, and if we've already found an initial '[',\n         * this leaves this construct looking like [:] or [:^], which almost\n         * certainly weren't intended to be posix classes */\n        if (has_opening_bracket) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* But this function can be called when we parse the colon for\n         * something like qr/[alpha:]]/, so we back up to look for the\n         * beginning */\n        p--;\n\n        if (*p == ';') {\n            found_problem = TRUE;\n            ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n        }\n        else if (*p != ':') {\n\n            /* XXX We are currently very restrictive here, so this code doesn't\n             * consider the possibility that, say, /[alpha.]]/ was intended to\n             * be a posix class. */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Here we have something like 'foo:]'.  There was no initial colon,\n         * and we back up over 'foo.  XXX Unlike the going forward case, we\n         * don't handle typos of non-word chars in the middle */\n        has_opening_colon = FALSE;\n        p--;\n\n        while (p > RExC_start && isWORDCHAR(*p)) {\n            p--;\n        }\n        p++;\n\n        /* Here, we have positioned ourselves to where we think the first\n         * character in the potential class is */\n    }\n\n    /* Now the interior really starts.  There are certain key characters that\n     * can end the interior, or these could just be typos.  To catch both\n     * cases, we may have to do two passes.  In the first pass, we keep on\n     * going unless we come to a sequence that matches\n     *      qr/ [[:punct:]] [[:blank:]]* \\] /xa\n     * This means it takes a sequence to end the pass, so two typos in a row if\n     * that wasn't what was intended.  If the class is perfectly formed, just\n     * this one pass is needed.  We also stop if there are too many characters\n     * being accumulated, but this number is deliberately set higher than any\n     * real class.  It is set high enough so that someone who thinks that\n     * 'alphanumeric' is a correct name would get warned that it wasn't.\n     * While doing the pass, we keep track of where the key characters were in\n     * it.  If we don't find an end to the class, and one of the key characters\n     * was found, we redo the pass, but stop when we get to that character.\n     * Thus the key character was considered a typo in the first pass, but a\n     * terminator in the second.  If two key characters are found, we stop at\n     * the second one in the first pass.  Again this can miss two typos, but\n     * catches a single one\n     *\n     * In the first pass, 'possible_end' starts as NULL, and then gets set to\n     * point to the first key character.  For the second pass, it starts as -1.\n     * */\n\n    name_start = p;\n  parse_name:\n    {\n        bool has_blank               = FALSE;\n        bool has_upper               = FALSE;\n        bool has_terminating_colon   = FALSE;\n        bool has_terminating_bracket = FALSE;\n        bool has_semi_colon          = FALSE;\n        unsigned int name_len        = 0;\n        int punct_count              = 0;\n\n        while (p < e) {\n\n            /* Squeeze out blanks when looking up the class name below */\n            if (isBLANK(*p) ) {\n                has_blank = TRUE;\n                found_problem = TRUE;\n                p++;\n                continue;\n            }\n\n            /* The name will end with a punctuation */\n            if (isPUNCT(*p)) {\n                const char * peek = p + 1;\n\n                /* Treat any non-']' punctuation followed by a ']' (possibly\n                 * with intervening blanks) as trying to terminate the class.\n                 * ']]' is very likely to mean a class was intended (but\n                 * missing the colon), but the warning message that gets\n                 * generated shows the error position better if we exit the\n                 * loop at the bottom (eventually), so skip it here. */\n                if (*p != ']') {\n                    if (peek < e && isBLANK(*peek)) {\n                        has_blank = TRUE;\n                        found_problem = TRUE;\n                        do {\n                            peek++;\n                        } while (peek < e && isBLANK(*peek));\n                    }\n\n                    if (peek < e && *peek == ']') {\n                        has_terminating_bracket = TRUE;\n                        if (*p == ':') {\n                            has_terminating_colon = TRUE;\n                        }\n                        else if (*p == ';') {\n                            has_semi_colon = TRUE;\n                            has_terminating_colon = TRUE;\n                        }\n                        else {\n                            found_problem = TRUE;\n                        }\n                        p = peek + 1;\n                        goto try_posix;\n                    }\n                }\n\n                /* Here we have punctuation we thought didn't end the class.\n                 * Keep track of the position of the key characters that are\n                 * more likely to have been class-enders */\n                if (*p == ']' || *p == '[' || *p == ':' || *p == ';') {\n\n                    /* Allow just one such possible class-ender not actually\n                     * ending the class. */\n                    if (possible_end) {\n                        break;\n                    }\n                    possible_end = p;\n                }\n\n                /* If we have too many punctuation characters, no use in\n                 * keeping going */\n                if (++punct_count > max_distance) {\n                    break;\n                }\n\n                /* Treat the punctuation as a typo. */\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else if (isUPPER(*p)) { /* Use lowercase for lookup */\n                input_text[name_len++] = toLOWER(*p);\n                has_upper = TRUE;\n                found_problem = TRUE;\n                p++;\n            } else if (! UTF || UTF8_IS_INVARIANT(*p)) {\n                input_text[name_len++] = *p;\n                p++;\n            }\n            else {\n                input_text[name_len++] = utf8_to_uvchr_buf((U8 *) p, e, NULL);\n                p+= UTF8SKIP(p);\n            }\n\n            /* The declaration of 'input_text' is how long we allow a potential\n             * class name to be, before saying they didn't mean a class name at\n             * all */\n            if (name_len >= C_ARRAY_LENGTH(input_text)) {\n                break;\n            }\n        }\n\n        /* We get to here when the possible class name hasn't been properly\n         * terminated before:\n         *   1) we ran off the end of the pattern; or\n         *   2) found two characters, each of which might have been intended to\n         *      be the name's terminator\n         *   3) found so many punctuation characters in the purported name,\n         *      that the edit distance to a valid one is exceeded\n         *   4) we decided it was more characters than anyone could have\n         *      intended to be one. */\n\n        found_problem = TRUE;\n\n        /* In the final two cases, we know that looking up what we've\n         * accumulated won't lead to a match, even a fuzzy one. */\n        if (   name_len >= C_ARRAY_LENGTH(input_text)\n            || punct_count > max_distance)\n        {\n            /* If there was an intermediate key character that could have been\n             * an intended end, redo the parse, but stop there */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1; /* Special signal value to say\n                                               we've done a first pass */\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Otherwise, it can't have meant to have been a class */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* If we ran off the end, and the final character was a punctuation\n         * one, back up one, to look at that final one just below.  Later, we\n         * will restore the parse pointer if appropriate */\n        if (name_len && p == e && isPUNCT(*(p-1))) {\n            p--;\n            name_len--;\n        }\n\n        if (p < e && isPUNCT(*p)) {\n            if (*p == ']') {\n                has_terminating_bracket = TRUE;\n\n                /* If this is a 2nd ']', and the first one is just below this\n                 * one, consider that to be the real terminator.  This gives a\n                 * uniform and better positioning for the warning message  */\n                if (   possible_end\n                    && possible_end != (char *) -1\n                    && *possible_end == ']'\n                    && name_len && input_text[name_len - 1] == ']')\n                {\n                    name_len--;\n                    p = possible_end;\n\n                    /* And this is actually equivalent to having done the 2nd\n                     * pass now, so set it to not try again */\n                    possible_end = (char *) -1;\n                }\n            }\n            else {\n                if (*p == ':') {\n                    has_terminating_colon = TRUE;\n                }\n                else if (*p == ';') {\n                    has_semi_colon = TRUE;\n                    has_terminating_colon = TRUE;\n                }\n                p++;\n            }\n        }\n\n    try_posix:\n\n        /* Here, we have a class name to look up.  We can short circuit the\n         * stuff below for short names that can't possibly be meant to be a\n         * class name.  (We can do this on the first pass, as any second pass\n         * will yield an even shorter name) */\n        if (name_len < 3) {\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n        /* Find which class it is.  Initially switch on the length of the name.\n         * */\n        switch (name_len) {\n            case 4:\n                if (memEQs(name_start, 4, \"word\")) {\n                    /* this is not POSIX, this is the Perl \\w */\n                    class_number = ANYOF_WORDCHAR;\n                }\n                break;\n            case 5:\n                /* Names all of length 5: alnum alpha ascii blank cntrl digit\n                 *                        graph lower print punct space upper\n                 * Offset 4 gives the best switch position.  */\n                switch (name_start[4]) {\n                    case 'a':\n                        if (memBEGINs(name_start, 5, \"alph\")) /* alpha */\n                            class_number = ANYOF_ALPHA;\n                        break;\n                    case 'e':\n                        if (memBEGINs(name_start, 5, \"spac\")) /* space */\n                            class_number = ANYOF_SPACE;\n                        break;\n                    case 'h':\n                        if (memBEGINs(name_start, 5, \"grap\")) /* graph */\n                            class_number = ANYOF_GRAPH;\n                        break;\n                    case 'i':\n                        if (memBEGINs(name_start, 5, \"asci\")) /* ascii */\n                            class_number = ANYOF_ASCII;\n                        break;\n                    case 'k':\n                        if (memBEGINs(name_start, 5, \"blan\")) /* blank */\n                            class_number = ANYOF_BLANK;\n                        break;\n                    case 'l':\n                        if (memBEGINs(name_start, 5, \"cntr\")) /* cntrl */\n                            class_number = ANYOF_CNTRL;\n                        break;\n                    case 'm':\n                        if (memBEGINs(name_start, 5, \"alnu\")) /* alnum */\n                            class_number = ANYOF_ALPHANUMERIC;\n                        break;\n                    case 'r':\n                        if (memBEGINs(name_start, 5, \"lowe\")) /* lower */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;\n                        else if (memBEGINs(name_start, 5, \"uppe\")) /* upper */\n                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;\n                        break;\n                    case 't':\n                        if (memBEGINs(name_start, 5, \"digi\")) /* digit */\n                            class_number = ANYOF_DIGIT;\n                        else if (memBEGINs(name_start, 5, \"prin\")) /* print */\n                            class_number = ANYOF_PRINT;\n                        else if (memBEGINs(name_start, 5, \"punc\")) /* punct */\n                            class_number = ANYOF_PUNCT;\n                        break;\n                }\n                break;\n            case 6:\n                if (memEQs(name_start, 6, \"xdigit\"))\n                    class_number = ANYOF_XDIGIT;\n                break;\n        }\n\n        /* If the name exactly matches a posix class name the class number will\n         * here be set to it, and the input almost certainly was meant to be a\n         * posix class, so we can skip further checking.  If instead the syntax\n         * is exactly correct, but the name isn't one of the legal ones, we\n         * will return that as an error below.  But if neither of these apply,\n         * it could be that no posix class was intended at all, or that one\n         * was, but there was a typo.  We tease these apart by doing fuzzy\n         * matching on the name */\n        if (class_number == OOB_NAMEDCLASS && found_problem) {\n            const UV posix_names[][6] = {\n                                                { 'a', 'l', 'n', 'u', 'm' },\n                                                { 'a', 'l', 'p', 'h', 'a' },\n                                                { 'a', 's', 'c', 'i', 'i' },\n                                                { 'b', 'l', 'a', 'n', 'k' },\n                                                { 'c', 'n', 't', 'r', 'l' },\n                                                { 'd', 'i', 'g', 'i', 't' },\n                                                { 'g', 'r', 'a', 'p', 'h' },\n                                                { 'l', 'o', 'w', 'e', 'r' },\n                                                { 'p', 'r', 'i', 'n', 't' },\n                                                { 'p', 'u', 'n', 'c', 't' },\n                                                { 's', 'p', 'a', 'c', 'e' },\n                                                { 'u', 'p', 'p', 'e', 'r' },\n                                                { 'w', 'o', 'r', 'd' },\n                                                { 'x', 'd', 'i', 'g', 'i', 't' }\n                                            };\n            /* The names of the above all have added NULs to make them the same\n             * size, so we need to also have the real lengths */\n            const UV posix_name_lengths[] = {\n                                                sizeof(\"alnum\") - 1,\n                                                sizeof(\"alpha\") - 1,\n                                                sizeof(\"ascii\") - 1,\n                                                sizeof(\"blank\") - 1,\n                                                sizeof(\"cntrl\") - 1,\n                                                sizeof(\"digit\") - 1,\n                                                sizeof(\"graph\") - 1,\n                                                sizeof(\"lower\") - 1,\n                                                sizeof(\"print\") - 1,\n                                                sizeof(\"punct\") - 1,\n                                                sizeof(\"space\") - 1,\n                                                sizeof(\"upper\") - 1,\n                                                sizeof(\"word\")  - 1,\n                                                sizeof(\"xdigit\")- 1\n                                            };\n            unsigned int i;\n            int temp_max = max_distance;    /* Use a temporary, so if we\n                                               reparse, we haven't changed the\n                                               outer one */\n\n            /* Use a smaller max edit distance if we are missing one of the\n             * delimiters */\n            if (   has_opening_bracket + has_opening_colon < 2\n                || has_terminating_bracket + has_terminating_colon < 2)\n            {\n                temp_max--;\n            }\n\n            /* See if the input name is close to a legal one */\n            for (i = 0; i < C_ARRAY_LENGTH(posix_names); i++) {\n\n                /* Short circuit call if the lengths are too far apart to be\n                 * able to match */\n                if (abs( (int) (name_len - posix_name_lengths[i]))\n                    > temp_max)\n                {\n                    continue;\n                }\n\n                if (edit_distance(input_text,\n                                  posix_names[i],\n                                  name_len,\n                                  posix_name_lengths[i],\n                                  temp_max\n                                 )\n                    > -1)\n                { /* If it is close, it probably was intended to be a class */\n                    goto probably_meant_to_be;\n                }\n            }\n\n            /* Here the input name is not close enough to a valid class name\n             * for us to consider it to be intended to be a posix class.  If\n             * we haven't already done so, and the parse found a character that\n             * could have been terminators for the name, but which we absorbed\n             * as typos during the first pass, repeat the parse, signalling it\n             * to stop at that character */\n            if (possible_end && possible_end != (char *) -1) {\n                possible_end = (char *) -1;\n                p = name_start;\n                goto parse_name;\n            }\n\n            /* Here neither pass found a close-enough class name */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(NOT_MEANT_TO_BE_A_POSIX_CLASS);\n        }\n\n    probably_meant_to_be:\n\n        /* Here we think that a posix specification was intended.  Update any\n         * parse pointer */\n        if (updated_parse_ptr) {\n            *updated_parse_ptr = (char *) p;\n        }\n\n        /* If a posix class name was intended but incorrectly specified, we\n         * output or return the warnings */\n        if (found_problem) {\n\n            /* We set flags for these issues in the parse loop above instead of\n             * adding them to the list of warnings, because we can parse it\n             * twice, and we only want one warning instance */\n            if (has_upper) {\n                ADD_POSIX_WARNING(p, \"the name must be all lowercase letters\");\n            }\n            if (has_blank) {\n                ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);\n            }\n            if (has_semi_colon) {\n                ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);\n            }\n            else if (! has_terminating_colon) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ':'\");\n            }\n            if (! has_terminating_bracket) {\n                ADD_POSIX_WARNING(p, \"there is no terminating ']'\");\n            }\n\n            if (posix_warnings && RExC_warn_text && av_top_index(RExC_warn_text) > -1) {\n                *posix_warnings = RExC_warn_text;\n            }\n        }\n        else if (class_number != OOB_NAMEDCLASS) {\n            /* If it is a known class, return the class.  The class number\n             * #defines are structured so each complement is +1 to the normal\n             * one */\n            CLEAR_POSIX_WARNINGS_AND_RETURN(class_number + complement);\n        }\n        else if (! check_only) {\n\n            /* Here, it is an unrecognized class.  This is an error (unless the\n            * call is to check only, which we've already handled above) */\n            const char * const complement_string = (complement)\n                                                   ? \"^\"\n                                                   : \"\";\n            RExC_parse = (char *) p;\n            vFAIL3utf8f(\"POSIX class [:%s%\" UTF8f \":] unknown\",\n                        complement_string,\n                        UTF8fARG(UTF, RExC_parse - name_start - 2, name_start));\n        }\n    }\n\n    return OOB_NAMEDCLASS;\n}\n#undef ADD_POSIX_WARNING\n\nSTATIC unsigned  int\nS_regex_set_precedence(const U8 my_operator) {\n\n    /* Returns the precedence in the (?[...]) construct of the input operator,\n     * specified by its character representation.  The precedence follows\n     * general Perl rules, but it extends this so that ')' and ']' have (low)\n     * precedence even though they aren't really operators */\n\n    switch (my_operator) {\n        case '!':\n            return 5;\n        case '&':\n            return 4;\n        case '^':\n        case '|':\n        case '+':\n        case '-':\n            return 3;\n        case ')':\n            return 2;\n        case ']':\n            return 1;\n    }\n\n    NOT_REACHED; /* NOTREACHED */\n    return 0;   /* Silence compiler warning */\n}\n\nSTATIC regnode *\nS_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist,\n                    I32 *flagp, U32 depth,\n                    char * const oregcomp_parse)\n{\n    /* Handle the (?[...]) construct to do set operations */\n\n    U8 curchar;                     /* Current character being parsed */\n    UV start, end;\t            /* End points of code point ranges */\n    SV* final = NULL;               /* The end result inversion list */\n    SV* result_string;              /* 'final' stringified */\n    AV* stack;                      /* stack of operators and operands not yet\n                                       resolved */\n    AV* fence_stack = NULL;         /* A stack containing the positions in\n                                       'stack' of where the undealt-with left\n                                       parens would be if they were actually\n                                       put there */\n    /* The 'volatile' is a workaround for an optimiser bug\n     * in Solaris Studio 12.3. See RT #127455 */\n    volatile IV fence = 0;          /* Position of where most recent undealt-\n                                       with left paren in stack is; -1 if none.\n                                     */\n    STRLEN len;                     /* Temporary */\n    regnode* node;                  /* Temporary, and final regnode returned by\n                                       this function */\n    const bool save_fold = FOLD;    /* Temporary */\n    char *save_end, *save_parse;    /* Temporaries */\n    const bool in_locale = LOC;     /* we turn off /l during processing */\n    AV* posix_warnings = NULL;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_HANDLE_REGEX_SETS;\n\n    DEBUG_PARSE(\"xcls\");\n\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);\n    }\n\n    REQUIRE_UNI_RULES(flagp, NULL);   /* The use of this operator implies /u.\n                                         This is required so that the compile\n                                         time values are valid in all runtime\n                                         cases */\n\n    /* This will return only an ANYOF regnode, or (unlikely) something smaller\n     * (such as EXACT).  Thus we can skip most everything if just sizing.  We\n     * call regclass to handle '[]' so as to not have to reinvent its parsing\n     * rules here (throwing away the size it computes each time).  And, we exit\n     * upon an unescaped ']' that isn't one ending a regclass.  To do both\n     * these things, we need to realize that something preceded by a backslash\n     * is escaped, so we have to keep track of backslashes */\n    if (SIZE_ONLY) {\n        UV nest_depth = 0; /* how many nested (?[...]) constructs */\n\n        while (RExC_parse < RExC_end) {\n            SV* current = NULL;\n\n            skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                    TRUE /* Force /x */ );\n\n            switch (*RExC_parse) {\n                case '(':\n                    if (RExC_parse[1] == '?' && RExC_parse[2] == '[')\n                        nest_depth++, RExC_parse+=2;\n                    /* FALLTHROUGH */\n                default:\n                    break;\n                case '\\\\':\n                    /* Skip past this, so the next character gets skipped, after\n                     * the switch */\n                    RExC_parse++;\n                    if (*RExC_parse == 'c') {\n                            /* Skip the \\cX notation for control characters */\n                            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n                    }\n                    break;\n\n                case '[':\n                {\n                    /* See if this is a [:posix:] class. */\n                    bool is_posix_class = (OOB_NAMEDCLASS\n                            < handle_possible_posix(pRExC_state,\n                                                RExC_parse + 1,\n                                                NULL,\n                                                NULL,\n                                                TRUE /* checking only */));\n                    /* If it is a posix class, leave the parse pointer at the\n                     * '[' to fool regclass() into thinking it is part of a\n                     * '[[:posix:]]'. */\n                    if (! is_posix_class) {\n                        RExC_parse++;\n                    }\n\n                    /* regclass() can only return RESTART_PASS1 and NEED_UTF8\n                     * if multi-char folds are allowed.  */\n                    if (!regclass(pRExC_state, flagp,depth+1,\n                                  is_posix_class, /* parse the whole char\n                                                     class only if not a\n                                                     posix class */\n                                  FALSE, /* don't allow multi-char folds */\n                                  TRUE, /* silence non-portable warnings. */\n                                  TRUE, /* strict */\n                                  FALSE, /* Require return to be an ANYOF */\n                                  &current,\n                                  &posix_warnings\n                                 ))\n                        FAIL2(\"panic: regclass returned NULL to handle_sets, \"\n                              \"flags=%#\" UVxf, (UV) *flagp);\n\n                    /* function call leaves parse pointing to the ']', except\n                     * if we faked it */\n                    if (is_posix_class) {\n                        RExC_parse--;\n                    }\n\n                    SvREFCNT_dec(current);   /* In case it returned something */\n                    break;\n                }\n\n                case ']':\n                    if (RExC_parse[1] == ')') {\n                        RExC_parse++;\n                        if (nest_depth--) break;\n                        node = reganode(pRExC_state, ANYOF, 0);\n                        RExC_size += ANYOF_SKIP;\n                        nextchar(pRExC_state);\n                        Set_Node_Length(node,\n                                RExC_parse - oregcomp_parse + 1); /* MJD */\n                        if (in_locale) {\n                            set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);\n                        }\n\n                        return node;\n                    }\n                    /* We output the messages even if warnings are off, because we'll fail\n                     * the very next thing, and these give a likely diagnosis for that */\n                    if (posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {\n                        output_or_return_posix_warnings(pRExC_state, posix_warnings, NULL);\n                    }\n                    RExC_parse++;\n                    vFAIL(\"Unexpected ']' with no following ')' in (?[...\");\n            }\n\n            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;\n        }\n\n        /* We output the messages even if warnings are off, because we'll fail\n         * the very next thing, and these give a likely diagnosis for that */\n        if (posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {\n            output_or_return_posix_warnings(pRExC_state, posix_warnings, NULL);\n        }\n\n        vFAIL(\"Syntax error in (?[...])\");\n    }\n\n    /* Pass 2 only after this. */\n    Perl_ck_warner_d(aTHX_\n        packWARN(WARN_EXPERIMENTAL__REGEX_SETS),\n        \"The regex_sets feature is experimental\" REPORT_LOCATION,\n        REPORT_LOCATION_ARGS(RExC_parse));\n\n    /* Everything in this construct is a metacharacter.  Operands begin with\n     * either a '\\' (for an escape sequence), or a '[' for a bracketed\n     * character class.  Any other character should be an operator, or\n     * parenthesis for grouping.  Both types of operands are handled by calling\n     * regclass() to parse them.  It is called with a parameter to indicate to\n     * return the computed inversion list.  The parsing here is implemented via\n     * a stack.  Each entry on the stack is a single character representing one\n     * of the operators; or else a pointer to an operand inversion list. */\n\n#define IS_OPERATOR(a) SvIOK(a)\n#define IS_OPERAND(a)  (! IS_OPERATOR(a))\n\n    /* The stack is kept in \u0141ukasiewicz order.  (That's pronounced similar\n     * to luke-a-shave-itch (or -itz), but people who didn't want to bother\n     * with pronouncing it called it Reverse Polish instead, but now that YOU\n     * know how to pronounce it you can use the correct term, thus giving due\n     * credit to the person who invented it, and impressing your geek friends.\n     * Wikipedia says that the pronounciation of \"\u0141\" has been changing so that\n     * it is now more like an English initial W (as in wonk) than an L.)\n     *\n     * This means that, for example, 'a | b & c' is stored on the stack as\n     *\n     * c  [4]\n     * b  [3]\n     * &  [2]\n     * a  [1]\n     * |  [0]\n     *\n     * where the numbers in brackets give the stack [array] element number.\n     * In this implementation, parentheses are not stored on the stack.\n     * Instead a '(' creates a \"fence\" so that the part of the stack below the\n     * fence is invisible except to the corresponding ')' (this allows us to\n     * replace testing for parens, by using instead subtraction of the fence\n     * position).  As new operands are processed they are pushed onto the stack\n     * (except as noted in the next paragraph).  New operators of higher\n     * precedence than the current final one are inserted on the stack before\n     * the lhs operand (so that when the rhs is pushed next, everything will be\n     * in the correct positions shown above.  When an operator of equal or\n     * lower precedence is encountered in parsing, all the stacked operations\n     * of equal or higher precedence are evaluated, leaving the result as the\n     * top entry on the stack.  This makes higher precedence operations\n     * evaluate before lower precedence ones, and causes operations of equal\n     * precedence to left associate.\n     *\n     * The only unary operator '!' is immediately pushed onto the stack when\n     * encountered.  When an operand is encountered, if the top of the stack is\n     * a '!\", the complement is immediately performed, and the '!' popped.  The\n     * resulting value is treated as a new operand, and the logic in the\n     * previous paragraph is executed.  Thus in the expression\n     *      [a] + ! [b]\n     * the stack looks like\n     *\n     * !\n     * a\n     * +\n     *\n     * as 'b' gets parsed, the latter gets evaluated to '!b', and the stack\n     * becomes\n     *\n     * !b\n     * a\n     * +\n     *\n     * A ')' is treated as an operator with lower precedence than all the\n     * aforementioned ones, which causes all operations on the stack above the\n     * corresponding '(' to be evaluated down to a single resultant operand.\n     * Then the fence for the '(' is removed, and the operand goes through the\n     * algorithm above, without the fence.\n     *\n     * A separate stack is kept of the fence positions, so that the position of\n     * the latest so-far unbalanced '(' is at the top of it.\n     *\n     * The ']' ending the construct is treated as the lowest operator of all,\n     * so that everything gets evaluated down to a single operand, which is the\n     * result */\n\n    sv_2mortal((SV *)(stack = newAV()));\n    sv_2mortal((SV *)(fence_stack = newAV()));\n\n    while (RExC_parse < RExC_end) {\n        I32 top_index;              /* Index of top-most element in 'stack' */\n        SV** top_ptr;               /* Pointer to top 'stack' element */\n        SV* current = NULL;         /* To contain the current inversion list\n                                       operand */\n        SV* only_to_avoid_leaks;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                TRUE /* Force /x */ );\n        if (RExC_parse >= RExC_end) {\n            Perl_croak(aTHX_ \"panic: Read past end of '(?[ ])'\");\n        }\n\n        curchar = UCHARAT(RExC_parse);\n\nredo_curchar:\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n                    /* Enable with -Accflags=-DENABLE_REGEX_SETS_DEBUGGING */\n        DEBUG_U(dump_regex_sets_structures(pRExC_state,\n                                           stack, fence, fence_stack));\n#endif\n\n        top_index = av_tindex_skip_len_mg(stack);\n\n        switch (curchar) {\n            SV** stacked_ptr;       /* Ptr to something already on 'stack' */\n            char stacked_operator;  /* The topmost operator on the 'stack'. */\n            SV* lhs;                /* Operand to the left of the operator */\n            SV* rhs;                /* Operand to the right of the operator */\n            SV* fence_ptr;          /* Pointer to top element of the fence\n                                       stack */\n\n            case '(':\n\n                if (   RExC_parse < RExC_end - 1\n                    && (UCHARAT(RExC_parse + 1) == '?'))\n                {\n                    /* If is a '(?', could be an embedded '(?flags:(?[...])'.\n                     * This happens when we have some thing like\n                     *\n                     *   my $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\n                     *   ...\n                     *   qr/(?[ \\p{Digit} & $thai_or_lao ])/;\n                     *\n                     * Here we would be handling the interpolated\n                     * '$thai_or_lao'.  We handle this by a recursive call to\n                     * ourselves which returns the inversion list the\n                     * interpolated expression evaluates to.  We use the flags\n                     * from the interpolated pattern. */\n                    U32 save_flags = RExC_flags;\n                    const char * save_parse;\n\n                    RExC_parse += 2;        /* Skip past the '(?' */\n                    save_parse = RExC_parse;\n\n                    /* Parse any flags for the '(?' */\n                    parse_lparen_question_flags(pRExC_state);\n\n                    if (RExC_parse == save_parse  /* Makes sure there was at\n                                                     least one flag (or else\n                                                     this embedding wasn't\n                                                     compiled) */\n                        || RExC_parse >= RExC_end - 4\n                        || UCHARAT(RExC_parse) != ':'\n                        || UCHARAT(++RExC_parse) != '('\n                        || UCHARAT(++RExC_parse) != '?'\n                        || UCHARAT(++RExC_parse) != '[')\n                    {\n\n                        /* In combination with the above, this moves the\n                         * pointer to the point just after the first erroneous\n                         * character (or if there are no flags, to where they\n                         * should have been) */\n                        if (RExC_parse >= RExC_end - 4) {\n                            RExC_parse = RExC_end;\n                        }\n                        else if (RExC_parse != save_parse) {\n                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                        }\n                        vFAIL(\"Expecting '(?flags:(?[...'\");\n                    }\n\n                    /* Recurse, with the meat of the embedded expression */\n                    RExC_parse++;\n                    (void) handle_regex_sets(pRExC_state, &current, flagp,\n                                                    depth+1, oregcomp_parse);\n\n                    /* Here, 'current' contains the embedded expression's\n                     * inversion list, and RExC_parse points to the trailing\n                     * ']'; the next character should be the ')' */\n                    RExC_parse++;\n                    if (UCHARAT(RExC_parse) != ')')\n                        vFAIL(\"Expecting close paren for nested extended charclass\");\n\n                    /* Then the ')' matching the original '(' handled by this\n                     * case: statement */\n                    RExC_parse++;\n                    if (UCHARAT(RExC_parse) != ')')\n                        vFAIL(\"Expecting close paren for wrapper for nested extended charclass\");\n\n                    RExC_parse++;\n                    RExC_flags = save_flags;\n                    goto handle_operand;\n                }\n\n                /* A regular '('.  Look behind for illegal syntax */\n                if (top_index - fence >= 0) {\n                    /* If the top entry on the stack is an operator, it had\n                     * better be a '!', otherwise the entry below the top\n                     * operand should be an operator */\n                    if (   ! (top_ptr = av_fetch(stack, top_index, FALSE))\n                        || (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) != '!')\n                        || (   IS_OPERAND(*top_ptr)\n                            && (   top_index - fence < 1\n                                || ! (stacked_ptr = av_fetch(stack,\n                                                             top_index - 1,\n                                                             FALSE))\n                                || ! IS_OPERATOR(*stacked_ptr))))\n                    {\n                        RExC_parse++;\n                        vFAIL(\"Unexpected '(' with no preceding operator\");\n                    }\n                }\n\n                /* Stack the position of this undealt-with left paren */\n                av_push(fence_stack, newSViv(fence));\n                fence = top_index + 1;\n                break;\n\n            case '\\\\':\n                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp,depth+1,\n                              TRUE, /* means parse just the next thing */\n                              FALSE, /* don't allow multi-char folds */\n                              FALSE, /* don't silence non-portable warnings.  */\n                              TRUE,  /* strict */\n                              FALSE, /* Require return to be an ANYOF */\n                              &current,\n                              NULL))\n                {\n                    FAIL2(\"panic: regclass returned NULL to handle_sets, \"\n                          \"flags=%#\" UVxf, (UV) *flagp);\n                }\n\n                /* regclass() will return with parsing just the \\ sequence,\n                 * leaving the parse pointer at the next thing to parse */\n                RExC_parse--;\n                goto handle_operand;\n\n            case '[':   /* Is a bracketed character class */\n            {\n                /* See if this is a [:posix:] class. */\n                bool is_posix_class = (OOB_NAMEDCLASS\n                            < handle_possible_posix(pRExC_state,\n                                                RExC_parse + 1,\n                                                NULL,\n                                                NULL,\n                                                TRUE /* checking only */));\n                /* If it is a posix class, leave the parse pointer at the '['\n                 * to fool regclass() into thinking it is part of a\n                 * '[[:posix:]]'. */\n                if (! is_posix_class) {\n                    RExC_parse++;\n                }\n\n                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if\n                 * multi-char folds are allowed.  */\n                if (!regclass(pRExC_state, flagp,depth+1,\n                                is_posix_class, /* parse the whole char\n                                                    class only if not a\n                                                    posix class */\n                                FALSE, /* don't allow multi-char folds */\n                                TRUE, /* silence non-portable warnings. */\n                                TRUE, /* strict */\n                                FALSE, /* Require return to be an ANYOF */\n                                &current,\n                                NULL\n                                ))\n                {\n                    FAIL2(\"panic: regclass returned NULL to handle_sets, \"\n                          \"flags=%#\" UVxf, (UV) *flagp);\n                }\n\n                /* function call leaves parse pointing to the ']', except if we\n                 * faked it */\n                if (is_posix_class) {\n                    RExC_parse--;\n                }\n\n                goto handle_operand;\n            }\n\n            case ']':\n                if (top_index >= 1) {\n                    goto join_operators;\n                }\n\n                /* Only a single operand on the stack: are done */\n                goto done;\n\n            case ')':\n                if (av_tindex_skip_len_mg(fence_stack) < 0) {\n                    RExC_parse++;\n                    vFAIL(\"Unexpected ')'\");\n                }\n\n                /* If nothing after the fence, is missing an operand */\n                if (top_index - fence < 0) {\n                    RExC_parse++;\n                    goto bad_syntax;\n                }\n                /* If at least two things on the stack, treat this as an\n                  * operator */\n                if (top_index - fence >= 1) {\n                    goto join_operators;\n                }\n\n                /* Here only a single thing on the fenced stack, and there is a\n                 * fence.  Get rid of it */\n                fence_ptr = av_pop(fence_stack);\n                assert(fence_ptr);\n                fence = SvIV(fence_ptr) - 1;\n                SvREFCNT_dec_NN(fence_ptr);\n                fence_ptr = NULL;\n\n                if (fence < 0) {\n                    fence = 0;\n                }\n\n                /* Having gotten rid of the fence, we pop the operand at the\n                 * stack top and process it as a newly encountered operand */\n                current = av_pop(stack);\n                if (IS_OPERAND(current)) {\n                    goto handle_operand;\n                }\n\n                RExC_parse++;\n                goto bad_syntax;\n\n            case '&':\n            case '|':\n            case '+':\n            case '-':\n            case '^':\n\n                /* These binary operators should have a left operand already\n                 * parsed */\n                if (   top_index - fence < 0\n                    || top_index - fence == 1\n                    || ( ! (top_ptr = av_fetch(stack, top_index, FALSE)))\n                    || ! IS_OPERAND(*top_ptr))\n                {\n                    goto unexpected_binary;\n                }\n\n                /* If only the one operand is on the part of the stack visible\n                 * to us, we just place this operator in the proper position */\n                if (top_index - fence < 2) {\n\n                    /* Place the operator before the operand */\n\n                    SV* lhs = av_pop(stack);\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* But if there is something else on the stack, we need to\n                 * process it before this new operator if and only if the\n                 * stacked operation has equal or higher precedence than the\n                 * new one */\n\n             join_operators:\n\n                /* The operator on the stack is supposed to be below both its\n                 * operands */\n                if (   ! (stacked_ptr = av_fetch(stack, top_index - 2, FALSE))\n                    || IS_OPERAND(*stacked_ptr))\n                {\n                    /* But if not, it's legal and indicates we are completely\n                     * done if and only if we're currently processing a ']',\n                     * which should be the final thing in the expression */\n                    if (curchar == ']') {\n                        goto done;\n                    }\n\n                  unexpected_binary:\n                    RExC_parse++;\n                    vFAIL2(\"Unexpected binary operator '%c' with no \"\n                           \"preceding operand\", curchar);\n                }\n                stacked_operator = (char) SvUV(*stacked_ptr);\n\n                if (regex_set_precedence(curchar)\n                    > regex_set_precedence(stacked_operator))\n                {\n                    /* Here, the new operator has higher precedence than the\n                     * stacked one.  This means we need to add the new one to\n                     * the stack to await its rhs operand (and maybe more\n                     * stuff).  We put it before the lhs operand, leaving\n                     * untouched the stacked operator and everything below it\n                     * */\n                    lhs = av_pop(stack);\n                    assert(IS_OPERAND(lhs));\n\n                    av_push(stack, newSVuv(curchar));\n                    av_push(stack, lhs);\n                    break;\n                }\n\n                /* Here, the new operator has equal or lower precedence than\n                 * what's already there.  This means the operation already\n                 * there should be performed now, before the new one. */\n\n                rhs = av_pop(stack);\n                if (! IS_OPERAND(rhs)) {\n\n                    /* This can happen when a ! is not followed by an operand,\n                     * like in /(?[\\t &!])/ */\n                    goto bad_syntax;\n                }\n\n                lhs = av_pop(stack);\n\n                if (! IS_OPERAND(lhs)) {\n\n                    /* This can happen when there is an empty (), like in\n                     * /(?[[0]+()+])/ */\n                    goto bad_syntax;\n                }\n\n                switch (stacked_operator) {\n                    case '&':\n                        _invlist_intersection(lhs, rhs, &rhs);\n                        break;\n\n                    case '|':\n                    case '+':\n                        _invlist_union(lhs, rhs, &rhs);\n                        break;\n\n                    case '-':\n                        _invlist_subtract(lhs, rhs, &rhs);\n                        break;\n\n                    case '^':   /* The union minus the intersection */\n                    {\n                        SV* i = NULL;\n                        SV* u = NULL;\n\n                        _invlist_union(lhs, rhs, &u);\n                        _invlist_intersection(lhs, rhs, &i);\n                        _invlist_subtract(u, i, &rhs);\n                        SvREFCNT_dec_NN(i);\n                        SvREFCNT_dec_NN(u);\n                        break;\n                    }\n                }\n                SvREFCNT_dec(lhs);\n\n                /* Here, the higher precedence operation has been done, and the\n                 * result is in 'rhs'.  We overwrite the stacked operator with\n                 * the result.  Then we redo this code to either push the new\n                 * operator onto the stack or perform any higher precedence\n                 * stacked operation */\n                only_to_avoid_leaks = av_pop(stack);\n                SvREFCNT_dec(only_to_avoid_leaks);\n                av_push(stack, rhs);\n                goto redo_curchar;\n\n            case '!':   /* Highest priority, right associative */\n\n                /* If what's already at the top of the stack is another '!\",\n                 * they just cancel each other out */\n                if (   (top_ptr = av_fetch(stack, top_index, FALSE))\n                    && (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) == '!'))\n                {\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n                }\n                else { /* Otherwise, since it's right associative, just push\n                          onto the stack */\n                    av_push(stack, newSVuv(curchar));\n                }\n                break;\n\n            default:\n                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                vFAIL(\"Unexpected character\");\n\n          handle_operand:\n\n            /* Here 'current' is the operand.  If something is already on the\n             * stack, we have to check if it is a !.  But first, the code above\n             * may have altered the stack in the time since we earlier set\n             * 'top_index'.  */\n\n            top_index = av_tindex_skip_len_mg(stack);\n            if (top_index - fence >= 0) {\n                /* If the top entry on the stack is an operator, it had better\n                 * be a '!', otherwise the entry below the top operand should\n                 * be an operator */\n                top_ptr = av_fetch(stack, top_index, FALSE);\n                assert(top_ptr);\n                if (IS_OPERATOR(*top_ptr)) {\n\n                    /* The only permissible operator at the top of the stack is\n                     * '!', which is applied immediately to this operand. */\n                    curchar = (char) SvUV(*top_ptr);\n                    if (curchar != '!') {\n                        SvREFCNT_dec(current);\n                        vFAIL2(\"Unexpected binary operator '%c' with no \"\n                                \"preceding operand\", curchar);\n                    }\n\n                    _invlist_invert(current);\n\n                    only_to_avoid_leaks = av_pop(stack);\n                    SvREFCNT_dec(only_to_avoid_leaks);\n\n                    /* And we redo with the inverted operand.  This allows\n                     * handling multiple ! in a row */\n                    goto handle_operand;\n                }\n                          /* Single operand is ok only for the non-binary ')'\n                           * operator */\n                else if ((top_index - fence == 0 && curchar != ')')\n                         || (top_index - fence > 0\n                             && (! (stacked_ptr = av_fetch(stack,\n                                                           top_index - 1,\n                                                           FALSE))\n                                 || IS_OPERAND(*stacked_ptr))))\n                {\n                    SvREFCNT_dec(current);\n                    vFAIL(\"Operand with no preceding operator\");\n                }\n            }\n\n            /* Here there was nothing on the stack or the top element was\n             * another operand.  Just add this new one */\n            av_push(stack, current);\n\n        } /* End of switch on next parse token */\n\n        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n    } /* End of loop parsing through the construct */\n\n  done:\n    if (av_tindex_skip_len_mg(fence_stack) >= 0) {\n        vFAIL(\"Unmatched (\");\n    }\n\n    if (av_tindex_skip_len_mg(stack) < 0   /* Was empty */\n        || ((final = av_pop(stack)) == NULL)\n        || ! IS_OPERAND(final)\n        || SvTYPE(final) != SVt_INVLIST\n        || av_tindex_skip_len_mg(stack) >= 0)  /* More left on stack */\n    {\n      bad_syntax:\n        SvREFCNT_dec(final);\n        vFAIL(\"Incomplete expression within '(?[ ])'\");\n    }\n\n    /* Here, 'final' is the resultant inversion list from evaluating the\n     * expression.  Return it if so requested */\n    if (return_invlist) {\n        *return_invlist = final;\n        return END;\n    }\n\n    /* Otherwise generate a resultant node, based on 'final'.  regclass() is\n     * expecting a string of ranges and individual code points */\n    invlist_iterinit(final);\n    result_string = newSVpvs(\"\");\n    while (invlist_iternext(final, &start, &end)) {\n        if (start == end) {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}\", start);\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ result_string, \"\\\\x{%\" UVXf \"}-\\\\x{%\" UVXf \"}\",\n                                                     start,          end);\n        }\n    }\n\n    /* About to generate an ANYOF (or similar) node from the inversion list we\n     * have calculated */\n    save_parse = RExC_parse;\n    RExC_parse = SvPV(result_string, len);\n    save_end = RExC_end;\n    RExC_end = RExC_parse + len;\n\n    /* We turn off folding around the call, as the class we have constructed\n     * already has all folding taken into consideration, and we don't want\n     * regclass() to add to that */\n    RExC_flags &= ~RXf_PMf_FOLD;\n    /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if multi-char\n     * folds are allowed.  */\n    node = regclass(pRExC_state, flagp,depth+1,\n                    FALSE, /* means parse the whole char class */\n                    FALSE, /* don't allow multi-char folds */\n                    TRUE, /* silence non-portable warnings.  The above may very\n                             well have generated non-portable code points, but\n                             they're valid on this machine */\n                    FALSE, /* similarly, no need for strict */\n                    FALSE, /* Require return to be an ANYOF */\n                    NULL,\n                    NULL\n                );\n    if (!node)\n        FAIL2(\"panic: regclass returned NULL to handle_sets, flags=%#\" UVxf,\n                    PTR2UV(flagp));\n\n    /* Fix up the node type if we are in locale.  (We have pretended we are\n     * under /u for the purposes of regclass(), as this construct will only\n     * work under UTF-8 locales.  But now we change the opcode to be ANYOFL (so\n     * as to cause any warnings about bad locales to be output in regexec.c),\n     * and add the flag that indicates to check if not in a UTF-8 locale.  The\n     * reason we above forbid optimization into something other than an ANYOF\n     * node is simply to minimize the number of code changes in regexec.c.\n     * Otherwise we would have to create new EXACTish node types and deal with\n     * them.  This decision could be revisited should this construct become\n     * popular.\n     *\n     * (One might think we could look at the resulting ANYOF node and suppress\n     * the flag if everything is above 255, as those would be UTF-8 only,\n     * but this isn't true, as the components that led to that result could\n     * have been locale-affected, and just happen to cancel each other out\n     * under UTF-8 locales.) */\n    if (in_locale) {\n        set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);\n\n        assert(OP(node) == ANYOF);\n\n        OP(node) = ANYOFL;\n        ANYOF_FLAGS(node)\n                |= ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n    }\n\n    if (save_fold) {\n        RExC_flags |= RXf_PMf_FOLD;\n    }\n\n    RExC_parse = save_parse + 1;\n    RExC_end = save_end;\n    SvREFCNT_dec_NN(final);\n    SvREFCNT_dec_NN(result_string);\n\n    nextchar(pRExC_state);\n    Set_Node_Length(node, RExC_parse - oregcomp_parse + 1); /* MJD */\n    return node;\n}\n\n#ifdef ENABLE_REGEX_SETS_DEBUGGING\n\nSTATIC void\nS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state,\n                             AV * stack, const IV fence, AV * fence_stack)\n{   /* Dumps the stacks in handle_regex_sets() */\n\n    const SSize_t stack_top = av_tindex_skip_len_mg(stack);\n    const SSize_t fence_stack_top = av_tindex_skip_len_mg(fence_stack);\n    SSize_t i;\n\n    PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES;\n\n    PerlIO_printf(Perl_debug_log, \"\\nParse position is:%s\\n\", RExC_parse);\n\n    if (stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Stack: (fence=%d)\\n\", (int) fence);\n        for (i = stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            if (IS_OPERATOR(*element_ptr)) {\n                PerlIO_printf(Perl_debug_log, \"[%d]: %c\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n            }\n            else {\n                PerlIO_printf(Perl_debug_log, \"[%d] \", (int) i);\n                sv_dump(*element_ptr);\n            }\n        }\n    }\n\n    if (fence_stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on fence_stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Fence_stack: \\n\");\n        for (i = fence_stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(fence_stack, i, FALSE);\n            if (! element_ptr) {\n            }\n\n            PerlIO_printf(Perl_debug_log, \"[%d]: %d\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n        }\n    }\n}\n\n#endif\n\n#undef IS_OPERATOR\n#undef IS_OPERAND\n\nSTATIC void\nS_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist)\n{\n    /* This hard-codes the Latin1/above-Latin1 folding rules, so that an\n     * innocent-looking character class, like /[ks]/i won't have to go out to\n     * disk to find the possible matches.\n     *\n     * This should be called only for a Latin1-range code points, cp, which is\n     * known to be involved in a simple fold with other code points above\n     * Latin1.  It would give false results if /aa has been specified.\n     * Multi-char folds are outside the scope of this, and must be handled\n     * specially.\n     *\n     * XXX It would be better to generate these via regen, in case a new\n     * version of the Unicode standard adds new mappings, though that is not\n     * really likely, and may be caught by the default: case of the switch\n     * below. */\n\n    PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS;\n\n    assert(HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(cp));\n\n    switch (cp) {\n        case 'k':\n        case 'K':\n          *invlist =\n             add_cp_to_invlist(*invlist, KELVIN_SIGN);\n            break;\n        case 's':\n        case 'S':\n          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_LONG_S);\n            break;\n        case MICRO_SIGN:\n          *invlist = add_cp_to_invlist(*invlist, GREEK_CAPITAL_LETTER_MU);\n          *invlist = add_cp_to_invlist(*invlist, GREEK_SMALL_LETTER_MU);\n            break;\n        case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:\n        case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:\n          *invlist = add_cp_to_invlist(*invlist, ANGSTROM_SIGN);\n            break;\n        case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:\n          *invlist = add_cp_to_invlist(*invlist,\n                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);\n            break;\n\n#ifdef LATIN_CAPITAL_LETTER_SHARP_S /* not defined in early Unicode releases */\n\n        case LATIN_SMALL_LETTER_SHARP_S:\n          *invlist = add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_SHARP_S);\n            break;\n\n#endif\n\n#if    UNICODE_MAJOR_VERSION < 3                                        \\\n   || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0)\n\n        /* In 3.0 and earlier, U+0130 folded simply to 'i'; and in 3.0.1 so did\n         * U+0131.  */\n        case 'i':\n        case 'I':\n          *invlist =\n             add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);\n#   if UNICODE_DOT_DOT_VERSION == 1\n          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_DOTLESS_I);\n#   endif\n            break;\n#endif\n\n        default:\n            /* Use deprecated warning to increase the chances of this being\n             * output */\n            if (PASS2) {\n                ckWARN2reg_d(RExC_parse, \"Perl folding rules are not up-to-date for 0x%02X; please use the perlbug utility to report;\", cp);\n            }\n            break;\n    }\n}\n\nSTATIC void\nS_output_or_return_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings, AV** return_posix_warnings)\n{\n    /* If the final parameter is NULL, output the elements of the array given\n     * by '*posix_warnings' as REGEXP warnings.  Otherwise, the elements are\n     * pushed onto it, (creating if necessary) */\n\n    SV * msg;\n    const bool first_is_fatal =  ! return_posix_warnings\n                                && ckDEAD(packWARN(WARN_REGEXP));\n\n    PERL_ARGS_ASSERT_OUTPUT_OR_RETURN_POSIX_WARNINGS;\n\n    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {\n        if (return_posix_warnings) {\n            if (! *return_posix_warnings) { /* mortalize to not leak if\n                                               warnings are fatal */\n                *return_posix_warnings = (AV *) sv_2mortal((SV *) newAV());\n            }\n            av_push(*return_posix_warnings, msg);\n        }\n        else {\n            if (first_is_fatal) {           /* Avoid leaking this */\n                av_undef(posix_warnings);   /* This isn't necessary if the\n                                               array is mortal, but is a\n                                               fail-safe */\n                (void) sv_2mortal(msg);\n                if (PASS2) {\n                    SAVEFREESV(RExC_rx_sv);\n                }\n            }\n            Perl_warner(aTHX_ packWARN(WARN_REGEXP), \"%s\", SvPVX(msg));\n            SvREFCNT_dec_NN(msg);\n        }\n    }\n}\n\nSTATIC AV *\nS_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count)\n{\n    /* This adds the string scalar <multi_string> to the array\n     * <multi_char_matches>.  <multi_string> is known to have exactly\n     * <cp_count> code points in it.  This is used when constructing a\n     * bracketed character class and we find something that needs to match more\n     * than a single character.\n     *\n     * <multi_char_matches> is actually an array of arrays.  Each top-level\n     * element is an array that contains all the strings known so far that are\n     * the same length.  And that length (in number of code points) is the same\n     * as the index of the top-level array.  Hence, the [2] element is an\n     * array, each element thereof is a string containing TWO code points;\n     * while element [3] is for strings of THREE characters, and so on.  Since\n     * this is for multi-char strings there can never be a [0] nor [1] element.\n     *\n     * When we rewrite the character class below, we will do so such that the\n     * longest strings are written first, so that it prefers the longest\n     * matching strings first.  This is done even if it turns out that any\n     * quantifier is non-greedy, out of this programmer's (khw) laziness.  Tom\n     * Christiansen has agreed that this is ok.  This makes the test for the\n     * ligature 'ffi' come before the test for 'ff', for example */\n\n    AV* this_array;\n    AV** this_array_ptr;\n\n    PERL_ARGS_ASSERT_ADD_MULTI_MATCH;\n\n    if (! multi_char_matches) {\n        multi_char_matches = newAV();\n    }\n\n    if (av_exists(multi_char_matches, cp_count)) {\n        this_array_ptr = (AV**) av_fetch(multi_char_matches, cp_count, FALSE);\n        this_array = *this_array_ptr;\n    }\n    else {\n        this_array = newAV();\n        av_store(multi_char_matches, cp_count,\n                 (SV*) this_array);\n    }\n    av_push(this_array, multi_string);\n\n    return multi_char_matches;\n}\n\n/* The names of properties whose definitions are not known at compile time are\n * stored in this SV, after a constant heading.  So if the length has been\n * changed since initialization, then there is a run-time definition. */\n#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION                            \\\n                                        (SvCUR(listsv) != initial_listsv_len)\n\n/* There is a restricted set of white space characters that are legal when\n * ignoring white space in a bracketed character class.  This generates the\n * code to skip them.\n *\n * There is a line below that uses the same white space criteria but is outside\n * this macro.  Both here and there must use the same definition */\n#define SKIP_BRACKETED_WHITE_SPACE(do_skip, p)                          \\\n    STMT_START {                                                        \\\n        if (do_skip) {                                                  \\\n            while (isBLANK_A(UCHARAT(p)))                               \\\n            {                                                           \\\n                p++;                                                    \\\n            }                                                           \\\n        }                                                               \\\n    } STMT_END\n\nSTATIC regnode *\nS_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,\n                 const bool stop_at_1,  /* Just parse the next thing, don't\n                                           look for a full character class */\n                 bool allow_multi_folds,\n                 const bool silence_non_portable,   /* Don't output warnings\n                                                       about too large\n                                                       characters */\n                 const bool strict,\n                 bool optimizable,                  /* ? Allow a non-ANYOF return\n                                                       node */\n                 SV** ret_invlist, /* Return an inversion list, not a node */\n                 AV** return_posix_warnings\n          )\n{\n    /* parse a bracketed class specification.  Most of these will produce an\n     * ANYOF node; but something like [a] will produce an EXACT node; [aA], an\n     * EXACTFish node; [[:ascii:]], a POSIXA node; etc.  It is more complex\n     * under /i with multi-character folds: it will be rewritten following the\n     * paradigm of this example, where the <multi-fold>s are characters which\n     * fold to multiple character sequences:\n     *      /[abc\\x{multi-fold1}def\\x{multi-fold2}ghi]/i\n     * gets effectively rewritten as:\n     *      /(?:\\x{multi-fold1}|\\x{multi-fold2}|[abcdefghi]/i\n     * reg() gets called (recursively) on the rewritten version, and this\n     * function will return what it constructs.  (Actually the <multi-fold>s\n     * aren't physically removed from the [abcdefghi], it's just that they are\n     * ignored in the recursion by means of a flag:\n     * <RExC_in_multi_char_class>.)\n     *\n     * ANYOF nodes contain a bit map for the first NUM_ANYOF_CODE_POINTS\n     * characters, with the corresponding bit set if that character is in the\n     * list.  For characters above this, a range list or swash is used.  There\n     * are extra bits for \\w, etc. in locale ANYOFs, as what these match is not\n     * determinable at compile time\n     *\n     * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs\n     * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded\n     * to UTF-8.  This can only happen if ret_invlist is non-NULL.\n     */\n\n    UV prevvalue = OOB_UNICODE, save_prevvalue = OOB_UNICODE;\n    IV range = 0;\n    UV value = OOB_UNICODE, save_value = OOB_UNICODE;\n    regnode *ret;\n    STRLEN numlen;\n    int namedclass = OOB_NAMEDCLASS;\n    char *rangebegin = NULL;\n    bool need_class = 0;\n    SV *listsv = NULL;\n    STRLEN initial_listsv_len = 0; /* Kind of a kludge to see if it is more\n\t\t\t\t      than just initialized.  */\n    SV* properties = NULL;    /* Code points that match \\p{} \\P{} */\n    SV* posixes = NULL;     /* Code points that match classes like [:word:],\n                               extended beyond the Latin1 range.  These have to\n                               be kept separate from other code points for much\n                               of this function because their handling  is\n                               different under /i, and for most classes under\n                               /d as well */\n    SV* nposixes = NULL;    /* Similarly for [:^word:].  These are kept\n                               separate for a while from the non-complemented\n                               versions because of complications with /d\n                               matching */\n    SV* simple_posixes = NULL; /* But under some conditions, the classes can be\n                                  treated more simply than the general case,\n                                  leading to less compilation and execution\n                                  work */\n    UV element_count = 0;   /* Number of distinct elements in the class.\n\t\t\t       Optimizations may be possible if this is tiny */\n    AV * multi_char_matches = NULL; /* Code points that fold to more than one\n                                       character; used under /i */\n    UV n;\n    char * stop_ptr = RExC_end;    /* where to stop parsing */\n\n    /* ignore unescaped whitespace? */\n    const bool skip_white = cBOOL(   ret_invlist\n                                  || (RExC_flags & RXf_PMf_EXTENDED_MORE));\n\n    /* Unicode properties are stored in a swash; this holds the current one\n     * being parsed.  If this swash is the only above-latin1 component of the\n     * character class, an optimization is to pass it directly on to the\n     * execution engine.  Otherwise, it is set to NULL to indicate that there\n     * are other things in the class that have to be dealt with at execution\n     * time */\n    SV* swash = NULL;\t\t/* Code points that match \\p{} \\P{} */\n\n    /* Set if a component of this character class is user-defined; just passed\n     * on to the engine */\n    bool has_user_defined_property = FALSE;\n\n    /* inversion list of code points this node matches only when the target\n     * string is in UTF-8.  These are all non-ASCII, < 256.  (Because is under\n     * /d) */\n    SV* has_upper_latin1_only_utf8_matches = NULL;\n\n    /* Inversion list of code points this node matches regardless of things\n     * like locale, folding, utf8ness of the target string */\n    SV* cp_list = NULL;\n\n    /* Like cp_list, but code points on this list need to be checked for things\n     * that fold to/from them under /i */\n    SV* cp_foldable_list = NULL;\n\n    /* Like cp_list, but code points on this list are valid only when the\n     * runtime locale is UTF-8 */\n    SV* only_utf8_locale_list = NULL;\n\n    /* In a range, if one of the endpoints is non-character-set portable,\n     * meaning that it hard-codes a code point that may mean a different\n     * charactger in ASCII vs. EBCDIC, as opposed to, say, a literal 'A' or a\n     * mnemonic '\\t' which each mean the same character no matter which\n     * character set the platform is on. */\n    unsigned int non_portable_endpoint = 0;\n\n    /* Is the range unicode? which means on a platform that isn't 1-1 native\n     * to Unicode (i.e. non-ASCII), each code point in it should be considered\n     * to be a Unicode value.  */\n    bool unicode_range = FALSE;\n    bool invert = FALSE;    /* Is this class to be complemented */\n\n    bool warn_super = ALWAYS_WARN_SUPER;\n\n    regnode * const orig_emit = RExC_emit; /* Save the original RExC_emit in\n        case we need to change the emitted regop to an EXACT. */\n    const char * orig_parse = RExC_parse;\n    const SSize_t orig_size = RExC_size;\n    bool posixl_matches_all = FALSE; /* Does /l class have both e.g. \\W,\\w ? */\n\n    /* This variable is used to mark where the end in the input is of something\n     * that looks like a POSIX construct but isn't.  During the parse, when\n     * something looks like it could be such a construct is encountered, it is\n     * checked for being one, but not if we've already checked this area of the\n     * input.  Only after this position is reached do we check again */\n    char *not_posix_region_end = RExC_parse - 1;\n\n    AV* posix_warnings = NULL;\n    const bool do_posix_warnings =     return_posix_warnings\n                                   || (PASS2 && ckWARN(WARN_REGEXP));\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGCLASS;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    DEBUG_PARSE(\"clas\");\n\n#if UNICODE_MAJOR_VERSION < 3 /* no multifolds in early Unicode */      \\\n    || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0          \\\n                                   && UNICODE_DOT_DOT_VERSION == 0)\n    allow_multi_folds = FALSE;\n#endif\n\n    /* Assume we are going to generate an ANYOF node. */\n    ret = reganode(pRExC_state,\n                   (LOC)\n                    ? ANYOFL\n                    : ANYOF,\n                   0);\n\n    if (SIZE_ONLY) {\n\tRExC_size += ANYOF_SKIP;\n\tlistsv = &PL_sv_undef; /* For code scanners: listsv always non-NULL. */\n    }\n    else {\n        ANYOF_FLAGS(ret) = 0;\n\n \tRExC_emit += ANYOF_SKIP;\n\tlistsv = newSVpvs_flags(\"# comment\\n\", SVs_TEMP);\n\tinitial_listsv_len = SvCUR(listsv);\n        SvTEMP_off(listsv); /* Grr, TEMPs and mortals are conflated.  */\n    }\n\n    SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n    assert(RExC_parse <= RExC_end);\n\n    if (UCHARAT(RExC_parse) == '^') {\t/* Complement the class */\n\tRExC_parse++;\n        invert = TRUE;\n        allow_multi_folds = FALSE;\n        MARK_NAUGHTY(1);\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n    }\n\n    /* Check that they didn't say [:posix:] instead of [[:posix:]] */\n    if (! ret_invlist && MAYBE_POSIXCC(UCHARAT(RExC_parse))) {\n        int maybe_class = handle_possible_posix(pRExC_state,\n                                                RExC_parse,\n                                                &not_posix_region_end,\n                                                NULL,\n                                                TRUE /* checking only */);\n        if (PASS2 && maybe_class >= OOB_NAMEDCLASS && do_posix_warnings) {\n            SAVEFREESV(RExC_rx_sv);\n            ckWARN4reg(not_posix_region_end,\n                    \"POSIX syntax [%c %c] belongs inside character classes%s\",\n                    *RExC_parse, *RExC_parse,\n                    (maybe_class == OOB_NAMEDCLASS)\n                    ? ((POSIXCC_NOTYET(*RExC_parse))\n                        ? \" (but this one isn't implemented)\"\n                        : \" (but this one isn't fully valid)\")\n                    : \"\"\n                    );\n            (void)ReREFCNT_inc(RExC_rx_sv);\n        }\n    }\n\n    /* If the caller wants us to just parse a single element, accomplish this\n     * by faking the loop ending condition */\n    if (stop_at_1 && RExC_end > RExC_parse) {\n        stop_ptr = RExC_parse + 1;\n    }\n\n    /* allow 1st char to be ']' (allowing it to be '-' is dealt with later) */\n    if (UCHARAT(RExC_parse) == ']')\n\tgoto charclassloop;\n\n    while (1) {\n\n        if (   posix_warnings\n            && av_tindex_skip_len_mg(posix_warnings) >= 0\n            && RExC_parse > not_posix_region_end)\n        {\n            /* Warnings about posix class issues are considered tentative until\n             * we are far enough along in the parse that we can no longer\n             * change our mind, at which point we either output them or add\n             * them, if it has so specified, to what gets returned to the\n             * caller.  This is done each time through the loop so that a later\n             * class won't zap them before they have been dealt with. */\n            output_or_return_posix_warnings(pRExC_state, posix_warnings,\n                                            return_posix_warnings);\n        }\n\n        if  (RExC_parse >= stop_ptr) {\n            break;\n        }\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        if  (UCHARAT(RExC_parse) == ']') {\n            break;\n        }\n\n      charclassloop:\n\n\tnamedclass = OOB_NAMEDCLASS; /* initialize as illegal */\n        save_value = value;\n        save_prevvalue = prevvalue;\n\n\tif (!range) {\n\t    rangebegin = RExC_parse;\n\t    element_count++;\n            non_portable_endpoint = 0;\n\t}\n\tif (UTF && ! UTF8_IS_INVARIANT(* RExC_parse)) {\n\t    value = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t    RExC_parse += numlen;\n\t}\n\telse\n\t    value = UCHARAT(RExC_parse++);\n\n        if (value == '[') {\n            char * posix_class_end;\n            namedclass = handle_possible_posix(pRExC_state,\n                                               RExC_parse,\n                                               &posix_class_end,\n                                               do_posix_warnings ? &posix_warnings : NULL,\n                                               FALSE    /* die if error */);\n            if (namedclass > OOB_NAMEDCLASS) {\n\n                /* If there was an earlier attempt to parse this particular\n                 * posix class, and it failed, it was a false alarm, as this\n                 * successful one proves */\n                if (   posix_warnings\n                    && av_tindex_skip_len_mg(posix_warnings) >= 0\n                    && not_posix_region_end >= RExC_parse\n                    && not_posix_region_end <= posix_class_end)\n                {\n                    av_undef(posix_warnings);\n                }\n\n                RExC_parse = posix_class_end;\n            }\n            else if (namedclass == OOB_NAMEDCLASS) {\n                not_posix_region_end = posix_class_end;\n            }\n            else {\n                namedclass = OOB_NAMEDCLASS;\n            }\n        }\n        else if (   RExC_parse - 1 > not_posix_region_end\n                 && MAYBE_POSIXCC(value))\n        {\n            (void) handle_possible_posix(\n                        pRExC_state,\n                        RExC_parse - 1,  /* -1 because parse has already been\n                                            advanced */\n                        &not_posix_region_end,\n                        do_posix_warnings ? &posix_warnings : NULL,\n                        TRUE /* checking only */);\n        }\n        else if (value == '\\\\') {\n            /* Is a backslash; get the code point of the char after it */\n\n            if (RExC_parse >= RExC_end) {\n                vFAIL(\"Unmatched [\");\n            }\n\n\t    if (UTF && ! UTF8_IS_INVARIANT(UCHARAT(RExC_parse))) {\n\t\tvalue = utf8n_to_uvchr((U8*)RExC_parse,\n\t\t\t\t   RExC_end - RExC_parse,\n\t\t\t\t   &numlen, UTF8_ALLOW_DEFAULT);\n\t\tRExC_parse += numlen;\n\t    }\n\t    else\n\t\tvalue = UCHARAT(RExC_parse++);\n\n\t    /* Some compilers cannot handle switching on 64-bit integer\n\t     * values, therefore value cannot be an UV.  Yes, this will\n\t     * be a problem later if we want switch on Unicode.\n\t     * A similar issue a little bit later when switching on\n\t     * namedclass. --jhi */\n\n            /* If the \\ is escaping white space when white space is being\n             * skipped, it means that that white space is wanted literally, and\n             * is already in 'value'.  Otherwise, need to translate the escape\n             * into what it signifies. */\n            if (! skip_white || ! isBLANK_A(value)) switch ((I32)value) {\n\n\t    case 'w':\tnamedclass = ANYOF_WORDCHAR;\tbreak;\n\t    case 'W':\tnamedclass = ANYOF_NWORDCHAR;\tbreak;\n\t    case 's':\tnamedclass = ANYOF_SPACE;\tbreak;\n\t    case 'S':\tnamedclass = ANYOF_NSPACE;\tbreak;\n\t    case 'd':\tnamedclass = ANYOF_DIGIT;\tbreak;\n\t    case 'D':\tnamedclass = ANYOF_NDIGIT;\tbreak;\n\t    case 'v':\tnamedclass = ANYOF_VERTWS;\tbreak;\n\t    case 'V':\tnamedclass = ANYOF_NVERTWS;\tbreak;\n\t    case 'h':\tnamedclass = ANYOF_HORIZWS;\tbreak;\n\t    case 'H':\tnamedclass = ANYOF_NHORIZWS;\tbreak;\n            case 'N':  /* Handle \\N{NAME} in class */\n                {\n                    const char * const backslash_N_beg = RExC_parse - 2;\n                    int cp_count;\n\n                    if (! grok_bslash_N(pRExC_state,\n                                        NULL,      /* No regnode */\n                                        &value,    /* Yes single value */\n                                        &cp_count, /* Multiple code pt count */\n                                        flagp,\n                                        strict,\n                                        depth)\n                    ) {\n\n                        if (*flagp & NEED_UTF8)\n                            FAIL(\"panic: grok_bslash_N set NEED_UTF8\");\n                        if (*flagp & RESTART_PASS1)\n                            return NULL;\n\n                        if (cp_count < 0) {\n                            vFAIL(\"\\\\N in a character class must be a named character: \\\\N{...}\");\n                        }\n                        else if (cp_count == 0) {\n                            if (PASS2) {\n                                ckWARNreg(RExC_parse,\n                                        \"Ignoring zero length \\\\N{} in character class\");\n                            }\n                        }\n                        else { /* cp_count > 1 */\n                            if (! RExC_in_multi_char_class) {\n                                if (invert || range || *RExC_parse == '-') {\n                                    if (strict) {\n                                        RExC_parse--;\n                                        vFAIL(\"\\\\N{} in inverted character class or as a range end-point is restricted to one character\");\n                                    }\n                                    else if (PASS2) {\n                                        ckWARNreg(RExC_parse, \"Using just the first character returned by \\\\N{} in character class\");\n                                    }\n                                    break; /* <value> contains the first code\n                                              point. Drop out of the switch to\n                                              process it */\n                                }\n                                else {\n                                    SV * multi_char_N = newSVpvn(backslash_N_beg,\n                                                 RExC_parse - backslash_N_beg);\n                                    multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_char_N,\n                                                          cp_count);\n                                }\n                            }\n                        } /* End of cp_count != 1 */\n\n                        /* This element should not be processed further in this\n                         * class */\n                        element_count--;\n                        value = save_value;\n                        prevvalue = save_prevvalue;\n                        continue;   /* Back to top of loop to get next char */\n                    }\n\n                    /* Here, is a single code point, and <value> contains it */\n                    unicode_range = TRUE;   /* \\N{} are Unicode */\n                }\n                break;\n\t    case 'p':\n\t    case 'P':\n\t\t{\n\t\tchar *e;\n\n                /* We will handle any undefined properties ourselves */\n                U8 swash_init_flags = _CORE_SWASH_INIT_RETURN_IF_UNDEF\n                                       /* And we actually would prefer to get\n                                        * the straight inversion list of the\n                                        * swash, since we will be accessing it\n                                        * anyway, to save a little time */\n                                      |_CORE_SWASH_INIT_ACCEPT_INVLIST;\n\n\t\tif (RExC_parse >= RExC_end)\n\t\t    vFAIL2(\"Empty \\\\%c\", (U8)value);\n\t\tif (*RExC_parse == '{') {\n\t\t    const U8 c = (U8)value;\n\t\t    e = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n                    if (!e) {\n                        RExC_parse++;\n                        vFAIL2(\"Missing right brace on \\\\%c{}\", c);\n                    }\n\n                    RExC_parse++;\n                    while (isSPACE(*RExC_parse)) {\n                         RExC_parse++;\n\t\t    }\n\n\t\t    if (UCHARAT(RExC_parse) == '^') {\n\n                        /* toggle.  (The rhs xor gets the single bit that\n                         * differs between P and p; the other xor inverts just\n                         * that bit) */\n                        value ^= 'P' ^ 'p';\n\n                        RExC_parse++;\n                        while (isSPACE(*RExC_parse)) {\n                            RExC_parse++;\n                        }\n                    }\n\n                    if (e == RExC_parse)\n                        vFAIL2(\"Empty \\\\%c{}\", c);\n\n\t\t    n = e - RExC_parse;\n\t\t    while (isSPACE(*(RExC_parse + n - 1)))\n\t\t        n--;\n\t\t}   /* The \\p isn't immediately followed by a '{' */\n\t\telse if (! isALPHA(*RExC_parse)) {\n                    RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                    vFAIL2(\"Character following \\\\%c must be '{' or a \"\n                           \"single-character Unicode property name\",\n                           (U8) value);\n                }\n                else {\n\t\t    e = RExC_parse;\n\t\t    n = 1;\n\t\t}\n\t\tif (!SIZE_ONLY) {\n                    SV* invlist;\n                    char* name;\n                    char* base_name;    /* name after any packages are stripped */\n                    char* lookup_name = NULL;\n                    const char * const colon_colon = \"::\";\n\n                    /* Try to get the definition of the property into\n                     * <invlist>.  If /i is in effect, the effective property\n                     * will have its name be <__NAME_i>.  The design is\n                     * discussed in commit\n                     * 2f833f5208e26b208886e51e09e2c072b5eabb46 */\n                    name = savepv(Perl_form(aTHX_ \"%.*s\", (int)n, RExC_parse));\n                    SAVEFREEPV(name);\n                    if (FOLD) {\n                        lookup_name = savepv(Perl_form(aTHX_ \"__%s_i\", name));\n\n                        /* The function call just below that uses this can fail\n                         * to return, leaking memory if we don't do this */\n                        SAVEFREEPV(lookup_name);\n                    }\n\n                    /* Look up the property name, and get its swash and\n                     * inversion list, if the property is found  */\n                    SvREFCNT_dec(swash); /* Free any left-overs */\n                    swash = _core_swash_init(\"utf8\",\n                                             (lookup_name)\n                                              ? lookup_name\n                                              : name,\n                                             &PL_sv_undef,\n                                             1, /* binary */\n                                             0, /* not tr/// */\n                                             NULL, /* No inversion list */\n                                             &swash_init_flags\n                                            );\n                    if (! swash || ! (invlist = _get_swash_invlist(swash))) {\n                        HV* curpkg = (IN_PERL_COMPILETIME)\n                                      ? PL_curstash\n                                      : CopSTASH(PL_curcop);\n                        UV final_n = n;\n                        bool has_pkg;\n\n                        if (swash) {    /* Got a swash but no inversion list.\n                                           Something is likely wrong that will\n                                           be sorted-out later */\n                            SvREFCNT_dec_NN(swash);\n                            swash = NULL;\n                        }\n\n                        /* Here didn't find it.  It could be a an error (like a\n                         * typo) in specifying a Unicode property, or it could\n                         * be a user-defined property that will be available at\n                         * run-time.  The names of these must begin with 'In'\n                         * or 'Is' (after any packages are stripped off).  So\n                         * if not one of those, or if we accept only\n                         * compile-time properties, is an error; otherwise add\n                         * it to the list for run-time look up. */\n                        if ((base_name = rninstr(name, name + n,\n                                                 colon_colon, colon_colon + 2)))\n                        { /* Has ::.  We know this must be a user-defined\n                             property */\n                            base_name += 2;\n                            final_n -= base_name - name;\n                            has_pkg = TRUE;\n                        }\n                        else {\n                            base_name = name;\n                            has_pkg = FALSE;\n                        }\n\n                        if (   final_n < 3\n                            || base_name[0] != 'I'\n                            || (base_name[1] != 's' && base_name[1] != 'n')\n                            || ret_invlist)\n                        {\n                            const char * const msg\n                                = (has_pkg)\n                                  ? \"Illegal user-defined property name\"\n                                  : \"Can't find Unicode property definition\";\n                            RExC_parse = e + 1;\n\n                            /* diag_listed_as: Can't find Unicode property definition \"%s\" */\n                            vFAIL3utf8f(\"%s \\\"%\" UTF8f \"\\\"\",\n                                msg, UTF8fARG(UTF, n, name));\n                        }\n\n                        /* If the property name doesn't already have a package\n                         * name, add the current one to it so that it can be\n                         * referred to outside it. [perl #121777] */\n                        if (! has_pkg && curpkg) {\n                            char* pkgname = HvNAME(curpkg);\n                            if (memNEs(pkgname, HvNAMELEN(curpkg), \"main\")) {\n                                char* full_name = Perl_form(aTHX_\n                                                            \"%s::%s\",\n                                                            pkgname,\n                                                            name);\n                                n = strlen(full_name);\n                                name = savepvn(full_name, n);\n                                SAVEFREEPV(name);\n                            }\n                        }\n                        Perl_sv_catpvf(aTHX_ listsv, \"%cutf8::%s%\" UTF8f \"%s\\n\",\n                                        (value == 'p' ? '+' : '!'),\n                                        (FOLD) ? \"__\" : \"\",\n                                        UTF8fARG(UTF, n, name),\n                                        (FOLD) ? \"_i\" : \"\");\n                        has_user_defined_property = TRUE;\n                        optimizable = FALSE;    /* Will have to leave this an\n                                                   ANYOF node */\n\n                        /* We don't know yet what this matches, so have to flag\n                         * it */\n                        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n                    }\n                    else {\n\n                        /* Here, did get the swash and its inversion list.  If\n                         * the swash is from a user-defined property, then this\n                         * whole character class should be regarded as such */\n                        if (swash_init_flags\n                            & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY)\n                        {\n                            has_user_defined_property = TRUE;\n                        }\n                        else if\n                            /* We warn on matching an above-Unicode code point\n                             * if the match would return true, except don't\n                             * warn for \\p{All}, which has exactly one element\n                             * = 0 */\n                            (_invlist_contains_cp(invlist, 0x110000)\n                                && (! (_invlist_len(invlist) == 1\n                                       && *invlist_array(invlist) == 0)))\n                        {\n                            warn_super = TRUE;\n                        }\n\n\n                        /* Invert if asking for the complement */\n                        if (value == 'P') {\n\t\t\t    _invlist_union_complement_2nd(properties,\n                                                          invlist,\n                                                          &properties);\n\n                            /* The swash can't be used as-is, because we've\n\t\t\t     * inverted things; delay removing it to here after\n\t\t\t     * have copied its invlist above */\n                            SvREFCNT_dec_NN(swash);\n                            swash = NULL;\n                        }\n                        else {\n                            _invlist_union(properties, invlist, &properties);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tRExC_parse = e + 1;\n                namedclass = ANYOF_UNIPROP;  /* no official name, but it's\n                                                named */\n\n\t\t/* \\p means they want Unicode semantics */\n\t\tREQUIRE_UNI_RULES(flagp, NULL);\n\t\t}\n\t\tbreak;\n\t    case 'n':\tvalue = '\\n';\t\t\tbreak;\n\t    case 'r':\tvalue = '\\r';\t\t\tbreak;\n\t    case 't':\tvalue = '\\t';\t\t\tbreak;\n\t    case 'f':\tvalue = '\\f';\t\t\tbreak;\n\t    case 'b':\tvalue = '\\b';\t\t\tbreak;\n\t    case 'e':\tvalue = ESC_NATIVE;             break;\n\t    case 'a':\tvalue = '\\a';                   break;\n\t    case 'o':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'o' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_o(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n                                               PASS2,   /* warnings only in\n                                                           pass 2 */\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n\t\t    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'x':\n\t\tRExC_parse--;\t/* function expects to be pointed at the 'x' */\n\t\t{\n\t\t    const char* error_msg;\n\t\t    bool valid = grok_bslash_x(&RExC_parse,\n                                               RExC_end,\n\t\t\t\t\t       &value,\n\t\t\t\t\t       &error_msg,\n\t\t\t\t\t       PASS2, /* Output warnings */\n                                               strict,\n                                               silence_non_portable,\n                                               UTF);\n                    if (! valid) {\n\t\t\tvFAIL(error_msg);\n\t\t    }\n\t\t}\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case 'c':\n\t\tvalue = grok_bslash_c(*RExC_parse++, PASS2);\n                non_portable_endpoint++;\n\t\tbreak;\n\t    case '0': case '1': case '2': case '3': case '4':\n\t    case '5': case '6': case '7':\n\t\t{\n\t\t    /* Take 1-3 octal digits */\n\t\t    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;\n                    numlen = (strict) ? 4 : 3;\n                    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);\n\t\t    RExC_parse += numlen;\n                    if (numlen != 3) {\n                        if (strict) {\n                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n                            vFAIL(\"Need exactly 3 octal digits\");\n                        }\n                        else if (! SIZE_ONLY /* like \\08, \\178 */\n                                 && numlen < 3\n                                 && RExC_parse < RExC_end\n                                 && isDIGIT(*RExC_parse)\n                                 && ckWARN(WARN_REGEXP))\n                        {\n                            SAVEFREESV(RExC_rx_sv);\n                            reg_warn_non_literal_string(\n                                 RExC_parse + 1,\n                                 form_short_octal_warning(RExC_parse, numlen));\n                            (void)ReREFCNT_inc(RExC_rx_sv);\n                        }\n                    }\n                    non_portable_endpoint++;\n\t\t    break;\n\t\t}\n\t    default:\n\t\t/* Allow \\_ to not give an error */\n\t\tif (!SIZE_ONLY && isWORDCHAR(value) && value != '_') {\n                    if (strict) {\n                        vFAIL2(\"Unrecognized escape \\\\%c in character class\",\n                               (int)value);\n                    }\n                    else {\n                        SAVEFREESV(RExC_rx_sv);\n                        ckWARN2reg(RExC_parse,\n                            \"Unrecognized escape \\\\%c in character class passed through\",\n                            (int)value);\n                        (void)ReREFCNT_inc(RExC_rx_sv);\n                    }\n\t\t}\n\t\tbreak;\n\t    }   /* End of switch on char following backslash */\n\t} /* end of handling backslash escape sequences */\n\n        /* Here, we have the current token in 'value' */\n\n\tif (namedclass > OOB_NAMEDCLASS) { /* this is a named class \\blah */\n            U8 classnum;\n\n\t    /* a bad range like a-\\d, a-[:digit:].  The '-' is taken as a\n\t     * literal, as is the character that began the false range, i.e.\n\t     * the 'a' in the examples */\n\t    if (range) {\n\t\tif (!SIZE_ONLY) {\n\t\t    const int w = (RExC_parse >= rangebegin)\n                                  ? RExC_parse - rangebegin\n                                  : 0;\n                    if (strict) {\n                        vFAIL2utf8f(\n                            \"False [] range \\\"%\" UTF8f \"\\\"\",\n                            UTF8fARG(UTF, w, rangebegin));\n                    }\n                    else {\n                        SAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */\n                        ckWARN2reg(RExC_parse,\n                            \"False [] range \\\"%\" UTF8f \"\\\"\",\n                            UTF8fARG(UTF, w, rangebegin));\n                        (void)ReREFCNT_inc(RExC_rx_sv);\n                        cp_list = add_cp_to_invlist(cp_list, '-');\n                        cp_foldable_list = add_cp_to_invlist(cp_foldable_list,\n                                                             prevvalue);\n                    }\n\t\t}\n\n\t\trange = 0; /* this was not a true range */\n                element_count += 2; /* So counts for three values */\n\t    }\n\n            classnum = namedclass_to_classnum(namedclass);\n\n\t    if (LOC && namedclass < ANYOF_POSIXL_MAX\n#ifndef HAS_ISASCII\n                && classnum != _CC_ASCII\n#endif\n            ) {\n                /* What the Posix classes (like \\w, [:space:]) match in locale\n                 * isn't knowable under locale until actual match time.  Room\n                 * must be reserved (one time per outer bracketed class) to\n                 * store such classes.  The space will contain a bit for each\n                 * named class that is to be matched against.  This isn't\n                 * needed for \\p{} and pseudo-classes, as they are not affected\n                 * by locale, and hence are dealt with separately */\n                if (! need_class) {\n                    need_class = 1;\n                    if (SIZE_ONLY) {\n                        RExC_size += ANYOF_POSIXL_SKIP - ANYOF_SKIP;\n                    }\n                    else {\n                        RExC_emit += ANYOF_POSIXL_SKIP - ANYOF_SKIP;\n                    }\n                    ANYOF_FLAGS(ret) |= ANYOF_MATCHES_POSIXL;\n                    ANYOF_POSIXL_ZERO(ret);\n\n                    /* We can't change this into some other type of node\n                     * (unless this is the only element, in which case there\n                     * are nodes that mean exactly this) as has runtime\n                     * dependencies */\n                    optimizable = FALSE;\n                }\n\n                /* Coverity thinks it is possible for this to be negative; both\n                 * jhi and khw think it's not, but be safer */\n                assert(! (ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)\n                       || (namedclass + ((namedclass % 2) ? -1 : 1)) >= 0);\n\n                /* See if it already matches the complement of this POSIX\n                 * class */\n                if ((ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)\n                    && ANYOF_POSIXL_TEST(ret, namedclass + ((namedclass % 2)\n                                                            ? -1\n                                                            : 1)))\n                {\n                    posixl_matches_all = TRUE;\n                    break;  /* No need to continue.  Since it matches both\n                               e.g., \\w and \\W, it matches everything, and the\n                               bracketed class can be optimized into qr/./s */\n                }\n\n                /* Add this class to those that should be checked at runtime */\n                ANYOF_POSIXL_SET(ret, namedclass);\n\n                /* The above-Latin1 characters are not subject to locale rules.\n                 * Just add them, in the second pass, to the\n                 * unconditionally-matched list */\n                if (! SIZE_ONLY) {\n                    SV* scratch_list = NULL;\n\n                    /* Get the list of the above-Latin1 code points this\n                     * matches */\n                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,\n                                          PL_XPosix_ptrs[classnum],\n\n                                          /* Odd numbers are complements, like\n                                           * NDIGIT, NASCII, ... */\n                                          namedclass % 2 != 0,\n                                          &scratch_list);\n                    /* Checking if 'cp_list' is NULL first saves an extra\n                     * clone.  Its reference count will be decremented at the\n                     * next union, etc, or if this is the only instance, at the\n                     * end of the routine */\n                    if (! cp_list) {\n                        cp_list = scratch_list;\n                    }\n                    else {\n                        _invlist_union(cp_list, scratch_list, &cp_list);\n                        SvREFCNT_dec_NN(scratch_list);\n                    }\n                    continue;   /* Go get next character */\n                }\n            }\n            else if (! SIZE_ONLY) {\n\n                /* Here, not in pass1 (in that pass we skip calculating the\n                 * contents of this class), and is not /l, or is a POSIX class\n                 * for which /l doesn't matter (or is a Unicode property, which\n                 * is skipped here). */\n                if (namedclass >= ANYOF_POSIXL_MAX) {  /* If a special class */\n                    if (namedclass != ANYOF_UNIPROP) { /* UNIPROP = \\p and \\P */\n\n                        /* Here, should be \\h, \\H, \\v, or \\V.  None of /d, /i\n                         * nor /l make a difference in what these match,\n                         * therefore we just add what they match to cp_list. */\n                        if (classnum != _CC_VERTSPACE) {\n                            assert(   namedclass == ANYOF_HORIZWS\n                                   || namedclass == ANYOF_NHORIZWS);\n\n                            /* It turns out that \\h is just a synonym for\n                             * XPosixBlank */\n                            classnum = _CC_BLANK;\n                        }\n\n                        _invlist_union_maybe_complement_2nd(\n                                cp_list,\n                                PL_XPosix_ptrs[classnum],\n                                namedclass % 2 != 0,    /* Complement if odd\n                                                          (NHORIZWS, NVERTWS)\n                                                        */\n                                &cp_list);\n                    }\n                }\n                else if (  UNI_SEMANTICS\n                        || classnum == _CC_ASCII\n                        || (DEPENDS_SEMANTICS && (   classnum == _CC_DIGIT\n                                                  || classnum == _CC_XDIGIT)))\n                {\n                    /* We usually have to worry about /d and /a affecting what\n                     * POSIX classes match, with special code needed for /d\n                     * because we won't know until runtime what all matches.\n                     * But there is no extra work needed under /u, and\n                     * [:ascii:] is unaffected by /a and /d; and :digit: and\n                     * :xdigit: don't have runtime differences under /d.  So we\n                     * can special case these, and avoid some extra work below,\n                     * and at runtime. */\n                    _invlist_union_maybe_complement_2nd(\n                                                     simple_posixes,\n                                                     PL_XPosix_ptrs[classnum],\n                                                     namedclass % 2 != 0,\n                                                     &simple_posixes);\n                }\n                else {  /* Garden variety class.  If is NUPPER, NALPHA, ...\n                           complement and use nposixes */\n                    SV** posixes_ptr = namedclass % 2 == 0\n                                       ? &posixes\n                                       : &nposixes;\n                    _invlist_union_maybe_complement_2nd(\n                                                     *posixes_ptr,\n                                                     PL_XPosix_ptrs[classnum],\n                                                     namedclass % 2 != 0,\n                                                     posixes_ptr);\n                }\n\t    }\n\t} /* end of namedclass \\blah */\n\n        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);\n\n        /* If 'range' is set, 'value' is the ending of a range--check its\n         * validity.  (If value isn't a single code point in the case of a\n         * range, we should have figured that out above in the code that\n         * catches false ranges).  Later, we will handle each individual code\n         * point in the range.  If 'range' isn't set, this could be the\n         * beginning of a range, so check for that by looking ahead to see if\n         * the next real character to be processed is the range indicator--the\n         * minus sign */\n\n\tif (range) {\n#ifdef EBCDIC\n            /* For unicode ranges, we have to test that the Unicode as opposed\n             * to the native values are not decreasing.  (Above 255, there is\n             * no difference between native and Unicode) */\n\t    if (unicode_range && prevvalue < 255 && value < 255) {\n                if (NATIVE_TO_LATIN1(prevvalue) > NATIVE_TO_LATIN1(value)) {\n                    goto backwards_range;\n                }\n            }\n            else\n#endif\n\t    if (prevvalue > value) /* b-a */ {\n\t\tint w;\n#ifdef EBCDIC\n              backwards_range:\n#endif\n                w = RExC_parse - rangebegin;\n                vFAIL2utf8f(\n                    \"Invalid [] range \\\"%\" UTF8f \"\\\"\",\n                    UTF8fARG(UTF, w, rangebegin));\n                NOT_REACHED; /* NOTREACHED */\n\t    }\n\t}\n\telse {\n            prevvalue = value; /* save the beginning of the potential range */\n            if (! stop_at_1     /* Can't be a range if parsing just one thing */\n                && *RExC_parse == '-')\n            {\n                char* next_char_ptr = RExC_parse + 1;\n\n                /* Get the next real char after the '-' */\n                SKIP_BRACKETED_WHITE_SPACE(skip_white, next_char_ptr);\n\n                /* If the '-' is at the end of the class (just before the ']',\n                 * it is a literal minus; otherwise it is a range */\n                if (next_char_ptr < RExC_end && *next_char_ptr != ']') {\n                    RExC_parse = next_char_ptr;\n\n                    /* a bad range like \\w-, [:word:]- ? */\n                    if (namedclass > OOB_NAMEDCLASS) {\n                        if (strict || (PASS2 && ckWARN(WARN_REGEXP))) {\n                            const int w = RExC_parse >= rangebegin\n                                          ?  RExC_parse - rangebegin\n                                          : 0;\n                            if (strict) {\n                                vFAIL4(\"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                            else if (PASS2) {\n                                vWARN4(RExC_parse,\n                                    \"False [] range \\\"%*.*s\\\"\",\n                                    w, w, rangebegin);\n                            }\n                        }\n                        if (!SIZE_ONLY) {\n                            cp_list = add_cp_to_invlist(cp_list, '-');\n                        }\n                        element_count++;\n                    } else\n                        range = 1;\t/* yeah, it's a range! */\n                    continue;\t/* but do it the next time */\n                }\n\t    }\n\t}\n\n        if (namedclass > OOB_NAMEDCLASS) {\n            continue;\n        }\n\n        /* Here, we have a single value this time through the loop, and\n         * <prevvalue> is the beginning of the range, if any; or <value> if\n         * not. */\n\n\t/* non-Latin1 code point implies unicode semantics.  Must be set in\n\t * pass1 so is there for the whole of pass 2 */\n\tif (value > 255) {\n            REQUIRE_UNI_RULES(flagp, NULL);\n\t}\n\n        /* Ready to process either the single value, or the completed range.\n         * For single-valued non-inverted ranges, we consider the possibility\n         * of multi-char folds.  (We made a conscious decision to not do this\n         * for the other cases because it can often lead to non-intuitive\n         * results.  For example, you have the peculiar case that:\n         *  \"s s\" =~ /^[^\\xDF]+$/i => Y\n         *  \"ss\"  =~ /^[^\\xDF]+$/i => N\n         *\n         * See [perl #89750] */\n        if (FOLD && allow_multi_folds && value == prevvalue) {\n            if (value == LATIN_SMALL_LETTER_SHARP_S\n                || (value > 255 && _invlist_contains_cp(PL_HasMultiCharFold,\n                                                        value)))\n            {\n                /* Here <value> is indeed a multi-char fold.  Get what it is */\n\n                U8 foldbuf[UTF8_MAXBYTES_CASE];\n                STRLEN foldlen;\n\n                UV folded = _to_uni_fold_flags(\n                                value,\n                                foldbuf,\n                                &foldlen,\n                                FOLD_FLAGS_FULL | (ASCII_FOLD_RESTRICTED\n                                                   ? FOLD_FLAGS_NOMIX_ASCII\n                                                   : 0)\n                                );\n\n                /* Here, <folded> should be the first character of the\n                 * multi-char fold of <value>, with <foldbuf> containing the\n                 * whole thing.  But, if this fold is not allowed (because of\n                 * the flags), <fold> will be the same as <value>, and should\n                 * be processed like any other character, so skip the special\n                 * handling */\n                if (folded != value) {\n\n                    /* Skip if we are recursed, currently parsing the class\n                     * again.  Otherwise add this character to the list of\n                     * multi-char folds. */\n                    if (! RExC_in_multi_char_class) {\n                        STRLEN cp_count = utf8_length(foldbuf,\n                                                      foldbuf + foldlen);\n                        SV* multi_fold = sv_2mortal(newSVpvs(\"\"));\n\n                        Perl_sv_catpvf(aTHX_ multi_fold, \"\\\\x{%\" UVXf \"}\", value);\n\n                        multi_char_matches\n                                        = add_multi_match(multi_char_matches,\n                                                          multi_fold,\n                                                          cp_count);\n\n                    }\n\n                    /* This element should not be processed further in this\n                     * class */\n                    element_count--;\n                    value = save_value;\n                    prevvalue = save_prevvalue;\n                    continue;\n                }\n            }\n        }\n\n        if (strict && PASS2 && ckWARN(WARN_REGEXP)) {\n            if (range) {\n\n                /* If the range starts above 255, everything is portable and\n                 * likely to be so for any forseeable character set, so don't\n                 * warn. */\n                if (unicode_range && non_portable_endpoint && prevvalue < 256) {\n                    vWARN(RExC_parse, \"Both or neither range ends should be Unicode\");\n                }\n                else if (prevvalue != value) {\n\n                    /* Under strict, ranges that stop and/or end in an ASCII\n                     * printable should have each end point be a portable value\n                     * for it (preferably like 'A', but we don't warn if it is\n                     * a (portable) Unicode name or code point), and the range\n                     * must be be all digits or all letters of the same case.\n                     * Otherwise, the range is non-portable and unclear as to\n                     * what it contains */\n                    if (             (isPRINT_A(prevvalue) || isPRINT_A(value))\n                        && (          non_portable_endpoint\n                            || ! (   (isDIGIT_A(prevvalue) && isDIGIT_A(value))\n                                  || (isLOWER_A(prevvalue) && isLOWER_A(value))\n                                  || (isUPPER_A(prevvalue) && isUPPER_A(value))\n                    ))) {\n                        vWARN(RExC_parse, \"Ranges of ASCII printables should\"\n                                          \" be some subset of \\\"0-9\\\",\"\n                                          \" \\\"A-Z\\\", or \\\"a-z\\\"\");\n                    }\n                    else if (prevvalue >= 0x660) { /* ARABIC_INDIC_DIGIT_ZERO */\n                        SSize_t index_start;\n                        SSize_t index_final;\n\n                        /* But the nature of Unicode and languages mean we\n                         * can't do the same checks for above-ASCII ranges,\n                         * except in the case of digit ones.  These should\n                         * contain only digits from the same group of 10.  The\n                         * ASCII case is handled just above.  0x660 is the\n                         * first digit character beyond ASCII.  Hence here, the\n                         * range could be a range of digits.  First some\n                         * unlikely special cases.  Grandfather in that a range\n                         * ending in 19DA (NEW TAI LUE THAM DIGIT ONE) is bad\n                         * if its starting value is one of the 10 digits prior\n                         * to it.  This is because it is an alternate way of\n                         * writing 19D1, and some people may expect it to be in\n                         * that group.  But it is bad, because it won't give\n                         * the expected results.  In Unicode 5.2 it was\n                         * considered to be in that group (of 11, hence), but\n                         * this was fixed in the next version */\n\n                        if (UNLIKELY(value == 0x19DA && prevvalue >= 0x19D0)) {\n                            goto warn_bad_digit_range;\n                        }\n                        else if (UNLIKELY(   prevvalue >= 0x1D7CE\n                                          &&     value <= 0x1D7FF))\n                        {\n                            /* This is the only other case currently in Unicode\n                             * where the algorithm below fails.  The code\n                             * points just above are the end points of a single\n                             * range containing only decimal digits.  It is 5\n                             * different series of 0-9.  All other ranges of\n                             * digits currently in Unicode are just a single\n                             * series.  (And mktables will notify us if a later\n                             * Unicode version breaks this.)\n                             *\n                             * If the range being checked is at most 9 long,\n                             * and the digit values represented are in\n                             * numerical order, they are from the same series.\n                             * */\n                            if (         value - prevvalue > 9\n                                ||    (((    value - 0x1D7CE) % 10)\n                                     <= (prevvalue - 0x1D7CE) % 10))\n                            {\n                                goto warn_bad_digit_range;\n                            }\n                        }\n                        else {\n\n                            /* For all other ranges of digits in Unicode, the\n                             * algorithm is just to check if both end points\n                             * are in the same series, which is the same range.\n                             * */\n                            index_start = _invlist_search(\n                                                    PL_XPosix_ptrs[_CC_DIGIT],\n                                                    prevvalue);\n\n                            /* Warn if the range starts and ends with a digit,\n                             * and they are not in the same group of 10. */\n                            if (   index_start >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_start)\n                                && (index_final =\n                                    _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],\n                                                    value)) != index_start\n                                && index_final >= 0\n                                && ELEMENT_RANGE_MATCHES_INVLIST(index_final))\n                            {\n                              warn_bad_digit_range:\n                                vWARN(RExC_parse, \"Ranges of digits should be\"\n                                                  \" from the same group of\"\n                                                  \" 10\");\n                            }\n                        }\n                    }\n                }\n            }\n            if ((! range || prevvalue == value) && non_portable_endpoint) {\n                if (isPRINT_A(value)) {\n                    char literal[3];\n                    unsigned d = 0;\n                    if (isBACKSLASHED_PUNCT(value)) {\n                        literal[d++] = '\\\\';\n                    }\n                    literal[d++] = (char) value;\n                    literal[d++] = '\\0';\n\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           literal\n                        );\n                }\n                else if isMNEMONIC_CNTRL(value) {\n                    vWARN4(RExC_parse,\n                           \"\\\"%.*s\\\" is more clearly written simply as \\\"%s\\\"\",\n                           (int) (RExC_parse - rangebegin),\n                           rangebegin,\n                           cntrl_to_mnemonic((U8) value)\n                        );\n                }\n            }\n        }\n\n        /* Deal with this element of the class */\n\tif (! SIZE_ONLY) {\n\n#ifndef EBCDIC\n            cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                     prevvalue, value);\n#else\n            /* On non-ASCII platforms, for ranges that span all of 0..255, and\n             * ones that don't require special handling, we can just add the\n             * range like we do for ASCII platforms */\n            if ((UNLIKELY(prevvalue == 0) && value >= 255)\n                || ! (prevvalue < 256\n                      && (unicode_range\n                          || (! non_portable_endpoint\n                              && ((isLOWER_A(prevvalue) && isLOWER_A(value))\n                                  || (isUPPER_A(prevvalue)\n                                      && isUPPER_A(value)))))))\n            {\n                cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                         prevvalue, value);\n            }\n            else {\n                /* Here, requires special handling.  This can be because it is\n                 * a range whose code points are considered to be Unicode, and\n                 * so must be individually translated into native, or because\n                 * its a subrange of 'A-Z' or 'a-z' which each aren't\n                 * contiguous in EBCDIC, but we have defined them to include\n                 * only the \"expected\" upper or lower case ASCII alphabetics.\n                 * Subranges above 255 are the same in native and Unicode, so\n                 * can be added as a range */\n                U8 start = NATIVE_TO_LATIN1(prevvalue);\n                unsigned j;\n                U8 end = (value < 256) ? NATIVE_TO_LATIN1(value) : 255;\n                for (j = start; j <= end; j++) {\n                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list, LATIN1_TO_NATIVE(j));\n                }\n                if (value > 255) {\n                    cp_foldable_list = _add_range_to_invlist(cp_foldable_list,\n                                                             256, value);\n                }\n            }\n#endif\n        }\n\n\trange = 0; /* this range (if it was one) is done now */\n    } /* End of loop through all the text within the brackets */\n\n\n    if (   posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {\n        output_or_return_posix_warnings(pRExC_state, posix_warnings,\n                                        return_posix_warnings);\n    }\n\n    /* If anything in the class expands to more than one character, we have to\n     * deal with them by building up a substitute parse string, and recursively\n     * calling reg() on it, instead of proceeding */\n    if (multi_char_matches) {\n\tSV * substitute_parse = newSVpvn_flags(\"?:\", 2, SVs_TEMP);\n        I32 cp_count;\n\tSTRLEN len;\n\tchar *save_end = RExC_end;\n\tchar *save_parse = RExC_parse;\n\tchar *save_start = RExC_start;\n        STRLEN prefix_end = 0;      /* We copy the character class after a\n                                       prefix supplied here.  This is the size\n                                       + 1 of that prefix */\n        bool first_time = TRUE;     /* First multi-char occurrence doesn't get\n                                       a \"|\" */\n        I32 reg_flags;\n\n        assert(! invert);\n        assert(RExC_precomp_adj == 0); /* Only one level of recursion allowed */\n\n#if 0   /* Have decided not to deal with multi-char folds in inverted classes,\n           because too confusing */\n        if (invert) {\n            sv_catpv(substitute_parse, \"(?:\");\n        }\n#endif\n\n        /* Look at the longest folds first */\n        for (cp_count = av_tindex_skip_len_mg(multi_char_matches);\n                        cp_count > 0;\n                        cp_count--)\n        {\n\n            if (av_exists(multi_char_matches, cp_count)) {\n                AV** this_array_ptr;\n                SV* this_sequence;\n\n                this_array_ptr = (AV**) av_fetch(multi_char_matches,\n                                                 cp_count, FALSE);\n                while ((this_sequence = av_pop(*this_array_ptr)) !=\n                                                                &PL_sv_undef)\n                {\n                    if (! first_time) {\n                        sv_catpv(substitute_parse, \"|\");\n                    }\n                    first_time = FALSE;\n\n                    sv_catpv(substitute_parse, SvPVX(this_sequence));\n                }\n            }\n        }\n\n        /* If the character class contains anything else besides these\n         * multi-character folds, have to include it in recursive parsing */\n        if (element_count) {\n            sv_catpv(substitute_parse, \"|[\");\n            prefix_end = SvCUR(substitute_parse);\n            sv_catpvn(substitute_parse, orig_parse, RExC_parse - orig_parse);\n\n            /* Put in a closing ']' only if not going off the end, as otherwise\n             * we are adding something that really isn't there */\n            if (RExC_parse < RExC_end) {\n                sv_catpv(substitute_parse, \"]\");\n            }\n        }\n\n        sv_catpv(substitute_parse, \")\");\n#if 0\n        if (invert) {\n            /* This is a way to get the parse to skip forward a whole named\n             * sequence instead of matching the 2nd character when it fails the\n             * first */\n            sv_catpv(substitute_parse, \"(*THEN)(*SKIP)(*FAIL)|.)\");\n        }\n#endif\n\n        /* Set up the data structure so that any errors will be properly\n         * reported.  See the comments at the definition of\n         * REPORT_LOCATION_ARGS for details */\n        RExC_precomp_adj = orig_parse - RExC_precomp;\n\tRExC_start =  RExC_parse = SvPV(substitute_parse, len);\n        RExC_adjusted_start = RExC_start + prefix_end;\n\tRExC_end = RExC_parse + len;\n        RExC_in_multi_char_class = 1;\n        RExC_emit = (regnode *)orig_emit;\n\n\tret = reg(pRExC_state, 1, &reg_flags, depth+1);\n\n\t*flagp |= reg_flags&(HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_PASS1|NEED_UTF8);\n\n        /* And restore so can parse the rest of the pattern */\n        RExC_parse = save_parse;\n\tRExC_start = RExC_adjusted_start = save_start;\n        RExC_precomp_adj = 0;\n\tRExC_end = save_end;\n\tRExC_in_multi_char_class = 0;\n        SvREFCNT_dec_NN(multi_char_matches);\n        return ret;\n    }\n\n    /* Here, we've gone through the entire class and dealt with multi-char\n     * folds.  We are now in a position that we can do some checks to see if we\n     * can optimize this ANYOF node into a simpler one, even in Pass 1.\n     * Currently we only do two checks:\n     * 1) is in the unlikely event that the user has specified both, eg. \\w and\n     *    \\W under /l, then the class matches everything.  (This optimization\n     *    is done only to make the optimizer code run later work.)\n     * 2) if the character class contains only a single element (including a\n     *    single range), we see if there is an equivalent node for it.\n     * Other checks are possible */\n    if (   optimizable\n        && ! ret_invlist   /* Can't optimize if returning the constructed\n                              inversion list */\n        && (UNLIKELY(posixl_matches_all) || element_count == 1))\n    {\n        U8 op = END;\n        U8 arg = 0;\n\n        if (UNLIKELY(posixl_matches_all)) {\n            op = SANY;\n        }\n        else if (namedclass > OOB_NAMEDCLASS) { /* this is a single named\n                                                   class, like \\w or [:digit:]\n                                                   or \\p{foo} */\n\n            /* All named classes are mapped into POSIXish nodes, with its FLAG\n             * argument giving which class it is */\n            switch ((I32)namedclass) {\n                case ANYOF_UNIPROP:\n                    break;\n\n                /* These don't depend on the charset modifiers.  They always\n                 * match under /u rules */\n                case ANYOF_NHORIZWS:\n                case ANYOF_HORIZWS:\n                    namedclass = ANYOF_BLANK + namedclass - ANYOF_HORIZWS;\n                    /* FALLTHROUGH */\n\n                case ANYOF_NVERTWS:\n                case ANYOF_VERTWS:\n                    op = POSIXU;\n                    goto join_posix;\n\n                /* The actual POSIXish node for all the rest depends on the\n                 * charset modifier.  The ones in the first set depend only on\n                 * ASCII or, if available on this platform, also locale */\n                case ANYOF_ASCII:\n                case ANYOF_NASCII:\n#ifdef HAS_ISASCII\n                    op = (LOC) ? POSIXL : POSIXA;\n#else\n                    op = POSIXA;\n#endif\n                    goto join_posix;\n\n                /* The following don't have any matches in the upper Latin1\n                 * range, hence /d is equivalent to /u for them.  Making it /u\n                 * saves some branches at runtime */\n                case ANYOF_DIGIT:\n                case ANYOF_NDIGIT:\n                case ANYOF_XDIGIT:\n                case ANYOF_NXDIGIT:\n                    if (! DEPENDS_SEMANTICS) {\n                        goto treat_as_default;\n                    }\n\n                    op = POSIXU;\n                    goto join_posix;\n\n                /* The following change to CASED under /i */\n                case ANYOF_LOWER:\n                case ANYOF_NLOWER:\n                case ANYOF_UPPER:\n                case ANYOF_NUPPER:\n                    if (FOLD) {\n                        namedclass = ANYOF_CASED + (namedclass % 2);\n                    }\n                    /* FALLTHROUGH */\n\n                /* The rest have more possibilities depending on the charset.\n                 * We take advantage of the enum ordering of the charset\n                 * modifiers to get the exact node type, */\n                default:\n                  treat_as_default:\n                    op = POSIXD + get_regex_charset(RExC_flags);\n                    if (op > POSIXA) { /* /aa is same as /a */\n                        op = POSIXA;\n                    }\n\n                  join_posix:\n                    /* The odd numbered ones are the complements of the\n                     * next-lower even number one */\n                    if (namedclass % 2 == 1) {\n                        invert = ! invert;\n                        namedclass--;\n                    }\n                    arg = namedclass_to_classnum(namedclass);\n                    break;\n            }\n        }\n        else if (value == prevvalue) {\n\n            /* Here, the class consists of just a single code point */\n\n            if (invert) {\n                if (! LOC && value == '\\n') {\n                    op = REG_ANY; /* Optimize [^\\n] */\n                    *flagp |= HASWIDTH|SIMPLE;\n                    MARK_NAUGHTY(1);\n                }\n            }\n            else if (value < 256 || UTF) {\n\n                /* Optimize a single value into an EXACTish node, but not if it\n                 * would require converting the pattern to UTF-8. */\n                op = compute_EXACTish(pRExC_state);\n            }\n        } /* Otherwise is a range */\n        else if (! LOC) {   /* locale could vary these */\n            if (prevvalue == '0') {\n                if (value == '9') {\n                    arg = _CC_DIGIT;\n                    op = POSIXA;\n                }\n            }\n            else if (! FOLD || ASCII_FOLD_RESTRICTED) {\n                /* We can optimize A-Z or a-z, but not if they could match\n                 * something like the KELVIN SIGN under /i. */\n                if (prevvalue == 'A') {\n                    if (value == 'Z'\n#ifdef EBCDIC\n                        && ! non_portable_endpoint\n#endif\n                    ) {\n                        arg = (FOLD) ? _CC_ALPHA : _CC_UPPER;\n                        op = POSIXA;\n                    }\n                }\n                else if (prevvalue == 'a') {\n                    if (value == 'z'\n#ifdef EBCDIC\n                        && ! non_portable_endpoint\n#endif\n                    ) {\n                        arg = (FOLD) ? _CC_ALPHA : _CC_LOWER;\n                        op = POSIXA;\n                    }\n                }\n            }\n        }\n\n        /* Here, we have changed <op> away from its initial value iff we found\n         * an optimization */\n        if (op != END) {\n\n            /* Throw away this ANYOF regnode, and emit the calculated one,\n             * which should correspond to the beginning, not current, state of\n             * the parse */\n            const char * cur_parse = RExC_parse;\n            RExC_parse = (char *)orig_parse;\n            if ( SIZE_ONLY) {\n                if (! LOC) {\n\n                    /* To get locale nodes to not use the full ANYOF size would\n                     * require moving the code above that writes the portions\n                     * of it that aren't in other nodes to after this point.\n                     * e.g.  ANYOF_POSIXL_SET */\n                    RExC_size = orig_size;\n                }\n            }\n            else {\n                RExC_emit = (regnode *)orig_emit;\n                if (PL_regkind[op] == POSIXD) {\n                    if (op == POSIXL) {\n                        RExC_contains_locale = 1;\n                    }\n                    if (invert) {\n                        op += NPOSIXD - POSIXD;\n                    }\n                }\n            }\n\n            ret = reg_node(pRExC_state, op);\n\n            if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {\n                if (! SIZE_ONLY) {\n                    FLAGS(ret) = arg;\n                }\n                *flagp |= HASWIDTH|SIMPLE;\n            }\n            else if (PL_regkind[op] == EXACT) {\n                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,\n                                           TRUE /* downgradable to EXACT */\n                                           );\n            }\n\n            RExC_parse = (char *) cur_parse;\n\n            SvREFCNT_dec(posixes);\n            SvREFCNT_dec(nposixes);\n            SvREFCNT_dec(simple_posixes);\n            SvREFCNT_dec(cp_list);\n            SvREFCNT_dec(cp_foldable_list);\n            return ret;\n        }\n    }\n\n    if (SIZE_ONLY)\n        return ret;\n    /****** !SIZE_ONLY (Pass 2) AFTER HERE *********/\n\n    /* If folding, we calculate all characters that could fold to or from the\n     * ones already on the list */\n    if (cp_foldable_list) {\n        if (FOLD) {\n            UV start, end;\t/* End points of code point ranges */\n\n            SV* fold_intersection = NULL;\n            SV** use_list;\n\n            /* Our calculated list will be for Unicode rules.  For locale\n             * matching, we have to keep a separate list that is consulted at\n             * runtime only when the locale indicates Unicode rules.  For\n             * non-locale, we just use the general list */\n            if (LOC) {\n                use_list = &only_utf8_locale_list;\n            }\n            else {\n                use_list = &cp_list;\n            }\n\n            /* Only the characters in this class that participate in folds need\n             * be checked.  Get the intersection of this class and all the\n             * possible characters that are foldable.  This can quickly narrow\n             * down a large class */\n            _invlist_intersection(PL_utf8_foldable, cp_foldable_list,\n                                  &fold_intersection);\n\n            /* The folds for all the Latin1 characters are hard-coded into this\n             * program, but we have to go out to disk to get the others. */\n            if (invlist_highest(cp_foldable_list) >= 256) {\n\n                /* This is a hash that for a particular fold gives all\n                 * characters that are involved in it */\n                if (! PL_utf8_foldclosures) {\n                    _load_PL_utf8_foldclosures();\n                }\n            }\n\n            /* Now look at the foldable characters in this class individually */\n            invlist_iterinit(fold_intersection);\n            while (invlist_iternext(fold_intersection, &start, &end)) {\n                UV j;\n\n                /* Look at every character in the range */\n                for (j = start; j <= end; j++) {\n                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];\n                    STRLEN foldlen;\n                    SV** listp;\n\n                    if (j < 256) {\n\n                        if (IS_IN_SOME_FOLD_L1(j)) {\n\n                            /* ASCII is always matched; non-ASCII is matched\n                             * only under Unicode rules (which could happen\n                             * under /l if the locale is a UTF-8 one */\n                            if (isASCII(j) || ! DEPENDS_SEMANTICS) {\n                                *use_list = add_cp_to_invlist(*use_list,\n                                                            PL_fold_latin1[j]);\n                            }\n                            else {\n                                has_upper_latin1_only_utf8_matches\n                                    = add_cp_to_invlist(\n                                            has_upper_latin1_only_utf8_matches,\n                                            PL_fold_latin1[j]);\n                            }\n                        }\n\n                        if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(j)\n                            && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))\n                        {\n                            add_above_Latin1_folds(pRExC_state,\n                                                   (U8) j,\n                                                   use_list);\n                        }\n                        continue;\n                    }\n\n                    /* Here is an above Latin1 character.  We don't have the\n                     * rules hard-coded for it.  First, get its fold.  This is\n                     * the simple fold, as the multi-character folds have been\n                     * handled earlier and separated out */\n                    _to_uni_fold_flags(j, foldbuf, &foldlen,\n                                                        (ASCII_FOLD_RESTRICTED)\n                                                        ? FOLD_FLAGS_NOMIX_ASCII\n                                                        : 0);\n\n                    /* Single character fold of above Latin1.  Add everything in\n                    * its fold closure to the list that this node should match.\n                    * The fold closures data structure is a hash with the keys\n                    * being the UTF-8 of every character that is folded to, like\n                    * 'k', and the values each an array of all code points that\n                    * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].\n                    * Multi-character folds are not included */\n                    if ((listp = hv_fetch(PL_utf8_foldclosures,\n                                        (char *) foldbuf, foldlen, FALSE)))\n                    {\n                        AV* list = (AV*) *listp;\n                        IV k;\n                        for (k = 0; k <= av_tindex_skip_len_mg(list); k++) {\n                            SV** c_p = av_fetch(list, k, FALSE);\n                            UV c;\n                            assert(c_p);\n\n                            c = SvUV(*c_p);\n\n                            /* /aa doesn't allow folds between ASCII and non- */\n                            if ((ASCII_FOLD_RESTRICTED\n                                && (isASCII(c) != isASCII(j))))\n                            {\n                                continue;\n                            }\n\n                            /* Folds under /l which cross the 255/256 boundary\n                             * are added to a separate list.  (These are valid\n                             * only when the locale is UTF-8.) */\n                            if (c < 256 && LOC) {\n                                *use_list = add_cp_to_invlist(*use_list, c);\n                                continue;\n                            }\n\n                            if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)\n                            {\n                                cp_list = add_cp_to_invlist(cp_list, c);\n                            }\n                            else {\n                                /* Similarly folds involving non-ascii Latin1\n                                * characters under /d are added to their list */\n                                has_upper_latin1_only_utf8_matches\n                                        = add_cp_to_invlist(\n                                           has_upper_latin1_only_utf8_matches,\n                                           c);\n                            }\n                        }\n                    }\n                }\n            }\n            SvREFCNT_dec_NN(fold_intersection);\n        }\n\n        /* Now that we have finished adding all the folds, there is no reason\n         * to keep the foldable list separate */\n        _invlist_union(cp_list, cp_foldable_list, &cp_list);\n\tSvREFCNT_dec_NN(cp_foldable_list);\n    }\n\n    /* And combine the result (if any) with any inversion lists from posix\n     * classes.  The lists are kept separate up to now because we don't want to\n     * fold the classes (folding of those is automatically handled by the swash\n     * fetching code) */\n    if (simple_posixes) {   /* These are the classes known to be unaffected by\n                               /a, /aa, and /d */\n        if (cp_list) {\n            _invlist_union(cp_list, simple_posixes, &cp_list);\n            SvREFCNT_dec_NN(simple_posixes);\n        }\n        else {\n            cp_list = simple_posixes;\n        }\n    }\n    if (posixes || nposixes) {\n\n        /* We have to adjust /a and /aa */\n        if (AT_LEAST_ASCII_RESTRICTED) {\n\n            /* Under /a and /aa, nothing above ASCII matches these */\n            if (posixes) {\n                _invlist_intersection(posixes,\n                                    PL_XPosix_ptrs[_CC_ASCII],\n                                    &posixes);\n            }\n\n            /* Under /a and /aa, everything above ASCII matches these\n             * complements */\n            if (nposixes) {\n                _invlist_union_complement_2nd(nposixes,\n                                              PL_XPosix_ptrs[_CC_ASCII],\n                                              &nposixes);\n            }\n        }\n\n        if (! DEPENDS_SEMANTICS) {\n\n            /* For everything but /d, we can just add the current 'posixes' and\n             * 'nposixes' to the main list */\n            if (posixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                }\n                else {\n                    cp_list = posixes;\n                }\n            }\n            if (nposixes) {\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                }\n                else {\n                    cp_list = nposixes;\n                }\n            }\n        }\n        else {\n            /* Under /d, things like \\w match upper Latin1 characters only if\n             * the target string is in UTF-8.  But things like \\W match all the\n             * upper Latin1 characters if the target string is not in UTF-8.\n             *\n             * Handle the case where there something like \\W separately */\n            if (nposixes) {\n                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1);\n\n                /* A complemented posix class matches all upper Latin1\n                 * characters if not in UTF-8.  And it matches just certain\n                 * ones when in UTF-8.  That means those certain ones are\n                 * matched regardless, so can just be added to the\n                 * unconditional list */\n                if (cp_list) {\n                    _invlist_union(cp_list, nposixes, &cp_list);\n                    SvREFCNT_dec_NN(nposixes);\n                    nposixes = NULL;\n                }\n                else {\n                    cp_list = nposixes;\n                }\n\n                /* Likewise for 'posixes' */\n                _invlist_union(posixes, cp_list, &cp_list);\n\n                /* Likewise for anything else in the range that matched only\n                 * under UTF-8 */\n                if (has_upper_latin1_only_utf8_matches) {\n                    _invlist_union(cp_list,\n                                   has_upper_latin1_only_utf8_matches,\n                                   &cp_list);\n                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);\n                    has_upper_latin1_only_utf8_matches = NULL;\n                }\n\n                /* If we don't match all the upper Latin1 characters regardless\n                 * of UTF-8ness, we have to set a flag to match the rest when\n                 * not in UTF-8 */\n                _invlist_subtract(only_non_utf8_list, cp_list,\n                                  &only_non_utf8_list);\n                if (_invlist_len(only_non_utf8_list) != 0) {\n                    ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n                }\n            }\n            else {\n                /* Here there were no complemented posix classes.  That means\n                 * the upper Latin1 characters in 'posixes' match only when the\n                 * target string is in UTF-8.  So we have to add them to the\n                 * list of those types of code points, while adding the\n                 * remainder to the unconditional list.\n                 *\n                 * First calculate what they are */\n                SV* nonascii_but_latin1_properties = NULL;\n                _invlist_intersection(posixes, PL_UpperLatin1,\n                                      &nonascii_but_latin1_properties);\n\n                /* And add them to the final list of such characters. */\n                _invlist_union(has_upper_latin1_only_utf8_matches,\n                               nonascii_but_latin1_properties,\n                               &has_upper_latin1_only_utf8_matches);\n\n                /* Remove them from what now becomes the unconditional list */\n                _invlist_subtract(posixes, nonascii_but_latin1_properties,\n                                  &posixes);\n\n                /* And add those unconditional ones to the final list */\n                if (cp_list) {\n                    _invlist_union(cp_list, posixes, &cp_list);\n                    SvREFCNT_dec_NN(posixes);\n                    posixes = NULL;\n                }\n                else {\n                    cp_list = posixes;\n                }\n\n                SvREFCNT_dec(nonascii_but_latin1_properties);\n\n                /* Get rid of any characters that we now know are matched\n                 * unconditionally from the conditional list, which may make\n                 * that list empty */\n                _invlist_subtract(has_upper_latin1_only_utf8_matches,\n                                  cp_list,\n                                  &has_upper_latin1_only_utf8_matches);\n                if (_invlist_len(has_upper_latin1_only_utf8_matches) == 0) {\n                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);\n                    has_upper_latin1_only_utf8_matches = NULL;\n                }\n            }\n        }\n    }\n\n    /* And combine the result (if any) with any inversion list from properties.\n     * The lists are kept separate up to now so that we can distinguish the two\n     * in regards to matching above-Unicode.  A run-time warning is generated\n     * if a Unicode property is matched against a non-Unicode code point. But,\n     * we allow user-defined properties to match anything, without any warning,\n     * and we also suppress the warning if there is a portion of the character\n     * class that isn't a Unicode property, and which matches above Unicode, \\W\n     * or [\\x{110000}] for example.\n     * (Note that in this case, unlike the Posix one above, there is no\n     * <has_upper_latin1_only_utf8_matches>, because having a Unicode property\n     * forces Unicode semantics */\n    if (properties) {\n        if (cp_list) {\n\n            /* If it matters to the final outcome, see if a non-property\n             * component of the class matches above Unicode.  If so, the\n             * warning gets suppressed.  This is true even if just a single\n             * such code point is specified, as, though not strictly correct if\n             * another such code point is matched against, the fact that they\n             * are using above-Unicode code points indicates they should know\n             * the issues involved */\n            if (warn_super) {\n                warn_super = ! (invert\n                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));\n            }\n\n            _invlist_union(properties, cp_list, &cp_list);\n            SvREFCNT_dec_NN(properties);\n        }\n        else {\n            cp_list = properties;\n        }\n\n        if (warn_super) {\n            ANYOF_FLAGS(ret)\n             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;\n\n            /* Because an ANYOF node is the only one that warns, this node\n             * can't be optimized into something else */\n            optimizable = FALSE;\n        }\n    }\n\n    /* Here, we have calculated what code points should be in the character\n     * class.\n     *\n     * Now we can see about various optimizations.  Fold calculation (which we\n     * did above) needs to take place before inversion.  Otherwise /[^k]/i\n     * would invert to include K, which under /i would match k, which it\n     * shouldn't.  Therefore we can't invert folded locale now, as it won't be\n     * folded until runtime */\n\n    /* If we didn't do folding, it's because some information isn't available\n     * until runtime; set the run-time fold flag for these.  (We don't have to\n     * worry about properties folding, as that is taken care of by the swash\n     * fetching).  We know to set the flag if we have a non-NULL list for UTF-8\n     * locales, or the class matches at least one 0-255 range code point */\n    if (LOC && FOLD) {\n\n        /* Some things on the list might be unconditionally included because of\n         * other components.  Remove them, and clean up the list if it goes to\n         * 0 elements */\n        if (only_utf8_locale_list && cp_list) {\n            _invlist_subtract(only_utf8_locale_list, cp_list,\n                              &only_utf8_locale_list);\n\n            if (_invlist_len(only_utf8_locale_list) == 0) {\n                SvREFCNT_dec_NN(only_utf8_locale_list);\n                only_utf8_locale_list = NULL;\n            }\n        }\n        if (only_utf8_locale_list) {\n            ANYOF_FLAGS(ret)\n                 |=  ANYOFL_FOLD\n                    |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;\n        }\n        else if (cp_list) { /* Look to see if a 0-255 code point is in list */\n            UV start, end;\n            invlist_iterinit(cp_list);\n            if (invlist_iternext(cp_list, &start, &end) && start < 256) {\n                ANYOF_FLAGS(ret) |= ANYOFL_FOLD;\n            }\n            invlist_iterfinish(cp_list);\n        }\n    }\n    else if (   DEPENDS_SEMANTICS\n             && (    has_upper_latin1_only_utf8_matches\n                 || (ANYOF_FLAGS(ret) & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)))\n    {\n        OP(ret) = ANYOFD;\n        optimizable = FALSE;\n    }\n\n\n    /* Optimize inverted simple patterns (e.g. [^a-z]) when everything is known\n     * at compile time.  Besides not inverting folded locale now, we can't\n     * invert if there are things such as \\w, which aren't known until runtime\n     * */\n    if (cp_list\n        && invert\n        && OP(ret) != ANYOFD\n        && ! (ANYOF_FLAGS(ret) & (ANYOF_LOCALE_FLAGS))\n\t&& ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)\n    {\n        _invlist_invert(cp_list);\n\n        /* Any swash can't be used as-is, because we've inverted things */\n        if (swash) {\n            SvREFCNT_dec_NN(swash);\n            swash = NULL;\n        }\n\n\t/* Clear the invert flag since have just done it here */\n\tinvert = FALSE;\n    }\n\n    if (ret_invlist) {\n        assert(cp_list);\n\n        *ret_invlist = cp_list;\n        SvREFCNT_dec(swash);\n\n        /* Discard the generated node */\n        if (SIZE_ONLY) {\n            RExC_size = orig_size;\n        }\n        else {\n            RExC_emit = orig_emit;\n        }\n        return orig_emit;\n    }\n\n    /* Some character classes are equivalent to other nodes.  Such nodes take\n     * up less room and generally fewer operations to execute than ANYOF nodes.\n     * Above, we checked for and optimized into some such equivalents for\n     * certain common classes that are easy to test.  Getting to this point in\n     * the code means that the class didn't get optimized there.  Since this\n     * code is only executed in Pass 2, it is too late to save space--it has\n     * been allocated in Pass 1, and currently isn't given back.  But turning\n     * things into an EXACTish node can allow the optimizer to join it to any\n     * adjacent such nodes.  And if the class is equivalent to things like /./,\n     * expensive run-time swashes can be avoided.  Now that we have more\n     * complete information, we can find things necessarily missed by the\n     * earlier code.  Another possible \"optimization\" that isn't done is that\n     * something like [Ee] could be changed into an EXACTFU.  khw tried this\n     * and found that the ANYOF is faster, including for code points not in the\n     * bitmap.  This still might make sense to do, provided it got joined with\n     * an adjacent node(s) to create a longer EXACTFU one.  This could be\n     * accomplished by creating a pseudo ANYOF_EXACTFU node type that the join\n     * routine would know is joinable.  If that didn't happen, the node type\n     * could then be made a straight ANYOF */\n\n    if (optimizable && cp_list && ! invert) {\n        UV start, end;\n        U8 op = END;  /* The optimzation node-type */\n        int posix_class = -1;   /* Illegal value */\n        const char * cur_parse= RExC_parse;\n\n        invlist_iterinit(cp_list);\n        if (! invlist_iternext(cp_list, &start, &end)) {\n\n            /* Here, the list is empty.  This happens, for example, when a\n             * Unicode property that doesn't match anything is the only element\n             * in the character class (perluniprops.pod notes such properties).\n             * */\n            op = OPFAIL;\n            *flagp |= HASWIDTH|SIMPLE;\n        }\n        else if (start == end) {    /* The range is a single code point */\n            if (! invlist_iternext(cp_list, &start, &end)\n\n                    /* Don't do this optimization if it would require changing\n                     * the pattern to UTF-8 */\n                && (start < 256 || UTF))\n            {\n                /* Here, the list contains a single code point.  Can optimize\n                 * into an EXACTish node */\n\n                value = start;\n\n                if (! FOLD) {\n                    op = (LOC)\n                         ? EXACTL\n                         : EXACT;\n                }\n                else if (LOC) {\n\n                    /* A locale node under folding with one code point can be\n                     * an EXACTFL, as its fold won't be calculated until\n                     * runtime */\n                    op = EXACTFL;\n                }\n                else {\n\n                    /* Here, we are generally folding, but there is only one\n                     * code point to match.  If we have to, we use an EXACT\n                     * node, but it would be better for joining with adjacent\n                     * nodes in the optimization pass if we used the same\n                     * EXACTFish node that any such are likely to be.  We can\n                     * do this iff the code point doesn't participate in any\n                     * folds.  For example, an EXACTF of a colon is the same as\n                     * an EXACT one, since nothing folds to or from a colon. */\n                    if (value < 256) {\n                        if (IS_IN_SOME_FOLD_L1(value)) {\n                            op = EXACT;\n                        }\n                    }\n                    else {\n                        if (_invlist_contains_cp(PL_utf8_foldable, value)) {\n                            op = EXACT;\n                        }\n                    }\n\n                    /* If we haven't found the node type, above, it means we\n                     * can use the prevailing one */\n                    if (op == END) {\n                        op = compute_EXACTish(pRExC_state);\n                    }\n                }\n            }\n        }   /* End of first range contains just a single code point */\n        else if (start == 0) {\n            if (end == UV_MAX) {\n                op = SANY;\n                *flagp |= HASWIDTH|SIMPLE;\n                MARK_NAUGHTY(1);\n            }\n            else if (end == '\\n' - 1\n                    && invlist_iternext(cp_list, &start, &end)\n                    && start == '\\n' + 1 && end == UV_MAX)\n            {\n                op = REG_ANY;\n                *flagp |= HASWIDTH|SIMPLE;\n                MARK_NAUGHTY(1);\n            }\n        }\n        invlist_iterfinish(cp_list);\n\n        if (op == END) {\n            const UV cp_list_len = _invlist_len(cp_list);\n            const UV* cp_list_array = invlist_array(cp_list);\n\n            /* Here, didn't find an optimization.  See if this matches any of\n             * the POSIX classes.  These run slightly faster for above-Unicode\n             * code points, so don't bother with POSIXA ones nor the 2 that\n             * have no above-Unicode matches.  We can avoid these checks unless\n             * the ANYOF matches at least as high as the lowest POSIX one\n             * (which was manually found to be \\v.  The actual code point may\n             * increase in later Unicode releases, if a higher code point is\n             * assigned to be \\v, but this code will never break.  It would\n             * just mean we could execute the checks for posix optimizations\n             * unnecessarily) */\n\n            if (cp_list_array[cp_list_len-1] > 0x2029) {\n                for (posix_class = 0;\n                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;\n                     posix_class++)\n                {\n                    int try_inverted;\n                    if (posix_class == _CC_ASCII || posix_class == _CC_CNTRL) {\n                        continue;\n                    }\n                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {\n\n                        /* Check if matches normal or inverted */\n                        if (_invlistEQ(cp_list,\n                                       PL_XPosix_ptrs[posix_class],\n                                       try_inverted))\n                        {\n                            op = (try_inverted)\n                                 ? NPOSIXU\n                                 : POSIXU;\n                            *flagp |= HASWIDTH|SIMPLE;\n                            goto found_posix;\n                        }\n                    }\n                }\n              found_posix: ;\n            }\n        }\n\n        if (op != END) {\n            RExC_parse = (char *)orig_parse;\n            RExC_emit = (regnode *)orig_emit;\n\n            if (regarglen[op]) {\n                ret = reganode(pRExC_state, op, 0);\n            } else {\n                ret = reg_node(pRExC_state, op);\n            }\n\n            RExC_parse = (char *)cur_parse;\n\n            if (PL_regkind[op] == EXACT) {\n                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,\n                                           TRUE /* downgradable to EXACT */\n                                          );\n            }\n            else if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {\n                FLAGS(ret) = posix_class;\n            }\n\n            SvREFCNT_dec_NN(cp_list);\n            return ret;\n        }\n    }\n\n    /* Here, <cp_list> contains all the code points we can determine at\n     * compile time that match under all conditions.  Go through it, and\n     * for things that belong in the bitmap, put them there, and delete from\n     * <cp_list>.  While we are at it, see if everything above 255 is in the\n     * list, and if so, set a flag to speed up execution */\n\n    populate_ANYOF_from_invlist(ret, &cp_list);\n\n    if (invert) {\n        ANYOF_FLAGS(ret) |= ANYOF_INVERT;\n    }\n\n    /* Here, the bitmap has been populated with all the Latin1 code points that\n     * always match.  Can now add to the overall list those that match only\n     * when the target string is UTF-8 (<has_upper_latin1_only_utf8_matches>).\n     * */\n    if (has_upper_latin1_only_utf8_matches) {\n\tif (cp_list) {\n\t    _invlist_union(cp_list,\n                           has_upper_latin1_only_utf8_matches,\n                           &cp_list);\n\t    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);\n\t}\n\telse {\n\t    cp_list = has_upper_latin1_only_utf8_matches;\n\t}\n        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;\n    }\n\n    /* If there is a swash and more than one element, we can't use the swash in\n     * the optimization below. */\n    if (swash && element_count > 1) {\n\tSvREFCNT_dec_NN(swash);\n\tswash = NULL;\n    }\n\n    /* Note that the optimization of using 'swash' if it is the only thing in\n     * the class doesn't have us change swash at all, so it can include things\n     * that are also in the bitmap; otherwise we have purposely deleted that\n     * duplicate information */\n    set_ANYOF_arg(pRExC_state, ret, cp_list,\n                  (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)\n                   ? listsv : NULL,\n                  only_utf8_locale_list,\n                  swash, has_user_defined_property);\n\n    *flagp |= HASWIDTH|SIMPLE;\n\n    if (ANYOF_FLAGS(ret) & ANYOF_LOCALE_FLAGS) {\n        RExC_contains_locale = 1;\n    }\n\n    return ret;\n}\n\n#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION\n\nSTATIC void\nS_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state,\n                regnode* const node,\n                SV* const cp_list,\n                SV* const runtime_defns,\n                SV* const only_utf8_locale_list,\n                SV* const swash,\n                const bool has_user_defined_property)\n{\n    /* Sets the arg field of an ANYOF-type node 'node', using information about\n     * the node passed-in.  If there is nothing outside the node's bitmap, the\n     * arg is set to ANYOF_ONLY_HAS_BITMAP.  Otherwise, it sets the argument to\n     * the count returned by add_data(), having allocated and stored an array,\n     * av, that that count references, as follows:\n     *  av[0] stores the character class description in its textual form.\n     *        This is used later (regexec.c:Perl_regclass_swash()) to\n     *        initialize the appropriate swash, and is also useful for dumping\n     *        the regnode.  This is set to &PL_sv_undef if the textual\n     *        description is not needed at run-time (as happens if the other\n     *        elements completely define the class)\n     *  av[1] if &PL_sv_undef, is a placeholder to later contain the swash\n     *        computed from av[0].  But if no further computation need be done,\n     *        the swash is stored here now (and av[0] is &PL_sv_undef).\n     *  av[2] stores the inversion list of code points that match only if the\n     *        current locale is UTF-8\n     *  av[3] stores the cp_list inversion list for use in addition or instead\n     *        of av[0]; used only if cp_list exists and av[1] is &PL_sv_undef.\n     *        (Otherwise everything needed is already in av[0] and av[1])\n     *  av[4] is set if any component of the class is from a user-defined\n     *        property; used only if av[3] exists */\n\n    UV n;\n\n    PERL_ARGS_ASSERT_SET_ANYOF_ARG;\n\n    if (! cp_list && ! runtime_defns && ! only_utf8_locale_list) {\n        assert(! (ANYOF_FLAGS(node)\n                & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP));\n\tARG_SET(node, ANYOF_ONLY_HAS_BITMAP);\n    }\n    else {\n\tAV * const av = newAV();\n\tSV *rv;\n\n\tav_store(av, 0, (runtime_defns)\n\t\t\t? SvREFCNT_inc(runtime_defns) : &PL_sv_undef);\n\tif (swash) {\n\t    assert(cp_list);\n\t    av_store(av, 1, swash);\n\t    SvREFCNT_dec_NN(cp_list);\n\t}\n\telse {\n\t    av_store(av, 1, &PL_sv_undef);\n\t    if (cp_list) {\n\t\tav_store(av, 3, cp_list);\n\t\tav_store(av, 4, newSVuv(has_user_defined_property));\n\t    }\n\t}\n\n        if (only_utf8_locale_list) {\n\t    av_store(av, 2, only_utf8_locale_list);\n        }\n        else {\n\t    av_store(av, 2, &PL_sv_undef);\n        }\n\n\trv = newRV_noinc(MUTABLE_SV(av));\n\tn = add_data(pRExC_state, STR_WITH_LEN(\"s\"));\n\tRExC_rxi->data->data[n] = (void*)rv;\n\tARG_SET(node, n);\n    }\n}\n\n#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)\nSV *\nPerl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,\n                                        const regnode* node,\n                                        bool doinit,\n                                        SV** listsvp,\n                                        SV** only_utf8_locale_ptr,\n                                        SV** output_invlist)\n\n{\n    /* For internal core use only.\n     * Returns the swash for the input 'node' in the regex 'prog'.\n     * If <doinit> is 'true', will attempt to create the swash if not already\n     *\t  done.\n     * If <listsvp> is non-null, will return the printable contents of the\n     *    swash.  This can be used to get debugging information even before the\n     *    swash exists, by calling this function with 'doinit' set to false, in\n     *    which case the components that will be used to eventually create the\n     *    swash are returned  (in a printable form).\n     * If <only_utf8_locale_ptr> is not NULL, it is where this routine is to\n     *    store an inversion list of code points that should match only if the\n     *    execution-time locale is a UTF-8 one.\n     * If <output_invlist> is not NULL, it is where this routine is to store an\n     *    inversion list of the code points that would be instead returned in\n     *    <listsvp> if this were NULL.  Thus, what gets output in <listsvp>\n     *    when this parameter is used, is just the non-code point data that\n     *    will go into creating the swash.  This currently should be just\n     *    user-defined properties whose definitions were not known at compile\n     *    time.  Using this parameter allows for easier manipulation of the\n     *    swash's data by the caller.  It is illegal to call this function with\n     *    this parameter set, but not <listsvp>\n     *\n     * Tied intimately to how S_set_ANYOF_arg sets up the data structure.  Note\n     * that, in spite of this function's name, the swash it returns may include\n     * the bitmap data as well */\n\n    SV *sw  = NULL;\n    SV *si  = NULL;         /* Input swash initialization string */\n    SV* invlist = NULL;\n\n    RXi_GET_DECL(prog,progi);\n    const struct reg_data * const data = prog ? progi->data : NULL;\n\n    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;\n    assert(! output_invlist || listsvp);\n\n    if (data && data->count) {\n\tconst U32 n = ARG(node);\n\n\tif (data->what[n] == 's') {\n\t    SV * const rv = MUTABLE_SV(data->data[n]);\n\t    AV * const av = MUTABLE_AV(SvRV(rv));\n\t    SV **const ary = AvARRAY(av);\n\t    U8 swash_init_flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;\n\n\t    si = *ary;\t/* ary[0] = the string to initialize the swash with */\n\n            if (av_tindex_skip_len_mg(av) >= 2) {\n                if (only_utf8_locale_ptr\n                    && ary[2]\n                    && ary[2] != &PL_sv_undef)\n                {\n                    *only_utf8_locale_ptr = ary[2];\n                }\n                else {\n                    assert(only_utf8_locale_ptr);\n                    *only_utf8_locale_ptr = NULL;\n                }\n\n                /* Elements 3 and 4 are either both present or both absent. [3]\n                 * is any inversion list generated at compile time; [4]\n                 * indicates if that inversion list has any user-defined\n                 * properties in it. */\n                if (av_tindex_skip_len_mg(av) >= 3) {\n                    invlist = ary[3];\n                    if (SvUV(ary[4])) {\n                        swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;\n                    }\n                }\n                else {\n                    invlist = NULL;\n                }\n\t    }\n\n\t    /* Element [1] is reserved for the set-up swash.  If already there,\n\t     * return it; if not, create it and store it there */\n\t    if (ary[1] && SvROK(ary[1])) {\n\t\tsw = ary[1];\n\t    }\n\t    else if (doinit && ((si && si != &PL_sv_undef)\n                                 || (invlist && invlist != &PL_sv_undef))) {\n\t\tassert(si);\n\t\tsw = _core_swash_init(\"utf8\", /* the utf8 package */\n\t\t\t\t      \"\", /* nameless */\n\t\t\t\t      si,\n\t\t\t\t      1, /* binary */\n\t\t\t\t      0, /* not from tr/// */\n\t\t\t\t      invlist,\n\t\t\t\t      &swash_init_flags);\n\t\t(void)av_store(av, 1, sw);\n\t    }\n\t}\n    }\n\n    /* If requested, return a printable version of what this swash matches */\n    if (listsvp) {\n\tSV* matches_string = NULL;\n\n        /* The swash should be used, if possible, to get the data, as it\n         * contains the resolved data.  But this function can be called at\n         * compile-time, before everything gets resolved, in which case we\n         * return the currently best available information, which is the string\n         * that will eventually be used to do that resolving, 'si' */\n\tif ((! sw || (invlist = _get_swash_invlist(sw)) == NULL)\n            && (si && si != &PL_sv_undef))\n        {\n            /* Here, we only have 'si' (and possibly some passed-in data in\n             * 'invlist', which is handled below)  If the caller only wants\n             * 'si', use that.  */\n            if (! output_invlist) {\n                matches_string = newSVsv(si);\n            }\n            else {\n                /* But if the caller wants an inversion list of the node, we\n                 * need to parse 'si' and place as much as possible in the\n                 * desired output inversion list, making 'matches_string' only\n                 * contain the currently unresolvable things */\n                const char *si_string = SvPVX(si);\n                STRLEN remaining = SvCUR(si);\n                UV prev_cp = 0;\n                U8 count = 0;\n\n                /* Ignore everything before the first new-line */\n                while (*si_string != '\\n' && remaining > 0) {\n                    si_string++;\n                    remaining--;\n                }\n                assert(remaining > 0);\n\n                si_string++;\n                remaining--;\n\n                while (remaining > 0) {\n\n                    /* The data consists of just strings defining user-defined\n                     * property names, but in prior incarnations, and perhaps\n                     * somehow from pluggable regex engines, it could still\n                     * hold hex code point definitions.  Each component of a\n                     * range would be separated by a tab, and each range by a\n                     * new-line.  If these are found, instead add them to the\n                     * inversion list */\n                    I32 grok_flags =  PERL_SCAN_SILENT_ILLDIGIT\n                                     |PERL_SCAN_SILENT_NON_PORTABLE;\n                    STRLEN len = remaining;\n                    UV cp = grok_hex(si_string, &len, &grok_flags, NULL);\n\n                    /* If the hex decode routine found something, it should go\n                     * up to the next \\n */\n                    if (   *(si_string + len) == '\\n') {\n                        if (count) {    /* 2nd code point on line */\n                            *output_invlist = _add_range_to_invlist(*output_invlist, prev_cp, cp);\n                        }\n                        else {\n                            *output_invlist = add_cp_to_invlist(*output_invlist, cp);\n                        }\n                        count = 0;\n                        goto prepare_for_next_iteration;\n                    }\n\n                    /* If the hex decode was instead for the lower range limit,\n                     * save it, and go parse the upper range limit */\n                    if (*(si_string + len) == '\\t') {\n                        assert(count == 0);\n\n                        prev_cp = cp;\n                        count = 1;\n                      prepare_for_next_iteration:\n                        si_string += len + 1;\n                        remaining -= len + 1;\n                        continue;\n                    }\n\n                    /* Here, didn't find a legal hex number.  Just add it from\n                     * here to the next \\n */\n\n                    remaining -= len;\n                    while (*(si_string + len) != '\\n' && remaining > 0) {\n                        remaining--;\n                        len++;\n                    }\n                    if (*(si_string + len) == '\\n') {\n                        len++;\n                        remaining--;\n                    }\n                    if (matches_string) {\n                        sv_catpvn(matches_string, si_string, len - 1);\n                    }\n                    else {\n                        matches_string = newSVpvn(si_string, len - 1);\n                    }\n                    si_string += len;\n                    sv_catpvs(matches_string, \" \");\n                } /* end of loop through the text */\n\n                assert(matches_string);\n                if (SvCUR(matches_string)) {  /* Get rid of trailing blank */\n                    SvCUR_set(matches_string, SvCUR(matches_string) - 1);\n                }\n            } /* end of has an 'si' but no swash */\n\t}\n\n        /* If we have a swash in place, its equivalent inversion list was above\n         * placed into 'invlist'.  If not, this variable may contain a stored\n         * inversion list which is information beyond what is in 'si' */\n        if (invlist) {\n\n            /* Again, if the caller doesn't want the output inversion list, put\n             * everything in 'matches-string' */\n            if (! output_invlist) {\n                if ( ! matches_string) {\n                    matches_string = newSVpvs(\"\\n\");\n                }\n                sv_catsv(matches_string, invlist_contents(invlist,\n                                                  TRUE /* traditional style */\n                                                  ));\n            }\n            else if (! *output_invlist) {\n                *output_invlist = invlist_clone(invlist);\n            }\n            else {\n                _invlist_union(*output_invlist, invlist, output_invlist);\n            }\n        }\n\n\t*listsvp = matches_string;\n    }\n\n    return sw;\n}\n#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */\n\n/* reg_skipcomment()\n\n   Absorbs an /x style # comment from the input stream,\n   returning a pointer to the first character beyond the comment, or if the\n   comment terminates the pattern without anything following it, this returns\n   one past the final character of the pattern (in other words, RExC_end) and\n   sets the REG_RUN_ON_COMMENT_SEEN flag.\n\n   Note it's the callers responsibility to ensure that we are\n   actually in /x mode\n\n*/\n\nPERL_STATIC_INLINE char*\nS_reg_skipcomment(RExC_state_t *pRExC_state, char* p)\n{\n    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;\n\n    assert(*p == '#');\n\n    while (p < RExC_end) {\n        if (*(++p) == '\\n') {\n            return p+1;\n        }\n    }\n\n    /* we ran off the end of the pattern without ending the comment, so we have\n     * to add an \\n when wrapping */\n    RExC_seen |= REG_RUN_ON_COMMENT_SEEN;\n    return p;\n}\n\nSTATIC void\nS_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state,\n                                char ** p,\n                                const bool force_to_xmod\n                         )\n{\n    /* If the text at the current parse position '*p' is a '(?#...)' comment,\n     * or if we are under /x or 'force_to_xmod' is TRUE, and the text at '*p'\n     * is /x whitespace, advance '*p' so that on exit it points to the first\n     * byte past all such white space and comments */\n\n    const bool use_xmod = force_to_xmod || (RExC_flags & RXf_PMf_EXTENDED);\n\n    PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT;\n\n    assert( ! UTF || UTF8_IS_INVARIANT(**p) || UTF8_IS_START(**p));\n\n    for (;;) {\n\tif (RExC_end - (*p) >= 3\n\t    && *(*p)     == '('\n\t    && *(*p + 1) == '?'\n\t    && *(*p + 2) == '#')\n\t{\n\t    while (*(*p) != ')') {\n\t\tif ((*p) == RExC_end)\n\t\t    FAIL(\"Sequence (?#... not terminated\");\n\t\t(*p)++;\n\t    }\n\t    (*p)++;\n\t    continue;\n\t}\n\n\tif (use_xmod) {\n            const char * save_p = *p;\n            while ((*p) < RExC_end) {\n                STRLEN len;\n                if ((len = is_PATWS_safe((*p), RExC_end, UTF))) {\n                    (*p) += len;\n                }\n                else if (*(*p) == '#') {\n                    (*p) = reg_skipcomment(pRExC_state, (*p));\n                }\n                else {\n                    break;\n                }\n            }\n            if (*p != save_p) {\n                continue;\n            }\n\t}\n\n        break;\n    }\n\n    return;\n}\n\n/* nextchar()\n\n   Advances the parse position by one byte, unless that byte is the beginning\n   of a '(?#...)' style comment, or is /x whitespace and /x is in effect.  In\n   those two cases, the parse position is advanced beyond all such comments and\n   white space.\n\n   This is the UTF, (?#...), and /x friendly way of saying RExC_parse++.\n*/\n\nSTATIC void\nS_nextchar(pTHX_ RExC_state_t *pRExC_state)\n{\n    PERL_ARGS_ASSERT_NEXTCHAR;\n\n    if (RExC_parse < RExC_end) {\n        assert(   ! UTF\n               || UTF8_IS_INVARIANT(*RExC_parse)\n               || UTF8_IS_START(*RExC_parse));\n\n        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;\n\n        skip_to_be_ignored_text(pRExC_state, &RExC_parse,\n                                FALSE /* Don't force /x */ );\n    }\n}\n\nSTATIC regnode *\nS_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_size, const char* const name)\n{\n    /* Allocate a regnode for 'op' and returns it, with 'extra_size' extra\n     * space.  In pass1, it aligns and increments RExC_size; in pass2,\n     * RExC_emit */\n\n    regnode * const ret = RExC_emit;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGNODE_GUTS;\n\n    assert(extra_size >= regarglen[op]);\n\n    if (SIZE_ONLY) {\n\tSIZE_ALIGN(RExC_size);\n\tRExC_size += 1 + extra_size;\n\treturn(ret);\n    }\n    if (RExC_emit >= RExC_emit_bound)\n        Perl_croak(aTHX_ \"panic: reg_node overrun trying to emit %d, %p>=%p\",\n\t\t   op, (void*)RExC_emit, (void*)RExC_emit_bound);\n\n    NODE_ALIGN_FILL(ret);\n#ifndef RE_TRACK_PATTERN_OFFSETS\n    PERL_UNUSED_ARG(name);\n#else\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s:%d: (op %s) %s %\" UVuf \" (len %\" UVuf \") (max %\" UVuf \").\\n\",\n              name, __LINE__,\n              PL_reg_name[op],\n              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0]\n\t\t? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)(RExC_emit - RExC_emit_start),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(RExC_emit, RExC_parse + (op == END));\n    }\n#endif\n    return(ret);\n}\n\n/*\n- reg_node - emit a node\n*/\nSTATIC regnode *\t\t\t/* Location. */\nS_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)\n{\n    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg_node\");\n\n    PERL_ARGS_ASSERT_REG_NODE;\n\n    assert(regarglen[op] == 0);\n\n    if (PASS2) {\n        regnode *ptr = ret;\n        FILL_ADVANCE_NODE(ptr, op);\n        RExC_emit = ptr;\n    }\n    return(ret);\n}\n\n/*\n- reganode - emit a node with an argument\n*/\nSTATIC regnode *\t\t\t/* Location. */\nS_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)\n{\n    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], \"reganode\");\n\n    PERL_ARGS_ASSERT_REGANODE;\n\n    assert(regarglen[op] == 1);\n\n    if (PASS2) {\n        regnode *ptr = ret;\n        FILL_ADVANCE_NODE_ARG(ptr, op, arg);\n        RExC_emit = ptr;\n    }\n    return(ret);\n}\n\nSTATIC regnode *\nS_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2)\n{\n    /* emit a node with U32 and I32 arguments */\n\n    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], \"reg2Lanode\");\n\n    PERL_ARGS_ASSERT_REG2LANODE;\n\n    assert(regarglen[op] == 2);\n\n    if (PASS2) {\n        regnode *ptr = ret;\n        FILL_ADVANCE_NODE_2L_ARG(ptr, op, arg1, arg2);\n        RExC_emit = ptr;\n    }\n    return(ret);\n}\n\n/*\n- reginsert - insert an operator in front of already-emitted operand\n*\n* Means relocating the operand.\n*\n* IMPORTANT NOTE - it is the *callers* responsibility to correctly\n* set up NEXT_OFF() of the inserted node if needed. Something like this:\n*\n* reginsert(pRExC, OPFAIL, orig_emit, depth+1);\n* if (PASS2)\n*     NEXT_OFF(orig_emit) = regarglen[OPFAIL] + NODE_STEP_REGNODE;\n*\n* ALSO NOTE - operand->flags will be set to 0 as well.\n*/\nSTATIC void\nS_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *operand, U32 depth)\n{\n    regnode *src;\n    regnode *dst;\n    regnode *place;\n    const int offset = regarglen[(U8)op];\n    const int size = NODE_STEP_REGNODE + offset;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGINSERT;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(depth);\n/* (PL_regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */\n    DEBUG_PARSE_FMT(\"inst\",\" - %s\",PL_reg_name[op]);\n    if (SIZE_ONLY) {\n\tRExC_size += size;\n\treturn;\n    }\n    assert(!RExC_study_started); /* I believe we should never use reginsert once we have started\n                                    studying. If this is wrong then we need to adjust RExC_recurse\n                                    below like we do with RExC_open_parens/RExC_close_parens. */\n    src = RExC_emit;\n    RExC_emit += size;\n    dst = RExC_emit;\n    if (RExC_open_parens) {\n        int paren;\n        /*DEBUG_PARSE_FMT(\"inst\",\" - %\" IVdf, (IV)RExC_npar);*/\n        /* remember that RExC_npar is rex->nparens + 1,\n         * iow it is 1 more than the number of parens seen in\n         * the pattern so far. */\n        for ( paren=0 ; paren < RExC_npar ; paren++ ) {\n            /* note, RExC_open_parens[0] is the start of the\n             * regex, it can't move. RExC_close_parens[0] is the end\n             * of the regex, it *can* move. */\n            if ( paren && RExC_open_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %d\",size);*/\n                RExC_open_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"open\",\" - %s\",\"ok\");*/\n            }\n            if ( RExC_close_parens[paren] >= operand ) {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %d\",size);*/\n                RExC_close_parens[paren] += size;\n            } else {\n                /*DEBUG_PARSE_FMT(\"close\",\" - %s\",\"ok\");*/\n            }\n        }\n    }\n    if (RExC_end_op)\n        RExC_end_op += size;\n\n    while (src > operand) {\n\tStructCopy(--src, --dst, regnode);\n#ifdef RE_TRACK_PATTERN_OFFSETS\n        if (RExC_offsets) {     /* MJD 20010112 */\n\t    MJD_OFFSET_DEBUG(\n                 (\"%s(%d): (op %s) %s copy %\" UVuf \" -> %\" UVuf \" (max %\" UVuf \").\\n\",\n                  \"reg_insert\",\n\t\t  __LINE__,\n\t\t  PL_reg_name[op],\n                  (UV)(dst - RExC_emit_start) > RExC_offsets[0]\n\t\t    ? \"Overwriting end of array!\\n\" : \"OK\",\n                  (UV)(src - RExC_emit_start),\n                  (UV)(dst - RExC_emit_start),\n                  (UV)RExC_offsets[0]));\n\t    Set_Node_Offset_To_R(dst-RExC_emit_start, Node_Offset(src));\n\t    Set_Node_Length_To_R(dst-RExC_emit_start, Node_Length(src));\n        }\n#endif\n    }\n\n    place = operand;\t\t/* Op node, where operand used to be. */\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (RExC_offsets) {         /* MJD */\n\tMJD_OFFSET_DEBUG(\n              (\"%s(%d): (op %s) %s %\" UVuf \" <- %\" UVuf \" (max %\" UVuf \").\\n\",\n              \"reginsert\",\n\t      __LINE__,\n\t      PL_reg_name[op],\n              (UV)(place - RExC_emit_start) > RExC_offsets[0]\n              ? \"Overwriting end of array!\\n\" : \"OK\",\n              (UV)(place - RExC_emit_start),\n              (UV)(RExC_parse - RExC_start),\n              (UV)RExC_offsets[0]));\n\tSet_Node_Offset(place, RExC_parse);\n\tSet_Node_Length(place, 1);\n    }\n#endif\n    src = NEXTOPER(place);\n    place->flags = 0;\n    FILL_ADVANCE_NODE(place, op);\n    Zero(src, offset, regnode);\n}\n\n/*\n- regtail - set the next-pointer at the end of a node chain of p to val.\n- SEE ALSO: regtail_study\n*/\nSTATIC void\nS_regtail(pTHX_ RExC_state_t * pRExC_state,\n                const regnode * const p,\n                const regnode * const val,\n                const U32 depth)\n{\n    regnode *scan;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL;\n#ifndef DEBUGGING\n    PERL_UNUSED_ARG(depth);\n#endif\n\n    if (SIZE_ONLY)\n\treturn;\n\n    /* Find last node. */\n    scan = (regnode *) p;\n    for (;;) {\n\tregnode * const temp = regnext(scan);\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tail\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) %s %s\\n\",\n                SvPV_nolen_const(RExC_mysv), REG_NODE_NUM(scan),\n                    (temp == NULL ? \"->\" : \"\"),\n                    (temp == NULL ? PL_reg_name[OP(val)] : \"\")\n            );\n        });\n        if (temp == NULL)\n            break;\n        scan = temp;\n    }\n\n    if (reg_off_by_arg[OP(scan)]) {\n        ARG_SET(scan, val - scan);\n    }\n    else {\n        NEXT_OFF(scan) = val - scan;\n    }\n}\n\n#ifdef DEBUGGING\n/*\n- regtail_study - set the next-pointer at the end of a node chain of p to val.\n- Look for optimizable sequences at the same time.\n- currently only looks for EXACT chains.\n\nThis is experimental code. The idea is to use this routine to perform\nin place optimizations on branches and groups as they are constructed,\nwith the long term intention of removing optimization from study_chunk so\nthat it is purely analytical.\n\nCurrently only used when in DEBUG mode. The macro REGTAIL_STUDY() is used\nto control which is which.\n\n*/\n/* TODO: All four parms should be const */\n\nSTATIC U8\nS_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p,\n                      const regnode *val,U32 depth)\n{\n    regnode *scan;\n    U8 exact = PSEUDO;\n#ifdef EXPERIMENTAL_INPLACESCAN\n    I32 min = 0;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGTAIL_STUDY;\n\n\n    if (SIZE_ONLY)\n        return exact;\n\n    /* Find last node. */\n\n    scan = p;\n    for (;;) {\n        regnode * const temp = regnext(scan);\n#ifdef EXPERIMENTAL_INPLACESCAN\n        if (PL_regkind[OP(scan)] == EXACT) {\n\t    bool unfolded_multi_char;\t/* Unexamined in this routine */\n            if (join_exact(pRExC_state, scan, &min,\n                           &unfolded_multi_char, 1, val, depth+1))\n                return EXACT;\n\t}\n#endif\n        if ( exact ) {\n            switch (OP(scan)) {\n                case EXACT:\n                case EXACTL:\n                case EXACTF:\n                case EXACTFA_NO_TRIE:\n                case EXACTFA:\n                case EXACTFU:\n                case EXACTFLU8:\n                case EXACTFU_SS:\n                case EXACTFL:\n                        if( exact == PSEUDO )\n                            exact= OP(scan);\n                        else if ( exact != OP(scan) )\n                            exact= 0;\n                case NOTHING:\n                    break;\n                default:\n                    exact= 0;\n            }\n        }\n        DEBUG_PARSE_r({\n            DEBUG_PARSE_MSG((scan==p ? \"tsdy\" : \"\"));\n            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\n            Perl_re_printf( aTHX_  \"~ %s (%d) -> %s\\n\",\n                SvPV_nolen_const(RExC_mysv),\n                REG_NODE_NUM(scan),\n                PL_reg_name[exact]);\n        });\n\tif (temp == NULL)\n\t    break;\n\tscan = temp;\n    }\n    DEBUG_PARSE_r({\n        DEBUG_PARSE_MSG(\"\");\n        regprop(RExC_rx, RExC_mysv, val, NULL, pRExC_state);\n        Perl_re_printf( aTHX_\n                      \"~ attach to %s (%\" IVdf \") offset to %\" IVdf \"\\n\",\n\t\t      SvPV_nolen_const(RExC_mysv),\n\t\t      (IV)REG_NODE_NUM(val),\n\t\t      (IV)(val - scan)\n        );\n    });\n    if (reg_off_by_arg[OP(scan)]) {\n\tARG_SET(scan, val - scan);\n    }\n    else {\n\tNEXT_OFF(scan) = val - scan;\n    }\n\n    return exact;\n}\n#endif\n\n/*\n - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form\n */\n#ifdef DEBUGGING\n\nstatic void\nS_regdump_intflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n\n    ASSUME(REG_INTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_INTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\",lead);\n            Perl_re_printf( aTHX_  \"%s \",PL_reg_intflags_name[bit]);\n        }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\",lead);\n    }\n}\n\nstatic void\nS_regdump_extflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n    regex_charset cs;\n\n    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n\n    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n\t    if ((1<<bit) & RXf_PMf_CHARSET) {\t/* Output separately, below */\n\t\tcontinue;\n\t    }\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\",lead);\n            Perl_re_printf( aTHX_  \"%s \",PL_reg_extflags_name[bit]);\n        }\n    }\n    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {\n            if (!set++ && lead) {\n                Perl_re_printf( aTHX_  \"%s\",lead);\n            }\n            switch (cs) {\n                case REGEX_UNICODE_CHARSET:\n                    Perl_re_printf( aTHX_  \"UNICODE\");\n                    break;\n                case REGEX_LOCALE_CHARSET:\n                    Perl_re_printf( aTHX_  \"LOCALE\");\n                    break;\n                case REGEX_ASCII_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-RESTRICTED\");\n                    break;\n                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-MORE_RESTRICTED\");\n                    break;\n                default:\n                    Perl_re_printf( aTHX_  \"UNKNOWN CHARACTER SET\");\n                    break;\n            }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\",lead);\n    }\n}\n#endif\n\nvoid\nPerl_regdump(pTHX_ const regexp *r)\n{\n#ifdef DEBUGGING\n    int i;\n    SV * const sv = sv_newmortal();\n    SV *dsv= sv_newmortal();\n    RXi_GET_DECL(r,ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGDUMP;\n\n    (void)dumpuntil(r, ri->program, ri->program + 1, NULL, NULL, sv, 0, 0);\n\n    /* Header fields of interest. */\n    for (i = 0; i < 2; i++) {\n        if (r->substrs->data[i].substr) {\n            RE_PV_QUOTED_DECL(s, 0, dsv,\n                            SvPVX_const(r->substrs->data[i].substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].substr),\n                            PL_dump_re_max_len);\n            Perl_re_printf( aTHX_\n                          \"%s %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n        else if (r->substrs->data[i].utf8_substr) {\n            RE_PV_QUOTED_DECL(s, 1, dsv,\n                            SvPVX_const(r->substrs->data[i].utf8_substr),\n                            RE_SV_DUMPLEN(r->substrs->data[i].utf8_substr),\n                            30);\n            Perl_re_printf( aTHX_\n                          \"%s utf8 %s%s at %\" IVdf \"..%\" UVuf \" \",\n                          i ? \"floating\" : \"anchored\",\n                          s,\n                          RE_SV_TAIL(r->substrs->data[i].utf8_substr),\n                          (IV)r->substrs->data[i].min_offset,\n                          (UV)r->substrs->data[i].max_offset);\n        }\n    }\n\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_\n\t\t      (const char *)\n\t\t      (   r->check_substr == r->substrs->data[1].substr\n\t\t       && r->check_utf8   == r->substrs->data[1].utf8_substr\n\t\t       ? \"(checking floating\" : \"(checking anchored\"));\n    if (r->intflags & PREGf_NOSCAN)\n        Perl_re_printf( aTHX_  \" noscan\");\n    if (r->extflags & RXf_CHECK_ALL)\n        Perl_re_printf( aTHX_  \" isall\");\n    if (r->check_substr || r->check_utf8)\n        Perl_re_printf( aTHX_  \") \");\n\n    if (ri->regstclass) {\n        regprop(r, sv, ri->regstclass, NULL, NULL);\n        Perl_re_printf( aTHX_  \"stclass %s \", SvPVX_const(sv));\n    }\n    if (r->intflags & PREGf_ANCH) {\n        Perl_re_printf( aTHX_  \"anchored\");\n        if (r->intflags & PREGf_ANCH_MBOL)\n            Perl_re_printf( aTHX_  \"(MBOL)\");\n        if (r->intflags & PREGf_ANCH_SBOL)\n            Perl_re_printf( aTHX_  \"(SBOL)\");\n        if (r->intflags & PREGf_ANCH_GPOS)\n            Perl_re_printf( aTHX_  \"(GPOS)\");\n        Perl_re_printf( aTHX_ \" \");\n    }\n    if (r->intflags & PREGf_GPOS_SEEN)\n        Perl_re_printf( aTHX_  \"GPOS:%\" UVuf \" \", (UV)r->gofs);\n    if (r->intflags & PREGf_SKIP)\n        Perl_re_printf( aTHX_  \"plus \");\n    if (r->intflags & PREGf_IMPLICIT)\n        Perl_re_printf( aTHX_  \"implicit \");\n    Perl_re_printf( aTHX_  \"minlen %\" IVdf \" \", (IV)r->minlen);\n    if (r->extflags & RXf_EVAL_SEEN)\n        Perl_re_printf( aTHX_  \"with eval \");\n    Perl_re_printf( aTHX_  \"\\n\");\n    DEBUG_FLAGS_r({\n        regdump_extflags(\"r->extflags: \",r->extflags);\n        regdump_intflags(\"r->intflags: \",r->intflags);\n    });\n#else\n    PERL_ARGS_ASSERT_REGDUMP;\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(r);\n#endif\t/* DEBUGGING */\n}\n\n/* Should be synchronized with ANYOF_ #defines in regcomp.h */\n#ifdef DEBUGGING\n\n#  if   _CC_WORDCHAR != 0 || _CC_DIGIT != 1        || _CC_ALPHA != 2    \\\n     || _CC_LOWER != 3    || _CC_UPPER != 4        || _CC_PUNCT != 5    \\\n     || _CC_PRINT != 6    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8    \\\n     || _CC_CASED != 9    || _CC_SPACE != 10       || _CC_BLANK != 11   \\\n     || _CC_XDIGIT != 12  || _CC_CNTRL != 13       || _CC_ASCII != 14   \\\n     || _CC_VERTSPACE != 15\n#   error Need to adjust order of anyofs[]\n#  endif\nstatic const char * const anyofs[] = {\n    \"\\\\w\",\n    \"\\\\W\",\n    \"\\\\d\",\n    \"\\\\D\",\n    \"[:alpha:]\",\n    \"[:^alpha:]\",\n    \"[:lower:]\",\n    \"[:^lower:]\",\n    \"[:upper:]\",\n    \"[:^upper:]\",\n    \"[:punct:]\",\n    \"[:^punct:]\",\n    \"[:print:]\",\n    \"[:^print:]\",\n    \"[:alnum:]\",\n    \"[:^alnum:]\",\n    \"[:graph:]\",\n    \"[:^graph:]\",\n    \"[:cased:]\",\n    \"[:^cased:]\",\n    \"\\\\s\",\n    \"\\\\S\",\n    \"[:blank:]\",\n    \"[:^blank:]\",\n    \"[:xdigit:]\",\n    \"[:^xdigit:]\",\n    \"[:cntrl:]\",\n    \"[:^cntrl:]\",\n    \"[:ascii:]\",\n    \"[:^ascii:]\",\n    \"\\\\v\",\n    \"\\\\V\"\n};\n#endif\n\n/*\n- regprop - printable representation of opcode, with run time support\n*/\n\nvoid\nPerl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state)\n{\n#ifdef DEBUGGING\n    int k;\n    RXi_GET_DECL(prog,progi);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGPROP;\n\n    SvPVCLEAR(sv);\n\n    if (OP(o) > REGNODE_MAX)\t\t/* regnode.type is unsigned */\n\t/* It would be nice to FAIL() here, but this may be called from\n\t   regexec.c, and it would be hard to supply pRExC_state. */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                              (int)OP(o), (int)REGNODE_MAX);\n    sv_catpv(sv, PL_reg_name[OP(o)]); /* Take off const! */\n\n    k = PL_regkind[OP(o)];\n\n    if (k == EXACT) {\n\tsv_catpvs(sv, \" \");\n\t/* Using is_utf8_string() (via PERL_PV_UNI_DETECT)\n\t * is a crude hack but it may be the best for now since\n\t * we have no flag \"this EXACTish node was UTF-8\"\n\t * --jhi */\n\tpv_pretty(sv, STRING(o), STR_LEN(o), PL_dump_re_max_len,\n                  PL_colors[0], PL_colors[1],\n\t\t  PERL_PV_ESCAPE_UNI_DETECT |\n\t\t  PERL_PV_ESCAPE_NONASCII   |\n\t\t  PERL_PV_PRETTY_ELLIPSES   |\n\t\t  PERL_PV_PRETTY_LTGT       |\n\t\t  PERL_PV_PRETTY_NOCLEAR\n\t\t  );\n    } else if (k == TRIE) {\n\t/* print the details of the trie in dumpuntil instead, as\n\t * progi->data isn't available here */\n        const char op = OP(o);\n        const U32 n = ARG(o);\n        const reg_ac_data * const ac = IS_TRIE_AC(op) ?\n               (reg_ac_data *)progi->data->data[n] :\n               NULL;\n        const reg_trie_data * const trie\n\t    = (reg_trie_data*)progi->data->data[!IS_TRIE_AC(op) ? n : ac->trie];\n\n        Perl_sv_catpvf(aTHX_ sv, \"-%s\",PL_reg_name[o->flags]);\n        DEBUG_TRIE_COMPILE_r({\n          if (trie->jump)\n            sv_catpvs(sv, \"(JUMP)\");\n          Perl_sv_catpvf(aTHX_ sv,\n            \"<S:%\" UVuf \"/%\" IVdf \" W:%\" UVuf \" L:%\" UVuf \"/%\" UVuf \" C:%\" UVuf \"/%\" UVuf \">\",\n            (UV)trie->startstate,\n            (IV)trie->statecount-1, /* -1 because of the unused 0 element */\n            (UV)trie->wordcount,\n            (UV)trie->minlen,\n            (UV)trie->maxlen,\n            (UV)TRIE_CHARCOUNT(trie),\n            (UV)trie->uniquecharcount\n          );\n        });\n        if ( IS_ANYOF_TRIE(op) || trie->bitmap ) {\n            sv_catpvs(sv, \"[\");\n            (void) put_charclass_bitmap_innards(sv,\n                                                ((IS_ANYOF_TRIE(op))\n                                                 ? ANYOF_BITMAP(o)\n                                                 : TRIE_BITMAP(trie)),\n                                                NULL,\n                                                NULL,\n                                                NULL,\n                                                FALSE\n                                               );\n            sv_catpvs(sv, \"]\");\n        }\n    } else if (k == CURLY) {\n        U32 lo = ARG1(o), hi = ARG2(o);\n\tif (OP(o) == CURLYM || OP(o) == CURLYN || OP(o) == CURLYX)\n\t    Perl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags); /* Parenth number */\n        Perl_sv_catpvf(aTHX_ sv, \"{%u,\", (unsigned) lo);\n        if (hi == REG_INFTY)\n            sv_catpvs(sv, \"INFTY\");\n        else\n            Perl_sv_catpvf(aTHX_ sv, \"%u\", (unsigned) hi);\n        sv_catpvs(sv, \"}\");\n    }\n    else if (k == WHILEM && o->flags)\t\t\t/* Ordinal/of */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d/%d]\", o->flags & 0xf, o->flags>>4);\n    else if (k == REF || k == OPEN || k == CLOSE\n             || k == GROUPP || OP(o)==ACCEPT)\n    {\n        AV *name_list= NULL;\n        U32 parno= OP(o) == ACCEPT ? (U32)ARG2L(o) : ARG(o);\n        Perl_sv_catpvf(aTHX_ sv, \"%\" UVuf, (UV)parno);        /* Parenth number */\n\tif ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n        if (name_list) {\n            if ( k != REF || (OP(o) < NREF)) {\n                SV **name= av_fetch(name_list, parno, 0 );\n\t        if (name)\n\t            Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n            }\n            else {\n                SV *sv_dat= MUTABLE_SV(progi->data->data[ parno ]);\n                I32 *nums=(I32*)SvPVX(sv_dat);\n                SV **name= av_fetch(name_list, nums[0], 0 );\n                I32 n;\n                if (name) {\n                    for ( n=0; n<SvIVX(sv_dat); n++ ) {\n                        Perl_sv_catpvf(aTHX_ sv, \"%s%\" IVdf,\n\t\t\t   \t    (n ? \",\" : \"\"), (IV)nums[n]);\n                    }\n                    Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n                }\n            }\n        }\n        if ( k == REF && reginfo) {\n            U32 n = ARG(o);  /* which paren pair */\n            I32 ln = prog->offs[n].start;\n            if (prog->lastparen < n || ln == -1)\n                Perl_sv_catpvf(aTHX_ sv, \": FAIL\");\n            else if (ln == prog->offs[n].end)\n                Perl_sv_catpvf(aTHX_ sv, \": ACCEPT - EMPTY STRING\");\n            else {\n                const char *s = reginfo->strbeg + ln;\n                Perl_sv_catpvf(aTHX_ sv, \": \");\n                Perl_pv_pretty( aTHX_ sv, s, prog->offs[n].end - prog->offs[n].start, 32, 0, 0,\n                    PERL_PV_ESCAPE_UNI_DETECT|PERL_PV_PRETTY_NOCLEAR|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE );\n            }\n        }\n    } else if (k == GOSUB) {\n        AV *name_list= NULL;\n        if ( RXp_PAREN_NAMES(prog) ) {\n            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);\n        } else if ( pRExC_state ) {\n            name_list= RExC_paren_name_list;\n        }\n\n        /* Paren and offset */\n        Perl_sv_catpvf(aTHX_ sv, \"%d[%+d:%d]\", (int)ARG(o),(int)ARG2L(o),\n                (int)((o + (int)ARG2L(o)) - progi->program) );\n        if (name_list) {\n            SV **name= av_fetch(name_list, ARG(o), 0 );\n            if (name)\n                Perl_sv_catpvf(aTHX_ sv, \" '%\" SVf \"'\", SVfARG(*name));\n        }\n    }\n    else if (k == LOGICAL)\n        /* 2: embedded, otherwise 1 */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d]\", o->flags);\n    else if (k == ANYOF) {\n\tconst U8 flags = ANYOF_FLAGS(o);\n        bool do_sep = FALSE;    /* Do we need to separate various components of\n                                   the output? */\n        /* Set if there is still an unresolved user-defined property */\n        SV *unresolved                = NULL;\n\n        /* Things that are ignored except when the runtime locale is UTF-8 */\n        SV *only_utf8_locale_invlist = NULL;\n\n        /* Code points that don't fit in the bitmap */\n        SV *nonbitmap_invlist = NULL;\n\n        /* And things that aren't in the bitmap, but are small enough to be */\n        SV* bitmap_range_not_in_bitmap = NULL;\n\n        const bool inverted = flags & ANYOF_INVERT;\n\n\tif (OP(o) == ANYOFL) {\n            if (ANYOFL_UTF8_LOCALE_REQD(flags)) {\n                sv_catpvs(sv, \"{utf8-locale-reqd}\");\n            }\n            if (flags & ANYOFL_FOLD) {\n                sv_catpvs(sv, \"{i}\");\n            }\n        }\n\n        /* If there is stuff outside the bitmap, get it */\n        if (ARG(o) != ANYOF_ONLY_HAS_BITMAP) {\n            (void) _get_regclass_nonbitmap_data(prog, o, FALSE,\n                                                &unresolved,\n                                                &only_utf8_locale_invlist,\n                                                &nonbitmap_invlist);\n            /* The non-bitmap data may contain stuff that could fit in the\n             * bitmap.  This could come from a user-defined property being\n             * finally resolved when this call was done; or much more likely\n             * because there are matches that require UTF-8 to be valid, and so\n             * aren't in the bitmap.  This is teased apart later */\n            _invlist_intersection(nonbitmap_invlist,\n                                  PL_InBitmap,\n                                  &bitmap_range_not_in_bitmap);\n            /* Leave just the things that don't fit into the bitmap */\n            _invlist_subtract(nonbitmap_invlist,\n                              PL_InBitmap,\n                              &nonbitmap_invlist);\n        }\n\n        /* Obey this flag to add all above-the-bitmap code points */\n        if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n            nonbitmap_invlist = _add_range_to_invlist(nonbitmap_invlist,\n                                                      NUM_ANYOF_CODE_POINTS,\n                                                      UV_MAX);\n        }\n\n        /* Ready to start outputting.  First, the initial left bracket */\n\tPerl_sv_catpvf(aTHX_ sv, \"[%s\", PL_colors[0]);\n\n        /* Then all the things that could fit in the bitmap */\n        do_sep = put_charclass_bitmap_innards(sv,\n                                              ANYOF_BITMAP(o),\n                                              bitmap_range_not_in_bitmap,\n                                              only_utf8_locale_invlist,\n                                              o,\n\n                                              /* Can't try inverting for a\n                                               * better display if there are\n                                               * things that haven't been\n                                               * resolved */\n                                              unresolved != NULL);\n        SvREFCNT_dec(bitmap_range_not_in_bitmap);\n\n        /* If there are user-defined properties which haven't been defined yet,\n         * output them.  If the result is not to be inverted, it is clearest to\n         * output them in a separate [] from the bitmap range stuff.  If the\n         * result is to be complemented, we have to show everything in one [],\n         * as the inversion applies to the whole thing.  Use {braces} to\n         * separate them from anything in the bitmap and anything above the\n         * bitmap. */\n        if (unresolved) {\n            if (inverted) {\n                if (! do_sep) { /* If didn't output anything in the bitmap */\n                    sv_catpvs(sv, \"^\");\n                }\n                sv_catpvs(sv, \"{\");\n            }\n            else if (do_sep) {\n                Perl_sv_catpvf(aTHX_ sv,\"%s][%s\",PL_colors[1],PL_colors[0]);\n            }\n            sv_catsv(sv, unresolved);\n            if (inverted) {\n                sv_catpvs(sv, \"}\");\n            }\n            do_sep = ! inverted;\n        }\n\n        /* And, finally, add the above-the-bitmap stuff */\n        if (nonbitmap_invlist && _invlist_len(nonbitmap_invlist)) {\n            SV* contents;\n\n            /* See if truncation size is overridden */\n            const STRLEN dump_len = (PL_dump_re_max_len > 256)\n                                    ? PL_dump_re_max_len\n                                    : 256;\n\n            /* This is output in a separate [] */\n            if (do_sep) {\n                Perl_sv_catpvf(aTHX_ sv,\"%s][%s\",PL_colors[1],PL_colors[0]);\n            }\n\n            /* And, for easy of understanding, it is shown in the\n             * uncomplemented form if possible.  The one exception being if\n             * there are unresolved items, where the inversion has to be\n             * delayed until runtime */\n            if (inverted && ! unresolved) {\n                _invlist_invert(nonbitmap_invlist);\n                _invlist_subtract(nonbitmap_invlist, PL_InBitmap, &nonbitmap_invlist);\n            }\n\n            contents = invlist_contents(nonbitmap_invlist,\n                                        FALSE /* output suitable for catsv */\n                                       );\n\n            /* If the output is shorter than the permissible maximum, just do it. */\n            if (SvCUR(contents) <= dump_len) {\n                sv_catsv(sv, contents);\n            }\n            else {\n                const char * contents_string = SvPVX(contents);\n                STRLEN i = dump_len;\n\n                /* Otherwise, start at the permissible max and work back to the\n                 * first break possibility */\n                while (i > 0 && contents_string[i] != ' ') {\n                    i--;\n                }\n                if (i == 0) {       /* Fail-safe.  Use the max if we couldn't\n                                       find a legal break */\n                    i = dump_len;\n                }\n\n                sv_catpvn(sv, contents_string, i);\n                sv_catpvs(sv, \"...\");\n            }\n\n            SvREFCNT_dec_NN(contents);\n            SvREFCNT_dec_NN(nonbitmap_invlist);\n        }\n\n        /* And finally the matching, closing ']' */\n\tPerl_sv_catpvf(aTHX_ sv, \"%s]\", PL_colors[1]);\n\n        SvREFCNT_dec(unresolved);\n    }\n    else if (k == POSIXD || k == NPOSIXD) {\n        U8 index = FLAGS(o) * 2;\n        if (index < C_ARRAY_LENGTH(anyofs)) {\n            if (*anyofs[index] != '[')  {\n                sv_catpv(sv, \"[\");\n            }\n            sv_catpv(sv, anyofs[index]);\n            if (*anyofs[index] != '[')  {\n                sv_catpv(sv, \"]\");\n            }\n        }\n        else {\n            Perl_sv_catpvf(aTHX_ sv, \"[illegal type=%d])\", index);\n        }\n    }\n    else if (k == BOUND || k == NBOUND) {\n        /* Must be synced with order of 'bound_type' in regcomp.h */\n        const char * const bounds[] = {\n            \"\",      /* Traditional */\n            \"{gcb}\",\n            \"{lb}\",\n            \"{sb}\",\n            \"{wb}\"\n        };\n        assert(FLAGS(o) < C_ARRAY_LENGTH(bounds));\n        sv_catpv(sv, bounds[FLAGS(o)]);\n    }\n    else if (k == BRANCHJ && (OP(o) == UNLESSM || OP(o) == IFMATCH))\n\tPerl_sv_catpvf(aTHX_ sv, \"[%d]\", -(o->flags));\n    else if (OP(o) == SBOL)\n        Perl_sv_catpvf(aTHX_ sv, \" /%s/\", o->flags ? \"\\\\A\" : \"^\");\n\n    /* add on the verb argument if there is one */\n    if ( ( k == VERB || OP(o) == ACCEPT || OP(o) == OPFAIL ) && o->flags) {\n        if ( ARG(o) )\n            Perl_sv_catpvf(aTHX_ sv, \":%\" SVf,\n                       SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));\n        else\n            sv_catpvs(sv, \":NULL\");\n    }\n#else\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n    PERL_UNUSED_ARG(o);\n    PERL_UNUSED_ARG(prog);\n    PERL_UNUSED_ARG(reginfo);\n    PERL_UNUSED_ARG(pRExC_state);\n#endif\t/* DEBUGGING */\n}\n\n\n\nSV *\nPerl_re_intuit_string(pTHX_ REGEXP * const r)\n{\t\t\t\t/* Assume that RE_INTUIT is set */\n    struct regexp *const prog = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_INTUIT_STRING;\n    PERL_UNUSED_CONTEXT;\n\n    DEBUG_COMPILE_r(\n\t{\n\t    const char * const s = SvPV_nolen_const(RX_UTF8(r)\n\t\t      ? prog->check_utf8 : prog->check_substr);\n\n\t    if (!PL_colorset) reginitcolors();\n            Perl_re_printf( aTHX_\n\t\t      \"%sUsing REx %ssubstr:%s \\\"%s%.60s%s%s\\\"\\n\",\n\t\t      PL_colors[4],\n\t\t      RX_UTF8(r) ? \"utf8 \" : \"\",\n\t\t      PL_colors[5],PL_colors[0],\n\t\t      s,\n\t\t      PL_colors[1],\n\t\t      (strlen(s) > PL_dump_re_max_len ? \"...\" : \"\"));\n\t} );\n\n    /* use UTF8 check substring if regexp pattern itself is in UTF8 */\n    return RX_UTF8(r) ? prog->check_utf8 : prog->check_substr;\n}\n\n/*\n   pregfree()\n\n   handles refcounting and freeing the perl core regexp structure. When\n   it is necessary to actually free the structure the first thing it\n   does is call the 'free' method of the regexp_engine associated to\n   the regexp, allowing the handling of the void *pprivate; member\n   first. (This routine is not overridable by extensions, which is why\n   the extensions free is called first.)\n\n   See regdupe and regdupe_internal if you change anything here.\n*/\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_pregfree(pTHX_ REGEXP *r)\n{\n    SvREFCNT_dec(r);\n}\n\nvoid\nPerl_pregfree2(pTHX_ REGEXP *rx)\n{\n    struct regexp *const r = ReANY(rx);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_PREGFREE2;\n\n    if (r->mother_re) {\n        ReREFCNT_dec(r->mother_re);\n    } else {\n        CALLREGFREE_PVT(rx); /* free the private data */\n        SvREFCNT_dec(RXp_PAREN_NAMES(r));\n    }\n    if (r->substrs) {\n        int i;\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_dec(r->substrs->data[i].substr);\n            SvREFCNT_dec(r->substrs->data[i].utf8_substr);\n        }\n\tSafefree(r->substrs);\n    }\n    RX_MATCH_COPY_FREE(rx);\n#ifdef PERL_ANY_COW\n    SvREFCNT_dec(r->saved_copy);\n#endif\n    Safefree(r->offs);\n    SvREFCNT_dec(r->qr_anoncv);\n    if (r->recurse_locinput)\n        Safefree(r->recurse_locinput);\n}\n\n\n/*  reg_temp_copy()\n\n    Copy ssv to dsv, both of which should of type SVt_REGEXP or SVt_PVLV,\n    except that dsv will be created if NULL.\n\n    This function is used in two main ways. First to implement\n        $r = qr/....; $s = $$r;\n\n    Secondly, it is used as a hacky workaround to the structural issue of\n    match results\n    being stored in the regexp structure which is in turn stored in\n    PL_curpm/PL_reg_curpm. The problem is that due to qr// the pattern\n    could be PL_curpm in multiple contexts, and could require multiple\n    result sets being associated with the pattern simultaneously, such\n    as when doing a recursive match with (??{$qr})\n\n    The solution is to make a lightweight copy of the regexp structure\n    when a qr// is returned from the code executed by (??{$qr}) this\n    lightweight copy doesn't actually own any of its data except for\n    the starp/end and the actual regexp structure itself.\n\n*/\n\n\nREGEXP *\nPerl_reg_temp_copy(pTHX_ REGEXP *dsv, REGEXP *ssv)\n{\n    struct regexp *drx;\n    struct regexp *const srx = ReANY(ssv);\n    const bool islv = dsv && SvTYPE(dsv) == SVt_PVLV;\n\n    PERL_ARGS_ASSERT_REG_TEMP_COPY;\n\n    if (!dsv)\n\tdsv = (REGEXP*) newSV_type(SVt_REGEXP);\n    else {\n\tSvOK_off((SV *)dsv);\n\tif (islv) {\n\t    /* For PVLVs, the head (sv_any) points to an XPVLV, while\n             * the LV's xpvlenu_rx will point to a regexp body, which\n             * we allocate here */\n\t    REGEXP *temp = (REGEXP *)newSV_type(SVt_REGEXP);\n\t    assert(!SvPVX(dsv));\n            ((XPV*)SvANY(dsv))->xpv_len_u.xpvlenu_rx = temp->sv_any;\n\t    temp->sv_any = NULL;\n\t    SvFLAGS(temp) = (SvFLAGS(temp) & ~SVTYPEMASK) | SVt_NULL;\n\t    SvREFCNT_dec_NN(temp);\n\t    /* SvCUR still resides in the xpvlv struct, so the regexp copy-\n\t       ing below will not set it. */\n\t    SvCUR_set(dsv, SvCUR(ssv));\n\t}\n    }\n    /* This ensures that SvTHINKFIRST(sv) is true, and hence that\n       sv_force_normal(sv) is called.  */\n    SvFAKE_on(dsv);\n    drx = ReANY(dsv);\n\n    SvFLAGS(dsv) |= SvFLAGS(ssv) & (SVf_POK|SVp_POK|SVf_UTF8);\n    SvPV_set(dsv, RX_WRAPPED(ssv));\n    /* We share the same string buffer as the original regexp, on which we\n       hold a reference count, incremented when mother_re is set below.\n       The string pointer is copied here, being part of the regexp struct.\n     */\n    memcpy(&(drx->xpv_cur), &(srx->xpv_cur),\n\t   sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur));\n    if (!islv)\n        SvLEN_set(dsv, 0);\n    if (srx->offs) {\n        const I32 npar = srx->nparens+1;\n        Newx(drx->offs, npar, regexp_paren_pair);\n        Copy(srx->offs, drx->offs, npar, regexp_paren_pair);\n    }\n    if (srx->substrs) {\n        int i;\n        Newx(drx->substrs, 1, struct reg_substr_data);\n\tStructCopy(srx->substrs, drx->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            SvREFCNT_inc_void(drx->substrs->data[i].substr);\n            SvREFCNT_inc_void(drx->substrs->data[i].utf8_substr);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n    }\n    RX_MATCH_COPIED_off(dsv);\n#ifdef PERL_ANY_COW\n    drx->saved_copy = NULL;\n#endif\n    drx->mother_re = ReREFCNT_inc(srx->mother_re ? srx->mother_re : ssv);\n    SvREFCNT_inc_void(drx->qr_anoncv);\n    if (srx->recurse_locinput)\n        Newx(drx->recurse_locinput,srx->nparens + 1,char *);\n\n    return dsv;\n}\n#endif\n\n\n/* regfree_internal()\n\n   Free the private data in a regexp. This is overloadable by\n   extensions. Perl takes care of the regexp structure in pregfree(),\n   this covers the *pprivate pointer which technically perl doesn't\n   know about, however of course we have to handle the\n   regexp_internal structure when no extension is in use.\n\n   Note this is called before freeing anything in the regexp\n   structure.\n */\n\nvoid\nPerl_regfree_internal(pTHX_ REGEXP * const rx)\n{\n    struct regexp *const r = ReANY(rx);\n    RXi_GET_DECL(r,ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_REGFREE_INTERNAL;\n\n    DEBUG_COMPILE_r({\n\tif (!PL_colorset)\n\t    reginitcolors();\n\t{\n\t    SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RX_UTF8(rx),\n                dsv, RX_PRECOMP(rx), RX_PRELEN(rx), PL_dump_re_max_len);\n            Perl_re_printf( aTHX_ \"%sFreeing REx:%s %s\\n\",\n                PL_colors[4],PL_colors[5],s);\n        }\n    });\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets)\n        Safefree(ri->u.offsets);             /* 20010421 MJD */\n#endif\n    if (ri->code_blocks)\n        S_free_codeblocks(aTHX_ ri->code_blocks);\n\n    if (ri->data) {\n\tint n = ri->data->count;\n\n\twhile (--n >= 0) {\n          /* If you add a ->what type here, update the comment in regcomp.h */\n\t    switch (ri->data->what[n]) {\n\t    case 'a':\n\t    case 'r':\n\t    case 's':\n\t    case 'S':\n\t    case 'u':\n\t\tSvREFCNT_dec(MUTABLE_SV(ri->data->data[n]));\n\t\tbreak;\n\t    case 'f':\n\t\tSafefree(ri->data->data[n]);\n\t\tbreak;\n\t    case 'l':\n\t    case 'L':\n\t        break;\n            case 'T':\n                { /* Aho Corasick add-on structure for a trie node.\n                     Used in stclass optimization only */\n                    U32 refcount;\n                    reg_ac_data *aho=(reg_ac_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --aho->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(aho->states);\n                        PerlMemShared_free(aho->fail);\n\t\t\t /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n                        /* we should only ever get called once, so\n                         * assert as much, and also guard the free\n                         * which /might/ happen twice. At the least\n                         * it will make code anlyzers happy and it\n                         * doesn't cost much. - Yves */\n                        assert(ri->regstclass);\n                        if (ri->regstclass) {\n                            PerlMemShared_free(ri->regstclass);\n                            ri->regstclass = 0;\n                        }\n                    }\n                }\n                break;\n\t    case 't':\n\t        {\n\t            /* trie structure. */\n\t            U32 refcount;\n\t            reg_trie_data *trie=(reg_trie_data*)ri->data->data[n];\n#ifdef USE_ITHREADS\n                    dVAR;\n#endif\n                    OP_REFCNT_LOCK;\n                    refcount = --trie->refcount;\n                    OP_REFCNT_UNLOCK;\n                    if ( !refcount ) {\n                        PerlMemShared_free(trie->charmap);\n                        PerlMemShared_free(trie->states);\n                        PerlMemShared_free(trie->trans);\n                        if (trie->bitmap)\n                            PerlMemShared_free(trie->bitmap);\n                        if (trie->jump)\n                            PerlMemShared_free(trie->jump);\n\t\t\tPerlMemShared_free(trie->wordinfo);\n                        /* do this last!!!! */\n                        PerlMemShared_free(ri->data->data[n]);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tPerl_croak(aTHX_ \"panic: regfree data code '%c'\",\n                                                    ri->data->what[n]);\n\t    }\n\t}\n\tSafefree(ri->data->what);\n\tSafefree(ri->data);\n    }\n\n    Safefree(ri);\n}\n\n#define av_dup_inc(s,t)\tMUTABLE_AV(sv_dup_inc((const SV *)s,t))\n#define hv_dup_inc(s,t)\tMUTABLE_HV(sv_dup_inc((const SV *)s,t))\n#define SAVEPVN(p,n)\t((p) ? savepvn(p,n) : NULL)\n\n/*\n   re_dup_guts - duplicate a regexp.\n\n   This routine is expected to clone a given regexp structure. It is only\n   compiled under USE_ITHREADS.\n\n   After all of the core data stored in struct regexp is duplicated\n   the regexp_engine.dupe method is used to copy any private data\n   stored in the *pprivate pointer. This allows extensions to handle\n   any duplication it needs to do.\n\n   See pregfree() and regfree_internal() if you change anything here.\n*/\n#if defined(USE_ITHREADS)\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS *param)\n{\n    dVAR;\n    I32 npar;\n    const struct regexp *r = ReANY(sstr);\n    struct regexp *ret = ReANY(dstr);\n\n    PERL_ARGS_ASSERT_RE_DUP_GUTS;\n\n    npar = r->nparens+1;\n    Newx(ret->offs, npar, regexp_paren_pair);\n    Copy(r->offs, ret->offs, npar, regexp_paren_pair);\n\n    if (ret->substrs) {\n\t/* Do it this way to avoid reading from *r after the StructCopy().\n\t   That way, if any of the sv_dup_inc()s dislodge *r from the L1\n\t   cache, it doesn't matter.  */\n        int i;\n\tconst bool anchored = r->check_substr\n\t    ? r->check_substr == r->substrs->data[0].substr\n\t    : r->check_utf8   == r->substrs->data[0].utf8_substr;\n        Newx(ret->substrs, 1, struct reg_substr_data);\n\tStructCopy(r->substrs, ret->substrs, struct reg_substr_data);\n\n        for (i = 0; i < 2; i++) {\n            ret->substrs->data[i].substr =\n                        sv_dup_inc(ret->substrs->data[i].substr, param);\n            ret->substrs->data[i].utf8_substr =\n                        sv_dup_inc(ret->substrs->data[i].utf8_substr, param);\n        }\n\n\t/* check_substr and check_utf8, if non-NULL, point to either their\n\t   anchored or float namesakes, and don't hold a second reference.  */\n\n\tif (ret->check_substr) {\n\t    if (anchored) {\n\t\tassert(r->check_utf8 == r->substrs->data[0].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[0].substr;\n\t\tret->check_utf8   = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tassert(r->check_substr == r->substrs->data[1].substr);\n\t\tassert(r->check_utf8   == r->substrs->data[1].utf8_substr);\n\n\t\tret->check_substr = ret->substrs->data[1].substr;\n\t\tret->check_utf8   = ret->substrs->data[1].utf8_substr;\n\t    }\n\t} else if (ret->check_utf8) {\n\t    if (anchored) {\n\t\tret->check_utf8 = ret->substrs->data[0].utf8_substr;\n\t    } else {\n\t\tret->check_utf8 = ret->substrs->data[1].utf8_substr;\n\t    }\n\t}\n    }\n\n    RXp_PAREN_NAMES(ret) = hv_dup_inc(RXp_PAREN_NAMES(ret), param);\n    ret->qr_anoncv = MUTABLE_CV(sv_dup_inc((const SV *)ret->qr_anoncv, param));\n    if (r->recurse_locinput)\n        Newx(ret->recurse_locinput,r->nparens + 1,char *);\n\n    if (ret->pprivate)\n\tRXi_SET(ret,CALLREGDUPE_PVT(dstr,param));\n\n    if (RX_MATCH_COPIED(dstr))\n\tret->subbeg  = SAVEPVN(ret->subbeg, ret->sublen);\n    else\n\tret->subbeg = NULL;\n#ifdef PERL_ANY_COW\n    ret->saved_copy = NULL;\n#endif\n\n    /* Whether mother_re be set or no, we need to copy the string.  We\n       cannot refrain from copying it when the storage points directly to\n       our mother regexp, because that's\n\t       1: a buffer in a different thread\n\t       2: something we no longer hold a reference on\n\t       so we need to copy it locally.  */\n    RX_WRAPPED(dstr) = SAVEPVN(RX_WRAPPED_const(sstr), SvCUR(sstr)+1);\n    ret->mother_re   = NULL;\n}\n#endif /* PERL_IN_XSUB_RE */\n\n/*\n   regdupe_internal()\n\n   This is the internal complement to regdupe() which is used to copy\n   the structure pointed to by the *pprivate pointer in the regexp.\n   This is the core version of the extension overridable cloning hook.\n   The regexp structure being duplicated will be copied by perl prior\n   to this and will be provided as the regexp *r argument, however\n   with the /old/ structures pprivate pointer value. Thus this routine\n   may override any copying normally done by perl.\n\n   It returns a pointer to the new regexp_internal structure.\n*/\n\nvoid *\nPerl_regdupe_internal(pTHX_ REGEXP * const rx, CLONE_PARAMS *param)\n{\n    dVAR;\n    struct regexp *const r = ReANY(rx);\n    regexp_internal *reti;\n    int len;\n    RXi_GET_DECL(r,ri);\n\n    PERL_ARGS_ASSERT_REGDUPE_INTERNAL;\n\n    len = ProgLen(ri);\n\n    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode),\n          char, regexp_internal);\n    Copy(ri->program, reti->program, len+1, regnode);\n\n\n    if (ri->code_blocks) {\n\tint n;\n\tNewx(reti->code_blocks, 1, struct reg_code_blocks);\n\tNewx(reti->code_blocks->cb, ri->code_blocks->count,\n                    struct reg_code_block);\n\tCopy(ri->code_blocks->cb, reti->code_blocks->cb,\n             ri->code_blocks->count, struct reg_code_block);\n\tfor (n = 0; n < ri->code_blocks->count; n++)\n\t     reti->code_blocks->cb[n].src_regex = (REGEXP*)\n\t\t    sv_dup_inc((SV*)(ri->code_blocks->cb[n].src_regex), param);\n        reti->code_blocks->count = ri->code_blocks->count;\n        reti->code_blocks->refcnt = 1;\n    }\n    else\n\treti->code_blocks = NULL;\n\n    reti->regstclass = NULL;\n\n    if (ri->data) {\n\tstruct reg_data *d;\n        const int count = ri->data->count;\n\tint i;\n\n\tNewxc(d, sizeof(struct reg_data) + count*sizeof(void *),\n\t\tchar, struct reg_data);\n\tNewx(d->what, count, U8);\n\n\td->count = count;\n\tfor (i = 0; i < count; i++) {\n\t    d->what[i] = ri->data->what[i];\n\t    switch (d->what[i]) {\n\t        /* see also regcomp.h and regfree_internal() */\n            case 'a': /* actually an AV, but the dup function is identical.\n                         values seem to be \"plain sv's\" generally. */\n            case 'r': /* a compiled regex (but still just another SV) */\n            case 's': /* an RV (currently only used for an RV to an AV by the ANYOF code)\n                         this use case should go away, the code could have used\n                         'a' instead - see S_set_ANYOF_arg() for array contents. */\n            case 'S': /* actually an SV, but the dup function is identical.  */\n            case 'u': /* actually an HV, but the dup function is identical.\n                         values are \"plain sv's\" */\n\t\td->data[i] = sv_dup_inc((const SV *)ri->data->data[i], param);\n\t\tbreak;\n\t    case 'f':\n                /* Synthetic Start Class - \"Fake\" charclass we generate to optimize\n                 * patterns which could start with several different things. Pre-TRIE\n                 * this was more important than it is now, however this still helps\n                 * in some places, for instance /x?a+/ might produce a SSC equivalent\n                 * to [xa]. This is used by Perl_re_intuit_start() and S_find_byclass()\n                 * in regexec.c\n                 */\n\t\t/* This is cheating. */\n\t\tNewx(d->data[i], 1, regnode_ssc);\n\t\tStructCopy(ri->data->data[i], d->data[i], regnode_ssc);\n\t\treti->regstclass = (regnode*)d->data[i];\n\t\tbreak;\n\t    case 'T':\n                /* AHO-CORASICK fail table */\n                /* Trie stclasses are readonly and can thus be shared\n\t\t * without duplication. We free the stclass in pregfree\n\t\t * when the corresponding reg_ac_data struct is freed.\n\t\t */\n\t\treti->regstclass= ri->regstclass;\n\t\t/* FALLTHROUGH */\n\t    case 't':\n                /* TRIE transition table */\n\t\tOP_REFCNT_LOCK;\n\t\t((reg_trie_data*)ri->data->data[i])->refcount++;\n\t\tOP_REFCNT_UNLOCK;\n\t\t/* FALLTHROUGH */\n            case 'l': /* (?{...}) or (??{ ... }) code (cb->block) */\n            case 'L': /* same when RExC_pm_flags & PMf_HAS_CV and code\n                         is not from another regexp */\n\t\td->data[i] = ri->data->data[i];\n\t\tbreak;\n            default:\n                Perl_croak(aTHX_ \"panic: re_dup_guts unknown data code '%c'\",\n                                                           ri->data->what[i]);\n\t    }\n\t}\n\n\treti->data = d;\n    }\n    else\n\treti->data = NULL;\n\n    reti->name_list_idx = ri->name_list_idx;\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    if (ri->u.offsets) {\n        Newx(reti->u.offsets, 2*len+1, U32);\n        Copy(ri->u.offsets, reti->u.offsets, 2*len+1, U32);\n    }\n#else\n    SetProgLen(reti,len);\n#endif\n\n    return (void*)reti;\n}\n\n#endif    /* USE_ITHREADS */\n\n#ifndef PERL_IN_XSUB_RE\n\n/*\n - regnext - dig the \"next\" pointer out of a node\n */\nregnode *\nPerl_regnext(pTHX_ regnode *p)\n{\n    I32 offset;\n\n    if (!p)\n\treturn(NULL);\n\n    if (OP(p) > REGNODE_MAX) {\t\t/* regnode.type is unsigned */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                                (int)OP(p), (int)REGNODE_MAX);\n    }\n\n    offset = (reg_off_by_arg[OP(p)] ? ARG(p) : NEXT_OFF(p));\n    if (offset == 0)\n\treturn(NULL);\n\n    return(p+offset);\n}\n#endif\n\nSTATIC void\nS_re_croak2(pTHX_ bool utf8, const char* pat1,const char* pat2,...)\n{\n    va_list args;\n    STRLEN l1 = strlen(pat1);\n    STRLEN l2 = strlen(pat2);\n    char buf[512];\n    SV *msv;\n    const char *message;\n\n    PERL_ARGS_ASSERT_RE_CROAK2;\n\n    if (l1 > 510)\n\tl1 = 510;\n    if (l1 + l2 > 510)\n\tl2 = 510 - l1;\n    Copy(pat1, buf, l1 , char);\n    Copy(pat2, buf + l1, l2 , char);\n    buf[l1 + l2] = '\\n';\n    buf[l1 + l2 + 1] = '\\0';\n    va_start(args, pat2);\n    msv = vmess(buf, &args);\n    va_end(args);\n    message = SvPV_const(msv,l1);\n    if (l1 > 512)\n\tl1 = 512;\n    Copy(message, buf, l1 , char);\n    /* l1-1 to avoid \\n */\n    Perl_croak(aTHX_ \"%\" UTF8f, UTF8fARG(utf8, l1-1, buf));\n}\n\n/* XXX Here's a total kludge.  But we need to re-enter for swash routines. */\n\n#ifndef PERL_IN_XSUB_RE\nvoid\nPerl_save_re_context(pTHX)\n{\n    I32 nparens = -1;\n    I32 i;\n\n    /* Save $1..$n (#18107: UTF-8 s/(\\w+)/uc($1)/e); AMS 20021106. */\n\n    if (PL_curpm) {\n\tconst REGEXP * const rx = PM_GETRE(PL_curpm);\n\tif (rx)\n            nparens = RX_NPARENS(rx);\n    }\n\n    /* RT #124109. This is a complete hack; in the SWASHNEW case we know\n     * that PL_curpm will be null, but that utf8.pm and the modules it\n     * loads will only use $1..$3.\n     * The t/porting/re_context.t test file checks this assumption.\n     */\n    if (nparens == -1)\n        nparens = 3;\n\n    for (i = 1; i <= nparens; i++) {\n        char digits[TYPE_CHARS(long)];\n        const STRLEN len = my_snprintf(digits, sizeof(digits),\n                                       \"%lu\", (long)i);\n        GV *const *const gvp\n            = (GV**)hv_fetch(PL_defstash, digits, len, 0);\n\n        if (gvp) {\n            GV * const gv = *gvp;\n            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))\n                save_scalar(gv);\n        }\n    }\n}\n#endif\n\n#ifdef DEBUGGING\n\nSTATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\n        /* We use {phrase} as metanotation in the class, so also escape literal\n         * braces */\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }\n}\n\n#define MAX_PRINT_A MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C\n\nSTATIC void\nS_put_range(pTHX_ SV *sv, UV start, const UV end, const bool allow_literals)\n{\n    /* Appends to 'sv' a displayable version of the range of code points from\n     * 'start' to 'end'.  Mnemonics (like '\\r') are used for the few controls\n     * that have them, when they occur at the beginning or end of the range.\n     * It uses hex to output the remaining code points, unless 'allow_literals'\n     * is true, in which case the printable ASCII ones are output as-is (though\n     * some of these will be escaped by put_code_point()).\n     *\n     * NOTE:  This is designed only for printing ranges of code points that fit\n     *        inside an ANYOF bitmap.  Higher code points are simply suppressed\n     */\n\n    const unsigned int min_range_count = 3;\n\n    assert(start <= end);\n\n    PERL_ARGS_ASSERT_PUT_RANGE;\n\n    while (start <= end) {\n        UV this_end;\n        const char * format;\n\n        if (end - start < min_range_count) {\n\n            /* Output chars individually when they occur in short ranges */\n            for (; start <= end; start++) {\n                put_code_point(sv, start);\n            }\n            break;\n        }\n\n        /* If permitted by the input options, and there is a possibility that\n         * this range contains a printable literal, look to see if there is\n         * one. */\n        if (allow_literals && start <= MAX_PRINT_A) {\n\n            /* If the character at the beginning of the range isn't an ASCII\n             * printable, effectively split the range into two parts:\n             *  1) the portion before the first such printable,\n             *  2) the rest\n             * and output them separately. */\n            if (! isPRINT_A(start)) {\n                UV temp_end = start + 1;\n\n                /* There is no point looking beyond the final possible\n                 * printable, in MAX_PRINT_A */\n                UV max = MIN(end, MAX_PRINT_A);\n\n                while (temp_end <= max && ! isPRINT_A(temp_end)) {\n                    temp_end++;\n                }\n\n                /* Here, temp_end points to one beyond the first printable if\n                 * found, or to one beyond 'max' if not.  If none found, make\n                 * sure that we use the entire range */\n                if (temp_end > MAX_PRINT_A) {\n                    temp_end = end + 1;\n                }\n\n                /* Output the first part of the split range: the part that\n                 * doesn't have printables, with the parameter set to not look\n                 * for literals (otherwise we would infinitely recurse) */\n                put_range(sv, start, temp_end - 1, FALSE);\n\n                /* The 2nd part of the range (if any) starts here. */\n                start = temp_end;\n\n                /* We do a continue, instead of dropping down, because even if\n                 * the 2nd part is non-empty, it could be so short that we want\n                 * to output it as individual characters, as tested for at the\n                 * top of this loop.  */\n                continue;\n            }\n\n            /* Here, 'start' is a printable ASCII.  If it is an alphanumeric,\n             * output a sub-range of just the digits or letters, then process\n             * the remaining portion as usual. */\n            if (isALPHANUMERIC_A(start)) {\n                UV mask = (isDIGIT_A(start))\n                           ? _CC_DIGIT\n                             : isUPPER_A(start)\n                               ? _CC_UPPER\n                               : _CC_LOWER;\n                UV temp_end = start + 1;\n\n                /* Find the end of the sub-range that includes just the\n                 * characters in the same class as the first character in it */\n                while (temp_end <= end && _generic_isCC_A(temp_end, mask)) {\n                    temp_end++;\n                }\n                temp_end--;\n\n                /* For short ranges, don't duplicate the code above to output\n                 * them; just call recursively */\n                if (temp_end - start < min_range_count) {\n                    put_range(sv, start, temp_end, FALSE);\n                }\n                else {  /* Output as a range */\n                    put_code_point(sv, start);\n                    sv_catpvs(sv, \"-\");\n                    put_code_point(sv, temp_end);\n                }\n                start = temp_end + 1;\n                continue;\n            }\n\n            /* We output any other printables as individual characters */\n            if (isPUNCT_A(start) || isSPACE_A(start)) {\n                while (start <= end && (isPUNCT_A(start)\n                                        || isSPACE_A(start)))\n                {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                continue;\n            }\n        } /* End of looking for literals */\n\n        /* Here is not to output as a literal.  Some control characters have\n         * mnemonic names.  Split off any of those at the beginning and end of\n         * the range to print mnemonically.  It isn't possible for many of\n         * these to be in a row, so this won't overwhelm with output */\n        if (   start <= end\n            && (isMNEMONIC_CNTRL(start) || isMNEMONIC_CNTRL(end)))\n        {\n            while (isMNEMONIC_CNTRL(start) && start <= end) {\n                put_code_point(sv, start);\n                start++;\n            }\n\n            /* If this didn't take care of the whole range ... */\n            if (start <= end) {\n\n                /* Look backwards from the end to find the final non-mnemonic\n                 * */\n                UV temp_end = end;\n                while (isMNEMONIC_CNTRL(temp_end)) {\n                    temp_end--;\n                }\n\n                /* And separately output the interior range that doesn't start\n                 * or end with mnemonics */\n                put_range(sv, start, temp_end, FALSE);\n\n                /* Then output the mnemonic trailing controls */\n                start = temp_end + 1;\n                while (start <= end) {\n                    put_code_point(sv, start);\n                    start++;\n                }\n                break;\n            }\n        }\n\n        /* As a final resort, output the range or subrange as hex. */\n\n        this_end = (end < NUM_ANYOF_CODE_POINTS)\n                    ? end\n                    : NUM_ANYOF_CODE_POINTS - 1;\n#if NUM_ANYOF_CODE_POINTS > 256\n        format = (this_end < 256)\n                 ? \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf\n                 : \"\\\\x{%04\" UVXf \"}-\\\\x{%04\" UVXf \"}\";\n#else\n        format = \"\\\\x%02\" UVXf \"-\\\\x%02\" UVXf;\n#endif\n        GCC_DIAG_IGNORE(-Wformat-nonliteral);\n        Perl_sv_catpvf(aTHX_ sv, format, start, this_end);\n        GCC_DIAG_RESTORE;\n        break;\n    }\n}\n\nSTATIC void\nS_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist)\n{\n    /* Concatenate onto the PV in 'sv' a displayable form of the inversion list\n     * 'invlist' */\n\n    UV start, end;\n    bool allow_literals = TRUE;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST;\n\n    /* Generally, it is more readable if printable characters are output as\n     * literals, but if a range (nearly) spans all of them, it's best to output\n     * it as a single range.  This code will use a single range if all but 2\n     * ASCII printables are in it */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\n        /* If the range starts beyond the final printable, it doesn't have any\n         * in it */\n        if (start > MAX_PRINT_A) {\n            break;\n        }\n\n        /* In both ASCII and EBCDIC, a SPACE is the lowest printable.  To span\n         * all but two, the range must start and end no later than 2 from\n         * either end */\n        if (start < ' ' + 2 && end > MAX_PRINT_A - 2) {\n            if (end > MAX_PRINT_A) {\n                end = MAX_PRINT_A;\n            }\n            if (start < ' ') {\n                start = ' ';\n            }\n            if (end - start >= MAX_PRINT_A - ' ' - 2) {\n                allow_literals = FALSE;\n            }\n            break;\n        }\n    }\n    invlist_iterfinish(invlist);\n\n    /* Here we have figured things out.  Output each range */\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n        if (start >= NUM_ANYOF_CODE_POINTS) {\n            break;\n        }\n        put_range(sv, start, end, allow_literals);\n    }\n    invlist_iterfinish(invlist);\n\n    return;\n}\n\nSTATIC SV*\nS_put_charclass_bitmap_innards_common(pTHX_\n        SV* invlist,            /* The bitmap */\n        SV* posixes,            /* Under /l, things like [:word:], \\S */\n        SV* only_utf8,          /* Under /d, matches iff the target is UTF-8 */\n        SV* not_utf8,           /* /d, matches iff the target isn't UTF-8 */\n        SV* only_utf8_locale,   /* Under /l, matches if the locale is UTF-8 */\n        const bool invert       /* Is the result to be inverted? */\n)\n{\n    /* Create and return an SV containing a displayable version of the bitmap\n     * and associated information determined by the input parameters.  If the\n     * output would have been only the inversion indicator '^', NULL is instead\n     * returned. */\n\n    SV * output;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON;\n\n    if (invert) {\n        output = newSVpvs(\"^\");\n    }\n    else {\n        output = newSVpvs(\"\");\n    }\n\n    /* First, the code points in the bitmap that are unconditionally there */\n    put_charclass_bitmap_innards_invlist(output, invlist);\n\n    /* Traditionally, these have been placed after the main code points */\n    if (posixes) {\n        sv_catsv(output, posixes);\n    }\n\n    if (only_utf8 && _invlist_len(only_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8);\n    }\n\n    if (not_utf8 && _invlist_len(not_utf8)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{not utf8}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, not_utf8);\n    }\n\n    if (only_utf8_locale && _invlist_len(only_utf8_locale)) {\n        Perl_sv_catpvf(aTHX_ output, \"%s{utf8 locale}%s\", PL_colors[1], PL_colors[0]);\n        put_charclass_bitmap_innards_invlist(output, only_utf8_locale);\n\n        /* This is the only list in this routine that can legally contain code\n         * points outside the bitmap range.  The call just above to\n         * 'put_charclass_bitmap_innards_invlist' will simply suppress them, so\n         * output them here.  There's about a half-dozen possible, and none in\n         * contiguous ranges longer than 2 */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            UV start, end;\n            SV* above_bitmap = NULL;\n\n            _invlist_subtract(only_utf8_locale, PL_InBitmap, &above_bitmap);\n\n            invlist_iterinit(above_bitmap);\n            while (invlist_iternext(above_bitmap, &start, &end)) {\n                UV i;\n\n                for (i = start; i <= end; i++) {\n                    put_code_point(output, i);\n                }\n            }\n            invlist_iterfinish(above_bitmap);\n            SvREFCNT_dec_NN(above_bitmap);\n        }\n    }\n\n    if (invert && SvCUR(output) == 1) {\n        return NULL;\n    }\n\n    return output;\n}\n\nSTATIC bool\nS_put_charclass_bitmap_innards(pTHX_ SV *sv,\n                                     char *bitmap,\n                                     SV *nonbitmap_invlist,\n                                     SV *only_utf8_locale_invlist,\n                                     const regnode * const node,\n                                     const bool force_as_is_display)\n{\n    /* Appends to 'sv' a displayable version of the innards of the bracketed\n     * character class defined by the other arguments:\n     *  'bitmap' points to the bitmap.\n     *  'nonbitmap_invlist' is an inversion list of the code points that are in\n     *      the bitmap range, but for some reason aren't in the bitmap; NULL if\n     *      none.  The reasons for this could be that they require some\n     *      condition such as the target string being or not being in UTF-8\n     *      (under /d), or because they came from a user-defined property that\n     *      was not resolved at the time of the regex compilation (under /u)\n     *  'only_utf8_locale_invlist' is an inversion list of the code points that\n     *      are valid only if the runtime locale is a UTF-8 one; NULL if none\n     *  'node' is the regex pattern node.  It is needed only when the above two\n     *      parameters are not null, and is passed so that this routine can\n     *      tease apart the various reasons for them.\n     *  'force_as_is_display' is TRUE if this routine should definitely NOT try\n     *      to invert things to see if that leads to a cleaner display.  If\n     *      FALSE, this routine is free to use its judgment about doing this.\n     *\n     * It returns TRUE if there was actually something output.  (It may be that\n     * the bitmap, etc is empty.)\n     *\n     * When called for outputting the bitmap of a non-ANYOF node, just pass the\n     * bitmap, with the succeeding parameters set to NULL, and the final one to\n     * FALSE.\n     */\n\n    /* In general, it tries to display the 'cleanest' representation of the\n     * innards, choosing whether to display them inverted or not, regardless of\n     * whether the class itself is to be inverted.  However,  there are some\n     * cases where it can't try inverting, as what actually matches isn't known\n     * until runtime, and hence the inversion isn't either. */\n    bool inverting_allowed = ! force_as_is_display;\n\n    int i;\n    STRLEN orig_sv_cur = SvCUR(sv);\n\n    SV* invlist;            /* Inversion list we accumulate of code points that\n                               are unconditionally matched */\n    SV* only_utf8 = NULL;   /* Under /d, list of matches iff the target is\n                               UTF-8 */\n    SV* not_utf8 =  NULL;   /* /d, list of matches iff the target isn't UTF-8\n                             */\n    SV* posixes = NULL;     /* Under /l, string of things like [:word:], \\D */\n    SV* only_utf8_locale = NULL;    /* Under /l, list of matches if the locale\n                                       is UTF-8 */\n\n    SV* as_is_display;      /* The output string when we take the inputs\n                               literally */\n    SV* inverted_display;   /* The output string when we invert the inputs */\n\n    U8 flags = (node) ? ANYOF_FLAGS(node) : 0;\n\n    bool invert = cBOOL(flags & ANYOF_INVERT);  /* Is the input to be inverted\n                                                   to match? */\n    /* We are biased in favor of displaying things without them being inverted,\n     * as that is generally easier to understand */\n    const int bias = 5;\n\n    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS;\n\n    /* Start off with whatever code points are passed in.  (We clone, so we\n     * don't change the caller's list) */\n    if (nonbitmap_invlist) {\n        assert(invlist_highest(nonbitmap_invlist) < NUM_ANYOF_CODE_POINTS);\n        invlist = invlist_clone(nonbitmap_invlist);\n    }\n    else {  /* Worst case size is every other code point is matched */\n        invlist = _new_invlist(NUM_ANYOF_CODE_POINTS / 2);\n    }\n\n    if (flags) {\n        if (OP(node) == ANYOFD) {\n\n            /* This flag indicates that the code points below 0x100 in the\n             * nonbitmap list are precisely the ones that match only when the\n             * target is UTF-8 (they should all be non-ASCII). */\n            if (flags & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)\n            {\n                _invlist_intersection(invlist, PL_UpperLatin1, &only_utf8);\n                _invlist_subtract(invlist, only_utf8, &invlist);\n            }\n\n            /* And this flag for matching all non-ASCII 0xFF and below */\n            if (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)\n            {\n                not_utf8 = invlist_clone(PL_UpperLatin1);\n            }\n        }\n        else if (OP(node) == ANYOFL) {\n\n            /* If either of these flags are set, what matches isn't\n             * determinable except during execution, so don't know enough here\n             * to invert */\n            if (flags & (ANYOFL_FOLD|ANYOF_MATCHES_POSIXL)) {\n                inverting_allowed = FALSE;\n            }\n\n            /* What the posix classes match also varies at runtime, so these\n             * will be output symbolically. */\n            if (ANYOF_POSIXL_TEST_ANY_SET(node)) {\n                int i;\n\n                posixes = newSVpvs(\"\");\n                for (i = 0; i < ANYOF_POSIXL_MAX; i++) {\n                    if (ANYOF_POSIXL_TEST(node,i)) {\n                        sv_catpv(posixes, anyofs[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    /* Accumulate the bit map into the unconditional match list */\n    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {\n        if (BITMAP_TEST(bitmap, i)) {\n            int start = i++;\n            for (; i < NUM_ANYOF_CODE_POINTS && BITMAP_TEST(bitmap, i); i++) {\n                /* empty */\n            }\n            invlist = _add_range_to_invlist(invlist, start, i-1);\n        }\n    }\n\n    /* Make sure that the conditional match lists don't have anything in them\n     * that match unconditionally; otherwise the output is quite confusing.\n     * This could happen if the code that populates these misses some\n     * duplication. */\n    if (only_utf8) {\n        _invlist_subtract(only_utf8, invlist, &only_utf8);\n    }\n    if (not_utf8) {\n        _invlist_subtract(not_utf8, invlist, &not_utf8);\n    }\n\n    if (only_utf8_locale_invlist) {\n\n        /* Since this list is passed in, we have to make a copy before\n         * modifying it */\n        only_utf8_locale = invlist_clone(only_utf8_locale_invlist);\n\n        _invlist_subtract(only_utf8_locale, invlist, &only_utf8_locale);\n\n        /* And, it can get really weird for us to try outputting an inverted\n         * form of this list when it has things above the bitmap, so don't even\n         * try */\n        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {\n            inverting_allowed = FALSE;\n        }\n    }\n\n    /* Calculate what the output would be if we take the input as-is */\n    as_is_display = put_charclass_bitmap_innards_common(invlist,\n                                                    posixes,\n                                                    only_utf8,\n                                                    not_utf8,\n                                                    only_utf8_locale,\n                                                    invert);\n\n    /* If have to take the output as-is, just do that */\n    if (! inverting_allowed) {\n        if (as_is_display) {\n            sv_catsv(sv, as_is_display);\n            SvREFCNT_dec_NN(as_is_display);\n        }\n    }\n    else { /* But otherwise, create the output again on the inverted input, and\n              use whichever version is shorter */\n\n        int inverted_bias, as_is_bias;\n\n        /* We will apply our bias to whichever of the the results doesn't have\n         * the '^' */\n        if (invert) {\n            invert = FALSE;\n            as_is_bias = bias;\n            inverted_bias = 0;\n        }\n        else {\n            invert = TRUE;\n            as_is_bias = 0;\n            inverted_bias = bias;\n        }\n\n        /* Now invert each of the lists that contribute to the output,\n         * excluding from the result things outside the possible range */\n\n        /* For the unconditional inversion list, we have to add in all the\n         * conditional code points, so that when inverted, they will be gone\n         * from it */\n        _invlist_union(only_utf8, invlist, &invlist);\n        _invlist_union(not_utf8, invlist, &invlist);\n        _invlist_union(only_utf8_locale, invlist, &invlist);\n        _invlist_invert(invlist);\n        _invlist_intersection(invlist, PL_InBitmap, &invlist);\n\n        if (only_utf8) {\n            _invlist_invert(only_utf8);\n            _invlist_intersection(only_utf8, PL_UpperLatin1, &only_utf8);\n        }\n        else if (not_utf8) {\n\n            /* If a code point matches iff the target string is not in UTF-8,\n             * then complementing the result has it not match iff not in UTF-8,\n             * which is the same thing as matching iff it is UTF-8. */\n            only_utf8 = not_utf8;\n            not_utf8 = NULL;\n        }\n\n        if (only_utf8_locale) {\n            _invlist_invert(only_utf8_locale);\n            _invlist_intersection(only_utf8_locale,\n                                  PL_InBitmap,\n                                  &only_utf8_locale);\n        }\n\n        inverted_display = put_charclass_bitmap_innards_common(\n                                            invlist,\n                                            posixes,\n                                            only_utf8,\n                                            not_utf8,\n                                            only_utf8_locale, invert);\n\n        /* Use the shortest representation, taking into account our bias\n         * against showing it inverted */\n        if (   inverted_display\n            && (   ! as_is_display\n                || (  SvCUR(inverted_display) + inverted_bias\n                    < SvCUR(as_is_display)    + as_is_bias)))\n        {\n\t    sv_catsv(sv, inverted_display);\n        }\n        else if (as_is_display) {\n\t    sv_catsv(sv, as_is_display);\n        }\n\n        SvREFCNT_dec(as_is_display);\n        SvREFCNT_dec(inverted_display);\n    }\n\n    SvREFCNT_dec_NN(invlist);\n    SvREFCNT_dec(only_utf8);\n    SvREFCNT_dec(not_utf8);\n    SvREFCNT_dec(posixes);\n    SvREFCNT_dec(only_utf8_locale);\n\n    return SvCUR(sv) > orig_sv_cur;\n}\n\n#define CLEAR_OPTSTART                                                       \\\n    if (optstart) STMT_START {                                               \\\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_                                           \\\n                              \" (%\" IVdf \" nodes)\\n\", (IV)(node - optstart))); \\\n        optstart=NULL;                                                       \\\n    } STMT_END\n\n#define DUMPUNTIL(b,e)                                                       \\\n                    CLEAR_OPTSTART;                                          \\\n                    node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);\n\nSTATIC const regnode *\nS_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node,\n\t    const regnode *last, const regnode *plast,\n\t    SV* sv, I32 indent, U32 depth)\n{\n    U8 op = PSEUDO;\t/* Arbitrary non-END op. */\n    const regnode *next;\n    const regnode *optstart= NULL;\n\n    RXi_GET_DECL(r,ri);\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_DUMPUNTIL;\n\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d : %d - %d - %d\\n\",indent,node-start,\n        last ? last-start : 0,plast ? plast-start : 0);\n#endif\n\n    if (plast && plast < last)\n        last= plast;\n\n    while (PL_regkind[op] != END && (!last || node < last)) {\n        assert(node);\n\t/* While that wasn't END last time... */\n\tNODE_ALIGN(node);\n\top = OP(node);\n\tif (op == CLOSE || op == WHILEM)\n\t    indent--;\n\tnext = regnext((regnode *)node);\n\n\t/* Where, what. */\n\tif (OP(node) == OPTIMIZED) {\n\t    if (!optstart && RE_DEBUG_FLAG(RE_DEBUG_COMPILE_OPTIMISE))\n\t        optstart = node;\n\t    else\n\t\tgoto after_print;\n\t} else\n\t    CLEAR_OPTSTART;\n\n        regprop(r, sv, node, NULL, NULL);\n        Perl_re_printf( aTHX_  \"%4\" IVdf \":%*s%s\", (IV)(node - start),\n\t\t      (int)(2*indent + 1), \"\", SvPVX_const(sv));\n\n        if (OP(node) != OPTIMIZED) {\n            if (next == NULL)\t\t/* Next ptr. */\n                Perl_re_printf( aTHX_  \" (0)\");\n            else if (PL_regkind[(U8)op] == BRANCH\n                     && PL_regkind[OP(next)] != BRANCH )\n                Perl_re_printf( aTHX_  \" (FAIL)\");\n            else\n                Perl_re_printf( aTHX_  \" (%\" IVdf \")\", (IV)(next - start));\n            Perl_re_printf( aTHX_ \"\\n\");\n        }\n\n      after_print:\n\tif (PL_regkind[(U8)op] == BRANCHJ) {\n\t    assert(next);\n\t    {\n                const regnode *nnode = (OP(next) == LONGJMP\n                                       ? regnext((regnode *)next)\n                                       : next);\n                if (last && nnode > last)\n                    nnode = last;\n                DUMPUNTIL(NEXTOPER(NEXTOPER(node)), nnode);\n\t    }\n\t}\n\telse if (PL_regkind[(U8)op] == BRANCH) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node), next);\n\t}\n\telse if ( PL_regkind[(U8)op]  == TRIE ) {\n\t    const regnode *this_trie = node;\n\t    const char op = OP(node);\n            const U32 n = ARG(node);\n\t    const reg_ac_data * const ac = op>=AHOCORASICK ?\n               (reg_ac_data *)ri->data->data[n] :\n               NULL;\n\t    const reg_trie_data * const trie =\n\t        (reg_trie_data*)ri->data->data[op<AHOCORASICK ? n : ac->trie];\n#ifdef DEBUGGING\n\t    AV *const trie_words\n                           = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);\n#endif\n\t    const regnode *nextbranch= NULL;\n\t    I32 word_idx;\n            SvPVCLEAR(sv);\n\t    for (word_idx= 0; word_idx < (I32)trie->wordcount; word_idx++) {\n\t\tSV ** const elem_ptr = av_fetch(trie_words,word_idx,0);\n\n                Perl_re_indentf( aTHX_  \"%s \",\n                    indent+3,\n                    elem_ptr\n                    ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr),\n                                SvCUR(*elem_ptr), PL_dump_re_max_len,\n                                PL_colors[0], PL_colors[1],\n                                (SvUTF8(*elem_ptr)\n                                 ? PERL_PV_ESCAPE_UNI\n                                 : 0)\n                                | PERL_PV_PRETTY_ELLIPSES\n                                | PERL_PV_PRETTY_LTGT\n                            )\n                    : \"???\"\n                );\n                if (trie->jump) {\n                    U16 dist= trie->jump[word_idx+1];\n                    Perl_re_printf( aTHX_  \"(%\" UVuf \")\\n\",\n                               (UV)((dist ? this_trie + dist : next) - start));\n                    if (dist) {\n                        if (!nextbranch)\n                            nextbranch= this_trie + trie->jump[0];\n\t\t\tDUMPUNTIL(this_trie + dist, nextbranch);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode *)nextbranch);\n                } else {\n                    Perl_re_printf( aTHX_  \"\\n\");\n\t\t}\n\t    }\n\t    if (last && next > last)\n\t        node= last;\n\t    else\n\t        node= next;\n\t}\n\telse if ( op == CURLY ) {   /* \"next\" might be very big: optimizer */\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS,\n                    NEXTOPER(node) + EXTRA_STEP_2ARGS + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {\n\t    assert(next);\n\t    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS, next);\n\t}\n\telse if ( op == PLUS || op == STAR) {\n\t    DUMPUNTIL(NEXTOPER(node), NEXTOPER(node) + 1);\n\t}\n\telse if (PL_regkind[(U8)op] == ANYOF) {\n\t    /* arglen 1 + class block */\n\t    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_MATCHES_POSIXL)\n                          ? ANYOF_POSIXL_SKIP\n                          : ANYOF_SKIP);\n\t    node = NEXTOPER(node);\n\t}\n\telse if (PL_regkind[(U8)op] == EXACT) {\n            /* Literal string, where present. */\n\t    node += NODE_SZ_STR(node) - 1;\n\t    node = NEXTOPER(node);\n\t}\n\telse {\n\t    node = NEXTOPER(node);\n\t    node += regarglen[(U8)op];\n\t}\n\tif (op == CURLYX || op == OPEN)\n\t    indent++;\n    }\n    CLEAR_OPTSTART;\n#ifdef DEBUG_DUMPUNTIL\n    Perl_re_printf( aTHX_  \"--- %d\\n\", (int)indent);\n#endif\n    return node;\n}\n\n#endif\t/* DEBUGGING */\n\n/*\n * ex: set ts=8 sts=4 sw=4 et:\n */\n", "  regcomp.c\tThese tests have been moved to t/re/reg_mesg.t\n\t\texcept for those that explicitly test line numbers\n                and those that don't have a <-- HERE in them, and those that\n                die plus have warnings, or otherwise require special handling\n\n__END__\nuse warnings 'regexp';\n$r=qr/(??{ q\"\\\\b+\" })/;\n\"a\" =~ /a$r/; # warning should come from this line\nEXPECT\n\\b+ matches null string many times in regex; marked by <-- HERE in m/\\b+ <-- HERE / at - line 3.\n########\n# regcomp.c\nuse warnings 'digit' ;\nmy $a = qr/\\o{1238456}\\x{100}/;\nmy $a = qr/[\\o{6548321}]\\x{100}/;\nno warnings 'digit' ;\nmy $a = qr/\\o{1238456}\\x{100}/;\nmy $a = qr/[\\o{6548321}]\\x{100}/;\nEXPECT\nNon-octal character '8'.  Resolved as \"\\o{123}\" at - line 3.\nNon-octal character '8'.  Resolved as \"\\o{654}\" at - line 4.\n########\n# regcomp.c\nBEGIN {\n    if (ord('A') == 193) {\n        print \"SKIPPED\\n# Different results on EBCDIC\";\n        exit 0;\n    }\n}\nuse warnings;\n$a = qr/\\c,/;\n$a = qr/[\\c,]/;\nno warnings 'syntax';\n$a = qr/\\c,/;\n$a = qr/[\\c,]/;\nEXPECT\n\"\\c,\" is more clearly written simply as \"l\" at - line 9.\n\"\\c,\" is more clearly written simply as \"l\" at - line 10.\n########\n# This is because currently a different error is output under\n# use re 'strict', so can't go in reg_mesg.t\n# NAME perl #126261, error message causes segfault\n# OPTION fatal\n qr/abc[\\x{df}[.00./i\nEXPECT\nUnmatched [ in regex; marked by <-- HERE in m/abc[ <-- HERE \\x{df}[.00./ at - line 4.\n########\n# NAME perl #126261, with 'use utf8'\n# OPTION fatal\nuse utf8;\nno warnings 'utf8';\nqr/abc[\ufb01[.00./i;\nEXPECT\nUnmatched [ in regex; marked by <-- HERE in m/abc[ <-- HERE \ufb01[.00./ at - line 4.\n########\n# NAME perl qr/(?[[[:word]]])/ XXX Why is 'syntax' lc?\n# OPTION fatal\nqr/(?[[[:word]]])/;\nEXPECT\nAssuming NOT a POSIX class since there is no terminating ':' in regex; marked by <-- HERE in m/(?[[[:word <-- HERE ]]])/ at - line 2.\nUnexpected ']' with no following ')' in (?[... in regex; marked by <-- HERE in m/(?[[[:word]] <-- HERE ])/ at - line 2.\n########\n# NAME qr/(?[ [[:digit: ])/\n# OPTION fatal\nqr/(?[[[:digit: ])/;\nEXPECT\nAssuming NOT a POSIX class since no blanks are allowed in one in regex; marked by <-- HERE in m/(?[[[:digit: ] <-- HERE )/ at - line 2.\nsyntax error in (?[...]) in regex; marked by <-- HERE in m/(?[[[:digit: ]) <-- HERE / at - line 2.\n########\n# NAME qr/(?[ [:digit: ])/\n# OPTION fatal\nqr/(?[[:digit: ])/\nEXPECT\nAssuming NOT a POSIX class since no blanks are allowed in one in regex; marked by <-- HERE in m/(?[[:digit: ] <-- HERE )/ at - line 2.\nsyntax error in (?[...]) in regex; marked by <-- HERE in m/(?[[:digit: ]) <-- HERE / at - line 2.\n########\n# NAME [perl #126141]\n# OPTION fatal\neval {/$_/}, print \"$_ ==> \", $@ || \"OK!\\n\" for \"]]]]]]]]][\\\\\", \"]]]]][\\\\\"\nEXPECT\n]]]]]]]]][\\ ==> Unmatched [ in regex; marked by <-- HERE in m/]]]]]]]]][\\ <-- HERE / at - line 2.\n]]]]][\\ ==> Unmatched [ in regex; marked by <-- HERE in m/]]]]][\\ <-- HERE / at - line 2.\n########\n# NAME [perl #123417]\n# OPTION fatal\nqr/[\\N{}]/;\nEXPECT\nUnknown charname '' at - line 2, within pattern\nExecution of - aborted due to compilation errors.\n########\n# NAME [perl #123417]\n# OPTION fatal\nqr/\\N{}/;\nEXPECT\nUnknown charname '' at - line 2, within pattern\nExecution of - aborted due to compilation errors.\n########\n# NAME [perl #131868]\nuse warnings;\nmy $qr = qr {\n    (?(DEFINE)\n      (?<digit>   [0-9])\n      (?<digits>  (?&digit){4})\n    )\n    ^(?&digits)$\n}x;\nEXPECT\n########\n", "#!./perl -w\n\n$|=1;   # outherwise things get mixed up in output\n\nBEGIN {\n\tchdir 't' if -d 't';\n\trequire './test.pl';\n    set_up_inc( qw '../lib ../ext/re' );\n\teval 'require Config'; # assume defaults if this fails\n}\n\nskip_all_without_unicode_tables();\n\nuse strict;\nuse open qw(:utf8 :std);\n\n# Kind of a kludge to mark warnings to be expected only if we are testing\n# under \"use re 'strict'\"\nmy $only_strict_marker = ':expected_only_under_strict';\n\n## If the markers used are changed (search for \"MARKER1\" in regcomp.c),\n## update only these two regexs, and leave the {#} in the @death/@warning\n## arrays below. The {#} is a meta-marker -- it marks where the marker should\n## go.\n\nsub fixup_expect ($$) {\n\n    # Fixes up the expected results by inserting the boiler plate text.\n    # Returns empty string if that is what is expected.  Otherwise, handles\n    # either a scalar, turning it into a single element array; or a ref to an\n    # array, adjusting each element.  If called in array context, returns an\n    # array, otherwise the join of all elements.\n\n    # The string $only_strict_marker will be removed from any expect line it\n    # begins, and if $strict is not true, that expect line will be removed\n    # from the output (hence won't be expected)\n\n    my ($expect_ref, $strict) = @_;\n    return \"\" if $expect_ref eq \"\";\n\n    my @expect;\n    if (ref $expect_ref) {\n        @expect = @$expect_ref;\n    }\n    else {\n        @expect = $expect_ref;\n    }\n\n    my @new_expect;\n    foreach my $element (@expect) {\n        $element =~ s/\\{\\#\\}/in regex; marked by <-- HERE in/;\n        $element =~ s/\\{\\#\\}/ <-- HERE /;\n        $element .= \" at \";\n        next if $element =~ s/ ^ $only_strict_marker \\s* //x && ! $strict;\n        push @new_expect, $element;\n    }\n    return wantarray ? @new_expect : join \"\", @new_expect;\n}\n\nsub add_markers {\n    my ($element)= @_;\n    $element =~ s/ at .* line \\d+\\.?\\n$//;\n    $element =~ s/in regex; marked by <-- HERE in/{#}/;\n    $element =~ s/ <-- HERE /{#}/;\n    return $element;\n}\n\nsub _qq {\n    my ($str)= @_;\n    $str =~ s/\\\\/\\\\\\\\/g;\n    $str =~ s/\\$/\\\\\\$/g;\n    return qq(\"$str\");\n}\n\n\n## Because we don't \"use utf8\" in this file, we need to do some extra legwork\n## for the utf8 tests: Prepend 'use utf8' to the pattern, and mark the strings\n## to check against as UTF-8, but for this all to work properly, the character\n## '\u30cd' (U+30CD) is required in each pattern somewhere as a marker.\n##\n## This also creates a second variant of the tests to check if the\n## latin1 error messages are working correctly.  Because we don't 'use utf8',\n## we can't tell if something is UTF-8 or Latin1, so you need the suffix\n## '; no latin1' to not have the second variant.\nmy $l1   = \"\\x{ef}\";\nmy $utf8 = \"\\x{30cd}\";\nutf8::encode($utf8);\n\nsub mark_as_utf8 {\n    my @ret;\n    for (my $i = 0; $i < @_; $i += 2) {\n        my $pat = $_[$i];\n        my $msg = $_[$i+1];\n        my $l1_pat = $pat =~ s/$utf8/$l1/gr;\n        my $l1_msg;\n        $pat = \"use utf8; $pat\";\n\n        if (ref $msg) {\n            $l1_msg = [ map { s/$utf8/$l1/gr } @$msg ];\n            @$msg   = map { my $c = $_; utf8::decode($c); $c } @$msg;\n        }\n        else {\n            $l1_msg = $msg =~ s/$utf8/$l1/gr;\n            utf8::decode($msg);\n        }\n        push @ret, $pat => $msg;\n\n        push @ret, $l1_pat => $l1_msg unless $l1_pat =~ /#no latin1/;\n    }\n    return @ret;\n}\n\nmy $inf_m1 = ($Config::Config{reg_infty} || 32767) - 1;\nmy $inf_p1 = $inf_m1 + 2;\n\nmy $B_hex = sprintf(\"\\\\x%02X\", ord \"B\");\nmy $low_mixed_alpha = ('A' lt 'a') ? 'A' : 'a';\nmy $high_mixed_alpha = ('A' lt 'a') ? 'a' : 'A';\nmy $low_mixed_digit = ('A' lt '0') ? 'A' : '0';\nmy $high_mixed_digit = ('A' lt '0') ? '0' : 'A';\n\nmy $colon_hex = sprintf \"%02X\", ord(\":\");\nmy $tab_hex = sprintf \"%02X\", ord(\"\\t\");\n\n# Key-value pairs of strings eval'd as patterns => warn/error messages that\n# they should generate.  In some cases, the value is an array of multiple\n# messages.  Some groups have the message(s) be default on; others, default\n# off.  This can be overridden on an individual key basis by preceding the\n# pattern string with either 'default_on' or 'default_off'\n#\n# The first set are those that should be fatal errors.\n\nmy @death =\n(\n '/[[=foo=]]/' => 'POSIX syntax [= =] is reserved for future extensions {#} m/[[=foo=]{#}]/',\n\n '/(?<= .*)/' =>  'Variable length lookbehind not implemented in regex m/(?<= .*)/',\n\n '/(?<= x{1000})/' => 'Lookbehind longer than 255 not implemented in regex m/(?<= x{1000})/',\n\n '/(?@)/' => 'Sequence (?@...) not implemented {#} m/(?@{#})/',\n\n '/(?{ 1/' => 'Missing right curly or square bracket',\n\n '/(?(1x))/' => 'Switch condition not recognized {#} m/(?(1x{#}))/',\n '/(?(1x(?#)))/'=> 'Switch condition not recognized {#} m/(?(1x{#}(?#)))/',\n\n '/(?(1)/'    => 'Switch (?(condition)... not terminated {#} m/(?(1){#}/',\n '/(?(1)x/'    => 'Switch (?(condition)... not terminated {#} m/(?(1)x{#}/',\n '/(?(1)x|y/'    => 'Switch (?(condition)... not terminated {#} m/(?(1)x|y{#}/',\n '/(?(1)x|y|z)/' => 'Switch (?(condition)... contains too many branches {#} m/(?(1)x|y|{#}z)/',\n\n '/(?(x)y|x)/' => 'Unknown switch condition (?(...)) {#} m/(?(x{#})y|x)/',\n '/(?(??{}))/' => 'Unknown switch condition (?(...)) {#} m/(?(?{#}?{}))/',\n '/(?(?[]))/' => 'Unknown switch condition (?(...)) {#} m/(?(?{#}[]))/',\n\n '/(?/' => 'Sequence (? incomplete {#} m/(?{#}/',\n\n '/(?;x/' => 'Sequence (?;...) not recognized {#} m/(?;{#}x/',\n '/(?<;x/' => 'Group name must start with a non-digit word character {#} m/(?<;{#}x/',\n '/(?\\ix/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}ix/',\n '/(?\\mx/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}mx/',\n '/(?\\:x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}:x/',\n '/(?\\=x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}=x/',\n '/(?\\!x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}!x/',\n '/(?\\<=x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}<=x/',\n '/(?\\<!x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}<!x/',\n '/(?\\>x/' => 'Sequence (?\\...) not recognized {#} m/(?\\{#}>x/',\n '/(?^-i:foo)/' => 'Sequence (?^-...) not recognized {#} m/(?^-{#}i:foo)/',\n '/(?^-i)foo/' => 'Sequence (?^-...) not recognized {#} m/(?^-{#}i)foo/',\n '/(?^d:foo)/' => 'Sequence (?^d...) not recognized {#} m/(?^d{#}:foo)/',\n '/(?^d)foo/' => 'Sequence (?^d...) not recognized {#} m/(?^d{#})foo/',\n '/(?^lu:foo)/' => 'Regexp modifiers \"l\" and \"u\" are mutually exclusive {#} m/(?^lu{#}:foo)/',\n '/(?^lu)foo/' => 'Regexp modifiers \"l\" and \"u\" are mutually exclusive {#} m/(?^lu{#})foo/',\n'/(?da:foo)/' => 'Regexp modifiers \"d\" and \"a\" are mutually exclusive {#} m/(?da{#}:foo)/',\n'/(?lil:foo)/' => 'Regexp modifier \"l\" may not appear twice {#} m/(?lil{#}:foo)/',\n'/(?aaia:foo)/' => 'Regexp modifier \"a\" may appear a maximum of twice {#} m/(?aaia{#}:foo)/',\n'/(?i-l:foo)/' => 'Regexp modifier \"l\" may not appear after the \"-\" {#} m/(?i-l{#}:foo)/',\n\n '/((x)/' => 'Unmatched ( {#} m/({#}(x)/',\n '/{(}/' => 'Unmatched ( {#} m/{({#}}/',    # [perl #127599]\n\n \"/x{$inf_p1}/\" => \"Quantifier in {,} bigger than $inf_m1 {#} m/x{{#}$inf_p1}/\",\n\n\n '/x**/' => 'Nested quantifiers {#} m/x**{#}/',\n\n '/x[/' => 'Unmatched [ {#} m/x[{#}/',\n\n '/*/', => 'Quantifier follows nothing {#} m/*{#}/',\n\n '/\\p{x/' => 'Missing right brace on \\p{} {#} m/\\p{{#}x/',\n\n '/[\\p{x]/' => 'Missing right brace on \\p{} {#} m/[\\p{{#}x]/',\n\n '/(x)\\2/' => 'Reference to nonexistent group {#} m/(x)\\2{#}/',\n\n '/\\g/' => 'Unterminated \\g... pattern {#} m/\\g{#}/',\n '/\\g{1/' => 'Unterminated \\g{...} pattern {#} m/\\g{1{#}/',\n\n 'my $m = \"\\\\\\\"; $m =~ $m', => 'Trailing \\ in regex m/\\/',\n\n '/\\x{1/' => 'Missing right brace on \\x{} {#} m/\\x{1{#}/',\n '/\\x{X/' => 'Missing right brace on \\x{} {#} m/\\x{{#}X/',\n\n '/[\\x{X]/' => 'Missing right brace on \\x{} {#} m/[\\x{{#}X]/',\n '/[\\x{A]/' => 'Missing right brace on \\x{} {#} m/[\\x{A{#}]/',\n\n '/\\o{1/' => 'Missing right brace on \\o{ {#} m/\\o{1{#}/',\n '/\\o{X/' => 'Missing right brace on \\o{ {#} m/\\o{{#}X/',\n\n '/[\\o{X]/' => 'Missing right brace on \\o{ {#} m/[\\o{{#}X]/',\n '/[\\o{7]/' => 'Missing right brace on \\o{ {#} m/[\\o{7{#}]/',\n\n '/[[:barf:]]/' => 'POSIX class [:barf:] unknown {#} m/[[:barf:]{#}]/',\n\n '/[[=barf=]]/' => 'POSIX syntax [= =] is reserved for future extensions {#} m/[[=barf=]{#}]/',\n\n '/[[.barf.]]/' => 'POSIX syntax [. .] is reserved for future extensions {#} m/[[.barf.]{#}]/',\n\n '/[z-a]/' => 'Invalid [] range \"z-a\" {#} m/[z-a{#}]/',\n\n '/\\p/' => 'Empty \\p {#} m/\\p{#}/',\n '/\\P/' => 'Empty \\P {#} m/\\P{#}/',\n '/\\p{}/' => 'Empty \\p{} {#} m/\\p{{#}}/',\n '/\\P{}/' => 'Empty \\P{} {#} m/\\P{{#}}/',\n\n'/a\\b{cde/' => 'Missing right brace on \\b{} {#} m/a\\b{{#}cde/',\n'/a\\B{cde/' => 'Missing right brace on \\B{} {#} m/a\\B{{#}cde/',\n\n '/\\b{}/' => 'Empty \\b{} {#} m/\\b{}{#}/',\n '/\\B{}/' => 'Empty \\B{} {#} m/\\B{}{#}/',\n\n '/\\b{gc}/' => \"'gc' is an unknown bound type {#} m/\\\\b{gc{#}}/\",\n '/\\B{gc}/' => \"'gc' is an unknown bound type {#} m/\\\\B{gc{#}}/\",\n\n\n '/(?[[[::]]])/' => \"Unexpected ']' with no following ')' in (?[... {#} m/(?[[[::]]{#}])/\",\n '/(?[[[:w:]]])/' => \"Unexpected ']' with no following ')' in (?[... {#} m/(?[[[:w:]]{#}])/\",\n '/(?[[:w:]])/' => \"\",\n '/([.].*)[.]/'   => \"\",    # [perl #127582]\n '/[.].*[.]/'     => \"\",    # [perl #127604]\n '/(?[a])/' =>  'Unexpected character {#} m/(?[a{#}])/',\n '/(?[ + \\t ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/(?[ +{#} \\t ])/',\n '/(?[ \\cK - ( + \\t ) ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/(?[ \\cK - ( +{#} \\t ) ])/',\n '/(?[ \\cK ( \\t ) ])/' => 'Unexpected \\'(\\' with no preceding operator {#} m/(?[ \\cK ({#} \\t ) ])/',\n '/(?[ \\cK \\t ])/' => 'Operand with no preceding operator {#} m/(?[ \\cK \\t{#} ])/',\n '/(?[ \\0004 ])/' => 'Need exactly 3 octal digits {#} m/(?[ \\0004 {#}])/',\n '/(?[ \\05 ])/' => 'Need exactly 3 octal digits {#} m/(?[ \\05 {#}])/',\n '/(?[ \\o{1038} ])/' => 'Non-octal character {#} m/(?[ \\o{1038{#}} ])/',\n '/(?[ \\o{} ])/' => 'Number with no digits {#} m/(?[ \\o{}{#} ])/',\n '/(?[ \\x{defg} ])/' => 'Non-hex character {#} m/(?[ \\x{defg{#}} ])/',\n '/(?[ \\xabcdef ])/' => 'Use \\\\x{...} for more than two hex characters {#} m/(?[ \\xabc{#}def ])/',\n '/(?[ \\x{} ])/' => 'Number with no digits {#} m/(?[ \\x{}{#} ])/',\n '/(?[ \\cK + ) ])/' => 'Unexpected \\')\\' {#} m/(?[ \\cK + ){#} ])/',\n '/(?[ \\cK + ])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[ \\cK + {#}])/',\n '/(?[ ( ) ])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[ ( ){#} ])/',\n '/(?[[0]+()+])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[[0]+(){#}+])/',\n '/(?[ \\p{foo} ])/' => 'Can\\'t find Unicode property definition \"foo\" {#} m/(?[ \\p{foo}{#} ])/',\n '/(?[ \\p{ foo = bar } ])/' => 'Can\\'t find Unicode property definition \"foo = bar\" {#} m/(?[ \\p{ foo = bar }{#} ])/',\n '/(?[ \\8 ])/' => 'Unrecognized escape \\8 in character class {#} m/(?[ \\8{#} ])/',\n '/(?[ \\t ]/' => \"Unexpected ']' with no following ')' in (?[... {#} m/(?[ \\\\t ]{#}/\",\n '/(?[ [ \\t ]/' => \"Syntax error in (?[...]) {#} m/(?[ [ \\\\t ]{#}/\",\n '/(?[ \\t ] ]/' => \"Unexpected ']' with no following ')' in (?[... {#} m/(?[ \\\\t ]{#} ]/\",\n '/(?[ [ ] ]/' => \"Syntax error in (?[...]) {#} m/(?[ [ ] ]{#}/\",\n '/(?[ \\t + \\e # This was supposed to be a comment ])/' =>\n    \"Syntax error in (?[...]) {#} m/(?[ \\\\t + \\\\e # This was supposed to be a comment ]){#}/\",\n '/(?[ ])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[ {#}])/',\n 'm/(?[[a-\\d]])/' => 'False [] range \"a-\\d\" {#} m/(?[[a-\\d{#}]])/',\n 'm/(?[[\\w-x]])/' => 'False [] range \"\\w-\" {#} m/(?[[\\w-{#}x]])/',\n 'm/(?[[a-\\pM]])/' => 'False [] range \"a-\\pM\" {#} m/(?[[a-\\pM{#}]])/',\n 'm/(?[[\\pM-x]])/' => 'False [] range \"\\pM-\" {#} m/(?[[\\pM-{#}x]])/',\n 'm/(?[[^\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}]])/' => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/(?[[^\\N{U+100.300{#}}]])/',\n 'm/(?[ \\p{Digit} & (?(?[ \\p{Thai} | \\p{Lao} ]))])/' => 'Sequence (?(...) not recognized {#} m/(?[ \\p{Digit} & (?({#}?[ \\p{Thai} | \\p{Lao} ]))])/',\n 'm/(?[ \\p{Digit} & (?:(?[ \\p{Thai} | \\p{Lao} ]))])/' => 'Expecting \\'(?flags:(?[...\\' {#} m/(?[ \\p{Digit} & (?{#}:(?[ \\p{Thai} | \\p{Lao} ]))])/',\n 'm/\\o{/' => 'Missing right brace on \\o{ {#} m/\\o{{#}/',\n 'm/\\o/' => 'Missing braces on \\o{} {#} m/\\o{#}/',\n 'm/\\o{}/' => 'Number with no digits {#} m/\\o{}{#}/',\n 'm/[\\o{]/' => 'Missing right brace on \\o{ {#} m/[\\o{{#}]/',\n 'm/[\\o]/' => 'Missing braces on \\o{} {#} m/[\\o{#}]/',\n 'm/[\\o{}]/' => 'Number with no digits {#} m/[\\o{}{#}]/',\n 'm/(?^-i:foo)/' => 'Sequence (?^-...) not recognized {#} m/(?^-{#}i:foo)/',\n 'm/\\87/' => 'Reference to nonexistent group {#} m/\\87{#}/',\n 'm/a\\87/' => 'Reference to nonexistent group {#} m/a\\87{#}/',\n 'm/a\\97/' => 'Reference to nonexistent group {#} m/a\\97{#}/',\n 'm/(*DOOF)/' => 'Unknown verb pattern \\'DOOF\\' {#} m/(*DOOF){#}/',\n 'm/(?&a/'  => 'Sequence (?&... not terminated {#} m/(?&a{#}/',\n 'm/(?P=/' => 'Sequence ?P=... not terminated {#} m/(?P={#}/',\n \"m/(?'/\"  => \"Sequence (?'... not terminated {#} m/(?'{#}/\",\n \"m/(?</\"  => \"Sequence (?<... not terminated {#} m/(?<{#}/\",\n 'm/(?&/'  => 'Sequence (?&... not terminated {#} m/(?&{#}/',\n 'm/(?(</' => 'Sequence (?(<... not terminated {#} m/(?(<{#}/',\n \"m/(?('/\" => \"Sequence (?('... not terminated {#} m/(?('{#}/\",\n 'm/\\g{/'  => 'Sequence \\g{... not terminated {#} m/\\g{{#}/',\n 'm/\\k</'  => 'Sequence \\k<... not terminated {#} m/\\k<{#}/',\n 'm/\\c\u00df/' => \"Character following \\\"\\\\c\\\" must be printable ASCII\",\n '/((?# This is a comment in the middle of a token)?:foo)/' => 'In \\'(?...)\\', the \\'(\\' and \\'?\\' must be adjacent {#} m/((?# This is a comment in the middle of a token)?{#}:foo)/',\n '/((?# This is a comment in the middle of a token)*FAIL)/' => 'In \\'(*VERB...)\\', the \\'(\\' and \\'*\\' must be adjacent {#} m/((?# This is a comment in the middle of a token)*{#}FAIL)/',\n '/(?[\\ &!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ &!{#}])/',    # [perl #126180]\n '/(?[\\ +!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ +!{#}])/',    # [perl #126180]\n '/(?[\\ -!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ -!{#}])/',    # [perl #126180]\n '/(?[\\ ^!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ ^!{#}])/',    # [perl #126180]\n '/(?[\\ |!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[\\ |!{#}])/',    # [perl #126180]\n '/(?[()-!])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[(){#}-!])/',    # [perl #126204]\n '/(?[!()])/' => 'Incomplete expression within \\'(?[ ])\\' {#} m/(?[!(){#}])/',      # [perl #126404]\n '/\\w{/' => 'Unescaped left brace in regex is illegal here {#} m/\\w{{#}/',\n '/\\q{/' => 'Unescaped left brace in regex is illegal here {#} m/\\q{{#}/',\n '/\\A{/' => 'Unescaped left brace in regex is illegal here {#} m/\\A{{#}/',\n '/abc/xix' => \"\",\n '/(?xmsixp:abc)/' => \"\",\n '/(?xmsixp)abc/' => \"\",\n '/(?xxxx:abc)/' => \"\",\n '/(?<=/' => 'Sequence (?... not terminated {#} m/(?<={#}/',                        # [perl #128170]\n\n);\n\n# These are messages that are warnings when not strict; death under 'use re\n# \"strict\".  See comment before @warnings as to why some have a \\x{100} in\n# them.  This array has 3 elements per construct.  [0] is the regex to use;\n# [1] is the message under no strict, and [2] is under strict.\nmy @death_only_under_strict = (\n    'm/\\xABC/' => \"\",\n               => 'Use \\x{...} for more than two hex characters {#} m/\\xABC{#}/',\n    'm/[\\xABC]/' => \"\",\n                 => 'Use \\x{...} for more than two hex characters {#} m/[\\xABC{#}]/',\n\n    # XXX This is a confusing error message.  The G isn't ignored; it just\n    # terminates the \\x.  Also some messages below are missing the <-- HERE,\n    # aren't all category 'regexp'.  (Hence we have to turn off 'digit'\n    # messages as well below)\n    'm/\\xAG/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n              => 'Non-hex character {#} m/\\xAG{#}/',\n    'm/[\\xAG]/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n                => 'Non-hex character {#} m/[\\xAG{#}]/',\n    'm/\\o{789}/' => 'Non-octal character \\'8\\'.  Resolved as \"\\o{7}\"',\n                 => 'Non-octal character {#} m/\\o{78{#}9}/',\n    'm/[\\o{789}]/' => 'Non-octal character \\'8\\'.  Resolved as \"\\o{7}\"',\n                   => 'Non-octal character {#} m/[\\o{78{#}9}]/',\n    'm/\\x{}/' => \"\",\n              => 'Number with no digits {#} m/\\x{}{#}/',\n    'm/[\\x{}]/' => \"\",\n                => 'Number with no digits {#} m/[\\x{}{#}]/',\n    'm/\\x{ABCDEFG}/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n                     => 'Non-hex character {#} m/\\x{ABCDEFG{#}}/',\n    'm/[\\x{ABCDEFG}]/' => 'Illegal hexadecimal digit \\'G\\' ignored',\n                       => 'Non-hex character {#} m/[\\x{ABCDEFG{#}}]/',\n    \"m'[\\\\y]\\\\x{100}'\" => 'Unrecognized escape \\y in character class passed through {#} m/[\\y{#}]\\x{100}/',\n                       => 'Unrecognized escape \\y in character class {#} m/[\\y{#}]\\x{100}/',\n    'm/[a-\\d]\\x{100}/' => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n                       => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n    'm/[\\w-x]\\x{100}/' => 'False [] range \"\\w-\" {#} m/[\\w-{#}x]\\x{100}/',\n                       => 'False [] range \"\\w-\" {#} m/[\\w-{#}x]\\x{100}/',\n    'm/[a-\\pM]\\x{100}/' => 'False [] range \"a-\\pM\" {#} m/[a-\\pM{#}]\\x{100}/',\n                        => 'False [] range \"a-\\pM\" {#} m/[a-\\pM{#}]\\x{100}/',\n    'm/[\\pM-x]\\x{100}/' => 'False [] range \"\\pM-\" {#} m/[\\pM-{#}x]\\x{100}/',\n                        => 'False [] range \"\\pM-\" {#} m/[\\pM-{#}x]\\x{100}/',\n    'm/[^\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}]/' => 'Using just the first character returned by \\N{} in character class {#} m/[^\\N{U+100.300}{#}]/',\n                                       => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/[^\\N{U+100.300{#}}]/',\n    'm/[\\x03-\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}]/' => 'Using just the first character returned by \\N{} in character class {#} m/[\\x03-\\N{U+100.300}{#}]/',\n                                            => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/[\\x03-\\N{U+100.300{#}}]/',\n    'm/[\\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}-\\x{10FFFF}]/' => 'Using just the first character returned by \\N{} in character class {#} m/[\\N{U+100.300}{#}-\\x{10FFFF}]/',\n                                                  => '\\N{} in inverted character class or as a range end-point is restricted to one character {#} m/[\\N{U+100.300{#}}-\\x{10FFFF}]/',\n    '/[\\08]/'   => '\\'\\08\\' resolved to \\'\\o{0}8\\' {#} m/[\\08{#}]/',\n                => 'Need exactly 3 octal digits {#} m/[\\08{#}]/',\n    '/[\\018]/'  => '\\'\\018\\' resolved to \\'\\o{1}8\\' {#} m/[\\018{#}]/',\n                => 'Need exactly 3 octal digits {#} m/[\\018{#}]/',\n    '/[\\_\\0]/'  => \"\",\n                => 'Need exactly 3 octal digits {#} m/[\\_\\0]{#}/',\n    '/[\\07]/'   => \"\",\n                => 'Need exactly 3 octal digits {#} m/[\\07]{#}/',\n    '/[\\0005]/' => \"\",\n                => 'Need exactly 3 octal digits {#} m/[\\0005]{#}/',\n    '/[\\8\\9]\\x{100}/' => ['Unrecognized escape \\8 in character class passed through {#} m/[\\8{#}\\9]\\x{100}/',\n                          'Unrecognized escape \\9 in character class passed through {#} m/[\\8\\9{#}]\\x{100}/',\n                         ],\n                      => 'Unrecognized escape \\8 in character class {#} m/[\\8{#}\\9]\\x{100}/',\n    '/[a-\\d]\\x{100}/' => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n                      => 'False [] range \"a-\\d\" {#} m/[a-\\d{#}]\\x{100}/',\n    '/[\\d-b]\\x{100}/' => 'False [] range \"\\d-\" {#} m/[\\d-{#}b]\\x{100}/',\n                      => 'False [] range \"\\d-\" {#} m/[\\d-{#}b]\\x{100}/',\n    '/[\\s-\\d]\\x{100}/' => 'False [] range \"\\s-\" {#} m/[\\s-{#}\\d]\\x{100}/',\n                       => 'False [] range \"\\s-\" {#} m/[\\s-{#}\\d]\\x{100}/',\n    '/[\\d-\\s]\\x{100}/' => 'False [] range \"\\d-\" {#} m/[\\d-{#}\\s]\\x{100}/',\n                       => 'False [] range \"\\d-\" {#} m/[\\d-{#}\\s]\\x{100}/',\n    '/[a-[:digit:]]\\x{100}/' => 'False [] range \"a-[:digit:]\" {#} m/[a-[:digit:]{#}]\\x{100}/',\n                             => 'False [] range \"a-[:digit:]\" {#} m/[a-[:digit:]{#}]\\x{100}/',\n    '/[[:digit:]-b]\\x{100}/' => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}b]\\x{100}/',\n                             => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}b]\\x{100}/',\n    '/[[:alpha:]-[:digit:]]\\x{100}/' => 'False [] range \"[:alpha:]-\" {#} m/[[:alpha:]-{#}[:digit:]]\\x{100}/',\n                                     => 'False [] range \"[:alpha:]-\" {#} m/[[:alpha:]-{#}[:digit:]]\\x{100}/',\n    '/[[:digit:]-[:alpha:]]\\x{100}/' => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}[:alpha:]]\\x{100}/',\n                                     => 'False [] range \"[:digit:]-\" {#} m/[[:digit:]-{#}[:alpha:]]\\x{100}/',\n    '/[a\\zb]\\x{100}/' => 'Unrecognized escape \\z in character class passed through {#} m/[a\\z{#}b]\\x{100}/',\n                      => 'Unrecognized escape \\z in character class {#} m/[a\\z{#}b]\\x{100}/',\n    'default_on/:{4,a}/'     => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/:{{#}4,a}/',\n                             => 'Unescaped left brace in regex is illegal here {#} m/:{{#}4,a}/',\n    'default_on/xa{3\\,4}y/'  => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/xa{{#}3\\,4}y/',\n                             => 'Unescaped left brace in regex is illegal here {#} m/xa{{#}3\\,4}y/',\n  'default_on/\\\\${[^\\\\}]*}/' => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/\\\\${{#}[^\\\\}]*}/',\n                             => 'Unescaped left brace in regex is illegal here {#} m/\\\\${{#}[^\\\\}]*}/',\n);\n\n# These need the character '\u30cd' as a marker for mark_as_utf8()\nmy @death_utf8 = mark_as_utf8(\n '/\u30cd(?<= .*)/' =>  'Variable length lookbehind not implemented in regex m/\u30cd(?<= .*)/',\n\n '/(?<= \u30cd{1000})/' => 'Lookbehind longer than 255 not implemented in regex m/(?<= \u30cd{1000})/',\n\n '/\u30cd(?\u30cd)\u30cd/' => 'Sequence (?\u30cd...) not recognized {#} m/\u30cd(?\u30cd{#})\u30cd/',\n\n '/\u30cd(?(1\u30cd))\u30cd/' => 'Switch condition not recognized {#} m/\u30cd(?(1\u30cd{#}))\u30cd/',\n\n '/(?(1)\u30cd|y|\u30cc)/' => 'Switch (?(condition)... contains too many branches {#} m/(?(1)\u30cd|y|{#}\u30cc)/',\n\n '/(?(\u30cd)y|\u30cd)/' => 'Unknown switch condition (?(...)) {#} m/(?(\u30cd{#})y|\u30cd)/',\n\n '/\u30cd(?/' => 'Sequence (? incomplete {#} m/\u30cd(?{#}/',\n\n '/\u30cd(?;\u30cd/' => 'Sequence (?;...) not recognized {#} m/\u30cd(?;{#}\u30cd/',\n '/\u30cd(?<;\u30cd/' => 'Group name must start with a non-digit word character {#} m/\u30cd(?<;{#}\u30cd/',\n '/\u30cd(?\\ix\u30cd/' => 'Sequence (?\\...) not recognized {#} m/\u30cd(?\\{#}ix\u30cd/',\n '/\u30cd(?^lu:\u30cd)/' => 'Regexp modifiers \"l\" and \"u\" are mutually exclusive {#} m/\u30cd(?^lu{#}:\u30cd)/',\n'/\u30cd(?lil:\u30cd)/' => 'Regexp modifier \"l\" may not appear twice {#} m/\u30cd(?lil{#}:\u30cd)/',\n'/\u30cd(?aaia:\u30cd)/' => 'Regexp modifier \"a\" may appear a maximum of twice {#} m/\u30cd(?aaia{#}:\u30cd)/',\n'/\u30cd(?i-l:\u30cd)/' => 'Regexp modifier \"l\" may not appear after the \"-\" {#} m/\u30cd(?i-l{#}:\u30cd)/',\n\n '/\u30cd((\u30cd)/' => 'Unmatched ( {#} m/\u30cd({#}(\u30cd)/',\n\n \"/\u30cd{$inf_p1}\u30cd/\" => \"Quantifier in {,} bigger than $inf_m1 {#} m/\u30cd{{#}$inf_p1}\u30cd/\",\n\n\n '/\u30cd**\u30cd/' => 'Nested quantifiers {#} m/\u30cd**{#}\u30cd/',\n\n '/\u30cd[\u30cd/' => 'Unmatched [ {#} m/\u30cd[{#}\u30cd/',\n\n '/*\u30cd/', => 'Quantifier follows nothing {#} m/*{#}\u30cd/',\n\n '/\u30cd\\p{\u30cd/' => 'Missing right brace on \\p{} {#} m/\u30cd\\p{{#}\u30cd/',\n\n '/(\u30cd)\\2\u30cd/' => 'Reference to nonexistent group {#} m/(\u30cd)\\2{#}\u30cd/',\n\n '/\\g{\u30cd/; #no latin1' => 'Sequence \\g{... not terminated {#} m/\\g{\u30cd{#}/',\n\n 'my $m = \"\u30cd\\\\\\\"; $m =~ $m', => 'Trailing \\ in regex m/\u30cd\\/',\n\n '/\\x{\u30cd/' => 'Missing right brace on \\x{} {#} m/\\x{{#}\u30cd/',\n '/\u30cd[\\x{\u30cd]\u30cd/' => 'Missing right brace on \\x{} {#} m/\u30cd[\\x{{#}\u30cd]\u30cd/',\n '/\u30cd[\\x{\u30cd]/' => 'Missing right brace on \\x{} {#} m/\u30cd[\\x{{#}\u30cd]/',\n\n '/\u30cd\\o{\u30cd/' => 'Missing right brace on \\o{ {#} m/\u30cd\\o{{#}\u30cd/',\n '/\u30cd[[:\u30cd:]]\u30cd/' => \"\",\n\n '/[\u30cd-a]\u30cd/' => 'Invalid [] range \"\u30cd-a\" {#} m/[\u30cd-a{#}]\u30cd/',\n\n '/\u30cd\\p{}\u30cd/' => 'Empty \\p{} {#} m/\u30cd\\p{{#}}\u30cd/',\n\n '/\u30cd(?[[[:\u30cd]]])\u30cd/' => \"Unexpected ']' with no following ')' in (?[... {#} m/\u30cd(?[[[:\u30cd]]{#}])\u30cd/\",\n '/\u30cd(?[[[:\u30cd: ])\u30cd/' => \"Syntax error in (?[...]) {#} m/\u30cd(?[[[:\u30cd: ])\u30cd{#}/\",\n '/\u30cd(?[[[::]]])\u30cd/' => \"Unexpected ']' with no following ')' in (?[... {#} m/\u30cd(?[[[::]]{#}])\u30cd/\",\n '/\u30cd(?[[[:\u30cd:]]])\u30cd/' => \"Unexpected ']' with no following ')' in (?[... {#} m/\u30cd(?[[[:\u30cd:]]{#}])\u30cd/\",\n '/\u30cd(?[[:\u30cd:]])\u30cd/' => \"\",\n '/\u30cd(?[\u30cd])\u30cd/' =>  'Unexpected character {#} m/\u30cd(?[\u30cd{#}])\u30cd/',\n '/\u30cd(?[ + [\u30cd] ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/\u30cd(?[ +{#} [\u30cd] ])/',\n '/\u30cd(?[ \\cK - ( + [\u30cd] ) ])/' => 'Unexpected binary operator \\'+\\' with no preceding operand {#} m/\u30cd(?[ \\cK - ( +{#} [\u30cd] ) ])/',\n '/\u30cd(?[ \\cK ( [\u30cd] ) ])/' => 'Unexpected \\'(\\' with no preceding operator {#} m/\u30cd(?[ \\cK ({#} [\u30cd] ) ])/',\n '/\u30cd(?[ \\cK [\u30cd] ])\u30cd/' => 'Operand with no preceding operator {#} m/\u30cd(?[ \\cK [\u30cd{#}] ])\u30cd/',\n '/\u30cd(?[ \\0004 ])\u30cd/' => 'Need exactly 3 octal digits {#} m/\u30cd(?[ \\0004 {#}])\u30cd/',\n '/(?[ \\o{\u30cd} ])\u30cd/' => 'Non-octal character {#} m/(?[ \\o{\u30cd{#}} ])\u30cd/',\n '/\u30cd(?[ \\o{} ])\u30cd/' => 'Number with no digits {#} m/\u30cd(?[ \\o{}{#} ])\u30cd/',\n '/(?[ \\x{\u30cd} ])\u30cd/' => 'Non-hex character {#} m/(?[ \\x{\u30cd{#}} ])\u30cd/',\n '/(?[ \\p{\u30cd} ])/' => 'Can\\'t find Unicode property definition \"\u30cd\" {#} m/(?[ \\p{\u30cd}{#} ])/',\n '/(?[ \\p{ \u30cd = bar } ])/' => 'Can\\'t find Unicode property definition \"\u30cd = bar\" {#} m/(?[ \\p{ \u30cd = bar }{#} ])/',\n '/\u30cd(?[ \\t ]/' => \"Unexpected ']' with no following ')' in (?[... {#} m/\u30cd(?[ \\\\t ]{#}/\",\n '/(?[ \\t + \\e # \u30cd This was supposed to be a comment ])/' =>\n    \"Syntax error in (?[...]) {#} m/(?[ \\\\t + \\\\e # \u30cd This was supposed to be a comment ]){#}/\",\n 'm/(*\u30cd)\u30cd/' => q<Unknown verb pattern '\u30cd' {#} m/(*\u30cd){#}\u30cd/>,\n '/\\c\u30cd/' => \"Character following \\\"\\\\c\\\" must be printable ASCII\",\n '/\\b{\u30cd}/' => \"'\u30cd' is an unknown bound type {#} m/\\\\b{\u30cd{#}}/\",\n '/\\B{\u30cd}/' => \"'\u30cd' is an unknown bound type {#} m/\\\\B{\u30cd{#}}/\",\n);\npush @death, @death_utf8;\n\nmy @death_utf8_only_under_strict = (\n    \"m'\u30cd[\\\\y]\u30cd'\" => 'Unrecognized escape \\y in character class passed through {#} m/\u30cd[\\y{#}]\u30cd/',\n                   => 'Unrecognized escape \\y in character class {#} m/\u30cd[\\y{#}]\u30cd/',\n    'm/\u30cd[\u30cd-\\d]\u30cd/' => 'False [] range \"\u30cd-\\d\" {#} m/\u30cd[\u30cd-\\d{#}]\u30cd/',\n                     => 'False [] range \"\u30cd-\\d\" {#} m/\u30cd[\u30cd-\\d{#}]\u30cd/',\n    'm/\u30cd[\\w-\u30cd]\u30cd/' => 'False [] range \"\\w-\" {#} m/\u30cd[\\w-{#}\u30cd]\u30cd/',\n                     => 'False [] range \"\\w-\" {#} m/\u30cd[\\w-{#}\u30cd]\u30cd/',\n    'm/\u30cd[\u30cd-\\pM]\u30cd/' => 'False [] range \"\u30cd-\\pM\" {#} m/\u30cd[\u30cd-\\pM{#}]\u30cd/',\n                      => 'False [] range \"\u30cd-\\pM\" {#} m/\u30cd[\u30cd-\\pM{#}]\u30cd/',\n    '/\u30cd[\u30cd-[:digit:]]\u30cd/' => 'False [] range \"\u30cd-[:digit:]\" {#} m/\u30cd[\u30cd-[:digit:]{#}]\u30cd/',\n                           => 'False [] range \"\u30cd-[:digit:]\" {#} m/\u30cd[\u30cd-[:digit:]{#}]\u30cd/',\n    '/\u30cd[\\d-\\s]\u30cd/' => 'False [] range \"\\d-\" {#} m/\u30cd[\\d-{#}\\s]\u30cd/',\n                    => 'False [] range \"\\d-\" {#} m/\u30cd[\\d-{#}\\s]\u30cd/',\n    '/\u30cd[a\\zb]\u30cd/' => 'Unrecognized escape \\z in character class passed through {#} m/\u30cd[a\\z{#}b]\u30cd/',\n                   => 'Unrecognized escape \\z in character class {#} m/\u30cd[a\\z{#}b]\u30cd/',\n);\n# Tests involving a user-defined charnames translator are in pat_advanced.t\n\n# In the following arrays of warnings, the value can be an array of things to\n# expect.  If the empty string, it means no warning should be raised.\n\n\n# Key-value pairs of code/error of code that should have non-fatal regexp\n# warnings.  Most currently have \\x{100} appended to them to force them to be\n# upgraded to UTF-8, and the first pass restarted.  Previously this would\n# cause some warnings to be output twice.  This tests that that behavior has\n# been fixed.\n\nmy @warning = (\n    'm/\\b*\\x{100}/' => '\\b* matches null string many times {#} m/\\b*{#}\\x{100}/',\n    '/\\b{g}/a' => \"Using /u for '\\\\b{g}' instead of /a {#} m/\\\\b{g}{#}/\",\n    '/\\B{gcb}/a' => \"Using /u for '\\\\B{gcb}' instead of /a {#} m/\\\\B{gcb}{#}/\",\n    'm/[:blank:]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes {#} m/[:blank:]{#}\\x{100}/',\n    'm/[[:cntrl:]][:^ascii:]\\x{100}/' =>  'POSIX syntax [: :] belongs inside character classes {#} m/[[:cntrl:]][:^ascii:]{#}\\x{100}/',\n    'm/[[:ascii]]\\x{100}/' => \"Assuming NOT a POSIX class since there is no terminating ':' {#} m/[[:ascii{#}]]\\\\x{100}/\",\n    'm/(?[[:word]])\\x{100}/' => \"Assuming NOT a POSIX class since there is no terminating ':' {#} m/(?[[:word{#}]])\\\\x{100}/\",\n    \"m'\\\\y\\\\x{100}'\"     => 'Unrecognized escape \\y passed through {#} m/\\y{#}\\x{100}/',\n    '/x{3,1}/'   => 'Quantifier {n,m} with n > m can\\'t match {#} m/x{3,1}{#}/',\n    '/\\08/' => '\\'\\08\\' resolved to \\'\\o{0}8\\' {#} m/\\08{#}/',\n    '/\\018/' => '\\'\\018\\' resolved to \\'\\o{1}8\\' {#} m/\\018{#}/',\n    '/(?=a)*/' => '(?=a)* matches null string many times {#} m/(?=a)*{#}/',\n    'my $x = \\'\\m\\'; qr/a$x/' => 'Unrecognized escape \\m passed through {#} m/a\\m{#}/',\n    '/\\q/' => 'Unrecognized escape \\q passed through {#} m/\\q{#}/',\n\n    # These two tests do not include the marker, because regcomp.c no\n    # longer knows where it goes by the time this warning is emitted.\n    # See [perl #122680] regcomp warning gives wrong position of\n    # problem.\n    '/(?=a){1,3}\\x{100}/' => 'Quantifier unexpected on zero-length expression in regex m/(?=a){1,3}\\x{100}/',\n    '/(a|b)(?=a){3}\\x{100}/' => 'Quantifier unexpected on zero-length expression in regex m/(a|b)(?=a){3}\\x{100}/',\n\n    '/\\_/' => \"\",\n    '/[\\006]/' => \"\",\n    '/[:alpha:]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes {#} m/[:alpha:]{#}\\x{100}/',\n    '/[:zog:]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes (but this one isn\\'t fully valid) {#} m/[:zog:]{#}\\x{100}/',\n    '/[.zog.]\\x{100}/' => 'POSIX syntax [. .] belongs inside character classes (but this one isn\\'t implemented) {#} m/[.zog.]{#}\\x{100}/',\n    '/[a-b]/' => \"\",\n    '/(?c)\\x{100}/' => 'Useless (?c) - use /gc modifier {#} m/(?c{#})\\x{100}/',\n    '/(?-c)\\x{100}/' => 'Useless (?-c) - don\\'t use /gc modifier {#} m/(?-c{#})\\x{100}/',\n    '/(?g)\\x{100}/' => 'Useless (?g) - use /g modifier {#} m/(?g{#})\\x{100}/',\n    '/(?-g)\\x{100}/' => 'Useless (?-g) - don\\'t use /g modifier {#} m/(?-g{#})\\x{100}/',\n    '/(?o)\\x{100}/' => 'Useless (?o) - use /o modifier {#} m/(?o{#})\\x{100}/',\n    '/(?-o)\\x{100}/' => 'Useless (?-o) - don\\'t use /o modifier {#} m/(?-o{#})\\x{100}/',\n    '/(?g-o)\\x{100}/' => [ 'Useless (?g) - use /g modifier {#} m/(?g{#}-o)\\x{100}/',\n                    'Useless (?-o) - don\\'t use /o modifier {#} m/(?g-o{#})\\x{100}/',\n                  ],\n    '/(?g-c)\\x{100}/' => [ 'Useless (?g) - use /g modifier {#} m/(?g{#}-c)\\x{100}/',\n                    'Useless (?-c) - don\\'t use /gc modifier {#} m/(?g-c{#})\\x{100}/',\n                  ],\n      # (?c) means (?g) error won't be thrown\n     '/(?o-cg)\\x{100}/' => [ 'Useless (?o) - use /o modifier {#} m/(?o{#}-cg)\\x{100}/',\n                      'Useless (?-c) - don\\'t use /gc modifier {#} m/(?o-c{#}g)\\x{100}/',\n                    ],\n    '/(?ogc)\\x{100}/' => [ 'Useless (?o) - use /o modifier {#} m/(?o{#}gc)\\x{100}/',\n                    'Useless (?g) - use /g modifier {#} m/(?og{#}c)\\x{100}/',\n                    'Useless (?c) - use /gc modifier {#} m/(?ogc{#})\\x{100}/',\n                  ],\n    '/a{1,1}?\\x{100}/' => 'Useless use of greediness modifier \\'?\\' {#} m/a{1,1}?{#}\\x{100}/',\n    \"/(?[ [ % - % ] ])/\" => \"\",\n    \"/(?[ [ : - \\\\x$colon_hex ] ])\\\\x{100}/\" => \"\\\": - \\\\x$colon_hex \\\" is more clearly written simply as \\\":\\\" {#} m/(?[ [ : - \\\\x$colon_hex {#}] ])\\\\x{100}/\",\n    \"/(?[ [ \\\\x$colon_hex - : ] ])\\\\x{100}/\" => \"\\\"\\\\x$colon_hex\\ - : \\\" is more clearly written simply as \\\":\\\" {#} m/(?[ [ \\\\x$colon_hex - : {#}] ])\\\\x{100}/\",\n    \"/(?[ [ \\\\t - \\\\x$tab_hex ] ])\\\\x{100}/\" => \"\\\"\\\\t - \\\\x$tab_hex \\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/(?[ [ \\\\t - \\\\x$tab_hex {#}] ])\\\\x{100}/\",\n    \"/(?[ [ \\\\x$tab_hex - \\\\t ] ])\\\\x{100}/\" => \"\\\"\\\\x$tab_hex\\ - \\\\t \\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/(?[ [ \\\\x$tab_hex - \\\\t {#}] ])\\\\x{100}/\",\n    \"/(?[ [ $B_hex - C ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ $B_hex - C {#}] ])/\",\n    \"/(?[ [ A - $B_hex ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ A - $B_hex {#}] ])/\",\n    \"/(?[ [ $low_mixed_alpha - $high_mixed_alpha ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ $low_mixed_alpha - $high_mixed_alpha {#}] ])/\",\n    \"/(?[ [ $low_mixed_digit - $high_mixed_digit ] ])/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/(?[ [ $low_mixed_digit - $high_mixed_digit {#}] ])/\",\n    \"/[alnum]/\" => \"\",\n    \"/[^alnum]/\" => \"\",\n    '/[:blank]\\x{100}/' => 'POSIX syntax [: :] belongs inside character classes (but this one isn\\'t fully valid) {#} m/[:blank{#}]\\x{100}/',\n    '/[[:digit]]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[:digit{#}]]\\x{100}/', # [perl # 8904]\n    '/[[:digit:foo]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\']\\' {#} m/[[:digit:{#}foo]\\x{100}/',\n    '/[[:di#it:foo]\\x{100}/x' => 'Assuming NOT a POSIX class since there is no terminating \\']\\' {#} m/[[:di#it:{#}foo]\\x{100}/',\n    '/[[:dgit]]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[:dgit{#}]]\\x{100}/',\n    '/[[:dgit:foo]\\x{100}/' => 'Assuming NOT a POSIX class since there is no terminating \\']\\' {#} m/[[:dgit:{#}foo]\\x{100}/',\n    '/[[:dgt]]\\x{100}/' => \"\",      # Far enough away from a real class to not be recognized as one\n    '/[[:dgt:foo]\\x{100}/' => \"\",\n    '/[[:DIGIT]]\\x{100}/' => [ 'Assuming NOT a POSIX class since the name must be all lowercase letters {#} m/[[:DIGIT{#}]]\\x{100}/',\n                               'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[:DIGIT{#}]]\\x{100}/',\n                           ],\n    '/[[digit]\\x{100}/' => [ 'Assuming NOT a POSIX class since there must be a starting \\':\\' {#} m/[[{#}digit]\\x{100}/',\n                             'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[digit{#}]\\x{100}/',\n                           ],\n    '/[[alpha]]\\x{100}/' => [ 'Assuming NOT a POSIX class since there must be a starting \\':\\' {#} m/[[{#}alpha]]\\x{100}/',\n                              'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[alpha{#}]]\\x{100}/',\n                           ],\n    '/[[^word]\\x{100}/' => [ 'Assuming NOT a POSIX class since the \\'^\\' must come after the colon {#} m/[[^{#}word]\\x{100}/',\n                              'Assuming NOT a POSIX class since there must be a starting \\':\\' {#} m/[[^{#}word]\\x{100}/',\n                              'Assuming NOT a POSIX class since there is no terminating \\':\\' {#} m/[[^word{#}]\\x{100}/',\n                            ],\n    '/[[   ^   :   x d i g i t   :   ]   ]\\x{100}/' => [ 'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   {#}^   :   x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since the \\'^\\' must come after the colon {#} m/[[   ^{#}   :   x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   ^   {#}:   x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   ^   :   {#}x d i g i t   :   ]   ]\\x{100}/',\n                                               'Assuming NOT a POSIX class since no blanks are allowed in one {#} m/[[   ^   :   x d i g i t   :   ]{#}   ]\\x{100}/',\n                                               $only_strict_marker . 'Unescaped literal \\']\\' {#} m/[[   ^   :   x d i g i t   :   ]   ]{#}\\x{100}/',\n                            ],\n    '/[foo:lower:]]\\x{100}/' => 'Assuming NOT a POSIX class since it doesn\\'t start with a \\'[\\' {#} m/[foo{#}:lower:]]\\x{100}/',\n    '/[[;upper;]]\\x{100}/' => [ 'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[[;{#}upper;]]\\x{100}/',\n                                'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[[;upper;]{#}]\\x{100}/',\n                              ],\n    '/[foo;punct;]]\\x{100}/' => [ 'Assuming NOT a POSIX class since it doesn\\'t start with a \\'[\\' {#} m/[foo{#};punct;]]\\x{100}/',\n                                  'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[foo;{#}punct;]]\\x{100}/',\n                                  'Assuming NOT a POSIX class since a semi-colon was found instead of a colon {#} m/[foo;punct;]{#}]\\x{100}/',\n                                ],\n   '/[][[:alpha:]]/' => \"\",        # [perl #127581]\n   '/[][[:alpha:]\\\\@\\\\\\\\^_?]/' => \"\", # [perl #131522]\n); # See comments before this for why '\\x{100}' is generally needed\n\n# These need the character '\u30cd' as a marker for mark_as_utf8()\nmy @warnings_utf8 = mark_as_utf8(\n    'm/\u30cd\\b*\u30cd/' => '\\b* matches null string many times {#} m/\u30cd\\b*{#}\u30cd/',\n    '/(?=\u30cd)*/' => '(?=\u30cd)* matches null string many times {#} m/(?=\u30cd)*{#}/',\n    'm/\u30cd[:foo:]\u30cd/' => 'POSIX syntax [: :] belongs inside character classes (but this one isn\\'t fully valid) {#} m/\u30cd[:foo:]{#}\u30cd/',\n    '/\u30cd(?c)\u30cd/' => 'Useless (?c) - use /gc modifier {#} m/\u30cd(?c{#})\u30cd/',\n    '/utf8 \u30cd (?ogc) \u30cd/' => [\n        'Useless (?o) - use /o modifier {#} m/utf8 \u30cd (?o{#}gc) \u30cd/',\n        'Useless (?g) - use /g modifier {#} m/utf8 \u30cd (?og{#}c) \u30cd/',\n        'Useless (?c) - use /gc modifier {#} m/utf8 \u30cd (?ogc{#}) \u30cd/',\n    ],\n\n);\n\npush @warning, @warnings_utf8;\n\nmy @warning_only_under_strict = (\n    '/[\\N{U+00}-\\x01]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+00}-\\x01{#}]\\x{100}/',\n    '/[\\x00-\\N{SOH}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\x00-\\N{U+01}{#}]\\x{100}/',\n    '/[\\N{DEL}-\\o{377}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+7F}-\\o{377}{#}]\\x{100}/',\n    '/[\\o{0}-\\N{U+01}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\o{0}-\\N{U+01}{#}]\\x{100}/',\n    '/[\\000-\\N{U+01}]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\000-\\N{U+01}{#}]\\x{100}/',\n    '/[\\N{DEL}-\\377]\\x{100}/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+7F}-\\377{#}]\\x{100}/',\n    '/[\\N{U+00}-A]\\x{100}/' => 'Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or \"a-z\" {#} m/[\\N{U+00}-A{#}]\\x{100}/',\n    '/[a-\\N{U+FF}]\\x{100}/' => 'Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or \"a-z\" {#} m/[a-\\N{U+FF}{#}]\\x{100}/',\n    '/[\\N{U+00}-\\a]\\x{100}/' => \"\",\n    '/[\\a-\\N{U+FF}]\\x{100}/' => \"\",\n    '/[\\N{U+FF}-\\x{100}]/' => 'Both or neither range ends should be Unicode {#} m/[\\N{U+FF}-\\x{100}{#}]/',\n    '/[\\N{U+100}-\\x{101}]/' => \"\",\n    \"/[%-%]/\" => \"\",\n    \"/[:-\\\\x$colon_hex]\\\\x{100}/\" => \"\\\":-\\\\x$colon_hex\\\" is more clearly written simply as \\\":\\\" {#} m/[:-\\\\x$colon_hex\\{#}]\\\\x{100}/\",\n    \"/[\\\\x$colon_hex-:]\\\\x{100}/\" => \"\\\"\\\\x$colon_hex-:\\\" is more clearly written simply as \\\":\\\" {#} m/[\\\\x$colon_hex\\-:{#}]\\\\x{100}/\",\n    \"/[\\\\t-\\\\x$tab_hex]\\\\x{100}/\" => \"\\\"\\\\t-\\\\x$tab_hex\\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/[\\\\t-\\\\x$tab_hex\\{#}]\\\\x{100}/\",\n    \"/[\\\\x$tab_hex-\\\\t]\\\\x{100}/\" => \"\\\"\\\\x$tab_hex-\\\\t\\\" is more clearly written simply as \\\"\\\\t\\\" {#} m/[\\\\x$tab_hex\\-\\\\t{#}]\\\\x{100}/\",\n    \"/[$B_hex-C]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[$B_hex-C{#}]/\",\n    \"/[A-$B_hex]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[A-$B_hex\\{#}]/\",\n    \"/[$low_mixed_alpha-$high_mixed_alpha]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[$low_mixed_alpha-$high_mixed_alpha\\{#}]/\",\n    \"/[$low_mixed_digit-$high_mixed_digit]/\" => \"Ranges of ASCII printables should be some subset of \\\"0-9\\\", \\\"A-Z\\\", or \\\"a-z\\\" {#} m/[$low_mixed_digit-$high_mixed_digit\\{#}]/\",\n    '/\\b<GCB}/' => 'Unescaped literal \\'}\\' {#} m/\\b<GCB}{#}/',\n    '/[ ]def]/' => 'Unescaped literal \\']\\' {#} m/[ ]def]{#}/',\n);\n\nmy @warning_utf8_only_under_strict = mark_as_utf8(\n '/\u30cd[\u1a89-\u1a90]/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd[\u1a89-\u1a90{#}]/\",\n '/\u30cd(?[ [ \u1a89 - \u1a90 ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \u1a89 - \u1a90 {#}] ])/\",\n '/\u30cd[\u19d9-\u19da]/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd[\u19d9-\u19da{#}]/\",\n '/\u30cd(?[ [ \u19d9 - \u19da ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \u19d9 - \u19da {#}] ])/\",\n '/\u30cd(?[ [ \ud835\udfd8 - \ud835\udfe1 ] ])/; #no latin1' => \"\",\n '/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff1 ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff1 {#}] ])/\",\n '/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff0 ] ])/; #no latin1' => \"Ranges of digits should be from the same group of 10 {#} m/\u30cd(?[ [ \ud835\udfe7 - \ud835\udff0 {#}] ])/\",\n);\n\npush @warning_only_under_strict, @warning_utf8_only_under_strict;\n\nmy @experimental_regex_sets = (\n    '/(?[ \\t ])/' => 'The regex_sets feature is experimental {#} m/(?[{#} \\t ])/',\n    'use utf8; /utf8 \u30cd (?[ [\\t\u30cd] ])/' => do { use utf8; 'The regex_sets feature is experimental {#} m/utf8 \u30cd (?[{#} [\\t\u30cd] ])/' },\n    '/noutf8 \u30cd (?[ [\\t\u30cd] ])/' => 'The regex_sets feature is experimental {#} m/noutf8 \u30cd (?[{#} [\\t\u30cd] ])/',\n);\n\nmy @deprecated = (\n '/^{/'          => \"\",\n '/foo|{/'       => \"\",\n '/foo|^{/'      => \"\",\n '/foo({bar)/'   => \"\",\n '/foo(:?{bar)/' => \"\",\n '/\\s*{/'        => \"\",\n '/a{3,4}{/'     => \"\",\n '/.{/'         => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/.{{#}/',\n '/[x]{/'       => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/[x]{{#}/',\n '/\\p{Latin}{/' => 'Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.30), passed through {#} m/\\p{Latin}{{#}/',\n);\n\nfor my $strict (\"\", \"use re 'strict';\") {\n\n    # First time just use @death; but under strict we add the things that fail\n    # there.  Doing it this way makes sure that 'strict' doesnt change the\n    # things that are already fatal when not under strict.\n    if ($strict) {\n        for (my $i = 0; $i < @death_only_under_strict; $i += 3) {\n            push @death, $death_only_under_strict[$i],    # The regex\n                         $death_only_under_strict[$i+2];  # The fatal msg\n        }\n        for (my $i = 0; $i < @death_utf8_only_under_strict; $i += 3) {\n\n            # Same with the utf8 versions\n            push @death, mark_as_utf8($death_utf8_only_under_strict[$i],\n                                      $death_utf8_only_under_strict[$i+2]);\n        }\n    }\n    for (my $i = 0; $i < @death; $i += 2) {\n        my $regex = $death[$i] =~ s/ default_ (on | off) //rx;\n        my $expect = fixup_expect($death[$i+1], $strict);\n        no warnings 'experimental::regex_sets';\n        no warnings 'experimental::re_strict';\n\n        warning_is(sub {\n                    my $eval_string = \"$strict $regex\";\n                    $_ = \"x\";\n                    eval $eval_string;\n                    my $error= $@;\n                    if ($error =~ qr/\\Q$expect/) {\n                        ok(1,$eval_string);\n                    } else {\n                        ok(0,$eval_string);\n                        diag(\"Have: \" . _qq(add_markers($error)));\n                        diag(\"Want: \" . _qq($death[$i+1]));\n                    }\n                }, undef, \"... and died without any other warnings\");\n    }\n}\n\nfor my $strict (\"\",  \"no warnings 'experimental::re_strict'; use re 'strict';\") {\n    my @warning_tests = @warning;\n\n    # Build the tests for @warning.  Use the strict/non-strict versions\n    # appropriately.\n    if ($strict) {\n        push @warning_tests, @warning_only_under_strict;\n    }\n    else {\n        for (my $i = 0; $i < @warning_only_under_strict; $i += 2) {\n\n            # (?[ ]) are always under strict\n            if ($warning_only_under_strict[$i] =~ /\\Q(?[/) {\n                push @warning_tests, $warning_only_under_strict[$i],  # The regex\n                                    $warning_only_under_strict[$i+1];\n            }\n            else {\n                push @warning_tests, $warning_only_under_strict[$i],  # The regex\n                                    \"\";    # No warning because not strict\n            }\n        }\n        for (my $i = 0; $i < @death_only_under_strict; $i += 3) {\n            push @warning_tests, $death_only_under_strict[$i],    # The regex\n                                 $death_only_under_strict[$i+1];  # The warning\n        }\n        for (my $i = 0; $i < @death_utf8_only_under_strict; $i += 3) {\n            push @warning_tests, mark_as_utf8($death_utf8_only_under_strict[$i],\n                                        $death_utf8_only_under_strict[$i+1]);\n        }\n    }\n\n    foreach my $ref (\\@warning_tests, \\@experimental_regex_sets, \\@deprecated) {\n        my $warning_type;\n        my $turn_off_warnings = \"\";\n        my $default_on;\n        if ($ref == \\@warning_tests) {\n            $warning_type = 'regexp, digit';\n            $turn_off_warnings = \"no warnings 'experimental::regex_sets';\";\n            $default_on = $strict;\n        }\n        elsif ($ref == \\@deprecated) {\n            $warning_type = 'regexp, deprecated';\n            $default_on = 1;\n        }\n        else {\n            $warning_type = 'experimental::regex_sets';\n            $default_on = 1;\n        }\n        for (my $i = 0; $i < @$ref; $i += 2) {\n            my $this_default_on = $default_on;\n            my $regex = $ref->[$i];\n            if ($regex =~ s/ default_ (on | off) //x) {\n                $this_default_on = $1 eq 'on';\n            }\n            my @expect = fixup_expect($ref->[$i+1], $strict);\n\n            # A length-1 array with an empty warning means no warning gets\n            # generated at all.\n            undef @expect if @expect == 1 && $expect[0] eq \"\";\n\n            {\n                $_ = \"x\";\n                #use feature 'unicode_eval';\n                #print STDERR __LINE__, \": \", \"eval '$strict no warnings; $regex'\", \"\\n\";\n                eval \"$strict no warnings; $regex\";\n            }\n            if (is($@, \"\", \"$strict $regex did not die\")) {\n                my @got = capture_warnings(sub {\n                                        $_ = \"x\";\n                                        eval \"$strict $turn_off_warnings $regex\" });\n                my $count = @expect;\n                if (! is(scalar @got, scalar @expect,\n                            \"... and gave expected number ($count) of warnings\"))\n                {\n                    if (@got < @expect) {\n                        $count = @got;\n                        note \"Expected warnings not gotten:\\n\\t\" . join \"\\n\\t\",\n                                                    @expect[$count .. $#expect];\n                    }\n                    else {\n                        note \"Unexpected warnings gotten:\\n\\t\" . join(\"\\n\\t\",\n                                                         @got[$count .. $#got]);\n                    }\n                }\n                foreach my $i (0 .. $count - 1) {\n                    if (! like($got[$i], qr/\\Q$expect[$i]/,\n                                               \"... and gave expected warning\"))\n                    {\n                        chomp($got[$i]);\n                        chomp($expect[$i]);\n                        diag(\"GOT\\n'$got[$i]'\\nEXPECT\\n'$expect[$i]'\");\n                    }\n                    else {\n                        ok (0 == capture_warnings(sub {\n                            $_ = \"x\";\n                            eval \"$strict no warnings '$warning_type'; $regex;\" }\n                           ),\n                           \"... and turning off '$warning_type' warnings suppressed it\");\n\n                        # Test that whether the warning is on by default is\n                        # correct.  This test relies on the fact that we\n                        # are outside the scope of any \u2018use warnings\u2019.\n                        local $^W;\n                        my @warns = capture_warnings(sub { $_ = \"x\";\n                                                        eval \"$strict $regex\" });\n                        # Warning should be on as well if is testing\n                        # '(?[...])' which turns on strict\n                        if ($this_default_on || grep { $_ =~ /\\Q(?[/ } @expect ) {\n                           ok @warns > 0, \"... and the warning is on by default\";\n                        }\n                        else {\n                         ok @warns == 0, \"... and the warning is off by default\";\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\ndone_testing();\n", "#!./perl\n\n# This tests (?[...]).  XXX These are just basic tests, as full ones would be\n# best done with an infrastructure change to allow getting out the inversion\n# list of the constructed set and then comparing it character by character\n# with the expected result.\n\nBEGIN {\n    chdir 't' if -d 't';\n    require './test.pl';\n    require './charset_tools.pl';\n    require './loc_tools.pl';\n    set_up_inc( '../lib','.','../ext/re' );\n}\n\nskip_all_without_unicode_tables();\n\nuse strict;\nuse warnings;\n\n$| = 1;\n\nuse utf8;\nno warnings 'experimental::regex_sets';\n\nlike(\"a\", qr/(?[ [a]      # This is a comment\n                    ])/, 'Can ignore a comment');\nlike(\"a\", qr/(?[ [a]      # [[:notaclass:]]\n                    ])/, 'A comment isn\\'t parsed');\nunlike(uni_to_native(\"\\x85\"), qr/(?[ \\t\u0085 ])/, 'NEL is white space');\nlike(uni_to_native(\"\\x85\"), qr/(?[ \\t + \\\u0085 ])/, 'can escape NEL to match');\nlike(uni_to_native(\"\\x85\"), qr/(?[ [\\\u0085] ])/, '... including within nested []');\nlike(\"\\t\", qr/(?[ \\t + \\\u0085 ])/, 'can do basic union');\nlike(\"\\cK\", qr/(?[ \\s ])/, '\\s matches \\cK');\nunlike(\"\\cK\", qr/(?[ \\s - \\cK ])/, 'can do basic subtraction');\nlike(\" \", qr/(?[ \\s - \\cK ])/, 'can do basic subtraction');\nlike(\":\", qr/(?[ [:] ])/, '[:] is not a posix class');\nunlike(\"\\t\", qr/(?[ ! \\t ])/, 'can do basic complement');\nlike(\"\\t\", qr/(?[ ! [ ^ \\t ] ])/, 'can do basic complement');\nunlike(\"\\r\", qr/(?[ \\t ])/, '\\r doesn\\'t match \\t ');\nlike(\"\\r\", qr/(?[ ! \\t ])/, 'can do basic complement');\nlike(\"0\", qr/(?[ [:word:] & [:digit:] ])/, 'can do basic intersection');\nunlike(\"A\", qr/(?[ [:word:] & [:digit:] ])/, 'can do basic intersection');\nlike(\"0\", qr/(?[[:word:]&[:digit:]])/, 'spaces around internal [] aren\\'t required');\n\nlike(\"a\", qr/(?[ [a] | [b] ])/, '| means union');\nlike(\"b\", qr/(?[ [a] | [b] ])/, '| means union');\nunlike(\"c\", qr/(?[ [a] | [b] ])/, '| means union');\n\nlike(\"a\", qr/(?[ [ab] ^ [bc] ])/, 'basic symmetric difference works');\nunlike(\"b\", qr/(?[ [ab] ^ [bc] ])/, 'basic symmetric difference works');\nlike(\"c\", qr/(?[ [ab] ^ [bc] ])/, 'basic symmetric difference works');\n\nlike(\"2\", qr/(?[ ( ( \\pN & ( [a] + [2] ) ) ) ])/, 'Nesting parens and grouping');\nunlike(\"a\", qr/(?[ ( ( \\pN & ( [a] + [2] ) ) ) ])/, 'Nesting parens and grouping');\n\nunlike(\"\\x{17f}\", qr/(?[ [k] + \\p{Blk=ASCII} ])/i, '/i doesn\\'t affect \\p{}');\nlike(\"\\N{KELVIN SIGN}\", qr/(?[ [k] + \\p{Blk=ASCII} ])/i, '/i does affect literals');\n\nmy $thai_or_lao = qr/(?[ \\p{Thai} + \\p{Lao} ])/;\nmy $thai_or_lao_digit = qr/(?[ \\p{Digit} & $thai_or_lao ])/;\nlike(\"\\N{THAI DIGIT ZERO}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{THAI DIGIT ZERO}\") - 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nlike(\"\\N{THAI DIGIT NINE}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{THAI DIGIT NINE}\") + 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nlike(\"\\N{LAO DIGIT ZERO}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{LAO DIGIT ZERO}\") - 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nlike(\"\\N{LAO DIGIT NINE}\", $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\nunlike(chr(ord(\"\\N{LAO DIGIT NINE}\") + 1), $thai_or_lao_digit, 'embedded qr/(?[ ])/ works');\n\nmy $ascii_word = qr/(?[ \\w ])/a;\nmy $ascii_digits_plus_all_of_arabic = qr/(?[ \\p{Arabic} + \\p{Digit} & $ascii_word ])/;\nlike(\"9\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for ASCII in the set\");\nunlike(\"A\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for ASCII not in the set\");\nunlike(\"\\N{BENGALI DIGIT ZERO}\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for non-ASCII not in either set\");\nunlike(\"\\N{BENGALI LETTER A}\", $ascii_digits_plus_all_of_arabic, \"/a, then interpolating and intersection works for non-ASCII in one set\");\nlike(\"\\N{ARABIC LETTER HAMZA}\", $ascii_digits_plus_all_of_arabic, \"intersection has higher precedence than union\");\nlike(\"\\N{EXTENDED ARABIC-INDIC DIGIT ZERO}\", $ascii_digits_plus_all_of_arabic, \"intersection has higher precedence than union\");\n\nlike(\"\\r\", qr/(?[ \\p{lb=cr} ])/, '\\r matches \\p{lb=cr}');\nunlike(\"\\r\", qr/(?[ ! \\p{lb=cr} ])/, '\\r doesnt match ! \\p{lb=cr}');\nlike(\"\\r\", qr/(?[ ! ! \\p{lb=cr} ])/, 'Two ! ! are the original');\nunlike(\"\\r\", qr/(?[ ! ! ! \\p{lb=cr} ])/, 'Three ! ! ! are the complement');\n# left associatve\n\nmy $kelvin = qr/(?[ \\N{KELVIN SIGN} ])/;\nmy $fold = qr/(?[ $kelvin ])/i;\nlike(\"\\N{KELVIN SIGN}\", $kelvin, '\"\\N{KELVIN SIGN}\" matches compiled qr/(?[ \\N{KELVIN SIGN} ])/');\nunlike(\"K\", $fold, \"/i on outer (?[ ]) doesn't leak to interpolated one\");\nunlike(\"k\", $fold, \"/i on outer (?[ ]) doesn't leak to interpolated one\");\n\nmy $kelvin_fold = qr/(?[ \\N{KELVIN SIGN} ])/i;\nmy $still_fold = qr/(?[ $kelvin_fold ])/;\nlike(\"K\", $still_fold, \"/i on interpolated (?[ ]) is retained in outer without /i\");\nlike(\"k\", $still_fold, \"/i on interpolated (?[ ]) is retained in outer without /i\");\n\neval 'my $x = qr/(?[ [a] ])/; qr/(?[ $x ])/';\nis($@, \"\", 'qr/(?[ [a] ])/ can be interpolated');\n\nlike(\"B\", qr/(?[ [B] | ! ( [^B] ) ])/, \"[perl #125892]\");\n\nlike(\"a\", qr/(?[ (?#comment) [a]])/, \"Can have (?#comments)\");\n\nif (! is_miniperl() && locales_enabled('LC_CTYPE')) {\n    my $utf8_locale = find_utf8_ctype_locale;\n    SKIP: {\n        skip(\"No utf8 locale available on this platform\", 8) unless $utf8_locale;\n\n        setlocale(&POSIX::LC_ALL, \"C\");\n        use locale;\n\n        $kelvin_fold = qr/(?[ \\N{KELVIN SIGN} ])/i;\n        my $single_char_class = qr/(?[ \\: ])/;\n\n        setlocale(&POSIX::LC_ALL, $utf8_locale);\n\n        like(\"\\N{KELVIN SIGN}\", $kelvin_fold,\n             '(?[ \\N{KELVIN SIGN} ]) matches itself under /i in UTF8-locale');\n        like(\"K\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"K\" under /i in UTF8-locale');\n        like(\"k\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"k\" under /i in UTF8-locale');\n        like(\":\", $single_char_class,\n             '(?[ : ]) matches itself in UTF8-locale (a single character class)');\n\n        setlocale(&POSIX::LC_ALL, \"C\");\n\n        # These should generate warnings (the above 4 shouldn't), but like()\n        # suppresses them, so the warnings tests are in t/lib/warnings/regexec\n        $^W = 0;   # Suppress the warnings that occur when run by hand with\n                   # the -w option\n        like(\"\\N{KELVIN SIGN}\", $kelvin_fold,\n             '(?[ \\N{KELVIN SIGN} ]) matches itself under /i in C locale');\n        like(\"K\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"K\" under /i in C locale');\n        like(\"k\", $kelvin_fold,\n                '(?[ \\N{KELVIN SIGN} ]) matches \"k\" under /i in C locale');\n        like(\":\", $single_char_class,\n             '(?[ : ]) matches itself in C locale (a single character class)');\n    }\n}\n\n# Tests that no warnings given for valid Unicode digit range.\nmy $arabic_digits = qr/(?[ [ \u0660 - \u0669 ] ])/;\nfor my $char (\"\u0660\", \"\u0665\", \"\u0669\") {\n    use charnames ();\n    my @got = capture_warnings(sub {\n                like(\"\u0660\", $arabic_digits, \"Matches \"\n                                                . charnames::viacode(ord $char));\n            });\n    is (@got, 0, \"... without warnings\");\n}\n\n# RT #126181: \\cX behaves strangely inside (?[])\n{\n\tno warnings qw(syntax regexp);\n\n\teval { $_ = '/(?[(\\c]) /'; qr/$_/ };\n\tlike($@, qr/^Syntax error/, '/(?[(\\c]) / should not panic');\n\teval { $_ = '(?[\\c#]' . \"\\n])\"; qr/$_/ };\n\tlike($@, qr/^Unexpected/, '/(?[(\\c]) / should not panic');\n\teval { $_ = '(?[(\\c])'; qr/$_/ };\n\tlike($@, qr/^Syntax error/, '/(?[(\\c])/ should be a syntax error');\n\teval { $_ = '(?[(\\c]) ]\\b'; qr/$_/ };\n\tlike($@, qr/^Unexpected/, '/(?[(\\c]) ]\\b/ should be a syntax error');\n\teval { $_ = '(?[\\c[]](])'; qr/$_/ };\n\tlike($@, qr/^Unexpected/, '/(?[\\c[]](])/ should be a syntax error');\n\tlike(\"\\c#\", qr/(?[\\c#])/, '\\c# should match itself');\n\tlike(\"\\c[\", qr/(?[\\c[])/, '\\c[ should match itself');\n\tlike(\"\\c\\ \", qr/(?[\\c\\])/, '\\c\\ should match itself');\n\tlike(\"\\c]\", qr/(?[\\c]])/, '\\c] should match itself');\n}\n\n# RT #126481 !! with syntax error panics\n{\n    fresh_perl_like('no warnings \"experimental::regex_sets\"; qr/(?[ ! ! (\\w])/',\n                    qr/^Unmatched \\(/, {},\n                    'qr/(?[ ! ! (\\w])/ doesnt panic');\n\n    # The following didn't panic before, but easy to add this here with a\n    # paren between the !!\n    fresh_perl_like('no warnings \"experimental::regex_sets\";qr/(?[ ! ( ! (\\w)])/',\n                    qr/^Unmatched \\(/, {},\n                    'qr/qr/(?[ ! ( ! (\\w)])/');\n}\n\n{   # RT #129122\n    my $pat = '(?[ ( [ABC] - [B] ) + ( [abc] - [b] ) + [def] ])';\n    like(\"A\", qr/$pat/, \"'A' matches /$pat/\");\n    unlike(\"B\", qr/$pat/, \"'B' doesn't match /$pat/\");\n    like(\"C\", qr/$pat/, \"'C' matches /$pat/\");\n    unlike(\"D\", qr/$pat/, \"'D' doesn't match /$pat/\");\n    like(\"a\", qr/$pat/, \"'a' matches /$pat/\");\n    unlike(\"b\", qr/$pat/, \"'b' doesn't match /$pat/\");\n    like(\"c\", qr/$pat/, \"'c' matches /$pat/\");\n    like(\"d\", qr/$pat/, \"'d' matches /$pat/\");\n    like(\"e\", qr/$pat/, \"'e' matches /$pat/\");\n    like(\"f\", qr/$pat/, \"'f' matches /$pat/\");\n    unlike(\"g\", qr/$pat/, \"'g' doesn't match /$pat/\");\n}\n\n{   # [perl #129322 ]  This crashed perl, so keep after the ones that don't\n    my $pat = '(?[[!]&[0]^[!]&[0]+[a]])';\n    like(\"a\", qr/$pat/, \"/$pat/ compiles and matches 'a'\");\n}\n\ndone_testing();\n\n1;\n"], "buggy_code_start_loc": [5948, 1131, 14950, 62, 237, 165], "buggy_code_end_loc": [6442, 1133, 15221, 77, 473, 172], "fixing_code_start_loc": [5948, 1131, 14950, 62, 237, 165], "fixing_code_end_loc": [6468, 1133, 15229, 77, 476, 172], "type": "CWE-119", "message": "Perl before 5.26.3 has a buffer overflow via a crafted regular expression that triggers invalid write operations.", "other": {"cve": {"id": "CVE-2018-18314", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-07T21:29:00.920", "lastModified": "2020-07-15T03:15:34.420", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Perl before 5.26.3 has a buffer overflow via a crafted regular expression that triggers invalid write operations."}, {"lang": "es", "value": "Perl, en versiones anteriores a la 5.26.3, tiene un desbordamiento de b\u00fafer mediante una expresi\u00f3n regular manipulada que desencadena operaciones inv\u00e1lidas de escritura."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:perl:perl:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.26.3", "matchCriteriaId": "C0FEAD21-C9A0-40F3-8F2E-489750B07760"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndIncluding": "11.40", "matchCriteriaId": "9C82200F-A26E-4AD4-82FF-DC5601A28D52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snap_creator_framework:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F4754FB-E3EB-454A-AB1A-AE3835C5350C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapdrive:-:*:*:*:*:unix:*:*", "matchCriteriaId": "61D7EF01-F618-497F-9375-8003CEA3D380"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "041F9200-4C01-4187-AE34-240E8277B54D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "4EB48767-F095-444F-9E05-D9AC345AB803"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5F6FA12B-504C-4DBF-A32E-0548557AA2ED"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106145", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1042181", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0001", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0010", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1646751", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Perl/perl5/commit/19a498a461d7c81ae3507c450953d1148efecf4f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RWQGEB543QN7SSBRKYJM6PSOC3RLYGSM/", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://metacpan.org/changes/release/SHAY/perl-5.26.3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://rt.perl.org/Ticket/Display.html?id=131649", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201909-01", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20190221-0003/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3834-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4347", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/Perl/perl5/commit/19a498a461d7c81ae3507c450953d1148efecf4f"}}