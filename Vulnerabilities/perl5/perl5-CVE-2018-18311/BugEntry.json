{"buggy_code": ["/*    util.c\n *\n *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others\n *\n *    You may distribute under the terms of either the GNU General Public\n *    License or the Artistic License, as specified in the README file.\n *\n */\n\n/*\n * 'Very useful, no doubt, that was to Saruman; yet it seems that he was\n *  not content.'                                    --Gandalf to Pippin\n *\n *     [p.598 of _The Lord of the Rings_, III/xi: \"The Palant\u00edr\"]\n */\n\n/* This file contains assorted utility routines.\n * Which is a polite way of saying any stuff that people couldn't think of\n * a better place for. Amongst other things, it includes the warning and\n * dieing stuff, plus wrappers for malloc code.\n */\n\n#include \"EXTERN.h\"\n#define PERL_IN_UTIL_C\n#include \"perl.h\"\n#include \"reentr.h\"\n\n#if defined(USE_PERLIO)\n#include \"perliol.h\" /* For PerlIOUnix_refcnt */\n#endif\n\n#ifndef PERL_MICRO\n#include <signal.h>\n#ifndef SIG_ERR\n# define SIG_ERR ((Sighandler_t) -1)\n#endif\n#endif\n\n#include <math.h>\n#include <stdlib.h>\n\n#ifdef __Lynx__\n/* Missing protos on LynxOS */\nint putenv(char *);\n#endif\n\n#ifdef __amigaos__\n# include \"amigaos4/amigaio.h\"\n#endif\n\n#ifdef HAS_SELECT\n# ifdef I_SYS_SELECT\n#  include <sys/select.h>\n# endif\n#endif\n\n#ifdef USE_C_BACKTRACE\n#  ifdef I_BFD\n#    define USE_BFD\n#    ifdef PERL_DARWIN\n#      undef USE_BFD /* BFD is useless in OS X. */\n#    endif\n#    ifdef USE_BFD\n#      include <bfd.h>\n#    endif\n#  endif\n#  ifdef I_DLFCN\n#    include <dlfcn.h>\n#  endif\n#  ifdef I_EXECINFO\n#    include <execinfo.h>\n#  endif\n#endif\n\n#ifdef PERL_DEBUG_READONLY_COW\n# include <sys/mman.h>\n#endif\n\n#define FLUSH\n\n/* NOTE:  Do not call the next three routines directly.  Use the macros\n * in handy.h, so that we can easily redefine everything to do tracking of\n * allocated hunks back to the original New to track down any memory leaks.\n * XXX This advice seems to be widely ignored :-(   --AD  August 1996.\n */\n\n#if defined (DEBUGGING) || defined(PERL_IMPLICIT_SYS) || defined (PERL_TRACK_MEMPOOL)\n#  define ALWAYS_NEED_THX\n#endif\n\n#if defined(PERL_TRACK_MEMPOOL) && defined(PERL_DEBUG_READONLY_COW)\nstatic void\nS_maybe_protect_rw(pTHX_ struct perl_memory_debug_header *header)\n{\n    if (header->readonly\n     && mprotect(header, header->size, PROT_READ|PROT_WRITE))\n\tPerl_warn(aTHX_ \"mprotect for COW string %p %lu failed with %d\",\n\t\t\t header, header->size, errno);\n}\n\nstatic void\nS_maybe_protect_ro(pTHX_ struct perl_memory_debug_header *header)\n{\n    if (header->readonly\n     && mprotect(header, header->size, PROT_READ))\n\tPerl_warn(aTHX_ \"mprotect RW for COW string %p %lu failed with %d\",\n\t\t\t header, header->size, errno);\n}\n# define maybe_protect_rw(foo) S_maybe_protect_rw(aTHX_ foo)\n# define maybe_protect_ro(foo) S_maybe_protect_ro(aTHX_ foo)\n#else\n# define maybe_protect_rw(foo) NOOP\n# define maybe_protect_ro(foo) NOOP\n#endif\n\n#if defined(PERL_TRACK_MEMPOOL) || defined(PERL_DEBUG_READONLY_COW)\n /* Use memory_debug_header */\n# define USE_MDH\n# if (defined(PERL_POISON) && defined(PERL_TRACK_MEMPOOL)) \\\n   || defined(PERL_DEBUG_READONLY_COW)\n#  define MDH_HAS_SIZE\n# endif\n#endif\n\n/* paranoid version of system's malloc() */\n\nMalloc_t\nPerl_safesysmalloc(MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n\n#ifdef USE_MDH\n    if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)\n        goto out_of_memory;\n    size += PERL_MEMORY_DEBUG_HEADER_SIZE;\n#endif\n#ifdef DEBUGGING\n    if ((SSize_t)size < 0)\n\tPerl_croak_nocontext(\"panic: malloc, size=%\" UVuf, (UV) size);\n#endif\n    if (!size) size = 1;\t/* malloc(0) is NASTY on our system */\n#ifdef PERL_DEBUG_READONLY_COW\n    if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,\n\t\t    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\tperror(\"mmap failed\");\n\tabort();\n    }\n#else\n    ptr = (Malloc_t)PerlMem_malloc(size?size:1);\n#endif\n    PERL_ALLOC_CHECK(ptr);\n    if (ptr != NULL) {\n#ifdef USE_MDH\n\tstruct perl_memory_debug_header *const header\n\t    = (struct perl_memory_debug_header *)ptr;\n#endif\n\n#ifdef PERL_POISON\n\tPoisonNew(((char *)ptr), size, char);\n#endif\n\n#ifdef PERL_TRACK_MEMPOOL\n\theader->interpreter = aTHX;\n\t/* Link us into the list.  */\n\theader->prev = &PL_memory_debug_header;\n\theader->next = PL_memory_debug_header.next;\n\tPL_memory_debug_header.next = header;\n\tmaybe_protect_rw(header->next);\n\theader->next->prev = header;\n\tmaybe_protect_ro(header->next);\n#  ifdef PERL_DEBUG_READONLY_COW\n\theader->readonly = 0;\n#  endif\n#endif\n#ifdef MDH_HAS_SIZE\n\theader->size = size;\n#endif\n\tptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) malloc %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)size));\n\n    }\n    else {\n#ifdef USE_MDH\n      out_of_memory:\n#endif\n        {\n#ifndef ALWAYS_NEED_THX\n            dTHX;\n#endif\n            if (PL_nomemok)\n                ptr =  NULL;\n            else\n                croak_no_mem();\n        }\n    }\n    return ptr;\n}\n\n/* paranoid version of system's realloc() */\n\nMalloc_t\nPerl_safesysrealloc(Malloc_t where,MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n#ifdef PERL_DEBUG_READONLY_COW\n    const MEM_SIZE oldsize = where\n\t? ((struct perl_memory_debug_header *)((char *)where - PERL_MEMORY_DEBUG_HEADER_SIZE))->size\n\t: 0;\n#endif\n\n    if (!size) {\n\tsafesysfree(where);\n\tptr = NULL;\n    }\n    else if (!where) {\n\tptr = safesysmalloc(size);\n    }\n    else {\n#ifdef USE_MDH\n\twhere = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);\n        if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)\n            goto out_of_memory;\n\tsize += PERL_MEMORY_DEBUG_HEADER_SIZE;\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)where;\n\n# ifdef PERL_TRACK_MEMPOOL\n\t    if (header->interpreter != aTHX) {\n\t\tPerl_croak_nocontext(\"panic: realloc from wrong pool, %p!=%p\",\n\t\t\t\t     header->interpreter, aTHX);\n\t    }\n\t    assert(header->next->prev == header);\n\t    assert(header->prev->next == header);\n#  ifdef PERL_POISON\n\t    if (header->size > size) {\n\t\tconst MEM_SIZE freed_up = header->size - size;\n\t\tchar *start_of_freed = ((char *)where) + size;\n\t\tPoisonFree(start_of_freed, freed_up, char);\n\t    }\n#  endif\n# endif\n# ifdef MDH_HAS_SIZE\n\t    header->size = size;\n# endif\n\t}\n#endif\n#ifdef DEBUGGING\n\tif ((SSize_t)size < 0)\n\t    Perl_croak_nocontext(\"panic: realloc, size=%\" UVuf, (UV)size);\n#endif\n#ifdef PERL_DEBUG_READONLY_COW\n\tif ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,\n\t\t\tMAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\t    perror(\"mmap failed\");\n\t    abort();\n\t}\n\tCopy(where,ptr,oldsize < size ? oldsize : size,char);\n\tif (munmap(where, oldsize)) {\n\t    perror(\"munmap failed\");\n\t    abort();\n\t}\n#else\n\tptr = (Malloc_t)PerlMem_realloc(where,size);\n#endif\n\tPERL_ALLOC_CHECK(ptr);\n\n    /* MUST do this fixup first, before doing ANYTHING else, as anything else\n       might allocate memory/free/move memory, and until we do the fixup, it\n       may well be chasing (and writing to) free memory.  */\n\tif (ptr != NULL) {\n#ifdef PERL_TRACK_MEMPOOL\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)ptr;\n\n#  ifdef PERL_POISON\n\t    if (header->size < size) {\n\t\tconst MEM_SIZE fresh = size - header->size;\n\t\tchar *start_of_fresh = ((char *)ptr) + size;\n\t\tPoisonNew(start_of_fresh, fresh, char);\n\t    }\n#  endif\n\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header;\n\t    maybe_protect_ro(header->next);\n\t    maybe_protect_rw(header->prev);\n\t    header->prev->next = header;\n\t    maybe_protect_ro(header->prev);\n#endif\n\t    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t}\n\n    /* In particular, must do that fixup above before logging anything via\n     *printf(), as it can reallocate memory, which can cause SEGVs.  */\n\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) rfree\\n\",PTR2UV(where),(long)PL_an++));\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) realloc %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)size));\n\n\tif (ptr == NULL) {\n#ifdef USE_MDH\n          out_of_memory:\n#endif\n            {\n#ifndef ALWAYS_NEED_THX\n                dTHX;\n#endif\n                if (PL_nomemok)\n                    ptr = NULL;\n                else\n                    croak_no_mem();\n            }\n\t}\n    }\n    return ptr;\n}\n\n/* safe version of system's free() */\n\nFree_t\nPerl_safesysfree(Malloc_t where)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    DEBUG_m( PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) free\\n\",PTR2UV(where),(long)PL_an++));\n    if (where) {\n#ifdef USE_MDH\n\tMalloc_t where_intrn = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)where_intrn;\n\n# ifdef MDH_HAS_SIZE\n\t    const MEM_SIZE size = header->size;\n# endif\n# ifdef PERL_TRACK_MEMPOOL\n\t    if (header->interpreter != aTHX) {\n\t\tPerl_croak_nocontext(\"panic: free from wrong pool, %p!=%p\",\n\t\t\t\t     header->interpreter, aTHX);\n\t    }\n\t    if (!header->prev) {\n\t\tPerl_croak_nocontext(\"panic: duplicate free\");\n\t    }\n\t    if (!(header->next))\n\t\tPerl_croak_nocontext(\"panic: bad free, header->next==NULL\");\n\t    if (header->next->prev != header || header->prev->next != header) {\n\t\tPerl_croak_nocontext(\"panic: bad free, ->next->prev=%p, \"\n\t\t\t\t     \"header=%p, ->prev->next=%p\",\n\t\t\t\t     header->next->prev, header,\n\t\t\t\t     header->prev->next);\n\t    }\n\t    /* Unlink us from the chain.  */\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header->prev;\n\t    maybe_protect_ro(header->next);\n\t    maybe_protect_rw(header->prev);\n\t    header->prev->next = header->next;\n\t    maybe_protect_ro(header->prev);\n\t    maybe_protect_rw(header);\n#  ifdef PERL_POISON\n\t    PoisonNew(where_intrn, size, char);\n#  endif\n\t    /* Trigger the duplicate free warning.  */\n\t    header->next = NULL;\n# endif\n# ifdef PERL_DEBUG_READONLY_COW\n\t    if (munmap(where_intrn, size)) {\n\t\tperror(\"munmap failed\");\n\t\tabort();\n\t    }\t\n# endif\n\t}\n#else\n\tMalloc_t where_intrn = where;\n#endif /* USE_MDH */\n#ifndef PERL_DEBUG_READONLY_COW\n\tPerlMem_free(where_intrn);\n#endif\n    }\n}\n\n/* safe version of system's calloc() */\n\nMalloc_t\nPerl_safesyscalloc(MEM_SIZE count, MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n#if defined(USE_MDH) || defined(DEBUGGING)\n    MEM_SIZE total_size = 0;\n#endif\n\n    /* Even though calloc() for zero bytes is strange, be robust. */\n    if (size && (count <= MEM_SIZE_MAX / size)) {\n#if defined(USE_MDH) || defined(DEBUGGING)\n\ttotal_size = size * count;\n#endif\n    }\n    else\n\tcroak_memory_wrap();\n#ifdef USE_MDH\n    if (PERL_MEMORY_DEBUG_HEADER_SIZE <= MEM_SIZE_MAX - (MEM_SIZE)total_size)\n\ttotal_size += PERL_MEMORY_DEBUG_HEADER_SIZE;\n    else\n\tcroak_memory_wrap();\n#endif\n#ifdef DEBUGGING\n    if ((SSize_t)size < 0 || (SSize_t)count < 0)\n\tPerl_croak_nocontext(\"panic: calloc, size=%\" UVuf \", count=%\" UVuf,\n\t\t\t     (UV)size, (UV)count);\n#endif\n#ifdef PERL_DEBUG_READONLY_COW\n    if ((ptr = mmap(0, total_size ? total_size : 1, PROT_READ|PROT_WRITE,\n\t\t    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\tperror(\"mmap failed\");\n\tabort();\n    }\n#elif defined(PERL_TRACK_MEMPOOL)\n    /* Have to use malloc() because we've added some space for our tracking\n       header.  */\n    /* malloc(0) is non-portable. */\n    ptr = (Malloc_t)PerlMem_malloc(total_size ? total_size : 1);\n#else\n    /* Use calloc() because it might save a memset() if the memory is fresh\n       and clean from the OS.  */\n    if (count && size)\n\tptr = (Malloc_t)PerlMem_calloc(count, size);\n    else /* calloc(0) is non-portable. */\n\tptr = (Malloc_t)PerlMem_calloc(count ? count : 1, size ? size : 1);\n#endif\n    PERL_ALLOC_CHECK(ptr);\n    DEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) calloc %ld x %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)count,(long)total_size));\n    if (ptr != NULL) {\n#ifdef USE_MDH\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)ptr;\n\n#  ifndef PERL_DEBUG_READONLY_COW\n\t    memset((void*)ptr, 0, total_size);\n#  endif\n#  ifdef PERL_TRACK_MEMPOOL\n\t    header->interpreter = aTHX;\n\t    /* Link us into the list.  */\n\t    header->prev = &PL_memory_debug_header;\n\t    header->next = PL_memory_debug_header.next;\n\t    PL_memory_debug_header.next = header;\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header;\n\t    maybe_protect_ro(header->next);\n#    ifdef PERL_DEBUG_READONLY_COW\n\t    header->readonly = 0;\n#    endif\n#  endif\n#  ifdef MDH_HAS_SIZE\n\t    header->size = total_size;\n#  endif\n\t    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t}\n#endif\n\treturn ptr;\n    }\n    else {\n#ifndef ALWAYS_NEED_THX\n\tdTHX;\n#endif\n\tif (PL_nomemok)\n\t    return NULL;\n\tcroak_no_mem();\n    }\n}\n\n/* These must be defined when not using Perl's malloc for binary\n * compatibility */\n\n#ifndef MYMALLOC\n\nMalloc_t Perl_malloc (MEM_SIZE nbytes)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    return (Malloc_t)PerlMem_malloc(nbytes);\n}\n\nMalloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    return (Malloc_t)PerlMem_calloc(elements, size);\n}\n\nMalloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    return (Malloc_t)PerlMem_realloc(where, nbytes);\n}\n\nFree_t   Perl_mfree (Malloc_t where)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    PerlMem_free(where);\n}\n\n#endif\n\n/* copy a string up to some (non-backslashed) delimiter, if any.\n * With allow_escape, converts \\<delimiter> to <delimiter>, while leaves\n * \\<non-delimiter> as-is.\n * Returns the position in the src string of the closing delimiter, if\n * any, or returns fromend otherwise.\n * This is the internal implementation for Perl_delimcpy and\n * Perl_delimcpy_no_escape.\n */\n\nstatic char *\nS_delimcpy_intern(char *to, const char *toend, const char *from,\n\t   const char *fromend, int delim, I32 *retlen,\n\t   const bool allow_escape)\n{\n    I32 tolen;\n\n    PERL_ARGS_ASSERT_DELIMCPY;\n\n    for (tolen = 0; from < fromend; from++, tolen++) {\n\tif (allow_escape && *from == '\\\\' && from + 1 < fromend) {\n\t    if (from[1] != delim) {\n\t\tif (to < toend)\n\t\t    *to++ = *from;\n\t\ttolen++;\n\t    }\n\t    from++;\n\t}\n\telse if (*from == delim)\n\t    break;\n\tif (to < toend)\n\t    *to++ = *from;\n    }\n    if (to < toend)\n\t*to = '\\0';\n    *retlen = tolen;\n    return (char *)from;\n}\n\nchar *\nPerl_delimcpy(char *to, const char *toend, const char *from, const char *fromend, int delim, I32 *retlen)\n{\n    PERL_ARGS_ASSERT_DELIMCPY;\n\n    return S_delimcpy_intern(to, toend, from, fromend, delim, retlen, 1);\n}\n\nchar *\nPerl_delimcpy_no_escape(char *to, const char *toend, const char *from,\n\t\t\tconst char *fromend, int delim, I32 *retlen)\n{\n    PERL_ARGS_ASSERT_DELIMCPY_NO_ESCAPE;\n\n    return S_delimcpy_intern(to, toend, from, fromend, delim, retlen, 0);\n}\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc Am|char *|ninstr|char * big|char * bigend|char * little|char * little_end\n\nFind the first (leftmost) occurrence of a sequence of bytes within another\nsequence.  This is the Perl version of C<strstr()>, extended to handle\narbitrary sequences, potentially containing embedded C<NUL> characters (C<NUL>\nis what the initial C<n> in the function name stands for; some systems have an\nequivalent, C<memmem()>, but with a somewhat different API).\n\nAnother way of thinking about this function is finding a needle in a haystack.\nC<big> points to the first byte in the haystack.  C<big_end> points to one byte\nbeyond the final byte in the haystack.  C<little> points to the first byte in\nthe needle.  C<little_end> points to one byte beyond the final byte in the\nneedle.  All the parameters must be non-C<NULL>.\n\nThe function returns C<NULL> if there is no occurrence of C<little> within\nC<big>.  If C<little> is the empty string, C<big> is returned.\n\nBecause this function operates at the byte level, and because of the inherent\ncharacteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the\nneedle and the haystack are strings with the same UTF-8ness, but not if the\nUTF-8ness differs.\n\n=cut\n\n*/\n\nchar *\nPerl_ninstr(const char *big, const char *bigend, const char *little, const char *lend)\n{\n    PERL_ARGS_ASSERT_NINSTR;\n\n#ifdef HAS_MEMMEM\n    return ninstr(big, bigend, little, lend);\n#else\n\n    if (little >= lend)\n        return (char*)big;\n    {\n        const char first = *little;\n        bigend -= lend - little++;\n    OUTER:\n        while (big <= bigend) {\n            if (*big++ == first) {\n                const char *s, *x;\n                for (x=big,s=little; s < lend; x++,s++) {\n                    if (*s != *x)\n                        goto OUTER;\n                }\n                return (char*)(big-1);\n            }\n        }\n    }\n    return NULL;\n\n#endif\n\n}\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc Am|char *|rninstr|char * big|char * bigend|char * little|char * little_end\n\nLike C<L</ninstr>>, but instead finds the final (rightmost) occurrence of a\nsequence of bytes within another sequence, returning C<NULL> if there is no\nsuch occurrence.\n\n=cut\n\n*/\n\nchar *\nPerl_rninstr(const char *big, const char *bigend, const char *little, const char *lend)\n{\n    const char *bigbeg;\n    const I32 first = *little;\n    const char * const littleend = lend;\n\n    PERL_ARGS_ASSERT_RNINSTR;\n\n    if (little >= littleend)\n\treturn (char*)bigend;\n    bigbeg = big;\n    big = bigend - (littleend - little++);\n    while (big >= bigbeg) {\n\tconst char *s, *x;\n\tif (*big-- != first)\n\t    continue;\n\tfor (x=big+2,s=little; s < littleend; /**/ ) {\n\t    if (*s != *x)\n\t\tbreak;\n\t    else {\n\t\tx++;\n\t\ts++;\n\t    }\n\t}\n\tif (s >= littleend)\n\t    return (char*)(big+1);\n    }\n    return NULL;\n}\n\n/* As a space optimization, we do not compile tables for strings of length\n   0 and 1, and for strings of length 2 unless FBMcf_TAIL.  These are\n   special-cased in fbm_instr().\n\n   If FBMcf_TAIL, the table is created as if the string has a trailing \\n. */\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc fbm_compile\n\nAnalyzes the string in order to make fast searches on it using C<fbm_instr()>\n-- the Boyer-Moore algorithm.\n\n=cut\n*/\n\nvoid\nPerl_fbm_compile(pTHX_ SV *sv, U32 flags)\n{\n    const U8 *s;\n    STRLEN i;\n    STRLEN len;\n    U32 frequency = 256;\n    MAGIC *mg;\n    PERL_DEB( STRLEN rarest = 0 );\n\n    PERL_ARGS_ASSERT_FBM_COMPILE;\n\n    if (isGV_with_GP(sv) || SvROK(sv))\n\treturn;\n\n    if (SvVALID(sv))\n\treturn;\n\n    if (flags & FBMcf_TAIL) {\n\tMAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;\n\tsv_catpvs(sv, \"\\n\");\t\t/* Taken into account in fbm_instr() */\n\tif (mg && mg->mg_len >= 0)\n\t    mg->mg_len++;\n    }\n    if (!SvPOK(sv) || SvNIOKp(sv))\n\ts = (U8*)SvPV_force_mutable(sv, len);\n    else s = (U8 *)SvPV_mutable(sv, len);\n    if (len == 0)\t\t/* TAIL might be on a zero-length string. */\n\treturn;\n    SvUPGRADE(sv, SVt_PVMG);\n    SvIOK_off(sv);\n    SvNOK_off(sv);\n\n    /* add PERL_MAGIC_bm magic holding the FBM lookup table */\n\n    assert(!mg_find(sv, PERL_MAGIC_bm));\n    mg = sv_magicext(sv, NULL, PERL_MAGIC_bm, &PL_vtbl_bm, NULL, 0);\n    assert(mg);\n\n    if (len > 2) {\n\t/* Shorter strings are special-cased in Perl_fbm_instr(), and don't use\n\t   the BM table.  */\n\tconst U8 mlen = (len>255) ? 255 : (U8)len;\n\tconst unsigned char *const sb = s + len - mlen; /* first char (maybe) */\n\tU8 *table;\n\n\tNewx(table, 256, U8);\n\tmemset((void*)table, mlen, 256);\n\tmg->mg_ptr = (char *)table;\n\tmg->mg_len = 256;\n\n\ts += len - 1; /* last char */\n\ti = 0;\n\twhile (s >= sb) {\n\t    if (table[*s] == mlen)\n\t\ttable[*s] = (U8)i;\n\t    s--, i++;\n\t}\n    }\n\n    s = (const unsigned char*)(SvPVX_const(sv));\t/* deeper magic */\n    for (i = 0; i < len; i++) {\n\tif (PL_freq[s[i]] < frequency) {\n\t    PERL_DEB( rarest = i );\n\t    frequency = PL_freq[s[i]];\n\t}\n    }\n    BmUSEFUL(sv) = 100;\t\t\t/* Initial value */\n    ((XPVNV*)SvANY(sv))->xnv_u.xnv_bm_tail = cBOOL(flags & FBMcf_TAIL);\n    DEBUG_r(PerlIO_printf(Perl_debug_log, \"rarest char %c at %\" UVuf \"\\n\",\n\t\t\t  s[rarest], (UV)rarest));\n}\n\n\n/*\n=for apidoc fbm_instr\n\nReturns the location of the SV in the string delimited by C<big> and\nC<bigend> (C<bigend>) is the char following the last char).\nIt returns C<NULL> if the string can't be found.  The C<sv>\ndoes not have to be C<fbm_compiled>, but the search will not be as fast\nthen.\n\n=cut\n\nIf SvTAIL(littlestr) is true, a fake \"\\n\" was appended to to the string\nduring FBM compilation due to FBMcf_TAIL in flags. It indicates that\nthe littlestr must be anchored to the end of bigstr (or to any \\n if\nFBMrf_MULTILINE).\n\nE.g. The regex compiler would compile /abc/ to a littlestr of \"abc\",\nwhile /abc$/ compiles to \"abc\\n\" with SvTAIL() true.\n\nA littlestr of \"abc\", !SvTAIL matches as /abc/;\na littlestr of \"ab\\n\", SvTAIL matches as:\n   without FBMrf_MULTILINE: /ab\\n?\\z/\n   with    FBMrf_MULTILINE: /ab\\n/ || /ab\\z/;\n\n(According to Ilya from 1999; I don't know if this is still true, DAPM 2015):\n  \"If SvTAIL is actually due to \\Z or \\z, this gives false positives\n  if multiline\".\n*/\n\n\nchar *\nPerl_fbm_instr(pTHX_ unsigned char *big, unsigned char *bigend, SV *littlestr, U32 flags)\n{\n    unsigned char *s;\n    STRLEN l;\n    const unsigned char *little = (const unsigned char *)SvPV_const(littlestr,l);\n    STRLEN littlelen = l;\n    const I32 multiline = flags & FBMrf_MULTILINE;\n    bool valid = SvVALID(littlestr);\n    bool tail = valid ? cBOOL(SvTAIL(littlestr)) : FALSE;\n\n    PERL_ARGS_ASSERT_FBM_INSTR;\n\n    assert(bigend >= big);\n\n    if ((STRLEN)(bigend - big) < littlelen) {\n\tif (     tail\n\t     && ((STRLEN)(bigend - big) == littlelen - 1)\n\t     && (littlelen == 1\n\t\t || (*big == *little &&\n\t\t     memEQ((char *)big, (char *)little, littlelen - 1))))\n\t    return (char*)big;\n\treturn NULL;\n    }\n\n    switch (littlelen) { /* Special cases for 0, 1 and 2  */\n    case 0:\n\treturn (char*)big;\t\t/* Cannot be SvTAIL! */\n\n    case 1:\n\t    if (tail && !multiline) /* Anchor only! */\n\t\t/* [-1] is safe because we know that bigend != big.  */\n\t\treturn (char *) (bigend - (bigend[-1] == '\\n'));\n\n\t    s = (unsigned char *)memchr((void*)big, *little, bigend-big);\n            if (s)\n                return (char *)s;\n\t    if (tail)\n\t\treturn (char *) bigend;\n\t    return NULL;\n\n    case 2:\n\tif (tail && !multiline) {\n            /* a littlestr with SvTAIL must be of the form \"X\\n\" (where X\n             * is a single char). It is anchored, and can only match\n             * \"....X\\n\"  or  \"....X\" */\n            if (bigend[-2] == *little && bigend[-1] == '\\n')\n\t\treturn (char*)bigend - 2;\n\t    if (bigend[-1] == *little)\n\t\treturn (char*)bigend - 1;\n\t    return NULL;\n\t}\n\n\t{\n            /* memchr() is likely to be very fast, possibly using whatever\n             * hardware support is available, such as checking a whole\n             * cache line in one instruction.\n             * So for a 2 char pattern, calling memchr() is likely to be\n             * faster than running FBM, or rolling our own. The previous\n             * version of this code was roll-your-own which typically\n             * only needed to read every 2nd char, which was good back in\n             * the day, but no longer.\n             */\n\t    unsigned char c1 = little[0];\n\t    unsigned char c2 = little[1];\n\n            /* *** for all this case, bigend points to the last char,\n             * not the trailing \\0: this makes the conditions slightly\n             * simpler */\n            bigend--;\n\t    s = big;\n            if (c1 != c2) {\n                while (s < bigend) {\n                    /* do a quick test for c1 before calling memchr();\n                     * this avoids the expensive fn call overhead when\n                     * there are lots of c1's */\n                    if (LIKELY(*s != c1)) {\n                        s++;\n                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);\n                        if (!s)\n                            break;\n                    }\n                    if (s[1] == c2)\n                        return (char*)s;\n\n                    /* failed; try searching for c2 this time; that way\n                     * we don't go pathologically slow when the string\n                     * consists mostly of c1's or vice versa.\n                     */\n                    s += 2;\n                    if (s > bigend)\n                        break;\n                    s = (unsigned char *)memchr((void*)s, c2, bigend - s + 1);\n                    if (!s)\n                        break;\n                    if (s[-1] == c1)\n                        return (char*)s - 1;\n                }\n            }\n            else {\n                /* c1, c2 the same */\n                while (s < bigend) {\n                    if (s[0] == c1) {\n                      got_1char:\n                        if (s[1] == c1)\n                            return (char*)s;\n                        s += 2;\n                    }\n                    else {\n                        s++;\n                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);\n                        if (!s || s >= bigend)\n                            break;\n                        goto got_1char;\n                    }\n                }\n            }\n\n            /* failed to find 2 chars; try anchored match at end without\n             * the \\n */\n            if (tail && bigend[0] == little[0])\n                return (char *)bigend;\n            return NULL;\n        }\n\n    default:\n\tbreak; /* Only lengths 0 1 and 2 have special-case code.  */\n    }\n\n    if (tail && !multiline) {\t/* tail anchored? */\n\ts = bigend - littlelen;\n\tif (s >= big && bigend[-1] == '\\n' && *s == *little\n\t    /* Automatically of length > 2 */\n\t    && memEQ((char*)s + 1, (char*)little + 1, littlelen - 2))\n\t{\n\t    return (char*)s;\t\t/* how sweet it is */\n\t}\n\tif (s[1] == *little\n\t    && memEQ((char*)s + 2, (char*)little + 1, littlelen - 2))\n\t{\n\t    return (char*)s + 1;\t/* how sweet it is */\n\t}\n\treturn NULL;\n    }\n\n    if (!valid) {\n        /* not compiled; use Perl_ninstr() instead */\n\tchar * const b = ninstr((char*)big,(char*)bigend,\n\t\t\t (char*)little, (char*)little + littlelen);\n\n        assert(!tail); /* valid => FBM; tail only set on SvVALID SVs */\n\treturn b;\n    }\n\n    /* Do actual FBM.  */\n    if (littlelen > (STRLEN)(bigend - big))\n\treturn NULL;\n\n    {\n\tconst MAGIC *const mg = mg_find(littlestr, PERL_MAGIC_bm);\n\tconst unsigned char *oldlittle;\n\n\tassert(mg);\n\n\t--littlelen;\t\t\t/* Last char found by table lookup */\n\n\ts = big + littlelen;\n\tlittle += littlelen;\t\t/* last char */\n\toldlittle = little;\n\tif (s < bigend) {\n\t    const unsigned char * const table = (const unsigned char *) mg->mg_ptr;\n            const unsigned char lastc = *little;\n\t    I32 tmp;\n\n\t  top2:\n\t    if ((tmp = table[*s])) {\n                /* *s != lastc; earliest position it could match now is\n                 * tmp slots further on */\n\t\tif ((s += tmp) >= bigend)\n                    goto check_end;\n                if (LIKELY(*s != lastc)) {\n                    s++;\n                    s = (unsigned char *)memchr((void*)s, lastc, bigend - s);\n                    if (!s) {\n                        s = bigend;\n                        goto check_end;\n                    }\n                    goto top2;\n                }\n\t    }\n\n\n            /* hand-rolled strncmp(): less expensive than calling the\n             * real function (maybe???) */\n\t    {\n\t\tunsigned char * const olds = s;\n\n\t\ttmp = littlelen;\n\n\t\twhile (tmp--) {\n\t\t    if (*--s == *--little)\n\t\t\tcontinue;\n\t\t    s = olds + 1;\t/* here we pay the price for failure */\n\t\t    little = oldlittle;\n\t\t    if (s < bigend)\t/* fake up continue to outer loop */\n\t\t\tgoto top2;\n\t\t    goto check_end;\n\t\t}\n\t\treturn (char *)s;\n\t    }\n\t}\n      check_end:\n\tif ( s == bigend\n\t     && tail\n\t     && memEQ((char *)(bigend - littlelen),\n\t\t      (char *)(oldlittle - littlelen), littlelen) )\n\t    return (char*)bigend - littlelen;\n\treturn NULL;\n    }\n}\n\n/* copy a string to a safe spot */\n\n/*\n=head1 Memory Management\n\n=for apidoc savepv\n\nPerl's version of C<strdup()>.  Returns a pointer to a newly allocated\nstring which is a duplicate of C<pv>.  The size of the string is\ndetermined by C<strlen()>, which means it may not contain embedded C<NUL>\ncharacters and must have a trailing C<NUL>.  The memory allocated for the new\nstring can be freed with the C<Safefree()> function.\n\nOn some platforms, Windows for example, all allocated memory owned by a thread\nis deallocated when that thread ends.  So if you need that not to happen, you\nneed to use the shared memory functions, such as C<L</savesharedpv>>.\n\n=cut\n*/\n\nchar *\nPerl_savepv(pTHX_ const char *pv)\n{\n    PERL_UNUSED_CONTEXT;\n    if (!pv)\n\treturn NULL;\n    else {\n\tchar *newaddr;\n\tconst STRLEN pvlen = strlen(pv)+1;\n\tNewx(newaddr, pvlen, char);\n\treturn (char*)memcpy(newaddr, pv, pvlen);\n    }\n}\n\n/* same thing but with a known length */\n\n/*\n=for apidoc savepvn\n\nPerl's version of what C<strndup()> would be if it existed.  Returns a\npointer to a newly allocated string which is a duplicate of the first\nC<len> bytes from C<pv>, plus a trailing\nC<NUL> byte.  The memory allocated for\nthe new string can be freed with the C<Safefree()> function.\n\nOn some platforms, Windows for example, all allocated memory owned by a thread\nis deallocated when that thread ends.  So if you need that not to happen, you\nneed to use the shared memory functions, such as C<L</savesharedpvn>>.\n\n=cut\n*/\n\nchar *\nPerl_savepvn(pTHX_ const char *pv, I32 len)\n{\n    char *newaddr;\n    PERL_UNUSED_CONTEXT;\n\n    assert(len >= 0);\n\n    Newx(newaddr,len+1,char);\n    /* Give a meaning to NULL pointer mainly for the use in sv_magic() */\n    if (pv) {\n\t/* might not be null terminated */\n    \tnewaddr[len] = '\\0';\n    \treturn (char *) CopyD(pv,newaddr,len,char);\n    }\n    else {\n\treturn (char *) ZeroD(newaddr,len+1,char);\n    }\n}\n\n/*\n=for apidoc savesharedpv\n\nA version of C<savepv()> which allocates the duplicate string in memory\nwhich is shared between threads.\n\n=cut\n*/\nchar *\nPerl_savesharedpv(pTHX_ const char *pv)\n{\n    char *newaddr;\n    STRLEN pvlen;\n\n    PERL_UNUSED_CONTEXT;\n\n    if (!pv)\n\treturn NULL;\n\n    pvlen = strlen(pv)+1;\n    newaddr = (char*)PerlMemShared_malloc(pvlen);\n    if (!newaddr) {\n\tcroak_no_mem();\n    }\n    return (char*)memcpy(newaddr, pv, pvlen);\n}\n\n/*\n=for apidoc savesharedpvn\n\nA version of C<savepvn()> which allocates the duplicate string in memory\nwhich is shared between threads.  (With the specific difference that a C<NULL>\npointer is not acceptable)\n\n=cut\n*/\nchar *\nPerl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)\n{\n    char *const newaddr = (char*)PerlMemShared_malloc(len + 1);\n\n    PERL_UNUSED_CONTEXT;\n    /* PERL_ARGS_ASSERT_SAVESHAREDPVN; */\n\n    if (!newaddr) {\n\tcroak_no_mem();\n    }\n    newaddr[len] = '\\0';\n    return (char*)memcpy(newaddr, pv, len);\n}\n\n/*\n=for apidoc savesvpv\n\nA version of C<savepv()>/C<savepvn()> which gets the string to duplicate from\nthe passed in SV using C<SvPV()>\n\nOn some platforms, Windows for example, all allocated memory owned by a thread\nis deallocated when that thread ends.  So if you need that not to happen, you\nneed to use the shared memory functions, such as C<L</savesharedsvpv>>.\n\n=cut\n*/\n\nchar *\nPerl_savesvpv(pTHX_ SV *sv)\n{\n    STRLEN len;\n    const char * const pv = SvPV_const(sv, len);\n    char *newaddr;\n\n    PERL_ARGS_ASSERT_SAVESVPV;\n\n    ++len;\n    Newx(newaddr,len,char);\n    return (char *) CopyD(pv,newaddr,len,char);\n}\n\n/*\n=for apidoc savesharedsvpv\n\nA version of C<savesharedpv()> which allocates the duplicate string in\nmemory which is shared between threads.\n\n=cut\n*/\n\nchar *\nPerl_savesharedsvpv(pTHX_ SV *sv)\n{\n    STRLEN len;\n    const char * const pv = SvPV_const(sv, len);\n\n    PERL_ARGS_ASSERT_SAVESHAREDSVPV;\n\n    return savesharedpvn(pv, len);\n}\n\n/* the SV for Perl_form() and mess() is not kept in an arena */\n\nSTATIC SV *\nS_mess_alloc(pTHX)\n{\n    SV *sv;\n    XPVMG *any;\n\n    if (PL_phase != PERL_PHASE_DESTRUCT)\n\treturn newSVpvs_flags(\"\", SVs_TEMP);\n\n    if (PL_mess_sv)\n\treturn PL_mess_sv;\n\n    /* Create as PVMG now, to avoid any upgrading later */\n    Newx(sv, 1, SV);\n    Newxz(any, 1, XPVMG);\n    SvFLAGS(sv) = SVt_PVMG;\n    SvANY(sv) = (void*)any;\n    SvPV_set(sv, NULL);\n    SvREFCNT(sv) = 1 << 30; /* practically infinite */\n    PL_mess_sv = sv;\n    return sv;\n}\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nchar *\nPerl_form_nocontext(const char* pat, ...)\n{\n    dTHX;\n    char *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_FORM_NOCONTEXT;\n    va_start(args, pat);\n    retval = vform(pat, &args);\n    va_end(args);\n    return retval;\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\n/*\n=head1 Miscellaneous Functions\n=for apidoc form\n\nTakes a sprintf-style format pattern and conventional\n(non-SV) arguments and returns the formatted string.\n\n    (char *) Perl_form(pTHX_ const char* pat, ...)\n\ncan be used any place a string (char *) is required:\n\n    char * s = Perl_form(\"%d.%d\",major,minor);\n\nUses a single private buffer so if you want to format several strings you\nmust explicitly copy the earlier strings away (and free the copies when you\nare done).\n\n=cut\n*/\n\nchar *\nPerl_form(pTHX_ const char* pat, ...)\n{\n    char *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_FORM;\n    va_start(args, pat);\n    retval = vform(pat, &args);\n    va_end(args);\n    return retval;\n}\n\nchar *\nPerl_vform(pTHX_ const char *pat, va_list *args)\n{\n    SV * const sv = mess_alloc();\n    PERL_ARGS_ASSERT_VFORM;\n    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);\n    return SvPVX(sv);\n}\n\n/*\n=for apidoc Am|SV *|mess|const char *pat|...\n\nTake a sprintf-style format pattern and argument list.  These are used to\ngenerate a string message.  If the message does not end with a newline,\nthen it will be extended with some indication of the current location\nin the code, as described for L</mess_sv>.\n\nNormally, the resulting message is returned in a new mortal SV.\nDuring global destruction a single SV may be shared between uses of\nthis function.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nSV *\nPerl_mess_nocontext(const char *pat, ...)\n{\n    dTHX;\n    SV *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_MESS_NOCONTEXT;\n    va_start(args, pat);\n    retval = vmess(pat, &args);\n    va_end(args);\n    return retval;\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nSV *\nPerl_mess(pTHX_ const char *pat, ...)\n{\n    SV *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_MESS;\n    va_start(args, pat);\n    retval = vmess(pat, &args);\n    va_end(args);\n    return retval;\n}\n\nconst COP*\nPerl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop,\n\t\t       bool opnext)\n{\n    /* Look for curop starting from o.  cop is the last COP we've seen. */\n    /* opnext means that curop is actually the ->op_next of the op we are\n       seeking. */\n\n    PERL_ARGS_ASSERT_CLOSEST_COP;\n\n    if (!o || !curop || (\n\topnext ? o->op_next == curop && o->op_type != OP_SCOPE : o == curop\n    ))\n\treturn cop;\n\n    if (o->op_flags & OPf_KIDS) {\n\tconst OP *kid;\n\tfor (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {\n\t    const COP *new_cop;\n\n\t    /* If the OP_NEXTSTATE has been optimised away we can still use it\n\t     * the get the file and line number. */\n\n\t    if (kid->op_type == OP_NULL && kid->op_targ == OP_NEXTSTATE)\n\t\tcop = (const COP *)kid;\n\n\t    /* Keep searching, and return when we've found something. */\n\n\t    new_cop = closest_cop(cop, kid, curop, opnext);\n\t    if (new_cop)\n\t\treturn new_cop;\n\t}\n    }\n\n    /* Nothing found. */\n\n    return NULL;\n}\n\n/*\n=for apidoc Am|SV *|mess_sv|SV *basemsg|bool consume\n\nExpands a message, intended for the user, to include an indication of\nthe current location in the code, if the message does not already appear\nto be complete.\n\nC<basemsg> is the initial message or object.  If it is a reference, it\nwill be used as-is and will be the result of this function.  Otherwise it\nis used as a string, and if it already ends with a newline, it is taken\nto be complete, and the result of this function will be the same string.\nIf the message does not end with a newline, then a segment such as C<at\nfoo.pl line 37> will be appended, and possibly other clauses indicating\nthe current state of execution.  The resulting message will end with a\ndot and a newline.\n\nNormally, the resulting message is returned in a new mortal SV.\nDuring global destruction a single SV may be shared between uses of this\nfunction.  If C<consume> is true, then the function is permitted (but not\nrequired) to modify and return C<basemsg> instead of allocating a new SV.\n\n=cut\n*/\n\nSV *\nPerl_mess_sv(pTHX_ SV *basemsg, bool consume)\n{\n    SV *sv;\n\n#if defined(USE_C_BACKTRACE) && defined(USE_C_BACKTRACE_ON_ERROR)\n    {\n        char *ws;\n        UV wi;\n        /* The PERL_C_BACKTRACE_ON_WARN must be an integer of one or more. */\n        if ((ws = PerlEnv_getenv(\"PERL_C_BACKTRACE_ON_ERROR\"))\n            && grok_atoUV(ws, &wi, NULL)\n            && wi <= PERL_INT_MAX\n        ) {\n            Perl_dump_c_backtrace(aTHX_ Perl_debug_log, (int)wi, 1);\n        }\n    }\n#endif\n\n    PERL_ARGS_ASSERT_MESS_SV;\n\n    if (SvROK(basemsg)) {\n\tif (consume) {\n\t    sv = basemsg;\n\t}\n\telse {\n\t    sv = mess_alloc();\n\t    sv_setsv(sv, basemsg);\n\t}\n\treturn sv;\n    }\n\n    if (SvPOK(basemsg) && consume) {\n\tsv = basemsg;\n    }\n    else {\n\tsv = mess_alloc();\n\tsv_copypv(sv, basemsg);\n    }\n\n    if (!SvCUR(sv) || *(SvEND(sv) - 1) != '\\n') {\n\t/*\n\t * Try and find the file and line for PL_op.  This will usually be\n\t * PL_curcop, but it might be a cop that has been optimised away.  We\n\t * can try to find such a cop by searching through the optree starting\n\t * from the sibling of PL_curcop.\n\t */\n\n        if (PL_curcop) {\n            const COP *cop =\n                closest_cop(PL_curcop, OpSIBLING(PL_curcop), PL_op, FALSE);\n            if (!cop)\n                cop = PL_curcop;\n\n            if (CopLINE(cop))\n                Perl_sv_catpvf(aTHX_ sv, \" at %s line %\" IVdf,\n                                OutCopFILE(cop), (IV)CopLINE(cop));\n        }\n\n\t/* Seems that GvIO() can be untrustworthy during global destruction. */\n\tif (GvIO(PL_last_in_gv) && (SvTYPE(GvIOp(PL_last_in_gv)) == SVt_PVIO)\n\t\t&& IoLINES(GvIOp(PL_last_in_gv)))\n\t{\n\t    STRLEN l;\n\t    const bool line_mode = (RsSIMPLE(PL_rs) &&\n\t\t\t\t   *SvPV_const(PL_rs,l) == '\\n' && l == 1);\n\t    Perl_sv_catpvf(aTHX_ sv, \", <%\" SVf \"> %s %\" IVdf,\n\t\t\t   SVfARG(PL_last_in_gv == PL_argvgv\n                                 ? &PL_sv_no\n                                 : sv_2mortal(newSVhek(GvNAME_HEK(PL_last_in_gv)))),\n\t\t\t   line_mode ? \"line\" : \"chunk\",\n\t\t\t   (IV)IoLINES(GvIOp(PL_last_in_gv)));\n\t}\n\tif (PL_phase == PERL_PHASE_DESTRUCT)\n\t    sv_catpvs(sv, \" during global destruction\");\n\tsv_catpvs(sv, \".\\n\");\n    }\n    return sv;\n}\n\n/*\n=for apidoc Am|SV *|vmess|const char *pat|va_list *args\n\nC<pat> and C<args> are a sprintf-style format pattern and encapsulated\nargument list, respectively.  These are used to generate a string message.  If\nthe\nmessage does not end with a newline, then it will be extended with\nsome indication of the current location in the code, as described for\nL</mess_sv>.\n\nNormally, the resulting message is returned in a new mortal SV.\nDuring global destruction a single SV may be shared between uses of\nthis function.\n\n=cut\n*/\n\nSV *\nPerl_vmess(pTHX_ const char *pat, va_list *args)\n{\n    SV * const sv = mess_alloc();\n\n    PERL_ARGS_ASSERT_VMESS;\n\n    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);\n    return mess_sv(sv, 1);\n}\n\nvoid\nPerl_write_to_stderr(pTHX_ SV* msv)\n{\n    IO *io;\n    MAGIC *mg;\n\n    PERL_ARGS_ASSERT_WRITE_TO_STDERR;\n\n    if (PL_stderrgv && SvREFCNT(PL_stderrgv) \n\t&& (io = GvIO(PL_stderrgv))\n\t&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) \n\tPerl_magic_methcall(aTHX_ MUTABLE_SV(io), mg, SV_CONST(PRINT),\n\t\t\t    G_SCALAR | G_DISCARD | G_WRITING_TO_STDERR, 1, msv);\n    else {\n\tPerlIO * const serr = Perl_error_log;\n\n\tdo_print(msv, serr);\n\t(void)PerlIO_flush(serr);\n    }\n}\n\n/*\n=head1 Warning and Dieing\n*/\n\n/* Common code used in dieing and warning */\n\nSTATIC SV *\nS_with_queued_errors(pTHX_ SV *ex)\n{\n    PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS;\n    if (PL_errors && SvCUR(PL_errors) && !SvROK(ex)) {\n\tsv_catsv(PL_errors, ex);\n\tex = sv_mortalcopy(PL_errors);\n\tSvCUR_set(PL_errors, 0);\n    }\n    return ex;\n}\n\nSTATIC bool\nS_invoke_exception_hook(pTHX_ SV *ex, bool warn)\n{\n    HV *stash;\n    GV *gv;\n    CV *cv;\n    SV **const hook = warn ? &PL_warnhook : &PL_diehook;\n    /* sv_2cv might call Perl_croak() or Perl_warner() */\n    SV * const oldhook = *hook;\n\n    if (!oldhook)\n\treturn FALSE;\n\n    ENTER;\n    SAVESPTR(*hook);\n    *hook = NULL;\n    cv = sv_2cv(oldhook, &stash, &gv, 0);\n    LEAVE;\n    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {\n\tdSP;\n\tSV *exarg;\n\n\tENTER;\n\tsave_re_context();\n\tif (warn) {\n\t    SAVESPTR(*hook);\n\t    *hook = NULL;\n\t}\n\texarg = newSVsv(ex);\n\tSvREADONLY_on(exarg);\n\tSAVEFREESV(exarg);\n\n\tPUSHSTACKi(warn ? PERLSI_WARNHOOK : PERLSI_DIEHOOK);\n\tPUSHMARK(SP);\n\tXPUSHs(exarg);\n\tPUTBACK;\n\tcall_sv(MUTABLE_SV(cv), G_DISCARD);\n\tPOPSTACK;\n\tLEAVE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n=for apidoc Am|OP *|die_sv|SV *baseex\n\nBehaves the same as L</croak_sv>, except for the return type.\nIt should be used only where the C<OP *> return type is required.\nThe function never actually returns.\n\n=cut\n*/\n\n#ifdef _MSC_VER\n#  pragma warning( push )\n#  pragma warning( disable : 4646 ) /* warning C4646: function declared with\n    __declspec(noreturn) has non-void return type */\n#  pragma warning( disable : 4645 ) /* warning C4645: function declared with\n__declspec(noreturn) has a return statement */\n#endif\nOP *\nPerl_die_sv(pTHX_ SV *baseex)\n{\n    PERL_ARGS_ASSERT_DIE_SV;\n    croak_sv(baseex);\n    /* NOTREACHED */\n    NORETURN_FUNCTION_END;\n}\n#ifdef _MSC_VER\n#  pragma warning( pop )\n#endif\n\n/*\n=for apidoc Am|OP *|die|const char *pat|...\n\nBehaves the same as L</croak>, except for the return type.\nIt should be used only where the C<OP *> return type is required.\nThe function never actually returns.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\n#ifdef _MSC_VER\n#  pragma warning( push )\n#  pragma warning( disable : 4646 ) /* warning C4646: function declared with\n    __declspec(noreturn) has non-void return type */\n#  pragma warning( disable : 4645 ) /* warning C4645: function declared with\n__declspec(noreturn) has a return statement */\n#endif\nOP *\nPerl_die_nocontext(const char* pat, ...)\n{\n    dTHX;\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n    NORETURN_FUNCTION_END;\n}\n#ifdef _MSC_VER\n#  pragma warning( pop )\n#endif\n#endif /* PERL_IMPLICIT_CONTEXT */\n\n#ifdef _MSC_VER\n#  pragma warning( push )\n#  pragma warning( disable : 4646 ) /* warning C4646: function declared with\n    __declspec(noreturn) has non-void return type */\n#  pragma warning( disable : 4645 ) /* warning C4645: function declared with\n__declspec(noreturn) has a return statement */\n#endif\nOP *\nPerl_die(pTHX_ const char* pat, ...)\n{\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n    NORETURN_FUNCTION_END;\n}\n#ifdef _MSC_VER\n#  pragma warning( pop )\n#endif\n\n/*\n=for apidoc Am|void|croak_sv|SV *baseex\n\nThis is an XS interface to Perl's C<die> function.\n\nC<baseex> is the error message or object.  If it is a reference, it\nwill be used as-is.  Otherwise it is used as a string, and if it does\nnot end with a newline then it will be extended with some indication of\nthe current location in the code, as described for L</mess_sv>.\n\nThe error message or object will be used as an exception, by default\nreturning control to the nearest enclosing C<eval>, but subject to\nmodification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak_sv>\nfunction never returns normally.\n\nTo die with a simple string message, the L</croak> function may be\nmore convenient.\n\n=cut\n*/\n\nvoid\nPerl_croak_sv(pTHX_ SV *baseex)\n{\n    SV *ex = with_queued_errors(mess_sv(baseex, 0));\n    PERL_ARGS_ASSERT_CROAK_SV;\n    invoke_exception_hook(ex, FALSE);\n    die_unwind(ex);\n}\n\n/*\n=for apidoc Am|void|vcroak|const char *pat|va_list *args\n\nThis is an XS interface to Perl's C<die> function.\n\nC<pat> and C<args> are a sprintf-style format pattern and encapsulated\nargument list.  These are used to generate a string message.  If the\nmessage does not end with a newline, then it will be extended with\nsome indication of the current location in the code, as described for\nL</mess_sv>.\n\nThe error message will be used as an exception, by default\nreturning control to the nearest enclosing C<eval>, but subject to\nmodification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>\nfunction never returns normally.\n\nFor historical reasons, if C<pat> is null then the contents of C<ERRSV>\n(C<$@>) will be used as an error message or object instead of building an\nerror message from arguments.  If you want to throw a non-string object,\nor build an error message in an SV yourself, it is preferable to use\nthe L</croak_sv> function, which does not involve clobbering C<ERRSV>.\n\n=cut\n*/\n\nvoid\nPerl_vcroak(pTHX_ const char* pat, va_list *args)\n{\n    SV *ex = with_queued_errors(pat ? vmess(pat, args) : mess_sv(ERRSV, 0));\n    invoke_exception_hook(ex, FALSE);\n    die_unwind(ex);\n}\n\n/*\n=for apidoc Am|void|croak|const char *pat|...\n\nThis is an XS interface to Perl's C<die> function.\n\nTake a sprintf-style format pattern and argument list.  These are used to\ngenerate a string message.  If the message does not end with a newline,\nthen it will be extended with some indication of the current location\nin the code, as described for L</mess_sv>.\n\nThe error message will be used as an exception, by default\nreturning control to the nearest enclosing C<eval>, but subject to\nmodification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>\nfunction never returns normally.\n\nFor historical reasons, if C<pat> is null then the contents of C<ERRSV>\n(C<$@>) will be used as an error message or object instead of building an\nerror message from arguments.  If you want to throw a non-string object,\nor build an error message in an SV yourself, it is preferable to use\nthe L</croak_sv> function, which does not involve clobbering C<ERRSV>.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nvoid\nPerl_croak_nocontext(const char *pat, ...)\n{\n    dTHX;\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nvoid\nPerl_croak(pTHX_ const char *pat, ...)\n{\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n}\n\n/*\n=for apidoc Am|void|croak_no_modify\n\nExactly equivalent to C<Perl_croak(aTHX_ \"%s\", PL_no_modify)>, but generates\nterser object code than using C<Perl_croak>.  Less code used on exception code\npaths reduces CPU cache pressure.\n\n=cut\n*/\n\nvoid\nPerl_croak_no_modify(void)\n{\n    Perl_croak_nocontext( \"%s\", PL_no_modify);\n}\n\n/* does not return, used in util.c perlio.c and win32.c\n   This is typically called when malloc returns NULL.\n*/\nvoid\nPerl_croak_no_mem(void)\n{\n    dTHX;\n\n    int fd = PerlIO_fileno(Perl_error_log);\n    if (fd < 0)\n        SETERRNO(EBADF,RMS_IFI);\n    else {\n        /* Can't use PerlIO to write as it allocates memory */\n        PERL_UNUSED_RESULT(PerlLIO_write(fd, PL_no_mem, sizeof(PL_no_mem)-1));\n    }\n    my_exit(1);\n}\n\n/* does not return, used only in POPSTACK */\nvoid\nPerl_croak_popstack(void)\n{\n    dTHX;\n    PerlIO_printf(Perl_error_log, \"panic: POPSTACK\\n\");\n    my_exit(1);\n}\n\n/*\n=for apidoc Am|void|warn_sv|SV *baseex\n\nThis is an XS interface to Perl's C<warn> function.\n\nC<baseex> is the error message or object.  If it is a reference, it\nwill be used as-is.  Otherwise it is used as a string, and if it does\nnot end with a newline then it will be extended with some indication of\nthe current location in the code, as described for L</mess_sv>.\n\nThe error message or object will by default be written to standard error,\nbut this is subject to modification by a C<$SIG{__WARN__}> handler.\n\nTo warn with a simple string message, the L</warn> function may be\nmore convenient.\n\n=cut\n*/\n\nvoid\nPerl_warn_sv(pTHX_ SV *baseex)\n{\n    SV *ex = mess_sv(baseex, 0);\n    PERL_ARGS_ASSERT_WARN_SV;\n    if (!invoke_exception_hook(ex, TRUE))\n\twrite_to_stderr(ex);\n}\n\n/*\n=for apidoc Am|void|vwarn|const char *pat|va_list *args\n\nThis is an XS interface to Perl's C<warn> function.\n\nC<pat> and C<args> are a sprintf-style format pattern and encapsulated\nargument list.  These are used to generate a string message.  If the\nmessage does not end with a newline, then it will be extended with\nsome indication of the current location in the code, as described for\nL</mess_sv>.\n\nThe error message or object will by default be written to standard error,\nbut this is subject to modification by a C<$SIG{__WARN__}> handler.\n\nUnlike with L</vcroak>, C<pat> is not permitted to be null.\n\n=cut\n*/\n\nvoid\nPerl_vwarn(pTHX_ const char* pat, va_list *args)\n{\n    SV *ex = vmess(pat, args);\n    PERL_ARGS_ASSERT_VWARN;\n    if (!invoke_exception_hook(ex, TRUE))\n\twrite_to_stderr(ex);\n}\n\n/*\n=for apidoc Am|void|warn|const char *pat|...\n\nThis is an XS interface to Perl's C<warn> function.\n\nTake a sprintf-style format pattern and argument list.  These are used to\ngenerate a string message.  If the message does not end with a newline,\nthen it will be extended with some indication of the current location\nin the code, as described for L</mess_sv>.\n\nThe error message or object will by default be written to standard error,\nbut this is subject to modification by a C<$SIG{__WARN__}> handler.\n\nUnlike with L</croak>, C<pat> is not permitted to be null.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nvoid\nPerl_warn_nocontext(const char *pat, ...)\n{\n    dTHX;\n    va_list args;\n    PERL_ARGS_ASSERT_WARN_NOCONTEXT;\n    va_start(args, pat);\n    vwarn(pat, &args);\n    va_end(args);\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nvoid\nPerl_warn(pTHX_ const char *pat, ...)\n{\n    va_list args;\n    PERL_ARGS_ASSERT_WARN;\n    va_start(args, pat);\n    vwarn(pat, &args);\n    va_end(args);\n}\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nvoid\nPerl_warner_nocontext(U32 err, const char *pat, ...)\n{\n    dTHX; \n    va_list args;\n    PERL_ARGS_ASSERT_WARNER_NOCONTEXT;\n    va_start(args, pat);\n    vwarner(err, pat, &args);\n    va_end(args);\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nvoid\nPerl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)\n{\n    PERL_ARGS_ASSERT_CK_WARNER_D;\n\n    if (Perl_ckwarn_d(aTHX_ err)) {\n\tva_list args;\n\tva_start(args, pat);\n\tvwarner(err, pat, &args);\n\tva_end(args);\n    }\n}\n\nvoid\nPerl_ck_warner(pTHX_ U32 err, const char* pat, ...)\n{\n    PERL_ARGS_ASSERT_CK_WARNER;\n\n    if (Perl_ckwarn(aTHX_ err)) {\n\tva_list args;\n\tva_start(args, pat);\n\tvwarner(err, pat, &args);\n\tva_end(args);\n    }\n}\n\nvoid\nPerl_warner(pTHX_ U32  err, const char* pat,...)\n{\n    va_list args;\n    PERL_ARGS_ASSERT_WARNER;\n    va_start(args, pat);\n    vwarner(err, pat, &args);\n    va_end(args);\n}\n\nvoid\nPerl_vwarner(pTHX_ U32  err, const char* pat, va_list* args)\n{\n    dVAR;\n    PERL_ARGS_ASSERT_VWARNER;\n    if (\n        (PL_warnhook == PERL_WARNHOOK_FATAL || ckDEAD(err)) &&\n        !(PL_in_eval & EVAL_KEEPERR)\n    ) {\n\tSV * const msv = vmess(pat, args);\n\n\tif (PL_parser && PL_parser->error_count) {\n\t    qerror(msv);\n\t}\n\telse {\n\t    invoke_exception_hook(msv, FALSE);\n\t    die_unwind(msv);\n\t}\n    }\n    else {\n\tPerl_vwarn(aTHX_ pat, args);\n    }\n}\n\n/* implements the ckWARN? macros */\n\nbool\nPerl_ckwarn(pTHX_ U32 w)\n{\n    /* If lexical warnings have not been set, use $^W.  */\n    if (isLEXWARN_off)\n\treturn PL_dowarn & G_WARN_ON;\n\n    return ckwarn_common(w);\n}\n\n/* implements the ckWARN?_d macro */\n\nbool\nPerl_ckwarn_d(pTHX_ U32 w)\n{\n    /* If lexical warnings have not been set then default classes warn.  */\n    if (isLEXWARN_off)\n\treturn TRUE;\n\n    return ckwarn_common(w);\n}\n\nstatic bool\nS_ckwarn_common(pTHX_ U32 w)\n{\n    if (PL_curcop->cop_warnings == pWARN_ALL)\n\treturn TRUE;\n\n    if (PL_curcop->cop_warnings == pWARN_NONE)\n\treturn FALSE;\n\n    /* Check the assumption that at least the first slot is non-zero.  */\n    assert(unpackWARN1(w));\n\n    /* Check the assumption that it is valid to stop as soon as a zero slot is\n       seen.  */\n    if (!unpackWARN2(w)) {\n\tassert(!unpackWARN3(w));\n\tassert(!unpackWARN4(w));\n    } else if (!unpackWARN3(w)) {\n\tassert(!unpackWARN4(w));\n    }\n\t\n    /* Right, dealt with all the special cases, which are implemented as non-\n       pointers, so there is a pointer to a real warnings mask.  */\n    do {\n\tif (isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w)))\n\t    return TRUE;\n    } while (w >>= WARNshift);\n\n    return FALSE;\n}\n\n/* Set buffer=NULL to get a new one.  */\nSTRLEN *\nPerl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits,\n\t\t\t   STRLEN size) {\n    const MEM_SIZE len_wanted =\n\tsizeof(STRLEN) + (size > WARNsize ? size : WARNsize);\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD;\n\n    buffer = (STRLEN*)\n\t(specialWARN(buffer) ?\n\t PerlMemShared_malloc(len_wanted) :\n\t PerlMemShared_realloc(buffer, len_wanted));\n    buffer[0] = size;\n    Copy(bits, (buffer + 1), size, char);\n    if (size < WARNsize)\n\tZero((char *)(buffer + 1) + size, WARNsize - size, char);\n    return buffer;\n}\n\n/* since we've already done strlen() for both nam and val\n * we can use that info to make things faster than\n * sprintf(s, \"%s=%s\", nam, val)\n */\n#define my_setenv_format(s, nam, nlen, val, vlen) \\\n   Copy(nam, s, nlen, char); \\\n   *(s+nlen) = '='; \\\n   Copy(val, s+(nlen+1), vlen, char); \\\n   *(s+(nlen+1+vlen)) = '\\0'\n\n#ifdef USE_ENVIRON_ARRAY\n       /* VMS' my_setenv() is in vms.c */\n#if !defined(WIN32) && !defined(NETWARE)\nvoid\nPerl_my_setenv(pTHX_ const char *nam, const char *val)\n{\n  dVAR;\n#ifdef __amigaos4__\n  amigaos4_obtain_environ(__FUNCTION__);\n#endif\n#ifdef USE_ITHREADS\n  /* only parent thread can modify process environment */\n  if (PL_curinterp == aTHX)\n#endif\n  {\n#ifndef PERL_USE_SAFE_PUTENV\n    if (!PL_use_safe_putenv) {\n        /* most putenv()s leak, so we manipulate environ directly */\n        I32 i;\n        const I32 len = strlen(nam);\n        int nlen, vlen;\n\n        /* where does it go? */\n        for (i = 0; environ[i]; i++) {\n            if (strnEQ(environ[i],nam,len) && environ[i][len] == '=')\n                break;\n        }\n\n        if (environ == PL_origenviron) {   /* need we copy environment? */\n            I32 j;\n            I32 max;\n            char **tmpenv;\n\n            max = i;\n            while (environ[max])\n                max++;\n            tmpenv = (char**)safesysmalloc((max+2) * sizeof(char*));\n            for (j=0; j<max; j++) {         /* copy environment */\n                const int len = strlen(environ[j]);\n                tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));\n                Copy(environ[j], tmpenv[j], len+1, char);\n            }\n            tmpenv[max] = NULL;\n            environ = tmpenv;               /* tell exec where it is now */\n        }\n        if (!val) {\n            safesysfree(environ[i]);\n            while (environ[i]) {\n                environ[i] = environ[i+1];\n                i++;\n            }\n#ifdef __amigaos4__\n            goto my_setenv_out;\n#else\n            return;\n#endif\n        }\n        if (!environ[i]) {                 /* does not exist yet */\n            environ = (char**)safesysrealloc(environ, (i+2) * sizeof(char*));\n            environ[i+1] = NULL;    /* make sure it's null terminated */\n        }\n        else\n            safesysfree(environ[i]);\n        nlen = strlen(nam);\n        vlen = strlen(val);\n\n        environ[i] = (char*)safesysmalloc((nlen+vlen+2) * sizeof(char));\n        /* all that work just for this */\n        my_setenv_format(environ[i], nam, nlen, val, vlen);\n    } else {\n# endif\n    /* This next branch should only be called #if defined(HAS_SETENV), but\n       Configure doesn't test for that yet.  For Solaris, setenv() and unsetenv()\n       were introduced in Solaris 9, so testing for HAS UNSETENV is sufficient.\n    */\n#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__) || (defined(__sun) && defined(HAS_UNSETENV)) || defined(PERL_DARWIN)\n#       if defined(HAS_UNSETENV)\n        if (val == NULL) {\n            (void)unsetenv(nam);\n        } else {\n            (void)setenv(nam, val, 1);\n        }\n#       else /* ! HAS_UNSETENV */\n        (void)setenv(nam, val, 1);\n#       endif /* HAS_UNSETENV */\n#   elif defined(HAS_UNSETENV)\n        if (val == NULL) {\n            if (environ) /* old glibc can crash with null environ */\n                (void)unsetenv(nam);\n        } else {\n\t    const int nlen = strlen(nam);\n\t    const int vlen = strlen(val);\n\t    char * const new_env =\n                (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));\n            my_setenv_format(new_env, nam, nlen, val, vlen);\n            (void)putenv(new_env);\n        }\n#   else /* ! HAS_UNSETENV */\n        char *new_env;\n\tconst int nlen = strlen(nam);\n\tint vlen;\n        if (!val) {\n\t   val = \"\";\n        }\n        vlen = strlen(val);\n        new_env = (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));\n        /* all that work just for this */\n        my_setenv_format(new_env, nam, nlen, val, vlen);\n        (void)putenv(new_env);\n#   endif /* __CYGWIN__ */\n#ifndef PERL_USE_SAFE_PUTENV\n    }\n#endif\n  }\n#ifdef __amigaos4__\nmy_setenv_out:\n  amigaos4_release_environ(__FUNCTION__);\n#endif\n}\n\n#else /* WIN32 || NETWARE */\n\nvoid\nPerl_my_setenv(pTHX_ const char *nam, const char *val)\n{\n    dVAR;\n    char *envstr;\n    const int nlen = strlen(nam);\n    int vlen;\n\n    if (!val) {\n       val = \"\";\n    }\n    vlen = strlen(val);\n    Newx(envstr, nlen+vlen+2, char);\n    my_setenv_format(envstr, nam, nlen, val, vlen);\n    (void)PerlEnv_putenv(envstr);\n    Safefree(envstr);\n}\n\n#endif /* WIN32 || NETWARE */\n\n#endif /* !VMS */\n\n#ifdef UNLINK_ALL_VERSIONS\nI32\nPerl_unlnk(pTHX_ const char *f)\t/* unlink all versions of a file */\n{\n    I32 retries = 0;\n\n    PERL_ARGS_ASSERT_UNLNK;\n\n    while (PerlLIO_unlink(f) >= 0)\n\tretries++;\n    return retries ? 0 : -1;\n}\n#endif\n\nPerlIO *\nPerl_my_popen_list(pTHX_ const char *mode, int n, SV **args)\n{\n#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(OS2) && !defined(VMS) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)\n    int p[2];\n    I32 This, that;\n    Pid_t pid;\n    SV *sv;\n    I32 did_pipes = 0;\n    int pp[2];\n\n    PERL_ARGS_ASSERT_MY_POPEN_LIST;\n\n    PERL_FLUSHALL_FOR_CHILD;\n    This = (*mode == 'w');\n    that = !This;\n    if (TAINTING_get) {\n\ttaint_env();\n\ttaint_proper(\"Insecure %s%s\", \"EXEC\");\n    }\n    if (PerlProc_pipe_cloexec(p) < 0)\n\treturn NULL;\n    /* Try for another pipe pair for error return */\n    if (PerlProc_pipe_cloexec(pp) >= 0)\n\tdid_pipes = 1;\n    while ((pid = PerlProc_fork()) < 0) {\n\tif (errno != EAGAIN) {\n\t    PerlLIO_close(p[This]);\n\t    PerlLIO_close(p[that]);\n\t    if (did_pipes) {\n\t\tPerlLIO_close(pp[0]);\n\t\tPerlLIO_close(pp[1]);\n\t    }\n\t    return NULL;\n\t}\n\tPerl_ck_warner(aTHX_ packWARN(WARN_PIPE), \"Can't fork, trying again in 5 seconds\");\n\tsleep(5);\n    }\n    if (pid == 0) {\n\t/* Child */\n#undef THIS\n#undef THAT\n#define THIS that\n#define THAT This\n\t/* Close parent's end of error status pipe (if any) */\n\tif (did_pipes)\n\t    PerlLIO_close(pp[0]);\n\t/* Now dup our end of _the_ pipe to right position */\n\tif (p[THIS] != (*mode == 'r')) {\n\t    PerlLIO_dup2(p[THIS], *mode == 'r');\n\t    PerlLIO_close(p[THIS]);\n\t    if (p[THAT] != (*mode == 'r'))\t/* if dup2() didn't close it */\n\t\tPerlLIO_close(p[THAT]);\t/* close parent's end of _the_ pipe */\n\t}\n\telse\n\t    PerlLIO_close(p[THAT]);\t/* close parent's end of _the_ pipe */\n#if !defined(HAS_FCNTL) || !defined(F_SETFD)\n\t/* No automatic close - do it by hand */\n#  ifndef NOFILE\n#  define NOFILE 20\n#  endif\n\t{\n\t    int fd;\n\n\t    for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++) {\n\t\tif (fd != pp[1])\n\t\t    PerlLIO_close(fd);\n\t    }\n\t}\n#endif\n\tdo_aexec5(NULL, args-1, args-1+n, pp[1], did_pipes);\n\tPerlProc__exit(1);\n#undef THIS\n#undef THAT\n    }\n    /* Parent */\n    if (did_pipes)\n\tPerlLIO_close(pp[1]);\n    /* Keep the lower of the two fd numbers */\n    if (p[that] < p[This]) {\n\tPerlLIO_dup2_cloexec(p[This], p[that]);\n\tPerlLIO_close(p[This]);\n\tp[This] = p[that];\n    }\n    else\n\tPerlLIO_close(p[that]);\t\t/* close child's end of pipe */\n\n    sv = *av_fetch(PL_fdpid,p[This],TRUE);\n    SvUPGRADE(sv,SVt_IV);\n    SvIV_set(sv, pid);\n    PL_forkprocess = pid;\n    /* If we managed to get status pipe check for exec fail */\n    if (did_pipes && pid > 0) {\n\tint errkid;\n\tunsigned n = 0;\n\n\twhile (n < sizeof(int)) {\n            const SSize_t n1 = PerlLIO_read(pp[0],\n\t\t\t      (void*)(((char*)&errkid)+n),\n\t\t\t      (sizeof(int)) - n);\n\t    if (n1 <= 0)\n\t\tbreak;\n\t    n += n1;\n\t}\n\tPerlLIO_close(pp[0]);\n\tdid_pipes = 0;\n\tif (n) {\t\t\t/* Error */\n\t    int pid2, status;\n\t    PerlLIO_close(p[This]);\n\t    if (n != sizeof(int))\n\t\tPerl_croak(aTHX_ \"panic: kid popen errno read, n=%u\", n);\n\t    do {\n\t\tpid2 = wait4pid(pid, &status, 0);\n\t    } while (pid2 == -1 && errno == EINTR);\n\t    errno = errkid;\t\t/* Propagate errno from kid */\n\t    return NULL;\n\t}\n    }\n    if (did_pipes)\n\t PerlLIO_close(pp[0]);\n    return PerlIO_fdopen(p[This], mode);\n#else\n#  if defined(OS2)\t/* Same, without fork()ing and all extra overhead... */\n    return my_syspopen4(aTHX_ NULL, mode, n, args);\n#  elif defined(WIN32)\n    return win32_popenlist(mode, n, args);\n#  else\n    Perl_croak(aTHX_ \"List form of piped open not implemented\");\n    return (PerlIO *) NULL;\n#  endif\n#endif\n}\n\n    /* VMS' my_popen() is in VMS.c, same with OS/2 and AmigaOS 4. */\n#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)\nPerlIO *\nPerl_my_popen(pTHX_ const char *cmd, const char *mode)\n{\n    int p[2];\n    I32 This, that;\n    Pid_t pid;\n    SV *sv;\n    const I32 doexec = !(*cmd == '-' && cmd[1] == '\\0');\n    I32 did_pipes = 0;\n    int pp[2];\n\n    PERL_ARGS_ASSERT_MY_POPEN;\n\n    PERL_FLUSHALL_FOR_CHILD;\n#ifdef OS2\n    if (doexec) {\n\treturn my_syspopen(aTHX_ cmd,mode);\n    }\n#endif\n    This = (*mode == 'w');\n    that = !This;\n    if (doexec && TAINTING_get) {\n\ttaint_env();\n\ttaint_proper(\"Insecure %s%s\", \"EXEC\");\n    }\n    if (PerlProc_pipe_cloexec(p) < 0)\n\treturn NULL;\n    if (doexec && PerlProc_pipe_cloexec(pp) >= 0)\n\tdid_pipes = 1;\n    while ((pid = PerlProc_fork()) < 0) {\n\tif (errno != EAGAIN) {\n\t    PerlLIO_close(p[This]);\n\t    PerlLIO_close(p[that]);\n\t    if (did_pipes) {\n\t\tPerlLIO_close(pp[0]);\n\t\tPerlLIO_close(pp[1]);\n\t    }\n\t    if (!doexec)\n\t\tPerl_croak(aTHX_ \"Can't fork: %s\", Strerror(errno));\n\t    return NULL;\n\t}\n\tPerl_ck_warner(aTHX_ packWARN(WARN_PIPE), \"Can't fork, trying again in 5 seconds\");\n\tsleep(5);\n    }\n    if (pid == 0) {\n\n#undef THIS\n#undef THAT\n#define THIS that\n#define THAT This\n\tif (did_pipes)\n\t    PerlLIO_close(pp[0]);\n\tif (p[THIS] != (*mode == 'r')) {\n\t    PerlLIO_dup2(p[THIS], *mode == 'r');\n\t    PerlLIO_close(p[THIS]);\n\t    if (p[THAT] != (*mode == 'r'))\t/* if dup2() didn't close it */\n\t\tPerlLIO_close(p[THAT]);\n\t}\n\telse\n\t    PerlLIO_close(p[THAT]);\n#ifndef OS2\n\tif (doexec) {\n#if !defined(HAS_FCNTL) || !defined(F_SETFD)\n#ifndef NOFILE\n#define NOFILE 20\n#endif\n\t    {\n\t\tint fd;\n\n\t\tfor (fd = PL_maxsysfd + 1; fd < NOFILE; fd++)\n\t\t    if (fd != pp[1])\n\t\t\tPerlLIO_close(fd);\n\t    }\n#endif\n\t    /* may or may not use the shell */\n\t    do_exec3(cmd, pp[1], did_pipes);\n\t    PerlProc__exit(1);\n\t}\n#endif\t/* defined OS2 */\n\n#ifdef PERLIO_USING_CRLF\n   /* Since we circumvent IO layers when we manipulate low-level\n      filedescriptors directly, need to manually switch to the\n      default, binary, low-level mode; see PerlIOBuf_open(). */\n   PerlLIO_setmode((*mode == 'r'), O_BINARY);\n#endif \n\tPL_forkprocess = 0;\n#ifdef PERL_USES_PL_PIDSTATUS\n\thv_clear(PL_pidstatus);\t/* we have no children */\n#endif\n\treturn NULL;\n#undef THIS\n#undef THAT\n    }\n    if (did_pipes)\n\tPerlLIO_close(pp[1]);\n    if (p[that] < p[This]) {\n\tPerlLIO_dup2_cloexec(p[This], p[that]);\n\tPerlLIO_close(p[This]);\n\tp[This] = p[that];\n    }\n    else\n\tPerlLIO_close(p[that]);\n\n    sv = *av_fetch(PL_fdpid,p[This],TRUE);\n    SvUPGRADE(sv,SVt_IV);\n    SvIV_set(sv, pid);\n    PL_forkprocess = pid;\n    if (did_pipes && pid > 0) {\n\tint errkid;\n\tunsigned n = 0;\n\n\twhile (n < sizeof(int)) {\n            const SSize_t n1 = PerlLIO_read(pp[0],\n\t\t\t      (void*)(((char*)&errkid)+n),\n\t\t\t      (sizeof(int)) - n);\n\t    if (n1 <= 0)\n\t\tbreak;\n\t    n += n1;\n\t}\n\tPerlLIO_close(pp[0]);\n\tdid_pipes = 0;\n\tif (n) {\t\t\t/* Error */\n\t    int pid2, status;\n\t    PerlLIO_close(p[This]);\n\t    if (n != sizeof(int))\n\t\tPerl_croak(aTHX_ \"panic: kid popen errno read, n=%u\", n);\n\t    do {\n\t\tpid2 = wait4pid(pid, &status, 0);\n\t    } while (pid2 == -1 && errno == EINTR);\n\t    errno = errkid;\t\t/* Propagate errno from kid */\n\t    return NULL;\n\t}\n    }\n    if (did_pipes)\n\t PerlLIO_close(pp[0]);\n    return PerlIO_fdopen(p[This], mode);\n}\n#elif defined(DJGPP)\nFILE *djgpp_popen();\nPerlIO *\nPerl_my_popen(pTHX_ const char *cmd, const char *mode)\n{\n    PERL_FLUSHALL_FOR_CHILD;\n    /* Call system's popen() to get a FILE *, then import it.\n       used 0 for 2nd parameter to PerlIO_importFILE;\n       apparently not used\n    */\n    return PerlIO_importFILE(djgpp_popen(cmd, mode), 0);\n}\n#elif defined(__LIBCATAMOUNT__)\nPerlIO *\nPerl_my_popen(pTHX_ const char *cmd, const char *mode)\n{\n    return NULL;\n}\n\n#endif /* !DOSISH */\n\n/* this is called in parent before the fork() */\nvoid\nPerl_atfork_lock(void)\n#if defined(USE_ITHREADS)\n#  ifdef USE_PERLIO\n  PERL_TSA_ACQUIRE(PL_perlio_mutex)\n#  endif\n#  ifdef MYMALLOC\n  PERL_TSA_ACQUIRE(PL_malloc_mutex)\n#  endif\n  PERL_TSA_ACQUIRE(PL_op_mutex)\n#endif\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n    /* locks must be held in locking order (if any) */\n#  ifdef USE_PERLIO\n    MUTEX_LOCK(&PL_perlio_mutex);\n#  endif\n#  ifdef MYMALLOC\n    MUTEX_LOCK(&PL_malloc_mutex);\n#  endif\n    OP_REFCNT_LOCK;\n#endif\n}\n\n/* this is called in both parent and child after the fork() */\nvoid\nPerl_atfork_unlock(void)\n#if defined(USE_ITHREADS)\n#  ifdef USE_PERLIO\n  PERL_TSA_RELEASE(PL_perlio_mutex)\n#  endif\n#  ifdef MYMALLOC\n  PERL_TSA_RELEASE(PL_malloc_mutex)\n#  endif\n  PERL_TSA_RELEASE(PL_op_mutex)\n#endif\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n    /* locks must be released in same order as in atfork_lock() */\n#  ifdef USE_PERLIO\n    MUTEX_UNLOCK(&PL_perlio_mutex);\n#  endif\n#  ifdef MYMALLOC\n    MUTEX_UNLOCK(&PL_malloc_mutex);\n#  endif\n    OP_REFCNT_UNLOCK;\n#endif\n}\n\nPid_t\nPerl_my_fork(void)\n{\n#if defined(HAS_FORK)\n    Pid_t pid;\n#if defined(USE_ITHREADS) && !defined(HAS_PTHREAD_ATFORK)\n    atfork_lock();\n    pid = fork();\n    atfork_unlock();\n#else\n    /* atfork_lock() and atfork_unlock() are installed as pthread_atfork()\n     * handlers elsewhere in the code */\n    pid = fork();\n#endif\n    return pid;\n#elif defined(__amigaos4__)\n    return amigaos_fork();\n#else\n    /* this \"canna happen\" since nothing should be calling here if !HAS_FORK */\n    Perl_croak_nocontext(\"fork() not available\");\n    return 0;\n#endif /* HAS_FORK */\n}\n\n#ifndef HAS_DUP2\nint\ndup2(int oldfd, int newfd)\n{\n#if defined(HAS_FCNTL) && defined(F_DUPFD)\n    if (oldfd == newfd)\n\treturn oldfd;\n    PerlLIO_close(newfd);\n    return fcntl(oldfd, F_DUPFD, newfd);\n#else\n#define DUP2_MAX_FDS 256\n    int fdtmp[DUP2_MAX_FDS];\n    I32 fdx = 0;\n    int fd;\n\n    if (oldfd == newfd)\n\treturn oldfd;\n    PerlLIO_close(newfd);\n    /* good enough for low fd's... */\n    while ((fd = PerlLIO_dup(oldfd)) != newfd && fd >= 0) {\n\tif (fdx >= DUP2_MAX_FDS) {\n\t    PerlLIO_close(fd);\n\t    fd = -1;\n\t    break;\n\t}\n\tfdtmp[fdx++] = fd;\n    }\n    while (fdx > 0)\n\tPerlLIO_close(fdtmp[--fdx]);\n    return fd;\n#endif\n}\n#endif\n\n#ifndef PERL_MICRO\n#ifdef HAS_SIGACTION\n\nSighandler_t\nPerl_rsignal(pTHX_ int signo, Sighandler_t handler)\n{\n    struct sigaction act, oact;\n\n#ifdef USE_ITHREADS\n    dVAR;\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn (Sighandler_t) SIG_ERR;\n#endif\n\n    act.sa_handler = (void(*)(int))handler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n#ifdef SA_RESTART\n    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)\n        act.sa_flags |= SA_RESTART;\t/* SVR4, 4.3+BSD */\n#endif\n#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */\n    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)\n\tact.sa_flags |= SA_NOCLDWAIT;\n#endif\n    if (sigaction(signo, &act, &oact) == -1)\n    \treturn (Sighandler_t) SIG_ERR;\n    else\n    \treturn (Sighandler_t) oact.sa_handler;\n}\n\nSighandler_t\nPerl_rsignal_state(pTHX_ int signo)\n{\n    struct sigaction oact;\n    PERL_UNUSED_CONTEXT;\n\n    if (sigaction(signo, (struct sigaction *)NULL, &oact) == -1)\n\treturn (Sighandler_t) SIG_ERR;\n    else\n\treturn (Sighandler_t) oact.sa_handler;\n}\n\nint\nPerl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)\n{\n#ifdef USE_ITHREADS\n    dVAR;\n#endif\n    struct sigaction act;\n\n    PERL_ARGS_ASSERT_RSIGNAL_SAVE;\n\n#ifdef USE_ITHREADS\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n\n    act.sa_handler = (void(*)(int))handler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n#ifdef SA_RESTART\n    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)\n        act.sa_flags |= SA_RESTART;\t/* SVR4, 4.3+BSD */\n#endif\n#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */\n    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)\n\tact.sa_flags |= SA_NOCLDWAIT;\n#endif\n    return sigaction(signo, &act, save);\n}\n\nint\nPerl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)\n{\n#ifdef USE_ITHREADS\n    dVAR;\n#endif\n    PERL_UNUSED_CONTEXT;\n#ifdef USE_ITHREADS\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n\n    return sigaction(signo, save, (struct sigaction *)NULL);\n}\n\n#else /* !HAS_SIGACTION */\n\nSighandler_t\nPerl_rsignal(pTHX_ int signo, Sighandler_t handler)\n{\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn (Sighandler_t) SIG_ERR;\n#endif\n\n    return PerlProc_signal(signo, handler);\n}\n\nstatic Signal_t\nsig_trap(int signo)\n{\n    dVAR;\n    PL_sig_trapped++;\n}\n\nSighandler_t\nPerl_rsignal_state(pTHX_ int signo)\n{\n    dVAR;\n    Sighandler_t oldsig;\n\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn (Sighandler_t) SIG_ERR;\n#endif\n\n    PL_sig_trapped = 0;\n    oldsig = PerlProc_signal(signo, sig_trap);\n    PerlProc_signal(signo, oldsig);\n    if (PL_sig_trapped)\n\tPerlProc_kill(PerlProc_getpid(), signo);\n    return oldsig;\n}\n\nint\nPerl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)\n{\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n    *save = PerlProc_signal(signo, handler);\n    return (*save == (Sighandler_t) SIG_ERR) ? -1 : 0;\n}\n\nint\nPerl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)\n{\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n    return (PerlProc_signal(signo, *save) == (Sighandler_t) SIG_ERR) ? -1 : 0;\n}\n\n#endif /* !HAS_SIGACTION */\n#endif /* !PERL_MICRO */\n\n    /* VMS' my_pclose() is in VMS.c; same with OS/2 */\n#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n{\n    int status;\n    SV **svp;\n    Pid_t pid;\n    Pid_t pid2 = 0;\n    bool close_failed;\n    dSAVEDERRNO;\n    const int fd = PerlIO_fileno(ptr);\n    bool should_wait;\n\n    svp = av_fetch(PL_fdpid,fd,TRUE);\n    pid = (SvTYPE(*svp) == SVt_IV) ? SvIVX(*svp) : -1;\n    SvREFCNT_dec(*svp);\n    *svp = NULL;\n\n#if defined(USE_PERLIO)\n    /* Find out whether the refcount is low enough for us to wait for the\n       child proc without blocking. */\n    should_wait = PerlIOUnix_refcnt(fd) == 1 && pid > 0;\n#else\n    should_wait = pid > 0;\n#endif\n\n#ifdef OS2\n    if (pid == -1) {\t\t\t/* Opened by popen. */\n\treturn my_syspclose(ptr);\n    }\n#endif\n    close_failed = (PerlIO_close(ptr) == EOF);\n    SAVE_ERRNO;\n    if (should_wait) do {\n\tpid2 = wait4pid(pid, &status, 0);\n    } while (pid2 == -1 && errno == EINTR);\n    if (close_failed) {\n\tRESTORE_ERRNO;\n\treturn -1;\n    }\n    return(\n      should_wait\n       ? pid2 < 0 ? pid2 : status == 0 ? 0 : (errno = 0, status)\n       : 0\n    );\n}\n#elif defined(__LIBCATAMOUNT__)\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n{\n    return -1;\n}\n#endif /* !DOSISH */\n\n#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(__LIBCATAMOUNT__)\nI32\nPerl_wait4pid(pTHX_ Pid_t pid, int *statusp, int flags)\n{\n    I32 result = 0;\n    PERL_ARGS_ASSERT_WAIT4PID;\n#ifdef PERL_USES_PL_PIDSTATUS\n    if (!pid) {\n        /* PERL_USES_PL_PIDSTATUS is only defined when neither\n           waitpid() nor wait4() is available, or on OS/2, which\n           doesn't appear to support waiting for a progress group\n           member, so we can only treat a 0 pid as an unknown child.\n        */\n        errno = ECHILD;\n        return -1;\n    }\n    {\n\tif (pid > 0) {\n\t    /* The keys in PL_pidstatus are now the raw 4 (or 8) bytes of the\n\t       pid, rather than a string form.  */\n\t    SV * const * const svp = hv_fetch(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),FALSE);\n\t    if (svp && *svp != &PL_sv_undef) {\n\t\t*statusp = SvIVX(*svp);\n\t\t(void)hv_delete(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),\n\t\t\t\tG_DISCARD);\n\t\treturn pid;\n\t    }\n\t}\n\telse {\n\t    HE *entry;\n\n\t    hv_iterinit(PL_pidstatus);\n\t    if ((entry = hv_iternext(PL_pidstatus))) {\n\t\tSV * const sv = hv_iterval(PL_pidstatus,entry);\n\t\tI32 len;\n\t\tconst char * const spid = hv_iterkey(entry,&len);\n\n\t\tassert (len == sizeof(Pid_t));\n\t\tmemcpy((char *)&pid, spid, len);\n\t\t*statusp = SvIVX(sv);\n\t\t/* The hash iterator is currently on this entry, so simply\n\t\t   calling hv_delete would trigger the lazy delete, which on\n\t\t   aggregate does more work, because next call to hv_iterinit()\n\t\t   would spot the flag, and have to call the delete routine,\n\t\t   while in the meantime any new entries can't re-use that\n\t\t   memory.  */\n\t\thv_iterinit(PL_pidstatus);\n\t\t(void)hv_delete(PL_pidstatus,spid,len,G_DISCARD);\n\t\treturn pid;\n\t    }\n\t}\n    }\n#endif\n#ifdef HAS_WAITPID\n#  ifdef HAS_WAITPID_RUNTIME\n    if (!HAS_WAITPID_RUNTIME)\n\tgoto hard_way;\n#  endif\n    result = PerlProc_waitpid(pid,statusp,flags);\n    goto finish;\n#endif\n#if !defined(HAS_WAITPID) && defined(HAS_WAIT4)\n    result = wait4(pid,statusp,flags,NULL);\n    goto finish;\n#endif\n#ifdef PERL_USES_PL_PIDSTATUS\n#if defined(HAS_WAITPID) && defined(HAS_WAITPID_RUNTIME)\n  hard_way:\n#endif\n    {\n\tif (flags)\n\t    Perl_croak(aTHX_ \"Can't do waitpid with flags\");\n\telse {\n\t    while ((result = PerlProc_wait(statusp)) != pid && pid > 0 && result >= 0)\n\t\tpidgone(result,*statusp);\n\t    if (result < 0)\n\t\t*statusp = -1;\n\t}\n    }\n#endif\n#if defined(HAS_WAITPID) || defined(HAS_WAIT4)\n  finish:\n#endif\n    if (result < 0 && errno == EINTR) {\n\tPERL_ASYNC_CHECK();\n\terrno = EINTR; /* reset in case a signal handler changed $! */\n    }\n    return result;\n}\n#endif /* !DOSISH || OS2 || WIN32 || NETWARE */\n\n#ifdef PERL_USES_PL_PIDSTATUS\nvoid\nS_pidgone(pTHX_ Pid_t pid, int status)\n{\n    SV *sv;\n\n    sv = *hv_fetch(PL_pidstatus,(const char*)&pid,sizeof(Pid_t),TRUE);\n    SvUPGRADE(sv,SVt_IV);\n    SvIV_set(sv, status);\n    return;\n}\n#endif\n\n#if defined(OS2)\nint pclose();\n#ifdef HAS_FORK\nint\t\t\t\t\t/* Cannot prototype with I32\n\t\t\t\t\t   in os2ish.h. */\nmy_syspclose(PerlIO *ptr)\n#else\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n#endif\n{\n    /* Needs work for PerlIO ! */\n    FILE * const f = PerlIO_findFILE(ptr);\n    const I32 result = pclose(f);\n    PerlIO_releaseFILE(ptr,f);\n    return result;\n}\n#endif\n\n#if defined(DJGPP)\nint djgpp_pclose();\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n{\n    /* Needs work for PerlIO ! */\n    FILE * const f = PerlIO_findFILE(ptr);\n    I32 result = djgpp_pclose(f);\n    result = (result << 8) & 0xff00;\n    PerlIO_releaseFILE(ptr,f);\n    return result;\n}\n#endif\n\n#define PERL_REPEATCPY_LINEAR 4\nvoid\nPerl_repeatcpy(char *to, const char *from, I32 len, IV count)\n{\n    PERL_ARGS_ASSERT_REPEATCPY;\n\n    assert(len >= 0);\n\n    if (count < 0)\n\tcroak_memory_wrap();\n\n    if (len == 1)\n\tmemset(to, *from, count);\n    else if (count) {\n\tchar *p = to;\n\tIV items, linear, half;\n\n\tlinear = count < PERL_REPEATCPY_LINEAR ? count : PERL_REPEATCPY_LINEAR;\n\tfor (items = 0; items < linear; ++items) {\n\t    const char *q = from;\n\t    IV todo;\n\t    for (todo = len; todo > 0; todo--)\n\t\t*p++ = *q++;\n        }\n\n\thalf = count / 2;\n\twhile (items <= half) {\n\t    IV size = items * len;\n\t    memcpy(p, to, size);\n\t    p     += size;\n\t    items *= 2;\n\t}\n\n\tif (count > items)\n\t    memcpy(p, to, (count - items) * len);\n    }\n}\n\n#ifndef HAS_RENAME\nI32\nPerl_same_dirent(pTHX_ const char *a, const char *b)\n{\n    char *fa = strrchr(a,'/');\n    char *fb = strrchr(b,'/');\n    Stat_t tmpstatbuf1;\n    Stat_t tmpstatbuf2;\n    SV * const tmpsv = sv_newmortal();\n\n    PERL_ARGS_ASSERT_SAME_DIRENT;\n\n    if (fa)\n\tfa++;\n    else\n\tfa = a;\n    if (fb)\n\tfb++;\n    else\n\tfb = b;\n    if (strNE(a,b))\n\treturn FALSE;\n    if (fa == a)\n\tsv_setpvs(tmpsv, \".\");\n    else\n\tsv_setpvn(tmpsv, a, fa - a);\n    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf1) < 0)\n\treturn FALSE;\n    if (fb == b)\n\tsv_setpvs(tmpsv, \".\");\n    else\n\tsv_setpvn(tmpsv, b, fb - b);\n    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf2) < 0)\n\treturn FALSE;\n    return tmpstatbuf1.st_dev == tmpstatbuf2.st_dev &&\n\t   tmpstatbuf1.st_ino == tmpstatbuf2.st_ino;\n}\n#endif /* !HAS_RENAME */\n\nchar*\nPerl_find_script(pTHX_ const char *scriptname, bool dosearch,\n\t\t const char *const *const search_ext, I32 flags)\n{\n    const char *xfound = NULL;\n    char *xfailed = NULL;\n    char tmpbuf[MAXPATHLEN];\n    char *s;\n    I32 len = 0;\n    int retval;\n    char *bufend;\n#if defined(DOSISH) && !defined(OS2)\n#  define SEARCH_EXTS \".bat\", \".cmd\", NULL\n#  define MAX_EXT_LEN 4\n#endif\n#ifdef OS2\n#  define SEARCH_EXTS \".cmd\", \".btm\", \".bat\", \".pl\", NULL\n#  define MAX_EXT_LEN 4\n#endif\n#ifdef VMS\n#  define SEARCH_EXTS \".pl\", \".com\", NULL\n#  define MAX_EXT_LEN 4\n#endif\n    /* additional extensions to try in each dir if scriptname not found */\n#ifdef SEARCH_EXTS\n    static const char *const exts[] = { SEARCH_EXTS };\n    const char *const *const ext = search_ext ? search_ext : exts;\n    int extidx = 0, i = 0;\n    const char *curext = NULL;\n#else\n    PERL_UNUSED_ARG(search_ext);\n#  define MAX_EXT_LEN 0\n#endif\n\n    PERL_ARGS_ASSERT_FIND_SCRIPT;\n\n    /*\n     * If dosearch is true and if scriptname does not contain path\n     * delimiters, search the PATH for scriptname.\n     *\n     * If SEARCH_EXTS is also defined, will look for each\n     * scriptname{SEARCH_EXTS} whenever scriptname is not found\n     * while searching the PATH.\n     *\n     * Assuming SEARCH_EXTS is C<\".foo\",\".bar\",NULL>, PATH search\n     * proceeds as follows:\n     *   If DOSISH or VMSISH:\n     *     + look for ./scriptname{,.foo,.bar}\n     *     + search the PATH for scriptname{,.foo,.bar}\n     *\n     *   If !DOSISH:\n     *     + look *only* in the PATH for scriptname{,.foo,.bar} (note\n     *       this will not look in '.' if it's not in the PATH)\n     */\n    tmpbuf[0] = '\\0';\n\n#ifdef VMS\n#  ifdef ALWAYS_DEFTYPES\n    len = strlen(scriptname);\n    if (!(len == 1 && *scriptname == '-') && scriptname[len-1] != ':') {\n\tint idx = 0, deftypes = 1;\n\tbool seen_dot = 1;\n\n\tconst int hasdir = !dosearch || (strpbrk(scriptname,\":[</\") != NULL);\n#  else\n    if (dosearch) {\n\tint idx = 0, deftypes = 1;\n\tbool seen_dot = 1;\n\n\tconst int hasdir = (strpbrk(scriptname,\":[</\") != NULL);\n#  endif\n\t/* The first time through, just add SEARCH_EXTS to whatever we\n\t * already have, so we can check for default file types. */\n\twhile (deftypes ||\n\t       (!hasdir && my_trnlnm(\"DCL$PATH\",tmpbuf,idx++)) )\n\t{\n\t    Stat_t statbuf;\n\t    if (deftypes) {\n\t\tdeftypes = 0;\n\t\t*tmpbuf = '\\0';\n\t    }\n\t    if ((strlen(tmpbuf) + strlen(scriptname)\n\t\t + MAX_EXT_LEN) >= sizeof tmpbuf)\n\t\tcontinue;\t/* don't search dir with too-long name */\n\t    my_strlcat(tmpbuf, scriptname, sizeof(tmpbuf));\n#else  /* !VMS */\n\n#ifdef DOSISH\n    if (strEQ(scriptname, \"-\"))\n \tdosearch = 0;\n    if (dosearch) {\t\t/* Look in '.' first. */\n\tconst char *cur = scriptname;\n#ifdef SEARCH_EXTS\n\tif ((curext = strrchr(scriptname,'.')))\t/* possible current ext */\n\t    while (ext[i])\n\t\tif (strEQ(ext[i++],curext)) {\n\t\t    extidx = -1;\t\t/* already has an ext */\n\t\t    break;\n\t\t}\n\tdo {\n#endif\n\t    DEBUG_p(PerlIO_printf(Perl_debug_log,\n\t\t\t\t  \"Looking for %s\\n\",cur));\n\t    {\n\t\tStat_t statbuf;\n\t\tif (PerlLIO_stat(cur,&statbuf) >= 0\n\t\t    && !S_ISDIR(statbuf.st_mode)) {\n\t\t    dosearch = 0;\n\t\t    scriptname = cur;\n#ifdef SEARCH_EXTS\n\t\t    break;\n#endif\n\t\t}\n\t    }\n#ifdef SEARCH_EXTS\n\t    if (cur == scriptname) {\n\t\tlen = strlen(scriptname);\n\t\tif (len+MAX_EXT_LEN+1 >= sizeof(tmpbuf))\n\t\t    break;\n\t\tmy_strlcpy(tmpbuf, scriptname, sizeof(tmpbuf));\n\t\tcur = tmpbuf;\n\t    }\n\t} while (extidx >= 0 && ext[extidx]\t/* try an extension? */\n\t\t && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len));\n#endif\n    }\n#endif\n\n    if (dosearch && !strchr(scriptname, '/')\n#ifdef DOSISH\n\t\t && !strchr(scriptname, '\\\\')\n#endif\n\t\t && (s = PerlEnv_getenv(\"PATH\")))\n    {\n\tbool seen_dot = 0;\n\n\tbufend = s + strlen(s);\n\twhile (s < bufend) {\n\t    Stat_t statbuf;\n#  ifdef DOSISH\n\t    for (len = 0; *s\n\t\t    && *s != ';'; len++, s++) {\n\t\tif (len < sizeof tmpbuf)\n\t\t    tmpbuf[len] = *s;\n\t    }\n\t    if (len < sizeof tmpbuf)\n\t\ttmpbuf[len] = '\\0';\n#  else\n\t    s = delimcpy_no_escape(tmpbuf, tmpbuf + sizeof tmpbuf, s, bufend,\n                                   ':', &len);\n#  endif\n\t    if (s < bufend)\n\t\ts++;\n\t    if (len + 1 + strlen(scriptname) + MAX_EXT_LEN >= sizeof tmpbuf)\n\t\tcontinue;\t/* don't search dir with too-long name */\n\t    if (len\n#  ifdef DOSISH\n\t\t&& tmpbuf[len - 1] != '/'\n\t\t&& tmpbuf[len - 1] != '\\\\'\n#  endif\n\t       )\n\t\ttmpbuf[len++] = '/';\n\t    if (len == 2 && tmpbuf[0] == '.')\n\t\tseen_dot = 1;\n\t    (void)my_strlcpy(tmpbuf + len, scriptname, sizeof(tmpbuf) - len);\n#endif  /* !VMS */\n\n#ifdef SEARCH_EXTS\n\t    len = strlen(tmpbuf);\n\t    if (extidx > 0)\t/* reset after previous loop */\n\t\textidx = 0;\n\t    do {\n#endif\n\t    \tDEBUG_p(PerlIO_printf(Perl_debug_log, \"Looking for %s\\n\",tmpbuf));\n\t\tretval = PerlLIO_stat(tmpbuf,&statbuf);\n\t\tif (S_ISDIR(statbuf.st_mode)) {\n\t\t    retval = -1;\n\t\t}\n#ifdef SEARCH_EXTS\n\t    } while (  retval < 0\t\t/* not there */\n\t\t    && extidx>=0 && ext[extidx]\t/* try an extension? */\n\t\t    && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len)\n\t\t);\n#endif\n\t    if (retval < 0)\n\t\tcontinue;\n\t    if (S_ISREG(statbuf.st_mode)\n\t\t&& cando(S_IRUSR,TRUE,&statbuf)\n#if !defined(DOSISH)\n\t\t&& cando(S_IXUSR,TRUE,&statbuf)\n#endif\n\t\t)\n\t    {\n\t\txfound = tmpbuf;\t\t/* bingo! */\n\t\tbreak;\n\t    }\n\t    if (!xfailed)\n\t\txfailed = savepv(tmpbuf);\n\t}\n#ifndef DOSISH\n\t{\n\t    Stat_t statbuf;\n\t    if (!xfound && !seen_dot && !xfailed &&\n\t\t(PerlLIO_stat(scriptname,&statbuf) < 0\n\t\t || S_ISDIR(statbuf.st_mode)))\n#endif\n\t\tseen_dot = 1;\t\t\t/* Disable message. */\n#ifndef DOSISH\n\t}\n#endif\n\tif (!xfound) {\n\t    if (flags & 1) {\t\t\t/* do or die? */\n\t\t/* diag_listed_as: Can't execute %s */\n\t\tPerl_croak(aTHX_ \"Can't %s %s%s%s\",\n\t\t      (xfailed ? \"execute\" : \"find\"),\n\t\t      (xfailed ? xfailed : scriptname),\n\t\t      (xfailed ? \"\" : \" on PATH\"),\n\t\t      (xfailed || seen_dot) ? \"\" : \", '.' not in PATH\");\n\t    }\n\t    scriptname = NULL;\n\t}\n\tSafefree(xfailed);\n\tscriptname = xfound;\n    }\n    return (scriptname ? savepv(scriptname) : NULL);\n}\n\n#ifndef PERL_GET_CONTEXT_DEFINED\n\nvoid *\nPerl_get_context(void)\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n#  ifdef OLD_PTHREADS_API\n    pthread_addr_t t;\n    int error = pthread_getspecific(PL_thr_key, &t)\n    if (error)\n\tPerl_croak_nocontext(\"panic: pthread_getspecific, error=%d\", error);\n    return (void*)t;\n#  elif defined(I_MACH_CTHREADS)\n    return (void*)cthread_data(cthread_self());\n#  else\n    return (void*)PTHREAD_GETSPECIFIC(PL_thr_key);\n#  endif\n#else\n    return (void*)NULL;\n#endif\n}\n\nvoid\nPerl_set_context(void *t)\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n#endif\n    PERL_ARGS_ASSERT_SET_CONTEXT;\n#if defined(USE_ITHREADS)\n#  ifdef I_MACH_CTHREADS\n    cthread_set_data(cthread_self(), t);\n#  else\n    {\n\tconst int error = pthread_setspecific(PL_thr_key, t);\n\tif (error)\n\t    Perl_croak_nocontext(\"panic: pthread_setspecific, error=%d\", error);\n    }\n#  endif\n#else\n    PERL_UNUSED_ARG(t);\n#endif\n}\n\n#endif /* !PERL_GET_CONTEXT_DEFINED */\n\n#if defined(PERL_GLOBAL_STRUCT) && !defined(PERL_GLOBAL_STRUCT_PRIVATE)\nstruct perl_vars *\nPerl_GetVars(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return &PL_Vars;\n}\n#endif\n\nchar **\nPerl_get_op_names(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return (char **)PL_op_name;\n}\n\nchar **\nPerl_get_op_descs(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return (char **)PL_op_desc;\n}\n\nconst char *\nPerl_get_no_modify(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return PL_no_modify;\n}\n\nU32 *\nPerl_get_opargs(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return (U32 *)PL_opargs;\n}\n\nPPADDR_t*\nPerl_get_ppaddr(pTHX)\n{\n    dVAR;\n    PERL_UNUSED_CONTEXT;\n    return (PPADDR_t*)PL_ppaddr;\n}\n\n#ifndef HAS_GETENV_LEN\nchar *\nPerl_getenv_len(pTHX_ const char *env_elem, unsigned long *len)\n{\n    char * const env_trans = PerlEnv_getenv(env_elem);\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_GETENV_LEN;\n    if (env_trans)\n\t*len = strlen(env_trans);\n    return env_trans;\n}\n#endif\n\n\nMGVTBL*\nPerl_get_vtbl(pTHX_ int vtbl_id)\n{\n    PERL_UNUSED_CONTEXT;\n\n    return (vtbl_id < 0 || vtbl_id >= magic_vtable_max)\n\t? NULL : (MGVTBL*)PL_magic_vtables + vtbl_id;\n}\n\nI32\nPerl_my_fflush_all(pTHX)\n{\n#if defined(USE_PERLIO) || defined(FFLUSH_NULL)\n    return PerlIO_flush(NULL);\n#else\n# if defined(HAS__FWALK)\n    extern int fflush(FILE *);\n    /* undocumented, unprototyped, but very useful BSDism */\n    extern void _fwalk(int (*)(FILE *));\n    _fwalk(&fflush);\n    return 0;\n# else\n#  if defined(FFLUSH_ALL) && defined(HAS_STDIO_STREAM_ARRAY)\n    long open_max = -1;\n#   ifdef PERL_FFLUSH_ALL_FOPEN_MAX\n    open_max = PERL_FFLUSH_ALL_FOPEN_MAX;\n#   elif defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)\n    open_max = sysconf(_SC_OPEN_MAX);\n#   elif defined(FOPEN_MAX)\n    open_max = FOPEN_MAX;\n#   elif defined(OPEN_MAX)\n    open_max = OPEN_MAX;\n#   elif defined(_NFILE)\n    open_max = _NFILE;\n#   endif\n    if (open_max > 0) {\n      long i;\n      for (i = 0; i < open_max; i++)\n\t    if (STDIO_STREAM_ARRAY[i]._file >= 0 &&\n\t\tSTDIO_STREAM_ARRAY[i]._file < open_max &&\n\t\tSTDIO_STREAM_ARRAY[i]._flag)\n\t\tPerlIO_flush(&STDIO_STREAM_ARRAY[i]);\n      return 0;\n    }\n#  endif\n    SETERRNO(EBADF,RMS_IFI);\n    return EOF;\n# endif\n#endif\n}\n\nvoid\nPerl_report_wrongway_fh(pTHX_ const GV *gv, const char have)\n{\n    if (ckWARN(WARN_IO)) {\n        HEK * const name\n           = gv && (isGV_with_GP(gv))\n                ? GvENAME_HEK((gv))\n                : NULL;\n\tconst char * const direction = have == '>' ? \"out\" : \"in\";\n\n\tif (name && HEK_LEN(name))\n\t    Perl_warner(aTHX_ packWARN(WARN_IO),\n\t\t\t\"Filehandle %\" HEKf \" opened only for %sput\",\n\t\t\tHEKfARG(name), direction);\n\telse\n\t    Perl_warner(aTHX_ packWARN(WARN_IO),\n\t\t\t\"Filehandle opened only for %sput\", direction);\n    }\n}\n\nvoid\nPerl_report_evil_fh(pTHX_ const GV *gv)\n{\n    const IO *io = gv ? GvIO(gv) : NULL;\n    const PERL_BITFIELD16 op = PL_op->op_type;\n    const char *vile;\n    I32 warn_type;\n\n    if (io && IoTYPE(io) == IoTYPE_CLOSED) {\n\tvile = \"closed\";\n\twarn_type = WARN_CLOSED;\n    }\n    else {\n\tvile = \"unopened\";\n\twarn_type = WARN_UNOPENED;\n    }\n\n    if (ckWARN(warn_type)) {\n        SV * const name\n            = gv && isGV_with_GP(gv) && GvENAMELEN(gv) ?\n                                     sv_2mortal(newSVhek(GvENAME_HEK(gv))) : NULL;\n\tconst char * const pars =\n\t    (const char *)(OP_IS_FILETEST(op) ? \"\" : \"()\");\n\tconst char * const func =\n\t    (const char *)\n\t    (op == OP_READLINE || op == OP_RCATLINE\n\t\t\t\t ? \"readline\"  :\t/* \"<HANDLE>\" not nice */\n\t     op == OP_LEAVEWRITE ? \"write\" :\t\t/* \"write exit\" not nice */\n\t     PL_op_desc[op]);\n\tconst char * const type =\n\t    (const char *)\n\t    (OP_IS_SOCKET(op) || (io && IoTYPE(io) == IoTYPE_SOCKET)\n\t     ? \"socket\" : \"filehandle\");\n\tconst bool have_name = name && SvCUR(name);\n\tPerl_warner(aTHX_ packWARN(warn_type),\n\t\t   \"%s%s on %s %s%s%\" SVf, func, pars, vile, type,\n\t\t    have_name ? \" \" : \"\",\n\t\t    SVfARG(have_name ? name : &PL_sv_no));\n\tif (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))\n\t\tPerl_warner(\n\t\t\t    aTHX_ packWARN(warn_type),\n\t\t\t\"\\t(Are you trying to call %s%s on dirhandle%s%\" SVf \"?)\\n\",\n\t\t\tfunc, pars, have_name ? \" \" : \"\",\n\t\t\tSVfARG(have_name ? name : &PL_sv_no)\n\t\t\t    );\n    }\n}\n\n/* To workaround core dumps from the uninitialised tm_zone we get the\n * system to give us a reasonable struct to copy.  This fix means that\n * strftime uses the tm_zone and tm_gmtoff values returned by\n * localtime(time()). That should give the desired result most of the\n * time. But probably not always!\n *\n * This does not address tzname aspects of NETaa14816.\n *\n */\n\n#ifdef __GLIBC__\n# ifndef STRUCT_TM_HASZONE\n#    define STRUCT_TM_HASZONE\n# endif\n#endif\n\n#ifdef STRUCT_TM_HASZONE /* Backward compat */\n# ifndef HAS_TM_TM_ZONE\n#    define HAS_TM_TM_ZONE\n# endif\n#endif\n\nvoid\nPerl_init_tm(pTHX_ struct tm *ptm)\t/* see mktime, strftime and asctime */\n{\n#ifdef HAS_TM_TM_ZONE\n    Time_t now;\n    const struct tm* my_tm;\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INIT_TM;\n    (void)time(&now);\n    my_tm = localtime(&now);\n    if (my_tm)\n        Copy(my_tm, ptm, 1, struct tm);\n#else\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INIT_TM;\n    PERL_UNUSED_ARG(ptm);\n#endif\n}\n\n/*\n * mini_mktime - normalise struct tm values without the localtime()\n * semantics (and overhead) of mktime().\n */\nvoid\nPerl_mini_mktime(struct tm *ptm)\n{\n    int yearday;\n    int secs;\n    int month, mday, year, jday;\n    int odd_cent, odd_year;\n\n    PERL_ARGS_ASSERT_MINI_MKTIME;\n\n#define\tDAYS_PER_YEAR\t365\n#define\tDAYS_PER_QYEAR\t(4*DAYS_PER_YEAR+1)\n#define\tDAYS_PER_CENT\t(25*DAYS_PER_QYEAR-1)\n#define\tDAYS_PER_QCENT\t(4*DAYS_PER_CENT+1)\n#define\tSECS_PER_HOUR\t(60*60)\n#define\tSECS_PER_DAY\t(24*SECS_PER_HOUR)\n/* parentheses deliberately absent on these two, otherwise they don't work */\n#define\tMONTH_TO_DAYS\t153/5\n#define\tDAYS_TO_MONTH\t5/153\n/* offset to bias by March (month 4) 1st between month/mday & year finding */\n#define\tYEAR_ADJUST\t(4*MONTH_TO_DAYS+1)\n/* as used here, the algorithm leaves Sunday as day 1 unless we adjust it */\n#define\tWEEKDAY_BIAS\t6\t/* (1+6)%7 makes Sunday 0 again */\n\n/*\n * Year/day algorithm notes:\n *\n * With a suitable offset for numeric value of the month, one can find\n * an offset into the year by considering months to have 30.6 (153/5) days,\n * using integer arithmetic (i.e., with truncation).  To avoid too much\n * messing about with leap days, we consider January and February to be\n * the 13th and 14th month of the previous year.  After that transformation,\n * we need the month index we use to be high by 1 from 'normal human' usage,\n * so the month index values we use run from 4 through 15.\n *\n * Given that, and the rules for the Gregorian calendar (leap years are those\n * divisible by 4 unless also divisible by 100, when they must be divisible\n * by 400 instead), we can simply calculate the number of days since some\n * arbitrary 'beginning of time' by futzing with the (adjusted) year number,\n * the days we derive from our month index, and adding in the day of the\n * month.  The value used here is not adjusted for the actual origin which\n * it normally would use (1 January A.D. 1), since we're not exposing it.\n * We're only building the value so we can turn around and get the\n * normalised values for the year, month, day-of-month, and day-of-year.\n *\n * For going backward, we need to bias the value we're using so that we find\n * the right year value.  (Basically, we don't want the contribution of\n * March 1st to the number to apply while deriving the year).  Having done\n * that, we 'count up' the contribution to the year number by accounting for\n * full quadracenturies (400-year periods) with their extra leap days, plus\n * the contribution from full centuries (to avoid counting in the lost leap\n * days), plus the contribution from full quad-years (to count in the normal\n * leap days), plus the leftover contribution from any non-leap years.\n * At this point, if we were working with an actual leap day, we'll have 0\n * days left over.  This is also true for March 1st, however.  So, we have\n * to special-case that result, and (earlier) keep track of the 'odd'\n * century and year contributions.  If we got 4 extra centuries in a qcent,\n * or 4 extra years in a qyear, then it's a leap day and we call it 29 Feb.\n * Otherwise, we add back in the earlier bias we removed (the 123 from\n * figuring in March 1st), find the month index (integer division by 30.6),\n * and the remainder is the day-of-month.  We then have to convert back to\n * 'real' months (including fixing January and February from being 14/15 in\n * the previous year to being in the proper year).  After that, to get\n * tm_yday, we work with the normalised year and get a new yearday value for\n * January 1st, which we subtract from the yearday value we had earlier,\n * representing the date we've re-built.  This is done from January 1\n * because tm_yday is 0-origin.\n *\n * Since POSIX time routines are only guaranteed to work for times since the\n * UNIX epoch (00:00:00 1 Jan 1970 UTC), the fact that this algorithm\n * applies Gregorian calendar rules even to dates before the 16th century\n * doesn't bother me.  Besides, you'd need cultural context for a given\n * date to know whether it was Julian or Gregorian calendar, and that's\n * outside the scope for this routine.  Since we convert back based on the\n * same rules we used to build the yearday, you'll only get strange results\n * for input which needed normalising, or for the 'odd' century years which\n * were leap years in the Julian calendar but not in the Gregorian one.\n * I can live with that.\n *\n * This algorithm also fails to handle years before A.D. 1 gracefully, but\n * that's still outside the scope for POSIX time manipulation, so I don't\n * care.\n *\n * - lwall\n */\n\n    year = 1900 + ptm->tm_year;\n    month = ptm->tm_mon;\n    mday = ptm->tm_mday;\n    jday = 0;\n    if (month >= 2)\n\tmonth+=2;\n    else\n\tmonth+=14, year--;\n    yearday = DAYS_PER_YEAR * year + year/4 - year/100 + year/400;\n    yearday += month*MONTH_TO_DAYS + mday + jday;\n    /*\n     * Note that we don't know when leap-seconds were or will be,\n     * so we have to trust the user if we get something which looks\n     * like a sensible leap-second.  Wild values for seconds will\n     * be rationalised, however.\n     */\n    if ((unsigned) ptm->tm_sec <= 60) {\n\tsecs = 0;\n    }\n    else {\n\tsecs = ptm->tm_sec;\n\tptm->tm_sec = 0;\n    }\n    secs += 60 * ptm->tm_min;\n    secs += SECS_PER_HOUR * ptm->tm_hour;\n    if (secs < 0) {\n\tif (secs-(secs/SECS_PER_DAY*SECS_PER_DAY) < 0) {\n\t    /* got negative remainder, but need positive time */\n\t    /* back off an extra day to compensate */\n\t    yearday += (secs/SECS_PER_DAY)-1;\n\t    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY - 1);\n\t}\n\telse {\n\t    yearday += (secs/SECS_PER_DAY);\n\t    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY);\n\t}\n    }\n    else if (secs >= SECS_PER_DAY) {\n\tyearday += (secs/SECS_PER_DAY);\n\tsecs %= SECS_PER_DAY;\n    }\n    ptm->tm_hour = secs/SECS_PER_HOUR;\n    secs %= SECS_PER_HOUR;\n    ptm->tm_min = secs/60;\n    secs %= 60;\n    ptm->tm_sec += secs;\n    /* done with time of day effects */\n    /*\n     * The algorithm for yearday has (so far) left it high by 428.\n     * To avoid mistaking a legitimate Feb 29 as Mar 1, we need to\n     * bias it by 123 while trying to figure out what year it\n     * really represents.  Even with this tweak, the reverse\n     * translation fails for years before A.D. 0001.\n     * It would still fail for Feb 29, but we catch that one below.\n     */\n    jday = yearday;\t/* save for later fixup vis-a-vis Jan 1 */\n    yearday -= YEAR_ADJUST;\n    year = (yearday / DAYS_PER_QCENT) * 400;\n    yearday %= DAYS_PER_QCENT;\n    odd_cent = yearday / DAYS_PER_CENT;\n    year += odd_cent * 100;\n    yearday %= DAYS_PER_CENT;\n    year += (yearday / DAYS_PER_QYEAR) * 4;\n    yearday %= DAYS_PER_QYEAR;\n    odd_year = yearday / DAYS_PER_YEAR;\n    year += odd_year;\n    yearday %= DAYS_PER_YEAR;\n    if (!yearday && (odd_cent==4 || odd_year==4)) { /* catch Feb 29 */\n\tmonth = 1;\n\tyearday = 29;\n    }\n    else {\n\tyearday += YEAR_ADJUST;\t/* recover March 1st crock */\n\tmonth = yearday*DAYS_TO_MONTH;\n\tyearday -= month*MONTH_TO_DAYS;\n\t/* recover other leap-year adjustment */\n\tif (month > 13) {\n\t    month-=14;\n\t    year++;\n\t}\n\telse {\n\t    month-=2;\n\t}\n    }\n    ptm->tm_year = year - 1900;\n    if (yearday) {\n      ptm->tm_mday = yearday;\n      ptm->tm_mon = month;\n    }\n    else {\n      ptm->tm_mday = 31;\n      ptm->tm_mon = month - 1;\n    }\n    /* re-build yearday based on Jan 1 to get tm_yday */\n    year--;\n    yearday = year*DAYS_PER_YEAR + year/4 - year/100 + year/400;\n    yearday += 14*MONTH_TO_DAYS + 1;\n    ptm->tm_yday = jday - yearday;\n    ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;\n}\n\nchar *\nPerl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)\n{\n#ifdef HAS_STRFTIME\n\n  /* strftime(), but with a different API so that the return value is a pointer\n   * to the formatted result (which MUST be arranged to be FREED BY THE\n   * CALLER).  This allows this function to increase the buffer size as needed,\n   * so that the caller doesn't have to worry about that.\n   *\n   * Note that yday and wday effectively are ignored by this function, as\n   * mini_mktime() overwrites them */\n\n  char *buf;\n  int buflen;\n  struct tm mytm;\n  int len;\n\n  PERL_ARGS_ASSERT_MY_STRFTIME;\n\n  init_tm(&mytm);\t/* XXX workaround - see init_tm() above */\n  mytm.tm_sec = sec;\n  mytm.tm_min = min;\n  mytm.tm_hour = hour;\n  mytm.tm_mday = mday;\n  mytm.tm_mon = mon;\n  mytm.tm_year = year;\n  mytm.tm_wday = wday;\n  mytm.tm_yday = yday;\n  mytm.tm_isdst = isdst;\n  mini_mktime(&mytm);\n  /* use libc to get the values for tm_gmtoff and tm_zone [perl #18238] */\n#if defined(HAS_MKTIME) && (defined(HAS_TM_TM_GMTOFF) || defined(HAS_TM_TM_ZONE))\n  STMT_START {\n    struct tm mytm2;\n    mytm2 = mytm;\n    mktime(&mytm2);\n#ifdef HAS_TM_TM_GMTOFF\n    mytm.tm_gmtoff = mytm2.tm_gmtoff;\n#endif\n#ifdef HAS_TM_TM_ZONE\n    mytm.tm_zone = mytm2.tm_zone;\n#endif\n  } STMT_END;\n#endif\n  buflen = 64;\n  Newx(buf, buflen, char);\n\n  GCC_DIAG_IGNORE_STMT(-Wformat-nonliteral); /* fmt checked by caller */\n  len = strftime(buf, buflen, fmt, &mytm);\n  GCC_DIAG_RESTORE_STMT;\n\n  /*\n  ** The following is needed to handle to the situation where\n  ** tmpbuf overflows.  Basically we want to allocate a buffer\n  ** and try repeatedly.  The reason why it is so complicated\n  ** is that getting a return value of 0 from strftime can indicate\n  ** one of the following:\n  ** 1. buffer overflowed,\n  ** 2. illegal conversion specifier, or\n  ** 3. the format string specifies nothing to be returned(not\n  **\t  an error).  This could be because format is an empty string\n  **    or it specifies %p that yields an empty string in some locale.\n  ** If there is a better way to make it portable, go ahead by\n  ** all means.\n  */\n  if ((len > 0 && len < buflen) || (len == 0 && *fmt == '\\0'))\n    return buf;\n  else {\n    /* Possibly buf overflowed - try again with a bigger buf */\n    const int fmtlen = strlen(fmt);\n    int bufsize = fmtlen + buflen;\n\n    Renew(buf, bufsize, char);\n    while (buf) {\n\n      GCC_DIAG_IGNORE_STMT(-Wformat-nonliteral); /* fmt checked by caller */\n      buflen = strftime(buf, bufsize, fmt, &mytm);\n      GCC_DIAG_RESTORE_STMT;\n\n      if (buflen > 0 && buflen < bufsize)\n\tbreak;\n      /* heuristic to prevent out-of-memory errors */\n      if (bufsize > 100*fmtlen) {\n\tSafefree(buf);\n\tbuf = NULL;\n\tbreak;\n      }\n      bufsize *= 2;\n      Renew(buf, bufsize, char);\n    }\n    return buf;\n  }\n#else\n  Perl_croak(aTHX_ \"panic: no strftime\");\n  return NULL;\n#endif\n}\n\n\n#define SV_CWD_RETURN_UNDEF \\\n    sv_set_undef(sv); \\\n    return FALSE\n\n#define SV_CWD_ISDOT(dp) \\\n    (dp->d_name[0] == '.' && (dp->d_name[1] == '\\0' || \\\n\t(dp->d_name[1] == '.' && dp->d_name[2] == '\\0')))\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc getcwd_sv\n\nFill C<sv> with current working directory\n\n=cut\n*/\n\n/* Originally written in Perl by John Bazik; rewritten in C by Ben Sugars.\n * rewritten again by dougm, optimized for use with xs TARG, and to prefer\n * getcwd(3) if available\n * Comments from the original:\n *     This is a faster version of getcwd.  It's also more dangerous\n *     because you might chdir out of a directory that you can't chdir\n *     back into. */\n\nint\nPerl_getcwd_sv(pTHX_ SV *sv)\n{\n#ifndef PERL_MICRO\n    SvTAINTED_on(sv);\n\n    PERL_ARGS_ASSERT_GETCWD_SV;\n\n#ifdef HAS_GETCWD\n    {\n\tchar buf[MAXPATHLEN];\n\n\t/* Some getcwd()s automatically allocate a buffer of the given\n\t * size from the heap if they are given a NULL buffer pointer.\n\t * The problem is that this behaviour is not portable. */\n\tif (getcwd(buf, sizeof(buf) - 1)) {\n\t    sv_setpv(sv, buf);\n\t    return TRUE;\n\t}\n\telse {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n    }\n\n#else\n\n    Stat_t statbuf;\n    int orig_cdev, orig_cino, cdev, cino, odev, oino, tdev, tino;\n    int pathlen=0;\n    Direntry_t *dp;\n\n    SvUPGRADE(sv, SVt_PV);\n\n    if (PerlLIO_lstat(\".\", &statbuf) < 0) {\n\tSV_CWD_RETURN_UNDEF;\n    }\n\n    orig_cdev = statbuf.st_dev;\n    orig_cino = statbuf.st_ino;\n    cdev = orig_cdev;\n    cino = orig_cino;\n\n    for (;;) {\n\tDIR *dir;\n\tint namelen;\n\todev = cdev;\n\toino = cino;\n\n\tif (PerlDir_chdir(\"..\") < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\tif (PerlLIO_stat(\".\", &statbuf) < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\tcdev = statbuf.st_dev;\n\tcino = statbuf.st_ino;\n\n\tif (odev == cdev && oino == cino) {\n\t    break;\n\t}\n\tif (!(dir = PerlDir_open(\".\"))) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\twhile ((dp = PerlDir_read(dir)) != NULL) {\n#ifdef DIRNAMLEN\n\t    namelen = dp->d_namlen;\n#else\n\t    namelen = strlen(dp->d_name);\n#endif\n\t    /* skip . and .. */\n\t    if (SV_CWD_ISDOT(dp)) {\n\t\tcontinue;\n\t    }\n\n\t    if (PerlLIO_lstat(dp->d_name, &statbuf) < 0) {\n\t\tSV_CWD_RETURN_UNDEF;\n\t    }\n\n\t    tdev = statbuf.st_dev;\n\t    tino = statbuf.st_ino;\n\t    if (tino == oino && tdev == odev) {\n\t\tbreak;\n\t    }\n\t}\n\n\tif (!dp) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\tif (pathlen + namelen + 1 >= MAXPATHLEN) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\tSvGROW(sv, pathlen + namelen + 1);\n\n\tif (pathlen) {\n\t    /* shift down */\n\t    Move(SvPVX_const(sv), SvPVX(sv) + namelen + 1, pathlen, char);\n\t}\n\n\t/* prepend current directory to the front */\n\t*SvPVX(sv) = '/';\n\tMove(dp->d_name, SvPVX(sv)+1, namelen, char);\n\tpathlen += (namelen + 1);\n\n#ifdef VOID_CLOSEDIR\n\tPerlDir_close(dir);\n#else\n\tif (PerlDir_close(dir) < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n#endif\n    }\n\n    if (pathlen) {\n\tSvCUR_set(sv, pathlen);\n\t*SvEND(sv) = '\\0';\n\tSvPOK_only(sv);\n\n\tif (PerlDir_chdir(SvPVX_const(sv)) < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n    }\n    if (PerlLIO_stat(\".\", &statbuf) < 0) {\n\tSV_CWD_RETURN_UNDEF;\n    }\n\n    cdev = statbuf.st_dev;\n    cino = statbuf.st_ino;\n\n    if (cdev != orig_cdev || cino != orig_cino) {\n\tPerl_croak(aTHX_ \"Unstable directory path, \"\n\t\t   \"current directory changed unexpectedly\");\n    }\n\n    return TRUE;\n#endif\n\n#else\n    return FALSE;\n#endif\n}\n\n#include \"vutil.c\"\n\n#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)\n#   define EMULATE_SOCKETPAIR_UDP\n#endif\n\n#ifdef EMULATE_SOCKETPAIR_UDP\nstatic int\nS_socketpair_udp (int fd[2]) {\n    dTHX;\n    /* Fake a datagram socketpair using UDP to localhost.  */\n    int sockets[2] = {-1, -1};\n    struct sockaddr_in addresses[2];\n    int i;\n    Sock_size_t size = sizeof(struct sockaddr_in);\n    unsigned short port;\n    int got;\n\n    memset(&addresses, 0, sizeof(addresses));\n    i = 1;\n    do {\n\tsockets[i] = PerlSock_socket(AF_INET, SOCK_DGRAM, PF_INET);\n\tif (sockets[i] == -1)\n\t    goto tidy_up_and_fail;\n\n\taddresses[i].sin_family = AF_INET;\n\taddresses[i].sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddresses[i].sin_port = 0;\t/* kernel choses port.  */\n\tif (PerlSock_bind(sockets[i], (struct sockaddr *) &addresses[i],\n\t\tsizeof(struct sockaddr_in)) == -1)\n\t    goto tidy_up_and_fail;\n    } while (i--);\n\n    /* Now have 2 UDP sockets. Find out which port each is connected to, and\n       for each connect the other socket to it.  */\n    i = 1;\n    do {\n\tif (PerlSock_getsockname(sockets[i], (struct sockaddr *) &addresses[i],\n\t\t&size) == -1)\n\t    goto tidy_up_and_fail;\n\tif (size != sizeof(struct sockaddr_in))\n\t    goto abort_tidy_up_and_fail;\n\t/* !1 is 0, !0 is 1 */\n\tif (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],\n\t\tsizeof(struct sockaddr_in)) == -1)\n\t    goto tidy_up_and_fail;\n    } while (i--);\n\n    /* Now we have 2 sockets connected to each other. I don't trust some other\n       process not to have already sent a packet to us (by random) so send\n       a packet from each to the other.  */\n    i = 1;\n    do {\n\t/* I'm going to send my own port number.  As a short.\n\t   (Who knows if someone somewhere has sin_port as a bitfield and needs\n\t   this routine. (I'm assuming crays have socketpair)) */\n\tport = addresses[i].sin_port;\n\tgot = PerlLIO_write(sockets[i], &port, sizeof(port));\n\tif (got != sizeof(port)) {\n\t    if (got == -1)\n\t\tgoto tidy_up_and_fail;\n\t    goto abort_tidy_up_and_fail;\n\t}\n    } while (i--);\n\n    /* Packets sent. I don't trust them to have arrived though.\n       (As I understand it Solaris TCP stack is multithreaded. Non-blocking\n       connect to localhost will use a second kernel thread. In 2.6 the\n       first thread running the connect() returns before the second completes,\n       so EINPROGRESS> In 2.7 the improved stack is faster and connect()\n       returns 0. Poor programs have tripped up. One poor program's authors'\n       had a 50-1 reverse stock split. Not sure how connected these were.)\n       So I don't trust someone not to have an unpredictable UDP stack.\n    */\n\n    {\n\tstruct timeval waitfor = {0, 100000}; /* You have 0.1 seconds */\n\tint max = sockets[1] > sockets[0] ? sockets[1] : sockets[0];\n\tfd_set rset;\n\n\tFD_ZERO(&rset);\n\tFD_SET((unsigned int)sockets[0], &rset);\n\tFD_SET((unsigned int)sockets[1], &rset);\n\n\tgot = PerlSock_select(max + 1, &rset, NULL, NULL, &waitfor);\n\tif (got != 2 || !FD_ISSET(sockets[0], &rset)\n\t\t|| !FD_ISSET(sockets[1], &rset)) {\n\t    /* I hope this is portable and appropriate.  */\n\t    if (got == -1)\n\t\tgoto tidy_up_and_fail;\n\t    goto abort_tidy_up_and_fail;\n\t}\n    }\n\n    /* And the paranoia department even now doesn't trust it to have arrive\n       (hence MSG_DONTWAIT). Or that what arrives was sent by us.  */\n    {\n\tstruct sockaddr_in readfrom;\n\tunsigned short buffer[2];\n\n\ti = 1;\n\tdo {\n#ifdef MSG_DONTWAIT\n\t    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,\n\t\t    sizeof(buffer), MSG_DONTWAIT,\n\t\t    (struct sockaddr *) &readfrom, &size);\n#else\n\t    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,\n\t\t    sizeof(buffer), 0,\n\t\t    (struct sockaddr *) &readfrom, &size);\n#endif\n\n\t    if (got == -1)\n\t\tgoto tidy_up_and_fail;\n\t    if (got != sizeof(port)\n\t\t    || size != sizeof(struct sockaddr_in)\n\t\t    /* Check other socket sent us its port.  */\n\t\t    || buffer[0] != (unsigned short) addresses[!i].sin_port\n\t\t    /* Check kernel says we got the datagram from that socket */\n\t\t    || readfrom.sin_family != addresses[!i].sin_family\n\t\t    || readfrom.sin_addr.s_addr != addresses[!i].sin_addr.s_addr\n\t\t    || readfrom.sin_port != addresses[!i].sin_port)\n\t\tgoto abort_tidy_up_and_fail;\n\t} while (i--);\n    }\n    /* My caller (my_socketpair) has validated that this is non-NULL  */\n    fd[0] = sockets[0];\n    fd[1] = sockets[1];\n    /* I hereby declare this connection open.  May God bless all who cross\n       her.  */\n    return 0;\n\n  abort_tidy_up_and_fail:\n    errno = ECONNABORTED;\n  tidy_up_and_fail:\n    {\n\tdSAVE_ERRNO;\n\tif (sockets[0] != -1)\n\t    PerlLIO_close(sockets[0]);\n\tif (sockets[1] != -1)\n\t    PerlLIO_close(sockets[1]);\n\tRESTORE_ERRNO;\n\treturn -1;\n    }\n}\n#endif /*  EMULATE_SOCKETPAIR_UDP */\n\n#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET)\nint\nPerl_my_socketpair (int family, int type, int protocol, int fd[2]) {\n    /* Stevens says that family must be AF_LOCAL, protocol 0.\n       I'm going to enforce that, then ignore it, and use TCP (or UDP).  */\n    dTHXa(NULL);\n    int listener = -1;\n    int connector = -1;\n    int acceptor = -1;\n    struct sockaddr_in listen_addr;\n    struct sockaddr_in connect_addr;\n    Sock_size_t size;\n\n    if (protocol\n#ifdef AF_UNIX\n\t|| family != AF_UNIX\n#endif\n    ) {\n\terrno = EAFNOSUPPORT;\n\treturn -1;\n    }\n    if (!fd) {\n\terrno = EINVAL;\n\treturn -1;\n    }\n\n#ifdef SOCK_CLOEXEC\n    type &= ~SOCK_CLOEXEC;\n#endif\n\n#ifdef EMULATE_SOCKETPAIR_UDP\n    if (type == SOCK_DGRAM)\n\treturn S_socketpair_udp(fd);\n#endif\n\n    aTHXa(PERL_GET_THX);\n    listener = PerlSock_socket(AF_INET, type, 0);\n    if (listener == -1)\n\treturn -1;\n    memset(&listen_addr, 0, sizeof(listen_addr));\n    listen_addr.sin_family = AF_INET;\n    listen_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    listen_addr.sin_port = 0;\t/* kernel choses port.  */\n    if (PerlSock_bind(listener, (struct sockaddr *) &listen_addr,\n\t    sizeof(listen_addr)) == -1)\n\tgoto tidy_up_and_fail;\n    if (PerlSock_listen(listener, 1) == -1)\n\tgoto tidy_up_and_fail;\n\n    connector = PerlSock_socket(AF_INET, type, 0);\n    if (connector == -1)\n\tgoto tidy_up_and_fail;\n    /* We want to find out the port number to connect to.  */\n    size = sizeof(connect_addr);\n    if (PerlSock_getsockname(listener, (struct sockaddr *) &connect_addr,\n\t    &size) == -1)\n\tgoto tidy_up_and_fail;\n    if (size != sizeof(connect_addr))\n\tgoto abort_tidy_up_and_fail;\n    if (PerlSock_connect(connector, (struct sockaddr *) &connect_addr,\n\t    sizeof(connect_addr)) == -1)\n\tgoto tidy_up_and_fail;\n\n    size = sizeof(listen_addr);\n    acceptor = PerlSock_accept(listener, (struct sockaddr *) &listen_addr,\n\t    &size);\n    if (acceptor == -1)\n\tgoto tidy_up_and_fail;\n    if (size != sizeof(listen_addr))\n\tgoto abort_tidy_up_and_fail;\n    PerlLIO_close(listener);\n    /* Now check we are talking to ourself by matching port and host on the\n       two sockets.  */\n    if (PerlSock_getsockname(connector, (struct sockaddr *) &connect_addr,\n\t    &size) == -1)\n\tgoto tidy_up_and_fail;\n    if (size != sizeof(connect_addr)\n\t    || listen_addr.sin_family != connect_addr.sin_family\n\t    || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr\n\t    || listen_addr.sin_port != connect_addr.sin_port) {\n\tgoto abort_tidy_up_and_fail;\n    }\n    fd[0] = connector;\n    fd[1] = acceptor;\n    return 0;\n\n  abort_tidy_up_and_fail:\n#ifdef ECONNABORTED\n  errno = ECONNABORTED;\t/* This would be the standard thing to do. */\n#elif defined(ECONNREFUSED)\n  errno = ECONNREFUSED;\t/* E.g. Symbian does not have ECONNABORTED. */\n#else\n  errno = ETIMEDOUT;\t/* Desperation time. */\n#endif\n  tidy_up_and_fail:\n    {\n\tdSAVE_ERRNO;\n\tif (listener != -1)\n\t    PerlLIO_close(listener);\n\tif (connector != -1)\n\t    PerlLIO_close(connector);\n\tif (acceptor != -1)\n\t    PerlLIO_close(acceptor);\n\tRESTORE_ERRNO;\n\treturn -1;\n    }\n}\n#else\n/* In any case have a stub so that there's code corresponding\n * to the my_socketpair in embed.fnc. */\nint\nPerl_my_socketpair (int family, int type, int protocol, int fd[2]) {\n#ifdef HAS_SOCKETPAIR\n    return socketpair(family, type, protocol, fd);\n#else\n    return -1;\n#endif\n}\n#endif\n\n/*\n\n=for apidoc sv_nosharing\n\nDummy routine which \"shares\" an SV when there is no sharing module present.\nOr \"locks\" it.  Or \"unlocks\" it.  In other\nwords, ignores its single SV argument.\nExists to avoid test for a C<NULL> function pointer and because it could\npotentially warn under some level of strict-ness.\n\n=cut\n*/\n\nvoid\nPerl_sv_nosharing(pTHX_ SV *sv)\n{\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n}\n\n/*\n\n=for apidoc sv_destroyable\n\nDummy routine which reports that object can be destroyed when there is no\nsharing module present.  It ignores its single SV argument, and returns\n'true'.  Exists to avoid test for a C<NULL> function pointer and because it\ncould potentially warn under some level of strict-ness.\n\n=cut\n*/\n\nbool\nPerl_sv_destroyable(pTHX_ SV *sv)\n{\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n    return TRUE;\n}\n\nU32\nPerl_parse_unicode_opts(pTHX_ const char **popt)\n{\n  const char *p = *popt;\n  U32 opt = 0;\n\n  PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS;\n\n  if (*p) {\n       if (isDIGIT(*p)) {\n            const char* endptr = p + strlen(p);\n            UV uv;\n            if (grok_atoUV(p, &uv, &endptr) && uv <= U32_MAX) {\n                opt = (U32)uv;\n                p = endptr;\n                if (p && *p && *p != '\\n' && *p != '\\r') {\n                    if (isSPACE(*p))\n                        goto the_end_of_the_opts_parser;\n                    else\n                        Perl_croak(aTHX_ \"Unknown Unicode option letter '%c'\", *p);\n                }\n            }\n            else {\n                Perl_croak(aTHX_ \"Invalid number '%s' for -C option.\\n\", p);\n            }\n        }\n        else {\n\t    for (; *p; p++) {\n\t\t switch (*p) {\n\t\t case PERL_UNICODE_STDIN:\n\t\t      opt |= PERL_UNICODE_STDIN_FLAG;\tbreak;\n\t\t case PERL_UNICODE_STDOUT:\n\t\t      opt |= PERL_UNICODE_STDOUT_FLAG;\tbreak;\n\t\t case PERL_UNICODE_STDERR:\n\t\t      opt |= PERL_UNICODE_STDERR_FLAG;\tbreak;\n\t\t case PERL_UNICODE_STD:\n\t\t      opt |= PERL_UNICODE_STD_FLAG;    \tbreak;\n\t\t case PERL_UNICODE_IN:\n\t\t      opt |= PERL_UNICODE_IN_FLAG;\tbreak;\n\t\t case PERL_UNICODE_OUT:\n\t\t      opt |= PERL_UNICODE_OUT_FLAG;\tbreak;\n\t\t case PERL_UNICODE_INOUT:\n\t\t      opt |= PERL_UNICODE_INOUT_FLAG;\tbreak;\n\t\t case PERL_UNICODE_LOCALE:\n\t\t      opt |= PERL_UNICODE_LOCALE_FLAG;\tbreak;\n\t\t case PERL_UNICODE_ARGV:\n\t\t      opt |= PERL_UNICODE_ARGV_FLAG;\tbreak;\n\t\t case PERL_UNICODE_UTF8CACHEASSERT:\n\t\t      opt |= PERL_UNICODE_UTF8CACHEASSERT_FLAG; break;\n\t\t default:\n\t\t      if (*p != '\\n' && *p != '\\r') {\n\t\t\tif(isSPACE(*p)) goto the_end_of_the_opts_parser;\n\t\t\telse\n\t\t\t  Perl_croak(aTHX_\n\t\t\t\t     \"Unknown Unicode option letter '%c'\", *p);\n\t\t      }\n\t\t }\n\t    }\n       }\n  }\n  else\n       opt = PERL_UNICODE_DEFAULT_FLAGS;\n\n  the_end_of_the_opts_parser:\n\n  if (opt & ~PERL_UNICODE_ALL_FLAGS)\n       Perl_croak(aTHX_ \"Unknown Unicode option value %\" UVuf,\n\t\t  (UV) (opt & ~PERL_UNICODE_ALL_FLAGS));\n\n  *popt = p;\n\n  return opt;\n}\n\n#ifdef VMS\n#  include <starlet.h>\n#endif\n\nU32\nPerl_seed(pTHX)\n{\n    /*\n     * This is really just a quick hack which grabs various garbage\n     * values.  It really should be a real hash algorithm which\n     * spreads the effect of every input bit onto every output bit,\n     * if someone who knows about such things would bother to write it.\n     * Might be a good idea to add that function to CORE as well.\n     * No numbers below come from careful analysis or anything here,\n     * except they are primes and SEED_C1 > 1E6 to get a full-width\n     * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should\n     * probably be bigger too.\n     */\n#if RANDBITS > 16\n#  define SEED_C1\t1000003\n#define   SEED_C4\t73819\n#else\n#  define SEED_C1\t25747\n#define   SEED_C4\t20639\n#endif\n#define   SEED_C2\t3\n#define   SEED_C3\t269\n#define   SEED_C5\t26107\n\n#ifndef PERL_NO_DEV_RANDOM\n    int fd;\n#endif\n    U32 u;\n#ifdef HAS_GETTIMEOFDAY\n    struct timeval when;\n#else\n    Time_t when;\n#endif\n\n/* This test is an escape hatch, this symbol isn't set by Configure. */\n#ifndef PERL_NO_DEV_RANDOM\n#ifndef PERL_RANDOM_DEVICE\n   /* /dev/random isn't used by default because reads from it will block\n    * if there isn't enough entropy available.  You can compile with\n    * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there\n    * is enough real entropy to fill the seed. */\n#  ifdef __amigaos4__\n#    define PERL_RANDOM_DEVICE \"RANDOM:SIZE=4\"\n#  else\n#    define PERL_RANDOM_DEVICE \"/dev/urandom\"\n#  endif\n#endif\n    fd = PerlLIO_open_cloexec(PERL_RANDOM_DEVICE, 0);\n    if (fd != -1) {\n    \tif (PerlLIO_read(fd, (void*)&u, sizeof u) != sizeof u)\n\t    u = 0;\n\tPerlLIO_close(fd);\n\tif (u)\n\t    return u;\n    }\n#endif\n\n#ifdef HAS_GETTIMEOFDAY\n    PerlProc_gettimeofday(&when,NULL);\n    u = (U32)SEED_C1 * when.tv_sec + (U32)SEED_C2 * when.tv_usec;\n#else\n    (void)time(&when);\n    u = (U32)SEED_C1 * when;\n#endif\n    u += SEED_C3 * (U32)PerlProc_getpid();\n    u += SEED_C4 * (U32)PTR2UV(PL_stack_sp);\n#ifndef PLAN9           /* XXX Plan9 assembler chokes on this; fix needed  */\n    u += SEED_C5 * (U32)PTR2UV(&when);\n#endif\n    return u;\n}\n\nvoid\nPerl_get_hash_seed(pTHX_ unsigned char * const seed_buffer)\n{\n#ifndef NO_PERL_HASH_ENV\n    const char *env_pv;\n#endif\n    unsigned long i;\n\n    PERL_ARGS_ASSERT_GET_HASH_SEED;\n\n#ifndef NO_PERL_HASH_ENV\n    env_pv= PerlEnv_getenv(\"PERL_HASH_SEED\");\n\n    if ( env_pv )\n    {\n        /* ignore leading spaces */\n        while (isSPACE(*env_pv))\n            env_pv++;\n#    ifdef USE_PERL_PERTURB_KEYS\n        /* if they set it to \"0\" we disable key traversal randomization completely */\n        if (strEQ(env_pv,\"0\")) {\n            PL_hash_rand_bits_enabled= 0;\n        } else {\n            /* otherwise switch to deterministic mode */\n            PL_hash_rand_bits_enabled= 2;\n        }\n#    endif\n        /* ignore a leading 0x... if it is there */\n        if (env_pv[0] == '0' && env_pv[1] == 'x')\n            env_pv += 2;\n\n        for( i = 0; isXDIGIT(*env_pv) && i < PERL_HASH_SEED_BYTES; i++ ) {\n            seed_buffer[i] = READ_XDIGIT(env_pv) << 4;\n            if ( isXDIGIT(*env_pv)) {\n                seed_buffer[i] |= READ_XDIGIT(env_pv);\n            }\n        }\n        while (isSPACE(*env_pv))\n            env_pv++;\n\n        if (*env_pv && !isXDIGIT(*env_pv)) {\n            Perl_warn(aTHX_ \"perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set\\n\");\n        }\n        /* should we check for unparsed crap? */\n        /* should we warn about unused hex? */\n        /* should we warn about insufficient hex? */\n    }\n    else\n#endif /* NO_PERL_HASH_ENV */\n    {\n        for( i = 0; i < PERL_HASH_SEED_BYTES; i++ ) {\n            seed_buffer[i] = (unsigned char)(Perl_internal_drand48() * (U8_MAX+1));\n        }\n    }\n#ifdef USE_PERL_PERTURB_KEYS\n    {   /* initialize PL_hash_rand_bits from the hash seed.\n         * This value is highly volatile, it is updated every\n         * hash insert, and is used as part of hash bucket chain\n         * randomization and hash iterator randomization. */\n        PL_hash_rand_bits= 0xbe49d17f; /* I just picked a number */\n        for( i = 0; i < sizeof(UV) ; i++ ) {\n            PL_hash_rand_bits += seed_buffer[i % PERL_HASH_SEED_BYTES];\n            PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,8);\n        }\n    }\n#  ifndef NO_PERL_HASH_ENV\n    env_pv= PerlEnv_getenv(\"PERL_PERTURB_KEYS\");\n    if (env_pv) {\n        if (strEQ(env_pv,\"0\") || strEQ(env_pv,\"NO\")) {\n            PL_hash_rand_bits_enabled= 0;\n        } else if (strEQ(env_pv,\"1\") || strEQ(env_pv,\"RANDOM\")) {\n            PL_hash_rand_bits_enabled= 1;\n        } else if (strEQ(env_pv,\"2\") || strEQ(env_pv,\"DETERMINISTIC\")) {\n            PL_hash_rand_bits_enabled= 2;\n        } else {\n            Perl_warn(aTHX_ \"perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'\\n\", env_pv);\n        }\n    }\n#  endif\n#endif\n}\n\n#ifdef PERL_GLOBAL_STRUCT\n\n#define PERL_GLOBAL_STRUCT_INIT\n#include \"opcode.h\" /* the ppaddr and check */\n\nstruct perl_vars *\nPerl_init_global_struct(pTHX)\n{\n    struct perl_vars *plvarsp = NULL;\n# ifdef PERL_GLOBAL_STRUCT\n    const IV nppaddr = C_ARRAY_LENGTH(Gppaddr);\n    const IV ncheck  = C_ARRAY_LENGTH(Gcheck);\n    PERL_UNUSED_CONTEXT;\n#  ifdef PERL_GLOBAL_STRUCT_PRIVATE\n    /* PerlMem_malloc() because can't use even safesysmalloc() this early. */\n    plvarsp = (struct perl_vars*)PerlMem_malloc(sizeof(struct perl_vars));\n    if (!plvarsp)\n        exit(1);\n#  else\n    plvarsp = PL_VarsPtr;\n#  endif /* PERL_GLOBAL_STRUCT_PRIVATE */\n#  undef PERLVAR\n#  undef PERLVARA\n#  undef PERLVARI\n#  undef PERLVARIC\n#  define PERLVAR(prefix,var,type) /**/\n#  define PERLVARA(prefix,var,n,type) /**/\n#  define PERLVARI(prefix,var,type,init) plvarsp->prefix##var = init;\n#  define PERLVARIC(prefix,var,type,init) plvarsp->prefix##var = init;\n#  include \"perlvars.h\"\n#  undef PERLVAR\n#  undef PERLVARA\n#  undef PERLVARI\n#  undef PERLVARIC\n#  ifdef PERL_GLOBAL_STRUCT\n    plvarsp->Gppaddr =\n\t(Perl_ppaddr_t*)\n\tPerlMem_malloc(nppaddr * sizeof(Perl_ppaddr_t));\n    if (!plvarsp->Gppaddr)\n        exit(1);\n    plvarsp->Gcheck  =\n\t(Perl_check_t*)\n\tPerlMem_malloc(ncheck  * sizeof(Perl_check_t));\n    if (!plvarsp->Gcheck)\n        exit(1);\n    Copy(Gppaddr, plvarsp->Gppaddr, nppaddr, Perl_ppaddr_t); \n    Copy(Gcheck,  plvarsp->Gcheck,  ncheck,  Perl_check_t); \n#  endif\n#  ifdef PERL_SET_VARS\n    PERL_SET_VARS(plvarsp);\n#  endif\n#  ifdef PERL_GLOBAL_STRUCT_PRIVATE\n    plvarsp->Gsv_placeholder.sv_flags = 0;\n    memset(plvarsp->Ghash_seed, 0, sizeof(plvarsp->Ghash_seed));\n#  endif\n# undef PERL_GLOBAL_STRUCT_INIT\n# endif\n    return plvarsp;\n}\n\n#endif /* PERL_GLOBAL_STRUCT */\n\n#ifdef PERL_GLOBAL_STRUCT\n\nvoid\nPerl_free_global_struct(pTHX_ struct perl_vars *plvarsp)\n{\n    int veto = plvarsp->Gveto_cleanup;\n\n    PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT;\n    PERL_UNUSED_CONTEXT;\n# ifdef PERL_GLOBAL_STRUCT\n#  ifdef PERL_UNSET_VARS\n    PERL_UNSET_VARS(plvarsp);\n#  endif\n    if (veto)\n        return;\n    free(plvarsp->Gppaddr);\n    free(plvarsp->Gcheck);\n#  ifdef PERL_GLOBAL_STRUCT_PRIVATE\n    free(plvarsp);\n#  endif\n# endif\n}\n\n#endif /* PERL_GLOBAL_STRUCT */\n\n#ifdef PERL_MEM_LOG\n\n/* -DPERL_MEM_LOG: the Perl_mem_log_..() is compiled, including\n * the default implementation, unless -DPERL_MEM_LOG_NOIMPL is also\n * given, and you supply your own implementation.\n *\n * The default implementation reads a single env var, PERL_MEM_LOG,\n * expecting one or more of the following:\n *\n *    \\d+ - fd\t\tfd to write to\t\t: must be 1st (grok_atoUV)\n *    'm' - memlog\twas PERL_MEM_LOG=1\n *    's' - svlog\twas PERL_SV_LOG=1\n *    't' - timestamp\twas PERL_MEM_LOG_TIMESTAMP=1\n *\n * This makes the logger controllable enough that it can reasonably be\n * added to the system perl.\n */\n\n/* -DPERL_MEM_LOG_SPRINTF_BUF_SIZE=X: size of a (stack-allocated) buffer\n * the Perl_mem_log_...() will use (either via sprintf or snprintf).\n */\n#define PERL_MEM_LOG_SPRINTF_BUF_SIZE 128\n\n/* -DPERL_MEM_LOG_FD=N: the file descriptor the Perl_mem_log_...()\n * writes to.  In the default logger, this is settable at runtime.\n */\n#ifndef PERL_MEM_LOG_FD\n#  define PERL_MEM_LOG_FD 2 /* If STDERR is too boring for you. */\n#endif\n\n#ifndef PERL_MEM_LOG_NOIMPL\n\n# ifdef DEBUG_LEAKING_SCALARS\n#   define SV_LOG_SERIAL_FMT\t    \" [%lu]\"\n#   define _SV_LOG_SERIAL_ARG(sv)   , (unsigned long) (sv)->sv_debug_serial\n# else\n#   define SV_LOG_SERIAL_FMT\n#   define _SV_LOG_SERIAL_ARG(sv)\n# endif\n\nstatic void\nS_mem_log_common(enum mem_log_type mlt, const UV n, \n\t\t const UV typesize, const char *type_name, const SV *sv,\n\t\t Malloc_t oldalloc, Malloc_t newalloc,\n\t\t const char *filename, const int linenumber,\n\t\t const char *funcname)\n{\n    const char *pmlenv;\n\n    PERL_ARGS_ASSERT_MEM_LOG_COMMON;\n\n    pmlenv = PerlEnv_getenv(\"PERL_MEM_LOG\");\n    if (!pmlenv)\n\treturn;\n    if (mlt < MLT_NEW_SV ? strchr(pmlenv,'m') : strchr(pmlenv,'s'))\n    {\n\t/* We can't use SVs or PerlIO for obvious reasons,\n\t * so we'll use stdio and low-level IO instead. */\n\tchar buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];\n\n#   ifdef HAS_GETTIMEOFDAY\n#     define MEM_LOG_TIME_FMT\t\"%10d.%06d: \"\n#     define MEM_LOG_TIME_ARG\t(int)tv.tv_sec, (int)tv.tv_usec\n\tstruct timeval tv;\n\tgettimeofday(&tv, 0);\n#   else\n#     define MEM_LOG_TIME_FMT\t\"%10d: \"\n#     define MEM_LOG_TIME_ARG\t(int)when\n        Time_t when;\n        (void)time(&when);\n#   endif\n\t/* If there are other OS specific ways of hires time than\n\t * gettimeofday() (see dist/Time-HiRes), the easiest way is\n\t * probably that they would be used to fill in the struct\n\t * timeval. */\n\t{\n\t    STRLEN len;\n            const char* endptr = pmlenv + stren(pmlenv);\n\t    int fd;\n            UV uv;\n            if (grok_atoUV(pmlenv, &uv, &endptr) /* Ignore endptr. */\n                && uv && uv <= PERL_INT_MAX\n            ) {\n                fd = (int)uv;\n            } else {\n\t\tfd = PERL_MEM_LOG_FD;\n            }\n\n\t    if (strchr(pmlenv, 't')) {\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\tMEM_LOG_TIME_FMT, MEM_LOG_TIME_ARG);\n\t\tPERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));\n\t    }\n\t    switch (mlt) {\n\t    case MLT_ALLOC:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"alloc: %s:%d:%s: %\" IVdf \" %\" UVuf\n\t\t\t\" %s = %\" IVdf \": %\" UVxf \"\\n\",\n\t\t\tfilename, linenumber, funcname, n, typesize,\n\t\t\ttype_name, n * typesize, PTR2UV(newalloc));\n\t\tbreak;\n\t    case MLT_REALLOC:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"realloc: %s:%d:%s: %\" IVdf \" %\" UVuf\n\t\t\t\" %s = %\" IVdf \": %\" UVxf \" -> %\" UVxf \"\\n\",\n\t\t\tfilename, linenumber, funcname, n, typesize,\n\t\t\ttype_name, n * typesize, PTR2UV(oldalloc),\n\t\t\tPTR2UV(newalloc));\n\t\tbreak;\n\t    case MLT_FREE:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"free: %s:%d:%s: %\" UVxf \"\\n\",\n\t\t\tfilename, linenumber, funcname,\n\t\t\tPTR2UV(oldalloc));\n\t\tbreak;\n\t    case MLT_NEW_SV:\n\t    case MLT_DEL_SV:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"%s_SV: %s:%d:%s: %\" UVxf SV_LOG_SERIAL_FMT \"\\n\",\n\t\t\tmlt == MLT_NEW_SV ? \"new\" : \"del\",\n\t\t\tfilename, linenumber, funcname,\n\t\t\tPTR2UV(sv) _SV_LOG_SERIAL_ARG(sv));\n\t\tbreak;\n\t    default:\n\t\tlen = 0;\n\t    }\n\t    PERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));\n\t}\n    }\n}\n#endif /* !PERL_MEM_LOG_NOIMPL */\n\n#ifndef PERL_MEM_LOG_NOIMPL\n# define \\\n    mem_log_common_if(alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm) \\\n    mem_log_common   (alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm)\n#else\n/* this is suboptimal, but bug compatible.  User is providing their\n   own implementation, but is getting these functions anyway, and they\n   do nothing. But _NOIMPL users should be able to cope or fix */\n# define \\\n    mem_log_common_if(alty, num, tysz, tynm, u, oal, nal, flnm, ln, fnnm) \\\n    /* mem_log_common_if_PERL_MEM_LOG_NOIMPL */\n#endif\n\nMalloc_t\nPerl_mem_log_alloc(const UV n, const UV typesize, const char *type_name,\n\t\t   Malloc_t newalloc, \n\t\t   const char *filename, const int linenumber,\n\t\t   const char *funcname)\n{\n    PERL_ARGS_ASSERT_MEM_LOG_ALLOC;\n\n    mem_log_common_if(MLT_ALLOC, n, typesize, type_name,\n\t\t      NULL, NULL, newalloc,\n\t\t      filename, linenumber, funcname);\n    return newalloc;\n}\n\nMalloc_t\nPerl_mem_log_realloc(const UV n, const UV typesize, const char *type_name,\n\t\t     Malloc_t oldalloc, Malloc_t newalloc, \n\t\t     const char *filename, const int linenumber, \n\t\t     const char *funcname)\n{\n    PERL_ARGS_ASSERT_MEM_LOG_REALLOC;\n\n    mem_log_common_if(MLT_REALLOC, n, typesize, type_name,\n\t\t      NULL, oldalloc, newalloc, \n\t\t      filename, linenumber, funcname);\n    return newalloc;\n}\n\nMalloc_t\nPerl_mem_log_free(Malloc_t oldalloc, \n\t\t  const char *filename, const int linenumber, \n\t\t  const char *funcname)\n{\n    PERL_ARGS_ASSERT_MEM_LOG_FREE;\n\n    mem_log_common_if(MLT_FREE, 0, 0, \"\", NULL, oldalloc, NULL, \n\t\t      filename, linenumber, funcname);\n    return oldalloc;\n}\n\nvoid\nPerl_mem_log_new_sv(const SV *sv, \n\t\t    const char *filename, const int linenumber,\n\t\t    const char *funcname)\n{\n    mem_log_common_if(MLT_NEW_SV, 0, 0, \"\", sv, NULL, NULL,\n\t\t      filename, linenumber, funcname);\n}\n\nvoid\nPerl_mem_log_del_sv(const SV *sv,\n\t\t    const char *filename, const int linenumber, \n\t\t    const char *funcname)\n{\n    mem_log_common_if(MLT_DEL_SV, 0, 0, \"\", sv, NULL, NULL, \n\t\t      filename, linenumber, funcname);\n}\n\n#endif /* PERL_MEM_LOG */\n\n/*\n=for apidoc quadmath_format_single\n\nC<quadmath_snprintf()> is very strict about its C<format> string and will\nfail, returning -1, if the format is invalid.  It accepts exactly\none format spec.\n\nC<quadmath_format_single()> checks that the intended single spec looks\nsane: begins with C<%>, has only one C<%>, ends with C<[efgaEFGA]>,\nand has C<Q> before it.  This is not a full \"printf syntax check\",\njust the basics.\n\nReturns the format if it is valid, NULL if not.\n\nC<quadmath_format_single()> can and will actually patch in the missing\nC<Q>, if necessary.  In this case it will return the modified copy of\nthe format, B<which the caller will need to free.>\n\nSee also L</quadmath_format_needed>.\n\n=cut\n*/\n#ifdef USE_QUADMATH\nconst char*\nPerl_quadmath_format_single(const char* format)\n{\n    STRLEN len;\n\n    PERL_ARGS_ASSERT_QUADMATH_FORMAT_SINGLE;\n\n    if (format[0] != '%' || strchr(format + 1, '%'))\n        return NULL;\n    len = strlen(format);\n    /* minimum length three: %Qg */\n    if (len < 3 || strchr(\"efgaEFGA\", format[len - 1]) == NULL)\n        return NULL;\n    if (format[len - 2] != 'Q') {\n        char* fixed;\n        Newx(fixed, len + 1, char);\n        memcpy(fixed, format, len - 1);\n        fixed[len - 1] = 'Q';\n        fixed[len    ] = format[len - 1];\n        fixed[len + 1] = 0;\n        return (const char*)fixed;\n    }\n    return format;\n}\n#endif\n\n/*\n=for apidoc quadmath_format_needed\n\nC<quadmath_format_needed()> returns true if the C<format> string seems to\ncontain at least one non-Q-prefixed C<%[efgaEFGA]> format specifier,\nor returns false otherwise.\n\nThe format specifier detection is not complete printf-syntax detection,\nbut it should catch most common cases.\n\nIf true is returned, those arguments B<should> in theory be processed\nwith C<quadmath_snprintf()>, but in case there is more than one such\nformat specifier (see L</quadmath_format_single>), and if there is\nanything else beyond that one (even just a single byte), they\nB<cannot> be processed because C<quadmath_snprintf()> is very strict,\naccepting only one format spec, and nothing else.\nIn this case, the code should probably fail.\n\n=cut\n*/\n#ifdef USE_QUADMATH\nbool\nPerl_quadmath_format_needed(const char* format)\n{\n  const char *p = format;\n  const char *q;\n\n  PERL_ARGS_ASSERT_QUADMATH_FORMAT_NEEDED;\n\n  while ((q = strchr(p, '%'))) {\n    q++;\n    if (*q == '+') /* plus */\n      q++;\n    if (*q == '#') /* alt */\n      q++;\n    if (*q == '*') /* width */\n      q++;\n    else {\n      if (isDIGIT(*q)) {\n        while (isDIGIT(*q)) q++;\n      }\n    }\n    if (*q == '.' && (q[1] == '*' || isDIGIT(q[1]))) { /* prec */\n      q++;\n      if (*q == '*')\n        q++;\n      else\n        while (isDIGIT(*q)) q++;\n    }\n    if (strchr(\"efgaEFGA\", *q)) /* Would have needed 'Q' in front. */\n      return TRUE;\n    p = q + 1;\n  }\n  return FALSE;\n}\n#endif\n\n/*\n=for apidoc my_snprintf\n\nThe C library C<snprintf> functionality, if available and\nstandards-compliant (uses C<vsnprintf>, actually).  However, if the\nC<vsnprintf> is not available, will unfortunately use the unsafe\nC<vsprintf> which can overrun the buffer (there is an overrun check,\nbut that may be too late).  Consider using C<sv_vcatpvf> instead, or\ngetting C<vsnprintf>.\n\n=cut\n*/\nint\nPerl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)\n{\n    int retval = -1;\n    va_list ap;\n    PERL_ARGS_ASSERT_MY_SNPRINTF;\n#ifndef HAS_VSNPRINTF\n    PERL_UNUSED_VAR(len);\n#endif\n    va_start(ap, format);\n#ifdef USE_QUADMATH\n    {\n        const char* qfmt = quadmath_format_single(format);\n        bool quadmath_valid = FALSE;\n        if (qfmt) {\n            /* If the format looked promising, use it as quadmath. */\n            retval = quadmath_snprintf(buffer, len, qfmt, va_arg(ap, NV));\n            if (retval == -1) {\n                if (qfmt != format) {\n                    dTHX;\n                    SAVEFREEPV(qfmt);\n                }\n                Perl_croak_nocontext(\"panic: quadmath_snprintf failed, format \\\"%s\\\"\", qfmt);\n            }\n            quadmath_valid = TRUE;\n            if (qfmt != format)\n                Safefree(qfmt);\n            qfmt = NULL;\n        }\n        assert(qfmt == NULL);\n        /* quadmath_format_single() will return false for example for\n         * \"foo = %g\", or simply \"%g\".  We could handle the %g by\n         * using quadmath for the NV args.  More complex cases of\n         * course exist: \"foo = %g, bar = %g\", or \"foo=%Qg\" (otherwise\n         * quadmath-valid but has stuff in front).\n         *\n         * Handling the \"Q-less\" cases right would require walking\n         * through the va_list and rewriting the format, calling\n         * quadmath for the NVs, building a new va_list, and then\n         * letting vsnprintf/vsprintf to take care of the other\n         * arguments.  This may be doable.\n         *\n         * We do not attempt that now.  But for paranoia, we here try\n         * to detect some common (but not all) cases where the\n         * \"Q-less\" %[efgaEFGA] formats are present, and die if\n         * detected.  This doesn't fix the problem, but it stops the\n         * vsnprintf/vsprintf pulling doubles off the va_list when\n         * __float128 NVs should be pulled off instead.\n         *\n         * If quadmath_format_needed() returns false, we are reasonably\n         * certain that we can call vnsprintf() or vsprintf() safely. */\n        if (!quadmath_valid && quadmath_format_needed(format))\n          Perl_croak_nocontext(\"panic: quadmath_snprintf failed, format \\\"%s\\\"\", format);\n\n    }\n#endif\n    if (retval == -1)\n#ifdef HAS_VSNPRINTF\n        retval = vsnprintf(buffer, len, format, ap);\n#else\n        retval = vsprintf(buffer, format, ap);\n#endif\n    va_end(ap);\n    /* vsprintf() shows failure with < 0 */\n    if (retval < 0\n#ifdef HAS_VSNPRINTF\n    /* vsnprintf() shows failure with >= len */\n        ||\n        (len > 0 && (Size_t)retval >= len)\n#endif\n    )\n\tPerl_croak_nocontext(\"panic: my_snprintf buffer overflow\");\n    return retval;\n}\n\n/*\n=for apidoc my_vsnprintf\n\nThe C library C<vsnprintf> if available and standards-compliant.\nHowever, if if the C<vsnprintf> is not available, will unfortunately\nuse the unsafe C<vsprintf> which can overrun the buffer (there is an\noverrun check, but that may be too late).  Consider using\nC<sv_vcatpvf> instead, or getting C<vsnprintf>.\n\n=cut\n*/\nint\nPerl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap)\n{\n#ifdef USE_QUADMATH\n    PERL_UNUSED_ARG(buffer);\n    PERL_UNUSED_ARG(len);\n    PERL_UNUSED_ARG(format);\n    /* the cast is to avoid gcc -Wsizeof-array-argument complaining */\n    PERL_UNUSED_ARG((void*)ap);\n    Perl_croak_nocontext(\"panic: my_vsnprintf not available with quadmath\");\n    return 0;\n#else\n    int retval;\n#ifdef NEED_VA_COPY\n    va_list apc;\n\n    PERL_ARGS_ASSERT_MY_VSNPRINTF;\n    Perl_va_copy(ap, apc);\n# ifdef HAS_VSNPRINTF\n    retval = vsnprintf(buffer, len, format, apc);\n# else\n    PERL_UNUSED_ARG(len);\n    retval = vsprintf(buffer, format, apc);\n# endif\n    va_end(apc);\n#else\n# ifdef HAS_VSNPRINTF\n    retval = vsnprintf(buffer, len, format, ap);\n# else\n    PERL_UNUSED_ARG(len);\n    retval = vsprintf(buffer, format, ap);\n# endif\n#endif /* #ifdef NEED_VA_COPY */\n    /* vsprintf() shows failure with < 0 */\n    if (retval < 0\n#ifdef HAS_VSNPRINTF\n    /* vsnprintf() shows failure with >= len */\n        ||\n        (len > 0 && (Size_t)retval >= len)\n#endif\n    )\n\tPerl_croak_nocontext(\"panic: my_vsnprintf buffer overflow\");\n    return retval;\n#endif\n}\n\nvoid\nPerl_my_clearenv(pTHX)\n{\n    dVAR;\n#if ! defined(PERL_MICRO)\n#  if defined(PERL_IMPLICIT_SYS) || defined(WIN32)\n    PerlEnv_clearenv();\n#  else /* ! (PERL_IMPLICIT_SYS || WIN32) */\n#    if defined(USE_ENVIRON_ARRAY)\n#      if defined(USE_ITHREADS)\n    /* only the parent thread can clobber the process environment */\n    if (PL_curinterp == aTHX)\n#      endif /* USE_ITHREADS */\n    {\n#      if ! defined(PERL_USE_SAFE_PUTENV)\n    if ( !PL_use_safe_putenv) {\n      I32 i;\n      if (environ == PL_origenviron)\n        environ = (char**)safesysmalloc(sizeof(char*));\n      else\n        for (i = 0; environ[i]; i++)\n          (void)safesysfree(environ[i]);\n    }\n    environ[0] = NULL;\n#      else /* PERL_USE_SAFE_PUTENV */\n#        if defined(HAS_CLEARENV)\n    (void)clearenv();\n#        elif defined(HAS_UNSETENV)\n    int bsiz = 80; /* Most envvar names will be shorter than this. */\n    char *buf = (char*)safesysmalloc(bsiz);\n    while (*environ != NULL) {\n      char *e = strchr(*environ, '=');\n      int l = e ? e - *environ : (int)strlen(*environ);\n      if (bsiz < l + 1) {\n        (void)safesysfree(buf);\n        bsiz = l + 1; /* + 1 for the \\0. */\n        buf = (char*)safesysmalloc(bsiz);\n      } \n      memcpy(buf, *environ, l);\n      buf[l] = '\\0';\n      (void)unsetenv(buf);\n    }\n    (void)safesysfree(buf);\n#        else /* ! HAS_CLEARENV && ! HAS_UNSETENV */\n    /* Just null environ and accept the leakage. */\n    *environ = NULL;\n#        endif /* HAS_CLEARENV || HAS_UNSETENV */\n#      endif /* ! PERL_USE_SAFE_PUTENV */\n    }\n#    endif /* USE_ENVIRON_ARRAY */\n#  endif /* PERL_IMPLICIT_SYS || WIN32 */\n#endif /* PERL_MICRO */\n}\n\n#ifdef PERL_IMPLICIT_CONTEXT\n\n/* Implements the MY_CXT_INIT macro. The first time a module is loaded,\nthe global PL_my_cxt_index is incremented, and that value is assigned to\nthat module's static my_cxt_index (who's address is passed as an arg).\nThen, for each interpreter this function is called for, it makes sure a\nvoid* slot is available to hang the static data off, by allocating or\nextending the interpreter's PL_my_cxt_list array */\n\n#ifndef PERL_GLOBAL_STRUCT_PRIVATE\nvoid *\nPerl_my_cxt_init(pTHX_ int *index, size_t size)\n{\n    dVAR;\n    void *p;\n    PERL_ARGS_ASSERT_MY_CXT_INIT;\n    if (*index == -1) {\n\t/* this module hasn't been allocated an index yet */\n\tMUTEX_LOCK(&PL_my_ctx_mutex);\n\t*index = PL_my_cxt_index++;\n\tMUTEX_UNLOCK(&PL_my_ctx_mutex);\n    }\n    \n    /* make sure the array is big enough */\n    if (PL_my_cxt_size <= *index) {\n\tif (PL_my_cxt_size) {\n            IV new_size = PL_my_cxt_size;\n\t    while (new_size <= *index)\n\t\tnew_size *= 2;\n\t    Renew(PL_my_cxt_list, new_size, void *);\n            PL_my_cxt_size = new_size;\n\t}\n\telse {\n\t    PL_my_cxt_size = 16;\n\t    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);\n\t}\n    }\n    /* newSV() allocates one more than needed */\n    p = (void*)SvPVX(newSV(size-1));\n    PL_my_cxt_list[*index] = p;\n    Zero(p, size, char);\n    return p;\n}\n\n#else /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */\n\nint\nPerl_my_cxt_index(pTHX_ const char *my_cxt_key)\n{\n    dVAR;\n    int index;\n\n    PERL_ARGS_ASSERT_MY_CXT_INDEX;\n\n    for (index = 0; index < PL_my_cxt_index; index++) {\n\tconst char *key = PL_my_cxt_keys[index];\n\t/* try direct pointer compare first - there are chances to success,\n\t * and it's much faster.\n\t */\n\tif ((key == my_cxt_key) || strEQ(key, my_cxt_key))\n\t    return index;\n    }\n    return -1;\n}\n\nvoid *\nPerl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size)\n{\n    dVAR;\n    void *p;\n    int index;\n\n    PERL_ARGS_ASSERT_MY_CXT_INIT;\n\n    index = Perl_my_cxt_index(aTHX_ my_cxt_key);\n    if (index == -1) {\n\t/* this module hasn't been allocated an index yet */\n\tMUTEX_LOCK(&PL_my_ctx_mutex);\n\tindex = PL_my_cxt_index++;\n\tMUTEX_UNLOCK(&PL_my_ctx_mutex);\n    }\n\n    /* make sure the array is big enough */\n    if (PL_my_cxt_size <= index) {\n\tint old_size = PL_my_cxt_size;\n\tint i;\n\tif (PL_my_cxt_size) {\n            IV new_size = PL_my_cxt_size;\n\t    while (new_size <= index)\n\t\tnew_size *= 2;\n\t    Renew(PL_my_cxt_list, new_size, void *);\n\t    Renew(PL_my_cxt_keys, new_size, const char *);\n            PL_my_cxt_size = new_size;\n\t}\n\telse {\n\t    PL_my_cxt_size = 16;\n\t    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);\n\t    Newx(PL_my_cxt_keys, PL_my_cxt_size, const char *);\n\t}\n\tfor (i = old_size; i < PL_my_cxt_size; i++) {\n\t    PL_my_cxt_keys[i] = 0;\n\t    PL_my_cxt_list[i] = 0;\n\t}\n    }\n    PL_my_cxt_keys[index] = my_cxt_key;\n    /* newSV() allocates one more than needed */\n    p = (void*)SvPVX(newSV(size-1));\n    PL_my_cxt_list[index] = p;\n    Zero(p, size, char);\n    return p;\n}\n#endif /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */\n#endif /* PERL_IMPLICIT_CONTEXT */\n\n\n/* Perl_xs_handshake():\n   implement the various XS_*_BOOTCHECK macros, which are added to .c\n   files by ExtUtils::ParseXS, to check that the perl the module was built\n   with is binary compatible with the running perl.\n\n   usage:\n       Perl_xs_handshake(U32 key, void * v_my_perl, const char * file,\n            [U32 items, U32 ax], [char * api_version], [char * xs_version])\n\n   The meaning of the varargs is determined the U32 key arg (which is not\n   a format string). The fields of key are assembled by using HS_KEY().\n\n   Under PERL_IMPLICIT_CONTEX, the v_my_perl arg is of type\n   \"PerlInterpreter *\" and represents the callers context; otherwise it is\n   of type \"CV *\", and is the boot xsub's CV.\n\n   v_my_perl will catch where a threaded future perl526.dll calling IO.dll\n   for example, and IO.dll was linked with threaded perl524.dll, and both\n   perl526.dll and perl524.dll are in %PATH and the Win32 DLL loader\n   successfully can load IO.dll into the process but simultaneously it\n   loaded an interpreter of a different version into the process, and XS\n   code will naturally pass SV*s created by perl524.dll for perl526.dll to\n   use through perl526.dll's my_perl->Istack_base.\n\n   v_my_perl cannot be the first arg, since then 'key' will be out of\n   place in a threaded vs non-threaded mixup; and analyzing the key\n   number's bitfields won't reveal the problem, since it will be a valid\n   key (unthreaded perl) on interp side, but croak will report the XS mod's\n   key as gibberish (it is really a my_perl ptr) (threaded XS mod); or if\n   it's a threaded perl and an unthreaded XS module, threaded perl will\n   look at an uninit C stack or an uninit register to get 'key'\n   (remember that it assumes that the 1st arg is the interp cxt).\n\n   'file' is the source filename of the caller.\n*/\n\nI32\nPerl_xs_handshake(const U32 key, void * v_my_perl, const char * file, ...)\n{\n    va_list args;\n    U32 items, ax;\n    void * got;\n    void * need;\n#ifdef PERL_IMPLICIT_CONTEXT\n    dTHX;\n    tTHX xs_interp;\n#else\n    CV* cv;\n    SV *** xs_spp;\n#endif\n    PERL_ARGS_ASSERT_XS_HANDSHAKE;\n    va_start(args, file);\n\n    got = INT2PTR(void*, (UV)(key & HSm_KEY_MATCH));\n    need = (void *)(HS_KEY(FALSE, FALSE, \"\", \"\") & HSm_KEY_MATCH);\n    if (UNLIKELY(got != need))\n\tgoto bad_handshake;\n/* try to catch where a 2nd threaded perl interp DLL is loaded into a process\n   by a XS DLL compiled against the wrong interl DLL b/c of bad @INC, and the\n   2nd threaded perl interp DLL never initialized its TLS/PERL_SYS_INIT3 so\n   dTHX call from 2nd interp DLL can't return the my_perl that pp_entersub\n   passed to the XS DLL */\n#ifdef PERL_IMPLICIT_CONTEXT\n    xs_interp = (tTHX)v_my_perl;\n    got = xs_interp;\n    need = my_perl;\n#else\n/* try to catch where an unthreaded perl interp DLL (for ex. perl522.dll) is\n   loaded into a process by a XS DLL built by an unthreaded perl522.dll perl,\n   but the DynaLoder/Perl that started the process and loaded the XS DLL is\n   unthreaded perl524.dll, since unthreadeds don't pass my_perl (a unique *)\n   through pp_entersub, use a unique value (which is a pointer to PL_stack_sp's\n   location in the unthreaded perl binary) stored in CV * to figure out if this\n   Perl_xs_handshake was called by the same pp_entersub */\n    cv = (CV*)v_my_perl;\n    xs_spp = (SV***)CvHSCXT(cv);\n    got = xs_spp;\n    need = &PL_stack_sp;\n#endif\n    if(UNLIKELY(got != need)) {\n\tbad_handshake:/* recycle branch and string from above */\n\tif(got != (void *)HSf_NOCHK)\n\t    noperl_die(\"%s: loadable library and perl binaries are mismatched\"\n                       \" (got handshake key %p, needed %p)\\n\",\n\t\tfile, got, need);\n    }\n\n    if(key & HSf_SETXSUBFN) {     /* this might be called from a module bootstrap */\n\tSAVEPPTR(PL_xsubfilename);/* which was require'd from a XSUB BEGIN */\n\tPL_xsubfilename = file;   /* so the old name must be restored for\n\t\t\t\t     additional XSUBs to register themselves */\n\t/* XSUBs can't be perl lang/perl5db.pl debugged\n\tif (PERLDB_LINE_OR_SAVESRC)\n\t    (void)gv_fetchfile(file); */\n    }\n\n    if(key & HSf_POPMARK) {\n\tax = POPMARK;\n\t{   SV **mark = PL_stack_base + ax++;\n\t    {   dSP;\n\t\titems = (I32)(SP - MARK);\n\t    }\n\t}\n    } else {\n\titems = va_arg(args, U32);\n\tax = va_arg(args, U32);\n    }\n    {\n\tU32 apiverlen;\n\tassert(HS_GETAPIVERLEN(key) <= UCHAR_MAX);\n\tif((apiverlen = HS_GETAPIVERLEN(key))) {\n\t    char * api_p = va_arg(args, char*);\n\t    if(apiverlen != sizeof(\"v\" PERL_API_VERSION_STRING)-1\n\t\t|| memNE(api_p, \"v\" PERL_API_VERSION_STRING,\n\t\t\t sizeof(\"v\" PERL_API_VERSION_STRING)-1))\n\t\tPerl_croak_nocontext(\"Perl API version %s of %\" SVf \" does not match %s\",\n\t\t\t\t    api_p, SVfARG(PL_stack_base[ax + 0]),\n\t\t\t\t    \"v\" PERL_API_VERSION_STRING);\n\t}\n    }\n    {\n\tU32 xsverlen;\n\tassert(HS_GETXSVERLEN(key) <= UCHAR_MAX && HS_GETXSVERLEN(key) <= HS_APIVERLEN_MAX);\n\tif((xsverlen = HS_GETXSVERLEN(key)))\n\t    S_xs_version_bootcheck(aTHX_\n\t\titems, ax, va_arg(args, char*), xsverlen);\n    }\n    va_end(args);\n    return ax;\n}\n\n\nSTATIC void\nS_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p,\n\t\t\t  STRLEN xs_len)\n{\n    SV *sv;\n    const char *vn = NULL;\n    SV *const module = PL_stack_base[ax];\n\n    PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK;\n\n    if (items >= 2)\t /* version supplied as bootstrap arg */\n\tsv = PL_stack_base[ax + 1];\n    else {\n\t/* XXX GV_ADDWARN */\n\tvn = \"XS_VERSION\";\n\tsv = get_sv(Perl_form(aTHX_ \"%\" SVf \"::%s\", SVfARG(module), vn), 0);\n\tif (!sv || !SvOK(sv)) {\n\t    vn = \"VERSION\";\n\t    sv = get_sv(Perl_form(aTHX_ \"%\" SVf \"::%s\", SVfARG(module), vn), 0);\n\t}\n    }\n    if (sv) {\n\tSV *xssv = Perl_newSVpvn_flags(aTHX_ xs_p, xs_len, SVs_TEMP);\n\tSV *pmsv = sv_isobject(sv) && sv_derived_from(sv, \"version\")\n\t    ? sv : sv_2mortal(new_version(sv));\n\txssv = upg_version(xssv, 0);\n\tif ( vcmp(pmsv,xssv) ) {\n\t    SV *string = vstringify(xssv);\n\t    SV *xpt = Perl_newSVpvf(aTHX_ \"%\" SVf \" object version %\" SVf\n\t\t\t\t    \" does not match \", SVfARG(module), SVfARG(string));\n\n\t    SvREFCNT_dec(string);\n\t    string = vstringify(pmsv);\n\n\t    if (vn) {\n\t\tPerl_sv_catpvf(aTHX_ xpt, \"$%\" SVf \"::%s %\" SVf, SVfARG(module), vn,\n\t\t\t       SVfARG(string));\n\t    } else {\n\t\tPerl_sv_catpvf(aTHX_ xpt, \"bootstrap parameter %\" SVf, SVfARG(string));\n\t    }\n\t    SvREFCNT_dec(string);\n\n\t    Perl_sv_2mortal(aTHX_ xpt);\n\t    Perl_croak_sv(aTHX_ xpt);\n\t}\n    }\n}\n\n/*\n=for apidoc my_strlcat\n\nThe C library C<strlcat> if available, or a Perl implementation of it.\nThis operates on C C<NUL>-terminated strings.\n\nC<my_strlcat()> appends string C<src> to the end of C<dst>.  It will append at\nmost S<C<size - strlen(dst) - 1>> characters.  It will then C<NUL>-terminate,\nunless C<size> is 0 or the original C<dst> string was longer than C<size> (in\npractice this should not happen as it means that either C<size> is incorrect or\nthat C<dst> is not a proper C<NUL>-terminated string).\n\nNote that C<size> is the full size of the destination buffer and\nthe result is guaranteed to be C<NUL>-terminated if there is room.  Note that\nroom for the C<NUL> should be included in C<size>.\n\nThe return value is the total length that C<dst> would have if C<size> is\nsufficiently large.  Thus it is the initial length of C<dst> plus the length of\nC<src>.  If C<size> is smaller than the return, the excess was not appended.\n\n=cut\n\nDescription stolen from http://man.openbsd.org/strlcat.3\n*/\n#ifndef HAS_STRLCAT\nSize_t\nPerl_my_strlcat(char *dst, const char *src, Size_t size)\n{\n    Size_t used, length, copy;\n\n    used = strlen(dst);\n    length = strlen(src);\n    if (size > 0 && used < size - 1) {\n        copy = (length >= size - used) ? size - used - 1 : length;\n        memcpy(dst + used, src, copy);\n        dst[used + copy] = '\\0';\n    }\n    return used + length;\n}\n#endif\n\n\n/*\n=for apidoc my_strlcpy\n\nThe C library C<strlcpy> if available, or a Perl implementation of it.\nThis operates on C C<NUL>-terminated strings.\n\nC<my_strlcpy()> copies up to S<C<size - 1>> characters from the string C<src>\nto C<dst>, C<NUL>-terminating the result if C<size> is not 0.\n\nThe return value is the total length C<src> would be if the copy completely\nsucceeded.  If it is larger than C<size>, the excess was not copied.\n\n=cut\n\nDescription stolen from http://man.openbsd.org/strlcpy.3\n*/\n#ifndef HAS_STRLCPY\nSize_t\nPerl_my_strlcpy(char *dst, const char *src, Size_t size)\n{\n    Size_t length, copy;\n\n    length = strlen(src);\n    if (size > 0) {\n        copy = (length >= size) ? size - 1 : length;\n        memcpy(dst, src, copy);\n        dst[copy] = '\\0';\n    }\n    return length;\n}\n#endif\n\n/*\n=for apidoc my_strnlen\n\nThe C library C<strnlen> if available, or a Perl implementation of it.\n\nC<my_strnlen()> computes the length of the string, up to C<maxlen>\ncharacters.  It will will never attempt to address more than C<maxlen>\ncharacters, making it suitable for use with strings that are not\nguaranteed to be NUL-terminated.\n\n=cut\n\nDescription stolen from http://man.openbsd.org/strnlen.3,\nimplementation stolen from PostgreSQL.\n*/\n#ifndef HAS_STRNLEN\nSize_t\nPerl_my_strnlen(const char *str, Size_t maxlen)\n{\n    const char *p = str;\n\n    PERL_ARGS_ASSERT_MY_STRNLEN;\n\n    while(maxlen-- && *p)\n        p++;\n\n    return p - str;\n}\n#endif\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1300) && (_MSC_VER < 1400) && (WINVER < 0x0500)\n/* VC7 or 7.1, building with pre-VC7 runtime libraries. */\nlong _ftol( double ); /* Defined by VC6 C libs. */\nlong _ftol2( double dblSource ) { return _ftol( dblSource ); }\n#endif\n\nPERL_STATIC_INLINE bool\nS_gv_has_usable_name(pTHX_ GV *gv)\n{\n    GV **gvp;\n    return GvSTASH(gv)\n\t&& HvENAME(GvSTASH(gv))\n\t&& (gvp = (GV **)hv_fetchhek(\n\t\t\tGvSTASH(gv), GvNAME_HEK(gv), 0\n\t   ))\n\t&& *gvp == gv;\n}\n\nvoid\nPerl_get_db_sub(pTHX_ SV **svp, CV *cv)\n{\n    SV * const dbsv = GvSVn(PL_DBsub);\n    const bool save_taint = TAINT_get;\n\n    /* When we are called from pp_goto (svp is null),\n     * we do not care about using dbsv to call CV;\n     * it's for informational purposes only.\n     */\n\n    PERL_ARGS_ASSERT_GET_DB_SUB;\n\n    TAINT_set(FALSE);\n    save_item(dbsv);\n    if (!PERLDB_SUB_NN) {\n\tGV *gv = CvGV(cv);\n\n\tif (!svp && !CvLEXICAL(cv)) {\n\t    gv_efullname3(dbsv, gv, NULL);\n\t}\n\telse if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED)) || CvLEXICAL(cv)\n\t     || strEQ(GvNAME(gv), \"END\")\n\t     || ( /* Could be imported, and old sub redefined. */\n\t\t (GvCV(gv) != cv || !S_gv_has_usable_name(aTHX_ gv))\n\t\t &&\n\t\t !( (SvTYPE(*svp) == SVt_PVGV)\n\t\t    && (GvCV((const GV *)*svp) == cv)\n\t\t    /* Use GV from the stack as a fallback. */\n\t\t    && S_gv_has_usable_name(aTHX_ gv = (GV *)*svp) \n\t\t  )\n\t\t)\n\t) {\n\t    /* GV is potentially non-unique, or contain different CV. */\n\t    SV * const tmp = newRV(MUTABLE_SV(cv));\n\t    sv_setsv(dbsv, tmp);\n\t    SvREFCNT_dec(tmp);\n\t}\n\telse {\n\t    sv_sethek(dbsv, HvENAME_HEK(GvSTASH(gv)));\n\t    sv_catpvs(dbsv, \"::\");\n\t    sv_cathek(dbsv, GvNAME_HEK(gv));\n\t}\n    }\n    else {\n\tconst int type = SvTYPE(dbsv);\n\tif (type < SVt_PVIV && type != SVt_IV)\n\t    sv_upgrade(dbsv, SVt_PVIV);\n\t(void)SvIOK_on(dbsv);\n\tSvIV_set(dbsv, PTR2IV(cv));\t/* Do it the quickest way  */\n    }\n    SvSETMAGIC(dbsv);\n    TAINT_IF(save_taint);\n#ifdef NO_TAINT_SUPPORT\n    PERL_UNUSED_VAR(save_taint);\n#endif\n}\n\nint\nPerl_my_dirfd(DIR * dir) {\n\n    /* Most dirfd implementations have problems when passed NULL. */\n    if(!dir)\n        return -1;\n#ifdef HAS_DIRFD\n    return dirfd(dir);\n#elif defined(HAS_DIR_DD_FD)\n    return dir->dd_fd;\n#else\n    Perl_croak_nocontext(PL_no_func, \"dirfd\");\n    NOT_REACHED; /* NOTREACHED */\n    return 0;\n#endif \n}\n\n#if !defined(HAS_MKOSTEMP) || !defined(HAS_MKSTEMP)\n\n#define TEMP_FILE_CH \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvxyz0123456789\"\n#define TEMP_FILE_CH_COUNT (sizeof(TEMP_FILE_CH)-1)\n\nstatic int\nS_my_mkostemp(char *templte, int flags) {\n    dTHX;\n    STRLEN len = strlen(templte);\n    int fd;\n    int attempts = 0;\n\n    if (len < 6 ||\n        templte[len-1] != 'X' || templte[len-2] != 'X' || templte[len-3] != 'X' ||\n        templte[len-4] != 'X' || templte[len-5] != 'X' || templte[len-6] != 'X') {\n        SETERRNO(EINVAL, LIB_INVARG);\n        return -1;\n    }\n\n    do {\n        int i;\n        for (i = 1; i <= 6; ++i) {\n            templte[len-i] = TEMP_FILE_CH[(int)(Perl_internal_drand48() * TEMP_FILE_CH_COUNT)];\n        }\n        fd = PerlLIO_open3(templte, O_RDWR | O_CREAT | O_EXCL | flags, 0600);\n    } while (fd == -1 && errno == EEXIST && ++attempts <= 100);\n\n    return fd;\n}\n\n#endif\n\n#ifndef HAS_MKOSTEMP\nint\nPerl_my_mkostemp(char *templte, int flags)\n{\n    PERL_ARGS_ASSERT_MY_MKOSTEMP;\n    return S_my_mkostemp(templte, flags);\n}\n#endif\n\n#ifndef HAS_MKSTEMP\nint\nPerl_my_mkstemp(char *templte)\n{\n    PERL_ARGS_ASSERT_MY_MKSTEMP;\n    return S_my_mkostemp(templte, 0);\n}\n#endif\n\nREGEXP *\nPerl_get_re_arg(pTHX_ SV *sv) {\n\n    if (sv) {\n        if (SvMAGICAL(sv))\n            mg_get(sv);\n        if (SvROK(sv))\n\t    sv = MUTABLE_SV(SvRV(sv));\n        if (SvTYPE(sv) == SVt_REGEXP)\n            return (REGEXP*) sv;\n    }\n \n    return NULL;\n}\n\n/*\n * This code is derived from drand48() implementation from FreeBSD,\n * found in lib/libc/gen/_rand48.c.\n *\n * The U64 implementation is original, based on the POSIX\n * specification for drand48().\n */\n\n/*\n* Copyright (c) 1993 Martin Birgmeier\n* All rights reserved.\n*\n* You may redistribute unmodified or modified versions of this source\n* code provided that the above copyright notice and this and the\n* following conditions are retained.\n*\n* This software is provided ``as is'', and comes with no warranties\n* of any kind. I shall in no event be liable for anything that happens\n* to anyone/anything when using this software.\n*/\n\n#define FREEBSD_DRAND48_SEED_0   (0x330e)\n\n#ifdef PERL_DRAND48_QUAD\n\n#define DRAND48_MULT UINT64_C(0x5deece66d)\n#define DRAND48_ADD  0xb\n#define DRAND48_MASK UINT64_C(0xffffffffffff)\n\n#else\n\n#define FREEBSD_DRAND48_SEED_1   (0xabcd)\n#define FREEBSD_DRAND48_SEED_2   (0x1234)\n#define FREEBSD_DRAND48_MULT_0   (0xe66d)\n#define FREEBSD_DRAND48_MULT_1   (0xdeec)\n#define FREEBSD_DRAND48_MULT_2   (0x0005)\n#define FREEBSD_DRAND48_ADD      (0x000b)\n\nconst unsigned short _rand48_mult[3] = {\n                FREEBSD_DRAND48_MULT_0,\n                FREEBSD_DRAND48_MULT_1,\n                FREEBSD_DRAND48_MULT_2\n};\nconst unsigned short _rand48_add = FREEBSD_DRAND48_ADD;\n\n#endif\n\nvoid\nPerl_drand48_init_r(perl_drand48_t *random_state, U32 seed)\n{\n    PERL_ARGS_ASSERT_DRAND48_INIT_R;\n\n#ifdef PERL_DRAND48_QUAD\n    *random_state = FREEBSD_DRAND48_SEED_0 + ((U64)seed << 16);\n#else\n    random_state->seed[0] = FREEBSD_DRAND48_SEED_0;\n    random_state->seed[1] = (U16) seed;\n    random_state->seed[2] = (U16) (seed >> 16);\n#endif\n}\n\ndouble\nPerl_drand48_r(perl_drand48_t *random_state)\n{\n    PERL_ARGS_ASSERT_DRAND48_R;\n\n#ifdef PERL_DRAND48_QUAD\n    *random_state = (*random_state * DRAND48_MULT + DRAND48_ADD)\n        & DRAND48_MASK;\n\n    return ldexp((double)*random_state, -48);\n#else\n    {\n    U32 accu;\n    U16 temp[2];\n\n    accu = (U32) _rand48_mult[0] * (U32) random_state->seed[0]\n         + (U32) _rand48_add;\n    temp[0] = (U16) accu;        /* lower 16 bits */\n    accu >>= sizeof(U16) * 8;\n    accu += (U32) _rand48_mult[0] * (U32) random_state->seed[1]\n          + (U32) _rand48_mult[1] * (U32) random_state->seed[0];\n    temp[1] = (U16) accu;        /* middle 16 bits */\n    accu >>= sizeof(U16) * 8;\n    accu += _rand48_mult[0] * random_state->seed[2]\n          + _rand48_mult[1] * random_state->seed[1]\n          + _rand48_mult[2] * random_state->seed[0];\n    random_state->seed[0] = temp[0];\n    random_state->seed[1] = temp[1];\n    random_state->seed[2] = (U16) accu;\n\n    return ldexp((double) random_state->seed[0], -48) +\n           ldexp((double) random_state->seed[1], -32) +\n           ldexp((double) random_state->seed[2], -16);\n    }\n#endif\n}\n\n#ifdef USE_C_BACKTRACE\n\n/* Possibly move all this USE_C_BACKTRACE code into a new file. */\n\n#ifdef USE_BFD\n\ntypedef struct {\n    /* abfd is the BFD handle. */\n    bfd* abfd;\n    /* bfd_syms is the BFD symbol table. */\n    asymbol** bfd_syms;\n    /* bfd_text is handle to the the \".text\" section of the object file. */\n    asection* bfd_text;\n    /* Since opening the executable and scanning its symbols is quite\n     * heavy operation, we remember the filename we used the last time,\n     * and do the opening and scanning only if the filename changes.\n     * This removes most (but not all) open+scan cycles. */\n    const char* fname_prev;\n} bfd_context;\n\n/* Given a dl_info, update the BFD context if necessary. */\nstatic void bfd_update(bfd_context* ctx, Dl_info* dl_info)\n{\n    /* BFD open and scan only if the filename changed. */\n    if (ctx->fname_prev == NULL ||\n        strNE(dl_info->dli_fname, ctx->fname_prev)) {\n        if (ctx->abfd) {\n            bfd_close(ctx->abfd);\n        }\n        ctx->abfd = bfd_openr(dl_info->dli_fname, 0);\n        if (ctx->abfd) {\n            if (bfd_check_format(ctx->abfd, bfd_object)) {\n                IV symbol_size = bfd_get_symtab_upper_bound(ctx->abfd);\n                if (symbol_size > 0) {\n                    Safefree(ctx->bfd_syms);\n                    Newx(ctx->bfd_syms, symbol_size, asymbol*);\n                    ctx->bfd_text =\n                        bfd_get_section_by_name(ctx->abfd, \".text\");\n                }\n                else\n                    ctx->abfd = NULL;\n            }\n            else\n                ctx->abfd = NULL;\n        }\n        ctx->fname_prev = dl_info->dli_fname;\n    }\n}\n\n/* Given a raw frame, try to symbolize it and store\n * symbol information (source file, line number) away. */\nstatic void bfd_symbolize(bfd_context* ctx,\n                          void* raw_frame,\n                          char** symbol_name,\n                          STRLEN* symbol_name_size,\n                          char** source_name,\n                          STRLEN* source_name_size,\n                          STRLEN* source_line)\n{\n    *symbol_name = NULL;\n    *symbol_name_size = 0;\n    if (ctx->abfd) {\n        IV offset = PTR2IV(raw_frame) - PTR2IV(ctx->bfd_text->vma);\n        if (offset > 0 &&\n            bfd_canonicalize_symtab(ctx->abfd, ctx->bfd_syms) > 0) {\n            const char *file;\n            const char *func;\n            unsigned int line = 0;\n            if (bfd_find_nearest_line(ctx->abfd, ctx->bfd_text,\n                                      ctx->bfd_syms, offset,\n                                      &file, &func, &line) &&\n                file && func && line > 0) {\n                /* Size and copy the source file, use only\n                 * the basename of the source file.\n                 *\n                 * NOTE: the basenames are fine for the\n                 * Perl source files, but may not always\n                 * be the best idea for XS files. */\n                const char *p, *b = NULL;\n                /* Look for the last slash. */\n                for (p = file; *p; p++) {\n                    if (*p == '/')\n                        b = p + 1;\n                }\n                if (b == NULL || *b == 0) {\n                    b = file;\n                }\n                *source_name_size = p - b + 1;\n                Newx(*source_name, *source_name_size + 1, char);\n                Copy(b, *source_name, *source_name_size + 1, char);\n\n                *symbol_name_size = strlen(func);\n                Newx(*symbol_name, *symbol_name_size + 1, char);\n                Copy(func, *symbol_name, *symbol_name_size + 1, char);\n\n                *source_line = line;\n            }\n        }\n    }\n}\n\n#endif /* #ifdef USE_BFD */\n\n#ifdef PERL_DARWIN\n\n/* OS X has no public API for for 'symbolicating' (Apple official term)\n * stack addresses to {function_name, source_file, line_number}.\n * Good news: there is command line utility atos(1) which does that.\n * Bad news 1: it's a command line utility.\n * Bad news 2: one needs to have the Developer Tools installed.\n * Bad news 3: in newer releases it needs to be run as 'xcrun atos'.\n *\n * To recap: we need to open a pipe for reading for a utility which\n * might not exist, or exists in different locations, and then parse\n * the output.  And since this is all for a low-level API, we cannot\n * use high-level stuff.  Thanks, Apple. */\n\ntypedef struct {\n    /* tool is set to the absolute pathname of the tool to use:\n     * xcrun or atos. */\n    const char* tool;\n    /* format is set to a printf format string used for building\n     * the external command to run. */\n    const char* format;\n    /* unavail is set if e.g. xcrun cannot be found, or something\n     * else happens that makes getting the backtrace dubious.  Note,\n     * however, that the context isn't persistent, the next call to\n     * get_c_backtrace() will start from scratch. */\n    bool unavail;\n    /* fname is the current object file name. */\n    const char* fname;\n    /* object_base_addr is the base address of the shared object. */\n    void* object_base_addr;\n} atos_context;\n\n/* Given |dl_info|, updates the context.  If the context has been\n * marked unavailable, return immediately.  If not but the tool has\n * not been set, set it to either \"xcrun atos\" or \"atos\" (also set the\n * format to use for creating commands for piping), or if neither is\n * unavailable (one needs the Developer Tools installed), mark the context\n * an unavailable.  Finally, update the filename (object name),\n * and its base address. */\n\nstatic void atos_update(atos_context* ctx,\n                        Dl_info* dl_info)\n{\n    if (ctx->unavail)\n        return;\n    if (ctx->tool == NULL) {\n        const char* tools[] = {\n            \"/usr/bin/xcrun\",\n            \"/usr/bin/atos\"\n        };\n        const char* formats[] = {\n            \"/usr/bin/xcrun atos -o '%s' -l %08x %08x 2>&1\",\n            \"/usr/bin/atos -d -o '%s' -l %08x %08x 2>&1\"\n        };\n        struct stat st;\n        UV i;\n        for (i = 0; i < C_ARRAY_LENGTH(tools); i++) {\n            if (stat(tools[i], &st) == 0 && S_ISREG(st.st_mode)) {\n                ctx->tool = tools[i];\n                ctx->format = formats[i];\n                break;\n            }\n        }\n        if (ctx->tool == NULL) {\n            ctx->unavail = TRUE;\n            return;\n        }\n    }\n    if (ctx->fname == NULL ||\n        strNE(dl_info->dli_fname, ctx->fname)) {\n        ctx->fname = dl_info->dli_fname;\n        ctx->object_base_addr = dl_info->dli_fbase;\n    }\n}\n\n/* Given an output buffer end |p| and its |start|, matches\n * for the atos output, extracting the source code location\n * and returning non-NULL if possible, returning NULL otherwise. */\nstatic const char* atos_parse(const char* p,\n                              const char* start,\n                              STRLEN* source_name_size,\n                              STRLEN* source_line) {\n    /* atos() output is something like:\n     * perl_parse (in miniperl) (perl.c:2314)\\n\\n\".\n     * We cannot use Perl regular expressions, because we need to\n     * stay low-level.  Therefore here we have a rolled-out version\n     * of a state machine which matches _backwards_from_the_end_ and\n     * if there's a success, returns the starts of the filename,\n     * also setting the filename size and the source line number.\n     * The matched regular expression is roughly \"\\(.*:\\d+\\)\\s*$\" */\n    const char* source_number_start;\n    const char* source_name_end;\n    const char* source_line_end = start;\n    const char* close_paren;\n    UV uv;\n\n    /* Skip trailing whitespace. */\n    while (p > start && isSPACE(*p)) p--;\n    /* Now we should be at the close paren. */\n    if (p == start || *p != ')')\n        return NULL;\n    close_paren = p;\n    p--;\n    /* Now we should be in the line number. */\n    if (p == start || !isDIGIT(*p))\n        return NULL;\n    /* Skip over the digits. */\n    while (p > start && isDIGIT(*p))\n        p--;\n    /* Now we should be at the colon. */\n    if (p == start || *p != ':')\n        return NULL;\n    source_number_start = p + 1;\n    source_name_end = p; /* Just beyond the end. */\n    p--;\n    /* Look for the open paren. */\n    while (p > start && *p != '(')\n        p--;\n    if (p == start)\n        return NULL;\n    p++;\n    *source_name_size = source_name_end - p;\n    if (grok_atoUV(source_number_start, &uv,  &source_line_end)\n        && source_line_end == close_paren\n        && uv <= PERL_INT_MAX\n    ) {\n        *source_line = (STRLEN)uv;\n        return p;\n    }\n    return NULL;\n}\n\n/* Given a raw frame, read a pipe from the symbolicator (that's the\n * technical term) atos, reads the result, and parses the source code\n * location.  We must stay low-level, so we use snprintf(), pipe(),\n * and fread(), and then also parse the output ourselves. */\nstatic void atos_symbolize(atos_context* ctx,\n                           void* raw_frame,\n                           char** source_name,\n                           STRLEN* source_name_size,\n                           STRLEN* source_line)\n{\n    char cmd[1024];\n    const char* p;\n    Size_t cnt;\n\n    if (ctx->unavail)\n        return;\n    /* Simple security measure: if there's any funny business with\n     * the object name (used as \"-o '%s'\" ), leave since at least\n     * partially the user controls it. */\n    for (p = ctx->fname; *p; p++) {\n        if (*p == '\\'' || isCNTRL(*p)) {\n            ctx->unavail = TRUE;\n            return;\n        }\n    }\n    cnt = snprintf(cmd, sizeof(cmd), ctx->format,\n                   ctx->fname, ctx->object_base_addr, raw_frame);\n    if (cnt < sizeof(cmd)) {\n        /* Undo nostdio.h #defines that disable stdio.\n         * This is somewhat naughty, but is used elsewhere\n         * in the core, and affects only OS X. */\n#undef FILE\n#undef popen\n#undef fread\n#undef pclose\n        FILE* fp = popen(cmd, \"r\");\n        /* At the moment we open a new pipe for each stack frame.\n         * This is naturally somewhat slow, but hopefully generating\n         * stack traces is never going to in a performance critical path.\n         *\n         * We could play tricks with atos by batching the stack\n         * addresses to be resolved: atos can either take multiple\n         * addresses from the command line, or read addresses from\n         * a file (though the mess of creating temporary files would\n         * probably negate much of any possible speedup).\n         *\n         * Normally there are only two objects present in the backtrace:\n         * perl itself, and the libdyld.dylib.  (Note that the object\n         * filenames contain the full pathname, so perl may not always\n         * be in the same place.)  Whenever the object in the\n         * backtrace changes, the base address also changes.\n         *\n         * The problem with batching the addresses, though, would be\n         * matching the results with the addresses: the parsing of\n         * the results is already painful enough with a single address. */\n        if (fp) {\n            char out[1024];\n            UV cnt = fread(out, 1, sizeof(out), fp);\n            if (cnt < sizeof(out)) {\n                const char* p = atos_parse(out + cnt - 1, out,\n                                           source_name_size,\n                                           source_line);\n                if (p) {\n                    Newx(*source_name,\n                         *source_name_size, char);\n                    Copy(p, *source_name,\n                         *source_name_size,  char);\n                }\n            }\n            pclose(fp);\n        }\n    }\n}\n\n#endif /* #ifdef PERL_DARWIN */\n\n/*\n=for apidoc get_c_backtrace\n\nCollects the backtrace (aka \"stacktrace\") into a single linear\nmalloced buffer, which the caller B<must> C<Perl_free_c_backtrace()>.\n\nScans the frames back by S<C<depth + skip>>, then drops the C<skip> innermost,\nreturning at most C<depth> frames.\n\n=cut\n*/\n\nPerl_c_backtrace*\nPerl_get_c_backtrace(pTHX_ int depth, int skip)\n{\n    /* Note that here we must stay as low-level as possible: Newx(),\n     * Copy(), Safefree(); since we may be called from anywhere,\n     * so we should avoid higher level constructs like SVs or AVs.\n     *\n     * Since we are using safesysmalloc() via Newx(), don't try\n     * getting backtrace() there, unless you like deep recursion. */\n\n    /* Currently only implemented with backtrace() and dladdr(),\n     * for other platforms NULL is returned. */\n\n#if defined(HAS_BACKTRACE) && defined(HAS_DLADDR)\n    /* backtrace() is available via <execinfo.h> in glibc and in most\n     * modern BSDs; dladdr() is available via <dlfcn.h>. */\n\n    /* We try fetching this many frames total, but then discard\n     * the |skip| first ones.  For the remaining ones we will try\n     * retrieving more information with dladdr(). */\n    int try_depth = skip +  depth;\n\n    /* The addresses (program counters) returned by backtrace(). */\n    void** raw_frames;\n\n    /* Retrieved with dladdr() from the addresses returned by backtrace(). */\n    Dl_info* dl_infos;\n\n    /* Sizes _including_ the terminating \\0 of the object name\n     * and symbol name strings. */\n    STRLEN* object_name_sizes;\n    STRLEN* symbol_name_sizes;\n\n#ifdef USE_BFD\n    /* The symbol names comes either from dli_sname,\n     * or if using BFD, they can come from BFD. */\n    char** symbol_names;\n#endif\n\n    /* The source code location information.  Dug out with e.g. BFD. */\n    char** source_names;\n    STRLEN* source_name_sizes;\n    STRLEN* source_lines;\n\n    Perl_c_backtrace* bt = NULL;  /* This is what will be returned. */\n    int got_depth; /* How many frames were returned from backtrace(). */\n    UV frame_count = 0; /* How many frames we return. */\n    UV total_bytes = 0; /* The size of the whole returned backtrace. */\n\n#ifdef USE_BFD\n    bfd_context bfd_ctx;\n#endif\n#ifdef PERL_DARWIN\n    atos_context atos_ctx;\n#endif\n\n    /* Here are probably possibilities for optimizing.  We could for\n     * example have a struct that contains most of these and then\n     * allocate |try_depth| of them, saving a bunch of malloc calls.\n     * Note, however, that |frames| could not be part of that struct\n     * because backtrace() will want an array of just them.  Also be\n     * careful about the name strings. */\n    Newx(raw_frames, try_depth, void*);\n    Newx(dl_infos, try_depth, Dl_info);\n    Newx(object_name_sizes, try_depth, STRLEN);\n    Newx(symbol_name_sizes, try_depth, STRLEN);\n    Newx(source_names, try_depth, char*);\n    Newx(source_name_sizes, try_depth, STRLEN);\n    Newx(source_lines, try_depth, STRLEN);\n#ifdef USE_BFD\n    Newx(symbol_names, try_depth, char*);\n#endif\n\n    /* Get the raw frames. */\n    got_depth = (int)backtrace(raw_frames, try_depth);\n\n    /* We use dladdr() instead of backtrace_symbols() because we want\n     * the full details instead of opaque strings.  This is useful for\n     * two reasons: () the details are needed for further symbolic\n     * digging, for example in OS X (2) by having the details we fully\n     * control the output, which in turn is useful when more platforms\n     * are added: we can keep out output \"portable\". */\n\n    /* We want a single linear allocation, which can then be freed\n     * with a single swoop.  We will do the usual trick of first\n     * walking over the structure and seeing how much we need to\n     * allocate, then allocating, and then walking over the structure\n     * the second time and populating it. */\n\n    /* First we must compute the total size of the buffer. */\n    total_bytes = sizeof(Perl_c_backtrace_header);\n    if (got_depth > skip) {\n        int i;\n#ifdef USE_BFD\n        bfd_init(); /* Is this safe to call multiple times? */\n        Zero(&bfd_ctx, 1, bfd_context);\n#endif\n#ifdef PERL_DARWIN\n        Zero(&atos_ctx, 1, atos_context);\n#endif\n        for (i = skip; i < try_depth; i++) {\n            Dl_info* dl_info = &dl_infos[i];\n\n            object_name_sizes[i] = 0;\n            source_names[i] = NULL;\n            source_name_sizes[i] = 0;\n            source_lines[i] = 0;\n\n            /* Yes, zero from dladdr() is failure. */\n            if (dladdr(raw_frames[i], dl_info)) {\n                total_bytes += sizeof(Perl_c_backtrace_frame);\n\n                object_name_sizes[i] =\n                    dl_info->dli_fname ? strlen(dl_info->dli_fname) : 0;\n                symbol_name_sizes[i] =\n                    dl_info->dli_sname ? strlen(dl_info->dli_sname) : 0;\n#ifdef USE_BFD\n                bfd_update(&bfd_ctx, dl_info);\n                bfd_symbolize(&bfd_ctx, raw_frames[i],\n                              &symbol_names[i],\n                              &symbol_name_sizes[i],\n                              &source_names[i],\n                              &source_name_sizes[i],\n                              &source_lines[i]);\n#endif\n#if PERL_DARWIN\n                atos_update(&atos_ctx, dl_info);\n                atos_symbolize(&atos_ctx,\n                               raw_frames[i],\n                               &source_names[i],\n                               &source_name_sizes[i],\n                               &source_lines[i]);\n#endif\n\n                /* Plus ones for the terminating \\0. */\n                total_bytes += object_name_sizes[i] + 1;\n                total_bytes += symbol_name_sizes[i] + 1;\n                total_bytes += source_name_sizes[i] + 1;\n\n                frame_count++;\n            } else {\n                break;\n            }\n        }\n#ifdef USE_BFD\n        Safefree(bfd_ctx.bfd_syms);\n#endif\n    }\n\n    /* Now we can allocate and populate the result buffer. */\n    Newxc(bt, total_bytes, char, Perl_c_backtrace);\n    Zero(bt, total_bytes, char);\n    bt->header.frame_count = frame_count;\n    bt->header.total_bytes = total_bytes;\n    if (frame_count > 0) {\n        Perl_c_backtrace_frame* frame = bt->frame_info;\n        char* name_base = (char *)(frame + frame_count);\n        char* name_curr = name_base; /* Outputting the name strings here. */\n        UV i;\n        for (i = skip; i < skip + frame_count; i++) {\n            Dl_info* dl_info = &dl_infos[i];\n\n            frame->addr = raw_frames[i];\n            frame->object_base_addr = dl_info->dli_fbase;\n            frame->symbol_addr = dl_info->dli_saddr;\n\n            /* Copies a string, including the \\0, and advances the name_curr.\n             * Also copies the start and the size to the frame. */\n#define PERL_C_BACKTRACE_STRCPY(frame, doffset, src, dsize, size) \\\n            if (size && src) \\\n                Copy(src, name_curr, size, char); \\\n            frame->doffset = name_curr - (char*)bt; \\\n            frame->dsize = size; \\\n            name_curr += size; \\\n            *name_curr++ = 0;\n\n            PERL_C_BACKTRACE_STRCPY(frame, object_name_offset,\n                                    dl_info->dli_fname,\n                                    object_name_size, object_name_sizes[i]);\n\n#ifdef USE_BFD\n            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,\n                                    symbol_names[i],\n                                    symbol_name_size, symbol_name_sizes[i]);\n            Safefree(symbol_names[i]);\n#else\n            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,\n                                    dl_info->dli_sname,\n                                    symbol_name_size, symbol_name_sizes[i]);\n#endif\n\n            PERL_C_BACKTRACE_STRCPY(frame, source_name_offset,\n                                    source_names[i],\n                                    source_name_size, source_name_sizes[i]);\n            Safefree(source_names[i]);\n\n#undef PERL_C_BACKTRACE_STRCPY\n\n            frame->source_line_number = source_lines[i];\n\n            frame++;\n        }\n        assert(total_bytes ==\n               (UV)(sizeof(Perl_c_backtrace_header) +\n                    frame_count * sizeof(Perl_c_backtrace_frame) +\n                    name_curr - name_base));\n    }\n#ifdef USE_BFD\n    Safefree(symbol_names);\n    if (bfd_ctx.abfd) {\n        bfd_close(bfd_ctx.abfd);\n    }\n#endif\n    Safefree(source_lines);\n    Safefree(source_name_sizes);\n    Safefree(source_names);\n    Safefree(symbol_name_sizes);\n    Safefree(object_name_sizes);\n    /* Assuming the strings returned by dladdr() are pointers\n     * to read-only static memory (the object file), so that\n     * they do not need freeing (and cannot be). */\n    Safefree(dl_infos);\n    Safefree(raw_frames);\n    return bt;\n#else\n    PERL_UNUSED_ARGV(depth);\n    PERL_UNUSED_ARGV(skip);\n    return NULL;\n#endif\n}\n\n/*\n=for apidoc free_c_backtrace\n\nDeallocates a backtrace received from get_c_bracktrace.\n\n=cut\n*/\n\n/*\n=for apidoc get_c_backtrace_dump\n\nReturns a SV containing a dump of C<depth> frames of the call stack, skipping\nthe C<skip> innermost ones.  C<depth> of 20 is usually enough.\n\nThe appended output looks like:\n\n...\n1   10e004812:0082   Perl_croak   util.c:1716    /usr/bin/perl\n2   10df8d6d2:1d72   perl_parse   perl.c:3975    /usr/bin/perl\n...\n\nThe fields are tab-separated.  The first column is the depth (zero\nbeing the innermost non-skipped frame).  In the hex:offset, the hex is\nwhere the program counter was in C<S_parse_body>, and the :offset (might\nbe missing) tells how much inside the C<S_parse_body> the program counter was.\n\nThe C<util.c:1716> is the source code file and line number.\n\nThe F</usr/bin/perl> is obvious (hopefully).\n\nUnknowns are C<\"-\">.  Unknowns can happen unfortunately quite easily:\nif the platform doesn't support retrieving the information;\nif the binary is missing the debug information;\nif the optimizer has transformed the code by for example inlining.\n\n=cut\n*/\n\nSV*\nPerl_get_c_backtrace_dump(pTHX_ int depth, int skip)\n{\n    Perl_c_backtrace* bt;\n\n    bt = get_c_backtrace(depth, skip + 1 /* Hide ourselves. */);\n    if (bt) {\n        Perl_c_backtrace_frame* frame;\n        SV* dsv = newSVpvs(\"\");\n        UV i;\n        for (i = 0, frame = bt->frame_info;\n             i < bt->header.frame_count; i++, frame++) {\n            Perl_sv_catpvf(aTHX_ dsv, \"%d\", (int)i);\n            Perl_sv_catpvf(aTHX_ dsv, \"\\t%p\", frame->addr ? frame->addr : \"-\");\n            /* Symbol (function) names might disappear without debug info.\n             *\n             * The source code location might disappear in case of the\n             * optimizer inlining or otherwise rearranging the code. */\n            if (frame->symbol_addr) {\n                Perl_sv_catpvf(aTHX_ dsv, \":%04x\",\n                               (int)\n                               ((char*)frame->addr - (char*)frame->symbol_addr));\n            }\n            Perl_sv_catpvf(aTHX_ dsv, \"\\t%s\",\n                           frame->symbol_name_size &&\n                           frame->symbol_name_offset ?\n                           (char*)bt + frame->symbol_name_offset : \"-\");\n            if (frame->source_name_size &&\n                frame->source_name_offset &&\n                frame->source_line_number) {\n                Perl_sv_catpvf(aTHX_ dsv, \"\\t%s:%\" UVuf,\n                               (char*)bt + frame->source_name_offset,\n                               (UV)frame->source_line_number);\n            } else {\n                Perl_sv_catpvf(aTHX_ dsv, \"\\t-\");\n            }\n            Perl_sv_catpvf(aTHX_ dsv, \"\\t%s\",\n                           frame->object_name_size &&\n                           frame->object_name_offset ?\n                           (char*)bt + frame->object_name_offset : \"-\");\n            /* The frame->object_base_addr is not output,\n             * but it is used for symbolizing/symbolicating. */\n            sv_catpvs(dsv, \"\\n\");\n        }\n\n        Perl_free_c_backtrace(bt);\n\n        return dsv;\n    }\n\n    return NULL;\n}\n\n/*\n=for apidoc dump_c_backtrace\n\nDumps the C backtrace to the given C<fp>.\n\nReturns true if a backtrace could be retrieved, false if not.\n\n=cut\n*/\n\nbool\nPerl_dump_c_backtrace(pTHX_ PerlIO* fp, int depth, int skip)\n{\n    SV* sv;\n\n    PERL_ARGS_ASSERT_DUMP_C_BACKTRACE;\n\n    sv = Perl_get_c_backtrace_dump(aTHX_ depth, skip);\n    if (sv) {\n        sv_2mortal(sv);\n        PerlIO_printf(fp, \"%s\", SvPV_nolen(sv));\n        return TRUE;\n    }\n    return FALSE;\n}\n\n#endif /* #ifdef USE_C_BACKTRACE */\n\n#ifdef PERL_TSA_ACTIVE\n\n/* pthread_mutex_t and perl_mutex are typedef equivalent\n * so casting the pointers is fine. */\n\nint perl_tsa_mutex_lock(perl_mutex* mutex)\n{\n    return pthread_mutex_lock((pthread_mutex_t *) mutex);\n}\n\nint perl_tsa_mutex_unlock(perl_mutex* mutex)\n{\n    return pthread_mutex_unlock((pthread_mutex_t *) mutex);\n}\n\nint perl_tsa_mutex_destroy(perl_mutex* mutex)\n{\n    return pthread_mutex_destroy((pthread_mutex_t *) mutex);\n}\n\n#endif\n\n\n#ifdef USE_DTRACE\n\n/* log a sub call or return */\n\nvoid\nPerl_dtrace_probe_call(pTHX_ CV *cv, bool is_call)\n{\n    const char *func;\n    const char *file;\n    const char *stash;\n    const COP  *start;\n    line_t      line;\n\n    PERL_ARGS_ASSERT_DTRACE_PROBE_CALL;\n\n    if (CvNAMED(cv)) {\n        HEK *hek = CvNAME_HEK(cv);\n        func = HEK_KEY(hek);\n    }\n    else {\n        GV  *gv = CvGV(cv);\n        func = GvENAME(gv);\n    }\n    start = (const COP *)CvSTART(cv);\n    file  = CopFILE(start);\n    line  = CopLINE(start);\n    stash = CopSTASHPV(start);\n\n    if (is_call) {\n        PERL_SUB_ENTRY(func, file, line, stash);\n    }\n    else {\n        PERL_SUB_RETURN(func, file, line, stash);\n    }\n}\n\n\n/* log a require file loading/loaded  */\n\nvoid\nPerl_dtrace_probe_load(pTHX_ const char *name, bool is_loading)\n{\n    PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD;\n\n    if (is_loading) {\n\tPERL_LOADING_FILE(name);\n    }\n    else {\n\tPERL_LOADED_FILE(name);\n    }\n}\n\n\n/* log an op execution */\n\nvoid\nPerl_dtrace_probe_op(pTHX_ const OP *op)\n{\n    PERL_ARGS_ASSERT_DTRACE_PROBE_OP;\n\n    PERL_OP_ENTRY(OP_NAME(op));\n}\n\n\n/* log a compile/run phase change */\n\nvoid\nPerl_dtrace_probe_phase(pTHX_ enum perl_phase phase)\n{\n    const char *ph_old = PL_phase_names[PL_phase];\n    const char *ph_new = PL_phase_names[phase];\n\n    PERL_PHASE_CHANGE(ph_new, ph_old);\n}\n\n#endif\n\n/*\n * ex: set ts=8 sts=4 sw=4 et:\n */\n"], "fixing_code": ["/*    util.c\n *\n *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others\n *\n *    You may distribute under the terms of either the GNU General Public\n *    License or the Artistic License, as specified in the README file.\n *\n */\n\n/*\n * 'Very useful, no doubt, that was to Saruman; yet it seems that he was\n *  not content.'                                    --Gandalf to Pippin\n *\n *     [p.598 of _The Lord of the Rings_, III/xi: \"The Palant\u00edr\"]\n */\n\n/* This file contains assorted utility routines.\n * Which is a polite way of saying any stuff that people couldn't think of\n * a better place for. Amongst other things, it includes the warning and\n * dieing stuff, plus wrappers for malloc code.\n */\n\n#include \"EXTERN.h\"\n#define PERL_IN_UTIL_C\n#include \"perl.h\"\n#include \"reentr.h\"\n\n#if defined(USE_PERLIO)\n#include \"perliol.h\" /* For PerlIOUnix_refcnt */\n#endif\n\n#ifndef PERL_MICRO\n#include <signal.h>\n#ifndef SIG_ERR\n# define SIG_ERR ((Sighandler_t) -1)\n#endif\n#endif\n\n#include <math.h>\n#include <stdlib.h>\n\n#ifdef __Lynx__\n/* Missing protos on LynxOS */\nint putenv(char *);\n#endif\n\n#ifdef __amigaos__\n# include \"amigaos4/amigaio.h\"\n#endif\n\n#ifdef HAS_SELECT\n# ifdef I_SYS_SELECT\n#  include <sys/select.h>\n# endif\n#endif\n\n#ifdef USE_C_BACKTRACE\n#  ifdef I_BFD\n#    define USE_BFD\n#    ifdef PERL_DARWIN\n#      undef USE_BFD /* BFD is useless in OS X. */\n#    endif\n#    ifdef USE_BFD\n#      include <bfd.h>\n#    endif\n#  endif\n#  ifdef I_DLFCN\n#    include <dlfcn.h>\n#  endif\n#  ifdef I_EXECINFO\n#    include <execinfo.h>\n#  endif\n#endif\n\n#ifdef PERL_DEBUG_READONLY_COW\n# include <sys/mman.h>\n#endif\n\n#define FLUSH\n\n/* NOTE:  Do not call the next three routines directly.  Use the macros\n * in handy.h, so that we can easily redefine everything to do tracking of\n * allocated hunks back to the original New to track down any memory leaks.\n * XXX This advice seems to be widely ignored :-(   --AD  August 1996.\n */\n\n#if defined (DEBUGGING) || defined(PERL_IMPLICIT_SYS) || defined (PERL_TRACK_MEMPOOL)\n#  define ALWAYS_NEED_THX\n#endif\n\n#if defined(PERL_TRACK_MEMPOOL) && defined(PERL_DEBUG_READONLY_COW)\nstatic void\nS_maybe_protect_rw(pTHX_ struct perl_memory_debug_header *header)\n{\n    if (header->readonly\n     && mprotect(header, header->size, PROT_READ|PROT_WRITE))\n\tPerl_warn(aTHX_ \"mprotect for COW string %p %lu failed with %d\",\n\t\t\t header, header->size, errno);\n}\n\nstatic void\nS_maybe_protect_ro(pTHX_ struct perl_memory_debug_header *header)\n{\n    if (header->readonly\n     && mprotect(header, header->size, PROT_READ))\n\tPerl_warn(aTHX_ \"mprotect RW for COW string %p %lu failed with %d\",\n\t\t\t header, header->size, errno);\n}\n# define maybe_protect_rw(foo) S_maybe_protect_rw(aTHX_ foo)\n# define maybe_protect_ro(foo) S_maybe_protect_ro(aTHX_ foo)\n#else\n# define maybe_protect_rw(foo) NOOP\n# define maybe_protect_ro(foo) NOOP\n#endif\n\n#if defined(PERL_TRACK_MEMPOOL) || defined(PERL_DEBUG_READONLY_COW)\n /* Use memory_debug_header */\n# define USE_MDH\n# if (defined(PERL_POISON) && defined(PERL_TRACK_MEMPOOL)) \\\n   || defined(PERL_DEBUG_READONLY_COW)\n#  define MDH_HAS_SIZE\n# endif\n#endif\n\n/* paranoid version of system's malloc() */\n\nMalloc_t\nPerl_safesysmalloc(MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n\n#ifdef USE_MDH\n    if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)\n        goto out_of_memory;\n    size += PERL_MEMORY_DEBUG_HEADER_SIZE;\n#endif\n#ifdef DEBUGGING\n    if ((SSize_t)size < 0)\n\tPerl_croak_nocontext(\"panic: malloc, size=%\" UVuf, (UV) size);\n#endif\n    if (!size) size = 1;\t/* malloc(0) is NASTY on our system */\n#ifdef PERL_DEBUG_READONLY_COW\n    if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,\n\t\t    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\tperror(\"mmap failed\");\n\tabort();\n    }\n#else\n    ptr = (Malloc_t)PerlMem_malloc(size?size:1);\n#endif\n    PERL_ALLOC_CHECK(ptr);\n    if (ptr != NULL) {\n#ifdef USE_MDH\n\tstruct perl_memory_debug_header *const header\n\t    = (struct perl_memory_debug_header *)ptr;\n#endif\n\n#ifdef PERL_POISON\n\tPoisonNew(((char *)ptr), size, char);\n#endif\n\n#ifdef PERL_TRACK_MEMPOOL\n\theader->interpreter = aTHX;\n\t/* Link us into the list.  */\n\theader->prev = &PL_memory_debug_header;\n\theader->next = PL_memory_debug_header.next;\n\tPL_memory_debug_header.next = header;\n\tmaybe_protect_rw(header->next);\n\theader->next->prev = header;\n\tmaybe_protect_ro(header->next);\n#  ifdef PERL_DEBUG_READONLY_COW\n\theader->readonly = 0;\n#  endif\n#endif\n#ifdef MDH_HAS_SIZE\n\theader->size = size;\n#endif\n\tptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) malloc %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)size));\n\n    }\n    else {\n#ifdef USE_MDH\n      out_of_memory:\n#endif\n        {\n#ifndef ALWAYS_NEED_THX\n            dTHX;\n#endif\n            if (PL_nomemok)\n                ptr =  NULL;\n            else\n                croak_no_mem();\n        }\n    }\n    return ptr;\n}\n\n/* paranoid version of system's realloc() */\n\nMalloc_t\nPerl_safesysrealloc(Malloc_t where,MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n#ifdef PERL_DEBUG_READONLY_COW\n    const MEM_SIZE oldsize = where\n\t? ((struct perl_memory_debug_header *)((char *)where - PERL_MEMORY_DEBUG_HEADER_SIZE))->size\n\t: 0;\n#endif\n\n    if (!size) {\n\tsafesysfree(where);\n\tptr = NULL;\n    }\n    else if (!where) {\n\tptr = safesysmalloc(size);\n    }\n    else {\n#ifdef USE_MDH\n\twhere = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);\n        if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)\n            goto out_of_memory;\n\tsize += PERL_MEMORY_DEBUG_HEADER_SIZE;\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)where;\n\n# ifdef PERL_TRACK_MEMPOOL\n\t    if (header->interpreter != aTHX) {\n\t\tPerl_croak_nocontext(\"panic: realloc from wrong pool, %p!=%p\",\n\t\t\t\t     header->interpreter, aTHX);\n\t    }\n\t    assert(header->next->prev == header);\n\t    assert(header->prev->next == header);\n#  ifdef PERL_POISON\n\t    if (header->size > size) {\n\t\tconst MEM_SIZE freed_up = header->size - size;\n\t\tchar *start_of_freed = ((char *)where) + size;\n\t\tPoisonFree(start_of_freed, freed_up, char);\n\t    }\n#  endif\n# endif\n# ifdef MDH_HAS_SIZE\n\t    header->size = size;\n# endif\n\t}\n#endif\n#ifdef DEBUGGING\n\tif ((SSize_t)size < 0)\n\t    Perl_croak_nocontext(\"panic: realloc, size=%\" UVuf, (UV)size);\n#endif\n#ifdef PERL_DEBUG_READONLY_COW\n\tif ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,\n\t\t\tMAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\t    perror(\"mmap failed\");\n\t    abort();\n\t}\n\tCopy(where,ptr,oldsize < size ? oldsize : size,char);\n\tif (munmap(where, oldsize)) {\n\t    perror(\"munmap failed\");\n\t    abort();\n\t}\n#else\n\tptr = (Malloc_t)PerlMem_realloc(where,size);\n#endif\n\tPERL_ALLOC_CHECK(ptr);\n\n    /* MUST do this fixup first, before doing ANYTHING else, as anything else\n       might allocate memory/free/move memory, and until we do the fixup, it\n       may well be chasing (and writing to) free memory.  */\n\tif (ptr != NULL) {\n#ifdef PERL_TRACK_MEMPOOL\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)ptr;\n\n#  ifdef PERL_POISON\n\t    if (header->size < size) {\n\t\tconst MEM_SIZE fresh = size - header->size;\n\t\tchar *start_of_fresh = ((char *)ptr) + size;\n\t\tPoisonNew(start_of_fresh, fresh, char);\n\t    }\n#  endif\n\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header;\n\t    maybe_protect_ro(header->next);\n\t    maybe_protect_rw(header->prev);\n\t    header->prev->next = header;\n\t    maybe_protect_ro(header->prev);\n#endif\n\t    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t}\n\n    /* In particular, must do that fixup above before logging anything via\n     *printf(), as it can reallocate memory, which can cause SEGVs.  */\n\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) rfree\\n\",PTR2UV(where),(long)PL_an++));\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) realloc %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)size));\n\n\tif (ptr == NULL) {\n#ifdef USE_MDH\n          out_of_memory:\n#endif\n            {\n#ifndef ALWAYS_NEED_THX\n                dTHX;\n#endif\n                if (PL_nomemok)\n                    ptr = NULL;\n                else\n                    croak_no_mem();\n            }\n\t}\n    }\n    return ptr;\n}\n\n/* safe version of system's free() */\n\nFree_t\nPerl_safesysfree(Malloc_t where)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    DEBUG_m( PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) free\\n\",PTR2UV(where),(long)PL_an++));\n    if (where) {\n#ifdef USE_MDH\n\tMalloc_t where_intrn = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)where_intrn;\n\n# ifdef MDH_HAS_SIZE\n\t    const MEM_SIZE size = header->size;\n# endif\n# ifdef PERL_TRACK_MEMPOOL\n\t    if (header->interpreter != aTHX) {\n\t\tPerl_croak_nocontext(\"panic: free from wrong pool, %p!=%p\",\n\t\t\t\t     header->interpreter, aTHX);\n\t    }\n\t    if (!header->prev) {\n\t\tPerl_croak_nocontext(\"panic: duplicate free\");\n\t    }\n\t    if (!(header->next))\n\t\tPerl_croak_nocontext(\"panic: bad free, header->next==NULL\");\n\t    if (header->next->prev != header || header->prev->next != header) {\n\t\tPerl_croak_nocontext(\"panic: bad free, ->next->prev=%p, \"\n\t\t\t\t     \"header=%p, ->prev->next=%p\",\n\t\t\t\t     header->next->prev, header,\n\t\t\t\t     header->prev->next);\n\t    }\n\t    /* Unlink us from the chain.  */\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header->prev;\n\t    maybe_protect_ro(header->next);\n\t    maybe_protect_rw(header->prev);\n\t    header->prev->next = header->next;\n\t    maybe_protect_ro(header->prev);\n\t    maybe_protect_rw(header);\n#  ifdef PERL_POISON\n\t    PoisonNew(where_intrn, size, char);\n#  endif\n\t    /* Trigger the duplicate free warning.  */\n\t    header->next = NULL;\n# endif\n# ifdef PERL_DEBUG_READONLY_COW\n\t    if (munmap(where_intrn, size)) {\n\t\tperror(\"munmap failed\");\n\t\tabort();\n\t    }\t\n# endif\n\t}\n#else\n\tMalloc_t where_intrn = where;\n#endif /* USE_MDH */\n#ifndef PERL_DEBUG_READONLY_COW\n\tPerlMem_free(where_intrn);\n#endif\n    }\n}\n\n/* safe version of system's calloc() */\n\nMalloc_t\nPerl_safesyscalloc(MEM_SIZE count, MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n#if defined(USE_MDH) || defined(DEBUGGING)\n    MEM_SIZE total_size = 0;\n#endif\n\n    /* Even though calloc() for zero bytes is strange, be robust. */\n    if (size && (count <= MEM_SIZE_MAX / size)) {\n#if defined(USE_MDH) || defined(DEBUGGING)\n\ttotal_size = size * count;\n#endif\n    }\n    else\n\tcroak_memory_wrap();\n#ifdef USE_MDH\n    if (PERL_MEMORY_DEBUG_HEADER_SIZE <= MEM_SIZE_MAX - (MEM_SIZE)total_size)\n\ttotal_size += PERL_MEMORY_DEBUG_HEADER_SIZE;\n    else\n\tcroak_memory_wrap();\n#endif\n#ifdef DEBUGGING\n    if ((SSize_t)size < 0 || (SSize_t)count < 0)\n\tPerl_croak_nocontext(\"panic: calloc, size=%\" UVuf \", count=%\" UVuf,\n\t\t\t     (UV)size, (UV)count);\n#endif\n#ifdef PERL_DEBUG_READONLY_COW\n    if ((ptr = mmap(0, total_size ? total_size : 1, PROT_READ|PROT_WRITE,\n\t\t    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\tperror(\"mmap failed\");\n\tabort();\n    }\n#elif defined(PERL_TRACK_MEMPOOL)\n    /* Have to use malloc() because we've added some space for our tracking\n       header.  */\n    /* malloc(0) is non-portable. */\n    ptr = (Malloc_t)PerlMem_malloc(total_size ? total_size : 1);\n#else\n    /* Use calloc() because it might save a memset() if the memory is fresh\n       and clean from the OS.  */\n    if (count && size)\n\tptr = (Malloc_t)PerlMem_calloc(count, size);\n    else /* calloc(0) is non-portable. */\n\tptr = (Malloc_t)PerlMem_calloc(count ? count : 1, size ? size : 1);\n#endif\n    PERL_ALLOC_CHECK(ptr);\n    DEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) calloc %ld x %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)count,(long)total_size));\n    if (ptr != NULL) {\n#ifdef USE_MDH\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)ptr;\n\n#  ifndef PERL_DEBUG_READONLY_COW\n\t    memset((void*)ptr, 0, total_size);\n#  endif\n#  ifdef PERL_TRACK_MEMPOOL\n\t    header->interpreter = aTHX;\n\t    /* Link us into the list.  */\n\t    header->prev = &PL_memory_debug_header;\n\t    header->next = PL_memory_debug_header.next;\n\t    PL_memory_debug_header.next = header;\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header;\n\t    maybe_protect_ro(header->next);\n#    ifdef PERL_DEBUG_READONLY_COW\n\t    header->readonly = 0;\n#    endif\n#  endif\n#  ifdef MDH_HAS_SIZE\n\t    header->size = total_size;\n#  endif\n\t    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t}\n#endif\n\treturn ptr;\n    }\n    else {\n#ifndef ALWAYS_NEED_THX\n\tdTHX;\n#endif\n\tif (PL_nomemok)\n\t    return NULL;\n\tcroak_no_mem();\n    }\n}\n\n/* These must be defined when not using Perl's malloc for binary\n * compatibility */\n\n#ifndef MYMALLOC\n\nMalloc_t Perl_malloc (MEM_SIZE nbytes)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    return (Malloc_t)PerlMem_malloc(nbytes);\n}\n\nMalloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    return (Malloc_t)PerlMem_calloc(elements, size);\n}\n\nMalloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    return (Malloc_t)PerlMem_realloc(where, nbytes);\n}\n\nFree_t   Perl_mfree (Malloc_t where)\n{\n#ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#endif\n    PerlMem_free(where);\n}\n\n#endif\n\n/* copy a string up to some (non-backslashed) delimiter, if any.\n * With allow_escape, converts \\<delimiter> to <delimiter>, while leaves\n * \\<non-delimiter> as-is.\n * Returns the position in the src string of the closing delimiter, if\n * any, or returns fromend otherwise.\n * This is the internal implementation for Perl_delimcpy and\n * Perl_delimcpy_no_escape.\n */\n\nstatic char *\nS_delimcpy_intern(char *to, const char *toend, const char *from,\n\t   const char *fromend, int delim, I32 *retlen,\n\t   const bool allow_escape)\n{\n    I32 tolen;\n\n    PERL_ARGS_ASSERT_DELIMCPY;\n\n    for (tolen = 0; from < fromend; from++, tolen++) {\n\tif (allow_escape && *from == '\\\\' && from + 1 < fromend) {\n\t    if (from[1] != delim) {\n\t\tif (to < toend)\n\t\t    *to++ = *from;\n\t\ttolen++;\n\t    }\n\t    from++;\n\t}\n\telse if (*from == delim)\n\t    break;\n\tif (to < toend)\n\t    *to++ = *from;\n    }\n    if (to < toend)\n\t*to = '\\0';\n    *retlen = tolen;\n    return (char *)from;\n}\n\nchar *\nPerl_delimcpy(char *to, const char *toend, const char *from, const char *fromend, int delim, I32 *retlen)\n{\n    PERL_ARGS_ASSERT_DELIMCPY;\n\n    return S_delimcpy_intern(to, toend, from, fromend, delim, retlen, 1);\n}\n\nchar *\nPerl_delimcpy_no_escape(char *to, const char *toend, const char *from,\n\t\t\tconst char *fromend, int delim, I32 *retlen)\n{\n    PERL_ARGS_ASSERT_DELIMCPY_NO_ESCAPE;\n\n    return S_delimcpy_intern(to, toend, from, fromend, delim, retlen, 0);\n}\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc Am|char *|ninstr|char * big|char * bigend|char * little|char * little_end\n\nFind the first (leftmost) occurrence of a sequence of bytes within another\nsequence.  This is the Perl version of C<strstr()>, extended to handle\narbitrary sequences, potentially containing embedded C<NUL> characters (C<NUL>\nis what the initial C<n> in the function name stands for; some systems have an\nequivalent, C<memmem()>, but with a somewhat different API).\n\nAnother way of thinking about this function is finding a needle in a haystack.\nC<big> points to the first byte in the haystack.  C<big_end> points to one byte\nbeyond the final byte in the haystack.  C<little> points to the first byte in\nthe needle.  C<little_end> points to one byte beyond the final byte in the\nneedle.  All the parameters must be non-C<NULL>.\n\nThe function returns C<NULL> if there is no occurrence of C<little> within\nC<big>.  If C<little> is the empty string, C<big> is returned.\n\nBecause this function operates at the byte level, and because of the inherent\ncharacteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the\nneedle and the haystack are strings with the same UTF-8ness, but not if the\nUTF-8ness differs.\n\n=cut\n\n*/\n\nchar *\nPerl_ninstr(const char *big, const char *bigend, const char *little, const char *lend)\n{\n    PERL_ARGS_ASSERT_NINSTR;\n\n#ifdef HAS_MEMMEM\n    return ninstr(big, bigend, little, lend);\n#else\n\n    if (little >= lend)\n        return (char*)big;\n    {\n        const char first = *little;\n        bigend -= lend - little++;\n    OUTER:\n        while (big <= bigend) {\n            if (*big++ == first) {\n                const char *s, *x;\n                for (x=big,s=little; s < lend; x++,s++) {\n                    if (*s != *x)\n                        goto OUTER;\n                }\n                return (char*)(big-1);\n            }\n        }\n    }\n    return NULL;\n\n#endif\n\n}\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc Am|char *|rninstr|char * big|char * bigend|char * little|char * little_end\n\nLike C<L</ninstr>>, but instead finds the final (rightmost) occurrence of a\nsequence of bytes within another sequence, returning C<NULL> if there is no\nsuch occurrence.\n\n=cut\n\n*/\n\nchar *\nPerl_rninstr(const char *big, const char *bigend, const char *little, const char *lend)\n{\n    const char *bigbeg;\n    const I32 first = *little;\n    const char * const littleend = lend;\n\n    PERL_ARGS_ASSERT_RNINSTR;\n\n    if (little >= littleend)\n\treturn (char*)bigend;\n    bigbeg = big;\n    big = bigend - (littleend - little++);\n    while (big >= bigbeg) {\n\tconst char *s, *x;\n\tif (*big-- != first)\n\t    continue;\n\tfor (x=big+2,s=little; s < littleend; /**/ ) {\n\t    if (*s != *x)\n\t\tbreak;\n\t    else {\n\t\tx++;\n\t\ts++;\n\t    }\n\t}\n\tif (s >= littleend)\n\t    return (char*)(big+1);\n    }\n    return NULL;\n}\n\n/* As a space optimization, we do not compile tables for strings of length\n   0 and 1, and for strings of length 2 unless FBMcf_TAIL.  These are\n   special-cased in fbm_instr().\n\n   If FBMcf_TAIL, the table is created as if the string has a trailing \\n. */\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc fbm_compile\n\nAnalyzes the string in order to make fast searches on it using C<fbm_instr()>\n-- the Boyer-Moore algorithm.\n\n=cut\n*/\n\nvoid\nPerl_fbm_compile(pTHX_ SV *sv, U32 flags)\n{\n    const U8 *s;\n    STRLEN i;\n    STRLEN len;\n    U32 frequency = 256;\n    MAGIC *mg;\n    PERL_DEB( STRLEN rarest = 0 );\n\n    PERL_ARGS_ASSERT_FBM_COMPILE;\n\n    if (isGV_with_GP(sv) || SvROK(sv))\n\treturn;\n\n    if (SvVALID(sv))\n\treturn;\n\n    if (flags & FBMcf_TAIL) {\n\tMAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;\n\tsv_catpvs(sv, \"\\n\");\t\t/* Taken into account in fbm_instr() */\n\tif (mg && mg->mg_len >= 0)\n\t    mg->mg_len++;\n    }\n    if (!SvPOK(sv) || SvNIOKp(sv))\n\ts = (U8*)SvPV_force_mutable(sv, len);\n    else s = (U8 *)SvPV_mutable(sv, len);\n    if (len == 0)\t\t/* TAIL might be on a zero-length string. */\n\treturn;\n    SvUPGRADE(sv, SVt_PVMG);\n    SvIOK_off(sv);\n    SvNOK_off(sv);\n\n    /* add PERL_MAGIC_bm magic holding the FBM lookup table */\n\n    assert(!mg_find(sv, PERL_MAGIC_bm));\n    mg = sv_magicext(sv, NULL, PERL_MAGIC_bm, &PL_vtbl_bm, NULL, 0);\n    assert(mg);\n\n    if (len > 2) {\n\t/* Shorter strings are special-cased in Perl_fbm_instr(), and don't use\n\t   the BM table.  */\n\tconst U8 mlen = (len>255) ? 255 : (U8)len;\n\tconst unsigned char *const sb = s + len - mlen; /* first char (maybe) */\n\tU8 *table;\n\n\tNewx(table, 256, U8);\n\tmemset((void*)table, mlen, 256);\n\tmg->mg_ptr = (char *)table;\n\tmg->mg_len = 256;\n\n\ts += len - 1; /* last char */\n\ti = 0;\n\twhile (s >= sb) {\n\t    if (table[*s] == mlen)\n\t\ttable[*s] = (U8)i;\n\t    s--, i++;\n\t}\n    }\n\n    s = (const unsigned char*)(SvPVX_const(sv));\t/* deeper magic */\n    for (i = 0; i < len; i++) {\n\tif (PL_freq[s[i]] < frequency) {\n\t    PERL_DEB( rarest = i );\n\t    frequency = PL_freq[s[i]];\n\t}\n    }\n    BmUSEFUL(sv) = 100;\t\t\t/* Initial value */\n    ((XPVNV*)SvANY(sv))->xnv_u.xnv_bm_tail = cBOOL(flags & FBMcf_TAIL);\n    DEBUG_r(PerlIO_printf(Perl_debug_log, \"rarest char %c at %\" UVuf \"\\n\",\n\t\t\t  s[rarest], (UV)rarest));\n}\n\n\n/*\n=for apidoc fbm_instr\n\nReturns the location of the SV in the string delimited by C<big> and\nC<bigend> (C<bigend>) is the char following the last char).\nIt returns C<NULL> if the string can't be found.  The C<sv>\ndoes not have to be C<fbm_compiled>, but the search will not be as fast\nthen.\n\n=cut\n\nIf SvTAIL(littlestr) is true, a fake \"\\n\" was appended to to the string\nduring FBM compilation due to FBMcf_TAIL in flags. It indicates that\nthe littlestr must be anchored to the end of bigstr (or to any \\n if\nFBMrf_MULTILINE).\n\nE.g. The regex compiler would compile /abc/ to a littlestr of \"abc\",\nwhile /abc$/ compiles to \"abc\\n\" with SvTAIL() true.\n\nA littlestr of \"abc\", !SvTAIL matches as /abc/;\na littlestr of \"ab\\n\", SvTAIL matches as:\n   without FBMrf_MULTILINE: /ab\\n?\\z/\n   with    FBMrf_MULTILINE: /ab\\n/ || /ab\\z/;\n\n(According to Ilya from 1999; I don't know if this is still true, DAPM 2015):\n  \"If SvTAIL is actually due to \\Z or \\z, this gives false positives\n  if multiline\".\n*/\n\n\nchar *\nPerl_fbm_instr(pTHX_ unsigned char *big, unsigned char *bigend, SV *littlestr, U32 flags)\n{\n    unsigned char *s;\n    STRLEN l;\n    const unsigned char *little = (const unsigned char *)SvPV_const(littlestr,l);\n    STRLEN littlelen = l;\n    const I32 multiline = flags & FBMrf_MULTILINE;\n    bool valid = SvVALID(littlestr);\n    bool tail = valid ? cBOOL(SvTAIL(littlestr)) : FALSE;\n\n    PERL_ARGS_ASSERT_FBM_INSTR;\n\n    assert(bigend >= big);\n\n    if ((STRLEN)(bigend - big) < littlelen) {\n\tif (     tail\n\t     && ((STRLEN)(bigend - big) == littlelen - 1)\n\t     && (littlelen == 1\n\t\t || (*big == *little &&\n\t\t     memEQ((char *)big, (char *)little, littlelen - 1))))\n\t    return (char*)big;\n\treturn NULL;\n    }\n\n    switch (littlelen) { /* Special cases for 0, 1 and 2  */\n    case 0:\n\treturn (char*)big;\t\t/* Cannot be SvTAIL! */\n\n    case 1:\n\t    if (tail && !multiline) /* Anchor only! */\n\t\t/* [-1] is safe because we know that bigend != big.  */\n\t\treturn (char *) (bigend - (bigend[-1] == '\\n'));\n\n\t    s = (unsigned char *)memchr((void*)big, *little, bigend-big);\n            if (s)\n                return (char *)s;\n\t    if (tail)\n\t\treturn (char *) bigend;\n\t    return NULL;\n\n    case 2:\n\tif (tail && !multiline) {\n            /* a littlestr with SvTAIL must be of the form \"X\\n\" (where X\n             * is a single char). It is anchored, and can only match\n             * \"....X\\n\"  or  \"....X\" */\n            if (bigend[-2] == *little && bigend[-1] == '\\n')\n\t\treturn (char*)bigend - 2;\n\t    if (bigend[-1] == *little)\n\t\treturn (char*)bigend - 1;\n\t    return NULL;\n\t}\n\n\t{\n            /* memchr() is likely to be very fast, possibly using whatever\n             * hardware support is available, such as checking a whole\n             * cache line in one instruction.\n             * So for a 2 char pattern, calling memchr() is likely to be\n             * faster than running FBM, or rolling our own. The previous\n             * version of this code was roll-your-own which typically\n             * only needed to read every 2nd char, which was good back in\n             * the day, but no longer.\n             */\n\t    unsigned char c1 = little[0];\n\t    unsigned char c2 = little[1];\n\n            /* *** for all this case, bigend points to the last char,\n             * not the trailing \\0: this makes the conditions slightly\n             * simpler */\n            bigend--;\n\t    s = big;\n            if (c1 != c2) {\n                while (s < bigend) {\n                    /* do a quick test for c1 before calling memchr();\n                     * this avoids the expensive fn call overhead when\n                     * there are lots of c1's */\n                    if (LIKELY(*s != c1)) {\n                        s++;\n                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);\n                        if (!s)\n                            break;\n                    }\n                    if (s[1] == c2)\n                        return (char*)s;\n\n                    /* failed; try searching for c2 this time; that way\n                     * we don't go pathologically slow when the string\n                     * consists mostly of c1's or vice versa.\n                     */\n                    s += 2;\n                    if (s > bigend)\n                        break;\n                    s = (unsigned char *)memchr((void*)s, c2, bigend - s + 1);\n                    if (!s)\n                        break;\n                    if (s[-1] == c1)\n                        return (char*)s - 1;\n                }\n            }\n            else {\n                /* c1, c2 the same */\n                while (s < bigend) {\n                    if (s[0] == c1) {\n                      got_1char:\n                        if (s[1] == c1)\n                            return (char*)s;\n                        s += 2;\n                    }\n                    else {\n                        s++;\n                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);\n                        if (!s || s >= bigend)\n                            break;\n                        goto got_1char;\n                    }\n                }\n            }\n\n            /* failed to find 2 chars; try anchored match at end without\n             * the \\n */\n            if (tail && bigend[0] == little[0])\n                return (char *)bigend;\n            return NULL;\n        }\n\n    default:\n\tbreak; /* Only lengths 0 1 and 2 have special-case code.  */\n    }\n\n    if (tail && !multiline) {\t/* tail anchored? */\n\ts = bigend - littlelen;\n\tif (s >= big && bigend[-1] == '\\n' && *s == *little\n\t    /* Automatically of length > 2 */\n\t    && memEQ((char*)s + 1, (char*)little + 1, littlelen - 2))\n\t{\n\t    return (char*)s;\t\t/* how sweet it is */\n\t}\n\tif (s[1] == *little\n\t    && memEQ((char*)s + 2, (char*)little + 1, littlelen - 2))\n\t{\n\t    return (char*)s + 1;\t/* how sweet it is */\n\t}\n\treturn NULL;\n    }\n\n    if (!valid) {\n        /* not compiled; use Perl_ninstr() instead */\n\tchar * const b = ninstr((char*)big,(char*)bigend,\n\t\t\t (char*)little, (char*)little + littlelen);\n\n        assert(!tail); /* valid => FBM; tail only set on SvVALID SVs */\n\treturn b;\n    }\n\n    /* Do actual FBM.  */\n    if (littlelen > (STRLEN)(bigend - big))\n\treturn NULL;\n\n    {\n\tconst MAGIC *const mg = mg_find(littlestr, PERL_MAGIC_bm);\n\tconst unsigned char *oldlittle;\n\n\tassert(mg);\n\n\t--littlelen;\t\t\t/* Last char found by table lookup */\n\n\ts = big + littlelen;\n\tlittle += littlelen;\t\t/* last char */\n\toldlittle = little;\n\tif (s < bigend) {\n\t    const unsigned char * const table = (const unsigned char *) mg->mg_ptr;\n            const unsigned char lastc = *little;\n\t    I32 tmp;\n\n\t  top2:\n\t    if ((tmp = table[*s])) {\n                /* *s != lastc; earliest position it could match now is\n                 * tmp slots further on */\n\t\tif ((s += tmp) >= bigend)\n                    goto check_end;\n                if (LIKELY(*s != lastc)) {\n                    s++;\n                    s = (unsigned char *)memchr((void*)s, lastc, bigend - s);\n                    if (!s) {\n                        s = bigend;\n                        goto check_end;\n                    }\n                    goto top2;\n                }\n\t    }\n\n\n            /* hand-rolled strncmp(): less expensive than calling the\n             * real function (maybe???) */\n\t    {\n\t\tunsigned char * const olds = s;\n\n\t\ttmp = littlelen;\n\n\t\twhile (tmp--) {\n\t\t    if (*--s == *--little)\n\t\t\tcontinue;\n\t\t    s = olds + 1;\t/* here we pay the price for failure */\n\t\t    little = oldlittle;\n\t\t    if (s < bigend)\t/* fake up continue to outer loop */\n\t\t\tgoto top2;\n\t\t    goto check_end;\n\t\t}\n\t\treturn (char *)s;\n\t    }\n\t}\n      check_end:\n\tif ( s == bigend\n\t     && tail\n\t     && memEQ((char *)(bigend - littlelen),\n\t\t      (char *)(oldlittle - littlelen), littlelen) )\n\t    return (char*)bigend - littlelen;\n\treturn NULL;\n    }\n}\n\n/* copy a string to a safe spot */\n\n/*\n=head1 Memory Management\n\n=for apidoc savepv\n\nPerl's version of C<strdup()>.  Returns a pointer to a newly allocated\nstring which is a duplicate of C<pv>.  The size of the string is\ndetermined by C<strlen()>, which means it may not contain embedded C<NUL>\ncharacters and must have a trailing C<NUL>.  The memory allocated for the new\nstring can be freed with the C<Safefree()> function.\n\nOn some platforms, Windows for example, all allocated memory owned by a thread\nis deallocated when that thread ends.  So if you need that not to happen, you\nneed to use the shared memory functions, such as C<L</savesharedpv>>.\n\n=cut\n*/\n\nchar *\nPerl_savepv(pTHX_ const char *pv)\n{\n    PERL_UNUSED_CONTEXT;\n    if (!pv)\n\treturn NULL;\n    else {\n\tchar *newaddr;\n\tconst STRLEN pvlen = strlen(pv)+1;\n\tNewx(newaddr, pvlen, char);\n\treturn (char*)memcpy(newaddr, pv, pvlen);\n    }\n}\n\n/* same thing but with a known length */\n\n/*\n=for apidoc savepvn\n\nPerl's version of what C<strndup()> would be if it existed.  Returns a\npointer to a newly allocated string which is a duplicate of the first\nC<len> bytes from C<pv>, plus a trailing\nC<NUL> byte.  The memory allocated for\nthe new string can be freed with the C<Safefree()> function.\n\nOn some platforms, Windows for example, all allocated memory owned by a thread\nis deallocated when that thread ends.  So if you need that not to happen, you\nneed to use the shared memory functions, such as C<L</savesharedpvn>>.\n\n=cut\n*/\n\nchar *\nPerl_savepvn(pTHX_ const char *pv, I32 len)\n{\n    char *newaddr;\n    PERL_UNUSED_CONTEXT;\n\n    assert(len >= 0);\n\n    Newx(newaddr,len+1,char);\n    /* Give a meaning to NULL pointer mainly for the use in sv_magic() */\n    if (pv) {\n\t/* might not be null terminated */\n    \tnewaddr[len] = '\\0';\n    \treturn (char *) CopyD(pv,newaddr,len,char);\n    }\n    else {\n\treturn (char *) ZeroD(newaddr,len+1,char);\n    }\n}\n\n/*\n=for apidoc savesharedpv\n\nA version of C<savepv()> which allocates the duplicate string in memory\nwhich is shared between threads.\n\n=cut\n*/\nchar *\nPerl_savesharedpv(pTHX_ const char *pv)\n{\n    char *newaddr;\n    STRLEN pvlen;\n\n    PERL_UNUSED_CONTEXT;\n\n    if (!pv)\n\treturn NULL;\n\n    pvlen = strlen(pv)+1;\n    newaddr = (char*)PerlMemShared_malloc(pvlen);\n    if (!newaddr) {\n\tcroak_no_mem();\n    }\n    return (char*)memcpy(newaddr, pv, pvlen);\n}\n\n/*\n=for apidoc savesharedpvn\n\nA version of C<savepvn()> which allocates the duplicate string in memory\nwhich is shared between threads.  (With the specific difference that a C<NULL>\npointer is not acceptable)\n\n=cut\n*/\nchar *\nPerl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)\n{\n    char *const newaddr = (char*)PerlMemShared_malloc(len + 1);\n\n    PERL_UNUSED_CONTEXT;\n    /* PERL_ARGS_ASSERT_SAVESHAREDPVN; */\n\n    if (!newaddr) {\n\tcroak_no_mem();\n    }\n    newaddr[len] = '\\0';\n    return (char*)memcpy(newaddr, pv, len);\n}\n\n/*\n=for apidoc savesvpv\n\nA version of C<savepv()>/C<savepvn()> which gets the string to duplicate from\nthe passed in SV using C<SvPV()>\n\nOn some platforms, Windows for example, all allocated memory owned by a thread\nis deallocated when that thread ends.  So if you need that not to happen, you\nneed to use the shared memory functions, such as C<L</savesharedsvpv>>.\n\n=cut\n*/\n\nchar *\nPerl_savesvpv(pTHX_ SV *sv)\n{\n    STRLEN len;\n    const char * const pv = SvPV_const(sv, len);\n    char *newaddr;\n\n    PERL_ARGS_ASSERT_SAVESVPV;\n\n    ++len;\n    Newx(newaddr,len,char);\n    return (char *) CopyD(pv,newaddr,len,char);\n}\n\n/*\n=for apidoc savesharedsvpv\n\nA version of C<savesharedpv()> which allocates the duplicate string in\nmemory which is shared between threads.\n\n=cut\n*/\n\nchar *\nPerl_savesharedsvpv(pTHX_ SV *sv)\n{\n    STRLEN len;\n    const char * const pv = SvPV_const(sv, len);\n\n    PERL_ARGS_ASSERT_SAVESHAREDSVPV;\n\n    return savesharedpvn(pv, len);\n}\n\n/* the SV for Perl_form() and mess() is not kept in an arena */\n\nSTATIC SV *\nS_mess_alloc(pTHX)\n{\n    SV *sv;\n    XPVMG *any;\n\n    if (PL_phase != PERL_PHASE_DESTRUCT)\n\treturn newSVpvs_flags(\"\", SVs_TEMP);\n\n    if (PL_mess_sv)\n\treturn PL_mess_sv;\n\n    /* Create as PVMG now, to avoid any upgrading later */\n    Newx(sv, 1, SV);\n    Newxz(any, 1, XPVMG);\n    SvFLAGS(sv) = SVt_PVMG;\n    SvANY(sv) = (void*)any;\n    SvPV_set(sv, NULL);\n    SvREFCNT(sv) = 1 << 30; /* practically infinite */\n    PL_mess_sv = sv;\n    return sv;\n}\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nchar *\nPerl_form_nocontext(const char* pat, ...)\n{\n    dTHX;\n    char *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_FORM_NOCONTEXT;\n    va_start(args, pat);\n    retval = vform(pat, &args);\n    va_end(args);\n    return retval;\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\n/*\n=head1 Miscellaneous Functions\n=for apidoc form\n\nTakes a sprintf-style format pattern and conventional\n(non-SV) arguments and returns the formatted string.\n\n    (char *) Perl_form(pTHX_ const char* pat, ...)\n\ncan be used any place a string (char *) is required:\n\n    char * s = Perl_form(\"%d.%d\",major,minor);\n\nUses a single private buffer so if you want to format several strings you\nmust explicitly copy the earlier strings away (and free the copies when you\nare done).\n\n=cut\n*/\n\nchar *\nPerl_form(pTHX_ const char* pat, ...)\n{\n    char *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_FORM;\n    va_start(args, pat);\n    retval = vform(pat, &args);\n    va_end(args);\n    return retval;\n}\n\nchar *\nPerl_vform(pTHX_ const char *pat, va_list *args)\n{\n    SV * const sv = mess_alloc();\n    PERL_ARGS_ASSERT_VFORM;\n    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);\n    return SvPVX(sv);\n}\n\n/*\n=for apidoc Am|SV *|mess|const char *pat|...\n\nTake a sprintf-style format pattern and argument list.  These are used to\ngenerate a string message.  If the message does not end with a newline,\nthen it will be extended with some indication of the current location\nin the code, as described for L</mess_sv>.\n\nNormally, the resulting message is returned in a new mortal SV.\nDuring global destruction a single SV may be shared between uses of\nthis function.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nSV *\nPerl_mess_nocontext(const char *pat, ...)\n{\n    dTHX;\n    SV *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_MESS_NOCONTEXT;\n    va_start(args, pat);\n    retval = vmess(pat, &args);\n    va_end(args);\n    return retval;\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nSV *\nPerl_mess(pTHX_ const char *pat, ...)\n{\n    SV *retval;\n    va_list args;\n    PERL_ARGS_ASSERT_MESS;\n    va_start(args, pat);\n    retval = vmess(pat, &args);\n    va_end(args);\n    return retval;\n}\n\nconst COP*\nPerl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop,\n\t\t       bool opnext)\n{\n    /* Look for curop starting from o.  cop is the last COP we've seen. */\n    /* opnext means that curop is actually the ->op_next of the op we are\n       seeking. */\n\n    PERL_ARGS_ASSERT_CLOSEST_COP;\n\n    if (!o || !curop || (\n\topnext ? o->op_next == curop && o->op_type != OP_SCOPE : o == curop\n    ))\n\treturn cop;\n\n    if (o->op_flags & OPf_KIDS) {\n\tconst OP *kid;\n\tfor (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {\n\t    const COP *new_cop;\n\n\t    /* If the OP_NEXTSTATE has been optimised away we can still use it\n\t     * the get the file and line number. */\n\n\t    if (kid->op_type == OP_NULL && kid->op_targ == OP_NEXTSTATE)\n\t\tcop = (const COP *)kid;\n\n\t    /* Keep searching, and return when we've found something. */\n\n\t    new_cop = closest_cop(cop, kid, curop, opnext);\n\t    if (new_cop)\n\t\treturn new_cop;\n\t}\n    }\n\n    /* Nothing found. */\n\n    return NULL;\n}\n\n/*\n=for apidoc Am|SV *|mess_sv|SV *basemsg|bool consume\n\nExpands a message, intended for the user, to include an indication of\nthe current location in the code, if the message does not already appear\nto be complete.\n\nC<basemsg> is the initial message or object.  If it is a reference, it\nwill be used as-is and will be the result of this function.  Otherwise it\nis used as a string, and if it already ends with a newline, it is taken\nto be complete, and the result of this function will be the same string.\nIf the message does not end with a newline, then a segment such as C<at\nfoo.pl line 37> will be appended, and possibly other clauses indicating\nthe current state of execution.  The resulting message will end with a\ndot and a newline.\n\nNormally, the resulting message is returned in a new mortal SV.\nDuring global destruction a single SV may be shared between uses of this\nfunction.  If C<consume> is true, then the function is permitted (but not\nrequired) to modify and return C<basemsg> instead of allocating a new SV.\n\n=cut\n*/\n\nSV *\nPerl_mess_sv(pTHX_ SV *basemsg, bool consume)\n{\n    SV *sv;\n\n#if defined(USE_C_BACKTRACE) && defined(USE_C_BACKTRACE_ON_ERROR)\n    {\n        char *ws;\n        UV wi;\n        /* The PERL_C_BACKTRACE_ON_WARN must be an integer of one or more. */\n        if ((ws = PerlEnv_getenv(\"PERL_C_BACKTRACE_ON_ERROR\"))\n            && grok_atoUV(ws, &wi, NULL)\n            && wi <= PERL_INT_MAX\n        ) {\n            Perl_dump_c_backtrace(aTHX_ Perl_debug_log, (int)wi, 1);\n        }\n    }\n#endif\n\n    PERL_ARGS_ASSERT_MESS_SV;\n\n    if (SvROK(basemsg)) {\n\tif (consume) {\n\t    sv = basemsg;\n\t}\n\telse {\n\t    sv = mess_alloc();\n\t    sv_setsv(sv, basemsg);\n\t}\n\treturn sv;\n    }\n\n    if (SvPOK(basemsg) && consume) {\n\tsv = basemsg;\n    }\n    else {\n\tsv = mess_alloc();\n\tsv_copypv(sv, basemsg);\n    }\n\n    if (!SvCUR(sv) || *(SvEND(sv) - 1) != '\\n') {\n\t/*\n\t * Try and find the file and line for PL_op.  This will usually be\n\t * PL_curcop, but it might be a cop that has been optimised away.  We\n\t * can try to find such a cop by searching through the optree starting\n\t * from the sibling of PL_curcop.\n\t */\n\n        if (PL_curcop) {\n            const COP *cop =\n                closest_cop(PL_curcop, OpSIBLING(PL_curcop), PL_op, FALSE);\n            if (!cop)\n                cop = PL_curcop;\n\n            if (CopLINE(cop))\n                Perl_sv_catpvf(aTHX_ sv, \" at %s line %\" IVdf,\n                                OutCopFILE(cop), (IV)CopLINE(cop));\n        }\n\n\t/* Seems that GvIO() can be untrustworthy during global destruction. */\n\tif (GvIO(PL_last_in_gv) && (SvTYPE(GvIOp(PL_last_in_gv)) == SVt_PVIO)\n\t\t&& IoLINES(GvIOp(PL_last_in_gv)))\n\t{\n\t    STRLEN l;\n\t    const bool line_mode = (RsSIMPLE(PL_rs) &&\n\t\t\t\t   *SvPV_const(PL_rs,l) == '\\n' && l == 1);\n\t    Perl_sv_catpvf(aTHX_ sv, \", <%\" SVf \"> %s %\" IVdf,\n\t\t\t   SVfARG(PL_last_in_gv == PL_argvgv\n                                 ? &PL_sv_no\n                                 : sv_2mortal(newSVhek(GvNAME_HEK(PL_last_in_gv)))),\n\t\t\t   line_mode ? \"line\" : \"chunk\",\n\t\t\t   (IV)IoLINES(GvIOp(PL_last_in_gv)));\n\t}\n\tif (PL_phase == PERL_PHASE_DESTRUCT)\n\t    sv_catpvs(sv, \" during global destruction\");\n\tsv_catpvs(sv, \".\\n\");\n    }\n    return sv;\n}\n\n/*\n=for apidoc Am|SV *|vmess|const char *pat|va_list *args\n\nC<pat> and C<args> are a sprintf-style format pattern and encapsulated\nargument list, respectively.  These are used to generate a string message.  If\nthe\nmessage does not end with a newline, then it will be extended with\nsome indication of the current location in the code, as described for\nL</mess_sv>.\n\nNormally, the resulting message is returned in a new mortal SV.\nDuring global destruction a single SV may be shared between uses of\nthis function.\n\n=cut\n*/\n\nSV *\nPerl_vmess(pTHX_ const char *pat, va_list *args)\n{\n    SV * const sv = mess_alloc();\n\n    PERL_ARGS_ASSERT_VMESS;\n\n    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);\n    return mess_sv(sv, 1);\n}\n\nvoid\nPerl_write_to_stderr(pTHX_ SV* msv)\n{\n    IO *io;\n    MAGIC *mg;\n\n    PERL_ARGS_ASSERT_WRITE_TO_STDERR;\n\n    if (PL_stderrgv && SvREFCNT(PL_stderrgv) \n\t&& (io = GvIO(PL_stderrgv))\n\t&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) \n\tPerl_magic_methcall(aTHX_ MUTABLE_SV(io), mg, SV_CONST(PRINT),\n\t\t\t    G_SCALAR | G_DISCARD | G_WRITING_TO_STDERR, 1, msv);\n    else {\n\tPerlIO * const serr = Perl_error_log;\n\n\tdo_print(msv, serr);\n\t(void)PerlIO_flush(serr);\n    }\n}\n\n/*\n=head1 Warning and Dieing\n*/\n\n/* Common code used in dieing and warning */\n\nSTATIC SV *\nS_with_queued_errors(pTHX_ SV *ex)\n{\n    PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS;\n    if (PL_errors && SvCUR(PL_errors) && !SvROK(ex)) {\n\tsv_catsv(PL_errors, ex);\n\tex = sv_mortalcopy(PL_errors);\n\tSvCUR_set(PL_errors, 0);\n    }\n    return ex;\n}\n\nSTATIC bool\nS_invoke_exception_hook(pTHX_ SV *ex, bool warn)\n{\n    HV *stash;\n    GV *gv;\n    CV *cv;\n    SV **const hook = warn ? &PL_warnhook : &PL_diehook;\n    /* sv_2cv might call Perl_croak() or Perl_warner() */\n    SV * const oldhook = *hook;\n\n    if (!oldhook)\n\treturn FALSE;\n\n    ENTER;\n    SAVESPTR(*hook);\n    *hook = NULL;\n    cv = sv_2cv(oldhook, &stash, &gv, 0);\n    LEAVE;\n    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {\n\tdSP;\n\tSV *exarg;\n\n\tENTER;\n\tsave_re_context();\n\tif (warn) {\n\t    SAVESPTR(*hook);\n\t    *hook = NULL;\n\t}\n\texarg = newSVsv(ex);\n\tSvREADONLY_on(exarg);\n\tSAVEFREESV(exarg);\n\n\tPUSHSTACKi(warn ? PERLSI_WARNHOOK : PERLSI_DIEHOOK);\n\tPUSHMARK(SP);\n\tXPUSHs(exarg);\n\tPUTBACK;\n\tcall_sv(MUTABLE_SV(cv), G_DISCARD);\n\tPOPSTACK;\n\tLEAVE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n=for apidoc Am|OP *|die_sv|SV *baseex\n\nBehaves the same as L</croak_sv>, except for the return type.\nIt should be used only where the C<OP *> return type is required.\nThe function never actually returns.\n\n=cut\n*/\n\n#ifdef _MSC_VER\n#  pragma warning( push )\n#  pragma warning( disable : 4646 ) /* warning C4646: function declared with\n    __declspec(noreturn) has non-void return type */\n#  pragma warning( disable : 4645 ) /* warning C4645: function declared with\n__declspec(noreturn) has a return statement */\n#endif\nOP *\nPerl_die_sv(pTHX_ SV *baseex)\n{\n    PERL_ARGS_ASSERT_DIE_SV;\n    croak_sv(baseex);\n    /* NOTREACHED */\n    NORETURN_FUNCTION_END;\n}\n#ifdef _MSC_VER\n#  pragma warning( pop )\n#endif\n\n/*\n=for apidoc Am|OP *|die|const char *pat|...\n\nBehaves the same as L</croak>, except for the return type.\nIt should be used only where the C<OP *> return type is required.\nThe function never actually returns.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\n#ifdef _MSC_VER\n#  pragma warning( push )\n#  pragma warning( disable : 4646 ) /* warning C4646: function declared with\n    __declspec(noreturn) has non-void return type */\n#  pragma warning( disable : 4645 ) /* warning C4645: function declared with\n__declspec(noreturn) has a return statement */\n#endif\nOP *\nPerl_die_nocontext(const char* pat, ...)\n{\n    dTHX;\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n    NORETURN_FUNCTION_END;\n}\n#ifdef _MSC_VER\n#  pragma warning( pop )\n#endif\n#endif /* PERL_IMPLICIT_CONTEXT */\n\n#ifdef _MSC_VER\n#  pragma warning( push )\n#  pragma warning( disable : 4646 ) /* warning C4646: function declared with\n    __declspec(noreturn) has non-void return type */\n#  pragma warning( disable : 4645 ) /* warning C4645: function declared with\n__declspec(noreturn) has a return statement */\n#endif\nOP *\nPerl_die(pTHX_ const char* pat, ...)\n{\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n    NORETURN_FUNCTION_END;\n}\n#ifdef _MSC_VER\n#  pragma warning( pop )\n#endif\n\n/*\n=for apidoc Am|void|croak_sv|SV *baseex\n\nThis is an XS interface to Perl's C<die> function.\n\nC<baseex> is the error message or object.  If it is a reference, it\nwill be used as-is.  Otherwise it is used as a string, and if it does\nnot end with a newline then it will be extended with some indication of\nthe current location in the code, as described for L</mess_sv>.\n\nThe error message or object will be used as an exception, by default\nreturning control to the nearest enclosing C<eval>, but subject to\nmodification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak_sv>\nfunction never returns normally.\n\nTo die with a simple string message, the L</croak> function may be\nmore convenient.\n\n=cut\n*/\n\nvoid\nPerl_croak_sv(pTHX_ SV *baseex)\n{\n    SV *ex = with_queued_errors(mess_sv(baseex, 0));\n    PERL_ARGS_ASSERT_CROAK_SV;\n    invoke_exception_hook(ex, FALSE);\n    die_unwind(ex);\n}\n\n/*\n=for apidoc Am|void|vcroak|const char *pat|va_list *args\n\nThis is an XS interface to Perl's C<die> function.\n\nC<pat> and C<args> are a sprintf-style format pattern and encapsulated\nargument list.  These are used to generate a string message.  If the\nmessage does not end with a newline, then it will be extended with\nsome indication of the current location in the code, as described for\nL</mess_sv>.\n\nThe error message will be used as an exception, by default\nreturning control to the nearest enclosing C<eval>, but subject to\nmodification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>\nfunction never returns normally.\n\nFor historical reasons, if C<pat> is null then the contents of C<ERRSV>\n(C<$@>) will be used as an error message or object instead of building an\nerror message from arguments.  If you want to throw a non-string object,\nor build an error message in an SV yourself, it is preferable to use\nthe L</croak_sv> function, which does not involve clobbering C<ERRSV>.\n\n=cut\n*/\n\nvoid\nPerl_vcroak(pTHX_ const char* pat, va_list *args)\n{\n    SV *ex = with_queued_errors(pat ? vmess(pat, args) : mess_sv(ERRSV, 0));\n    invoke_exception_hook(ex, FALSE);\n    die_unwind(ex);\n}\n\n/*\n=for apidoc Am|void|croak|const char *pat|...\n\nThis is an XS interface to Perl's C<die> function.\n\nTake a sprintf-style format pattern and argument list.  These are used to\ngenerate a string message.  If the message does not end with a newline,\nthen it will be extended with some indication of the current location\nin the code, as described for L</mess_sv>.\n\nThe error message will be used as an exception, by default\nreturning control to the nearest enclosing C<eval>, but subject to\nmodification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>\nfunction never returns normally.\n\nFor historical reasons, if C<pat> is null then the contents of C<ERRSV>\n(C<$@>) will be used as an error message or object instead of building an\nerror message from arguments.  If you want to throw a non-string object,\nor build an error message in an SV yourself, it is preferable to use\nthe L</croak_sv> function, which does not involve clobbering C<ERRSV>.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nvoid\nPerl_croak_nocontext(const char *pat, ...)\n{\n    dTHX;\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nvoid\nPerl_croak(pTHX_ const char *pat, ...)\n{\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n}\n\n/*\n=for apidoc Am|void|croak_no_modify\n\nExactly equivalent to C<Perl_croak(aTHX_ \"%s\", PL_no_modify)>, but generates\nterser object code than using C<Perl_croak>.  Less code used on exception code\npaths reduces CPU cache pressure.\n\n=cut\n*/\n\nvoid\nPerl_croak_no_modify(void)\n{\n    Perl_croak_nocontext( \"%s\", PL_no_modify);\n}\n\n/* does not return, used in util.c perlio.c and win32.c\n   This is typically called when malloc returns NULL.\n*/\nvoid\nPerl_croak_no_mem(void)\n{\n    dTHX;\n\n    int fd = PerlIO_fileno(Perl_error_log);\n    if (fd < 0)\n        SETERRNO(EBADF,RMS_IFI);\n    else {\n        /* Can't use PerlIO to write as it allocates memory */\n        PERL_UNUSED_RESULT(PerlLIO_write(fd, PL_no_mem, sizeof(PL_no_mem)-1));\n    }\n    my_exit(1);\n}\n\n/* does not return, used only in POPSTACK */\nvoid\nPerl_croak_popstack(void)\n{\n    dTHX;\n    PerlIO_printf(Perl_error_log, \"panic: POPSTACK\\n\");\n    my_exit(1);\n}\n\n/*\n=for apidoc Am|void|warn_sv|SV *baseex\n\nThis is an XS interface to Perl's C<warn> function.\n\nC<baseex> is the error message or object.  If it is a reference, it\nwill be used as-is.  Otherwise it is used as a string, and if it does\nnot end with a newline then it will be extended with some indication of\nthe current location in the code, as described for L</mess_sv>.\n\nThe error message or object will by default be written to standard error,\nbut this is subject to modification by a C<$SIG{__WARN__}> handler.\n\nTo warn with a simple string message, the L</warn> function may be\nmore convenient.\n\n=cut\n*/\n\nvoid\nPerl_warn_sv(pTHX_ SV *baseex)\n{\n    SV *ex = mess_sv(baseex, 0);\n    PERL_ARGS_ASSERT_WARN_SV;\n    if (!invoke_exception_hook(ex, TRUE))\n\twrite_to_stderr(ex);\n}\n\n/*\n=for apidoc Am|void|vwarn|const char *pat|va_list *args\n\nThis is an XS interface to Perl's C<warn> function.\n\nC<pat> and C<args> are a sprintf-style format pattern and encapsulated\nargument list.  These are used to generate a string message.  If the\nmessage does not end with a newline, then it will be extended with\nsome indication of the current location in the code, as described for\nL</mess_sv>.\n\nThe error message or object will by default be written to standard error,\nbut this is subject to modification by a C<$SIG{__WARN__}> handler.\n\nUnlike with L</vcroak>, C<pat> is not permitted to be null.\n\n=cut\n*/\n\nvoid\nPerl_vwarn(pTHX_ const char* pat, va_list *args)\n{\n    SV *ex = vmess(pat, args);\n    PERL_ARGS_ASSERT_VWARN;\n    if (!invoke_exception_hook(ex, TRUE))\n\twrite_to_stderr(ex);\n}\n\n/*\n=for apidoc Am|void|warn|const char *pat|...\n\nThis is an XS interface to Perl's C<warn> function.\n\nTake a sprintf-style format pattern and argument list.  These are used to\ngenerate a string message.  If the message does not end with a newline,\nthen it will be extended with some indication of the current location\nin the code, as described for L</mess_sv>.\n\nThe error message or object will by default be written to standard error,\nbut this is subject to modification by a C<$SIG{__WARN__}> handler.\n\nUnlike with L</croak>, C<pat> is not permitted to be null.\n\n=cut\n*/\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nvoid\nPerl_warn_nocontext(const char *pat, ...)\n{\n    dTHX;\n    va_list args;\n    PERL_ARGS_ASSERT_WARN_NOCONTEXT;\n    va_start(args, pat);\n    vwarn(pat, &args);\n    va_end(args);\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nvoid\nPerl_warn(pTHX_ const char *pat, ...)\n{\n    va_list args;\n    PERL_ARGS_ASSERT_WARN;\n    va_start(args, pat);\n    vwarn(pat, &args);\n    va_end(args);\n}\n\n#if defined(PERL_IMPLICIT_CONTEXT)\nvoid\nPerl_warner_nocontext(U32 err, const char *pat, ...)\n{\n    dTHX; \n    va_list args;\n    PERL_ARGS_ASSERT_WARNER_NOCONTEXT;\n    va_start(args, pat);\n    vwarner(err, pat, &args);\n    va_end(args);\n}\n#endif /* PERL_IMPLICIT_CONTEXT */\n\nvoid\nPerl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)\n{\n    PERL_ARGS_ASSERT_CK_WARNER_D;\n\n    if (Perl_ckwarn_d(aTHX_ err)) {\n\tva_list args;\n\tva_start(args, pat);\n\tvwarner(err, pat, &args);\n\tva_end(args);\n    }\n}\n\nvoid\nPerl_ck_warner(pTHX_ U32 err, const char* pat, ...)\n{\n    PERL_ARGS_ASSERT_CK_WARNER;\n\n    if (Perl_ckwarn(aTHX_ err)) {\n\tva_list args;\n\tva_start(args, pat);\n\tvwarner(err, pat, &args);\n\tva_end(args);\n    }\n}\n\nvoid\nPerl_warner(pTHX_ U32  err, const char* pat,...)\n{\n    va_list args;\n    PERL_ARGS_ASSERT_WARNER;\n    va_start(args, pat);\n    vwarner(err, pat, &args);\n    va_end(args);\n}\n\nvoid\nPerl_vwarner(pTHX_ U32  err, const char* pat, va_list* args)\n{\n    dVAR;\n    PERL_ARGS_ASSERT_VWARNER;\n    if (\n        (PL_warnhook == PERL_WARNHOOK_FATAL || ckDEAD(err)) &&\n        !(PL_in_eval & EVAL_KEEPERR)\n    ) {\n\tSV * const msv = vmess(pat, args);\n\n\tif (PL_parser && PL_parser->error_count) {\n\t    qerror(msv);\n\t}\n\telse {\n\t    invoke_exception_hook(msv, FALSE);\n\t    die_unwind(msv);\n\t}\n    }\n    else {\n\tPerl_vwarn(aTHX_ pat, args);\n    }\n}\n\n/* implements the ckWARN? macros */\n\nbool\nPerl_ckwarn(pTHX_ U32 w)\n{\n    /* If lexical warnings have not been set, use $^W.  */\n    if (isLEXWARN_off)\n\treturn PL_dowarn & G_WARN_ON;\n\n    return ckwarn_common(w);\n}\n\n/* implements the ckWARN?_d macro */\n\nbool\nPerl_ckwarn_d(pTHX_ U32 w)\n{\n    /* If lexical warnings have not been set then default classes warn.  */\n    if (isLEXWARN_off)\n\treturn TRUE;\n\n    return ckwarn_common(w);\n}\n\nstatic bool\nS_ckwarn_common(pTHX_ U32 w)\n{\n    if (PL_curcop->cop_warnings == pWARN_ALL)\n\treturn TRUE;\n\n    if (PL_curcop->cop_warnings == pWARN_NONE)\n\treturn FALSE;\n\n    /* Check the assumption that at least the first slot is non-zero.  */\n    assert(unpackWARN1(w));\n\n    /* Check the assumption that it is valid to stop as soon as a zero slot is\n       seen.  */\n    if (!unpackWARN2(w)) {\n\tassert(!unpackWARN3(w));\n\tassert(!unpackWARN4(w));\n    } else if (!unpackWARN3(w)) {\n\tassert(!unpackWARN4(w));\n    }\n\t\n    /* Right, dealt with all the special cases, which are implemented as non-\n       pointers, so there is a pointer to a real warnings mask.  */\n    do {\n\tif (isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w)))\n\t    return TRUE;\n    } while (w >>= WARNshift);\n\n    return FALSE;\n}\n\n/* Set buffer=NULL to get a new one.  */\nSTRLEN *\nPerl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits,\n\t\t\t   STRLEN size) {\n    const MEM_SIZE len_wanted =\n\tsizeof(STRLEN) + (size > WARNsize ? size : WARNsize);\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD;\n\n    buffer = (STRLEN*)\n\t(specialWARN(buffer) ?\n\t PerlMemShared_malloc(len_wanted) :\n\t PerlMemShared_realloc(buffer, len_wanted));\n    buffer[0] = size;\n    Copy(bits, (buffer + 1), size, char);\n    if (size < WARNsize)\n\tZero((char *)(buffer + 1) + size, WARNsize - size, char);\n    return buffer;\n}\n\n/* since we've already done strlen() for both nam and val\n * we can use that info to make things faster than\n * sprintf(s, \"%s=%s\", nam, val)\n */\n#define my_setenv_format(s, nam, nlen, val, vlen) \\\n   Copy(nam, s, nlen, char); \\\n   *(s+nlen) = '='; \\\n   Copy(val, s+(nlen+1), vlen, char); \\\n   *(s+(nlen+1+vlen)) = '\\0'\n\n#ifdef USE_ENVIRON_ARRAY\n\n/* small wrapper for use by Perl_my_setenv that mallocs, or reallocs if\n * 'current' is non-null, with up to three sizes that are added together.\n * It handles integer overflow.\n */\nstatic char *\nS_env_alloc(void *current, Size_t l1, Size_t l2, Size_t l3, Size_t size)\n{\n    void *p;\n    Size_t sl, l = l1 + l2;\n\n    if (l < l2)\n        goto panic;\n    l += l3;\n    if (l < l3)\n        goto panic;\n    sl = l * size;\n    if (sl < l)\n        goto panic;\n\n    p = current\n            ? safesysrealloc(current, sl)\n            : safesysmalloc(sl);\n    if (p)\n        return (char*)p;\n\n  panic:\n    croak_memory_wrap();\n}\n\n\n/* VMS' my_setenv() is in vms.c */\n#if !defined(WIN32) && !defined(NETWARE)\n\nvoid\nPerl_my_setenv(pTHX_ const char *nam, const char *val)\n{\n  dVAR;\n#ifdef __amigaos4__\n  amigaos4_obtain_environ(__FUNCTION__);\n#endif\n#ifdef USE_ITHREADS\n  /* only parent thread can modify process environment */\n  if (PL_curinterp == aTHX)\n#endif\n  {\n#ifndef PERL_USE_SAFE_PUTENV\n    if (!PL_use_safe_putenv) {\n        /* most putenv()s leak, so we manipulate environ directly */\n        UV i;\n        Size_t vlen, nlen = strlen(nam);\n\n        /* where does it go? */\n        for (i = 0; environ[i]; i++) {\n            if (strnEQ(environ[i], nam, nlen) && environ[i][nlen] == '=')\n                break;\n        }\n\n        if (environ == PL_origenviron) {   /* need we copy environment? */\n            UV j, max;\n            char **tmpenv;\n\n            max = i;\n            while (environ[max])\n                max++;\n            /* XXX shouldn't that be max+1 rather than max+2 ??? - DAPM */\n            tmpenv = (char**)S_env_alloc(NULL, max, 2, 0, sizeof(char*));\n            for (j=0; j<max; j++) {         /* copy environment */\n                const Size_t len = strlen(environ[j]);\n                tmpenv[j] = S_env_alloc(NULL, len, 1, 0, 1);\n                Copy(environ[j], tmpenv[j], len+1, char);\n            }\n            tmpenv[max] = NULL;\n            environ = tmpenv;               /* tell exec where it is now */\n        }\n        if (!val) {\n            safesysfree(environ[i]);\n            while (environ[i]) {\n                environ[i] = environ[i+1];\n                i++;\n            }\n#ifdef __amigaos4__\n            goto my_setenv_out;\n#else\n            return;\n#endif\n        }\n        if (!environ[i]) {                 /* does not exist yet */\n            environ = (char**)S_env_alloc(environ, i, 2, 0, sizeof(char*));\n            environ[i+1] = NULL;    /* make sure it's null terminated */\n        }\n        else\n            safesysfree(environ[i]);\n\n        vlen = strlen(val);\n\n        environ[i] = S_env_alloc(NULL, nlen, vlen, 2, 1);\n        /* all that work just for this */\n        my_setenv_format(environ[i], nam, nlen, val, vlen);\n    } else {\n# endif\n    /* This next branch should only be called #if defined(HAS_SETENV), but\n       Configure doesn't test for that yet.  For Solaris, setenv() and unsetenv()\n       were introduced in Solaris 9, so testing for HAS UNSETENV is sufficient.\n    */\n#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__) || (defined(__sun) && defined(HAS_UNSETENV)) || defined(PERL_DARWIN)\n#       if defined(HAS_UNSETENV)\n        if (val == NULL) {\n            (void)unsetenv(nam);\n        } else {\n            (void)setenv(nam, val, 1);\n        }\n#       else /* ! HAS_UNSETENV */\n        (void)setenv(nam, val, 1);\n#       endif /* HAS_UNSETENV */\n#   elif defined(HAS_UNSETENV)\n        if (val == NULL) {\n            if (environ) /* old glibc can crash with null environ */\n                (void)unsetenv(nam);\n        } else {\n\t    const Size_t nlen = strlen(nam);\n\t    const Size_t vlen = strlen(val);\n\t    char * const new_env = S_env_alloc(NULL, nlen, vlen, 2, 1);\n            my_setenv_format(new_env, nam, nlen, val, vlen);\n            (void)putenv(new_env);\n        }\n#   else /* ! HAS_UNSETENV */\n        char *new_env;\n\tconst Size_t nlen = strlen(nam);\n\tSize_t vlen;\n        if (!val) {\n\t   val = \"\";\n        }\n        vlen = strlen(val);\n        new_env = S_env_alloc(NULL, nlen, vlen, 2, 1);\n        /* all that work just for this */\n        my_setenv_format(new_env, nam, nlen, val, vlen);\n        (void)putenv(new_env);\n#   endif /* __CYGWIN__ */\n#ifndef PERL_USE_SAFE_PUTENV\n    }\n#endif\n  }\n#ifdef __amigaos4__\nmy_setenv_out:\n  amigaos4_release_environ(__FUNCTION__);\n#endif\n}\n\n#else /* WIN32 || NETWARE */\n\nvoid\nPerl_my_setenv(pTHX_ const char *nam, const char *val)\n{\n    dVAR;\n    char *envstr;\n    const Size_t nlen = strlen(nam);\n    Size_t vlen;\n\n    if (!val) {\n       val = \"\";\n    }\n    vlen = strlen(val);\n    envstr = S_env_alloc(NULL, nlen, vlen, 2, 1);\n    my_setenv_format(envstr, nam, nlen, val, vlen);\n    (void)PerlEnv_putenv(envstr);\n    Safefree(envstr);\n}\n\n#endif /* WIN32 || NETWARE */\n\n#endif /* !VMS */\n\n#ifdef UNLINK_ALL_VERSIONS\nI32\nPerl_unlnk(pTHX_ const char *f)\t/* unlink all versions of a file */\n{\n    I32 retries = 0;\n\n    PERL_ARGS_ASSERT_UNLNK;\n\n    while (PerlLIO_unlink(f) >= 0)\n\tretries++;\n    return retries ? 0 : -1;\n}\n#endif\n\nPerlIO *\nPerl_my_popen_list(pTHX_ const char *mode, int n, SV **args)\n{\n#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(OS2) && !defined(VMS) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)\n    int p[2];\n    I32 This, that;\n    Pid_t pid;\n    SV *sv;\n    I32 did_pipes = 0;\n    int pp[2];\n\n    PERL_ARGS_ASSERT_MY_POPEN_LIST;\n\n    PERL_FLUSHALL_FOR_CHILD;\n    This = (*mode == 'w');\n    that = !This;\n    if (TAINTING_get) {\n\ttaint_env();\n\ttaint_proper(\"Insecure %s%s\", \"EXEC\");\n    }\n    if (PerlProc_pipe_cloexec(p) < 0)\n\treturn NULL;\n    /* Try for another pipe pair for error return */\n    if (PerlProc_pipe_cloexec(pp) >= 0)\n\tdid_pipes = 1;\n    while ((pid = PerlProc_fork()) < 0) {\n\tif (errno != EAGAIN) {\n\t    PerlLIO_close(p[This]);\n\t    PerlLIO_close(p[that]);\n\t    if (did_pipes) {\n\t\tPerlLIO_close(pp[0]);\n\t\tPerlLIO_close(pp[1]);\n\t    }\n\t    return NULL;\n\t}\n\tPerl_ck_warner(aTHX_ packWARN(WARN_PIPE), \"Can't fork, trying again in 5 seconds\");\n\tsleep(5);\n    }\n    if (pid == 0) {\n\t/* Child */\n#undef THIS\n#undef THAT\n#define THIS that\n#define THAT This\n\t/* Close parent's end of error status pipe (if any) */\n\tif (did_pipes)\n\t    PerlLIO_close(pp[0]);\n\t/* Now dup our end of _the_ pipe to right position */\n\tif (p[THIS] != (*mode == 'r')) {\n\t    PerlLIO_dup2(p[THIS], *mode == 'r');\n\t    PerlLIO_close(p[THIS]);\n\t    if (p[THAT] != (*mode == 'r'))\t/* if dup2() didn't close it */\n\t\tPerlLIO_close(p[THAT]);\t/* close parent's end of _the_ pipe */\n\t}\n\telse\n\t    PerlLIO_close(p[THAT]);\t/* close parent's end of _the_ pipe */\n#if !defined(HAS_FCNTL) || !defined(F_SETFD)\n\t/* No automatic close - do it by hand */\n#  ifndef NOFILE\n#  define NOFILE 20\n#  endif\n\t{\n\t    int fd;\n\n\t    for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++) {\n\t\tif (fd != pp[1])\n\t\t    PerlLIO_close(fd);\n\t    }\n\t}\n#endif\n\tdo_aexec5(NULL, args-1, args-1+n, pp[1], did_pipes);\n\tPerlProc__exit(1);\n#undef THIS\n#undef THAT\n    }\n    /* Parent */\n    if (did_pipes)\n\tPerlLIO_close(pp[1]);\n    /* Keep the lower of the two fd numbers */\n    if (p[that] < p[This]) {\n\tPerlLIO_dup2_cloexec(p[This], p[that]);\n\tPerlLIO_close(p[This]);\n\tp[This] = p[that];\n    }\n    else\n\tPerlLIO_close(p[that]);\t\t/* close child's end of pipe */\n\n    sv = *av_fetch(PL_fdpid,p[This],TRUE);\n    SvUPGRADE(sv,SVt_IV);\n    SvIV_set(sv, pid);\n    PL_forkprocess = pid;\n    /* If we managed to get status pipe check for exec fail */\n    if (did_pipes && pid > 0) {\n\tint errkid;\n\tunsigned n = 0;\n\n\twhile (n < sizeof(int)) {\n            const SSize_t n1 = PerlLIO_read(pp[0],\n\t\t\t      (void*)(((char*)&errkid)+n),\n\t\t\t      (sizeof(int)) - n);\n\t    if (n1 <= 0)\n\t\tbreak;\n\t    n += n1;\n\t}\n\tPerlLIO_close(pp[0]);\n\tdid_pipes = 0;\n\tif (n) {\t\t\t/* Error */\n\t    int pid2, status;\n\t    PerlLIO_close(p[This]);\n\t    if (n != sizeof(int))\n\t\tPerl_croak(aTHX_ \"panic: kid popen errno read, n=%u\", n);\n\t    do {\n\t\tpid2 = wait4pid(pid, &status, 0);\n\t    } while (pid2 == -1 && errno == EINTR);\n\t    errno = errkid;\t\t/* Propagate errno from kid */\n\t    return NULL;\n\t}\n    }\n    if (did_pipes)\n\t PerlLIO_close(pp[0]);\n    return PerlIO_fdopen(p[This], mode);\n#else\n#  if defined(OS2)\t/* Same, without fork()ing and all extra overhead... */\n    return my_syspopen4(aTHX_ NULL, mode, n, args);\n#  elif defined(WIN32)\n    return win32_popenlist(mode, n, args);\n#  else\n    Perl_croak(aTHX_ \"List form of piped open not implemented\");\n    return (PerlIO *) NULL;\n#  endif\n#endif\n}\n\n    /* VMS' my_popen() is in VMS.c, same with OS/2 and AmigaOS 4. */\n#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)\nPerlIO *\nPerl_my_popen(pTHX_ const char *cmd, const char *mode)\n{\n    int p[2];\n    I32 This, that;\n    Pid_t pid;\n    SV *sv;\n    const I32 doexec = !(*cmd == '-' && cmd[1] == '\\0');\n    I32 did_pipes = 0;\n    int pp[2];\n\n    PERL_ARGS_ASSERT_MY_POPEN;\n\n    PERL_FLUSHALL_FOR_CHILD;\n#ifdef OS2\n    if (doexec) {\n\treturn my_syspopen(aTHX_ cmd,mode);\n    }\n#endif\n    This = (*mode == 'w');\n    that = !This;\n    if (doexec && TAINTING_get) {\n\ttaint_env();\n\ttaint_proper(\"Insecure %s%s\", \"EXEC\");\n    }\n    if (PerlProc_pipe_cloexec(p) < 0)\n\treturn NULL;\n    if (doexec && PerlProc_pipe_cloexec(pp) >= 0)\n\tdid_pipes = 1;\n    while ((pid = PerlProc_fork()) < 0) {\n\tif (errno != EAGAIN) {\n\t    PerlLIO_close(p[This]);\n\t    PerlLIO_close(p[that]);\n\t    if (did_pipes) {\n\t\tPerlLIO_close(pp[0]);\n\t\tPerlLIO_close(pp[1]);\n\t    }\n\t    if (!doexec)\n\t\tPerl_croak(aTHX_ \"Can't fork: %s\", Strerror(errno));\n\t    return NULL;\n\t}\n\tPerl_ck_warner(aTHX_ packWARN(WARN_PIPE), \"Can't fork, trying again in 5 seconds\");\n\tsleep(5);\n    }\n    if (pid == 0) {\n\n#undef THIS\n#undef THAT\n#define THIS that\n#define THAT This\n\tif (did_pipes)\n\t    PerlLIO_close(pp[0]);\n\tif (p[THIS] != (*mode == 'r')) {\n\t    PerlLIO_dup2(p[THIS], *mode == 'r');\n\t    PerlLIO_close(p[THIS]);\n\t    if (p[THAT] != (*mode == 'r'))\t/* if dup2() didn't close it */\n\t\tPerlLIO_close(p[THAT]);\n\t}\n\telse\n\t    PerlLIO_close(p[THAT]);\n#ifndef OS2\n\tif (doexec) {\n#if !defined(HAS_FCNTL) || !defined(F_SETFD)\n#ifndef NOFILE\n#define NOFILE 20\n#endif\n\t    {\n\t\tint fd;\n\n\t\tfor (fd = PL_maxsysfd + 1; fd < NOFILE; fd++)\n\t\t    if (fd != pp[1])\n\t\t\tPerlLIO_close(fd);\n\t    }\n#endif\n\t    /* may or may not use the shell */\n\t    do_exec3(cmd, pp[1], did_pipes);\n\t    PerlProc__exit(1);\n\t}\n#endif\t/* defined OS2 */\n\n#ifdef PERLIO_USING_CRLF\n   /* Since we circumvent IO layers when we manipulate low-level\n      filedescriptors directly, need to manually switch to the\n      default, binary, low-level mode; see PerlIOBuf_open(). */\n   PerlLIO_setmode((*mode == 'r'), O_BINARY);\n#endif \n\tPL_forkprocess = 0;\n#ifdef PERL_USES_PL_PIDSTATUS\n\thv_clear(PL_pidstatus);\t/* we have no children */\n#endif\n\treturn NULL;\n#undef THIS\n#undef THAT\n    }\n    if (did_pipes)\n\tPerlLIO_close(pp[1]);\n    if (p[that] < p[This]) {\n\tPerlLIO_dup2_cloexec(p[This], p[that]);\n\tPerlLIO_close(p[This]);\n\tp[This] = p[that];\n    }\n    else\n\tPerlLIO_close(p[that]);\n\n    sv = *av_fetch(PL_fdpid,p[This],TRUE);\n    SvUPGRADE(sv,SVt_IV);\n    SvIV_set(sv, pid);\n    PL_forkprocess = pid;\n    if (did_pipes && pid > 0) {\n\tint errkid;\n\tunsigned n = 0;\n\n\twhile (n < sizeof(int)) {\n            const SSize_t n1 = PerlLIO_read(pp[0],\n\t\t\t      (void*)(((char*)&errkid)+n),\n\t\t\t      (sizeof(int)) - n);\n\t    if (n1 <= 0)\n\t\tbreak;\n\t    n += n1;\n\t}\n\tPerlLIO_close(pp[0]);\n\tdid_pipes = 0;\n\tif (n) {\t\t\t/* Error */\n\t    int pid2, status;\n\t    PerlLIO_close(p[This]);\n\t    if (n != sizeof(int))\n\t\tPerl_croak(aTHX_ \"panic: kid popen errno read, n=%u\", n);\n\t    do {\n\t\tpid2 = wait4pid(pid, &status, 0);\n\t    } while (pid2 == -1 && errno == EINTR);\n\t    errno = errkid;\t\t/* Propagate errno from kid */\n\t    return NULL;\n\t}\n    }\n    if (did_pipes)\n\t PerlLIO_close(pp[0]);\n    return PerlIO_fdopen(p[This], mode);\n}\n#elif defined(DJGPP)\nFILE *djgpp_popen();\nPerlIO *\nPerl_my_popen(pTHX_ const char *cmd, const char *mode)\n{\n    PERL_FLUSHALL_FOR_CHILD;\n    /* Call system's popen() to get a FILE *, then import it.\n       used 0 for 2nd parameter to PerlIO_importFILE;\n       apparently not used\n    */\n    return PerlIO_importFILE(djgpp_popen(cmd, mode), 0);\n}\n#elif defined(__LIBCATAMOUNT__)\nPerlIO *\nPerl_my_popen(pTHX_ const char *cmd, const char *mode)\n{\n    return NULL;\n}\n\n#endif /* !DOSISH */\n\n/* this is called in parent before the fork() */\nvoid\nPerl_atfork_lock(void)\n#if defined(USE_ITHREADS)\n#  ifdef USE_PERLIO\n  PERL_TSA_ACQUIRE(PL_perlio_mutex)\n#  endif\n#  ifdef MYMALLOC\n  PERL_TSA_ACQUIRE(PL_malloc_mutex)\n#  endif\n  PERL_TSA_ACQUIRE(PL_op_mutex)\n#endif\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n    /* locks must be held in locking order (if any) */\n#  ifdef USE_PERLIO\n    MUTEX_LOCK(&PL_perlio_mutex);\n#  endif\n#  ifdef MYMALLOC\n    MUTEX_LOCK(&PL_malloc_mutex);\n#  endif\n    OP_REFCNT_LOCK;\n#endif\n}\n\n/* this is called in both parent and child after the fork() */\nvoid\nPerl_atfork_unlock(void)\n#if defined(USE_ITHREADS)\n#  ifdef USE_PERLIO\n  PERL_TSA_RELEASE(PL_perlio_mutex)\n#  endif\n#  ifdef MYMALLOC\n  PERL_TSA_RELEASE(PL_malloc_mutex)\n#  endif\n  PERL_TSA_RELEASE(PL_op_mutex)\n#endif\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n    /* locks must be released in same order as in atfork_lock() */\n#  ifdef USE_PERLIO\n    MUTEX_UNLOCK(&PL_perlio_mutex);\n#  endif\n#  ifdef MYMALLOC\n    MUTEX_UNLOCK(&PL_malloc_mutex);\n#  endif\n    OP_REFCNT_UNLOCK;\n#endif\n}\n\nPid_t\nPerl_my_fork(void)\n{\n#if defined(HAS_FORK)\n    Pid_t pid;\n#if defined(USE_ITHREADS) && !defined(HAS_PTHREAD_ATFORK)\n    atfork_lock();\n    pid = fork();\n    atfork_unlock();\n#else\n    /* atfork_lock() and atfork_unlock() are installed as pthread_atfork()\n     * handlers elsewhere in the code */\n    pid = fork();\n#endif\n    return pid;\n#elif defined(__amigaos4__)\n    return amigaos_fork();\n#else\n    /* this \"canna happen\" since nothing should be calling here if !HAS_FORK */\n    Perl_croak_nocontext(\"fork() not available\");\n    return 0;\n#endif /* HAS_FORK */\n}\n\n#ifndef HAS_DUP2\nint\ndup2(int oldfd, int newfd)\n{\n#if defined(HAS_FCNTL) && defined(F_DUPFD)\n    if (oldfd == newfd)\n\treturn oldfd;\n    PerlLIO_close(newfd);\n    return fcntl(oldfd, F_DUPFD, newfd);\n#else\n#define DUP2_MAX_FDS 256\n    int fdtmp[DUP2_MAX_FDS];\n    I32 fdx = 0;\n    int fd;\n\n    if (oldfd == newfd)\n\treturn oldfd;\n    PerlLIO_close(newfd);\n    /* good enough for low fd's... */\n    while ((fd = PerlLIO_dup(oldfd)) != newfd && fd >= 0) {\n\tif (fdx >= DUP2_MAX_FDS) {\n\t    PerlLIO_close(fd);\n\t    fd = -1;\n\t    break;\n\t}\n\tfdtmp[fdx++] = fd;\n    }\n    while (fdx > 0)\n\tPerlLIO_close(fdtmp[--fdx]);\n    return fd;\n#endif\n}\n#endif\n\n#ifndef PERL_MICRO\n#ifdef HAS_SIGACTION\n\nSighandler_t\nPerl_rsignal(pTHX_ int signo, Sighandler_t handler)\n{\n    struct sigaction act, oact;\n\n#ifdef USE_ITHREADS\n    dVAR;\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn (Sighandler_t) SIG_ERR;\n#endif\n\n    act.sa_handler = (void(*)(int))handler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n#ifdef SA_RESTART\n    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)\n        act.sa_flags |= SA_RESTART;\t/* SVR4, 4.3+BSD */\n#endif\n#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */\n    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)\n\tact.sa_flags |= SA_NOCLDWAIT;\n#endif\n    if (sigaction(signo, &act, &oact) == -1)\n    \treturn (Sighandler_t) SIG_ERR;\n    else\n    \treturn (Sighandler_t) oact.sa_handler;\n}\n\nSighandler_t\nPerl_rsignal_state(pTHX_ int signo)\n{\n    struct sigaction oact;\n    PERL_UNUSED_CONTEXT;\n\n    if (sigaction(signo, (struct sigaction *)NULL, &oact) == -1)\n\treturn (Sighandler_t) SIG_ERR;\n    else\n\treturn (Sighandler_t) oact.sa_handler;\n}\n\nint\nPerl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)\n{\n#ifdef USE_ITHREADS\n    dVAR;\n#endif\n    struct sigaction act;\n\n    PERL_ARGS_ASSERT_RSIGNAL_SAVE;\n\n#ifdef USE_ITHREADS\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n\n    act.sa_handler = (void(*)(int))handler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n#ifdef SA_RESTART\n    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)\n        act.sa_flags |= SA_RESTART;\t/* SVR4, 4.3+BSD */\n#endif\n#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */\n    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)\n\tact.sa_flags |= SA_NOCLDWAIT;\n#endif\n    return sigaction(signo, &act, save);\n}\n\nint\nPerl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)\n{\n#ifdef USE_ITHREADS\n    dVAR;\n#endif\n    PERL_UNUSED_CONTEXT;\n#ifdef USE_ITHREADS\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n\n    return sigaction(signo, save, (struct sigaction *)NULL);\n}\n\n#else /* !HAS_SIGACTION */\n\nSighandler_t\nPerl_rsignal(pTHX_ int signo, Sighandler_t handler)\n{\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn (Sighandler_t) SIG_ERR;\n#endif\n\n    return PerlProc_signal(signo, handler);\n}\n\nstatic Signal_t\nsig_trap(int signo)\n{\n    dVAR;\n    PL_sig_trapped++;\n}\n\nSighandler_t\nPerl_rsignal_state(pTHX_ int signo)\n{\n    dVAR;\n    Sighandler_t oldsig;\n\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn (Sighandler_t) SIG_ERR;\n#endif\n\n    PL_sig_trapped = 0;\n    oldsig = PerlProc_signal(signo, sig_trap);\n    PerlProc_signal(signo, oldsig);\n    if (PL_sig_trapped)\n\tPerlProc_kill(PerlProc_getpid(), signo);\n    return oldsig;\n}\n\nint\nPerl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)\n{\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n    *save = PerlProc_signal(signo, handler);\n    return (*save == (Sighandler_t) SIG_ERR) ? -1 : 0;\n}\n\nint\nPerl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)\n{\n#if defined(USE_ITHREADS) && !defined(WIN32)\n    /* only \"parent\" interpreter can diddle signals */\n    if (PL_curinterp != aTHX)\n\treturn -1;\n#endif\n    return (PerlProc_signal(signo, *save) == (Sighandler_t) SIG_ERR) ? -1 : 0;\n}\n\n#endif /* !HAS_SIGACTION */\n#endif /* !PERL_MICRO */\n\n    /* VMS' my_pclose() is in VMS.c; same with OS/2 */\n#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n{\n    int status;\n    SV **svp;\n    Pid_t pid;\n    Pid_t pid2 = 0;\n    bool close_failed;\n    dSAVEDERRNO;\n    const int fd = PerlIO_fileno(ptr);\n    bool should_wait;\n\n    svp = av_fetch(PL_fdpid,fd,TRUE);\n    pid = (SvTYPE(*svp) == SVt_IV) ? SvIVX(*svp) : -1;\n    SvREFCNT_dec(*svp);\n    *svp = NULL;\n\n#if defined(USE_PERLIO)\n    /* Find out whether the refcount is low enough for us to wait for the\n       child proc without blocking. */\n    should_wait = PerlIOUnix_refcnt(fd) == 1 && pid > 0;\n#else\n    should_wait = pid > 0;\n#endif\n\n#ifdef OS2\n    if (pid == -1) {\t\t\t/* Opened by popen. */\n\treturn my_syspclose(ptr);\n    }\n#endif\n    close_failed = (PerlIO_close(ptr) == EOF);\n    SAVE_ERRNO;\n    if (should_wait) do {\n\tpid2 = wait4pid(pid, &status, 0);\n    } while (pid2 == -1 && errno == EINTR);\n    if (close_failed) {\n\tRESTORE_ERRNO;\n\treturn -1;\n    }\n    return(\n      should_wait\n       ? pid2 < 0 ? pid2 : status == 0 ? 0 : (errno = 0, status)\n       : 0\n    );\n}\n#elif defined(__LIBCATAMOUNT__)\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n{\n    return -1;\n}\n#endif /* !DOSISH */\n\n#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(__LIBCATAMOUNT__)\nI32\nPerl_wait4pid(pTHX_ Pid_t pid, int *statusp, int flags)\n{\n    I32 result = 0;\n    PERL_ARGS_ASSERT_WAIT4PID;\n#ifdef PERL_USES_PL_PIDSTATUS\n    if (!pid) {\n        /* PERL_USES_PL_PIDSTATUS is only defined when neither\n           waitpid() nor wait4() is available, or on OS/2, which\n           doesn't appear to support waiting for a progress group\n           member, so we can only treat a 0 pid as an unknown child.\n        */\n        errno = ECHILD;\n        return -1;\n    }\n    {\n\tif (pid > 0) {\n\t    /* The keys in PL_pidstatus are now the raw 4 (or 8) bytes of the\n\t       pid, rather than a string form.  */\n\t    SV * const * const svp = hv_fetch(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),FALSE);\n\t    if (svp && *svp != &PL_sv_undef) {\n\t\t*statusp = SvIVX(*svp);\n\t\t(void)hv_delete(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),\n\t\t\t\tG_DISCARD);\n\t\treturn pid;\n\t    }\n\t}\n\telse {\n\t    HE *entry;\n\n\t    hv_iterinit(PL_pidstatus);\n\t    if ((entry = hv_iternext(PL_pidstatus))) {\n\t\tSV * const sv = hv_iterval(PL_pidstatus,entry);\n\t\tI32 len;\n\t\tconst char * const spid = hv_iterkey(entry,&len);\n\n\t\tassert (len == sizeof(Pid_t));\n\t\tmemcpy((char *)&pid, spid, len);\n\t\t*statusp = SvIVX(sv);\n\t\t/* The hash iterator is currently on this entry, so simply\n\t\t   calling hv_delete would trigger the lazy delete, which on\n\t\t   aggregate does more work, because next call to hv_iterinit()\n\t\t   would spot the flag, and have to call the delete routine,\n\t\t   while in the meantime any new entries can't re-use that\n\t\t   memory.  */\n\t\thv_iterinit(PL_pidstatus);\n\t\t(void)hv_delete(PL_pidstatus,spid,len,G_DISCARD);\n\t\treturn pid;\n\t    }\n\t}\n    }\n#endif\n#ifdef HAS_WAITPID\n#  ifdef HAS_WAITPID_RUNTIME\n    if (!HAS_WAITPID_RUNTIME)\n\tgoto hard_way;\n#  endif\n    result = PerlProc_waitpid(pid,statusp,flags);\n    goto finish;\n#endif\n#if !defined(HAS_WAITPID) && defined(HAS_WAIT4)\n    result = wait4(pid,statusp,flags,NULL);\n    goto finish;\n#endif\n#ifdef PERL_USES_PL_PIDSTATUS\n#if defined(HAS_WAITPID) && defined(HAS_WAITPID_RUNTIME)\n  hard_way:\n#endif\n    {\n\tif (flags)\n\t    Perl_croak(aTHX_ \"Can't do waitpid with flags\");\n\telse {\n\t    while ((result = PerlProc_wait(statusp)) != pid && pid > 0 && result >= 0)\n\t\tpidgone(result,*statusp);\n\t    if (result < 0)\n\t\t*statusp = -1;\n\t}\n    }\n#endif\n#if defined(HAS_WAITPID) || defined(HAS_WAIT4)\n  finish:\n#endif\n    if (result < 0 && errno == EINTR) {\n\tPERL_ASYNC_CHECK();\n\terrno = EINTR; /* reset in case a signal handler changed $! */\n    }\n    return result;\n}\n#endif /* !DOSISH || OS2 || WIN32 || NETWARE */\n\n#ifdef PERL_USES_PL_PIDSTATUS\nvoid\nS_pidgone(pTHX_ Pid_t pid, int status)\n{\n    SV *sv;\n\n    sv = *hv_fetch(PL_pidstatus,(const char*)&pid,sizeof(Pid_t),TRUE);\n    SvUPGRADE(sv,SVt_IV);\n    SvIV_set(sv, status);\n    return;\n}\n#endif\n\n#if defined(OS2)\nint pclose();\n#ifdef HAS_FORK\nint\t\t\t\t\t/* Cannot prototype with I32\n\t\t\t\t\t   in os2ish.h. */\nmy_syspclose(PerlIO *ptr)\n#else\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n#endif\n{\n    /* Needs work for PerlIO ! */\n    FILE * const f = PerlIO_findFILE(ptr);\n    const I32 result = pclose(f);\n    PerlIO_releaseFILE(ptr,f);\n    return result;\n}\n#endif\n\n#if defined(DJGPP)\nint djgpp_pclose();\nI32\nPerl_my_pclose(pTHX_ PerlIO *ptr)\n{\n    /* Needs work for PerlIO ! */\n    FILE * const f = PerlIO_findFILE(ptr);\n    I32 result = djgpp_pclose(f);\n    result = (result << 8) & 0xff00;\n    PerlIO_releaseFILE(ptr,f);\n    return result;\n}\n#endif\n\n#define PERL_REPEATCPY_LINEAR 4\nvoid\nPerl_repeatcpy(char *to, const char *from, I32 len, IV count)\n{\n    PERL_ARGS_ASSERT_REPEATCPY;\n\n    assert(len >= 0);\n\n    if (count < 0)\n\tcroak_memory_wrap();\n\n    if (len == 1)\n\tmemset(to, *from, count);\n    else if (count) {\n\tchar *p = to;\n\tIV items, linear, half;\n\n\tlinear = count < PERL_REPEATCPY_LINEAR ? count : PERL_REPEATCPY_LINEAR;\n\tfor (items = 0; items < linear; ++items) {\n\t    const char *q = from;\n\t    IV todo;\n\t    for (todo = len; todo > 0; todo--)\n\t\t*p++ = *q++;\n        }\n\n\thalf = count / 2;\n\twhile (items <= half) {\n\t    IV size = items * len;\n\t    memcpy(p, to, size);\n\t    p     += size;\n\t    items *= 2;\n\t}\n\n\tif (count > items)\n\t    memcpy(p, to, (count - items) * len);\n    }\n}\n\n#ifndef HAS_RENAME\nI32\nPerl_same_dirent(pTHX_ const char *a, const char *b)\n{\n    char *fa = strrchr(a,'/');\n    char *fb = strrchr(b,'/');\n    Stat_t tmpstatbuf1;\n    Stat_t tmpstatbuf2;\n    SV * const tmpsv = sv_newmortal();\n\n    PERL_ARGS_ASSERT_SAME_DIRENT;\n\n    if (fa)\n\tfa++;\n    else\n\tfa = a;\n    if (fb)\n\tfb++;\n    else\n\tfb = b;\n    if (strNE(a,b))\n\treturn FALSE;\n    if (fa == a)\n\tsv_setpvs(tmpsv, \".\");\n    else\n\tsv_setpvn(tmpsv, a, fa - a);\n    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf1) < 0)\n\treturn FALSE;\n    if (fb == b)\n\tsv_setpvs(tmpsv, \".\");\n    else\n\tsv_setpvn(tmpsv, b, fb - b);\n    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf2) < 0)\n\treturn FALSE;\n    return tmpstatbuf1.st_dev == tmpstatbuf2.st_dev &&\n\t   tmpstatbuf1.st_ino == tmpstatbuf2.st_ino;\n}\n#endif /* !HAS_RENAME */\n\nchar*\nPerl_find_script(pTHX_ const char *scriptname, bool dosearch,\n\t\t const char *const *const search_ext, I32 flags)\n{\n    const char *xfound = NULL;\n    char *xfailed = NULL;\n    char tmpbuf[MAXPATHLEN];\n    char *s;\n    I32 len = 0;\n    int retval;\n    char *bufend;\n#if defined(DOSISH) && !defined(OS2)\n#  define SEARCH_EXTS \".bat\", \".cmd\", NULL\n#  define MAX_EXT_LEN 4\n#endif\n#ifdef OS2\n#  define SEARCH_EXTS \".cmd\", \".btm\", \".bat\", \".pl\", NULL\n#  define MAX_EXT_LEN 4\n#endif\n#ifdef VMS\n#  define SEARCH_EXTS \".pl\", \".com\", NULL\n#  define MAX_EXT_LEN 4\n#endif\n    /* additional extensions to try in each dir if scriptname not found */\n#ifdef SEARCH_EXTS\n    static const char *const exts[] = { SEARCH_EXTS };\n    const char *const *const ext = search_ext ? search_ext : exts;\n    int extidx = 0, i = 0;\n    const char *curext = NULL;\n#else\n    PERL_UNUSED_ARG(search_ext);\n#  define MAX_EXT_LEN 0\n#endif\n\n    PERL_ARGS_ASSERT_FIND_SCRIPT;\n\n    /*\n     * If dosearch is true and if scriptname does not contain path\n     * delimiters, search the PATH for scriptname.\n     *\n     * If SEARCH_EXTS is also defined, will look for each\n     * scriptname{SEARCH_EXTS} whenever scriptname is not found\n     * while searching the PATH.\n     *\n     * Assuming SEARCH_EXTS is C<\".foo\",\".bar\",NULL>, PATH search\n     * proceeds as follows:\n     *   If DOSISH or VMSISH:\n     *     + look for ./scriptname{,.foo,.bar}\n     *     + search the PATH for scriptname{,.foo,.bar}\n     *\n     *   If !DOSISH:\n     *     + look *only* in the PATH for scriptname{,.foo,.bar} (note\n     *       this will not look in '.' if it's not in the PATH)\n     */\n    tmpbuf[0] = '\\0';\n\n#ifdef VMS\n#  ifdef ALWAYS_DEFTYPES\n    len = strlen(scriptname);\n    if (!(len == 1 && *scriptname == '-') && scriptname[len-1] != ':') {\n\tint idx = 0, deftypes = 1;\n\tbool seen_dot = 1;\n\n\tconst int hasdir = !dosearch || (strpbrk(scriptname,\":[</\") != NULL);\n#  else\n    if (dosearch) {\n\tint idx = 0, deftypes = 1;\n\tbool seen_dot = 1;\n\n\tconst int hasdir = (strpbrk(scriptname,\":[</\") != NULL);\n#  endif\n\t/* The first time through, just add SEARCH_EXTS to whatever we\n\t * already have, so we can check for default file types. */\n\twhile (deftypes ||\n\t       (!hasdir && my_trnlnm(\"DCL$PATH\",tmpbuf,idx++)) )\n\t{\n\t    Stat_t statbuf;\n\t    if (deftypes) {\n\t\tdeftypes = 0;\n\t\t*tmpbuf = '\\0';\n\t    }\n\t    if ((strlen(tmpbuf) + strlen(scriptname)\n\t\t + MAX_EXT_LEN) >= sizeof tmpbuf)\n\t\tcontinue;\t/* don't search dir with too-long name */\n\t    my_strlcat(tmpbuf, scriptname, sizeof(tmpbuf));\n#else  /* !VMS */\n\n#ifdef DOSISH\n    if (strEQ(scriptname, \"-\"))\n \tdosearch = 0;\n    if (dosearch) {\t\t/* Look in '.' first. */\n\tconst char *cur = scriptname;\n#ifdef SEARCH_EXTS\n\tif ((curext = strrchr(scriptname,'.')))\t/* possible current ext */\n\t    while (ext[i])\n\t\tif (strEQ(ext[i++],curext)) {\n\t\t    extidx = -1;\t\t/* already has an ext */\n\t\t    break;\n\t\t}\n\tdo {\n#endif\n\t    DEBUG_p(PerlIO_printf(Perl_debug_log,\n\t\t\t\t  \"Looking for %s\\n\",cur));\n\t    {\n\t\tStat_t statbuf;\n\t\tif (PerlLIO_stat(cur,&statbuf) >= 0\n\t\t    && !S_ISDIR(statbuf.st_mode)) {\n\t\t    dosearch = 0;\n\t\t    scriptname = cur;\n#ifdef SEARCH_EXTS\n\t\t    break;\n#endif\n\t\t}\n\t    }\n#ifdef SEARCH_EXTS\n\t    if (cur == scriptname) {\n\t\tlen = strlen(scriptname);\n\t\tif (len+MAX_EXT_LEN+1 >= sizeof(tmpbuf))\n\t\t    break;\n\t\tmy_strlcpy(tmpbuf, scriptname, sizeof(tmpbuf));\n\t\tcur = tmpbuf;\n\t    }\n\t} while (extidx >= 0 && ext[extidx]\t/* try an extension? */\n\t\t && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len));\n#endif\n    }\n#endif\n\n    if (dosearch && !strchr(scriptname, '/')\n#ifdef DOSISH\n\t\t && !strchr(scriptname, '\\\\')\n#endif\n\t\t && (s = PerlEnv_getenv(\"PATH\")))\n    {\n\tbool seen_dot = 0;\n\n\tbufend = s + strlen(s);\n\twhile (s < bufend) {\n\t    Stat_t statbuf;\n#  ifdef DOSISH\n\t    for (len = 0; *s\n\t\t    && *s != ';'; len++, s++) {\n\t\tif (len < sizeof tmpbuf)\n\t\t    tmpbuf[len] = *s;\n\t    }\n\t    if (len < sizeof tmpbuf)\n\t\ttmpbuf[len] = '\\0';\n#  else\n\t    s = delimcpy_no_escape(tmpbuf, tmpbuf + sizeof tmpbuf, s, bufend,\n                                   ':', &len);\n#  endif\n\t    if (s < bufend)\n\t\ts++;\n\t    if (len + 1 + strlen(scriptname) + MAX_EXT_LEN >= sizeof tmpbuf)\n\t\tcontinue;\t/* don't search dir with too-long name */\n\t    if (len\n#  ifdef DOSISH\n\t\t&& tmpbuf[len - 1] != '/'\n\t\t&& tmpbuf[len - 1] != '\\\\'\n#  endif\n\t       )\n\t\ttmpbuf[len++] = '/';\n\t    if (len == 2 && tmpbuf[0] == '.')\n\t\tseen_dot = 1;\n\t    (void)my_strlcpy(tmpbuf + len, scriptname, sizeof(tmpbuf) - len);\n#endif  /* !VMS */\n\n#ifdef SEARCH_EXTS\n\t    len = strlen(tmpbuf);\n\t    if (extidx > 0)\t/* reset after previous loop */\n\t\textidx = 0;\n\t    do {\n#endif\n\t    \tDEBUG_p(PerlIO_printf(Perl_debug_log, \"Looking for %s\\n\",tmpbuf));\n\t\tretval = PerlLIO_stat(tmpbuf,&statbuf);\n\t\tif (S_ISDIR(statbuf.st_mode)) {\n\t\t    retval = -1;\n\t\t}\n#ifdef SEARCH_EXTS\n\t    } while (  retval < 0\t\t/* not there */\n\t\t    && extidx>=0 && ext[extidx]\t/* try an extension? */\n\t\t    && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len)\n\t\t);\n#endif\n\t    if (retval < 0)\n\t\tcontinue;\n\t    if (S_ISREG(statbuf.st_mode)\n\t\t&& cando(S_IRUSR,TRUE,&statbuf)\n#if !defined(DOSISH)\n\t\t&& cando(S_IXUSR,TRUE,&statbuf)\n#endif\n\t\t)\n\t    {\n\t\txfound = tmpbuf;\t\t/* bingo! */\n\t\tbreak;\n\t    }\n\t    if (!xfailed)\n\t\txfailed = savepv(tmpbuf);\n\t}\n#ifndef DOSISH\n\t{\n\t    Stat_t statbuf;\n\t    if (!xfound && !seen_dot && !xfailed &&\n\t\t(PerlLIO_stat(scriptname,&statbuf) < 0\n\t\t || S_ISDIR(statbuf.st_mode)))\n#endif\n\t\tseen_dot = 1;\t\t\t/* Disable message. */\n#ifndef DOSISH\n\t}\n#endif\n\tif (!xfound) {\n\t    if (flags & 1) {\t\t\t/* do or die? */\n\t\t/* diag_listed_as: Can't execute %s */\n\t\tPerl_croak(aTHX_ \"Can't %s %s%s%s\",\n\t\t      (xfailed ? \"execute\" : \"find\"),\n\t\t      (xfailed ? xfailed : scriptname),\n\t\t      (xfailed ? \"\" : \" on PATH\"),\n\t\t      (xfailed || seen_dot) ? \"\" : \", '.' not in PATH\");\n\t    }\n\t    scriptname = NULL;\n\t}\n\tSafefree(xfailed);\n\tscriptname = xfound;\n    }\n    return (scriptname ? savepv(scriptname) : NULL);\n}\n\n#ifndef PERL_GET_CONTEXT_DEFINED\n\nvoid *\nPerl_get_context(void)\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n#  ifdef OLD_PTHREADS_API\n    pthread_addr_t t;\n    int error = pthread_getspecific(PL_thr_key, &t)\n    if (error)\n\tPerl_croak_nocontext(\"panic: pthread_getspecific, error=%d\", error);\n    return (void*)t;\n#  elif defined(I_MACH_CTHREADS)\n    return (void*)cthread_data(cthread_self());\n#  else\n    return (void*)PTHREAD_GETSPECIFIC(PL_thr_key);\n#  endif\n#else\n    return (void*)NULL;\n#endif\n}\n\nvoid\nPerl_set_context(void *t)\n{\n#if defined(USE_ITHREADS)\n    dVAR;\n#endif\n    PERL_ARGS_ASSERT_SET_CONTEXT;\n#if defined(USE_ITHREADS)\n#  ifdef I_MACH_CTHREADS\n    cthread_set_data(cthread_self(), t);\n#  else\n    {\n\tconst int error = pthread_setspecific(PL_thr_key, t);\n\tif (error)\n\t    Perl_croak_nocontext(\"panic: pthread_setspecific, error=%d\", error);\n    }\n#  endif\n#else\n    PERL_UNUSED_ARG(t);\n#endif\n}\n\n#endif /* !PERL_GET_CONTEXT_DEFINED */\n\n#if defined(PERL_GLOBAL_STRUCT) && !defined(PERL_GLOBAL_STRUCT_PRIVATE)\nstruct perl_vars *\nPerl_GetVars(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return &PL_Vars;\n}\n#endif\n\nchar **\nPerl_get_op_names(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return (char **)PL_op_name;\n}\n\nchar **\nPerl_get_op_descs(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return (char **)PL_op_desc;\n}\n\nconst char *\nPerl_get_no_modify(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return PL_no_modify;\n}\n\nU32 *\nPerl_get_opargs(pTHX)\n{\n    PERL_UNUSED_CONTEXT;\n    return (U32 *)PL_opargs;\n}\n\nPPADDR_t*\nPerl_get_ppaddr(pTHX)\n{\n    dVAR;\n    PERL_UNUSED_CONTEXT;\n    return (PPADDR_t*)PL_ppaddr;\n}\n\n#ifndef HAS_GETENV_LEN\nchar *\nPerl_getenv_len(pTHX_ const char *env_elem, unsigned long *len)\n{\n    char * const env_trans = PerlEnv_getenv(env_elem);\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_GETENV_LEN;\n    if (env_trans)\n\t*len = strlen(env_trans);\n    return env_trans;\n}\n#endif\n\n\nMGVTBL*\nPerl_get_vtbl(pTHX_ int vtbl_id)\n{\n    PERL_UNUSED_CONTEXT;\n\n    return (vtbl_id < 0 || vtbl_id >= magic_vtable_max)\n\t? NULL : (MGVTBL*)PL_magic_vtables + vtbl_id;\n}\n\nI32\nPerl_my_fflush_all(pTHX)\n{\n#if defined(USE_PERLIO) || defined(FFLUSH_NULL)\n    return PerlIO_flush(NULL);\n#else\n# if defined(HAS__FWALK)\n    extern int fflush(FILE *);\n    /* undocumented, unprototyped, but very useful BSDism */\n    extern void _fwalk(int (*)(FILE *));\n    _fwalk(&fflush);\n    return 0;\n# else\n#  if defined(FFLUSH_ALL) && defined(HAS_STDIO_STREAM_ARRAY)\n    long open_max = -1;\n#   ifdef PERL_FFLUSH_ALL_FOPEN_MAX\n    open_max = PERL_FFLUSH_ALL_FOPEN_MAX;\n#   elif defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)\n    open_max = sysconf(_SC_OPEN_MAX);\n#   elif defined(FOPEN_MAX)\n    open_max = FOPEN_MAX;\n#   elif defined(OPEN_MAX)\n    open_max = OPEN_MAX;\n#   elif defined(_NFILE)\n    open_max = _NFILE;\n#   endif\n    if (open_max > 0) {\n      long i;\n      for (i = 0; i < open_max; i++)\n\t    if (STDIO_STREAM_ARRAY[i]._file >= 0 &&\n\t\tSTDIO_STREAM_ARRAY[i]._file < open_max &&\n\t\tSTDIO_STREAM_ARRAY[i]._flag)\n\t\tPerlIO_flush(&STDIO_STREAM_ARRAY[i]);\n      return 0;\n    }\n#  endif\n    SETERRNO(EBADF,RMS_IFI);\n    return EOF;\n# endif\n#endif\n}\n\nvoid\nPerl_report_wrongway_fh(pTHX_ const GV *gv, const char have)\n{\n    if (ckWARN(WARN_IO)) {\n        HEK * const name\n           = gv && (isGV_with_GP(gv))\n                ? GvENAME_HEK((gv))\n                : NULL;\n\tconst char * const direction = have == '>' ? \"out\" : \"in\";\n\n\tif (name && HEK_LEN(name))\n\t    Perl_warner(aTHX_ packWARN(WARN_IO),\n\t\t\t\"Filehandle %\" HEKf \" opened only for %sput\",\n\t\t\tHEKfARG(name), direction);\n\telse\n\t    Perl_warner(aTHX_ packWARN(WARN_IO),\n\t\t\t\"Filehandle opened only for %sput\", direction);\n    }\n}\n\nvoid\nPerl_report_evil_fh(pTHX_ const GV *gv)\n{\n    const IO *io = gv ? GvIO(gv) : NULL;\n    const PERL_BITFIELD16 op = PL_op->op_type;\n    const char *vile;\n    I32 warn_type;\n\n    if (io && IoTYPE(io) == IoTYPE_CLOSED) {\n\tvile = \"closed\";\n\twarn_type = WARN_CLOSED;\n    }\n    else {\n\tvile = \"unopened\";\n\twarn_type = WARN_UNOPENED;\n    }\n\n    if (ckWARN(warn_type)) {\n        SV * const name\n            = gv && isGV_with_GP(gv) && GvENAMELEN(gv) ?\n                                     sv_2mortal(newSVhek(GvENAME_HEK(gv))) : NULL;\n\tconst char * const pars =\n\t    (const char *)(OP_IS_FILETEST(op) ? \"\" : \"()\");\n\tconst char * const func =\n\t    (const char *)\n\t    (op == OP_READLINE || op == OP_RCATLINE\n\t\t\t\t ? \"readline\"  :\t/* \"<HANDLE>\" not nice */\n\t     op == OP_LEAVEWRITE ? \"write\" :\t\t/* \"write exit\" not nice */\n\t     PL_op_desc[op]);\n\tconst char * const type =\n\t    (const char *)\n\t    (OP_IS_SOCKET(op) || (io && IoTYPE(io) == IoTYPE_SOCKET)\n\t     ? \"socket\" : \"filehandle\");\n\tconst bool have_name = name && SvCUR(name);\n\tPerl_warner(aTHX_ packWARN(warn_type),\n\t\t   \"%s%s on %s %s%s%\" SVf, func, pars, vile, type,\n\t\t    have_name ? \" \" : \"\",\n\t\t    SVfARG(have_name ? name : &PL_sv_no));\n\tif (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))\n\t\tPerl_warner(\n\t\t\t    aTHX_ packWARN(warn_type),\n\t\t\t\"\\t(Are you trying to call %s%s on dirhandle%s%\" SVf \"?)\\n\",\n\t\t\tfunc, pars, have_name ? \" \" : \"\",\n\t\t\tSVfARG(have_name ? name : &PL_sv_no)\n\t\t\t    );\n    }\n}\n\n/* To workaround core dumps from the uninitialised tm_zone we get the\n * system to give us a reasonable struct to copy.  This fix means that\n * strftime uses the tm_zone and tm_gmtoff values returned by\n * localtime(time()). That should give the desired result most of the\n * time. But probably not always!\n *\n * This does not address tzname aspects of NETaa14816.\n *\n */\n\n#ifdef __GLIBC__\n# ifndef STRUCT_TM_HASZONE\n#    define STRUCT_TM_HASZONE\n# endif\n#endif\n\n#ifdef STRUCT_TM_HASZONE /* Backward compat */\n# ifndef HAS_TM_TM_ZONE\n#    define HAS_TM_TM_ZONE\n# endif\n#endif\n\nvoid\nPerl_init_tm(pTHX_ struct tm *ptm)\t/* see mktime, strftime and asctime */\n{\n#ifdef HAS_TM_TM_ZONE\n    Time_t now;\n    const struct tm* my_tm;\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INIT_TM;\n    (void)time(&now);\n    my_tm = localtime(&now);\n    if (my_tm)\n        Copy(my_tm, ptm, 1, struct tm);\n#else\n    PERL_UNUSED_CONTEXT;\n    PERL_ARGS_ASSERT_INIT_TM;\n    PERL_UNUSED_ARG(ptm);\n#endif\n}\n\n/*\n * mini_mktime - normalise struct tm values without the localtime()\n * semantics (and overhead) of mktime().\n */\nvoid\nPerl_mini_mktime(struct tm *ptm)\n{\n    int yearday;\n    int secs;\n    int month, mday, year, jday;\n    int odd_cent, odd_year;\n\n    PERL_ARGS_ASSERT_MINI_MKTIME;\n\n#define\tDAYS_PER_YEAR\t365\n#define\tDAYS_PER_QYEAR\t(4*DAYS_PER_YEAR+1)\n#define\tDAYS_PER_CENT\t(25*DAYS_PER_QYEAR-1)\n#define\tDAYS_PER_QCENT\t(4*DAYS_PER_CENT+1)\n#define\tSECS_PER_HOUR\t(60*60)\n#define\tSECS_PER_DAY\t(24*SECS_PER_HOUR)\n/* parentheses deliberately absent on these two, otherwise they don't work */\n#define\tMONTH_TO_DAYS\t153/5\n#define\tDAYS_TO_MONTH\t5/153\n/* offset to bias by March (month 4) 1st between month/mday & year finding */\n#define\tYEAR_ADJUST\t(4*MONTH_TO_DAYS+1)\n/* as used here, the algorithm leaves Sunday as day 1 unless we adjust it */\n#define\tWEEKDAY_BIAS\t6\t/* (1+6)%7 makes Sunday 0 again */\n\n/*\n * Year/day algorithm notes:\n *\n * With a suitable offset for numeric value of the month, one can find\n * an offset into the year by considering months to have 30.6 (153/5) days,\n * using integer arithmetic (i.e., with truncation).  To avoid too much\n * messing about with leap days, we consider January and February to be\n * the 13th and 14th month of the previous year.  After that transformation,\n * we need the month index we use to be high by 1 from 'normal human' usage,\n * so the month index values we use run from 4 through 15.\n *\n * Given that, and the rules for the Gregorian calendar (leap years are those\n * divisible by 4 unless also divisible by 100, when they must be divisible\n * by 400 instead), we can simply calculate the number of days since some\n * arbitrary 'beginning of time' by futzing with the (adjusted) year number,\n * the days we derive from our month index, and adding in the day of the\n * month.  The value used here is not adjusted for the actual origin which\n * it normally would use (1 January A.D. 1), since we're not exposing it.\n * We're only building the value so we can turn around and get the\n * normalised values for the year, month, day-of-month, and day-of-year.\n *\n * For going backward, we need to bias the value we're using so that we find\n * the right year value.  (Basically, we don't want the contribution of\n * March 1st to the number to apply while deriving the year).  Having done\n * that, we 'count up' the contribution to the year number by accounting for\n * full quadracenturies (400-year periods) with their extra leap days, plus\n * the contribution from full centuries (to avoid counting in the lost leap\n * days), plus the contribution from full quad-years (to count in the normal\n * leap days), plus the leftover contribution from any non-leap years.\n * At this point, if we were working with an actual leap day, we'll have 0\n * days left over.  This is also true for March 1st, however.  So, we have\n * to special-case that result, and (earlier) keep track of the 'odd'\n * century and year contributions.  If we got 4 extra centuries in a qcent,\n * or 4 extra years in a qyear, then it's a leap day and we call it 29 Feb.\n * Otherwise, we add back in the earlier bias we removed (the 123 from\n * figuring in March 1st), find the month index (integer division by 30.6),\n * and the remainder is the day-of-month.  We then have to convert back to\n * 'real' months (including fixing January and February from being 14/15 in\n * the previous year to being in the proper year).  After that, to get\n * tm_yday, we work with the normalised year and get a new yearday value for\n * January 1st, which we subtract from the yearday value we had earlier,\n * representing the date we've re-built.  This is done from January 1\n * because tm_yday is 0-origin.\n *\n * Since POSIX time routines are only guaranteed to work for times since the\n * UNIX epoch (00:00:00 1 Jan 1970 UTC), the fact that this algorithm\n * applies Gregorian calendar rules even to dates before the 16th century\n * doesn't bother me.  Besides, you'd need cultural context for a given\n * date to know whether it was Julian or Gregorian calendar, and that's\n * outside the scope for this routine.  Since we convert back based on the\n * same rules we used to build the yearday, you'll only get strange results\n * for input which needed normalising, or for the 'odd' century years which\n * were leap years in the Julian calendar but not in the Gregorian one.\n * I can live with that.\n *\n * This algorithm also fails to handle years before A.D. 1 gracefully, but\n * that's still outside the scope for POSIX time manipulation, so I don't\n * care.\n *\n * - lwall\n */\n\n    year = 1900 + ptm->tm_year;\n    month = ptm->tm_mon;\n    mday = ptm->tm_mday;\n    jday = 0;\n    if (month >= 2)\n\tmonth+=2;\n    else\n\tmonth+=14, year--;\n    yearday = DAYS_PER_YEAR * year + year/4 - year/100 + year/400;\n    yearday += month*MONTH_TO_DAYS + mday + jday;\n    /*\n     * Note that we don't know when leap-seconds were or will be,\n     * so we have to trust the user if we get something which looks\n     * like a sensible leap-second.  Wild values for seconds will\n     * be rationalised, however.\n     */\n    if ((unsigned) ptm->tm_sec <= 60) {\n\tsecs = 0;\n    }\n    else {\n\tsecs = ptm->tm_sec;\n\tptm->tm_sec = 0;\n    }\n    secs += 60 * ptm->tm_min;\n    secs += SECS_PER_HOUR * ptm->tm_hour;\n    if (secs < 0) {\n\tif (secs-(secs/SECS_PER_DAY*SECS_PER_DAY) < 0) {\n\t    /* got negative remainder, but need positive time */\n\t    /* back off an extra day to compensate */\n\t    yearday += (secs/SECS_PER_DAY)-1;\n\t    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY - 1);\n\t}\n\telse {\n\t    yearday += (secs/SECS_PER_DAY);\n\t    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY);\n\t}\n    }\n    else if (secs >= SECS_PER_DAY) {\n\tyearday += (secs/SECS_PER_DAY);\n\tsecs %= SECS_PER_DAY;\n    }\n    ptm->tm_hour = secs/SECS_PER_HOUR;\n    secs %= SECS_PER_HOUR;\n    ptm->tm_min = secs/60;\n    secs %= 60;\n    ptm->tm_sec += secs;\n    /* done with time of day effects */\n    /*\n     * The algorithm for yearday has (so far) left it high by 428.\n     * To avoid mistaking a legitimate Feb 29 as Mar 1, we need to\n     * bias it by 123 while trying to figure out what year it\n     * really represents.  Even with this tweak, the reverse\n     * translation fails for years before A.D. 0001.\n     * It would still fail for Feb 29, but we catch that one below.\n     */\n    jday = yearday;\t/* save for later fixup vis-a-vis Jan 1 */\n    yearday -= YEAR_ADJUST;\n    year = (yearday / DAYS_PER_QCENT) * 400;\n    yearday %= DAYS_PER_QCENT;\n    odd_cent = yearday / DAYS_PER_CENT;\n    year += odd_cent * 100;\n    yearday %= DAYS_PER_CENT;\n    year += (yearday / DAYS_PER_QYEAR) * 4;\n    yearday %= DAYS_PER_QYEAR;\n    odd_year = yearday / DAYS_PER_YEAR;\n    year += odd_year;\n    yearday %= DAYS_PER_YEAR;\n    if (!yearday && (odd_cent==4 || odd_year==4)) { /* catch Feb 29 */\n\tmonth = 1;\n\tyearday = 29;\n    }\n    else {\n\tyearday += YEAR_ADJUST;\t/* recover March 1st crock */\n\tmonth = yearday*DAYS_TO_MONTH;\n\tyearday -= month*MONTH_TO_DAYS;\n\t/* recover other leap-year adjustment */\n\tif (month > 13) {\n\t    month-=14;\n\t    year++;\n\t}\n\telse {\n\t    month-=2;\n\t}\n    }\n    ptm->tm_year = year - 1900;\n    if (yearday) {\n      ptm->tm_mday = yearday;\n      ptm->tm_mon = month;\n    }\n    else {\n      ptm->tm_mday = 31;\n      ptm->tm_mon = month - 1;\n    }\n    /* re-build yearday based on Jan 1 to get tm_yday */\n    year--;\n    yearday = year*DAYS_PER_YEAR + year/4 - year/100 + year/400;\n    yearday += 14*MONTH_TO_DAYS + 1;\n    ptm->tm_yday = jday - yearday;\n    ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;\n}\n\nchar *\nPerl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)\n{\n#ifdef HAS_STRFTIME\n\n  /* strftime(), but with a different API so that the return value is a pointer\n   * to the formatted result (which MUST be arranged to be FREED BY THE\n   * CALLER).  This allows this function to increase the buffer size as needed,\n   * so that the caller doesn't have to worry about that.\n   *\n   * Note that yday and wday effectively are ignored by this function, as\n   * mini_mktime() overwrites them */\n\n  char *buf;\n  int buflen;\n  struct tm mytm;\n  int len;\n\n  PERL_ARGS_ASSERT_MY_STRFTIME;\n\n  init_tm(&mytm);\t/* XXX workaround - see init_tm() above */\n  mytm.tm_sec = sec;\n  mytm.tm_min = min;\n  mytm.tm_hour = hour;\n  mytm.tm_mday = mday;\n  mytm.tm_mon = mon;\n  mytm.tm_year = year;\n  mytm.tm_wday = wday;\n  mytm.tm_yday = yday;\n  mytm.tm_isdst = isdst;\n  mini_mktime(&mytm);\n  /* use libc to get the values for tm_gmtoff and tm_zone [perl #18238] */\n#if defined(HAS_MKTIME) && (defined(HAS_TM_TM_GMTOFF) || defined(HAS_TM_TM_ZONE))\n  STMT_START {\n    struct tm mytm2;\n    mytm2 = mytm;\n    mktime(&mytm2);\n#ifdef HAS_TM_TM_GMTOFF\n    mytm.tm_gmtoff = mytm2.tm_gmtoff;\n#endif\n#ifdef HAS_TM_TM_ZONE\n    mytm.tm_zone = mytm2.tm_zone;\n#endif\n  } STMT_END;\n#endif\n  buflen = 64;\n  Newx(buf, buflen, char);\n\n  GCC_DIAG_IGNORE_STMT(-Wformat-nonliteral); /* fmt checked by caller */\n  len = strftime(buf, buflen, fmt, &mytm);\n  GCC_DIAG_RESTORE_STMT;\n\n  /*\n  ** The following is needed to handle to the situation where\n  ** tmpbuf overflows.  Basically we want to allocate a buffer\n  ** and try repeatedly.  The reason why it is so complicated\n  ** is that getting a return value of 0 from strftime can indicate\n  ** one of the following:\n  ** 1. buffer overflowed,\n  ** 2. illegal conversion specifier, or\n  ** 3. the format string specifies nothing to be returned(not\n  **\t  an error).  This could be because format is an empty string\n  **    or it specifies %p that yields an empty string in some locale.\n  ** If there is a better way to make it portable, go ahead by\n  ** all means.\n  */\n  if ((len > 0 && len < buflen) || (len == 0 && *fmt == '\\0'))\n    return buf;\n  else {\n    /* Possibly buf overflowed - try again with a bigger buf */\n    const int fmtlen = strlen(fmt);\n    int bufsize = fmtlen + buflen;\n\n    Renew(buf, bufsize, char);\n    while (buf) {\n\n      GCC_DIAG_IGNORE_STMT(-Wformat-nonliteral); /* fmt checked by caller */\n      buflen = strftime(buf, bufsize, fmt, &mytm);\n      GCC_DIAG_RESTORE_STMT;\n\n      if (buflen > 0 && buflen < bufsize)\n\tbreak;\n      /* heuristic to prevent out-of-memory errors */\n      if (bufsize > 100*fmtlen) {\n\tSafefree(buf);\n\tbuf = NULL;\n\tbreak;\n      }\n      bufsize *= 2;\n      Renew(buf, bufsize, char);\n    }\n    return buf;\n  }\n#else\n  Perl_croak(aTHX_ \"panic: no strftime\");\n  return NULL;\n#endif\n}\n\n\n#define SV_CWD_RETURN_UNDEF \\\n    sv_set_undef(sv); \\\n    return FALSE\n\n#define SV_CWD_ISDOT(dp) \\\n    (dp->d_name[0] == '.' && (dp->d_name[1] == '\\0' || \\\n\t(dp->d_name[1] == '.' && dp->d_name[2] == '\\0')))\n\n/*\n=head1 Miscellaneous Functions\n\n=for apidoc getcwd_sv\n\nFill C<sv> with current working directory\n\n=cut\n*/\n\n/* Originally written in Perl by John Bazik; rewritten in C by Ben Sugars.\n * rewritten again by dougm, optimized for use with xs TARG, and to prefer\n * getcwd(3) if available\n * Comments from the original:\n *     This is a faster version of getcwd.  It's also more dangerous\n *     because you might chdir out of a directory that you can't chdir\n *     back into. */\n\nint\nPerl_getcwd_sv(pTHX_ SV *sv)\n{\n#ifndef PERL_MICRO\n    SvTAINTED_on(sv);\n\n    PERL_ARGS_ASSERT_GETCWD_SV;\n\n#ifdef HAS_GETCWD\n    {\n\tchar buf[MAXPATHLEN];\n\n\t/* Some getcwd()s automatically allocate a buffer of the given\n\t * size from the heap if they are given a NULL buffer pointer.\n\t * The problem is that this behaviour is not portable. */\n\tif (getcwd(buf, sizeof(buf) - 1)) {\n\t    sv_setpv(sv, buf);\n\t    return TRUE;\n\t}\n\telse {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n    }\n\n#else\n\n    Stat_t statbuf;\n    int orig_cdev, orig_cino, cdev, cino, odev, oino, tdev, tino;\n    int pathlen=0;\n    Direntry_t *dp;\n\n    SvUPGRADE(sv, SVt_PV);\n\n    if (PerlLIO_lstat(\".\", &statbuf) < 0) {\n\tSV_CWD_RETURN_UNDEF;\n    }\n\n    orig_cdev = statbuf.st_dev;\n    orig_cino = statbuf.st_ino;\n    cdev = orig_cdev;\n    cino = orig_cino;\n\n    for (;;) {\n\tDIR *dir;\n\tint namelen;\n\todev = cdev;\n\toino = cino;\n\n\tif (PerlDir_chdir(\"..\") < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\tif (PerlLIO_stat(\".\", &statbuf) < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\tcdev = statbuf.st_dev;\n\tcino = statbuf.st_ino;\n\n\tif (odev == cdev && oino == cino) {\n\t    break;\n\t}\n\tif (!(dir = PerlDir_open(\".\"))) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\twhile ((dp = PerlDir_read(dir)) != NULL) {\n#ifdef DIRNAMLEN\n\t    namelen = dp->d_namlen;\n#else\n\t    namelen = strlen(dp->d_name);\n#endif\n\t    /* skip . and .. */\n\t    if (SV_CWD_ISDOT(dp)) {\n\t\tcontinue;\n\t    }\n\n\t    if (PerlLIO_lstat(dp->d_name, &statbuf) < 0) {\n\t\tSV_CWD_RETURN_UNDEF;\n\t    }\n\n\t    tdev = statbuf.st_dev;\n\t    tino = statbuf.st_ino;\n\t    if (tino == oino && tdev == odev) {\n\t\tbreak;\n\t    }\n\t}\n\n\tif (!dp) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\tif (pathlen + namelen + 1 >= MAXPATHLEN) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n\n\tSvGROW(sv, pathlen + namelen + 1);\n\n\tif (pathlen) {\n\t    /* shift down */\n\t    Move(SvPVX_const(sv), SvPVX(sv) + namelen + 1, pathlen, char);\n\t}\n\n\t/* prepend current directory to the front */\n\t*SvPVX(sv) = '/';\n\tMove(dp->d_name, SvPVX(sv)+1, namelen, char);\n\tpathlen += (namelen + 1);\n\n#ifdef VOID_CLOSEDIR\n\tPerlDir_close(dir);\n#else\n\tif (PerlDir_close(dir) < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n#endif\n    }\n\n    if (pathlen) {\n\tSvCUR_set(sv, pathlen);\n\t*SvEND(sv) = '\\0';\n\tSvPOK_only(sv);\n\n\tif (PerlDir_chdir(SvPVX_const(sv)) < 0) {\n\t    SV_CWD_RETURN_UNDEF;\n\t}\n    }\n    if (PerlLIO_stat(\".\", &statbuf) < 0) {\n\tSV_CWD_RETURN_UNDEF;\n    }\n\n    cdev = statbuf.st_dev;\n    cino = statbuf.st_ino;\n\n    if (cdev != orig_cdev || cino != orig_cino) {\n\tPerl_croak(aTHX_ \"Unstable directory path, \"\n\t\t   \"current directory changed unexpectedly\");\n    }\n\n    return TRUE;\n#endif\n\n#else\n    return FALSE;\n#endif\n}\n\n#include \"vutil.c\"\n\n#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)\n#   define EMULATE_SOCKETPAIR_UDP\n#endif\n\n#ifdef EMULATE_SOCKETPAIR_UDP\nstatic int\nS_socketpair_udp (int fd[2]) {\n    dTHX;\n    /* Fake a datagram socketpair using UDP to localhost.  */\n    int sockets[2] = {-1, -1};\n    struct sockaddr_in addresses[2];\n    int i;\n    Sock_size_t size = sizeof(struct sockaddr_in);\n    unsigned short port;\n    int got;\n\n    memset(&addresses, 0, sizeof(addresses));\n    i = 1;\n    do {\n\tsockets[i] = PerlSock_socket(AF_INET, SOCK_DGRAM, PF_INET);\n\tif (sockets[i] == -1)\n\t    goto tidy_up_and_fail;\n\n\taddresses[i].sin_family = AF_INET;\n\taddresses[i].sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddresses[i].sin_port = 0;\t/* kernel choses port.  */\n\tif (PerlSock_bind(sockets[i], (struct sockaddr *) &addresses[i],\n\t\tsizeof(struct sockaddr_in)) == -1)\n\t    goto tidy_up_and_fail;\n    } while (i--);\n\n    /* Now have 2 UDP sockets. Find out which port each is connected to, and\n       for each connect the other socket to it.  */\n    i = 1;\n    do {\n\tif (PerlSock_getsockname(sockets[i], (struct sockaddr *) &addresses[i],\n\t\t&size) == -1)\n\t    goto tidy_up_and_fail;\n\tif (size != sizeof(struct sockaddr_in))\n\t    goto abort_tidy_up_and_fail;\n\t/* !1 is 0, !0 is 1 */\n\tif (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],\n\t\tsizeof(struct sockaddr_in)) == -1)\n\t    goto tidy_up_and_fail;\n    } while (i--);\n\n    /* Now we have 2 sockets connected to each other. I don't trust some other\n       process not to have already sent a packet to us (by random) so send\n       a packet from each to the other.  */\n    i = 1;\n    do {\n\t/* I'm going to send my own port number.  As a short.\n\t   (Who knows if someone somewhere has sin_port as a bitfield and needs\n\t   this routine. (I'm assuming crays have socketpair)) */\n\tport = addresses[i].sin_port;\n\tgot = PerlLIO_write(sockets[i], &port, sizeof(port));\n\tif (got != sizeof(port)) {\n\t    if (got == -1)\n\t\tgoto tidy_up_and_fail;\n\t    goto abort_tidy_up_and_fail;\n\t}\n    } while (i--);\n\n    /* Packets sent. I don't trust them to have arrived though.\n       (As I understand it Solaris TCP stack is multithreaded. Non-blocking\n       connect to localhost will use a second kernel thread. In 2.6 the\n       first thread running the connect() returns before the second completes,\n       so EINPROGRESS> In 2.7 the improved stack is faster and connect()\n       returns 0. Poor programs have tripped up. One poor program's authors'\n       had a 50-1 reverse stock split. Not sure how connected these were.)\n       So I don't trust someone not to have an unpredictable UDP stack.\n    */\n\n    {\n\tstruct timeval waitfor = {0, 100000}; /* You have 0.1 seconds */\n\tint max = sockets[1] > sockets[0] ? sockets[1] : sockets[0];\n\tfd_set rset;\n\n\tFD_ZERO(&rset);\n\tFD_SET((unsigned int)sockets[0], &rset);\n\tFD_SET((unsigned int)sockets[1], &rset);\n\n\tgot = PerlSock_select(max + 1, &rset, NULL, NULL, &waitfor);\n\tif (got != 2 || !FD_ISSET(sockets[0], &rset)\n\t\t|| !FD_ISSET(sockets[1], &rset)) {\n\t    /* I hope this is portable and appropriate.  */\n\t    if (got == -1)\n\t\tgoto tidy_up_and_fail;\n\t    goto abort_tidy_up_and_fail;\n\t}\n    }\n\n    /* And the paranoia department even now doesn't trust it to have arrive\n       (hence MSG_DONTWAIT). Or that what arrives was sent by us.  */\n    {\n\tstruct sockaddr_in readfrom;\n\tunsigned short buffer[2];\n\n\ti = 1;\n\tdo {\n#ifdef MSG_DONTWAIT\n\t    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,\n\t\t    sizeof(buffer), MSG_DONTWAIT,\n\t\t    (struct sockaddr *) &readfrom, &size);\n#else\n\t    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,\n\t\t    sizeof(buffer), 0,\n\t\t    (struct sockaddr *) &readfrom, &size);\n#endif\n\n\t    if (got == -1)\n\t\tgoto tidy_up_and_fail;\n\t    if (got != sizeof(port)\n\t\t    || size != sizeof(struct sockaddr_in)\n\t\t    /* Check other socket sent us its port.  */\n\t\t    || buffer[0] != (unsigned short) addresses[!i].sin_port\n\t\t    /* Check kernel says we got the datagram from that socket */\n\t\t    || readfrom.sin_family != addresses[!i].sin_family\n\t\t    || readfrom.sin_addr.s_addr != addresses[!i].sin_addr.s_addr\n\t\t    || readfrom.sin_port != addresses[!i].sin_port)\n\t\tgoto abort_tidy_up_and_fail;\n\t} while (i--);\n    }\n    /* My caller (my_socketpair) has validated that this is non-NULL  */\n    fd[0] = sockets[0];\n    fd[1] = sockets[1];\n    /* I hereby declare this connection open.  May God bless all who cross\n       her.  */\n    return 0;\n\n  abort_tidy_up_and_fail:\n    errno = ECONNABORTED;\n  tidy_up_and_fail:\n    {\n\tdSAVE_ERRNO;\n\tif (sockets[0] != -1)\n\t    PerlLIO_close(sockets[0]);\n\tif (sockets[1] != -1)\n\t    PerlLIO_close(sockets[1]);\n\tRESTORE_ERRNO;\n\treturn -1;\n    }\n}\n#endif /*  EMULATE_SOCKETPAIR_UDP */\n\n#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET)\nint\nPerl_my_socketpair (int family, int type, int protocol, int fd[2]) {\n    /* Stevens says that family must be AF_LOCAL, protocol 0.\n       I'm going to enforce that, then ignore it, and use TCP (or UDP).  */\n    dTHXa(NULL);\n    int listener = -1;\n    int connector = -1;\n    int acceptor = -1;\n    struct sockaddr_in listen_addr;\n    struct sockaddr_in connect_addr;\n    Sock_size_t size;\n\n    if (protocol\n#ifdef AF_UNIX\n\t|| family != AF_UNIX\n#endif\n    ) {\n\terrno = EAFNOSUPPORT;\n\treturn -1;\n    }\n    if (!fd) {\n\terrno = EINVAL;\n\treturn -1;\n    }\n\n#ifdef SOCK_CLOEXEC\n    type &= ~SOCK_CLOEXEC;\n#endif\n\n#ifdef EMULATE_SOCKETPAIR_UDP\n    if (type == SOCK_DGRAM)\n\treturn S_socketpair_udp(fd);\n#endif\n\n    aTHXa(PERL_GET_THX);\n    listener = PerlSock_socket(AF_INET, type, 0);\n    if (listener == -1)\n\treturn -1;\n    memset(&listen_addr, 0, sizeof(listen_addr));\n    listen_addr.sin_family = AF_INET;\n    listen_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    listen_addr.sin_port = 0;\t/* kernel choses port.  */\n    if (PerlSock_bind(listener, (struct sockaddr *) &listen_addr,\n\t    sizeof(listen_addr)) == -1)\n\tgoto tidy_up_and_fail;\n    if (PerlSock_listen(listener, 1) == -1)\n\tgoto tidy_up_and_fail;\n\n    connector = PerlSock_socket(AF_INET, type, 0);\n    if (connector == -1)\n\tgoto tidy_up_and_fail;\n    /* We want to find out the port number to connect to.  */\n    size = sizeof(connect_addr);\n    if (PerlSock_getsockname(listener, (struct sockaddr *) &connect_addr,\n\t    &size) == -1)\n\tgoto tidy_up_and_fail;\n    if (size != sizeof(connect_addr))\n\tgoto abort_tidy_up_and_fail;\n    if (PerlSock_connect(connector, (struct sockaddr *) &connect_addr,\n\t    sizeof(connect_addr)) == -1)\n\tgoto tidy_up_and_fail;\n\n    size = sizeof(listen_addr);\n    acceptor = PerlSock_accept(listener, (struct sockaddr *) &listen_addr,\n\t    &size);\n    if (acceptor == -1)\n\tgoto tidy_up_and_fail;\n    if (size != sizeof(listen_addr))\n\tgoto abort_tidy_up_and_fail;\n    PerlLIO_close(listener);\n    /* Now check we are talking to ourself by matching port and host on the\n       two sockets.  */\n    if (PerlSock_getsockname(connector, (struct sockaddr *) &connect_addr,\n\t    &size) == -1)\n\tgoto tidy_up_and_fail;\n    if (size != sizeof(connect_addr)\n\t    || listen_addr.sin_family != connect_addr.sin_family\n\t    || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr\n\t    || listen_addr.sin_port != connect_addr.sin_port) {\n\tgoto abort_tidy_up_and_fail;\n    }\n    fd[0] = connector;\n    fd[1] = acceptor;\n    return 0;\n\n  abort_tidy_up_and_fail:\n#ifdef ECONNABORTED\n  errno = ECONNABORTED;\t/* This would be the standard thing to do. */\n#elif defined(ECONNREFUSED)\n  errno = ECONNREFUSED;\t/* E.g. Symbian does not have ECONNABORTED. */\n#else\n  errno = ETIMEDOUT;\t/* Desperation time. */\n#endif\n  tidy_up_and_fail:\n    {\n\tdSAVE_ERRNO;\n\tif (listener != -1)\n\t    PerlLIO_close(listener);\n\tif (connector != -1)\n\t    PerlLIO_close(connector);\n\tif (acceptor != -1)\n\t    PerlLIO_close(acceptor);\n\tRESTORE_ERRNO;\n\treturn -1;\n    }\n}\n#else\n/* In any case have a stub so that there's code corresponding\n * to the my_socketpair in embed.fnc. */\nint\nPerl_my_socketpair (int family, int type, int protocol, int fd[2]) {\n#ifdef HAS_SOCKETPAIR\n    return socketpair(family, type, protocol, fd);\n#else\n    return -1;\n#endif\n}\n#endif\n\n/*\n\n=for apidoc sv_nosharing\n\nDummy routine which \"shares\" an SV when there is no sharing module present.\nOr \"locks\" it.  Or \"unlocks\" it.  In other\nwords, ignores its single SV argument.\nExists to avoid test for a C<NULL> function pointer and because it could\npotentially warn under some level of strict-ness.\n\n=cut\n*/\n\nvoid\nPerl_sv_nosharing(pTHX_ SV *sv)\n{\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n}\n\n/*\n\n=for apidoc sv_destroyable\n\nDummy routine which reports that object can be destroyed when there is no\nsharing module present.  It ignores its single SV argument, and returns\n'true'.  Exists to avoid test for a C<NULL> function pointer and because it\ncould potentially warn under some level of strict-ness.\n\n=cut\n*/\n\nbool\nPerl_sv_destroyable(pTHX_ SV *sv)\n{\n    PERL_UNUSED_CONTEXT;\n    PERL_UNUSED_ARG(sv);\n    return TRUE;\n}\n\nU32\nPerl_parse_unicode_opts(pTHX_ const char **popt)\n{\n  const char *p = *popt;\n  U32 opt = 0;\n\n  PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS;\n\n  if (*p) {\n       if (isDIGIT(*p)) {\n            const char* endptr = p + strlen(p);\n            UV uv;\n            if (grok_atoUV(p, &uv, &endptr) && uv <= U32_MAX) {\n                opt = (U32)uv;\n                p = endptr;\n                if (p && *p && *p != '\\n' && *p != '\\r') {\n                    if (isSPACE(*p))\n                        goto the_end_of_the_opts_parser;\n                    else\n                        Perl_croak(aTHX_ \"Unknown Unicode option letter '%c'\", *p);\n                }\n            }\n            else {\n                Perl_croak(aTHX_ \"Invalid number '%s' for -C option.\\n\", p);\n            }\n        }\n        else {\n\t    for (; *p; p++) {\n\t\t switch (*p) {\n\t\t case PERL_UNICODE_STDIN:\n\t\t      opt |= PERL_UNICODE_STDIN_FLAG;\tbreak;\n\t\t case PERL_UNICODE_STDOUT:\n\t\t      opt |= PERL_UNICODE_STDOUT_FLAG;\tbreak;\n\t\t case PERL_UNICODE_STDERR:\n\t\t      opt |= PERL_UNICODE_STDERR_FLAG;\tbreak;\n\t\t case PERL_UNICODE_STD:\n\t\t      opt |= PERL_UNICODE_STD_FLAG;    \tbreak;\n\t\t case PERL_UNICODE_IN:\n\t\t      opt |= PERL_UNICODE_IN_FLAG;\tbreak;\n\t\t case PERL_UNICODE_OUT:\n\t\t      opt |= PERL_UNICODE_OUT_FLAG;\tbreak;\n\t\t case PERL_UNICODE_INOUT:\n\t\t      opt |= PERL_UNICODE_INOUT_FLAG;\tbreak;\n\t\t case PERL_UNICODE_LOCALE:\n\t\t      opt |= PERL_UNICODE_LOCALE_FLAG;\tbreak;\n\t\t case PERL_UNICODE_ARGV:\n\t\t      opt |= PERL_UNICODE_ARGV_FLAG;\tbreak;\n\t\t case PERL_UNICODE_UTF8CACHEASSERT:\n\t\t      opt |= PERL_UNICODE_UTF8CACHEASSERT_FLAG; break;\n\t\t default:\n\t\t      if (*p != '\\n' && *p != '\\r') {\n\t\t\tif(isSPACE(*p)) goto the_end_of_the_opts_parser;\n\t\t\telse\n\t\t\t  Perl_croak(aTHX_\n\t\t\t\t     \"Unknown Unicode option letter '%c'\", *p);\n\t\t      }\n\t\t }\n\t    }\n       }\n  }\n  else\n       opt = PERL_UNICODE_DEFAULT_FLAGS;\n\n  the_end_of_the_opts_parser:\n\n  if (opt & ~PERL_UNICODE_ALL_FLAGS)\n       Perl_croak(aTHX_ \"Unknown Unicode option value %\" UVuf,\n\t\t  (UV) (opt & ~PERL_UNICODE_ALL_FLAGS));\n\n  *popt = p;\n\n  return opt;\n}\n\n#ifdef VMS\n#  include <starlet.h>\n#endif\n\nU32\nPerl_seed(pTHX)\n{\n    /*\n     * This is really just a quick hack which grabs various garbage\n     * values.  It really should be a real hash algorithm which\n     * spreads the effect of every input bit onto every output bit,\n     * if someone who knows about such things would bother to write it.\n     * Might be a good idea to add that function to CORE as well.\n     * No numbers below come from careful analysis or anything here,\n     * except they are primes and SEED_C1 > 1E6 to get a full-width\n     * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should\n     * probably be bigger too.\n     */\n#if RANDBITS > 16\n#  define SEED_C1\t1000003\n#define   SEED_C4\t73819\n#else\n#  define SEED_C1\t25747\n#define   SEED_C4\t20639\n#endif\n#define   SEED_C2\t3\n#define   SEED_C3\t269\n#define   SEED_C5\t26107\n\n#ifndef PERL_NO_DEV_RANDOM\n    int fd;\n#endif\n    U32 u;\n#ifdef HAS_GETTIMEOFDAY\n    struct timeval when;\n#else\n    Time_t when;\n#endif\n\n/* This test is an escape hatch, this symbol isn't set by Configure. */\n#ifndef PERL_NO_DEV_RANDOM\n#ifndef PERL_RANDOM_DEVICE\n   /* /dev/random isn't used by default because reads from it will block\n    * if there isn't enough entropy available.  You can compile with\n    * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there\n    * is enough real entropy to fill the seed. */\n#  ifdef __amigaos4__\n#    define PERL_RANDOM_DEVICE \"RANDOM:SIZE=4\"\n#  else\n#    define PERL_RANDOM_DEVICE \"/dev/urandom\"\n#  endif\n#endif\n    fd = PerlLIO_open_cloexec(PERL_RANDOM_DEVICE, 0);\n    if (fd != -1) {\n    \tif (PerlLIO_read(fd, (void*)&u, sizeof u) != sizeof u)\n\t    u = 0;\n\tPerlLIO_close(fd);\n\tif (u)\n\t    return u;\n    }\n#endif\n\n#ifdef HAS_GETTIMEOFDAY\n    PerlProc_gettimeofday(&when,NULL);\n    u = (U32)SEED_C1 * when.tv_sec + (U32)SEED_C2 * when.tv_usec;\n#else\n    (void)time(&when);\n    u = (U32)SEED_C1 * when;\n#endif\n    u += SEED_C3 * (U32)PerlProc_getpid();\n    u += SEED_C4 * (U32)PTR2UV(PL_stack_sp);\n#ifndef PLAN9           /* XXX Plan9 assembler chokes on this; fix needed  */\n    u += SEED_C5 * (U32)PTR2UV(&when);\n#endif\n    return u;\n}\n\nvoid\nPerl_get_hash_seed(pTHX_ unsigned char * const seed_buffer)\n{\n#ifndef NO_PERL_HASH_ENV\n    const char *env_pv;\n#endif\n    unsigned long i;\n\n    PERL_ARGS_ASSERT_GET_HASH_SEED;\n\n#ifndef NO_PERL_HASH_ENV\n    env_pv= PerlEnv_getenv(\"PERL_HASH_SEED\");\n\n    if ( env_pv )\n    {\n        /* ignore leading spaces */\n        while (isSPACE(*env_pv))\n            env_pv++;\n#    ifdef USE_PERL_PERTURB_KEYS\n        /* if they set it to \"0\" we disable key traversal randomization completely */\n        if (strEQ(env_pv,\"0\")) {\n            PL_hash_rand_bits_enabled= 0;\n        } else {\n            /* otherwise switch to deterministic mode */\n            PL_hash_rand_bits_enabled= 2;\n        }\n#    endif\n        /* ignore a leading 0x... if it is there */\n        if (env_pv[0] == '0' && env_pv[1] == 'x')\n            env_pv += 2;\n\n        for( i = 0; isXDIGIT(*env_pv) && i < PERL_HASH_SEED_BYTES; i++ ) {\n            seed_buffer[i] = READ_XDIGIT(env_pv) << 4;\n            if ( isXDIGIT(*env_pv)) {\n                seed_buffer[i] |= READ_XDIGIT(env_pv);\n            }\n        }\n        while (isSPACE(*env_pv))\n            env_pv++;\n\n        if (*env_pv && !isXDIGIT(*env_pv)) {\n            Perl_warn(aTHX_ \"perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set\\n\");\n        }\n        /* should we check for unparsed crap? */\n        /* should we warn about unused hex? */\n        /* should we warn about insufficient hex? */\n    }\n    else\n#endif /* NO_PERL_HASH_ENV */\n    {\n        for( i = 0; i < PERL_HASH_SEED_BYTES; i++ ) {\n            seed_buffer[i] = (unsigned char)(Perl_internal_drand48() * (U8_MAX+1));\n        }\n    }\n#ifdef USE_PERL_PERTURB_KEYS\n    {   /* initialize PL_hash_rand_bits from the hash seed.\n         * This value is highly volatile, it is updated every\n         * hash insert, and is used as part of hash bucket chain\n         * randomization and hash iterator randomization. */\n        PL_hash_rand_bits= 0xbe49d17f; /* I just picked a number */\n        for( i = 0; i < sizeof(UV) ; i++ ) {\n            PL_hash_rand_bits += seed_buffer[i % PERL_HASH_SEED_BYTES];\n            PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,8);\n        }\n    }\n#  ifndef NO_PERL_HASH_ENV\n    env_pv= PerlEnv_getenv(\"PERL_PERTURB_KEYS\");\n    if (env_pv) {\n        if (strEQ(env_pv,\"0\") || strEQ(env_pv,\"NO\")) {\n            PL_hash_rand_bits_enabled= 0;\n        } else if (strEQ(env_pv,\"1\") || strEQ(env_pv,\"RANDOM\")) {\n            PL_hash_rand_bits_enabled= 1;\n        } else if (strEQ(env_pv,\"2\") || strEQ(env_pv,\"DETERMINISTIC\")) {\n            PL_hash_rand_bits_enabled= 2;\n        } else {\n            Perl_warn(aTHX_ \"perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'\\n\", env_pv);\n        }\n    }\n#  endif\n#endif\n}\n\n#ifdef PERL_GLOBAL_STRUCT\n\n#define PERL_GLOBAL_STRUCT_INIT\n#include \"opcode.h\" /* the ppaddr and check */\n\nstruct perl_vars *\nPerl_init_global_struct(pTHX)\n{\n    struct perl_vars *plvarsp = NULL;\n# ifdef PERL_GLOBAL_STRUCT\n    const IV nppaddr = C_ARRAY_LENGTH(Gppaddr);\n    const IV ncheck  = C_ARRAY_LENGTH(Gcheck);\n    PERL_UNUSED_CONTEXT;\n#  ifdef PERL_GLOBAL_STRUCT_PRIVATE\n    /* PerlMem_malloc() because can't use even safesysmalloc() this early. */\n    plvarsp = (struct perl_vars*)PerlMem_malloc(sizeof(struct perl_vars));\n    if (!plvarsp)\n        exit(1);\n#  else\n    plvarsp = PL_VarsPtr;\n#  endif /* PERL_GLOBAL_STRUCT_PRIVATE */\n#  undef PERLVAR\n#  undef PERLVARA\n#  undef PERLVARI\n#  undef PERLVARIC\n#  define PERLVAR(prefix,var,type) /**/\n#  define PERLVARA(prefix,var,n,type) /**/\n#  define PERLVARI(prefix,var,type,init) plvarsp->prefix##var = init;\n#  define PERLVARIC(prefix,var,type,init) plvarsp->prefix##var = init;\n#  include \"perlvars.h\"\n#  undef PERLVAR\n#  undef PERLVARA\n#  undef PERLVARI\n#  undef PERLVARIC\n#  ifdef PERL_GLOBAL_STRUCT\n    plvarsp->Gppaddr =\n\t(Perl_ppaddr_t*)\n\tPerlMem_malloc(nppaddr * sizeof(Perl_ppaddr_t));\n    if (!plvarsp->Gppaddr)\n        exit(1);\n    plvarsp->Gcheck  =\n\t(Perl_check_t*)\n\tPerlMem_malloc(ncheck  * sizeof(Perl_check_t));\n    if (!plvarsp->Gcheck)\n        exit(1);\n    Copy(Gppaddr, plvarsp->Gppaddr, nppaddr, Perl_ppaddr_t); \n    Copy(Gcheck,  plvarsp->Gcheck,  ncheck,  Perl_check_t); \n#  endif\n#  ifdef PERL_SET_VARS\n    PERL_SET_VARS(plvarsp);\n#  endif\n#  ifdef PERL_GLOBAL_STRUCT_PRIVATE\n    plvarsp->Gsv_placeholder.sv_flags = 0;\n    memset(plvarsp->Ghash_seed, 0, sizeof(plvarsp->Ghash_seed));\n#  endif\n# undef PERL_GLOBAL_STRUCT_INIT\n# endif\n    return plvarsp;\n}\n\n#endif /* PERL_GLOBAL_STRUCT */\n\n#ifdef PERL_GLOBAL_STRUCT\n\nvoid\nPerl_free_global_struct(pTHX_ struct perl_vars *plvarsp)\n{\n    int veto = plvarsp->Gveto_cleanup;\n\n    PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT;\n    PERL_UNUSED_CONTEXT;\n# ifdef PERL_GLOBAL_STRUCT\n#  ifdef PERL_UNSET_VARS\n    PERL_UNSET_VARS(plvarsp);\n#  endif\n    if (veto)\n        return;\n    free(plvarsp->Gppaddr);\n    free(plvarsp->Gcheck);\n#  ifdef PERL_GLOBAL_STRUCT_PRIVATE\n    free(plvarsp);\n#  endif\n# endif\n}\n\n#endif /* PERL_GLOBAL_STRUCT */\n\n#ifdef PERL_MEM_LOG\n\n/* -DPERL_MEM_LOG: the Perl_mem_log_..() is compiled, including\n * the default implementation, unless -DPERL_MEM_LOG_NOIMPL is also\n * given, and you supply your own implementation.\n *\n * The default implementation reads a single env var, PERL_MEM_LOG,\n * expecting one or more of the following:\n *\n *    \\d+ - fd\t\tfd to write to\t\t: must be 1st (grok_atoUV)\n *    'm' - memlog\twas PERL_MEM_LOG=1\n *    's' - svlog\twas PERL_SV_LOG=1\n *    't' - timestamp\twas PERL_MEM_LOG_TIMESTAMP=1\n *\n * This makes the logger controllable enough that it can reasonably be\n * added to the system perl.\n */\n\n/* -DPERL_MEM_LOG_SPRINTF_BUF_SIZE=X: size of a (stack-allocated) buffer\n * the Perl_mem_log_...() will use (either via sprintf or snprintf).\n */\n#define PERL_MEM_LOG_SPRINTF_BUF_SIZE 128\n\n/* -DPERL_MEM_LOG_FD=N: the file descriptor the Perl_mem_log_...()\n * writes to.  In the default logger, this is settable at runtime.\n */\n#ifndef PERL_MEM_LOG_FD\n#  define PERL_MEM_LOG_FD 2 /* If STDERR is too boring for you. */\n#endif\n\n#ifndef PERL_MEM_LOG_NOIMPL\n\n# ifdef DEBUG_LEAKING_SCALARS\n#   define SV_LOG_SERIAL_FMT\t    \" [%lu]\"\n#   define _SV_LOG_SERIAL_ARG(sv)   , (unsigned long) (sv)->sv_debug_serial\n# else\n#   define SV_LOG_SERIAL_FMT\n#   define _SV_LOG_SERIAL_ARG(sv)\n# endif\n\nstatic void\nS_mem_log_common(enum mem_log_type mlt, const UV n, \n\t\t const UV typesize, const char *type_name, const SV *sv,\n\t\t Malloc_t oldalloc, Malloc_t newalloc,\n\t\t const char *filename, const int linenumber,\n\t\t const char *funcname)\n{\n    const char *pmlenv;\n\n    PERL_ARGS_ASSERT_MEM_LOG_COMMON;\n\n    pmlenv = PerlEnv_getenv(\"PERL_MEM_LOG\");\n    if (!pmlenv)\n\treturn;\n    if (mlt < MLT_NEW_SV ? strchr(pmlenv,'m') : strchr(pmlenv,'s'))\n    {\n\t/* We can't use SVs or PerlIO for obvious reasons,\n\t * so we'll use stdio and low-level IO instead. */\n\tchar buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];\n\n#   ifdef HAS_GETTIMEOFDAY\n#     define MEM_LOG_TIME_FMT\t\"%10d.%06d: \"\n#     define MEM_LOG_TIME_ARG\t(int)tv.tv_sec, (int)tv.tv_usec\n\tstruct timeval tv;\n\tgettimeofday(&tv, 0);\n#   else\n#     define MEM_LOG_TIME_FMT\t\"%10d: \"\n#     define MEM_LOG_TIME_ARG\t(int)when\n        Time_t when;\n        (void)time(&when);\n#   endif\n\t/* If there are other OS specific ways of hires time than\n\t * gettimeofday() (see dist/Time-HiRes), the easiest way is\n\t * probably that they would be used to fill in the struct\n\t * timeval. */\n\t{\n\t    STRLEN len;\n            const char* endptr = pmlenv + stren(pmlenv);\n\t    int fd;\n            UV uv;\n            if (grok_atoUV(pmlenv, &uv, &endptr) /* Ignore endptr. */\n                && uv && uv <= PERL_INT_MAX\n            ) {\n                fd = (int)uv;\n            } else {\n\t\tfd = PERL_MEM_LOG_FD;\n            }\n\n\t    if (strchr(pmlenv, 't')) {\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\tMEM_LOG_TIME_FMT, MEM_LOG_TIME_ARG);\n\t\tPERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));\n\t    }\n\t    switch (mlt) {\n\t    case MLT_ALLOC:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"alloc: %s:%d:%s: %\" IVdf \" %\" UVuf\n\t\t\t\" %s = %\" IVdf \": %\" UVxf \"\\n\",\n\t\t\tfilename, linenumber, funcname, n, typesize,\n\t\t\ttype_name, n * typesize, PTR2UV(newalloc));\n\t\tbreak;\n\t    case MLT_REALLOC:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"realloc: %s:%d:%s: %\" IVdf \" %\" UVuf\n\t\t\t\" %s = %\" IVdf \": %\" UVxf \" -> %\" UVxf \"\\n\",\n\t\t\tfilename, linenumber, funcname, n, typesize,\n\t\t\ttype_name, n * typesize, PTR2UV(oldalloc),\n\t\t\tPTR2UV(newalloc));\n\t\tbreak;\n\t    case MLT_FREE:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"free: %s:%d:%s: %\" UVxf \"\\n\",\n\t\t\tfilename, linenumber, funcname,\n\t\t\tPTR2UV(oldalloc));\n\t\tbreak;\n\t    case MLT_NEW_SV:\n\t    case MLT_DEL_SV:\n\t\tlen = my_snprintf(buf, sizeof(buf),\n\t\t\t\"%s_SV: %s:%d:%s: %\" UVxf SV_LOG_SERIAL_FMT \"\\n\",\n\t\t\tmlt == MLT_NEW_SV ? \"new\" : \"del\",\n\t\t\tfilename, linenumber, funcname,\n\t\t\tPTR2UV(sv) _SV_LOG_SERIAL_ARG(sv));\n\t\tbreak;\n\t    default:\n\t\tlen = 0;\n\t    }\n\t    PERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));\n\t}\n    }\n}\n#endif /* !PERL_MEM_LOG_NOIMPL */\n\n#ifndef PERL_MEM_LOG_NOIMPL\n# define \\\n    mem_log_common_if(alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm) \\\n    mem_log_common   (alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm)\n#else\n/* this is suboptimal, but bug compatible.  User is providing their\n   own implementation, but is getting these functions anyway, and they\n   do nothing. But _NOIMPL users should be able to cope or fix */\n# define \\\n    mem_log_common_if(alty, num, tysz, tynm, u, oal, nal, flnm, ln, fnnm) \\\n    /* mem_log_common_if_PERL_MEM_LOG_NOIMPL */\n#endif\n\nMalloc_t\nPerl_mem_log_alloc(const UV n, const UV typesize, const char *type_name,\n\t\t   Malloc_t newalloc, \n\t\t   const char *filename, const int linenumber,\n\t\t   const char *funcname)\n{\n    PERL_ARGS_ASSERT_MEM_LOG_ALLOC;\n\n    mem_log_common_if(MLT_ALLOC, n, typesize, type_name,\n\t\t      NULL, NULL, newalloc,\n\t\t      filename, linenumber, funcname);\n    return newalloc;\n}\n\nMalloc_t\nPerl_mem_log_realloc(const UV n, const UV typesize, const char *type_name,\n\t\t     Malloc_t oldalloc, Malloc_t newalloc, \n\t\t     const char *filename, const int linenumber, \n\t\t     const char *funcname)\n{\n    PERL_ARGS_ASSERT_MEM_LOG_REALLOC;\n\n    mem_log_common_if(MLT_REALLOC, n, typesize, type_name,\n\t\t      NULL, oldalloc, newalloc, \n\t\t      filename, linenumber, funcname);\n    return newalloc;\n}\n\nMalloc_t\nPerl_mem_log_free(Malloc_t oldalloc, \n\t\t  const char *filename, const int linenumber, \n\t\t  const char *funcname)\n{\n    PERL_ARGS_ASSERT_MEM_LOG_FREE;\n\n    mem_log_common_if(MLT_FREE, 0, 0, \"\", NULL, oldalloc, NULL, \n\t\t      filename, linenumber, funcname);\n    return oldalloc;\n}\n\nvoid\nPerl_mem_log_new_sv(const SV *sv, \n\t\t    const char *filename, const int linenumber,\n\t\t    const char *funcname)\n{\n    mem_log_common_if(MLT_NEW_SV, 0, 0, \"\", sv, NULL, NULL,\n\t\t      filename, linenumber, funcname);\n}\n\nvoid\nPerl_mem_log_del_sv(const SV *sv,\n\t\t    const char *filename, const int linenumber, \n\t\t    const char *funcname)\n{\n    mem_log_common_if(MLT_DEL_SV, 0, 0, \"\", sv, NULL, NULL, \n\t\t      filename, linenumber, funcname);\n}\n\n#endif /* PERL_MEM_LOG */\n\n/*\n=for apidoc quadmath_format_single\n\nC<quadmath_snprintf()> is very strict about its C<format> string and will\nfail, returning -1, if the format is invalid.  It accepts exactly\none format spec.\n\nC<quadmath_format_single()> checks that the intended single spec looks\nsane: begins with C<%>, has only one C<%>, ends with C<[efgaEFGA]>,\nand has C<Q> before it.  This is not a full \"printf syntax check\",\njust the basics.\n\nReturns the format if it is valid, NULL if not.\n\nC<quadmath_format_single()> can and will actually patch in the missing\nC<Q>, if necessary.  In this case it will return the modified copy of\nthe format, B<which the caller will need to free.>\n\nSee also L</quadmath_format_needed>.\n\n=cut\n*/\n#ifdef USE_QUADMATH\nconst char*\nPerl_quadmath_format_single(const char* format)\n{\n    STRLEN len;\n\n    PERL_ARGS_ASSERT_QUADMATH_FORMAT_SINGLE;\n\n    if (format[0] != '%' || strchr(format + 1, '%'))\n        return NULL;\n    len = strlen(format);\n    /* minimum length three: %Qg */\n    if (len < 3 || strchr(\"efgaEFGA\", format[len - 1]) == NULL)\n        return NULL;\n    if (format[len - 2] != 'Q') {\n        char* fixed;\n        Newx(fixed, len + 1, char);\n        memcpy(fixed, format, len - 1);\n        fixed[len - 1] = 'Q';\n        fixed[len    ] = format[len - 1];\n        fixed[len + 1] = 0;\n        return (const char*)fixed;\n    }\n    return format;\n}\n#endif\n\n/*\n=for apidoc quadmath_format_needed\n\nC<quadmath_format_needed()> returns true if the C<format> string seems to\ncontain at least one non-Q-prefixed C<%[efgaEFGA]> format specifier,\nor returns false otherwise.\n\nThe format specifier detection is not complete printf-syntax detection,\nbut it should catch most common cases.\n\nIf true is returned, those arguments B<should> in theory be processed\nwith C<quadmath_snprintf()>, but in case there is more than one such\nformat specifier (see L</quadmath_format_single>), and if there is\nanything else beyond that one (even just a single byte), they\nB<cannot> be processed because C<quadmath_snprintf()> is very strict,\naccepting only one format spec, and nothing else.\nIn this case, the code should probably fail.\n\n=cut\n*/\n#ifdef USE_QUADMATH\nbool\nPerl_quadmath_format_needed(const char* format)\n{\n  const char *p = format;\n  const char *q;\n\n  PERL_ARGS_ASSERT_QUADMATH_FORMAT_NEEDED;\n\n  while ((q = strchr(p, '%'))) {\n    q++;\n    if (*q == '+') /* plus */\n      q++;\n    if (*q == '#') /* alt */\n      q++;\n    if (*q == '*') /* width */\n      q++;\n    else {\n      if (isDIGIT(*q)) {\n        while (isDIGIT(*q)) q++;\n      }\n    }\n    if (*q == '.' && (q[1] == '*' || isDIGIT(q[1]))) { /* prec */\n      q++;\n      if (*q == '*')\n        q++;\n      else\n        while (isDIGIT(*q)) q++;\n    }\n    if (strchr(\"efgaEFGA\", *q)) /* Would have needed 'Q' in front. */\n      return TRUE;\n    p = q + 1;\n  }\n  return FALSE;\n}\n#endif\n\n/*\n=for apidoc my_snprintf\n\nThe C library C<snprintf> functionality, if available and\nstandards-compliant (uses C<vsnprintf>, actually).  However, if the\nC<vsnprintf> is not available, will unfortunately use the unsafe\nC<vsprintf> which can overrun the buffer (there is an overrun check,\nbut that may be too late).  Consider using C<sv_vcatpvf> instead, or\ngetting C<vsnprintf>.\n\n=cut\n*/\nint\nPerl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)\n{\n    int retval = -1;\n    va_list ap;\n    PERL_ARGS_ASSERT_MY_SNPRINTF;\n#ifndef HAS_VSNPRINTF\n    PERL_UNUSED_VAR(len);\n#endif\n    va_start(ap, format);\n#ifdef USE_QUADMATH\n    {\n        const char* qfmt = quadmath_format_single(format);\n        bool quadmath_valid = FALSE;\n        if (qfmt) {\n            /* If the format looked promising, use it as quadmath. */\n            retval = quadmath_snprintf(buffer, len, qfmt, va_arg(ap, NV));\n            if (retval == -1) {\n                if (qfmt != format) {\n                    dTHX;\n                    SAVEFREEPV(qfmt);\n                }\n                Perl_croak_nocontext(\"panic: quadmath_snprintf failed, format \\\"%s\\\"\", qfmt);\n            }\n            quadmath_valid = TRUE;\n            if (qfmt != format)\n                Safefree(qfmt);\n            qfmt = NULL;\n        }\n        assert(qfmt == NULL);\n        /* quadmath_format_single() will return false for example for\n         * \"foo = %g\", or simply \"%g\".  We could handle the %g by\n         * using quadmath for the NV args.  More complex cases of\n         * course exist: \"foo = %g, bar = %g\", or \"foo=%Qg\" (otherwise\n         * quadmath-valid but has stuff in front).\n         *\n         * Handling the \"Q-less\" cases right would require walking\n         * through the va_list and rewriting the format, calling\n         * quadmath for the NVs, building a new va_list, and then\n         * letting vsnprintf/vsprintf to take care of the other\n         * arguments.  This may be doable.\n         *\n         * We do not attempt that now.  But for paranoia, we here try\n         * to detect some common (but not all) cases where the\n         * \"Q-less\" %[efgaEFGA] formats are present, and die if\n         * detected.  This doesn't fix the problem, but it stops the\n         * vsnprintf/vsprintf pulling doubles off the va_list when\n         * __float128 NVs should be pulled off instead.\n         *\n         * If quadmath_format_needed() returns false, we are reasonably\n         * certain that we can call vnsprintf() or vsprintf() safely. */\n        if (!quadmath_valid && quadmath_format_needed(format))\n          Perl_croak_nocontext(\"panic: quadmath_snprintf failed, format \\\"%s\\\"\", format);\n\n    }\n#endif\n    if (retval == -1)\n#ifdef HAS_VSNPRINTF\n        retval = vsnprintf(buffer, len, format, ap);\n#else\n        retval = vsprintf(buffer, format, ap);\n#endif\n    va_end(ap);\n    /* vsprintf() shows failure with < 0 */\n    if (retval < 0\n#ifdef HAS_VSNPRINTF\n    /* vsnprintf() shows failure with >= len */\n        ||\n        (len > 0 && (Size_t)retval >= len)\n#endif\n    )\n\tPerl_croak_nocontext(\"panic: my_snprintf buffer overflow\");\n    return retval;\n}\n\n/*\n=for apidoc my_vsnprintf\n\nThe C library C<vsnprintf> if available and standards-compliant.\nHowever, if if the C<vsnprintf> is not available, will unfortunately\nuse the unsafe C<vsprintf> which can overrun the buffer (there is an\noverrun check, but that may be too late).  Consider using\nC<sv_vcatpvf> instead, or getting C<vsnprintf>.\n\n=cut\n*/\nint\nPerl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap)\n{\n#ifdef USE_QUADMATH\n    PERL_UNUSED_ARG(buffer);\n    PERL_UNUSED_ARG(len);\n    PERL_UNUSED_ARG(format);\n    /* the cast is to avoid gcc -Wsizeof-array-argument complaining */\n    PERL_UNUSED_ARG((void*)ap);\n    Perl_croak_nocontext(\"panic: my_vsnprintf not available with quadmath\");\n    return 0;\n#else\n    int retval;\n#ifdef NEED_VA_COPY\n    va_list apc;\n\n    PERL_ARGS_ASSERT_MY_VSNPRINTF;\n    Perl_va_copy(ap, apc);\n# ifdef HAS_VSNPRINTF\n    retval = vsnprintf(buffer, len, format, apc);\n# else\n    PERL_UNUSED_ARG(len);\n    retval = vsprintf(buffer, format, apc);\n# endif\n    va_end(apc);\n#else\n# ifdef HAS_VSNPRINTF\n    retval = vsnprintf(buffer, len, format, ap);\n# else\n    PERL_UNUSED_ARG(len);\n    retval = vsprintf(buffer, format, ap);\n# endif\n#endif /* #ifdef NEED_VA_COPY */\n    /* vsprintf() shows failure with < 0 */\n    if (retval < 0\n#ifdef HAS_VSNPRINTF\n    /* vsnprintf() shows failure with >= len */\n        ||\n        (len > 0 && (Size_t)retval >= len)\n#endif\n    )\n\tPerl_croak_nocontext(\"panic: my_vsnprintf buffer overflow\");\n    return retval;\n#endif\n}\n\nvoid\nPerl_my_clearenv(pTHX)\n{\n    dVAR;\n#if ! defined(PERL_MICRO)\n#  if defined(PERL_IMPLICIT_SYS) || defined(WIN32)\n    PerlEnv_clearenv();\n#  else /* ! (PERL_IMPLICIT_SYS || WIN32) */\n#    if defined(USE_ENVIRON_ARRAY)\n#      if defined(USE_ITHREADS)\n    /* only the parent thread can clobber the process environment */\n    if (PL_curinterp == aTHX)\n#      endif /* USE_ITHREADS */\n    {\n#      if ! defined(PERL_USE_SAFE_PUTENV)\n    if ( !PL_use_safe_putenv) {\n      I32 i;\n      if (environ == PL_origenviron)\n        environ = (char**)safesysmalloc(sizeof(char*));\n      else\n        for (i = 0; environ[i]; i++)\n          (void)safesysfree(environ[i]);\n    }\n    environ[0] = NULL;\n#      else /* PERL_USE_SAFE_PUTENV */\n#        if defined(HAS_CLEARENV)\n    (void)clearenv();\n#        elif defined(HAS_UNSETENV)\n    int bsiz = 80; /* Most envvar names will be shorter than this. */\n    char *buf = (char*)safesysmalloc(bsiz);\n    while (*environ != NULL) {\n      char *e = strchr(*environ, '=');\n      int l = e ? e - *environ : (int)strlen(*environ);\n      if (bsiz < l + 1) {\n        (void)safesysfree(buf);\n        bsiz = l + 1; /* + 1 for the \\0. */\n        buf = (char*)safesysmalloc(bsiz);\n      } \n      memcpy(buf, *environ, l);\n      buf[l] = '\\0';\n      (void)unsetenv(buf);\n    }\n    (void)safesysfree(buf);\n#        else /* ! HAS_CLEARENV && ! HAS_UNSETENV */\n    /* Just null environ and accept the leakage. */\n    *environ = NULL;\n#        endif /* HAS_CLEARENV || HAS_UNSETENV */\n#      endif /* ! PERL_USE_SAFE_PUTENV */\n    }\n#    endif /* USE_ENVIRON_ARRAY */\n#  endif /* PERL_IMPLICIT_SYS || WIN32 */\n#endif /* PERL_MICRO */\n}\n\n#ifdef PERL_IMPLICIT_CONTEXT\n\n/* Implements the MY_CXT_INIT macro. The first time a module is loaded,\nthe global PL_my_cxt_index is incremented, and that value is assigned to\nthat module's static my_cxt_index (who's address is passed as an arg).\nThen, for each interpreter this function is called for, it makes sure a\nvoid* slot is available to hang the static data off, by allocating or\nextending the interpreter's PL_my_cxt_list array */\n\n#ifndef PERL_GLOBAL_STRUCT_PRIVATE\nvoid *\nPerl_my_cxt_init(pTHX_ int *index, size_t size)\n{\n    dVAR;\n    void *p;\n    PERL_ARGS_ASSERT_MY_CXT_INIT;\n    if (*index == -1) {\n\t/* this module hasn't been allocated an index yet */\n\tMUTEX_LOCK(&PL_my_ctx_mutex);\n\t*index = PL_my_cxt_index++;\n\tMUTEX_UNLOCK(&PL_my_ctx_mutex);\n    }\n    \n    /* make sure the array is big enough */\n    if (PL_my_cxt_size <= *index) {\n\tif (PL_my_cxt_size) {\n            IV new_size = PL_my_cxt_size;\n\t    while (new_size <= *index)\n\t\tnew_size *= 2;\n\t    Renew(PL_my_cxt_list, new_size, void *);\n            PL_my_cxt_size = new_size;\n\t}\n\telse {\n\t    PL_my_cxt_size = 16;\n\t    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);\n\t}\n    }\n    /* newSV() allocates one more than needed */\n    p = (void*)SvPVX(newSV(size-1));\n    PL_my_cxt_list[*index] = p;\n    Zero(p, size, char);\n    return p;\n}\n\n#else /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */\n\nint\nPerl_my_cxt_index(pTHX_ const char *my_cxt_key)\n{\n    dVAR;\n    int index;\n\n    PERL_ARGS_ASSERT_MY_CXT_INDEX;\n\n    for (index = 0; index < PL_my_cxt_index; index++) {\n\tconst char *key = PL_my_cxt_keys[index];\n\t/* try direct pointer compare first - there are chances to success,\n\t * and it's much faster.\n\t */\n\tif ((key == my_cxt_key) || strEQ(key, my_cxt_key))\n\t    return index;\n    }\n    return -1;\n}\n\nvoid *\nPerl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size)\n{\n    dVAR;\n    void *p;\n    int index;\n\n    PERL_ARGS_ASSERT_MY_CXT_INIT;\n\n    index = Perl_my_cxt_index(aTHX_ my_cxt_key);\n    if (index == -1) {\n\t/* this module hasn't been allocated an index yet */\n\tMUTEX_LOCK(&PL_my_ctx_mutex);\n\tindex = PL_my_cxt_index++;\n\tMUTEX_UNLOCK(&PL_my_ctx_mutex);\n    }\n\n    /* make sure the array is big enough */\n    if (PL_my_cxt_size <= index) {\n\tint old_size = PL_my_cxt_size;\n\tint i;\n\tif (PL_my_cxt_size) {\n            IV new_size = PL_my_cxt_size;\n\t    while (new_size <= index)\n\t\tnew_size *= 2;\n\t    Renew(PL_my_cxt_list, new_size, void *);\n\t    Renew(PL_my_cxt_keys, new_size, const char *);\n            PL_my_cxt_size = new_size;\n\t}\n\telse {\n\t    PL_my_cxt_size = 16;\n\t    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);\n\t    Newx(PL_my_cxt_keys, PL_my_cxt_size, const char *);\n\t}\n\tfor (i = old_size; i < PL_my_cxt_size; i++) {\n\t    PL_my_cxt_keys[i] = 0;\n\t    PL_my_cxt_list[i] = 0;\n\t}\n    }\n    PL_my_cxt_keys[index] = my_cxt_key;\n    /* newSV() allocates one more than needed */\n    p = (void*)SvPVX(newSV(size-1));\n    PL_my_cxt_list[index] = p;\n    Zero(p, size, char);\n    return p;\n}\n#endif /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */\n#endif /* PERL_IMPLICIT_CONTEXT */\n\n\n/* Perl_xs_handshake():\n   implement the various XS_*_BOOTCHECK macros, which are added to .c\n   files by ExtUtils::ParseXS, to check that the perl the module was built\n   with is binary compatible with the running perl.\n\n   usage:\n       Perl_xs_handshake(U32 key, void * v_my_perl, const char * file,\n            [U32 items, U32 ax], [char * api_version], [char * xs_version])\n\n   The meaning of the varargs is determined the U32 key arg (which is not\n   a format string). The fields of key are assembled by using HS_KEY().\n\n   Under PERL_IMPLICIT_CONTEX, the v_my_perl arg is of type\n   \"PerlInterpreter *\" and represents the callers context; otherwise it is\n   of type \"CV *\", and is the boot xsub's CV.\n\n   v_my_perl will catch where a threaded future perl526.dll calling IO.dll\n   for example, and IO.dll was linked with threaded perl524.dll, and both\n   perl526.dll and perl524.dll are in %PATH and the Win32 DLL loader\n   successfully can load IO.dll into the process but simultaneously it\n   loaded an interpreter of a different version into the process, and XS\n   code will naturally pass SV*s created by perl524.dll for perl526.dll to\n   use through perl526.dll's my_perl->Istack_base.\n\n   v_my_perl cannot be the first arg, since then 'key' will be out of\n   place in a threaded vs non-threaded mixup; and analyzing the key\n   number's bitfields won't reveal the problem, since it will be a valid\n   key (unthreaded perl) on interp side, but croak will report the XS mod's\n   key as gibberish (it is really a my_perl ptr) (threaded XS mod); or if\n   it's a threaded perl and an unthreaded XS module, threaded perl will\n   look at an uninit C stack or an uninit register to get 'key'\n   (remember that it assumes that the 1st arg is the interp cxt).\n\n   'file' is the source filename of the caller.\n*/\n\nI32\nPerl_xs_handshake(const U32 key, void * v_my_perl, const char * file, ...)\n{\n    va_list args;\n    U32 items, ax;\n    void * got;\n    void * need;\n#ifdef PERL_IMPLICIT_CONTEXT\n    dTHX;\n    tTHX xs_interp;\n#else\n    CV* cv;\n    SV *** xs_spp;\n#endif\n    PERL_ARGS_ASSERT_XS_HANDSHAKE;\n    va_start(args, file);\n\n    got = INT2PTR(void*, (UV)(key & HSm_KEY_MATCH));\n    need = (void *)(HS_KEY(FALSE, FALSE, \"\", \"\") & HSm_KEY_MATCH);\n    if (UNLIKELY(got != need))\n\tgoto bad_handshake;\n/* try to catch where a 2nd threaded perl interp DLL is loaded into a process\n   by a XS DLL compiled against the wrong interl DLL b/c of bad @INC, and the\n   2nd threaded perl interp DLL never initialized its TLS/PERL_SYS_INIT3 so\n   dTHX call from 2nd interp DLL can't return the my_perl that pp_entersub\n   passed to the XS DLL */\n#ifdef PERL_IMPLICIT_CONTEXT\n    xs_interp = (tTHX)v_my_perl;\n    got = xs_interp;\n    need = my_perl;\n#else\n/* try to catch where an unthreaded perl interp DLL (for ex. perl522.dll) is\n   loaded into a process by a XS DLL built by an unthreaded perl522.dll perl,\n   but the DynaLoder/Perl that started the process and loaded the XS DLL is\n   unthreaded perl524.dll, since unthreadeds don't pass my_perl (a unique *)\n   through pp_entersub, use a unique value (which is a pointer to PL_stack_sp's\n   location in the unthreaded perl binary) stored in CV * to figure out if this\n   Perl_xs_handshake was called by the same pp_entersub */\n    cv = (CV*)v_my_perl;\n    xs_spp = (SV***)CvHSCXT(cv);\n    got = xs_spp;\n    need = &PL_stack_sp;\n#endif\n    if(UNLIKELY(got != need)) {\n\tbad_handshake:/* recycle branch and string from above */\n\tif(got != (void *)HSf_NOCHK)\n\t    noperl_die(\"%s: loadable library and perl binaries are mismatched\"\n                       \" (got handshake key %p, needed %p)\\n\",\n\t\tfile, got, need);\n    }\n\n    if(key & HSf_SETXSUBFN) {     /* this might be called from a module bootstrap */\n\tSAVEPPTR(PL_xsubfilename);/* which was require'd from a XSUB BEGIN */\n\tPL_xsubfilename = file;   /* so the old name must be restored for\n\t\t\t\t     additional XSUBs to register themselves */\n\t/* XSUBs can't be perl lang/perl5db.pl debugged\n\tif (PERLDB_LINE_OR_SAVESRC)\n\t    (void)gv_fetchfile(file); */\n    }\n\n    if(key & HSf_POPMARK) {\n\tax = POPMARK;\n\t{   SV **mark = PL_stack_base + ax++;\n\t    {   dSP;\n\t\titems = (I32)(SP - MARK);\n\t    }\n\t}\n    } else {\n\titems = va_arg(args, U32);\n\tax = va_arg(args, U32);\n    }\n    {\n\tU32 apiverlen;\n\tassert(HS_GETAPIVERLEN(key) <= UCHAR_MAX);\n\tif((apiverlen = HS_GETAPIVERLEN(key))) {\n\t    char * api_p = va_arg(args, char*);\n\t    if(apiverlen != sizeof(\"v\" PERL_API_VERSION_STRING)-1\n\t\t|| memNE(api_p, \"v\" PERL_API_VERSION_STRING,\n\t\t\t sizeof(\"v\" PERL_API_VERSION_STRING)-1))\n\t\tPerl_croak_nocontext(\"Perl API version %s of %\" SVf \" does not match %s\",\n\t\t\t\t    api_p, SVfARG(PL_stack_base[ax + 0]),\n\t\t\t\t    \"v\" PERL_API_VERSION_STRING);\n\t}\n    }\n    {\n\tU32 xsverlen;\n\tassert(HS_GETXSVERLEN(key) <= UCHAR_MAX && HS_GETXSVERLEN(key) <= HS_APIVERLEN_MAX);\n\tif((xsverlen = HS_GETXSVERLEN(key)))\n\t    S_xs_version_bootcheck(aTHX_\n\t\titems, ax, va_arg(args, char*), xsverlen);\n    }\n    va_end(args);\n    return ax;\n}\n\n\nSTATIC void\nS_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p,\n\t\t\t  STRLEN xs_len)\n{\n    SV *sv;\n    const char *vn = NULL;\n    SV *const module = PL_stack_base[ax];\n\n    PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK;\n\n    if (items >= 2)\t /* version supplied as bootstrap arg */\n\tsv = PL_stack_base[ax + 1];\n    else {\n\t/* XXX GV_ADDWARN */\n\tvn = \"XS_VERSION\";\n\tsv = get_sv(Perl_form(aTHX_ \"%\" SVf \"::%s\", SVfARG(module), vn), 0);\n\tif (!sv || !SvOK(sv)) {\n\t    vn = \"VERSION\";\n\t    sv = get_sv(Perl_form(aTHX_ \"%\" SVf \"::%s\", SVfARG(module), vn), 0);\n\t}\n    }\n    if (sv) {\n\tSV *xssv = Perl_newSVpvn_flags(aTHX_ xs_p, xs_len, SVs_TEMP);\n\tSV *pmsv = sv_isobject(sv) && sv_derived_from(sv, \"version\")\n\t    ? sv : sv_2mortal(new_version(sv));\n\txssv = upg_version(xssv, 0);\n\tif ( vcmp(pmsv,xssv) ) {\n\t    SV *string = vstringify(xssv);\n\t    SV *xpt = Perl_newSVpvf(aTHX_ \"%\" SVf \" object version %\" SVf\n\t\t\t\t    \" does not match \", SVfARG(module), SVfARG(string));\n\n\t    SvREFCNT_dec(string);\n\t    string = vstringify(pmsv);\n\n\t    if (vn) {\n\t\tPerl_sv_catpvf(aTHX_ xpt, \"$%\" SVf \"::%s %\" SVf, SVfARG(module), vn,\n\t\t\t       SVfARG(string));\n\t    } else {\n\t\tPerl_sv_catpvf(aTHX_ xpt, \"bootstrap parameter %\" SVf, SVfARG(string));\n\t    }\n\t    SvREFCNT_dec(string);\n\n\t    Perl_sv_2mortal(aTHX_ xpt);\n\t    Perl_croak_sv(aTHX_ xpt);\n\t}\n    }\n}\n\n/*\n=for apidoc my_strlcat\n\nThe C library C<strlcat> if available, or a Perl implementation of it.\nThis operates on C C<NUL>-terminated strings.\n\nC<my_strlcat()> appends string C<src> to the end of C<dst>.  It will append at\nmost S<C<size - strlen(dst) - 1>> characters.  It will then C<NUL>-terminate,\nunless C<size> is 0 or the original C<dst> string was longer than C<size> (in\npractice this should not happen as it means that either C<size> is incorrect or\nthat C<dst> is not a proper C<NUL>-terminated string).\n\nNote that C<size> is the full size of the destination buffer and\nthe result is guaranteed to be C<NUL>-terminated if there is room.  Note that\nroom for the C<NUL> should be included in C<size>.\n\nThe return value is the total length that C<dst> would have if C<size> is\nsufficiently large.  Thus it is the initial length of C<dst> plus the length of\nC<src>.  If C<size> is smaller than the return, the excess was not appended.\n\n=cut\n\nDescription stolen from http://man.openbsd.org/strlcat.3\n*/\n#ifndef HAS_STRLCAT\nSize_t\nPerl_my_strlcat(char *dst, const char *src, Size_t size)\n{\n    Size_t used, length, copy;\n\n    used = strlen(dst);\n    length = strlen(src);\n    if (size > 0 && used < size - 1) {\n        copy = (length >= size - used) ? size - used - 1 : length;\n        memcpy(dst + used, src, copy);\n        dst[used + copy] = '\\0';\n    }\n    return used + length;\n}\n#endif\n\n\n/*\n=for apidoc my_strlcpy\n\nThe C library C<strlcpy> if available, or a Perl implementation of it.\nThis operates on C C<NUL>-terminated strings.\n\nC<my_strlcpy()> copies up to S<C<size - 1>> characters from the string C<src>\nto C<dst>, C<NUL>-terminating the result if C<size> is not 0.\n\nThe return value is the total length C<src> would be if the copy completely\nsucceeded.  If it is larger than C<size>, the excess was not copied.\n\n=cut\n\nDescription stolen from http://man.openbsd.org/strlcpy.3\n*/\n#ifndef HAS_STRLCPY\nSize_t\nPerl_my_strlcpy(char *dst, const char *src, Size_t size)\n{\n    Size_t length, copy;\n\n    length = strlen(src);\n    if (size > 0) {\n        copy = (length >= size) ? size - 1 : length;\n        memcpy(dst, src, copy);\n        dst[copy] = '\\0';\n    }\n    return length;\n}\n#endif\n\n/*\n=for apidoc my_strnlen\n\nThe C library C<strnlen> if available, or a Perl implementation of it.\n\nC<my_strnlen()> computes the length of the string, up to C<maxlen>\ncharacters.  It will will never attempt to address more than C<maxlen>\ncharacters, making it suitable for use with strings that are not\nguaranteed to be NUL-terminated.\n\n=cut\n\nDescription stolen from http://man.openbsd.org/strnlen.3,\nimplementation stolen from PostgreSQL.\n*/\n#ifndef HAS_STRNLEN\nSize_t\nPerl_my_strnlen(const char *str, Size_t maxlen)\n{\n    const char *p = str;\n\n    PERL_ARGS_ASSERT_MY_STRNLEN;\n\n    while(maxlen-- && *p)\n        p++;\n\n    return p - str;\n}\n#endif\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1300) && (_MSC_VER < 1400) && (WINVER < 0x0500)\n/* VC7 or 7.1, building with pre-VC7 runtime libraries. */\nlong _ftol( double ); /* Defined by VC6 C libs. */\nlong _ftol2( double dblSource ) { return _ftol( dblSource ); }\n#endif\n\nPERL_STATIC_INLINE bool\nS_gv_has_usable_name(pTHX_ GV *gv)\n{\n    GV **gvp;\n    return GvSTASH(gv)\n\t&& HvENAME(GvSTASH(gv))\n\t&& (gvp = (GV **)hv_fetchhek(\n\t\t\tGvSTASH(gv), GvNAME_HEK(gv), 0\n\t   ))\n\t&& *gvp == gv;\n}\n\nvoid\nPerl_get_db_sub(pTHX_ SV **svp, CV *cv)\n{\n    SV * const dbsv = GvSVn(PL_DBsub);\n    const bool save_taint = TAINT_get;\n\n    /* When we are called from pp_goto (svp is null),\n     * we do not care about using dbsv to call CV;\n     * it's for informational purposes only.\n     */\n\n    PERL_ARGS_ASSERT_GET_DB_SUB;\n\n    TAINT_set(FALSE);\n    save_item(dbsv);\n    if (!PERLDB_SUB_NN) {\n\tGV *gv = CvGV(cv);\n\n\tif (!svp && !CvLEXICAL(cv)) {\n\t    gv_efullname3(dbsv, gv, NULL);\n\t}\n\telse if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED)) || CvLEXICAL(cv)\n\t     || strEQ(GvNAME(gv), \"END\")\n\t     || ( /* Could be imported, and old sub redefined. */\n\t\t (GvCV(gv) != cv || !S_gv_has_usable_name(aTHX_ gv))\n\t\t &&\n\t\t !( (SvTYPE(*svp) == SVt_PVGV)\n\t\t    && (GvCV((const GV *)*svp) == cv)\n\t\t    /* Use GV from the stack as a fallback. */\n\t\t    && S_gv_has_usable_name(aTHX_ gv = (GV *)*svp) \n\t\t  )\n\t\t)\n\t) {\n\t    /* GV is potentially non-unique, or contain different CV. */\n\t    SV * const tmp = newRV(MUTABLE_SV(cv));\n\t    sv_setsv(dbsv, tmp);\n\t    SvREFCNT_dec(tmp);\n\t}\n\telse {\n\t    sv_sethek(dbsv, HvENAME_HEK(GvSTASH(gv)));\n\t    sv_catpvs(dbsv, \"::\");\n\t    sv_cathek(dbsv, GvNAME_HEK(gv));\n\t}\n    }\n    else {\n\tconst int type = SvTYPE(dbsv);\n\tif (type < SVt_PVIV && type != SVt_IV)\n\t    sv_upgrade(dbsv, SVt_PVIV);\n\t(void)SvIOK_on(dbsv);\n\tSvIV_set(dbsv, PTR2IV(cv));\t/* Do it the quickest way  */\n    }\n    SvSETMAGIC(dbsv);\n    TAINT_IF(save_taint);\n#ifdef NO_TAINT_SUPPORT\n    PERL_UNUSED_VAR(save_taint);\n#endif\n}\n\nint\nPerl_my_dirfd(DIR * dir) {\n\n    /* Most dirfd implementations have problems when passed NULL. */\n    if(!dir)\n        return -1;\n#ifdef HAS_DIRFD\n    return dirfd(dir);\n#elif defined(HAS_DIR_DD_FD)\n    return dir->dd_fd;\n#else\n    Perl_croak_nocontext(PL_no_func, \"dirfd\");\n    NOT_REACHED; /* NOTREACHED */\n    return 0;\n#endif \n}\n\n#if !defined(HAS_MKOSTEMP) || !defined(HAS_MKSTEMP)\n\n#define TEMP_FILE_CH \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvxyz0123456789\"\n#define TEMP_FILE_CH_COUNT (sizeof(TEMP_FILE_CH)-1)\n\nstatic int\nS_my_mkostemp(char *templte, int flags) {\n    dTHX;\n    STRLEN len = strlen(templte);\n    int fd;\n    int attempts = 0;\n\n    if (len < 6 ||\n        templte[len-1] != 'X' || templte[len-2] != 'X' || templte[len-3] != 'X' ||\n        templte[len-4] != 'X' || templte[len-5] != 'X' || templte[len-6] != 'X') {\n        SETERRNO(EINVAL, LIB_INVARG);\n        return -1;\n    }\n\n    do {\n        int i;\n        for (i = 1; i <= 6; ++i) {\n            templte[len-i] = TEMP_FILE_CH[(int)(Perl_internal_drand48() * TEMP_FILE_CH_COUNT)];\n        }\n        fd = PerlLIO_open3(templte, O_RDWR | O_CREAT | O_EXCL | flags, 0600);\n    } while (fd == -1 && errno == EEXIST && ++attempts <= 100);\n\n    return fd;\n}\n\n#endif\n\n#ifndef HAS_MKOSTEMP\nint\nPerl_my_mkostemp(char *templte, int flags)\n{\n    PERL_ARGS_ASSERT_MY_MKOSTEMP;\n    return S_my_mkostemp(templte, flags);\n}\n#endif\n\n#ifndef HAS_MKSTEMP\nint\nPerl_my_mkstemp(char *templte)\n{\n    PERL_ARGS_ASSERT_MY_MKSTEMP;\n    return S_my_mkostemp(templte, 0);\n}\n#endif\n\nREGEXP *\nPerl_get_re_arg(pTHX_ SV *sv) {\n\n    if (sv) {\n        if (SvMAGICAL(sv))\n            mg_get(sv);\n        if (SvROK(sv))\n\t    sv = MUTABLE_SV(SvRV(sv));\n        if (SvTYPE(sv) == SVt_REGEXP)\n            return (REGEXP*) sv;\n    }\n \n    return NULL;\n}\n\n/*\n * This code is derived from drand48() implementation from FreeBSD,\n * found in lib/libc/gen/_rand48.c.\n *\n * The U64 implementation is original, based on the POSIX\n * specification for drand48().\n */\n\n/*\n* Copyright (c) 1993 Martin Birgmeier\n* All rights reserved.\n*\n* You may redistribute unmodified or modified versions of this source\n* code provided that the above copyright notice and this and the\n* following conditions are retained.\n*\n* This software is provided ``as is'', and comes with no warranties\n* of any kind. I shall in no event be liable for anything that happens\n* to anyone/anything when using this software.\n*/\n\n#define FREEBSD_DRAND48_SEED_0   (0x330e)\n\n#ifdef PERL_DRAND48_QUAD\n\n#define DRAND48_MULT UINT64_C(0x5deece66d)\n#define DRAND48_ADD  0xb\n#define DRAND48_MASK UINT64_C(0xffffffffffff)\n\n#else\n\n#define FREEBSD_DRAND48_SEED_1   (0xabcd)\n#define FREEBSD_DRAND48_SEED_2   (0x1234)\n#define FREEBSD_DRAND48_MULT_0   (0xe66d)\n#define FREEBSD_DRAND48_MULT_1   (0xdeec)\n#define FREEBSD_DRAND48_MULT_2   (0x0005)\n#define FREEBSD_DRAND48_ADD      (0x000b)\n\nconst unsigned short _rand48_mult[3] = {\n                FREEBSD_DRAND48_MULT_0,\n                FREEBSD_DRAND48_MULT_1,\n                FREEBSD_DRAND48_MULT_2\n};\nconst unsigned short _rand48_add = FREEBSD_DRAND48_ADD;\n\n#endif\n\nvoid\nPerl_drand48_init_r(perl_drand48_t *random_state, U32 seed)\n{\n    PERL_ARGS_ASSERT_DRAND48_INIT_R;\n\n#ifdef PERL_DRAND48_QUAD\n    *random_state = FREEBSD_DRAND48_SEED_0 + ((U64)seed << 16);\n#else\n    random_state->seed[0] = FREEBSD_DRAND48_SEED_0;\n    random_state->seed[1] = (U16) seed;\n    random_state->seed[2] = (U16) (seed >> 16);\n#endif\n}\n\ndouble\nPerl_drand48_r(perl_drand48_t *random_state)\n{\n    PERL_ARGS_ASSERT_DRAND48_R;\n\n#ifdef PERL_DRAND48_QUAD\n    *random_state = (*random_state * DRAND48_MULT + DRAND48_ADD)\n        & DRAND48_MASK;\n\n    return ldexp((double)*random_state, -48);\n#else\n    {\n    U32 accu;\n    U16 temp[2];\n\n    accu = (U32) _rand48_mult[0] * (U32) random_state->seed[0]\n         + (U32) _rand48_add;\n    temp[0] = (U16) accu;        /* lower 16 bits */\n    accu >>= sizeof(U16) * 8;\n    accu += (U32) _rand48_mult[0] * (U32) random_state->seed[1]\n          + (U32) _rand48_mult[1] * (U32) random_state->seed[0];\n    temp[1] = (U16) accu;        /* middle 16 bits */\n    accu >>= sizeof(U16) * 8;\n    accu += _rand48_mult[0] * random_state->seed[2]\n          + _rand48_mult[1] * random_state->seed[1]\n          + _rand48_mult[2] * random_state->seed[0];\n    random_state->seed[0] = temp[0];\n    random_state->seed[1] = temp[1];\n    random_state->seed[2] = (U16) accu;\n\n    return ldexp((double) random_state->seed[0], -48) +\n           ldexp((double) random_state->seed[1], -32) +\n           ldexp((double) random_state->seed[2], -16);\n    }\n#endif\n}\n\n#ifdef USE_C_BACKTRACE\n\n/* Possibly move all this USE_C_BACKTRACE code into a new file. */\n\n#ifdef USE_BFD\n\ntypedef struct {\n    /* abfd is the BFD handle. */\n    bfd* abfd;\n    /* bfd_syms is the BFD symbol table. */\n    asymbol** bfd_syms;\n    /* bfd_text is handle to the the \".text\" section of the object file. */\n    asection* bfd_text;\n    /* Since opening the executable and scanning its symbols is quite\n     * heavy operation, we remember the filename we used the last time,\n     * and do the opening and scanning only if the filename changes.\n     * This removes most (but not all) open+scan cycles. */\n    const char* fname_prev;\n} bfd_context;\n\n/* Given a dl_info, update the BFD context if necessary. */\nstatic void bfd_update(bfd_context* ctx, Dl_info* dl_info)\n{\n    /* BFD open and scan only if the filename changed. */\n    if (ctx->fname_prev == NULL ||\n        strNE(dl_info->dli_fname, ctx->fname_prev)) {\n        if (ctx->abfd) {\n            bfd_close(ctx->abfd);\n        }\n        ctx->abfd = bfd_openr(dl_info->dli_fname, 0);\n        if (ctx->abfd) {\n            if (bfd_check_format(ctx->abfd, bfd_object)) {\n                IV symbol_size = bfd_get_symtab_upper_bound(ctx->abfd);\n                if (symbol_size > 0) {\n                    Safefree(ctx->bfd_syms);\n                    Newx(ctx->bfd_syms, symbol_size, asymbol*);\n                    ctx->bfd_text =\n                        bfd_get_section_by_name(ctx->abfd, \".text\");\n                }\n                else\n                    ctx->abfd = NULL;\n            }\n            else\n                ctx->abfd = NULL;\n        }\n        ctx->fname_prev = dl_info->dli_fname;\n    }\n}\n\n/* Given a raw frame, try to symbolize it and store\n * symbol information (source file, line number) away. */\nstatic void bfd_symbolize(bfd_context* ctx,\n                          void* raw_frame,\n                          char** symbol_name,\n                          STRLEN* symbol_name_size,\n                          char** source_name,\n                          STRLEN* source_name_size,\n                          STRLEN* source_line)\n{\n    *symbol_name = NULL;\n    *symbol_name_size = 0;\n    if (ctx->abfd) {\n        IV offset = PTR2IV(raw_frame) - PTR2IV(ctx->bfd_text->vma);\n        if (offset > 0 &&\n            bfd_canonicalize_symtab(ctx->abfd, ctx->bfd_syms) > 0) {\n            const char *file;\n            const char *func;\n            unsigned int line = 0;\n            if (bfd_find_nearest_line(ctx->abfd, ctx->bfd_text,\n                                      ctx->bfd_syms, offset,\n                                      &file, &func, &line) &&\n                file && func && line > 0) {\n                /* Size and copy the source file, use only\n                 * the basename of the source file.\n                 *\n                 * NOTE: the basenames are fine for the\n                 * Perl source files, but may not always\n                 * be the best idea for XS files. */\n                const char *p, *b = NULL;\n                /* Look for the last slash. */\n                for (p = file; *p; p++) {\n                    if (*p == '/')\n                        b = p + 1;\n                }\n                if (b == NULL || *b == 0) {\n                    b = file;\n                }\n                *source_name_size = p - b + 1;\n                Newx(*source_name, *source_name_size + 1, char);\n                Copy(b, *source_name, *source_name_size + 1, char);\n\n                *symbol_name_size = strlen(func);\n                Newx(*symbol_name, *symbol_name_size + 1, char);\n                Copy(func, *symbol_name, *symbol_name_size + 1, char);\n\n                *source_line = line;\n            }\n        }\n    }\n}\n\n#endif /* #ifdef USE_BFD */\n\n#ifdef PERL_DARWIN\n\n/* OS X has no public API for for 'symbolicating' (Apple official term)\n * stack addresses to {function_name, source_file, line_number}.\n * Good news: there is command line utility atos(1) which does that.\n * Bad news 1: it's a command line utility.\n * Bad news 2: one needs to have the Developer Tools installed.\n * Bad news 3: in newer releases it needs to be run as 'xcrun atos'.\n *\n * To recap: we need to open a pipe for reading for a utility which\n * might not exist, or exists in different locations, and then parse\n * the output.  And since this is all for a low-level API, we cannot\n * use high-level stuff.  Thanks, Apple. */\n\ntypedef struct {\n    /* tool is set to the absolute pathname of the tool to use:\n     * xcrun or atos. */\n    const char* tool;\n    /* format is set to a printf format string used for building\n     * the external command to run. */\n    const char* format;\n    /* unavail is set if e.g. xcrun cannot be found, or something\n     * else happens that makes getting the backtrace dubious.  Note,\n     * however, that the context isn't persistent, the next call to\n     * get_c_backtrace() will start from scratch. */\n    bool unavail;\n    /* fname is the current object file name. */\n    const char* fname;\n    /* object_base_addr is the base address of the shared object. */\n    void* object_base_addr;\n} atos_context;\n\n/* Given |dl_info|, updates the context.  If the context has been\n * marked unavailable, return immediately.  If not but the tool has\n * not been set, set it to either \"xcrun atos\" or \"atos\" (also set the\n * format to use for creating commands for piping), or if neither is\n * unavailable (one needs the Developer Tools installed), mark the context\n * an unavailable.  Finally, update the filename (object name),\n * and its base address. */\n\nstatic void atos_update(atos_context* ctx,\n                        Dl_info* dl_info)\n{\n    if (ctx->unavail)\n        return;\n    if (ctx->tool == NULL) {\n        const char* tools[] = {\n            \"/usr/bin/xcrun\",\n            \"/usr/bin/atos\"\n        };\n        const char* formats[] = {\n            \"/usr/bin/xcrun atos -o '%s' -l %08x %08x 2>&1\",\n            \"/usr/bin/atos -d -o '%s' -l %08x %08x 2>&1\"\n        };\n        struct stat st;\n        UV i;\n        for (i = 0; i < C_ARRAY_LENGTH(tools); i++) {\n            if (stat(tools[i], &st) == 0 && S_ISREG(st.st_mode)) {\n                ctx->tool = tools[i];\n                ctx->format = formats[i];\n                break;\n            }\n        }\n        if (ctx->tool == NULL) {\n            ctx->unavail = TRUE;\n            return;\n        }\n    }\n    if (ctx->fname == NULL ||\n        strNE(dl_info->dli_fname, ctx->fname)) {\n        ctx->fname = dl_info->dli_fname;\n        ctx->object_base_addr = dl_info->dli_fbase;\n    }\n}\n\n/* Given an output buffer end |p| and its |start|, matches\n * for the atos output, extracting the source code location\n * and returning non-NULL if possible, returning NULL otherwise. */\nstatic const char* atos_parse(const char* p,\n                              const char* start,\n                              STRLEN* source_name_size,\n                              STRLEN* source_line) {\n    /* atos() output is something like:\n     * perl_parse (in miniperl) (perl.c:2314)\\n\\n\".\n     * We cannot use Perl regular expressions, because we need to\n     * stay low-level.  Therefore here we have a rolled-out version\n     * of a state machine which matches _backwards_from_the_end_ and\n     * if there's a success, returns the starts of the filename,\n     * also setting the filename size and the source line number.\n     * The matched regular expression is roughly \"\\(.*:\\d+\\)\\s*$\" */\n    const char* source_number_start;\n    const char* source_name_end;\n    const char* source_line_end = start;\n    const char* close_paren;\n    UV uv;\n\n    /* Skip trailing whitespace. */\n    while (p > start && isSPACE(*p)) p--;\n    /* Now we should be at the close paren. */\n    if (p == start || *p != ')')\n        return NULL;\n    close_paren = p;\n    p--;\n    /* Now we should be in the line number. */\n    if (p == start || !isDIGIT(*p))\n        return NULL;\n    /* Skip over the digits. */\n    while (p > start && isDIGIT(*p))\n        p--;\n    /* Now we should be at the colon. */\n    if (p == start || *p != ':')\n        return NULL;\n    source_number_start = p + 1;\n    source_name_end = p; /* Just beyond the end. */\n    p--;\n    /* Look for the open paren. */\n    while (p > start && *p != '(')\n        p--;\n    if (p == start)\n        return NULL;\n    p++;\n    *source_name_size = source_name_end - p;\n    if (grok_atoUV(source_number_start, &uv,  &source_line_end)\n        && source_line_end == close_paren\n        && uv <= PERL_INT_MAX\n    ) {\n        *source_line = (STRLEN)uv;\n        return p;\n    }\n    return NULL;\n}\n\n/* Given a raw frame, read a pipe from the symbolicator (that's the\n * technical term) atos, reads the result, and parses the source code\n * location.  We must stay low-level, so we use snprintf(), pipe(),\n * and fread(), and then also parse the output ourselves. */\nstatic void atos_symbolize(atos_context* ctx,\n                           void* raw_frame,\n                           char** source_name,\n                           STRLEN* source_name_size,\n                           STRLEN* source_line)\n{\n    char cmd[1024];\n    const char* p;\n    Size_t cnt;\n\n    if (ctx->unavail)\n        return;\n    /* Simple security measure: if there's any funny business with\n     * the object name (used as \"-o '%s'\" ), leave since at least\n     * partially the user controls it. */\n    for (p = ctx->fname; *p; p++) {\n        if (*p == '\\'' || isCNTRL(*p)) {\n            ctx->unavail = TRUE;\n            return;\n        }\n    }\n    cnt = snprintf(cmd, sizeof(cmd), ctx->format,\n                   ctx->fname, ctx->object_base_addr, raw_frame);\n    if (cnt < sizeof(cmd)) {\n        /* Undo nostdio.h #defines that disable stdio.\n         * This is somewhat naughty, but is used elsewhere\n         * in the core, and affects only OS X. */\n#undef FILE\n#undef popen\n#undef fread\n#undef pclose\n        FILE* fp = popen(cmd, \"r\");\n        /* At the moment we open a new pipe for each stack frame.\n         * This is naturally somewhat slow, but hopefully generating\n         * stack traces is never going to in a performance critical path.\n         *\n         * We could play tricks with atos by batching the stack\n         * addresses to be resolved: atos can either take multiple\n         * addresses from the command line, or read addresses from\n         * a file (though the mess of creating temporary files would\n         * probably negate much of any possible speedup).\n         *\n         * Normally there are only two objects present in the backtrace:\n         * perl itself, and the libdyld.dylib.  (Note that the object\n         * filenames contain the full pathname, so perl may not always\n         * be in the same place.)  Whenever the object in the\n         * backtrace changes, the base address also changes.\n         *\n         * The problem with batching the addresses, though, would be\n         * matching the results with the addresses: the parsing of\n         * the results is already painful enough with a single address. */\n        if (fp) {\n            char out[1024];\n            UV cnt = fread(out, 1, sizeof(out), fp);\n            if (cnt < sizeof(out)) {\n                const char* p = atos_parse(out + cnt - 1, out,\n                                           source_name_size,\n                                           source_line);\n                if (p) {\n                    Newx(*source_name,\n                         *source_name_size, char);\n                    Copy(p, *source_name,\n                         *source_name_size,  char);\n                }\n            }\n            pclose(fp);\n        }\n    }\n}\n\n#endif /* #ifdef PERL_DARWIN */\n\n/*\n=for apidoc get_c_backtrace\n\nCollects the backtrace (aka \"stacktrace\") into a single linear\nmalloced buffer, which the caller B<must> C<Perl_free_c_backtrace()>.\n\nScans the frames back by S<C<depth + skip>>, then drops the C<skip> innermost,\nreturning at most C<depth> frames.\n\n=cut\n*/\n\nPerl_c_backtrace*\nPerl_get_c_backtrace(pTHX_ int depth, int skip)\n{\n    /* Note that here we must stay as low-level as possible: Newx(),\n     * Copy(), Safefree(); since we may be called from anywhere,\n     * so we should avoid higher level constructs like SVs or AVs.\n     *\n     * Since we are using safesysmalloc() via Newx(), don't try\n     * getting backtrace() there, unless you like deep recursion. */\n\n    /* Currently only implemented with backtrace() and dladdr(),\n     * for other platforms NULL is returned. */\n\n#if defined(HAS_BACKTRACE) && defined(HAS_DLADDR)\n    /* backtrace() is available via <execinfo.h> in glibc and in most\n     * modern BSDs; dladdr() is available via <dlfcn.h>. */\n\n    /* We try fetching this many frames total, but then discard\n     * the |skip| first ones.  For the remaining ones we will try\n     * retrieving more information with dladdr(). */\n    int try_depth = skip +  depth;\n\n    /* The addresses (program counters) returned by backtrace(). */\n    void** raw_frames;\n\n    /* Retrieved with dladdr() from the addresses returned by backtrace(). */\n    Dl_info* dl_infos;\n\n    /* Sizes _including_ the terminating \\0 of the object name\n     * and symbol name strings. */\n    STRLEN* object_name_sizes;\n    STRLEN* symbol_name_sizes;\n\n#ifdef USE_BFD\n    /* The symbol names comes either from dli_sname,\n     * or if using BFD, they can come from BFD. */\n    char** symbol_names;\n#endif\n\n    /* The source code location information.  Dug out with e.g. BFD. */\n    char** source_names;\n    STRLEN* source_name_sizes;\n    STRLEN* source_lines;\n\n    Perl_c_backtrace* bt = NULL;  /* This is what will be returned. */\n    int got_depth; /* How many frames were returned from backtrace(). */\n    UV frame_count = 0; /* How many frames we return. */\n    UV total_bytes = 0; /* The size of the whole returned backtrace. */\n\n#ifdef USE_BFD\n    bfd_context bfd_ctx;\n#endif\n#ifdef PERL_DARWIN\n    atos_context atos_ctx;\n#endif\n\n    /* Here are probably possibilities for optimizing.  We could for\n     * example have a struct that contains most of these and then\n     * allocate |try_depth| of them, saving a bunch of malloc calls.\n     * Note, however, that |frames| could not be part of that struct\n     * because backtrace() will want an array of just them.  Also be\n     * careful about the name strings. */\n    Newx(raw_frames, try_depth, void*);\n    Newx(dl_infos, try_depth, Dl_info);\n    Newx(object_name_sizes, try_depth, STRLEN);\n    Newx(symbol_name_sizes, try_depth, STRLEN);\n    Newx(source_names, try_depth, char*);\n    Newx(source_name_sizes, try_depth, STRLEN);\n    Newx(source_lines, try_depth, STRLEN);\n#ifdef USE_BFD\n    Newx(symbol_names, try_depth, char*);\n#endif\n\n    /* Get the raw frames. */\n    got_depth = (int)backtrace(raw_frames, try_depth);\n\n    /* We use dladdr() instead of backtrace_symbols() because we want\n     * the full details instead of opaque strings.  This is useful for\n     * two reasons: () the details are needed for further symbolic\n     * digging, for example in OS X (2) by having the details we fully\n     * control the output, which in turn is useful when more platforms\n     * are added: we can keep out output \"portable\". */\n\n    /* We want a single linear allocation, which can then be freed\n     * with a single swoop.  We will do the usual trick of first\n     * walking over the structure and seeing how much we need to\n     * allocate, then allocating, and then walking over the structure\n     * the second time and populating it. */\n\n    /* First we must compute the total size of the buffer. */\n    total_bytes = sizeof(Perl_c_backtrace_header);\n    if (got_depth > skip) {\n        int i;\n#ifdef USE_BFD\n        bfd_init(); /* Is this safe to call multiple times? */\n        Zero(&bfd_ctx, 1, bfd_context);\n#endif\n#ifdef PERL_DARWIN\n        Zero(&atos_ctx, 1, atos_context);\n#endif\n        for (i = skip; i < try_depth; i++) {\n            Dl_info* dl_info = &dl_infos[i];\n\n            object_name_sizes[i] = 0;\n            source_names[i] = NULL;\n            source_name_sizes[i] = 0;\n            source_lines[i] = 0;\n\n            /* Yes, zero from dladdr() is failure. */\n            if (dladdr(raw_frames[i], dl_info)) {\n                total_bytes += sizeof(Perl_c_backtrace_frame);\n\n                object_name_sizes[i] =\n                    dl_info->dli_fname ? strlen(dl_info->dli_fname) : 0;\n                symbol_name_sizes[i] =\n                    dl_info->dli_sname ? strlen(dl_info->dli_sname) : 0;\n#ifdef USE_BFD\n                bfd_update(&bfd_ctx, dl_info);\n                bfd_symbolize(&bfd_ctx, raw_frames[i],\n                              &symbol_names[i],\n                              &symbol_name_sizes[i],\n                              &source_names[i],\n                              &source_name_sizes[i],\n                              &source_lines[i]);\n#endif\n#if PERL_DARWIN\n                atos_update(&atos_ctx, dl_info);\n                atos_symbolize(&atos_ctx,\n                               raw_frames[i],\n                               &source_names[i],\n                               &source_name_sizes[i],\n                               &source_lines[i]);\n#endif\n\n                /* Plus ones for the terminating \\0. */\n                total_bytes += object_name_sizes[i] + 1;\n                total_bytes += symbol_name_sizes[i] + 1;\n                total_bytes += source_name_sizes[i] + 1;\n\n                frame_count++;\n            } else {\n                break;\n            }\n        }\n#ifdef USE_BFD\n        Safefree(bfd_ctx.bfd_syms);\n#endif\n    }\n\n    /* Now we can allocate and populate the result buffer. */\n    Newxc(bt, total_bytes, char, Perl_c_backtrace);\n    Zero(bt, total_bytes, char);\n    bt->header.frame_count = frame_count;\n    bt->header.total_bytes = total_bytes;\n    if (frame_count > 0) {\n        Perl_c_backtrace_frame* frame = bt->frame_info;\n        char* name_base = (char *)(frame + frame_count);\n        char* name_curr = name_base; /* Outputting the name strings here. */\n        UV i;\n        for (i = skip; i < skip + frame_count; i++) {\n            Dl_info* dl_info = &dl_infos[i];\n\n            frame->addr = raw_frames[i];\n            frame->object_base_addr = dl_info->dli_fbase;\n            frame->symbol_addr = dl_info->dli_saddr;\n\n            /* Copies a string, including the \\0, and advances the name_curr.\n             * Also copies the start and the size to the frame. */\n#define PERL_C_BACKTRACE_STRCPY(frame, doffset, src, dsize, size) \\\n            if (size && src) \\\n                Copy(src, name_curr, size, char); \\\n            frame->doffset = name_curr - (char*)bt; \\\n            frame->dsize = size; \\\n            name_curr += size; \\\n            *name_curr++ = 0;\n\n            PERL_C_BACKTRACE_STRCPY(frame, object_name_offset,\n                                    dl_info->dli_fname,\n                                    object_name_size, object_name_sizes[i]);\n\n#ifdef USE_BFD\n            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,\n                                    symbol_names[i],\n                                    symbol_name_size, symbol_name_sizes[i]);\n            Safefree(symbol_names[i]);\n#else\n            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,\n                                    dl_info->dli_sname,\n                                    symbol_name_size, symbol_name_sizes[i]);\n#endif\n\n            PERL_C_BACKTRACE_STRCPY(frame, source_name_offset,\n                                    source_names[i],\n                                    source_name_size, source_name_sizes[i]);\n            Safefree(source_names[i]);\n\n#undef PERL_C_BACKTRACE_STRCPY\n\n            frame->source_line_number = source_lines[i];\n\n            frame++;\n        }\n        assert(total_bytes ==\n               (UV)(sizeof(Perl_c_backtrace_header) +\n                    frame_count * sizeof(Perl_c_backtrace_frame) +\n                    name_curr - name_base));\n    }\n#ifdef USE_BFD\n    Safefree(symbol_names);\n    if (bfd_ctx.abfd) {\n        bfd_close(bfd_ctx.abfd);\n    }\n#endif\n    Safefree(source_lines);\n    Safefree(source_name_sizes);\n    Safefree(source_names);\n    Safefree(symbol_name_sizes);\n    Safefree(object_name_sizes);\n    /* Assuming the strings returned by dladdr() are pointers\n     * to read-only static memory (the object file), so that\n     * they do not need freeing (and cannot be). */\n    Safefree(dl_infos);\n    Safefree(raw_frames);\n    return bt;\n#else\n    PERL_UNUSED_ARGV(depth);\n    PERL_UNUSED_ARGV(skip);\n    return NULL;\n#endif\n}\n\n/*\n=for apidoc free_c_backtrace\n\nDeallocates a backtrace received from get_c_bracktrace.\n\n=cut\n*/\n\n/*\n=for apidoc get_c_backtrace_dump\n\nReturns a SV containing a dump of C<depth> frames of the call stack, skipping\nthe C<skip> innermost ones.  C<depth> of 20 is usually enough.\n\nThe appended output looks like:\n\n...\n1   10e004812:0082   Perl_croak   util.c:1716    /usr/bin/perl\n2   10df8d6d2:1d72   perl_parse   perl.c:3975    /usr/bin/perl\n...\n\nThe fields are tab-separated.  The first column is the depth (zero\nbeing the innermost non-skipped frame).  In the hex:offset, the hex is\nwhere the program counter was in C<S_parse_body>, and the :offset (might\nbe missing) tells how much inside the C<S_parse_body> the program counter was.\n\nThe C<util.c:1716> is the source code file and line number.\n\nThe F</usr/bin/perl> is obvious (hopefully).\n\nUnknowns are C<\"-\">.  Unknowns can happen unfortunately quite easily:\nif the platform doesn't support retrieving the information;\nif the binary is missing the debug information;\nif the optimizer has transformed the code by for example inlining.\n\n=cut\n*/\n\nSV*\nPerl_get_c_backtrace_dump(pTHX_ int depth, int skip)\n{\n    Perl_c_backtrace* bt;\n\n    bt = get_c_backtrace(depth, skip + 1 /* Hide ourselves. */);\n    if (bt) {\n        Perl_c_backtrace_frame* frame;\n        SV* dsv = newSVpvs(\"\");\n        UV i;\n        for (i = 0, frame = bt->frame_info;\n             i < bt->header.frame_count; i++, frame++) {\n            Perl_sv_catpvf(aTHX_ dsv, \"%d\", (int)i);\n            Perl_sv_catpvf(aTHX_ dsv, \"\\t%p\", frame->addr ? frame->addr : \"-\");\n            /* Symbol (function) names might disappear without debug info.\n             *\n             * The source code location might disappear in case of the\n             * optimizer inlining or otherwise rearranging the code. */\n            if (frame->symbol_addr) {\n                Perl_sv_catpvf(aTHX_ dsv, \":%04x\",\n                               (int)\n                               ((char*)frame->addr - (char*)frame->symbol_addr));\n            }\n            Perl_sv_catpvf(aTHX_ dsv, \"\\t%s\",\n                           frame->symbol_name_size &&\n                           frame->symbol_name_offset ?\n                           (char*)bt + frame->symbol_name_offset : \"-\");\n            if (frame->source_name_size &&\n                frame->source_name_offset &&\n                frame->source_line_number) {\n                Perl_sv_catpvf(aTHX_ dsv, \"\\t%s:%\" UVuf,\n                               (char*)bt + frame->source_name_offset,\n                               (UV)frame->source_line_number);\n            } else {\n                Perl_sv_catpvf(aTHX_ dsv, \"\\t-\");\n            }\n            Perl_sv_catpvf(aTHX_ dsv, \"\\t%s\",\n                           frame->object_name_size &&\n                           frame->object_name_offset ?\n                           (char*)bt + frame->object_name_offset : \"-\");\n            /* The frame->object_base_addr is not output,\n             * but it is used for symbolizing/symbolicating. */\n            sv_catpvs(dsv, \"\\n\");\n        }\n\n        Perl_free_c_backtrace(bt);\n\n        return dsv;\n    }\n\n    return NULL;\n}\n\n/*\n=for apidoc dump_c_backtrace\n\nDumps the C backtrace to the given C<fp>.\n\nReturns true if a backtrace could be retrieved, false if not.\n\n=cut\n*/\n\nbool\nPerl_dump_c_backtrace(pTHX_ PerlIO* fp, int depth, int skip)\n{\n    SV* sv;\n\n    PERL_ARGS_ASSERT_DUMP_C_BACKTRACE;\n\n    sv = Perl_get_c_backtrace_dump(aTHX_ depth, skip);\n    if (sv) {\n        sv_2mortal(sv);\n        PerlIO_printf(fp, \"%s\", SvPV_nolen(sv));\n        return TRUE;\n    }\n    return FALSE;\n}\n\n#endif /* #ifdef USE_C_BACKTRACE */\n\n#ifdef PERL_TSA_ACTIVE\n\n/* pthread_mutex_t and perl_mutex are typedef equivalent\n * so casting the pointers is fine. */\n\nint perl_tsa_mutex_lock(perl_mutex* mutex)\n{\n    return pthread_mutex_lock((pthread_mutex_t *) mutex);\n}\n\nint perl_tsa_mutex_unlock(perl_mutex* mutex)\n{\n    return pthread_mutex_unlock((pthread_mutex_t *) mutex);\n}\n\nint perl_tsa_mutex_destroy(perl_mutex* mutex)\n{\n    return pthread_mutex_destroy((pthread_mutex_t *) mutex);\n}\n\n#endif\n\n\n#ifdef USE_DTRACE\n\n/* log a sub call or return */\n\nvoid\nPerl_dtrace_probe_call(pTHX_ CV *cv, bool is_call)\n{\n    const char *func;\n    const char *file;\n    const char *stash;\n    const COP  *start;\n    line_t      line;\n\n    PERL_ARGS_ASSERT_DTRACE_PROBE_CALL;\n\n    if (CvNAMED(cv)) {\n        HEK *hek = CvNAME_HEK(cv);\n        func = HEK_KEY(hek);\n    }\n    else {\n        GV  *gv = CvGV(cv);\n        func = GvENAME(gv);\n    }\n    start = (const COP *)CvSTART(cv);\n    file  = CopFILE(start);\n    line  = CopLINE(start);\n    stash = CopSTASHPV(start);\n\n    if (is_call) {\n        PERL_SUB_ENTRY(func, file, line, stash);\n    }\n    else {\n        PERL_SUB_RETURN(func, file, line, stash);\n    }\n}\n\n\n/* log a require file loading/loaded  */\n\nvoid\nPerl_dtrace_probe_load(pTHX_ const char *name, bool is_loading)\n{\n    PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD;\n\n    if (is_loading) {\n\tPERL_LOADING_FILE(name);\n    }\n    else {\n\tPERL_LOADED_FILE(name);\n    }\n}\n\n\n/* log an op execution */\n\nvoid\nPerl_dtrace_probe_op(pTHX_ const OP *op)\n{\n    PERL_ARGS_ASSERT_DTRACE_PROBE_OP;\n\n    PERL_OP_ENTRY(OP_NAME(op));\n}\n\n\n/* log a compile/run phase change */\n\nvoid\nPerl_dtrace_probe_phase(pTHX_ enum perl_phase phase)\n{\n    const char *ph_old = PL_phase_names[PL_phase];\n    const char *ph_new = PL_phase_names[phase];\n\n    PERL_PHASE_CHANGE(ph_new, ph_old);\n}\n\n#endif\n\n/*\n * ex: set ts=8 sts=4 sw=4 et:\n */\n"], "buggy_code_start_loc": [2064], "buggy_code_end_loc": [2198], "fixing_code_start_loc": [2064], "fixing_code_end_loc": [2228], "type": "CWE-190", "message": "Perl before 5.26.3 and 5.28.x before 5.28.1 has a buffer overflow via a crafted regular expression that triggers invalid write operations.", "other": {"cve": {"id": "CVE-2018-18311", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-07T21:29:00.407", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Perl before 5.26.3 and 5.28.x before 5.28.1 has a buffer overflow via a crafted regular expression that triggers invalid write operations."}, {"lang": "es", "value": "Perl, en versiones anteriores a la 5.26.3 y versiones 5.28.0.x anteriores a la 5.28.1, tiene un desbordamiento de b\u00fafer mediante una expresi\u00f3n regular manipulada que desencadena operaciones inv\u00e1lidas de escritura."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:perl:perl:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.26.3", "matchCriteriaId": "C0FEAD21-C9A0-40F3-8F2E-489750B07760"}, {"vulnerable": true, "criteria": "cpe:2.3:a:perl:perl:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.28.0", "versionEndExcluding": "5.28.1", "matchCriteriaId": "054E1C6A-1EC3-4877-839C-1C28FCEC501A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2EBD848-26BA-4EF6-81C8-83B6DFFC75DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snap_creator_framework:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F4754FB-E3EB-454A-AB1A-AE3835C5350C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapdriver:-:*:*:*:*:unix:*:*", "matchCriteriaId": "19F76A75-CFAE-4E1B-A845-E9E2E236C5DB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "2F87326E-0B56-4356-A889-73D026DB1D4B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "041F9200-4C01-4187-AE34-240E8277B54D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "4EB48767-F095-444F-9E05-D9AC345AB803"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5F6FA12B-504C-4DBF-A32E-0548557AA2ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.14.4", "matchCriteriaId": "09CDBB72-2A0D-4321-BA1F-4FB326A5646A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mcafee:web_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.7.2", "versionEndExcluding": "7.7.2.21", "matchCriteriaId": "A0F4117D-97ED-4DD8-843F-F4147342AAE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mcafee:web_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.8.2", "versionEndExcluding": "7.8.2.8", "matchCriteriaId": "70504EAB-FC1C-4E0B-859E-49BD13685E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mcafee:web_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.1.1", "matchCriteriaId": "9D943214-14D8-47BC-BCF4-76B78EE95028"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2019/Mar/49", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/106145", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1042181", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHBA-2019:0327", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0001", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0010", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0109", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1790", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1942", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2400", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1646730", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Perl/perl5/commit/34716e2a6ee2af96078d62b065b7785c001194be", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://kc.mcafee.com/corporate/index?page=content&id=SB10278", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00039.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RWQGEB543QN7SSBRKYJM6PSOC3RLYGSM/", "source": "cve@mitre.org", "tags": ["Product", "Release Notes"]}, {"url": "https://metacpan.org/changes/release/SHAY/perl-5.26.3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://metacpan.org/changes/release/SHAY/perl-5.28.1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://rt.perl.org/Ticket/Display.html?id=133204", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Mar/42", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201909-01", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20190221-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT209600", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3834-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3834-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4347", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujul2019-5072835.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/Perl/perl5/commit/34716e2a6ee2af96078d62b065b7785c001194be"}}