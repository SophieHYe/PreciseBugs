{"buggy_code": ["---@declare-global\n-- The global sync table is copied to the user layer every time the main and sim threads are\n-- synchronized on the sim beat (which is like a tick but happens even when the game is paused)\nSync = {}\n\n-- UnitData that has been synced. We keep a separate copy of this so when we change\n-- focus army we can resync the data.\nUnitData = {}\n\nSimUnitEnhancements = {}\n\nfunction ResetSyncTable()\n    Sync = {\n        -- A list of camera control operations that we'd like the user layer to perform.\n        CameraRequests = {},\n        Sounds = {},\n        Voice = {},\n        AIChat = {},\n\n        -- Table of army indices set to \"victory\" or \"defeat\".\n        -- It's the user layer's job to determine if any UI needs to be shown\n        -- for the focus army.\n        GameResult = {},\n\n        -- Player to player queries that can affect the Sim\n        PlayerQueries = {},\n        QueryResults = {},\n\n        -- Contain operation data when op is complete\n        OperationComplete = nil,\n\n        UnitData = {},\n        ReleaseIds = {},\n\n        -- contains the current score for each army\n        Score = {},\n        ScoreAccum = {},\n\n        Reclaim = {}\n    }\nend\n\nfunction AddUnitEnhancement(unit, enhancement, slot)\n    if not slot then return end\n    local id = unit.EntityId\n    SimUnitEnhancements[id] = SimUnitEnhancements[id] or {}\n    SimUnitEnhancements[id][slot] = enhancement\n    SyncUnitEnhancements()\nend\n\nfunction RemoveUnitEnhancement(unit, enhancement)\n    if not unit or unit.Dead then return end\n    local id = unit.EntityId\n    local slots = SimUnitEnhancements[id]\n    if not slots then return end\n    local key = nil\n    for k, v in slots do\n        if v == enhancement then\n            key = k\n            break\n        end\n    end\n\n    if not key then return end\n    SimUnitEnhancements[id][key] = nil\n    if table.empty(slots) then\n        SimUnitEnhancements[id] = nil\n    end\n    SyncUnitEnhancements()\nend\n\nfunction RemoveAllUnitEnhancements(unit)\n    local id = unit.EntityId\n    if not SimUnitEnhancements[id] then return end\n    SimUnitEnhancements[id] = nil\n    SyncUnitEnhancements()\nend\n\nfunction SyncUnitEnhancements()\n    import(\"/lua/enhancementcommon.lua\").SetEnhancementTable(SimUnitEnhancements)\n    local sync = {}\n\n    for id, slots in SimUnitEnhancements do\n        local unit = GetEntityById(id)\n        local me = GetFocusArmy()\n        if unit and (me == -1 or IsAlly(me, unit.Army)) then\n            sync[id] = slots\n        end\n    end\n\n    Sync.UserUnitEnhancements = sync\nend\n\nfunction DebugMoveCamera(x0,y0,x1,y1)\n    local Camera = import(\"/lua/simcamera.lua\").SimCamera\n    local cam = Camera(\"WorldCamera\")\n--    cam:ScaleMoveVelocity(0.02)\n    cam:MoveTo(Rect(x0,y0,x1,y1),5.0)\nend\n\nfunction SyncPlayableRect(rect)\n    local Camera = import(\"/lua/simcamera.lua\").SimCamera\n    local cam = Camera(\"WorldCamera\")\n    cam:SyncPlayableRect(rect)\nend\n\nfunction LockInput()\n    Sync.LockInput = true\nend\n\nfunction UnlockInput()\n    Sync.UnlockInput = true\nend\n\nfunction OnPostLoad()\n    local focus = GetFocusArmy()\n    for entityID, data in UnitData do\n        if data.OwnerArmy == focus or focus == -1 then\n            Sync.UnitData[entityID] = data.Data\n        end\n    end\n    Sync.IsSavedGame = true\nend\n\nfunction NoteFocusArmyChanged(new, old)\n    --LOG('NoteFocusArmyChanged(new=' .. repr(new) .. ', old=' .. repr(old) .. ')')\n    import(\"/lua/simping.lua\").OnArmyChange()\n    for entityID, data in UnitData do\n        if new == -1 or data.OwnerArmy == new then\n            Sync.UnitData[entityID] = data.Data\n        elseif old == -1 or data.OwnerArmy == old then\n            Sync.ReleaseIds[entityID] = true\n        else\n        end\n    end\n    SyncUnitEnhancements()\n    Sync.FocusArmyChanged = {new = new, old = old}\nend\n\nfunction FloatingEntityText(entityId, text)\n    if not entityId and text then\n        WARN('Trying to float entity text with no entityId or no text.')\n        return false\n    else\n        if GetEntityById(entityId).Army == GetFocusArmy() then\n            if not Sync.FloatingEntityText then Sync.FloatingEntityText = {} end\n            table.insert(Sync.FloatingEntityText, {entity = entityId, text = text})\n        end\n    end\nend\n\nfunction StartCountdown(entityId, duration)\n    cdDuration = duration or 5\n    if not entityId then\n        WARN('Trying to start countdown text with no entityId.')\n        return false\n    else\n        if GetEntityById(entityId).Army == GetFocusArmy() then\n            if not Sync.StartCountdown then Sync.StartCountdown = {} end\n            table.insert(Sync.StartCountdown, {entity = entityId, duration = cdDuration})\n        end\n    end\nend\n\nfunction CancelCountdown(entityId)\n    if not entityId then\n        WARN('Trying to Cancel Countdown text with no entityId.')\n        return false\n    else\n        if GetEntityById(entityId).Army == GetFocusArmy() then\n            if not Sync.CancelCountdown then Sync.CancelCountdown = {} end\n            table.insert(Sync.CancelCountdown, {entity = entityId})\n        end\n    end\nend\n\nfunction HighlightUIPanel(panel)\n    if not Sync.HighlightUIPanel then Sync.HighlightUIPanel = {} end\n    table.insert(Sync.HighlightUIPanel, panel)\nend\n\nfunction ChangeCameraZoom(newMult)\n    Sync.ChangeCameraZoom = newMult\nend\n\nfunction CreateCameraMarker(position)\n    return import(\"/lua/simcameramarkers.lua\").AddCameraMarker(position)\nend\n\nfunction EndDemo()\n    Sync.EndDemo = true\nend\n\nfunction PrintText(text, fontSize, fontColor, duration, location)\n    if not text and location then\n        WARN('Trying to print text with no string or no location.')\n        return false\n    else\n        if not Sync.PrintText then Sync.PrintText = {} end\n        table.insert(Sync.PrintText, {text = text, size = fontSize, color = fontColor, duration = duration, location = location})\n    end\nend\n\nfunction CreateDialogue(text, buttonText, position)\n    return import(\"/lua/simdialogue.lua\").Create(text, buttonText, position)\nend\n", "-- Copyright \u00a9 2005 Gas Powered Games, Inc.  All rights reserved.\n--\n-- General Sim scripts\n\n-- ==============================================================================\n-- Diplomacy\n-- ==============================================================================\n\nlocal CreateWreckage = import(\"/lua/wreckage.lua\").CreateWreckage\n\nlocal transferUnbuiltCategory = categories.EXPERIMENTAL + categories.TECH3 * categories.STRUCTURE * categories.ARTILLERY\nlocal transferUnitsCategory = categories.ALLUNITS - categories.INSIGNIFICANTUNIT\nlocal buildersCategory = categories.ALLUNITS - categories.CONSTRUCTION - categories.ENGINEER\n\nlocal sharedUnits = {}\n\n---@param owner number\nfunction KillSharedUnits(owner)\n    local sharedUnitOwner = sharedUnits[owner]\n    if sharedUnitOwner and not table.empty(sharedUnitOwner) then\n        for _, unit in sharedUnitOwner do\n            if not unit.Dead and unit.oldowner == owner then\n                unit:Kill()\n            end\n        end\n        sharedUnits[owner] = {}\n    end\nend\n\n-- used to make more expensive units transfer first, in case there's a unit cap issue\nlocal function TransferUnitsOwnershipComparator(a, b)\n    a = a.Blueprint or a.Blueprint\n    b = b.Blueprint or b.Blueprint\n    return a.Economy.BuildCostMass > b.Economy.BuildCostMass\nend\n\n--- Temporarily disables the weapons of gifted units\n---@param weapon Weapon\nlocal function TransferUnitsOwnershipDelayedWeapons(weapon)\n    if not weapon:BeenDestroyed() then\n        -- compute delay\n        local bp = weapon.Blueprint\n        local delay = 1 / bp.RateOfFire\n        WaitSeconds(delay)\n\n        -- enable the weapon again if it still exists\n        if not weapon:BeenDestroyed() then\n            weapon:SetEnabled(true)\n        end\n    end\nend\n\n--- Transfers units to an army, returning the new units (since changing the army\n--- replaces the units with new ones)\n---@param units Unit[]\n---@param toArmy number \n---@param captured boolean\n---@return Unit[]?\nfunction TransferUnitsOwnership(units, toArmy, captured)\n    local toBrain = GetArmyBrain(toArmy)\n    if not toBrain or toBrain:IsDefeated() or not units or table.empty(units) then\n        return\n    end\n    local categoriesENGINEERSTATION = categories.ENGINEERSTATION\n    local shareUpgrades = ScenarioInfo.Options.Share == 'FullShare'\n\n    -- do not gift insignificant units\n    units = EntityCategoryFilterDown(transferUnitsCategory, units)\n\n    -- gift most valuable units first\n    table.sort(units, TransferUnitsOwnershipComparator)\n\n    local newUnitCount = 0\n    local newUnits = {}\n    local upgradeUnitCount = 0\n    local upgradeUnits = {}\n    local pauseKennelCount = 0\n    local pauseKennels = {}\n    local upgradeKennelCount = 0\n    local upgradeKennels = {}\n\n    for _, unit in units do\n        local owner = unit.Army\n        -- Only allow units not attached to be given. This is because units will give all of its\n        -- children over as well, so we only want the top level units to be given.\n        -- Units currently being captured are also denied\n        if  owner == toArmy or\n            unit:GetParent() ~= unit or (unit.Parent and unit.Parent ~= unit) or\n            unit.CaptureProgress > 0 or\n            unit:GetFractionComplete() < 1.0\n        then\n            continue\n        end\n\n        local bp = unit.Blueprint\n        local bpPhysics = bp.Physics\n        local categoriesHash = bp.CategoriesHash\n\n        -- B E F O R E\n        local numNukes = unit:GetNukeSiloAmmoCount() -- nuclear missiles; SML or SMD\n        local numTacMsl = unit:GetTacticalSiloAmmoCount()\n        local unitSync = unit.Sync\n        local massKilled = unitSync.totalMassKilled\n        local massKilledTrue = unitSync.totalMassKilledTrue\n        local unitHealth = unit:GetHealth()\n        local shieldIsOn = false\n        local shieldHealth = 0\n        local hasFuel = false\n        local fuelRatio = 0\n        local activeEnhancements\n        local oldowner = unit.oldowner\n        local upgradesTo = unit.UpgradesTo\n        local defaultBuildRate\n        local upgradeBuildTimeComplete\n        local exclude\n\n        local shield = unit.MyShield\n        if shield then\n            shieldIsOn = unit:ShieldIsOn()\n            shieldHealth = shield:GetHealth()\n        end\n        local fuelUseTime = bpPhysics.FuelUseTime\n        if fuelUseTime and fuelUseTime > 0 then   -- going through the BP to check for fuel\n            fuelRatio = unit:GetFuelRatio()       -- usage is more reliable then unit.HasFuel\n            hasFuel = true                        -- cause some buildings say they use fuel\n        end\n        local enhancements = bp.Enhancements\n        if enhancements then\n            local unitEnh = SimUnitEnhancements[unit.EntityId]\n            if unitEnh then\n                activeEnhancements = {}\n                for i, enh in unitEnh do\n                    activeEnhancements[i] = enh\n                end\n                if not activeEnhancements[1] then\n                    activeEnhancements = nil\n                end\n            end\n        end\n\n        if categoriesHash.ENGINEERSTATION and categoriesHash.UEF then\n            -- We have to kill drones which are idling inside Kennel at the moment of transfer\n            -- otherwise additional dummy drone will appear after transfer\n            for _, drone in unit:GetCargo() do\n                drone:Destroy()\n            end\n        end\n\n        if unit.TransferUpgradeProgress and shareUpgrades then\n            local progress = unit:GetWorkProgress()\n            local upgradeBuildTime = unit.UpgradeBuildTime\n\n            defaultBuildRate = unit:GetBuildRate()\n\n            if progress > 0.05 then --5%. EcoManager & auto-paused mexes etc.\n                upgradeBuildTimeComplete = upgradeBuildTime * progress\n            end\n        end\n\n        unit.IsBeingTransferred = true\n\n        -- changing owner\n        unit = ChangeUnitArmy(unit, toArmy)\n        if not unit then\n            continue\n        end\n\n        newUnitCount = newUnitCount + 1\n        newUnits[newUnitCount] = unit\n\n        if IsAlly(owner, toArmy) then\n            if not oldowner then\n                oldowner = owner\n            end\n\n            local sharedUnitsTable = sharedUnits[oldowner]\n            if not sharedUnitsTable then\n                sharedUnitsTable = {}\n                sharedUnits[oldowner] = sharedUnitsTable\n            end\n            table.insert(sharedUnitsTable, unit)\n        end\n\n        unit.oldowner = oldowner\n\n        -- A F T E R\n        if massKilled and massKilled > 0 then\n            unit:CalculateVeterancyLevelAfterTransfer(massKilled, massKilledTrue)\n        end\n        if activeEnhancements then\n            for _, enh in activeEnhancements do\n                unit:CreateEnhancement(enh)\n            end\n        end\n        local maxHealth = unit:GetMaxHealth()\n        if unitHealth > maxHealth then\n            unitHealth = maxHealth\n        end\n        unit:SetHealth(unit, unitHealth)\n        if hasFuel then\n            unit:SetFuelRatio(fuelRatio)\n        end\n        if numNukes and numNukes > 0 then\n            unit:GiveNukeSiloAmmo(numNukes - unit:GetNukeSiloAmmoCount())\n        end\n        if numTacMsl and numTacMsl > 0 then\n            unit:GiveTacticalSiloAmmo(numTacMsl - unit:GetTacticalSiloAmmoCount())\n        end\n        local newShield = unit.MyShield\n        if newShield then\n            newShield:SetHealth(unit, shieldHealth)\n            if shieldIsOn then\n                unit:EnableShield()\n            else\n                unit:DisableShield()\n            end\n        end\n        if EntityCategoryContains(categoriesENGINEERSTATION, unit) then\n            if not upgradeBuildTimeComplete or not shareUpgrades then\n                if categoriesHash.UEF then\n                    -- use special thread for UEF Kennels\n                    -- Give them 1 tick to spawn their drones and then pause both station and drone\n                    pauseKennelCount = pauseKennelCount + 1\n                    pauseKennels[pauseKennelCount] = unit\n                else -- pause cybran hives immediately\n                    unit:SetPaused(true)\n                end\n            elseif categoriesHash.UEF then\n                unit.UpgradesTo = upgradesTo\n                unit.DefaultBuildRate = defaultBuildRate\n                unit.TargetUpgradeBuildTime = upgradeBuildTimeComplete\n\n                upgradeKennelCount = upgradeKennelCount + 1\n                upgradeKennels[upgradeKennelCount] = unit\n\n                exclude = true\n            end\n        end\n\n        if upgradeBuildTimeComplete and not exclude then\n            unit.UpgradesTo = upgradesTo\n            unit.DefaultBuildRate = defaultBuildRate\n            unit.TargetUpgradeBuildTime = upgradeBuildTimeComplete\n\n            upgradeUnitCount = upgradeUnitCount + 1\n            upgradeUnits[upgradeUnitCount] =  unit\n        end\n\n        unit.IsBeingTransferred = nil\n\n        if unit.OnGiven then\n            unit:OnGiven(unit)\n        end\n    end\n\n    if not captured then\n        if upgradeUnits[1] then\n            ForkThread(UpgradeUnits, upgradeUnits)\n        end\n        if pauseKennels[1] then\n            ForkThread(PauseTransferredKennels, pauseKennels)\n        end\n        if upgradeKennels[1] then\n            ForkThread(UpgradeTransferredKennels, upgradeKennels)\n        end\n    end\n\n    -- add delay on turning on each weapon \n    for _, unit in newUnits do\n        -- disable all weapons, enable with a delay\n        for k = 1, unit.WeaponCount do\n            local weapon = unit:GetWeapon(k)\n            weapon:SetEnabled(false)\n            weapon:ForkThread(TransferUnitsOwnershipDelayedWeapons)\n        end\n    end\n\n    return newUnits\nend\n\n--- Pauses all drones in `kennels`\n---@param kennels Unit[]\nfunction PauseTransferredKennels(kennels)\n    -- wait for drones to spawn\n    WaitTicks(1)\n\n    for _, unit in kennels do\n        unit:SetPaused(true)\n        local podData = unit.PodData\n        if podData then\n            for _, pod in podData do\n                local podHandle = pod.PodHandle\n                if podHandle then\n                    podHandle:SetPaused(true)\n                end\n            end\n        end\n    end\nend\n\n--- Upgrades `kennels` to their `TargetUpgradeBuildTime` value, allowing for drones to spawn and get paused\n---@param kennels any\nfunction UpgradeTransferredKennels(kennels)\n    WaitTicks(1) -- spawn drones\n\n    for _, unit in kennels do\n        if not unit:BeenDestroyed() then\n            for _, pod in unit.PodData or {} do -- pause Kennels drones\n                local podHandle = pod.PodHandle\n                if podHandle then\n                    podHandle:SetPaused(true)\n                end\n            end\n\n            IssueUpgrade({unit}, unit.UpgradesTo)\n        end\n    end\n\n    WaitTicks(3)\n\n    for _, unit in kennels do\n        if not unit:BeenDestroyed() then\n            unit:SetBuildRate(unit.TargetUpgradeBuildTime * 10)\n            unit:SetConsumptionPerSecondMass(0)\n            unit:SetConsumptionPerSecondEnergy(0)\n        end\n    end\n\n    WaitTicks(1)\n\n    for _, unit in kennels do\n        if not unit:BeenDestroyed() then\n            unit:SetBuildRate(unit.DefaultBuildRate)\n            unit:SetPaused(true) -- `SetPaused` updates ConsumptionPerSecond values\n            unit.TargetUpgradeBuildTime = nil\n            unit.DefaultBuildRate = nil\n        end\n    end\nend\n\n--- Takes the units and tries to rebuild them for each army (in order). \n--- The transfer procedure is fairly expensive, so it is filtered to important units (EXPs and T3 arty).\n---@param units Unit[]\n---@param armies Army[]\nfunction TransferUnfinishedUnitsAfterDeath(units, armies)\n    local unbuiltUnits = {}\n    local unbuiltUnitCount = 0\n    for _, unit in EntityCategoryFilterDown(transferUnbuiltCategory, units) do\n        if unit:IsBeingBuilt() then\n            unbuiltUnitCount = unbuiltUnitCount + 1\n            unbuiltUnits[unbuiltUnitCount] = unit\n        end\n    end\n    if not (unbuiltUnits[1] and armies[1]) then\n        return\n    end\n    RebuildUnits(unbuiltUnits, armies)\nend\n\n--- Upgrades `units` to `UpgradesTo` at their `TargetUpgradeBuildTime` values (defaulting to\n--- `UpgradeBuildTime`, i.e. completion) and resets the build rate to `DefaultBuildRate` (defaulting\n--- to the build rate at the start)\n---@param units Unit[]\nfunction UpgradeUnits(units)\n    for _, unit in units do\n        IssueUpgrade({unit}, unit.UpgradesTo)\n        if not unit.DefaultBuildRate then\n            unit.DefaultBuildRate = unit:GetBuildRate()\n        end\n        unit:SetBuildRate(0)\n    end\n\n    WaitTicks(3)\n\n    for _, unit in units do\n        if not unit:BeenDestroyed() then\n            local targetUpgradeBuildTime = unit.TargetUpgradeBuildTime or unit.UpgradeBuildTime\n            unit:SetBuildRate(targetUpgradeBuildTime * 10)\n            unit:SetConsumptionPerSecondMass(0)\n            unit:SetConsumptionPerSecondEnergy(0)\n        end\n    end\n\n    WaitTicks(1)\n\n    for _, unit in units do\n        if not unit:BeenDestroyed() then\n            unit:SetBuildRate(unit.DefaultBuildRate)\n            unit:SetPaused(true) -- `SetPaused` updates ConsumptionPerSecond values\n            unit.TargetUpgradeBuildTime = nil\n            unit.DefaultBuildRate = nil\n        end\n    end\nend\n\n--- Rebuilds `units`, giving a try for each army (in order) in case they can't for unit cap\n--- reasons. If a unit cannot be rebuilt at all, a wreckage is placed instead. Each unit can\n--- be tagged with `TargetFractionComplete` to be rebuilt with a different build progress.\n---@see AddConstructionProgress # doesn't destroy and rebuild the unit\n---@param units Unit[]\n---@param armies Army[]\nfunction RebuildUnits(units, armies)\n    local trackers, blockingEntities = StartRebuildUnits(units)\n    for _, army in ipairs(armies) do\n        TryRebuildUnits(trackers, army)\n    end\n    FinalizeRebuiltUnits(trackers, blockingEntities)\nend\n\n---@class RebuildTracker\n---@field CanCreateWreck boolean\n---@field Success boolean\n---@field TargetBuildTime number\n---@field UnitBlueprint UnitBlueprint\n---@field UnitBlueprintID string\n---@field UnitHealth number\n---@field UnitID string\n---@field UnitOrientation Quaternion\n---@field UnitPos Vector\n---@field UnitProgress number\n\n---@alias RevertibleCollisionShapeEntity Prop | Unit\n\n--- Initializes the rebuild process for a `unit`. It is destroyed in this method and replaced\n--- with a tracker. Any possible entities that could block construction have their collision\n--- shapes disabled and are placed into `blockingEntities` to be reverted later. A unit can be\n--- tagged with `TargetFractionComplete` to be rebuilt with a different build progress.\n---@param unit Unit\n---@param blockingEntities RevertibleCollisionShapeEntity[]\n---@return RebuildTracker tracker\nfunction CreateRebuildTracker(unit, blockingEntities)\n    local bp = unit.Blueprint\n    local blueprintID = bp.BlueprintId\n    local buildTime = bp.Economy.BuildTime\n    local health = unit:GetHealth()\n    local pos = unit:GetPosition()\n    local progress = unit.TargetFractionComplete or unit:GetFractionComplete()\n\n    local tracker = {\n        -- save all important data because the unit will be destroyed\n        UnitHealth = health,\n        UnitPos = pos,\n        UnitID = unit.EntityId,\n        UnitOrientation = unit:GetOrientation(),\n        UnitBlueprint = bp,\n        UnitBlueprintID = blueprintID,\n        UnitProgress = progress, -- save current progress for some later checks\n        CanCreateWreck = progress > 0.5, -- if rebuilding fails, we have to create a wreck manually\n        TargetBuildTime = progress * buildTime,\n        Success = false,\n    }\n\n    -- wrecks can prevent drone from starting construction\n    local wrecks = GetReclaimablesInRect(unit:GetSkirtRect()) -- returns nil instead of empty table when empty\n    if wrecks then\n        for _, reclaim in wrecks do\n            if reclaim.IsWreckage then\n                -- collision shape to none to prevent it from blocking, keep track to revert later\n                reclaim:SetCollisionShape('None')\n                table.insert(blockingEntities, reclaim)\n            end\n        end\n    end\n\n    -- units can prevent drone from starting construction\n    local nearbyUnits = GetUnitsInRect(unit:GetSkirtRect())\n    if nearbyUnits then\n        for _, nearbyUnit in nearbyUnits do\n            nearbyUnit:SetCollisionShape('None')\n            table.insert(blockingEntities, nearbyUnit)\n        end\n    end\n\n    unit:Destroy()\n\n    return tracker\nend\n\n--- Attempts to rebuild `units` for an `army`, returning the resulting rebuild trackers\n--- and any entities needing their collision shape reverted\n---@param units Unit[]\n---@param trackers? RebuildTracker[]\n---@param blockingEntities? RevertibleCollisionShapeEntity[]\n---@return RebuildTracker[] blockingEntities\n---@return RevertibleCollisionShapeEntity[] blockingEntities\nfunction StartRebuildUnits(units, trackers, blockingEntities)\n    trackers = trackers or {}\n    blockingEntities = blockingEntities or {}\n    for i, unit in ipairs(units) do\n        trackers[i] = CreateRebuildTracker(unit, blockingEntities)\n    end\n    return trackers, blockingEntities\nend\n\n--- Attempts to rebuild units for an `army`, using `trackers`\n---@param trackers RebuildTracker[]\n---@param army Army\nfunction TryRebuildUnits(trackers, army)\n    local rebuilders = {}\n    for k, tracker in ipairs(trackers) do\n        if tracker.Success then\n            continue\n        end\n        -- create invisible drone which belongs to allied army. BuildRange = 10000\n        local rebuilder = CreateUnitHPR('ZXA0001', army, 5, 20, 5, 0, 0, 0)\n        rebuilder.TargetBuildTime = tracker.TargetBuildTime\n        rebuilders[k] = rebuilder\n\n        IssueBuildMobile({rebuilder}, tracker.UnitPos, tracker.UnitBlueprintID, {})\n    end\n\n    WaitTicks(3) -- wait some ticks (3 is minimum), IssueBuildMobile() is not instant\n\n    for k, rebuilder in rebuilders do\n        rebuilder:SetBuildRate(rebuilder.TargetBuildTime * 10) -- set crazy build rate and consumption = 0\n        rebuilder:SetConsumptionPerSecondMass(0)\n        rebuilder:SetConsumptionPerSecondEnergy(0)\n    end\n\n    WaitTicks(1)\n\n    for k, rebuilder in ipairs(rebuilders) do\n        local tracker = trackers[k]\n        local newUnit = rebuilder:GetFocusUnit()\n        local progressDif = rebuilder:GetWorkProgress() - tracker.UnitProgress\n        if newUnit and math.abs(progressDif) < 0.001 then\n            newUnit:SetHealth(newUnit, tracker.UnitHealth)\n            tracker.Success = true\n        end\n        rebuilder:Destroy()\n    end\nend\n\n--- Finalizes the unit rebuilding process. Any failed rebuilding attempts are replaced with\n--- wreckage and all blocking entities have their collision shapes reverted.\n---@param trackers RebuildTracker[]\n---@param blockingEntities RevertibleCollisionShapeEntity[]\nfunction FinalizeRebuiltUnits(trackers, blockingEntities)\n    for _, tracker in trackers do\n        if not tracker.Success and tracker.CanCreateWreck then -- create 50% wreck. Copied from Unit:CreateWreckageProp()\n            local bp = tracker.UnitBlueprint\n            local pos = tracker.UnitPos\n            local orientation = tracker.UnitOrientation\n            local mass = bp.Economy.BuildCostMass * 0.57 --0.57 to compensate some multipliers in CreateWreckage()\n            local energy = 0\n            local time = (bp.Wreckage.ReclaimTimeMultiplier or 1) * 2\n            CreateWreckage(bp, pos, orientation, mass, energy, time)\n        end\n    end\n\n    -- revert collision shapes of any blocking units or wreckage\n    for _, entity in blockingEntities do\n        if not entity:BeenDestroyed() then\n            entity:RevertCollisionShape()\n        end\n    end\nend\n\n---@param data {To: number}\n---@param units Unit[]\nfunction GiveUnitsToPlayer(data, units)\n    local manualShare = ScenarioInfo.Options.ManualUnitShare\n    if manualShare == 'none' then\n        return\n    end\n    local toArmy = data.To\n\n    if units then\n        local owner = units[1].Army\n        if OkayToMessWithArmy(owner) and IsAlly(owner, toArmy) then\n            if manualShare == 'no_builders' then\n                local unitsBefore = table.getsize(units)\n                units = EntityCategoryFilterDown(buildersCategory, units)\n                local unitsAfter = table.getsize(units)\n\n                if unitsAfter ~= unitsBefore then\n                    -- Maybe spawn an UI dialog instead?\n                    print((unitsBefore - unitsAfter) .. \" engineers/factories could not be transferred due to manual share rules\")\n                end\n            end\n\n            TransferUnitsOwnership(units, toArmy)\n        end\n    end\nend\n\n---@param data {Army: number, Value: boolean}\nfunction SetResourceSharing(data)\n    local army = data.Army\n    if not OkayToMessWithArmy(army) then\n        return\n    end\n    local brain = GetArmyBrain(army)\n    brain:SetResourceSharing(data.Value)\nend\n\n---@param data {Army: number, Value: boolean}\nfunction RequestAlliedVictory(data)\n    -- You cannot change this in a team game\n    if ScenarioInfo.TeamGame then\n        return\n    end\n    local army = data.Army\n    if not OkayToMessWithArmy(army) then\n        return\n    end\n    local brain = GetArmyBrain(army)\n    brain.RequestingAlliedVictory = data.Value\nend\n\n---@param data {Army: number, Value: boolean}\nfunction SetOfferDraw(data)\n    local army = data.Army\n    if not OkayToMessWithArmy(army) then\n        return\n    end\n    local brain = GetArmyBrain(army)\n    brain.OfferingDraw = data.Value\nend\n\n-- ==============================================================================\n-- UNIT CAP\n-- ==============================================================================\n\n--- Given that `deadArmy` just died, redistributes their unit cap based on the scenario options\n---@param deadArmy number\nfunction UpdateUnitCap(deadArmy)\n    -- If we are asked to share out unit cap for the defeated army, do the following...\n    local options = ScenarioInfo.Options\n    local mode = options.ShareUnitCap\n    if not mode or mode == 'none' then\n        return\n    end\n    local aliveCount = 0\n    local alive = {}\n    local caps = {}\n\n    for index, brain in ArmyBrains do\n        if (mode == 'all' or (mode == 'allies' and IsAlly(deadArmy, index))) and not ArmyIsCivilian(index) then\n            if not brain:IsDefeated() then\n                brain.index = index\n                aliveCount = aliveCount + 1\n                alive[aliveCount] = brain\n                local cap = GetArmyUnitCap(index)\n                caps[aliveCount] = cap\n            end\n        end\n    end\n\n    if aliveCount > 0 then\n        local capChng = GetArmyUnitCap(deadArmy) / aliveCount\n        for i, brain in alive do\n            SetArmyUnitCap(brain.index, caps[i] + capChng)\n        end\n    end\nend\n\n---@param data {Sender: number, Msg: string}\nfunction SendChatToReplay(data)\n    if data.Sender and data.Msg then\n        if not Sync.UnitData.Chat then\n            Sync.UnitData.Chat = {}\n        end\n        table.insert(Sync.UnitData.Chat, {sender = data.Sender, msg = data.Msg})\n    end\nend\n\n---@param data {From: number, To: number, Mass: number, Energy: number}\nfunction GiveResourcesToPlayer(data)\n    SendChatToReplay(data)\n    -- Ignore observers and players trying to send resources to themselves or to enemies\n    if data.From ~= -1 and data.From ~= data.To and IsAlly(data.From, data.To) then\n        if not OkayToMessWithArmy(data.From) then\n            return\n        end\n        local fromBrain = GetArmyBrain(data.From)\n        local toBrain = GetArmyBrain(data.To)\n        -- Abort if any of the armies is defeated or if trying to send a negative value\n        if fromBrain:IsDefeated() or toBrain:IsDefeated() or data.Mass < 0 or data.Energy < 0 then\n            return\n        end\n        local massTaken = fromBrain:TakeResource('Mass', data.Mass * fromBrain:GetEconomyStored('Mass'))\n        local energyTaken = fromBrain:TakeResource('Energy', data.Energy * fromBrain:GetEconomyStored('Energy'))\n\n        toBrain:GiveResource('Mass', massTaken)\n        toBrain:GiveResource('Energy', energyTaken)\n    end\nend\n\n---@param data {From: number, To: number}\nfunction BreakAlliance(data)\n    -- You cannot change alliances in a team game\n    if ScenarioInfo.TeamGame then\n        return\n    end\n\n    if OkayToMessWithArmy(data.From) then\n        SetAlliance(data.From, data.To, \"Enemy\")\n\n        if Sync.BrokenAlliances == nil then\n            Sync.BrokenAlliances = {}\n        end\n        table.insert(Sync.BrokenAlliances, { From = data.From, To = data.To })\n    end\n    import(\"/lua/simping.lua\").OnAllianceChange()\nend\n\n---@param resultData {From: number, To: number, ResultValue: DiplomacyActionType}\nfunction OnAllianceResult(resultData)\n    -- You cannot change alliances in a team game\n    if ScenarioInfo.TeamGame then\n        return\n    end\n\n    if OkayToMessWithArmy(resultData.From) then\n        if resultData.ResultValue == \"accept\" then\n            SetAlliance(resultData.From,resultData.To, \"Ally\")\n            if Sync.FormedAlliances == nil then\n                Sync.FormedAlliances = {}\n            end\n            table.insert(Sync.FormedAlliances, { From = resultData.From, To = resultData.To })\n        end\n    end\n    import(\"/lua/simping.lua\").OnAllianceChange()\nend\nimport(\"/lua/simplayerquery.lua\").AddResultListener(\"OfferAlliance\", OnAllianceResult)\n", "\ndoscript \"/lua/shared/RecallParams.lua\"\n\n---@alias CannotRecallReason \"active\" | \"ai\" | \"gate\" | \"request\" | \"scenario\" | \"vote\" | false\n\nfunction init()\n    for _, brain in ArmyBrains do\n        brain.LastRecallRequestTime = PlayerGateCooldown - PlayerRequestCooldown\n        brain.LastRecallVoteTime = PlayerGateCooldown - TeamVoteCooldown\n    end\n    ForkThread(function()\n        if ScenarioInfo.RecallDisabled then\n            Sync.RecallRequest = {CannotRequest = \"scenario\"}\n        else\n            Sync.RecallRequest = {CannotRequest = \"gate\"}\n            WaitTicks(PlayerGateCooldown + 1)\n\n            local focus = GetFocusArmy()\n            local brain = GetArmyBrain(focus)\n            for index, brainWith in ArmyBrains do\n                if brain ~= brainWith then\n                    if  not brain:IsDefeated() and\n                        IsAlly(focus, index) and\n                        brainWith.BrainType ~= \"Human\" and\n                        not ArmyIsCivilian(index)\n                    then\n                        Sync.RecallRequest = {CannotRequest = \"ai\"}\n                        return\n                    end\n                end\n            end\n            Sync.RecallRequest = {CannotRequest = false}\n        end\n    end)\nend\n\n---@param lastTeamVote number\n---@param lastPlayerRequest number\n---@param playerGatein? number\n---@return number cooldown\n---@return CannotRecallReason reason\nfunction RecallRequestCooldown(lastTeamVote, lastPlayerRequest, playerGatein)\n    playerGatein = playerGatein or 0\n    local gametime = GetGameTick()\n    local reqCooldown = lastPlayerRequest + PlayerRequestCooldown - gametime\n    local voteCooldown = lastTeamVote + TeamVoteCooldown - gametime\n    local gateCooldown = playerGatein + PlayerGateCooldown - gametime\n\n    local largest, reason = reqCooldown, \"request\"\n    if largest < voteCooldown then\n        largest, reason = voteCooldown, \"vote\"\n    end\n    if largest < gateCooldown then\n        largest, reason = gateCooldown, \"gate\"\n    end\n    if largest < 0 then\n        return 0, false\n    end\n    return largest, reason\nend\n\n--- Returns the recall request cooldown for an army\n---@param army Army\n---@return number cooldown\n---@return string reason\nfunction ArmyRecallRequestCooldown(army)\n    local brain = GetArmyBrain(army)\n    if ScenarioInfo.RecallDisabled then\n        return 36000, \"scenario\"\n    end\n    if brain.RecallVote ~= nil then\n        return 36000, \"active\"\n    end\n    local lastPlayerRequest = brain.LastRecallRequestTime\n    local lastTeamVote\n    army = brain.Army\n    lastTeamVote = lastPlayerRequest\n    for index, ally in ArmyBrains do\n        if not ally:IsDefeated() and IsAlly(army, index) and not ArmyIsCivilian(index) then\n            local allyTeamVote = ally.LastRecallVoteTime\n            if allyTeamVote < lastTeamVote then\n                lastTeamVote = allyTeamVote\n            end\n        end\n    end\n    return RecallRequestCooldown(lastTeamVote, lastPlayerRequest)\nend\n\n---@param reason CannotRecallReason\nlocal function SetCannotRequestRecall(reason)\n    local recallSync = Sync.RecallRequest\n    if not recallSync then\n        Sync.RecallRequest = {CannotRequest = reason}\n    else\n        recallSync.CannotRequest = reason\n    end\nend\n\nlocal function RecallVotingThread(requestingArmy)\n    WaitTicks(VoteTime + 1)\n\n    local gametick = GetGameTick()\n    local recallAcceptance = 0\n    local team = {}\n    local teammates = 0\n    for index, brain in ArmyBrains do\n        if not brain:IsDefeated() and IsAlly(requestingArmy, brain.Army) and not ArmyIsCivilian(index) then\n            teammates = teammates + 1\n            team[teammates] = brain\n            if brain.RecallVote then\n                recallAcceptance = recallAcceptance + 1\n            end\n            brain.RecallVote = nil\n            brain.LastRecallVoteTime = gametick\n        end\n    end\n    local recallAccepted = RecallRequestAccepted(recallAcceptance, teammates)\n    local focus = GetFocusArmy()\n    local brain = GetArmyBrain(requestingArmy)\n    if IsAlly(focus, requestingArmy) then\n        Sync.RecallRequest = {\n            Close = recallAccepted,\n        }\n    elseif recallAccepted then\n        local dip = Sync.DiplomacyAnnouncement\n        if not dip then\n            dip = {}\n            Sync.DiplomacyAnnouncement = dip\n        end\n        table.insert(dip, {\n            Action = \"recall\",\n            Team = brain.Nickname,\n        })\n    end\n    if recallAccepted then\n        SPEW(\"Vote passed; recalling!\")\n        for army, brain in team do\n            brain:RecallAllCommanders()\n        end\n    else\n        brain.LastRecallRequestTime = gametick\n\n        -- update UI once the cooldown dissipates\n        local cooldown, reason = ArmyRecallRequestCooldown(focus)\n        repeat\n            SetCannotRequestRecall(reason)\n            WaitTicks(cooldown + 1)\n\n            cooldown, reason = ArmyRecallRequestCooldown(focus)\n        until cooldown <= 0\n        SetCannotRequestRecall(false)\n    end\n    brain.recallVotingThread = nil\nend\n\nlocal function ArmyVoteRecall(army, vote, lastVote)\n    if lastVote then\n        for index, ally in ArmyBrains do\n            if army ~= index and not ally:IsDefeated() and IsAlly(army, index) then\n                local thread = ally.recallVotingThread\n                if thread then\n                    -- end voting period\n                    coroutine.resume(thread)\n                    break\n                end\n            end\n        end\n    end\n\n    local focus = GetFocusArmy()\n    -- don't update the recall panel for votes we aren't a part of\n    if not IsAlly(focus, army) then\n        return false\n    end\n    local recallSync = Sync.RecallRequest\n    if not recallSync then\n        recallSync = {}\n        Sync.RecallRequest = recallSync\n    end\n    if vote then\n        local accept = recallSync.Accept or 0\n        recallSync.Accept = accept + 1\n    else\n        local veto = recallSync.Veto or 0\n        recallSync.Veto = veto + 1\n    end\n    if army == focus then\n        recallSync.CannotRequest = \"active\"\n    end\n    return true\nend\n\nlocal function ArmyRequestRecall(army, teammates, lastVote)\n    if teammates > 0 then\n        GetArmyBrain(army).recallVotingThread = ForkThread(RecallVotingThread, army)\n        if ArmyVoteRecall(army, true, lastVote) then\n            local recallSync = Sync.RecallRequest\n            recallSync.Open = VoteTime * 0.1\n            recallSync.CanVote = army ~= GetFocusArmy()\n            recallSync.Blocks = teammates + 1\n        end\n    elseif lastVote then\n        -- if we're the first and last vote, it's just us; recall our army\n        SPEW(\"Immediately recalling\")\n        GetArmyBrain(army):RecallAllCommanders()\n    end\nend\n\n---@param data {From: number, Vote: boolean}\nfunction SetRecallVote(data)\n    local focus = GetFocusArmy()\n    local army = data.From\n    if not ScenarioInfo.TeamGame then\n        if army == focus then\n            SetCannotRequestRecall(\"scenario\")\n        end\n        return\n    end\n    local vote = data.Vote and true or false\n\n    local isRequest = true\n    local lastVote = true\n    local teammates = 0\n    for index, ally in ArmyBrains do\n        if army ~= index and not ally:IsDefeated() and IsAlly(army, index) and not ArmyIsCivilian(index) then\n            if ally.BrainType ~= \"Human\" then\n                if army == focus then\n                    SetCannotRequestRecall(\"ai\")\n                end\n                return\n            end\n            local allyHasVoted = ally.RecallVote ~= nil\n            lastVote = lastVote and allyHasVoted\n            isRequest = isRequest and not allyHasVoted\n            teammates = teammates + 1\n        end\n    end\n\n    local brain = GetArmyBrain(army)\n    if isRequest then\n        -- the player is making a recall request; this will reset their recall request cooldown\n        local cooldown, reason = ArmyRecallRequestCooldown(army)\n        if cooldown > 0 then\n            if army == focus then\n                SetCannotRequestRecall(reason)\n            end\n            return\n        end\n        SPEW(\"Army \" .. tostring(army) .. \" is requesting recall\")\n        brain.RecallVote = vote\n        ArmyRequestRecall(army, teammates, lastVote)\n    else\n        -- the player is responding to a recall request; we don't count this against their\n        -- individual recall request cooldown\n        SPEW(\"Army \" .. tostring(army) .. \" recall vote: \" .. (vote and \"accept\" or \"veto\"))\n        brain.RecallVote = vote\n        ArmyVoteRecall(army, vote, lastVote)\n    end\nend\n", "--*****************************************************************************\n--* File: lua/modules/ui/game/diplomacy.lua\n--* Summary: UI for the diplomacy control\n--*\n--* Copyright \u00a9 2006 Gas Powered Games, Inc.  All rights reserved.\n--*****************************************************************************\n\n---@alias DiplomacyActionType \"accept\" | \"break\" | \"never\" | \"offer\" | \"reject\"\n\n---@class DiplomacyAction\n---@field Action DiplomacyActionType\n---@field To number army index\n---@field From number army index\n\nlocal Bitmap = import(\"/lua/maui/bitmap.lua\").Bitmap\nlocal UIUtil = import(\"/lua/ui/uiutil.lua\")\nlocal LayoutHelpers = import(\"/lua/maui/layouthelpers.lua\")\nlocal Group = import(\"/lua/maui/group.lua\").Group\nlocal StatusBar = import(\"/lua/maui/statusbar.lua\").StatusBar\nlocal Slider = import(\"/lua/maui/slider.lua\").Slider\nlocal Tooltip = import(\"/lua/ui/game/tooltip.lua\")\nlocal Tabs = import(\"/lua/ui/game/tabs.lua\")\n\nlocal ScaleNumber = LayoutHelpers.ScaleNumber\nlocal Layouter = LayoutHelpers.LayoutFor\nlocal CreateBitmap = UIUtil.CreateBitmap\nlocal CreateBitmapStd = UIUtil.CreateBitmapStd\n\n---@type Group\nlocal parent = false\nlocal shareResources = true\nlocal alliedVictory = true\n\nlocal dialogue = false\nlocal offerQueue = {}\nlocal drawOffered = false\n\n---@type CannotRecallReason\nlocal cannotRequestRecall = false\n\nfunction CannotRequestRecall()\n    return cannotRequestRecall\nend\n\nfunction UpdateCannotRequestRecall(canRequest)\n    cannotRequestRecall = canRequest\n    if parent then\n        BuildPlayerLines()\n    end\nend\n\nfunction ActionHandler(actions)\n    local armies = GetArmiesTable().armiesTable\n    for _, action in actions do\n        local from = armies[action.From].nickname\n        local actionName = action.Action\n        if actionName == 'offer' then\n            if not dialogue then\n                dialogue = CreateOfferDialogue(action)\n            else\n                table.insert(offerQueue, action)\n            end\n        elseif actionName == 'accept' then\n            Announce(LOC('<LOC diplomacy_0005>%s accepts your alliance.'):format(from))\n        elseif actionName == 'reject' then\n            Announce(LOC('<LOC diplomacy_0006>%s rejects your alliance.'):format(from))\n        elseif actionName == 'never' then\n            Announce(LOC('<LOC diplomacy_0007>%s is now ignoring your requests.'):format(from))\n        elseif actionName == 'break' then\n            Announce(LOC('<LOC diplomacy_0008>Your alliance with %s has been broken.'):format(from))\n        end\n    end\nend\n\nfunction AnnouncementHandler(announcements)\n    local armies = GetArmiesTable().armiesTable\n    for _, announcement in announcements do\n        local announcementName = announcement.Action\n        if announcementName == \"accept\" then\n            Announce(LOC('<LOC diplomacy_0009>%s and %s are now allies.'):format(armies[announcement.From].nickname, armies[announcement.To].nickname))\n        elseif announcementName == \"break\" then\n            Announce(LOC('<LOC diplomacy_0010>%s and %s are no longer allies.'):format(armies[announcement.From].nickname, armies[announcement.To].nickname))\n        elseif announcementName == \"recall\" then\n            Announce(LOC('<LOC diplomacy_0020>Team %s has recalled from battle.'):format(announcement.Team))\n        end\n    end\nend\n\nfunction Announce(msg)\n    Tabs.TabAnnouncement('diplomacy', msg)\n    if parent then\n        BuildPlayerLines()\n    end\nend\n\nfunction CreateOfferDialogue(action)\n    local from = action.From\n    local army = GetArmiesTable().armiesTable[from].nickname\n    return UIUtil.QuickDialog(\n        GetFrame(0),\n        LOC(\"<LOC diplomacy_0004>%s has offered you an alliance.\"):format(army),\n        \"<LOC _Accept>\", function() SendAnswer(from, 'accept') end,\n        \"<LOC _Reject>\", function() SendAnswer(from, 'reject') end,\n        \"<LOC _Never>\",  function() SendAnswer(from, 'never') end,\n        true, {\n            escapeButton = 2,\n            enterButton = 1,\n            worldCover = false,\n            OnlyWorldCover = true,\n        }\n    )\nend\n\nfunction SendAnswer(army, answer)\n    SimCallback({\n        Func = 'DiplomacyHandler',\n        Args = {\n            Action = answer,\n            From = GetFocusArmy(),\n            To = army,\n        },\n    })\n    local i = 1\n    local offer = offerQueue[i]\n    while offer do\n        if offer.From == army then\n            table.remove(offerQueue, i)\n        else\n            i = i + 1\n        end\n        offer = offerQueue[i]\n    end\n    offer = offerQueue[1]\n    if offer then\n        CreateOfferDialogue(offer)\n        table.remove(offerQueue, 1)\n    else\n        dialogue = false\n    end\nend\n\nfunction CreateContent(inParent)\n    parent = Group(inParent)\n\n    BuildPlayerLines()\n\n    LayoutHelpers.SetWidth(parent, 266)\n    parent.OnDestroy = function(self)\n        parent = false\n    end\n\n    return parent\nend\n\nlocal function LayoutMajorAlliedEntry(entry, manualShare)\n    local giveUnitBtn = UIUtil.CreateButtonStd(entry,\n        '/dialogs/toggle_btn/toggle-d',\n        '<LOC diplomacy_0011>Units', 12\n    )\n    giveUnitBtn.label:SetFont(UIUtil.bodyFont, 12)\n    LayoutHelpers.Below(giveUnitBtn, entry.factionIcon, -2)\n    LayoutHelpers.AtLeftIn(giveUnitBtn, entry)\n    Tooltip.AddButtonTooltip(giveUnitBtn, 'dip_give_units')\n    entry.giveUnitBtn = giveUnitBtn\n\n    if manualShare == 'none' then\n        giveUnitBtn:Disable()\n    else\n        giveUnitBtn.OnClick = function(self, modifiers)\n            UIUtil.QuickDialog(GetFrame(0),\n                LOC(\"<LOC unitxfer_0000>Give Selected Units to %s?\"):format(entry.Data.nickname),\n                '<LOC _Yes>',\n                function()\n                    local to = entry.Data.armyIndex\n                    if IsKeyDown('Shift') then\n                        IssueCommand(\"UNITCOMMAND_Script\", {TaskName = 'GiveTask', To = to}, false)\n                    else\n                        SimCallback({\n                            Func = \"GiveUnitsToPlayer\",\n                            Args = {\n                                From = GetFocusArmy(),\n                                To = to,\n                            },\n                        }, true)\n                    end\n                end,\n                '<LOC _No>', nil, nil, nil, nil,\n                {worldCover = false, enterButton = 1, escapeButton = 2}\n            )\n        end\n    end\n\n    local giveResourcesBtn = UIUtil.CreateButtonStd(entry,\n        '/dialogs/toggle_btn/toggle-d',\n        '<LOC diplomacy_0012>Resources', 12\n    )\n    LayoutHelpers.RightOf(giveResourcesBtn, giveUnitBtn)\n    giveResourcesBtn.label:SetFont(UIUtil.bodyFont, 12)\n    Tooltip.AddButtonTooltip(giveResourcesBtn, 'dip_give_resources')\n    entry.giveResourcesBtn = giveResourcesBtn\n\n    giveResourcesBtn.OnClick = function(self, modifiers)\n        CreateShareResourcesDialog(entry)\n    end\nend\n\nlocal function LayoutAlliedEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked, manualShare)\n    if isHuman and not outOfGame then\n        LayoutMajorAlliedEntry(entry, manualShare)\n    end\n\n    if teamsLocked then\n    else\n        if not outOfGame then\n            local breakBtn = UIUtil.CreateButtonStd(entry,\n                \"/dialogs/toggle_btn/toggle-d\",\n                \"<LOC diplomacy_0013>Break\", 12\n            )\n            breakBtn.label:SetFont(UIUtil.bodyFont, 12)\n            LayoutHelpers.Below(breakBtn, entry.factionIcon, -2)\n            LayoutHelpers.AtRightIn(breakBtn, entry)\n            LayoutHelpers.ResetLeft(breakBtn)\n            Tooltip.AddButtonTooltip(breakBtn, \"dip_break_alliance\")\n            entry.breakBtn = breakBtn\n\n            breakBtn.OnClick = function(self, checked)\n                SimCallback({\n                    Func = \"DiplomacyHandler\",\n                    Args = {\n                        Action = \"break\",\n                        From = GetFocusArmy(),\n                        To = armyIndex,\n                    },\n                })\n                ForkThread(function()\n                    WaitSeconds(1)\n                    BuildPlayerLines()\n                end)\n            end\n        end\n    end\nend\n\nlocal function LayoutEnemyEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked)\n    if isHuman and not teamsLocked and not outOfGame then\n        local offerBtn = UIUtil.CreateButtonStd(entry,\n            '/dialogs/toggle_btn/toggle-d',\n            '<LOC diplomacy_0014>Offer', 12\n        )\n        offerBtn.label:SetFont(UIUtil.bodyFont, 12)\n        LayoutHelpers.AtRightBottomIn(offerBtn, entry)\n        Tooltip.AddButtonTooltip(offerBtn, 'dip_offer_alliance')\n        entry.offerBtn = offerBtn\n\n        offerBtn.OnClick = function(self, checked)\n            self:Disable()\n            SimCallback({\n                Func = 'DiplomacyHandler',\n                Args = {\n                    Action = 'offer',\n                    From = GetFocusArmy(),\n                    To = armyIndex,\n                },\n            })\n        end\n    end\nend\n\nlocal function CreateDiplomacyEntry(parent, data, isAlly)\n    local sessionOptions = SessionGetScenarioInfo().Options\n    local isHuman = data.human\n    local outOfGame = data.outOfGame\n    local teamsLocked = sessionOptions and sessionOptions.TeamLock == \"locked\"\n    local manualShare = sessionOptions.ManualUnitShare\n    local armyIndex = data.armyIndex\n\n    local entry = Bitmap(parent)\n    entry.Height:Set(function()\n        local data = entry.Data\n        if (isAlly or isHuman) and not data.outOfGame then\n            return entry.factionIcon.Height() + 12 + ScaleNumber(12)\n        else\n            return entry.factionIcon.Height() + ScaleNumber(4)\n        end\n    end)\n    entry.Width:Set(function() return parent.Width() - 12 end)\n    entry.Depth:Set(function() return parent.Depth() + 10 end)\n    entry:SetSolidColor('00000000')\n    entry.Data = data\n\n    local typeIcon\n    local factionIcon\n    local colorIcon\n    if isHuman then\n        typeIcon = \"/game/options-diplomacy-panel/icon-person\"\n    else\n        typeIcon = \"/game/options-diplomacy-panel/icon-ai\"\n    end\n    if outOfGame then\n        factionIcon = \"/game/unit-over/icon-skull_bmp.dds\"\n        colorIcon = \"ff000000\"\n    else\n        factionIcon = UIUtil.GetFactionIcon(data.faction)\n        colorIcon = data.color\n    end\n\n    typeIcon = CreateBitmapStd(entry, typeIcon)\n    LayoutHelpers.AtLeftIn(typeIcon, entry)\n    entry.typeIcon = typeIcon\n\n    factionIcon = CreateBitmap(entry, factionIcon)\n    LayoutHelpers.RightOf(factionIcon, typeIcon)\n    LayoutHelpers.AtTopIn(factionIcon, entry)\n    entry.factionIcon = factionIcon\n\n    LayoutHelpers.AtVerticalCenterIn(typeIcon, factionIcon)\n\n    colorIcon = UIUtil.CreateBitmapColor(factionIcon, colorIcon)\n    colorIcon.Depth:Set(function() return factionIcon.Depth() - 1 end)\n    LayoutHelpers.FillParent(colorIcon, factionIcon)\n    entry.color = colorIcon\n\n    local name = UIUtil.CreateText(entry, data.nickname, 16, UIUtil.bodyFont)\n    LayoutHelpers.AtRightIn(name, entry)\n    LayoutHelpers.AnchorToRight(name, factionIcon, 5)\n    LayoutHelpers.AtVerticalCenterIn(name, factionIcon)\n    entry.name = name\n\n    if isAlly then\n        LayoutAlliedEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked, manualShare)\n    else\n        LayoutEnemyEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked)\n    end\n\n    return entry\nend\n\nlocal function CreatePlayerGroup(parent, panelFilename, titleLoc, titleColor, controls, controlCount, isAlly)\n    local lineFilename = panelFilename .. \"-line\"\n    local group = UIUtil.CreateVertFillGroup(parent, panelFilename)\n\n    local title = UIUtil.CreateText(group, titleLoc, 18, UIUtil.bodyFont)\n    Layouter(title)\n        :Color(titleColor)\n        :DropShadow(true)\n        :Over(group, 10)\n    title.Left:Set(function() return group.Left() + 8 end)\n    title.Top:Set(function() return group.Top() + 8 end)\n    title.Right:Set(function() return group.Right() - 8 end)\n\n    local entry = CreateDiplomacyEntry(group, controls[1], isAlly)\n    LayoutHelpers.Below(entry, title, 4)\n    local belowEntry = entry\n    local lines = {entry}\n\n    for index = 2, controlCount do\n        local entry = CreateDiplomacyEntry(group, controls[index], isAlly)\n        LayoutHelpers.Below(entry, belowEntry, 4)\n        lines[index] = entry\n\n        local separator = CreateBitmapStd(entry, lineFilename)\n        separator.Left:Set(function() return group.Left() + 6 end)\n        separator.Top:Set(function() return entry.Top() - 4 end)\n        entry.Separator = separator\n\n        belowEntry = entry\n    end\n\n    group.Height:Set(function()\n        return lines[controlCount].Bottom() - title.Top() + 20\n    end)\n    group.title = title\n    group.lines = lines\n\n    return group\nend\n\n\nfunction BuildPlayerLines()\n    local sessionOptions = SessionGetScenarioInfo().Options\n    local focusArmy = GetFocusArmy()\n\n    local group = parent.personalGroup\n    if group then\n        group:Destroy()\n    end\n    group = parent.alliedGroup\n    if group then\n        group:Destroy()\n    end\n    group = parent.enemyGroup\n    if group then\n        group:Destroy()\n    end\n\n    local allyControls = {}\n    local allyCount = 0\n    local enemyControls = {}\n    local enemyCount = 0\n    local allHumanGame = true\n\n    for index, playerInfo in GetArmiesTable().armiesTable do\n        if playerInfo.civilian or index == focusArmy then continue end\n        playerInfo.armyIndex = index\n        if IsAlly(focusArmy, index) then\n            allyCount = allyCount + 1\n            allyControls[allyCount] = playerInfo\n        else\n            enemyCount = enemyCount + 1\n            enemyControls[enemyCount] = playerInfo\n        end\n        if allHumanGame and not (playerInfo.human or playerInfo.outOfGame) then\n            allHumanGame = false\n        end\n    end\n\n    local belowEntry = parent\n\n    if not import(\"/lua/ui/campaign/campaignmanager.lua\").campaignMode then\n        local personalGroup = CreateBitmapStd(parent, \"/game/options-diplomacy-panel/panel-recall\")\n        if belowEntry == parent then\n            LayoutHelpers.AtLeftTopIn(personalGroup, belowEntry, 0, 8)\n        else\n            LayoutHelpers.Below(personalGroup, belowEntry, 8)\n        end\n        parent.personalGroup = personalGroup\n\n        local recallButton = UIUtil.CreateButtonStd(personalGroup, \"/widgets02/small\")\n        Layouter(recallButton)\n            :AtCenterIn(personalGroup)\n            :Over(personalGroup, 5)\n        personalGroup.button = recallButton\n\n        local reason = CannotRequestRecall()\n        if reason then\n            recallButton:Disable()\n            Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request_dis_\" .. reason)\n        else\n            recallButton.OnClick = function(self, modifiers)\n                UIUtil.QuickDialog(GetFrame(0),\n                    \"<LOC diplomacy_0019>Are you sure you're ready to recall from battle? This will send a request to your team.\",\n                    \"<LOC _Yes>\",\n                    function()\n                        SimCallback({\n                            Func = \"SetRecallVote\",\n                            Args = {\n                                From = GetFocusArmy(),\n                                Vote = true,\n                            },\n                        })\n                        recallButton:Disable()\n                        cannotRequestRecall = \"active\"\n                        Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request_dis_active\")\n                        import(\"/lua/ui/game/tabs.lua\").CollapseWindow()\n                    end,\n                    \"<LOC _No>\", nil, nil, nil, nil,\n                    {worldCover = false, enterButton = 1, escapeButton = 2}\n                )\n            end\n            Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request\")\n        end\n\n        local recallIcon = CreateBitmapStd(recallButton, \"/game/recall-panel/icon-recall\")\n        Layouter(recallIcon)\n            :AtCenterIn(recallButton)\n            :Over(recallButton, 5)\n        recallButton.label = recallIcon\n\n        belowEntry = personalGroup\n    end\n\n    if allyCount > 0 then\n        local allyGroup = CreatePlayerGroup(parent,\n            \"/game/options-diplomacy-panel/panel-allies\",\n            \"<LOC diplomacy_0002>Allies\", \"ff00ff72\",\n            allyControls, allyCount, true\n        )\n        if belowEntry == parent then\n            LayoutHelpers.AtLeftTopIn(allyGroup, belowEntry, 0, 8)\n        else\n            LayoutHelpers.Below(allyGroup, belowEntry, 8)\n        end\n        parent.alliedGroup = allyGroup\n\n        local allyTitle = allyGroup.title\n\n        local srCheck = UIUtil.CreateCheckboxStd(allyTitle, '/game/toggle_btn/toggle')\n        srCheck:SetCheck(shareResources, true)\n        LayoutHelpers.AtRightIn(srCheck, allyTitle)\n        srCheck.Top:Set(function() return allyGroup.Top() + 4 end)\n        Tooltip.AddCheckboxTooltip(srCheck, 'dip_share_resources')\n        allyTitle.srCheck = srCheck\n\n        local icon = CreateBitmapStd(srCheck, \"/game/toggle_btn/icon-shared-resources\")\n        icon:DisableHitTest()\n        LayoutHelpers.AtCenterIn(icon, srCheck)\n        srCheck.label = icon\n\n        if sessionOptions.TeamLock == \"unlocked\" then\n            local avCheck = UIUtil.CreateCheckboxStd(allyTitle, \"/game/toggle_btn/toggle\")\n            avCheck:SetCheck(alliedVictory, true)\n            LayoutHelpers.LeftOf(avCheck, srCheck)\n            Tooltip.AddCheckboxTooltip(avCheck, \"dip_allied_victory\")\n            allyTitle.avCheck = avCheck\n\n            icon = CreateBitmapStd(avCheck, \"/game/toggle_btn/icon-allied-victory\")\n            icon:DisableHitTest()\n            LayoutHelpers.AtCenterIn(icon, avCheck)\n            avCheck.label = icon\n\n            avCheck.OnCheck = function(self, checked)\n                alliedVictory = checked\n                SimCallback({\n                    Func = \"RequestAlliedVictory\",\n                    Args = {\n                        Army = GetFocusArmy(),\n                        Value = checked,\n                    },\n                })\n            end\n        end\n\n        belowEntry = allyGroup._bottom\n\n        srCheck.OnCheck = function(self, checked)\n            shareResources = checked\n            SimCallback({\n                Func = \"SetResourceSharing\",\n                Args = {\n                    Army = GetFocusArmy(),\n                    Value = checked,\n                },\n            })\n        end\n    end\n\n    if enemyCount > 0 then\n        local enemyGroup = CreatePlayerGroup(parent,\n            \"/game/options-diplomacy-panel/panel-enemy\",\n            \"<LOC diplomacy_0003>Enemies\", \"ffff3c00\",\n            enemyControls, enemyCount, false\n        )\n        if belowEntry == parent then\n            LayoutHelpers.AtLeftTopIn(enemyGroup, belowEntry, 0, 8)\n        else\n            LayoutHelpers.Below(enemyGroup, belowEntry, 8)\n        end\n        parent.enemyGroup = enemyGroup\n\n        local enemyTitle = enemyGroup.title\n\n        if allHumanGame then\n            local odCheck = UIUtil.CreateCheckboxStd(enemyTitle, \"/dialogs/toggle_btn/toggle\")\n            odCheck:SetCheck(drawOffered, true)\n            odCheck.Top:Set(function() return enemyGroup.Top() + 4 end)\n            LayoutHelpers.AtRightIn(odCheck, enemyTitle)\n            Tooltip.AddCheckboxTooltip(odCheck, 'dip_offer_draw')\n            enemyTitle.odCheck = odCheck\n\n            odCheck.label = UIUtil.CreateText(odCheck, \"<LOC _Draw>Draw\", 12, UIUtil.bodyFont)\n            LayoutHelpers.AtCenterIn(odCheck.label, odCheck)\n\n            odCheck.OnCheck = function(self, checked)\n                drawOffered = checked\n                SimCallback({\n                    Func = \"SetOfferDraw\",\n                    Args = {\n                        Army = GetFocusArmy(),\n                        Value = checked,\n                    },\n                })\n                local msg = '<LOC diplomacy_0000>has offered a draw.'\n                if not checked then\n                    msg = '<LOC diplomacy_0001>has rescinded their draw offer.'\n                end\n                SessionSendChatMessage({to = 'all', ConsoleOutput = msg})\n            end\n        end\n\n        belowEntry = enemyGroup._bottom\n    end\n\n    LayoutHelpers.AtBottomIn(parent, belowEntry, 14)\nend\n\nfunction CreateShareResourcesDialog(control)\n    local giveResGroup = control.giveResourcesGroup\n    if giveResGroup then\n        giveResGroup:Destroy()\n        control.giveResourcesGroup = false\n        control.Height:Set(control.OrigHeight)\n        control.OrigHeight = nil\n    else\n        control.OrigHeight = control.Height()\n\n        giveResGroup = Group(control)\n        giveResGroup.Width:Set(control.Width)\n        LayoutHelpers.SetHeight(giveResGroup, 90)\n        LayoutHelpers.AtLeftBottomIn(giveResGroup, control)\n        control.giveResourcesGroup = giveResGroup\n\n        local okBtn = UIUtil.CreateButtonStd(giveResGroup,\n            '/dialogs/toggle_btn/toggle-d',\n            '<LOC _Ok>', 12\n        )\n        LayoutHelpers.AtBottomIn(okBtn, giveResGroup)\n        okBtn.Left:Set(function()\n            local giveResGroup = control.giveResourcesGroup\n            return giveResGroup.Left() + giveResGroup.Width() * 0.25 - okBtn.Width() * 0.5\n        end)\n\n        local cancelBtn = UIUtil.CreateButtonStd(giveResGroup,\n            '/dialogs/toggle_btn/toggle-d',\n            '<LOC _Cancel>', 12\n        )\n        LayoutHelpers.AtBottomIn(cancelBtn, giveResGroup)\n        cancelBtn.Left:Set(function()\n            local giveResGroup = control.giveResourcesGroup\n            return giveResGroup.Left() + giveResGroup.Width() * 0.75 - okBtn.Width() * 0.5\n        end)\n\n        local massStatus = StatusBar(giveResGroup, 0, 100, false, false,\n            UIUtil.UIFile('/game/resource-bars/mini-mass-bar-back_bmp.dds'),\n            UIUtil.UIFile('/game/resource-bars/mini-mass-bar_bmp.dds'), false\n        )\n        massStatus.Left:Set(giveResGroup.Left)\n        LayoutHelpers.AtRightTopIn(massStatus, giveResGroup, 50, 10)\n\n        local massSlider = Slider(giveResGroup, false, 0, 100,\n            UIUtil.UIFile('/game/slider-btn/slider-mass_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-mass_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-mass_btn_up.dds')\n        )\n        LayoutHelpers.AtVerticalCenterIn(massSlider, massStatus)\n        massSlider.Left:Set(giveResGroup.Left)\n        massSlider:SetValue(0)\n        LayoutHelpers.AtRightIn(massSlider, giveResGroup, 50)\n\n        massInput = UIUtil.CreateText(giveResGroup, '0%', 16, UIUtil.bodyFont)\n        massInput:SetColor('ff00ff00')\n        LayoutHelpers.RightOf(massInput, massStatus, 5)\n\n        massSlider.OnValueChanged = function(self, newValue)\n            massInput:SetText(string.format(\"%d%%\", math.max(math.min(math.floor(newValue), 100), 0)))\n            massStatus:SetValue(math.floor(newValue))\n        end\n        massStatus.Depth:Set(function() return massSlider.Depth() - 1 end)\n\n\n        local energyStatus = StatusBar(giveResGroup, 0, 100, false, false,\n            UIUtil.UIFile('/game/resource-bars/mini-energy-bar-back_bmp.dds'),\n            UIUtil.UIFile('/game/resource-bars/mini-energy-bar_bmp.dds'), false\n        )\n        energyStatus.Left:Set(giveResGroup.Left)\n        LayoutHelpers.Below(energyStatus, massStatus, 20)\n        LayoutHelpers.AtRightIn(energyStatus, giveResGroup, 50)\n\n        local energySlider = Slider(giveResGroup, false, 0, 100,\n            UIUtil.UIFile('/game/slider-btn/slider-energy_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-energy_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-energy_btn_up.dds')\n        )\n        LayoutHelpers.AtVerticalCenterIn(energySlider, energyStatus)\n        energySlider.Left:Set(giveResGroup.Left)\n        energySlider:SetValue(0)\n        LayoutHelpers.AtRightIn(energySlider, giveResGroup, 50)\n\n        energyInput = UIUtil.CreateText(giveResGroup, '0%', 16, UIUtil.bodyFont)\n        energyInput:SetColor('ffffc700')\n        LayoutHelpers.RightOf(energyInput, energyStatus, 5)\n\n        energySlider.OnValueChanged = function(self, newValue)\n            energyInput:SetText(string.format(\"%d%%\", math.max(math.min(math.floor(newValue), 100), 0)))\n            energyStatus:SetValue(math.floor(newValue))\n        end\n        energyStatus.Depth:Set(function() return massSlider.Depth() - 1 end)\n\n        control.Height:Set(function()\n            return control.OrigHeight + control.giveResourcesGroup.Height()\n        end)\n\n        okBtn.OnClick = function(self, modifiers)\n            SimCallback({\n                Func = \"GiveResourcesToPlayer\",\n                Args = {\n                    From = GetFocusArmy(),\n                    To = control.Data.armyIndex,\n                    Mass = massSlider:GetValue() * 0.01,\n                    Energy = energySlider:GetValue() * 0.01,\n                },\n            })\n            CreateShareResourcesDialog(control)\n        end\n        cancelBtn.OnClick = function(self, modifiers)\n            CreateShareResourcesDialog(control)\n        end\n    end\nend\n\nfunction SetAlliedVictory(state)\n    alliedVictory = state\nend\n\n\n\n--- Unused\n\nlocal EffectHelpers = import(\"/lua/maui/effecthelpers.lua\")\nlocal Text = import(\"/lua/maui/text.lua\").Text\nlocal Edit = import(\"/lua/maui/edit.lua\").Edit\nlocal Checkbox = import(\"/lua/maui/checkbox.lua\").Checkbox\nlocal Button = import(\"/lua/maui/button.lua\").Button\nlocal GameCommon = import(\"/lua/ui/game/gamecommon.lua\")\nlocal NeverAllyWith = {}\n\nif SessionGetScenarioInfo().Options.TeamLock == 'locked' then\n    lockTeams = true\nend", "local LayoutHelpers = import(\"/lua/maui/layouthelpers.lua\")\nlocal NinePatch = import(\"/lua/ui/controls/ninepatch.lua\")\nlocal Prefs = import(\"/lua/user/prefs.lua\")\nlocal Tooltip = import(\"/lua/ui/game/tooltip.lua\")\nlocal UIUtil = import(\"/lua/ui/uiutil.lua\")\n\nlocal Dragger = import(\"/lua/maui/dragger.lua\").Dragger\nlocal Group = import(\"/lua/maui/group.lua\").Group\n\nlocal Lazyvar = import(\"/lua/lazyvar.lua\").Create\nlocal Layouter = LayoutHelpers.ReusedLayoutFor\n\n\n-- seconds to see recall voting results\nlocal reviewResultsDuration = 5\n\nlocal panel\n\nfunction Create(parent)\n    panel = RecallPanel(parent)\n    return panel\nend\n\nfunction SetLayout()\n    Layouter(panel)\n        :AtLeftIn(panel.parent, panel:LoadPosition().left)\n        -- set to uncollapsed position; lets us layout the collapse button and setup the height\n        -- so we know where the panel's actual inital position is\n        :Top(panel.parent.Top() + LayoutHelpers.ScaleNumber(4) + panel.t.Height())\n        :Width(panel.DefaultWidth)\n        :Height(function()\n            local panel = panel\n            local Scale = LayoutHelpers.ScaleNumber\n            local height = Scale(-4) + panel.label.Height() + Scale(5) + panel.votes.Height()\n            -- make sure these register as a dependency\n            local voteHeight = panel.buttonAccept.Height()\n            local progHeight = panel.progressBarBG.Height()\n            if panel.canVote() then\n                height = height + Scale(5) + voteHeight\n                if panel.startTime() > 0 then\n                    height = height + Scale(2) + progHeight\n                end\n            elseif panel.startTime() > 0 then\n                height = height + Scale(10) + progHeight\n            end\n            return height + Scale(-2)\n        end)\n        :Hide()\n        :End()\n    panel.Top:Set(panel.parent.Top() - panel:TotalHeight())\nend\n\nfunction ToggleControl()\n    if panel and not panel.collapseArrow:IsDisabled() then\n        panel.collapseArrow:ToggleCheck()\n    end\nend\n\nfunction RequestHandler(data)\n    if data.CannotRequest ~= nil then\n        import(\"/lua/ui/game/diplomacy.lua\").UpdateCannotRequestRecall(data.CannotRequest)\n    end\n    if data.Open then\n        panel:StartVote(data.Blocks, data.Open, data.CanVote)\n    end\n    local accept, veto = data.Accept, data.Veto\n    if accept or veto then\n        panel:AddVotes(accept, veto)\n    end\n    if data.Close ~= nil then\n        panel:CloseVote(data.Close)\n    end\nend\n\n---@class RecallPanel : NinePatch\nRecallPanel = Class(NinePatch.NinePatch) {\n    DefaultWidth = 320,\n\n    __init = function(self, parent)\n        NinePatch.InitStd(self, parent, \"/game/filter-ping-list-panel/panel\")\n\n        self.parent = parent\n        self.collapseArrow = UIUtil.CreateCollapseArrow(parent, \"t\")\n        self.label = UIUtil.CreateText(self, \"<LOC diplomacy_0018>Ready for recall\", 18, UIUtil.bodyFont, true)\n        self.votes = Group(self)\n        self.buttonAccept = UIUtil.CreateButtonStd(self, \"/widgets02/small\", \"<LOC diplomacy_0016>Accept\", 16)\n        self.buttonVeto = UIUtil.CreateButtonStd(self, \"/widgets02/small\", \"<LOC diplomacy_0017>Veto\", 16)\n        self.progressBarBG = UIUtil.CreateBitmapColor(self, \"Gray\")\n        self.progressBar = UIUtil.CreateBitmapColor(self.progressBarBG, \"Yellow\")\n\n        self.progressBarBG.Height:Set(LayoutHelpers.ScaleNumber(4))\n        self.votes.Height:Set(LayoutHelpers.ScaleNumber(1))\n\n        self.votes.blocks = 0\n        self.canVote = Lazyvar(true)\n        self.startTime = Lazyvar(-9999)\n\n        self:Logic()\n    end;\n\n    Layout = function(self)\n        local collapseArrow = Layouter(self.collapseArrow)\n            :Top(self.t.Top() - 7)\n            :AtHorizontalCenterIn(self)\n            :Over(self, 10)\n            :Disable()\n            :Hide()\n            :End()\n\n        local label = Layouter(self.label)\n            :AtTopCenterIn(self, -4)\n            :End()\n\n        local votes = Layouter(self.votes)\n            :AnchorToBottom(label, 5)\n            :AtHorizontalCenterIn(self)\n            :Width(function() return self.Width() - LayoutHelpers.ScaleNumber(16) end)\n            :Height(function()\n                local vote = self.votes[1]\n                if vote then return vote.Height() end\n                return 1\n            end)\n            :End()\n\n        local buttonAccept = Layouter(self.buttonAccept)\n            :AtLeftIn(self, 8)\n            :AnchorToBottom(votes, 5)\n            :End()\n\n        local buttonVeto = Layouter(self.buttonVeto)\n            :AtRightIn(self, 8)\n            :AnchorToBottom(votes, 5)\n            :End()\n\n        local progressBarBG = Layouter(self.progressBarBG)\n            :Width(function() return self.Width() - LayoutHelpers.ScaleNumber(16) end)\n            :Height(4)\n            :AtBottomCenterIn(self, -2)\n            :End()\n\n        Layouter(self.progressBar)\n            :AtHorizontalCenterIn(progressBarBG)\n            :Top(progressBarBG.Top)\n            :Bottom(progressBarBG.Bottom)\n            :Width(function() return self.Width() - LayoutHelpers.ScaleNumber(16) end)\n            :Over(progressBarBG, 10)\n            :End()\n\n        Tooltip.AddCheckboxTooltip(collapseArrow, \"voting_collapse\")\n        Tooltip.AddButtonTooltip(buttonAccept, \"dip_recall_request_accept\")\n        Tooltip.AddButtonTooltip(buttonVeto, \"dip_recall_request_veto\")\n    end;\n\n    LayoutBlocks = function(self, blocks)\n        local votes = self.votes\n        local currentBlocks = votes.blocks\n        if blocks ~= currentBlocks then\n            votes.blocks = blocks\n            for i = currentBlocks, 1, -1 do\n                local block = votes[i]\n                if block then\n                    block:Destroy()\n                end\n                votes[i] = nil\n            end\n            if blocks > 2 then\n                local panelWidth = votes.Width()\n                local width = math.floor(panelWidth / blocks)\n                local offsetX = math.floor((panelWidth - blocks * width) * 0.5) - width\n                for i = 1, blocks do\n                    local vote = Layouter(UIUtil.CreateHorzFillGroup(votes, \"/game/recall-panel/recall-vote\"))\n                        :AtLeftTopIn(votes, offsetX + i * width)\n                        :Width(width)\n                        :End()\n                    votes[i] = vote\n                end\n            else\n                local text\n                if self.canVote() then\n                    text = \"<LOC diplomacy_0026>Your teammate has requested you to recall\"\n                else\n                    text = \"<LOC diplomacy_0025>Waiting for teammate to respond...\"\n                end\n                text = Layouter(UIUtil.CreateText(votes, text, 14))\n                    :AtTopCenterIn(votes)\n                    :End()\n                votes[1] = text\n            end\n            -- manual dirtying of the lazyvar\n            votes.Height[1] = nil\n        end\n    end;\n\n    Logic = function(self)\n        self.collapseArrow.OnCheck = function(_, checked)\n            if UIUtil.GetAnimationPrefs() then\n                if not checked or self:IsHidden() then\n                    PlaySound(Sound {\n                        Cue = \"UI_Score_Window_Open\",\n                        Bank = \"Interface\"\n                    })\n                    self:Show()\n                    self:SetNeedsFrameUpdate(true)\n                    self.Slide = false\n                else\n                    PlaySound(Sound {\n                        Cue = \"UI_Score_Window_Close\",\n                        Bank = \"Interface\"\n                    })\n                    self:SetNeedsFrameUpdate(true)\n                    self.Slide = true\n                end\n            else\n                if not checked or self:IsHidden() then\n                    self:Show()\n                    self.collapseArrow:SetCheck(false, true)\n                else\n                    self:Hide()\n                    self.collapseArrow:SetCheck(true, true)\n                end\n            end\n        end\n        self.collapseArrow.OnHide = function(collapse, hide)\n            if hide ~= collapse:IsDisabled() then\n                return true\n            end\n        end\n\n        local function ShowForVote(button, hide)\n            return not hide and not self.canVote()\n        end\n        self.buttonAccept.OnHide = ShowForVote\n        self.buttonAccept.OnClick = function()\n            SimCallback({\n                Func = \"SetRecallVote\",\n                Args = {\n                    From = GetFocusArmy(),\n                    Vote = true,\n                },\n            })\n            self:SetCanVote(false)\n        end\n        self.buttonVeto.OnHide = ShowForVote\n        self.buttonVeto.OnClick = function()\n            SimCallback({\n                Func = \"SetRecallVote\",\n                Args = {\n                    From = GetFocusArmy(),\n                    Vote = false,\n                },\n            })\n            self:SetCanVote(false)\n        end\n    end;\n\n    SetCanVote = function(self, canVote)\n        local buttonAccept = self.buttonAccept\n        local buttonVeto = self.buttonVeto\n        self.canVote:Set(canVote)\n        if canVote then\n            buttonAccept:Show()\n            buttonVeto:Show()\n        else\n            buttonAccept:Hide()\n            buttonVeto:Hide()\n        end\n    end;\n\n    StartVote = function(self, blocks, duration, canVote)\n        SPEW(\"Recall voting!\")\n        self.duration = duration\n        self.startTime:Set(GetGameTimeSeconds())\n        self:SetCanVote(canVote)\n        self:LayoutBlocks(blocks) -- can depend on `canVote`, so put after it\n        self.collapseArrow:Enable()\n        self.collapseArrow:Show()\n        self.collapseArrow:SetCheck(false)\n        if not UIUtil.GetAnimationPrefs() then\n            -- update the timer in a more rudimentary fashion\n            self.reviewResultsThread = ForkThread(function(self)\n                local nominalWidth = self.Width() - LayoutHelpers.ScaleNumber(16)\n                local incWidth = nominalWidth / duration\n                for i = 1, duration do\n                    if self.startTime() < 0 then -- accept the close vote signal\n                        break\n                    end\n                    self.progressBar.Width:Set(nominalWidth - i * incWidth)\n                    WaitSeconds(1)\n\n                end\n                self.progressBar.Width:Set(0)\n                WaitSeconds(reviewResultsDuration)\n\n                self:OnResultsReviewed()\n                self.reviewResultsThread = nil\n            end, self)\n        end\n    end;\n\n    CloseVote = function(self, accepted)\n        self:SetCanVote(false)\n        self.startTime:Set(-9999) -- make sure the OnFrame animation ends\n        if self.reviewResultsThread then\n            -- continue the OnSecond animation if it exists\n            coroutine.resume(self.reviewResultsThread)\n        else\n            -- otherwise, create our own result reviewing handler\n            self.reviewResultsThread = ForkThread(function(self)\n                WaitSeconds(reviewResultsDuration)\n\n                self:OnResultsReviewed()\n                self.reviewResultsThread = nil\n            end, self)\n        end\n        if accepted then\n            self:OnVoteAccepted()\n        else\n            self:OnVoteVetoed()\n        end\n    end;\n\n    AddVotes = function(self, accept, veto)\n        local votes = self.votes\n        if votes.blocks < 3 then return end\n        local function SetTextures(vote, filename)\n            vote._left:SetTexture(UIUtil.UIFile(filename .. \"_bmp_l.dds\"))\n            vote._middle:SetTexture(UIUtil.UIFile(filename .. \"_bmp_m.dds\"))\n            vote._right:SetTexture(UIUtil.UIFile(filename .. \"_bmp_r.dds\"))\n        end\n        local index = 1\n        for i = 1, votes.blocks do\n            if not votes[i].cast then\n                index = i\n                break\n            end\n        end\n        if accept then\n            for _ = 1, accept do\n                local vote = votes[index]\n                index = index + 1\n                vote.cast = \"accept\"\n                SetTextures(vote, \"/game/recall-panel/recall-accept\")\n            end\n        end\n        if veto then\n            for _ = 1, veto do\n                local vote = votes[index]\n                index = index + 1\n                vote.cast = \"veto\"\n                SetTextures(vote, \"/game/recall-panel/recall-veto\")\n            end\n        end\n    end;\n\n    OnFrame = function(self, delta)\n        local slide = self.Slide\n        local notAnimating = true\n        if slide ~= nil then\n            local newTop = self.t.Top()\n            local topLimit = self.parent.Top()\n            if slide then\n                newTop = newTop - 500 * delta\n                topLimit = topLimit - self:TotalHeight()\n                if newTop < topLimit then\n                    newTop = topLimit\n                    self:Hide()\n                    self:SetNeedsFrameUpdate(false)\n                    self.Slide = nil\n                end\n            else\n                newTop = newTop + 500 * delta + 4\n                if newTop > topLimit then\n                    newTop = topLimit\n                    self.Slide = nil\n                end\n            end\n            self.Top:Set(newTop + self.t.Height())\n            notAnimating = false\n        end\n\n        local time = self.startTime()\n        if time > 0 then\n            local dur = self.duration\n            time = GetGameTimeSeconds() - time\n            local nominalWidth = self.Width() - LayoutHelpers.ScaleNumber(16)\n            if time >= dur then\n                self.startTime:Set(-9999)\n                self.progressBar.Width:Set(0)\n            else\n                self.progressBar.Width:Set((1 - time / dur) * nominalWidth)\n            end\n            notAnimating = false\n        end\n        if notAnimating then\n            self:SetNeedsFrameUpdate(false)\n        end\n    end;\n\n    OnResultsReviewed = function(self)\n        local collapse = self.collapseArrow\n        collapse:Disable()\n        collapse:SetCheck(true)\n    end;\n\n    OnVoteAccepted = function(self)\n        import(\"/lua/ui/game/announcement.lua\").CreateAnnouncement(LOC(\"<LOC diplomacy_0021>The recall vote was accepted.\"))\n        self.label:SetText(LOC(\"<LOC diplomacy_0023>Recalling...\"))\n    end;\n\n    OnVoteVetoed = function(self)\n        import(\"/lua/ui/game/announcement.lua\").CreateAnnouncement(LOC(\"<LOC diplomacy_0022>The recall vote was vetoed.\"))\n        self.label:SetText(LOC(\"<LOC diplomacy_0024>Not ready for recall\"))\n    end;\n\n    OnHide = function(self, hide)\n        local supress = import(\"/lua/ui/game/gamecommon.lua\").SupressShowingWhenRestoringUI(self, hide)\n        local collapse = self.collapseArrow\n        if collapse then\n            if supress or collapse:IsDisabled() then\n                collapse:Hide()\n                if not hide then\n                    supress = true\n                end\n            else\n                collapse:Show()\n            end\n        end\n        return supress\n    end;\n\n    HandleEvent = function(self, event)\n        if event.Type == \"ButtonPress\" and event.Modifiers.Middle then\n            local drag = Dragger()\n            local offX = event.MouseX - self.Left()\n            drag.OnMove = function(dragself, x, y)\n                self.Left:Set(math.min(math.max(x - offX, self.parent.Left()), self.parent.Right() - self.Width()))\n                GetCursor():SetTexture(UIUtil.GetCursor(\"W_E\"))\n            end\n            drag.OnRelease = function()\n                self:SavePosition()\n                GetCursor():Reset()\n                drag:Destroy()\n            end\n            PostDragger(self:GetRootFrame(), event.KeyCode, drag)\n            return true\n        end\n        return false\n    end;\n\n    LoadPosition = function(self)\n        return Prefs.GetFromCurrentProfile(\"RecallPanelPos\") or {\n            left = 800,\n        }\n    end;\n\n    SavePosition = function(self)\n        Prefs.SetToCurrentProfile(\"RecallPanelPos\", {\n            left = LayoutHelpers.InvScaleNumber(self.Left()),\n        })\n    end;\n}\n"], "fixing_code": ["---@declare-global\n-- The global sync table is copied to the user layer every time the main and sim threads are\n-- synchronized on the sim beat (which is like a tick but happens even when the game is paused)\nSync = {}\n\n-- UnitData that has been synced. We keep a separate copy of this so when we change\n-- focus army we can resync the data.\nUnitData = {}\n\nSimUnitEnhancements = {}\n\nfunction ResetSyncTable()\n    Sync = {\n        -- A list of camera control operations that we'd like the user layer to perform.\n        CameraRequests = {},\n        Sounds = {},\n        Voice = {},\n        AIChat = {},\n\n        -- Table of army indices set to \"victory\" or \"defeat\".\n        -- It's the user layer's job to determine if any UI needs to be shown\n        -- for the focus army.\n        GameResult = {},\n\n        -- Player to player queries that can affect the Sim\n        PlayerQueries = {},\n        QueryResults = {},\n\n        -- Contain operation data when op is complete\n        OperationComplete = nil,\n\n        UnitData = {},\n        ReleaseIds = {},\n\n        -- contains the current score for each army\n        Score = {},\n        ScoreAccum = {},\n\n        Reclaim = {}\n    }\nend\n\nfunction AddUnitEnhancement(unit, enhancement, slot)\n    if not slot then return end\n    local id = unit.EntityId\n    SimUnitEnhancements[id] = SimUnitEnhancements[id] or {}\n    SimUnitEnhancements[id][slot] = enhancement\n    SyncUnitEnhancements()\nend\n\nfunction RemoveUnitEnhancement(unit, enhancement)\n    if not unit or unit.Dead then return end\n    local id = unit.EntityId\n    local slots = SimUnitEnhancements[id]\n    if not slots then return end\n    local key = nil\n    for k, v in slots do\n        if v == enhancement then\n            key = k\n            break\n        end\n    end\n\n    if not key then return end\n    SimUnitEnhancements[id][key] = nil\n    if table.empty(slots) then\n        SimUnitEnhancements[id] = nil\n    end\n    SyncUnitEnhancements()\nend\n\nfunction RemoveAllUnitEnhancements(unit)\n    local id = unit.EntityId\n    if not SimUnitEnhancements[id] then return end\n    SimUnitEnhancements[id] = nil\n    SyncUnitEnhancements()\nend\n\nfunction SyncUnitEnhancements()\n    import(\"/lua/enhancementcommon.lua\").SetEnhancementTable(SimUnitEnhancements)\n    local sync = {}\n\n    for id, slots in SimUnitEnhancements do\n        local unit = GetEntityById(id)\n        local me = GetFocusArmy()\n        if unit and (me == -1 or IsAlly(me, unit.Army)) then\n            sync[id] = slots\n        end\n    end\n\n    Sync.UserUnitEnhancements = sync\nend\n\nfunction DebugMoveCamera(x0,y0,x1,y1)\n    local Camera = import(\"/lua/simcamera.lua\").SimCamera\n    local cam = Camera(\"WorldCamera\")\n--    cam:ScaleMoveVelocity(0.02)\n    cam:MoveTo(Rect(x0,y0,x1,y1),5.0)\nend\n\nfunction SyncPlayableRect(rect)\n    local Camera = import(\"/lua/simcamera.lua\").SimCamera\n    local cam = Camera(\"WorldCamera\")\n    cam:SyncPlayableRect(rect)\nend\n\nfunction LockInput()\n    Sync.LockInput = true\nend\n\nfunction UnlockInput()\n    Sync.UnlockInput = true\nend\n\nfunction OnPostLoad()\n    local focus = GetFocusArmy()\n    for entityID, data in UnitData do\n        if data.OwnerArmy == focus or focus == -1 then\n            Sync.UnitData[entityID] = data.Data\n        end\n    end\n    Sync.IsSavedGame = true\nend\n\nfunction NoteFocusArmyChanged(new, old)\n    --LOG('NoteFocusArmyChanged(new=' .. repr(new) .. ', old=' .. repr(old) .. ')')\n    import(\"/lua/simping.lua\").OnArmyChange()\n    import(\"/lua/sim/recall.lua\").OnArmyChange()\n    for entityID, data in UnitData do\n        if new == -1 or data.OwnerArmy == new then\n            Sync.UnitData[entityID] = data.Data\n        elseif old == -1 or data.OwnerArmy == old then\n            Sync.ReleaseIds[entityID] = true\n        end\n    end\n    SyncUnitEnhancements()\n    Sync.FocusArmyChanged = {new = new, old = old}\nend\n\nfunction FloatingEntityText(entityId, text)\n    if not entityId and text then\n        WARN('Trying to float entity text with no entityId or no text.')\n        return false\n    else\n        if GetEntityById(entityId).Army == GetFocusArmy() then\n            if not Sync.FloatingEntityText then Sync.FloatingEntityText = {} end\n            table.insert(Sync.FloatingEntityText, {entity = entityId, text = text})\n        end\n    end\nend\n\nfunction StartCountdown(entityId, duration)\n    cdDuration = duration or 5\n    if not entityId then\n        WARN('Trying to start countdown text with no entityId.')\n        return false\n    else\n        if GetEntityById(entityId).Army == GetFocusArmy() then\n            if not Sync.StartCountdown then Sync.StartCountdown = {} end\n            table.insert(Sync.StartCountdown, {entity = entityId, duration = cdDuration})\n        end\n    end\nend\n\nfunction CancelCountdown(entityId)\n    if not entityId then\n        WARN('Trying to Cancel Countdown text with no entityId.')\n        return false\n    else\n        if GetEntityById(entityId).Army == GetFocusArmy() then\n            if not Sync.CancelCountdown then Sync.CancelCountdown = {} end\n            table.insert(Sync.CancelCountdown, {entity = entityId})\n        end\n    end\nend\n\nfunction HighlightUIPanel(panel)\n    if not Sync.HighlightUIPanel then Sync.HighlightUIPanel = {} end\n    table.insert(Sync.HighlightUIPanel, panel)\nend\n\nfunction ChangeCameraZoom(newMult)\n    Sync.ChangeCameraZoom = newMult\nend\n\nfunction CreateCameraMarker(position)\n    return import(\"/lua/simcameramarkers.lua\").AddCameraMarker(position)\nend\n\nfunction EndDemo()\n    Sync.EndDemo = true\nend\n\nfunction PrintText(text, fontSize, fontColor, duration, location)\n    if not text and location then\n        WARN('Trying to print text with no string or no location.')\n        return false\n    else\n        if not Sync.PrintText then Sync.PrintText = {} end\n        table.insert(Sync.PrintText, {text = text, size = fontSize, color = fontColor, duration = duration, location = location})\n    end\nend\n\nfunction CreateDialogue(text, buttonText, position)\n    return import(\"/lua/simdialogue.lua\").Create(text, buttonText, position)\nend\n", "-- Copyright \u00a9 2005 Gas Powered Games, Inc.  All rights reserved.\n--\n-- General Sim scripts\n\n-- ==============================================================================\n-- Diplomacy\n-- ==============================================================================\n\nlocal CreateWreckage = import(\"/lua/wreckage.lua\").CreateWreckage\n\nlocal transferUnbuiltCategory = categories.EXPERIMENTAL + categories.TECH3 * categories.STRUCTURE * categories.ARTILLERY\nlocal transferUnitsCategory = categories.ALLUNITS - categories.INSIGNIFICANTUNIT\nlocal buildersCategory = categories.ALLUNITS - categories.CONSTRUCTION - categories.ENGINEER\n\nlocal sharedUnits = {}\n\n---@param owner number\nfunction KillSharedUnits(owner)\n    local sharedUnitOwner = sharedUnits[owner]\n    if sharedUnitOwner and not table.empty(sharedUnitOwner) then\n        for _, unit in sharedUnitOwner do\n            if not unit.Dead and unit.oldowner == owner then\n                unit:Kill()\n            end\n        end\n        sharedUnits[owner] = {}\n    end\nend\n\n-- used to make more expensive units transfer first, in case there's a unit cap issue\nlocal function TransferUnitsOwnershipComparator(a, b)\n    a = a.Blueprint or a.Blueprint\n    b = b.Blueprint or b.Blueprint\n    return a.Economy.BuildCostMass > b.Economy.BuildCostMass\nend\n\n--- Temporarily disables the weapons of gifted units\n---@param weapon Weapon\nlocal function TransferUnitsOwnershipDelayedWeapons(weapon)\n    if not weapon:BeenDestroyed() then\n        -- compute delay\n        local bp = weapon.Blueprint\n        local delay = 1 / bp.RateOfFire\n        WaitSeconds(delay)\n\n        -- enable the weapon again if it still exists\n        if not weapon:BeenDestroyed() then\n            weapon:SetEnabled(true)\n        end\n    end\nend\n\n--- Transfers units to an army, returning the new units (since changing the army\n--- replaces the units with new ones)\n---@param units Unit[]\n---@param toArmy number \n---@param captured boolean\n---@return Unit[]?\nfunction TransferUnitsOwnership(units, toArmy, captured)\n    local toBrain = GetArmyBrain(toArmy)\n    if not toBrain or toBrain:IsDefeated() or not units or table.empty(units) then\n        return\n    end\n    local categoriesENGINEERSTATION = categories.ENGINEERSTATION\n    local shareUpgrades = ScenarioInfo.Options.Share == 'FullShare'\n\n    -- do not gift insignificant units\n    units = EntityCategoryFilterDown(transferUnitsCategory, units)\n\n    -- gift most valuable units first\n    table.sort(units, TransferUnitsOwnershipComparator)\n\n    local newUnitCount = 0\n    local newUnits = {}\n    local upgradeUnitCount = 0\n    local upgradeUnits = {}\n    local pauseKennelCount = 0\n    local pauseKennels = {}\n    local upgradeKennelCount = 0\n    local upgradeKennels = {}\n\n    for _, unit in units do\n        local owner = unit.Army\n        -- Only allow units not attached to be given. This is because units will give all of its\n        -- children over as well, so we only want the top level units to be given.\n        -- Units currently being captured are also denied\n        if  owner == toArmy or\n            unit:GetParent() ~= unit or (unit.Parent and unit.Parent ~= unit) or\n            unit.CaptureProgress > 0 or\n            unit:GetFractionComplete() < 1.0\n        then\n            continue\n        end\n\n        local bp = unit.Blueprint\n        local bpPhysics = bp.Physics\n        local categoriesHash = bp.CategoriesHash\n\n        -- B E F O R E\n        local numNukes = unit:GetNukeSiloAmmoCount() -- nuclear missiles; SML or SMD\n        local numTacMsl = unit:GetTacticalSiloAmmoCount()\n        local unitSync = unit.Sync\n        local massKilled = unitSync.totalMassKilled\n        local massKilledTrue = unitSync.totalMassKilledTrue\n        local unitHealth = unit:GetHealth()\n        local shieldIsOn = false\n        local shieldHealth = 0\n        local hasFuel = false\n        local fuelRatio = 0\n        local activeEnhancements\n        local oldowner = unit.oldowner\n        local upgradesTo = unit.UpgradesTo\n        local defaultBuildRate\n        local upgradeBuildTimeComplete\n        local exclude\n\n        local shield = unit.MyShield\n        if shield then\n            shieldIsOn = unit:ShieldIsOn()\n            shieldHealth = shield:GetHealth()\n        end\n        local fuelUseTime = bpPhysics.FuelUseTime\n        if fuelUseTime and fuelUseTime > 0 then   -- going through the BP to check for fuel\n            fuelRatio = unit:GetFuelRatio()       -- usage is more reliable then unit.HasFuel\n            hasFuel = true                        -- cause some buildings say they use fuel\n        end\n        local enhancements = bp.Enhancements\n        if enhancements then\n            local unitEnh = SimUnitEnhancements[unit.EntityId]\n            if unitEnh then\n                activeEnhancements = {}\n                for i, enh in unitEnh do\n                    activeEnhancements[i] = enh\n                end\n                if not activeEnhancements[1] then\n                    activeEnhancements = nil\n                end\n            end\n        end\n\n        if categoriesHash.ENGINEERSTATION and categoriesHash.UEF then\n            -- We have to kill drones which are idling inside Kennel at the moment of transfer\n            -- otherwise additional dummy drone will appear after transfer\n            for _, drone in unit:GetCargo() do\n                drone:Destroy()\n            end\n        end\n\n        if unit.TransferUpgradeProgress and shareUpgrades then\n            local progress = unit:GetWorkProgress()\n            local upgradeBuildTime = unit.UpgradeBuildTime\n\n            defaultBuildRate = unit:GetBuildRate()\n\n            if progress > 0.05 then --5%. EcoManager & auto-paused mexes etc.\n                upgradeBuildTimeComplete = upgradeBuildTime * progress\n            end\n        end\n\n        unit.IsBeingTransferred = true\n\n        -- changing owner\n        unit = ChangeUnitArmy(unit, toArmy)\n        if not unit then\n            continue\n        end\n\n        newUnitCount = newUnitCount + 1\n        newUnits[newUnitCount] = unit\n\n        if IsAlly(owner, toArmy) then\n            if not oldowner then\n                oldowner = owner\n            end\n\n            local sharedUnitsTable = sharedUnits[oldowner]\n            if not sharedUnitsTable then\n                sharedUnitsTable = {}\n                sharedUnits[oldowner] = sharedUnitsTable\n            end\n            table.insert(sharedUnitsTable, unit)\n        end\n\n        unit.oldowner = oldowner\n\n        -- A F T E R\n        if massKilled and massKilled > 0 then\n            unit:CalculateVeterancyLevelAfterTransfer(massKilled, massKilledTrue)\n        end\n        if activeEnhancements then\n            for _, enh in activeEnhancements do\n                unit:CreateEnhancement(enh)\n            end\n        end\n        local maxHealth = unit:GetMaxHealth()\n        if unitHealth > maxHealth then\n            unitHealth = maxHealth\n        end\n        unit:SetHealth(unit, unitHealth)\n        if hasFuel then\n            unit:SetFuelRatio(fuelRatio)\n        end\n        if numNukes and numNukes > 0 then\n            unit:GiveNukeSiloAmmo(numNukes - unit:GetNukeSiloAmmoCount())\n        end\n        if numTacMsl and numTacMsl > 0 then\n            unit:GiveTacticalSiloAmmo(numTacMsl - unit:GetTacticalSiloAmmoCount())\n        end\n        local newShield = unit.MyShield\n        if newShield then\n            newShield:SetHealth(unit, shieldHealth)\n            if shieldIsOn then\n                unit:EnableShield()\n            else\n                unit:DisableShield()\n            end\n        end\n        if EntityCategoryContains(categoriesENGINEERSTATION, unit) then\n            if not upgradeBuildTimeComplete or not shareUpgrades then\n                if categoriesHash.UEF then\n                    -- use special thread for UEF Kennels\n                    -- Give them 1 tick to spawn their drones and then pause both station and drone\n                    pauseKennelCount = pauseKennelCount + 1\n                    pauseKennels[pauseKennelCount] = unit\n                else -- pause cybran hives immediately\n                    unit:SetPaused(true)\n                end\n            elseif categoriesHash.UEF then\n                unit.UpgradesTo = upgradesTo\n                unit.DefaultBuildRate = defaultBuildRate\n                unit.TargetUpgradeBuildTime = upgradeBuildTimeComplete\n\n                upgradeKennelCount = upgradeKennelCount + 1\n                upgradeKennels[upgradeKennelCount] = unit\n\n                exclude = true\n            end\n        end\n\n        if upgradeBuildTimeComplete and not exclude then\n            unit.UpgradesTo = upgradesTo\n            unit.DefaultBuildRate = defaultBuildRate\n            unit.TargetUpgradeBuildTime = upgradeBuildTimeComplete\n\n            upgradeUnitCount = upgradeUnitCount + 1\n            upgradeUnits[upgradeUnitCount] =  unit\n        end\n\n        unit.IsBeingTransferred = nil\n\n        if unit.OnGiven then\n            unit:OnGiven(unit)\n        end\n    end\n\n    if not captured then\n        if upgradeUnits[1] then\n            ForkThread(UpgradeUnits, upgradeUnits)\n        end\n        if pauseKennels[1] then\n            ForkThread(PauseTransferredKennels, pauseKennels)\n        end\n        if upgradeKennels[1] then\n            ForkThread(UpgradeTransferredKennels, upgradeKennels)\n        end\n    end\n\n    -- add delay on turning on each weapon \n    for _, unit in newUnits do\n        -- disable all weapons, enable with a delay\n        for k = 1, unit.WeaponCount do\n            local weapon = unit:GetWeapon(k)\n            weapon:SetEnabled(false)\n            weapon:ForkThread(TransferUnitsOwnershipDelayedWeapons)\n        end\n    end\n\n    return newUnits\nend\n\n--- Pauses all drones in `kennels`\n---@param kennels Unit[]\nfunction PauseTransferredKennels(kennels)\n    -- wait for drones to spawn\n    WaitTicks(1)\n\n    for _, unit in kennels do\n        unit:SetPaused(true)\n        local podData = unit.PodData\n        if podData then\n            for _, pod in podData do\n                local podHandle = pod.PodHandle\n                if podHandle then\n                    podHandle:SetPaused(true)\n                end\n            end\n        end\n    end\nend\n\n--- Upgrades `kennels` to their `TargetUpgradeBuildTime` value, allowing for drones to spawn and get paused\n---@param kennels any\nfunction UpgradeTransferredKennels(kennels)\n    WaitTicks(1) -- spawn drones\n\n    for _, unit in kennels do\n        if not unit:BeenDestroyed() then\n            for _, pod in unit.PodData or {} do -- pause Kennels drones\n                local podHandle = pod.PodHandle\n                if podHandle then\n                    podHandle:SetPaused(true)\n                end\n            end\n\n            IssueUpgrade({unit}, unit.UpgradesTo)\n        end\n    end\n\n    WaitTicks(3)\n\n    for _, unit in kennels do\n        if not unit:BeenDestroyed() then\n            unit:SetBuildRate(unit.TargetUpgradeBuildTime * 10)\n            unit:SetConsumptionPerSecondMass(0)\n            unit:SetConsumptionPerSecondEnergy(0)\n        end\n    end\n\n    WaitTicks(1)\n\n    for _, unit in kennels do\n        if not unit:BeenDestroyed() then\n            unit:SetBuildRate(unit.DefaultBuildRate)\n            unit:SetPaused(true) -- `SetPaused` updates ConsumptionPerSecond values\n            unit.TargetUpgradeBuildTime = nil\n            unit.DefaultBuildRate = nil\n        end\n    end\nend\n\n--- Takes the units and tries to rebuild them for each army (in order). \n--- The transfer procedure is fairly expensive, so it is filtered to important units (EXPs and T3 arty).\n---@param units Unit[]\n---@param armies Army[]\nfunction TransferUnfinishedUnitsAfterDeath(units, armies)\n    local unbuiltUnits = {}\n    local unbuiltUnitCount = 0\n    for _, unit in EntityCategoryFilterDown(transferUnbuiltCategory, units) do\n        if unit:IsBeingBuilt() then\n            unbuiltUnitCount = unbuiltUnitCount + 1\n            unbuiltUnits[unbuiltUnitCount] = unit\n        end\n    end\n    if not (unbuiltUnits[1] and armies[1]) then\n        return\n    end\n    RebuildUnits(unbuiltUnits, armies)\nend\n\n--- Upgrades `units` to `UpgradesTo` at their `TargetUpgradeBuildTime` values (defaulting to\n--- `UpgradeBuildTime`, i.e. completion) and resets the build rate to `DefaultBuildRate` (defaulting\n--- to the build rate at the start)\n---@param units Unit[]\nfunction UpgradeUnits(units)\n    for _, unit in units do\n        IssueUpgrade({unit}, unit.UpgradesTo)\n        if not unit.DefaultBuildRate then\n            unit.DefaultBuildRate = unit:GetBuildRate()\n        end\n        unit:SetBuildRate(0)\n    end\n\n    WaitTicks(3)\n\n    for _, unit in units do\n        if not unit:BeenDestroyed() then\n            local targetUpgradeBuildTime = unit.TargetUpgradeBuildTime or unit.UpgradeBuildTime\n            unit:SetBuildRate(targetUpgradeBuildTime * 10)\n            unit:SetConsumptionPerSecondMass(0)\n            unit:SetConsumptionPerSecondEnergy(0)\n        end\n    end\n\n    WaitTicks(1)\n\n    for _, unit in units do\n        if not unit:BeenDestroyed() then\n            unit:SetBuildRate(unit.DefaultBuildRate)\n            unit:SetPaused(true) -- `SetPaused` updates ConsumptionPerSecond values\n            unit.TargetUpgradeBuildTime = nil\n            unit.DefaultBuildRate = nil\n        end\n    end\nend\n\n--- Rebuilds `units`, giving a try for each army (in order) in case they can't for unit cap\n--- reasons. If a unit cannot be rebuilt at all, a wreckage is placed instead. Each unit can\n--- be tagged with `TargetFractionComplete` to be rebuilt with a different build progress.\n---@see AddConstructionProgress # doesn't destroy and rebuild the unit\n---@param units Unit[]\n---@param armies Army[]\nfunction RebuildUnits(units, armies)\n    local trackers, blockingEntities = StartRebuildUnits(units)\n    for _, army in ipairs(armies) do\n        TryRebuildUnits(trackers, army)\n    end\n    FinalizeRebuiltUnits(trackers, blockingEntities)\nend\n\n---@class RebuildTracker\n---@field CanCreateWreck boolean\n---@field Success boolean\n---@field TargetBuildTime number\n---@field UnitBlueprint UnitBlueprint\n---@field UnitBlueprintID string\n---@field UnitHealth number\n---@field UnitID string\n---@field UnitOrientation Quaternion\n---@field UnitPos Vector\n---@field UnitProgress number\n\n---@alias RevertibleCollisionShapeEntity Prop | Unit\n\n--- Initializes the rebuild process for a `unit`. It is destroyed in this method and replaced\n--- with a tracker. Any possible entities that could block construction have their collision\n--- shapes disabled and are placed into `blockingEntities` to be reverted later. A unit can be\n--- tagged with `TargetFractionComplete` to be rebuilt with a different build progress.\n---@param unit Unit\n---@param blockingEntities RevertibleCollisionShapeEntity[]\n---@return RebuildTracker tracker\nfunction CreateRebuildTracker(unit, blockingEntities)\n    local bp = unit.Blueprint\n    local blueprintID = bp.BlueprintId\n    local buildTime = bp.Economy.BuildTime\n    local health = unit:GetHealth()\n    local pos = unit:GetPosition()\n    local progress = unit.TargetFractionComplete or unit:GetFractionComplete()\n\n    local tracker = {\n        -- save all important data because the unit will be destroyed\n        UnitHealth = health,\n        UnitPos = pos,\n        UnitID = unit.EntityId,\n        UnitOrientation = unit:GetOrientation(),\n        UnitBlueprint = bp,\n        UnitBlueprintID = blueprintID,\n        UnitProgress = progress, -- save current progress for some later checks\n        CanCreateWreck = progress > 0.5, -- if rebuilding fails, we have to create a wreck manually\n        TargetBuildTime = progress * buildTime,\n        Success = false,\n    }\n\n    -- wrecks can prevent drone from starting construction\n    local wrecks = GetReclaimablesInRect(unit:GetSkirtRect()) -- returns nil instead of empty table when empty\n    if wrecks then\n        for _, reclaim in wrecks do\n            if reclaim.IsWreckage then\n                -- collision shape to none to prevent it from blocking, keep track to revert later\n                reclaim:SetCollisionShape('None')\n                table.insert(blockingEntities, reclaim)\n            end\n        end\n    end\n\n    -- units can prevent drone from starting construction\n    local nearbyUnits = GetUnitsInRect(unit:GetSkirtRect())\n    if nearbyUnits then\n        for _, nearbyUnit in nearbyUnits do\n            nearbyUnit:SetCollisionShape('None')\n            table.insert(blockingEntities, nearbyUnit)\n        end\n    end\n\n    unit:Destroy()\n\n    return tracker\nend\n\n--- Attempts to rebuild `units` for an `army`, returning the resulting rebuild trackers\n--- and any entities needing their collision shape reverted\n---@param units Unit[]\n---@param trackers? RebuildTracker[]\n---@param blockingEntities? RevertibleCollisionShapeEntity[]\n---@return RebuildTracker[] blockingEntities\n---@return RevertibleCollisionShapeEntity[] blockingEntities\nfunction StartRebuildUnits(units, trackers, blockingEntities)\n    trackers = trackers or {}\n    blockingEntities = blockingEntities or {}\n    for i, unit in ipairs(units) do\n        trackers[i] = CreateRebuildTracker(unit, blockingEntities)\n    end\n    return trackers, blockingEntities\nend\n\n--- Attempts to rebuild units for an `army`, using `trackers`\n---@param trackers RebuildTracker[]\n---@param army Army\nfunction TryRebuildUnits(trackers, army)\n    local rebuilders = {}\n    for k, tracker in ipairs(trackers) do\n        if tracker.Success then\n            continue\n        end\n        -- create invisible drone which belongs to allied army. BuildRange = 10000\n        local rebuilder = CreateUnitHPR('ZXA0001', army, 5, 20, 5, 0, 0, 0)\n        rebuilder.TargetBuildTime = tracker.TargetBuildTime\n        rebuilders[k] = rebuilder\n\n        IssueBuildMobile({rebuilder}, tracker.UnitPos, tracker.UnitBlueprintID, {})\n    end\n\n    WaitTicks(3) -- wait some ticks (3 is minimum), IssueBuildMobile() is not instant\n\n    for k, rebuilder in rebuilders do\n        rebuilder:SetBuildRate(rebuilder.TargetBuildTime * 10) -- set crazy build rate and consumption = 0\n        rebuilder:SetConsumptionPerSecondMass(0)\n        rebuilder:SetConsumptionPerSecondEnergy(0)\n    end\n\n    WaitTicks(1)\n\n    for k, rebuilder in ipairs(rebuilders) do\n        local tracker = trackers[k]\n        local newUnit = rebuilder:GetFocusUnit()\n        local progressDif = rebuilder:GetWorkProgress() - tracker.UnitProgress\n        if newUnit and math.abs(progressDif) < 0.001 then\n            newUnit:SetHealth(newUnit, tracker.UnitHealth)\n            tracker.Success = true\n        end\n        rebuilder:Destroy()\n    end\nend\n\n--- Finalizes the unit rebuilding process. Any failed rebuilding attempts are replaced with\n--- wreckage and all blocking entities have their collision shapes reverted.\n---@param trackers RebuildTracker[]\n---@param blockingEntities RevertibleCollisionShapeEntity[]\nfunction FinalizeRebuiltUnits(trackers, blockingEntities)\n    for _, tracker in trackers do\n        if not tracker.Success and tracker.CanCreateWreck then -- create 50% wreck. Copied from Unit:CreateWreckageProp()\n            local bp = tracker.UnitBlueprint\n            local pos = tracker.UnitPos\n            local orientation = tracker.UnitOrientation\n            local mass = bp.Economy.BuildCostMass * 0.57 --0.57 to compensate some multipliers in CreateWreckage()\n            local energy = 0\n            local time = (bp.Wreckage.ReclaimTimeMultiplier or 1) * 2\n            CreateWreckage(bp, pos, orientation, mass, energy, time)\n        end\n    end\n\n    -- revert collision shapes of any blocking units or wreckage\n    for _, entity in blockingEntities do\n        if not entity:BeenDestroyed() then\n            entity:RevertCollisionShape()\n        end\n    end\nend\n\n---@param data {To: number}\n---@param units Unit[]\nfunction GiveUnitsToPlayer(data, units)\n    local manualShare = ScenarioInfo.Options.ManualUnitShare\n    if manualShare == 'none' then\n        return\n    end\n    local toArmy = data.To\n\n    if units then\n        local owner = units[1].Army\n        if OkayToMessWithArmy(owner) and IsAlly(owner, toArmy) then\n            if manualShare == 'no_builders' then\n                local unitsBefore = table.getsize(units)\n                units = EntityCategoryFilterDown(buildersCategory, units)\n                local unitsAfter = table.getsize(units)\n\n                if unitsAfter ~= unitsBefore then\n                    -- Maybe spawn an UI dialog instead?\n                    print((unitsBefore - unitsAfter) .. \" engineers/factories could not be transferred due to manual share rules\")\n                end\n            end\n\n            TransferUnitsOwnership(units, toArmy)\n        end\n    end\nend\n\n---@param data {Army: number, Value: boolean}\nfunction SetResourceSharing(data)\n    local army = data.Army\n    if not OkayToMessWithArmy(army) then\n        return\n    end\n    local brain = GetArmyBrain(army)\n    brain:SetResourceSharing(data.Value)\nend\n\n---@param data {Army: number, Value: boolean}\nfunction RequestAlliedVictory(data)\n    -- You cannot change this in a team game\n    if ScenarioInfo.TeamGame then\n        return\n    end\n    local army = data.Army\n    if not OkayToMessWithArmy(army) then\n        return\n    end\n    local brain = GetArmyBrain(army)\n    brain.RequestingAlliedVictory = data.Value\nend\n\n---@param data {Army: number, Value: boolean}\nfunction SetOfferDraw(data)\n    local army = data.Army\n    if not OkayToMessWithArmy(army) then\n        return\n    end\n    local brain = GetArmyBrain(army)\n    brain.OfferingDraw = data.Value\nend\n\n-- ==============================================================================\n-- UNIT CAP\n-- ==============================================================================\n\n--- Given that `deadArmy` just died, redistributes their unit cap based on the scenario options\n---@param deadArmy number\nfunction UpdateUnitCap(deadArmy)\n    -- If we are asked to share out unit cap for the defeated army, do the following...\n    local options = ScenarioInfo.Options\n    local mode = options.ShareUnitCap\n    if not mode or mode == 'none' then\n        return\n    end\n    local aliveCount = 0\n    local alive = {}\n    local caps = {}\n\n    for index, brain in ArmyBrains do\n        if (mode == 'all' or (mode == 'allies' and IsAlly(deadArmy, index))) and not ArmyIsCivilian(index) then\n            if not brain:IsDefeated() then\n                brain.index = index\n                aliveCount = aliveCount + 1\n                alive[aliveCount] = brain\n                local cap = GetArmyUnitCap(index)\n                caps[aliveCount] = cap\n            end\n        end\n    end\n\n    if aliveCount > 0 then\n        local capChng = GetArmyUnitCap(deadArmy) / aliveCount\n        for i, brain in alive do\n            SetArmyUnitCap(brain.index, caps[i] + capChng)\n        end\n    end\nend\n\n---@param data {Sender: number, Msg: string}\nfunction SendChatToReplay(data)\n    if data.Sender and data.Msg then\n        if not Sync.UnitData.Chat then\n            Sync.UnitData.Chat = {}\n        end\n        table.insert(Sync.UnitData.Chat, {sender = data.Sender, msg = data.Msg})\n    end\nend\n\n---@param data {From: number, To: number, Mass: number, Energy: number}\nfunction GiveResourcesToPlayer(data)\n    SendChatToReplay(data)\n    -- Ignore observers and players trying to send resources to themselves or to enemies\n    if data.From ~= -1 and data.From ~= data.To and IsAlly(data.From, data.To) then\n        if not OkayToMessWithArmy(data.From) then\n            return\n        end\n        local fromBrain = GetArmyBrain(data.From)\n        local toBrain = GetArmyBrain(data.To)\n        -- Abort if any of the armies is defeated or if trying to send a negative value\n        if fromBrain:IsDefeated() or toBrain:IsDefeated() or data.Mass < 0 or data.Energy < 0 then\n            return\n        end\n        local massTaken = fromBrain:TakeResource('Mass', data.Mass * fromBrain:GetEconomyStored('Mass'))\n        local energyTaken = fromBrain:TakeResource('Energy', data.Energy * fromBrain:GetEconomyStored('Energy'))\n\n        toBrain:GiveResource('Mass', massTaken)\n        toBrain:GiveResource('Energy', energyTaken)\n    end\nend\n\n---@param data {From: number, To: number}\nfunction BreakAlliance(data)\n    -- You cannot change alliances in a team game\n    if ScenarioInfo.TeamGame then\n        return\n    end\n\n    if OkayToMessWithArmy(data.From) then\n        SetAlliance(data.From, data.To, \"Enemy\")\n\n        if Sync.BrokenAlliances == nil then\n            Sync.BrokenAlliances = {}\n        end\n        table.insert(Sync.BrokenAlliances, { From = data.From, To = data.To })\n    end\n    import(\"/lua/simping.lua\").OnAllianceChange()\n    import(\"/lua/sim/recall.lua\").OnAllianceChange(data)\nend\n\n---@param resultData {From: number, To: number, ResultValue: DiplomacyActionType}\nfunction OnAllianceResult(resultData)\n    -- You cannot change alliances in a team game\n    if ScenarioInfo.TeamGame then\n        return\n    end\n\n    if OkayToMessWithArmy(resultData.From) then\n        if resultData.ResultValue == \"accept\" then\n            SetAlliance(resultData.From,resultData.To, \"Ally\")\n            if Sync.FormedAlliances == nil then\n                Sync.FormedAlliances = {}\n            end\n            table.insert(Sync.FormedAlliances, { From = resultData.From, To = resultData.To })\n        end\n    end\n    import(\"/lua/simping.lua\").OnAllianceChange()\nend\nimport(\"/lua/simplayerquery.lua\").AddResultListener(\"OfferAlliance\", OnAllianceResult)\n", "\n-- import recall parameters\ndoscript \"/lua/shared/RecallParams.lua\"\n\nlocal SyncAnnouncement = import(\"/lua/simdiplomacy.lua\").SyncAnnouncement\n\n\n---@alias CannotRecallReason false\n---| \"active\"\n---| \"ai\"\n---| \"gate\"\n---| \"request\"\n---| \"scenario\"\n---| \"vote\"\n---| \"observer\"\n\n\nfunction init()\n    -- setup sim recall state in the brains\n    local playerCooldown = PlayerGateCooldown - PlayerRequestCooldown\n    local teamCooldown = PlayerGateCooldown - TeamVoteCooldown\n    for _, brain in ArmyBrains do\n        brain.LastRecallRequestTime = playerCooldown\n        brain.LastRecallVoteTime = teamCooldown\n    end\n\n    -- setup user recall state notifier in this thread\n    SyncRecallStatus()\nend\n\nfunction OnArmyChange()\n    local focus = GetFocusArmy()\n    if focus == -1 then\n        SyncCancelRecallVote()\n        SyncRecallStatus()\n        return\n    end\n    local teamSize = 0\n    local accept, veto = 0, 0\n    local votingThreadBrain\n    for index, brain in ArmyBrains do\n        if IsAlly(focus, index) and not ArmyIsCivilian(index) then\n            -- Found a voting thread. We really do need a better way to handle team data...\n            teamSize = teamSize + 1\n            if brain.Vote ~= nil then\n                if brain.Vote then\n                    accept = accept + 1\n                else\n                    veto = veto + 1\n                end\n            end\n            if brain.recallVotingThread then\n                votingThreadBrain = brain\n            end\n        end\n    end\n    if votingThreadBrain then\n        Sync.RecallRequest = {\n            StartTime = votingThreadBrain.RecallVoteStartTime,\n            Open = VoteTime * 0.1,\n            Blocks = teamSize,\n            Accept = accept,\n            Veto = veto,\n            CanVote = GetArmyBrain(focus).Vote ~= nil,\n        }\n    end\n    SyncRecallStatus()\nend\n\n---@param data {From: number, To: number}\nfunction OnAllianceChange(data)\n    local armyFrom, armyTo = data.From, data.To\n    local oldTeammates = 0\n    local oldTeam = {}\n    local votingThreadBrain\n    for index, ally in ArmyBrains do\n        if (IsAlly(armyFrom, index) or IsAlly(armyTo, index))\n            and not ally:IsDefeated()\n            and not ArmyIsCivilian(index)\n        then\n            oldTeammates = oldTeammates + 1\n            oldTeam[oldTeammates] = ally.Nickname\n            -- Found a voting thread. We really do need a better way to handle team data...\n            if ally.recallVotingThread then\n                votingThreadBrain = ally\n            end\n        end\n    end\n    if votingThreadBrain then\n        SPEW(\"Canceling recall voting for team \" .. table.concat(oldTeam, \", \") .. \" due to alliance break\")\n        votingThreadBrain.VoteCancelled = true\n        coroutine.resume(votingThreadBrain.recallVotingThread)\n        if IsAlly(votingThreadBrain, GetFocusArmy()) then\n            SyncCancelRecallVote()\n            SyncRecallStatus()\n        end\n    end\nend\n\n\n---@param lastTeamVote number\n---@param lastPlayerRequest number\n---@param playerGatein? number\n---@return CannotRecallReason CannotRecallReason\n---@return number? cooldown\nfunction RecallRequestCooldown(lastTeamVote, lastPlayerRequest, playerGatein)\n    -- note that this doesn't always return the reason that currently has the longest cooldown, it\n    -- returns the more \"fundamental\" one (i.e. the reason whose base cooldown is longest)\n    -- this is more useful in reporting the reason, and isn't a problem when put in a loop\n    local gametime = GetGameTick()\n    local gateCooldown = (playerGatein or 0) + PlayerGateCooldown - gametime\n    if gateCooldown > 0 then\n        return \"gate\", gateCooldown\n    end\n    local reqCooldown = lastPlayerRequest + PlayerRequestCooldown - gametime\n    if reqCooldown > 0 then\n        return \"request\", reqCooldown\n    end\n    local voteCooldown = lastTeamVote + TeamVoteCooldown - gametime\n    if voteCooldown > 0 then\n        return \"vote\", voteCooldown\n    end\n    return false\nend\n\n--- Returns the current reason an army cannot request recall and the cooldown of that reason, or\n--- false\n---@param army Army\n---@return CannotRecallReason\n---@return number? cooldown no timeout/cooldown if absent\nfunction ArmyRecallRequestCooldown(army)\n    if army == -1 then\n        return \"observer\"\n    end\n    local brain = GetArmyBrain(army)\n    if ScenarioInfo.RecallDisabled then\n        return \"scenario\"\n    end\n    if brain.RecallVote ~= nil then\n        return \"active\", VoteTime\n    end\n    local lastPlayerRequest = brain.LastRecallRequestTime\n    local lastTeamVote\n    army = brain.Army\n    lastTeamVote = lastPlayerRequest\n    for index, ally in ArmyBrains do\n        if IsAlly(army, index) and not ally:IsDefeated() and not ArmyIsCivilian(index) then\n            if ally.BrainType ~= \"Human\" then\n                return \"ai\"\n            end\n            local allyTeamVote = ally.LastRecallVoteTime\n            if allyTeamVote < lastTeamVote then\n                lastTeamVote = allyTeamVote\n            end\n        end\n    end\n    -- if someone adds a feature that gates in commanders at different times, that time should be\n    -- added as an argument to this method call\n    return RecallRequestCooldown(lastTeamVote, lastPlayerRequest)\nend\n\n---@param requestingArmy number\nlocal function RecallVotingThread(requestingArmy)\n    local requestingBrain = GetArmyBrain(requestingArmy)\n    requestingBrain.RecallVoteStartTime = GetGameTick()\n    WaitTicks(VoteTime) -- may be interrupted if the vote closes or is canceled by an alliance break\n\n    local focus = GetFocusArmy()\n    if requestingBrain.VoteCancelled then\n        if IsAlly(requestingArmy, focus) then\n            SyncCancelRecallVote()\n            SyncRecallStatus()\n        end\n        requestingBrain.VoteCancelled = nil\n        requestingBrain.RecallVoteStartTime = nil\n        requestingBrain.recallVotingThread = nil\n        return\n    end\n\n    local gametick = GetGameTick()\n    local recallAcceptance = 0\n    local teammates = 0\n    local team = {}\n    for index, brain in ArmyBrains do\n        if not brain:IsDefeated() and IsAlly(requestingArmy, brain.Army) and not ArmyIsCivilian(index) then\n            teammates = teammates + 1\n            team[teammates] = brain\n            if brain.RecallVote then\n                recallAcceptance = recallAcceptance + 1\n            end\n            brain.RecallVote = nil\n            brain.LastRecallVoteTime = gametick\n        end\n    end\n    -- this function is found in the recall params file, for those looking\n    local recallAccepted = RecallRequestAccepted(recallAcceptance, teammates)\n    if IsAlly(focus, requestingArmy) then\n        SyncCloseRecallVote(recallAccepted)\n        -- the recall UI will handle the announcement in this case\n    elseif recallAccepted then\n        -- in this case though, we need to handle the announcement\n        SyncAnnouncement {\n            Action = \"recall\",\n            Team = requestingBrain.Nickname,\n        }\n    end\n    local listTeam = team[1].Nickname\n    for i = 2, table.getn(team) do\n        listTeam = listTeam .. \", \" .. team[i].Nickname\n    end\n    if recallAccepted then\n        SPEW(\"Recalling team \" .. listTeam .. \" at the request of \" .. requestingBrain.Nickname .. \" (vote passed \" .. recallAcceptance .. \" to \" .. (teammates - recallAcceptance ) .. \")\")\n        for _, brain in team do\n            brain:RecallAllCommanders()\n        end\n    else\n        SPEW(\"Not recalling team \" .. listTeam .. \" (vote failed \" .. recallAcceptance .. \" to \" .. (teammates - recallAcceptance ) .. \")\")\n        requestingBrain.LastRecallRequestTime = gametick\n    end\n    if IsAlly(requestingArmy, focus) then\n        -- update UI once the cooldown dissipates\n        SyncRecallStatus()\n    end\n    requestingBrain.RecallVoteStartTime = nil\n    requestingBrain.recallVotingThread = nil\nend\n\n---@param army number\n---@param vote boolean\n---@param lastVote boolean\n---@return boolean # if further user sync should happen\nlocal function ArmyVoteRecall(army, vote, lastVote)\n    if lastVote then\n        for index, ally in ArmyBrains do\n            if army ~= index and IsAlly(army, index) and not ally:IsDefeated() then\n                local thread = ally.recallVotingThread\n                if thread then\n                    -- end voting period\n                    coroutine.resume(thread)\n                    break\n                end\n            end\n        end\n    end\n\n    local focus = GetFocusArmy()\n    if focus == -1 or not IsAlly(focus, army) then\n        return false -- don't update the recall panel for votes we aren't a part of or for observers\n    end\n    SyncRecallVote(vote)\n    if army == focus then\n        SyncCannotRequestRecall(\"active\")\n    end\n    return true\nend\n\n---@param army number\n---@param teammates number\nlocal function ArmyRequestRecall(army, teammates)\n    local brain = GetArmyBrain(army)\n    if teammates > 0 then\n        brain.recallVotingThread = ForkThread(RecallVotingThread, army)\n        if ArmyVoteRecall(army, true, false) then\n            SyncOpenRecallVote(teammates + 1, army)\n        end\n    else\n        -- it's just us; recall our army\n        SPEW(\"Recalling \" .. brain.Nickname)\n        brain:RecallAllCommanders()\n\n    end\nend\n\n---@param data {From: number, Vote: boolean}\nfunction SetRecallVote(data)\n    local army = data.From\n    if not OkayToMessWithArmy(army) then\n        return\n    end\n    local focus = GetFocusArmy()\n    if not ScenarioInfo.TeamGame then\n        if army == focus then\n            SyncCannotRequestRecall(\"scenario\")\n        end\n        return\n    end\n    local vote = data.Vote and true or false\n\n    -- determine team voting status\n    local isRequest = true\n    local lastVote = true\n    local teammates = 0\n    local team = {}\n    for index, ally in ArmyBrains do\n        if army ~= index and not ally:IsDefeated() and IsAlly(army, index) and not ArmyIsCivilian(index) then\n            if ally.BrainType ~= \"Human\" then\n                if army == focus then\n                    SyncCannotRequestRecall(\"ai\")\n                end\n                return\n            end\n            local allyHasVoted = ally.RecallVote ~= nil\n            lastVote = lastVote and allyHasVoted -- only the last vote if all allies have also voted\n            isRequest = isRequest and not allyHasVoted -- only the last vote if no allies have voted\n            teammates = teammates + 1\n            team[teammates] = ally.Nickname\n        end\n    end\n\n    local brain = GetArmyBrain(army)\n    if isRequest then\n        -- the player is making a recall request; this will reset their recall request cooldown\n        local reason = ArmyRecallRequestCooldown(army)\n        if reason then\n            if army == focus then\n                SyncCannotRequestRecall(reason)\n            end\n            return\n        end\n        SPEW(\"Army \" .. tostring(army) .. \" is requesting recall for \" .. table.concat(team, ','))\n        brain.RecallVote = vote\n        ArmyRequestRecall(army, teammates)\n    else\n        -- the player is responding to a recall request; we don't count this against their\n        -- individual recall request cooldown\n        SPEW(\"Army \" .. tostring(army) .. \" recall vote: \" .. (vote and \"accept\" or \"veto\"))\n        brain.RecallVote = vote\n        ArmyVoteRecall(army, vote, lastVote)\n    end\nend\n\n\n---@param reason CannotRecallReason\nfunction SyncCannotRequestRecall(reason)\n    local recallSync = Sync.RecallRequest\n    if not recallSync then\n        Sync.RecallRequest = {CannotRequest = reason}\n    else\n        recallSync.CannotRequest = reason\n    end\nend\n\n---@param result boolean\nfunction SyncCloseRecallVote(result)\n    local recallSync = Sync.RecallRequest\n    if not recallSync then\n        Sync.RecallRequest = {Close = result}\n    else\n        recallSync.Close = result\n    end\nend\n\nfunction SyncCancelRecallVote()\n    local recallSync = Sync.RecallRequest\n    if not recallSync then\n        Sync.RecallRequest = {Cancel = true}\n    else\n        recallSync.Cancel = true\n    end\nend\n\n---@param vote boolean\nfunction SyncRecallVote(vote)\n    local recallSync = Sync.RecallRequest\n    if not recallSync then\n        recallSync = {}\n        Sync.RecallRequest = recallSync\n    end\n    if vote then\n        recallSync.Accept = (recallSync.Accept or 0) + 1\n    else\n        recallSync.Veto = (recallSync.Veto or 0) + 1\n    end\nend\n\n---@param teamSize number\n---@param army number\nfunction SyncOpenRecallVote(teamSize, army)\n    local recallSync = Sync.RecallRequest\n    if not recallSync then\n        recallSync = {}\n        Sync.RecallRequest = recallSync\n    end\n    local focus = GetFocusArmy()\n    recallSync.Open = VoteTime * 0.1\n    recallSync.CanVote = focus ~= -1 and army ~= focus\n    recallSync.Blocks = teamSize\nend\n\nlocal UserRecallStatusThread\n\nlocal function SyncRecallStatusThread()\n    local reason, cooldown = ArmyRecallRequestCooldown(GetFocusArmy())\n    while reason do\n        SyncCannotRequestRecall(reason)\n        if not cooldown then\n            UserRecallStatusThread = nil\n            return\n        end\n        -- may be interrupted for various reasons, such as the focus army changing\n        -- this will be fine, we'll pick up the proper cooldown reason anyway and loop again\n        WaitTicks(cooldown)\n\n        reason, cooldown = ArmyRecallRequestCooldown(GetFocusArmy())\n    end\n    SyncCannotRequestRecall(false)\n    UserRecallStatusThread = nil\nend\n\nfunction SyncRecallStatus()\n    if UserRecallStatusThread then\n        coroutine.resume(UserRecallStatusThread) -- force update the existing thread\n    else\n        UserRecallStatusThread = ForkThread(SyncRecallStatusThread)\n    end\nend\n", "--*****************************************************************************\n--* File: lua/modules/ui/game/diplomacy.lua\n--* Summary: UI for the diplomacy control\n--*\n--* Copyright \u00a9 2006 Gas Powered Games, Inc.  All rights reserved.\n--*****************************************************************************\n\n---@alias DiplomacyActionType \"accept\" | \"break\" | \"never\" | \"offer\" | \"reject\"\n\n---@class DiplomacyAction\n---@field Action DiplomacyActionType\n---@field To number army index\n---@field From number army index\n\nlocal Bitmap = import(\"/lua/maui/bitmap.lua\").Bitmap\nlocal UIUtil = import(\"/lua/ui/uiutil.lua\")\nlocal LayoutHelpers = import(\"/lua/maui/layouthelpers.lua\")\nlocal Group = import(\"/lua/maui/group.lua\").Group\nlocal StatusBar = import(\"/lua/maui/statusbar.lua\").StatusBar\nlocal Slider = import(\"/lua/maui/slider.lua\").Slider\nlocal Tooltip = import(\"/lua/ui/game/tooltip.lua\")\nlocal Tabs = import(\"/lua/ui/game/tabs.lua\")\n\nlocal ScaleNumber = LayoutHelpers.ScaleNumber\nlocal Layouter = LayoutHelpers.LayoutFor\nlocal CreateBitmap = UIUtil.CreateBitmap\nlocal CreateBitmapStd = UIUtil.CreateBitmapStd\n\n---@type Group\nlocal parent = false\nlocal shareResources = true\nlocal alliedVictory = true\n\nlocal dialogue = false\nlocal offerQueue = {}\nlocal drawOffered = false\n\n---@type CannotRecallReason\nlocal CannotRequestRecallReason = false\n\nfunction GetCannotRequestRecallReason()\n    return CannotRequestRecallReason\nend\n\nfunction SetCannotRequestRecallReason(canRequest)\n    CannotRequestRecallReason = canRequest\n    if parent then\n        BuildPlayerLines()\n    end\nend\n\nfunction ActionHandler(actions)\n    local armies = GetArmiesTable().armiesTable\n    for _, action in actions do\n        local from = armies[action.From].nickname\n        local actionName = action.Action\n        if actionName == 'offer' then\n            if not dialogue then\n                dialogue = CreateOfferDialogue(action)\n            else\n                table.insert(offerQueue, action)\n            end\n        elseif actionName == 'accept' then\n            Announce(LOC('<LOC diplomacy_0005>%s accepts your alliance.'):format(from))\n        elseif actionName == 'reject' then\n            Announce(LOC('<LOC diplomacy_0006>%s rejects your alliance.'):format(from))\n        elseif actionName == 'never' then\n            Announce(LOC('<LOC diplomacy_0007>%s is now ignoring your requests.'):format(from))\n        elseif actionName == 'break' then\n            Announce(LOC('<LOC diplomacy_0008>Your alliance with %s has been broken.'):format(from))\n        end\n    end\nend\n\nfunction AnnouncementHandler(announcements)\n    local armies = GetArmiesTable().armiesTable\n    for _, announcement in announcements do\n        local announcementName = announcement.Action\n        if announcementName == \"accept\" then\n            Announce(LOC('<LOC diplomacy_0009>%s and %s are now allies.'):format(armies[announcement.From].nickname, armies[announcement.To].nickname))\n        elseif announcementName == \"break\" then\n            Announce(LOC('<LOC diplomacy_0010>%s and %s are no longer allies.'):format(armies[announcement.From].nickname, armies[announcement.To].nickname))\n        elseif announcementName == \"recall\" then\n            Announce(LOC('<LOC diplomacy_0020>Team %s has recalled from battle.'):format(announcement.Team))\n        end\n    end\nend\n\nfunction Announce(msg)\n    Tabs.TabAnnouncement('diplomacy', msg)\n    if parent then\n        BuildPlayerLines()\n    end\nend\n\nfunction CreateOfferDialogue(action)\n    local from = action.From\n    local army = GetArmiesTable().armiesTable[from].nickname\n    return UIUtil.QuickDialog(\n        GetFrame(0),\n        LOC(\"<LOC diplomacy_0004>%s has offered you an alliance.\"):format(army),\n        \"<LOC _Accept>\", function() SendAnswer(from, 'accept') end,\n        \"<LOC _Reject>\", function() SendAnswer(from, 'reject') end,\n        \"<LOC _Never>\",  function() SendAnswer(from, 'never') end,\n        true, {\n            escapeButton = 2,\n            enterButton = 1,\n            worldCover = false,\n            OnlyWorldCover = true,\n        }\n    )\nend\n\nfunction SendAnswer(army, answer)\n    SimCallback({\n        Func = 'DiplomacyHandler',\n        Args = {\n            Action = answer,\n            From = GetFocusArmy(),\n            To = army,\n        },\n    })\n    local i = 1\n    local offer = offerQueue[i]\n    while offer do\n        if offer.From == army then\n            table.remove(offerQueue, i)\n        else\n            i = i + 1\n        end\n        offer = offerQueue[i]\n    end\n    offer = offerQueue[1]\n    if offer then\n        CreateOfferDialogue(offer)\n        table.remove(offerQueue, 1)\n    else\n        dialogue = false\n    end\nend\n\nfunction CreateContent(inParent)\n    parent = Group(inParent)\n\n    BuildPlayerLines()\n\n    LayoutHelpers.SetWidth(parent, 266)\n    parent.OnDestroy = function(self)\n        parent = false\n    end\n\n    return parent\nend\n\nlocal function LayoutMajorAlliedEntry(entry, manualShare)\n    local giveUnitBtn = UIUtil.CreateButtonStd(entry,\n        '/dialogs/toggle_btn/toggle-d',\n        '<LOC diplomacy_0011>Units', 12\n    )\n    giveUnitBtn.label:SetFont(UIUtil.bodyFont, 12)\n    LayoutHelpers.Below(giveUnitBtn, entry.factionIcon, -2)\n    LayoutHelpers.AtLeftIn(giveUnitBtn, entry)\n    Tooltip.AddButtonTooltip(giveUnitBtn, 'dip_give_units')\n    entry.giveUnitBtn = giveUnitBtn\n\n    if manualShare == 'none' then\n        giveUnitBtn:Disable()\n    else\n        giveUnitBtn.OnClick = function(self, modifiers)\n            UIUtil.QuickDialog(GetFrame(0),\n                LOC(\"<LOC unitxfer_0000>Give Selected Units to %s?\"):format(entry.Data.nickname),\n                '<LOC _Yes>',\n                function()\n                    local to = entry.Data.armyIndex\n                    if IsKeyDown('Shift') then\n                        IssueCommand(\"UNITCOMMAND_Script\", {TaskName = 'GiveTask', To = to}, false)\n                    else\n                        SimCallback({\n                            Func = \"GiveUnitsToPlayer\",\n                            Args = {\n                                From = GetFocusArmy(),\n                                To = to,\n                            },\n                        }, true)\n                    end\n                end,\n                '<LOC _No>', nil, nil, nil, nil,\n                {worldCover = false, enterButton = 1, escapeButton = 2}\n            )\n        end\n    end\n\n    local giveResourcesBtn = UIUtil.CreateButtonStd(entry,\n        '/dialogs/toggle_btn/toggle-d',\n        '<LOC diplomacy_0012>Resources', 12\n    )\n    LayoutHelpers.RightOf(giveResourcesBtn, giveUnitBtn)\n    giveResourcesBtn.label:SetFont(UIUtil.bodyFont, 12)\n    Tooltip.AddButtonTooltip(giveResourcesBtn, 'dip_give_resources')\n    entry.giveResourcesBtn = giveResourcesBtn\n\n    giveResourcesBtn.OnClick = function(self, modifiers)\n        CreateShareResourcesDialog(entry)\n    end\nend\n\nlocal function LayoutAlliedEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked, manualShare)\n    if isHuman and not outOfGame then\n        LayoutMajorAlliedEntry(entry, manualShare)\n    end\n\n    if teamsLocked then\n    else\n        if not outOfGame then\n            local breakBtn = UIUtil.CreateButtonStd(entry,\n                \"/dialogs/toggle_btn/toggle-d\",\n                \"<LOC diplomacy_0013>Break\", 12\n            )\n            breakBtn.label:SetFont(UIUtil.bodyFont, 12)\n            LayoutHelpers.Below(breakBtn, entry.factionIcon, -2)\n            LayoutHelpers.AtRightIn(breakBtn, entry)\n            LayoutHelpers.ResetLeft(breakBtn)\n            Tooltip.AddButtonTooltip(breakBtn, \"dip_break_alliance\")\n            entry.breakBtn = breakBtn\n\n            breakBtn.OnClick = function(self, checked)\n                SimCallback({\n                    Func = \"DiplomacyHandler\",\n                    Args = {\n                        Action = \"break\",\n                        From = GetFocusArmy(),\n                        To = armyIndex,\n                    },\n                })\n                ForkThread(function()\n                    WaitSeconds(1)\n                    BuildPlayerLines()\n                end)\n            end\n        end\n    end\nend\n\nlocal function LayoutEnemyEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked)\n    if isHuman and not teamsLocked and not outOfGame then\n        local offerBtn = UIUtil.CreateButtonStd(entry,\n            '/dialogs/toggle_btn/toggle-d',\n            '<LOC diplomacy_0014>Offer', 12\n        )\n        offerBtn.label:SetFont(UIUtil.bodyFont, 12)\n        LayoutHelpers.AtRightBottomIn(offerBtn, entry)\n        Tooltip.AddButtonTooltip(offerBtn, 'dip_offer_alliance')\n        entry.offerBtn = offerBtn\n\n        offerBtn.OnClick = function(self, checked)\n            self:Disable()\n            SimCallback({\n                Func = 'DiplomacyHandler',\n                Args = {\n                    Action = 'offer',\n                    From = GetFocusArmy(),\n                    To = armyIndex,\n                },\n            })\n        end\n    end\nend\n\nlocal function CreateDiplomacyEntry(parent, data, isAlly)\n    local sessionOptions = SessionGetScenarioInfo().Options\n    local isHuman = data.human\n    local outOfGame = data.outOfGame\n    local teamsLocked = sessionOptions and sessionOptions.TeamLock == \"locked\"\n    local manualShare = sessionOptions.ManualUnitShare\n    local armyIndex = data.armyIndex\n\n    local entry = Bitmap(parent)\n    entry.Height:Set(function()\n        local data = entry.Data\n        if (isAlly or isHuman) and not data.outOfGame then\n            return entry.factionIcon.Height() + 12 + ScaleNumber(12)\n        else\n            return entry.factionIcon.Height() + ScaleNumber(4)\n        end\n    end)\n    entry.Width:Set(function() return parent.Width() - 12 end)\n    entry.Depth:Set(function() return parent.Depth() + 10 end)\n    entry:SetSolidColor('00000000')\n    entry.Data = data\n\n    local typeIcon\n    local factionIcon\n    local colorIcon\n    if isHuman then\n        typeIcon = \"/game/options-diplomacy-panel/icon-person\"\n    else\n        typeIcon = \"/game/options-diplomacy-panel/icon-ai\"\n    end\n    if outOfGame then\n        factionIcon = \"/game/unit-over/icon-skull_bmp.dds\"\n        colorIcon = \"ff000000\"\n    else\n        factionIcon = UIUtil.GetFactionIcon(data.faction)\n        colorIcon = data.color\n    end\n\n    typeIcon = CreateBitmapStd(entry, typeIcon)\n    LayoutHelpers.AtLeftIn(typeIcon, entry)\n    entry.typeIcon = typeIcon\n\n    factionIcon = CreateBitmap(entry, factionIcon)\n    LayoutHelpers.RightOf(factionIcon, typeIcon)\n    LayoutHelpers.AtTopIn(factionIcon, entry)\n    entry.factionIcon = factionIcon\n\n    LayoutHelpers.AtVerticalCenterIn(typeIcon, factionIcon)\n\n    colorIcon = UIUtil.CreateBitmapColor(factionIcon, colorIcon)\n    colorIcon.Depth:Set(function() return factionIcon.Depth() - 1 end)\n    LayoutHelpers.FillParent(colorIcon, factionIcon)\n    entry.color = colorIcon\n\n    local name = UIUtil.CreateText(entry, data.nickname, 16, UIUtil.bodyFont)\n    LayoutHelpers.AtRightIn(name, entry)\n    LayoutHelpers.AnchorToRight(name, factionIcon, 5)\n    LayoutHelpers.AtVerticalCenterIn(name, factionIcon)\n    entry.name = name\n\n    if isAlly then\n        LayoutAlliedEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked, manualShare)\n    else\n        LayoutEnemyEntry(entry, armyIndex, isHuman, outOfGame, teamsLocked)\n    end\n\n    return entry\nend\n\nlocal function CreatePlayerGroup(parent, panelFilename, titleLoc, titleColor, controls, controlCount, isAlly)\n    local lineFilename = panelFilename .. \"-line\"\n    local group = UIUtil.CreateVertFillGroup(parent, panelFilename)\n\n    local title = UIUtil.CreateText(group, titleLoc, 18, UIUtil.bodyFont)\n    Layouter(title)\n        :Color(titleColor)\n        :DropShadow(true)\n        :Over(group, 10)\n    title.Left:Set(function() return group.Left() + 8 end)\n    title.Top:Set(function() return group.Top() + 8 end)\n    title.Right:Set(function() return group.Right() - 8 end)\n\n    local entry = CreateDiplomacyEntry(group, controls[1], isAlly)\n    LayoutHelpers.Below(entry, title, 4)\n    local belowEntry = entry\n    local lines = {entry}\n\n    for index = 2, controlCount do\n        local entry = CreateDiplomacyEntry(group, controls[index], isAlly)\n        LayoutHelpers.Below(entry, belowEntry, 4)\n        lines[index] = entry\n\n        local separator = CreateBitmapStd(entry, lineFilename)\n        separator.Left:Set(function() return group.Left() + 6 end)\n        separator.Top:Set(function() return entry.Top() - 4 end)\n        entry.Separator = separator\n\n        belowEntry = entry\n    end\n\n    group.Height:Set(function()\n        return lines[controlCount].Bottom() - title.Top() + 20\n    end)\n    group.title = title\n    group.lines = lines\n\n    return group\nend\n\n\nfunction BuildPlayerLines()\n    local sessionOptions = SessionGetScenarioInfo().Options\n    local focusArmy = GetFocusArmy()\n    if focusArmy == -1 then\n        focusArmy = import(\"/lua/ui/game/gamemain.lua\").OriginalFocusArmy\n        if focusArmy == -1 then\n            return\n        end\n    end\n\n    local group = parent.personalGroup\n    if group then\n        group:Destroy()\n    end\n    group = parent.alliedGroup\n    if group then\n        group:Destroy()\n    end\n    group = parent.enemyGroup\n    if group then\n        group:Destroy()\n    end\n\n    local allyControls = {}\n    local allyCount = 0\n    local enemyControls = {}\n    local enemyCount = 0\n    local allHumanGame = true\n\n    for index, playerInfo in GetArmiesTable().armiesTable do\n        if playerInfo.civilian or index == focusArmy then continue end\n        playerInfo.armyIndex = index\n        if IsAlly(focusArmy, index) then\n            allyCount = allyCount + 1\n            allyControls[allyCount] = playerInfo\n        else\n            enemyCount = enemyCount + 1\n            enemyControls[enemyCount] = playerInfo\n        end\n        if allHumanGame and not (playerInfo.human or playerInfo.outOfGame) then\n            allHumanGame = false\n        end\n    end\n\n    local belowEntry = parent\n\n    local reason = GetCannotRequestRecallReason()\n    if not import(\"/lua/ui/campaign/campaignmanager.lua\").campaignMode and reason ~= \"observer\" then\n        local personalGroup = CreateBitmapStd(parent, \"/game/options-diplomacy-panel/panel-recall\")\n        if belowEntry == parent then\n            LayoutHelpers.AtLeftTopIn(personalGroup, belowEntry, 0, 8)\n        else\n            LayoutHelpers.Below(personalGroup, belowEntry, 8)\n        end\n        parent.personalGroup = personalGroup\n\n        local recallButton = UIUtil.CreateButtonStd(personalGroup, \"/widgets02/small\")\n        Layouter(recallButton)\n            :AtCenterIn(personalGroup)\n            :Over(personalGroup, 5)\n        personalGroup.button = recallButton\n\n        if reason then\n            recallButton:Disable()\n            Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request_dis_\" .. reason)\n        else\n            local function OnAcceptRecall()\n                SimCallback({\n                    Func = \"SetRecallVote\",\n                    Args = {\n                        From = GetFocusArmy(),\n                        Vote = true,\n                    },\n                })\n                -- preemptively expect the sim to accept our recall and disable the button so we\n                -- can't possiblely confuse the sim with more than one request\n                -- note that if--for some reason (*ahem* due to a mod maybe)--the sim *doesn't*\n                -- end up accepting it, then we'll be stuck until the sim sends a new update\n                recallButton:Disable()\n                SetCannotRequestRecallReason(\"active\")\n                Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request_dis_active\")\n                import(\"/lua/ui/game/tabs.lua\").CollapseWindow()\n            end\n            recallButton.OnClick = function(self, modifiers)\n                UIUtil.QuickDialog(GetFrame(0),\n                    \"<LOC diplomacy_0019>Are you sure you're ready to recall from battle? This will send a request to your team.\",\n                    \"<LOC _Yes>\",\n                    OnAcceptRecall,\n                    \"<LOC _No>\", nil, nil, nil, nil,\n                    {worldCover = false, enterButton = 1, escapeButton = 2}\n                )\n            end\n            Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request\")\n        end\n\n        local recallIcon = CreateBitmapStd(recallButton, \"/game/recall-panel/icon-recall\")\n        Layouter(recallIcon)\n            --:DisableHitTest()\n            :AtCenterIn(recallButton)\n            :Over(recallButton, 5)\n        recallButton.label = recallIcon\n\n        belowEntry = personalGroup\n    end\n\n    if allyCount > 0 then\n        local allyGroup = CreatePlayerGroup(parent,\n            \"/game/options-diplomacy-panel/panel-allies\",\n            \"<LOC diplomacy_0002>Allies\", \"ff00ff72\",\n            allyControls, allyCount, true\n        )\n        if belowEntry == parent then\n            LayoutHelpers.AtLeftTopIn(allyGroup, belowEntry, 0, 8)\n        else\n            LayoutHelpers.Below(allyGroup, belowEntry, 8)\n        end\n        parent.alliedGroup = allyGroup\n\n        local allyTitle = allyGroup.title\n\n        local srCheck = UIUtil.CreateCheckboxStd(allyTitle, '/game/toggle_btn/toggle')\n        srCheck:SetCheck(shareResources, true)\n        LayoutHelpers.AtRightIn(srCheck, allyTitle)\n        srCheck.Top:Set(function() return allyGroup.Top() + 4 end)\n        Tooltip.AddCheckboxTooltip(srCheck, 'dip_share_resources')\n        allyTitle.srCheck = srCheck\n\n        local icon = CreateBitmapStd(srCheck, \"/game/toggle_btn/icon-shared-resources\")\n        icon:DisableHitTest()\n        LayoutHelpers.AtCenterIn(icon, srCheck)\n        srCheck.label = icon\n\n        if sessionOptions.TeamLock == \"unlocked\" then\n            local avCheck = UIUtil.CreateCheckboxStd(allyTitle, \"/game/toggle_btn/toggle\")\n            avCheck:SetCheck(alliedVictory, true)\n            LayoutHelpers.LeftOf(avCheck, srCheck)\n            Tooltip.AddCheckboxTooltip(avCheck, \"dip_allied_victory\")\n            allyTitle.avCheck = avCheck\n\n            icon = CreateBitmapStd(avCheck, \"/game/toggle_btn/icon-allied-victory\")\n            icon:DisableHitTest()\n            LayoutHelpers.AtCenterIn(icon, avCheck)\n            avCheck.label = icon\n\n            avCheck.OnCheck = function(self, checked)\n                alliedVictory = checked\n                SimCallback({\n                    Func = \"RequestAlliedVictory\",\n                    Args = {\n                        Army = GetFocusArmy(),\n                        Value = checked,\n                    },\n                })\n            end\n        end\n\n        belowEntry = allyGroup._bottom\n\n        srCheck.OnCheck = function(self, checked)\n            shareResources = checked\n            SimCallback({\n                Func = \"SetResourceSharing\",\n                Args = {\n                    Army = GetFocusArmy(),\n                    Value = checked,\n                },\n            })\n        end\n    end\n\n    if enemyCount > 0 then\n        local enemyGroup = CreatePlayerGroup(parent,\n            \"/game/options-diplomacy-panel/panel-enemy\",\n            \"<LOC diplomacy_0003>Enemies\", \"ffff3c00\",\n            enemyControls, enemyCount, false\n        )\n        if belowEntry == parent then\n            LayoutHelpers.AtLeftTopIn(enemyGroup, belowEntry, 0, 8)\n        else\n            LayoutHelpers.Below(enemyGroup, belowEntry, 8)\n        end\n        parent.enemyGroup = enemyGroup\n\n        local enemyTitle = enemyGroup.title\n\n        if allHumanGame then\n            local odCheck = UIUtil.CreateCheckboxStd(enemyTitle, \"/dialogs/toggle_btn/toggle\")\n            odCheck:SetCheck(drawOffered, true)\n            odCheck.Top:Set(function() return enemyGroup.Top() + 4 end)\n            LayoutHelpers.AtRightIn(odCheck, enemyTitle)\n            Tooltip.AddCheckboxTooltip(odCheck, 'dip_offer_draw')\n            enemyTitle.odCheck = odCheck\n\n            odCheck.label = UIUtil.CreateText(odCheck, \"<LOC _Draw>Draw\", 12, UIUtil.bodyFont)\n            LayoutHelpers.AtCenterIn(odCheck.label, odCheck)\n\n            odCheck.OnCheck = function(self, checked)\n                drawOffered = checked\n                SimCallback({\n                    Func = \"SetOfferDraw\",\n                    Args = {\n                        Army = GetFocusArmy(),\n                        Value = checked,\n                    },\n                })\n                local msg = '<LOC diplomacy_0000>has offered a draw.'\n                if not checked then\n                    msg = '<LOC diplomacy_0001>has rescinded their draw offer.'\n                end\n                SessionSendChatMessage({to = 'all', ConsoleOutput = msg})\n            end\n        end\n\n        belowEntry = enemyGroup._bottom\n    end\n\n    LayoutHelpers.AtBottomIn(parent, belowEntry, 14)\nend\n\nfunction CreateShareResourcesDialog(control)\n    local giveResGroup = control.giveResourcesGroup\n    if giveResGroup then\n        giveResGroup:Destroy()\n        control.giveResourcesGroup = false\n        control.Height:Set(control.OrigHeight)\n        control.OrigHeight = nil\n    else\n        control.OrigHeight = control.Height()\n\n        giveResGroup = Group(control)\n        giveResGroup.Width:Set(control.Width)\n        LayoutHelpers.SetHeight(giveResGroup, 90)\n        LayoutHelpers.AtLeftBottomIn(giveResGroup, control)\n        control.giveResourcesGroup = giveResGroup\n\n        local okBtn = UIUtil.CreateButtonStd(giveResGroup,\n            '/dialogs/toggle_btn/toggle-d',\n            '<LOC _Ok>', 12\n        )\n        LayoutHelpers.AtBottomIn(okBtn, giveResGroup)\n        okBtn.Left:Set(function()\n            local giveResGroup = control.giveResourcesGroup\n            return giveResGroup.Left() + giveResGroup.Width() * 0.25 - okBtn.Width() * 0.5\n        end)\n\n        local cancelBtn = UIUtil.CreateButtonStd(giveResGroup,\n            '/dialogs/toggle_btn/toggle-d',\n            '<LOC _Cancel>', 12\n        )\n        LayoutHelpers.AtBottomIn(cancelBtn, giveResGroup)\n        cancelBtn.Left:Set(function()\n            local giveResGroup = control.giveResourcesGroup\n            return giveResGroup.Left() + giveResGroup.Width() * 0.75 - okBtn.Width() * 0.5\n        end)\n\n        local massStatus = StatusBar(giveResGroup, 0, 100, false, false,\n            UIUtil.UIFile('/game/resource-bars/mini-mass-bar-back_bmp.dds'),\n            UIUtil.UIFile('/game/resource-bars/mini-mass-bar_bmp.dds'), false\n        )\n        massStatus.Left:Set(giveResGroup.Left)\n        LayoutHelpers.AtRightTopIn(massStatus, giveResGroup, 50, 10)\n\n        local massSlider = Slider(giveResGroup, false, 0, 100,\n            UIUtil.UIFile('/game/slider-btn/slider-mass_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-mass_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-mass_btn_up.dds')\n        )\n        LayoutHelpers.AtVerticalCenterIn(massSlider, massStatus)\n        massSlider.Left:Set(giveResGroup.Left)\n        massSlider:SetValue(0)\n        LayoutHelpers.AtRightIn(massSlider, giveResGroup, 50)\n\n        massInput = UIUtil.CreateText(giveResGroup, '0%', 16, UIUtil.bodyFont)\n        massInput:SetColor('ff00ff00')\n        LayoutHelpers.RightOf(massInput, massStatus, 5)\n\n        massSlider.OnValueChanged = function(self, newValue)\n            massInput:SetText(string.format(\"%d%%\", math.max(math.min(math.floor(newValue), 100), 0)))\n            massStatus:SetValue(math.floor(newValue))\n        end\n        massStatus.Depth:Set(function() return massSlider.Depth() - 1 end)\n\n\n        local energyStatus = StatusBar(giveResGroup, 0, 100, false, false,\n            UIUtil.UIFile('/game/resource-bars/mini-energy-bar-back_bmp.dds'),\n            UIUtil.UIFile('/game/resource-bars/mini-energy-bar_bmp.dds'), false\n        )\n        energyStatus.Left:Set(giveResGroup.Left)\n        LayoutHelpers.Below(energyStatus, massStatus, 20)\n        LayoutHelpers.AtRightIn(energyStatus, giveResGroup, 50)\n\n        local energySlider = Slider(giveResGroup, false, 0, 100,\n            UIUtil.UIFile('/game/slider-btn/slider-energy_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-energy_btn_up.dds'),\n            UIUtil.UIFile('/game/slider-btn/slider-energy_btn_up.dds')\n        )\n        LayoutHelpers.AtVerticalCenterIn(energySlider, energyStatus)\n        energySlider.Left:Set(giveResGroup.Left)\n        energySlider:SetValue(0)\n        LayoutHelpers.AtRightIn(energySlider, giveResGroup, 50)\n\n        energyInput = UIUtil.CreateText(giveResGroup, '0%', 16, UIUtil.bodyFont)\n        energyInput:SetColor('ffffc700')\n        LayoutHelpers.RightOf(energyInput, energyStatus, 5)\n\n        energySlider.OnValueChanged = function(self, newValue)\n            energyInput:SetText(string.format(\"%d%%\", math.max(math.min(math.floor(newValue), 100), 0)))\n            energyStatus:SetValue(math.floor(newValue))\n        end\n        energyStatus.Depth:Set(function() return massSlider.Depth() - 1 end)\n\n        control.Height:Set(function()\n            return control.OrigHeight + control.giveResourcesGroup.Height()\n        end)\n\n        okBtn.OnClick = function(self, modifiers)\n            SimCallback({\n                Func = \"GiveResourcesToPlayer\",\n                Args = {\n                    From = GetFocusArmy(),\n                    To = control.Data.armyIndex,\n                    Mass = massSlider:GetValue() * 0.01,\n                    Energy = energySlider:GetValue() * 0.01,\n                },\n            })\n            CreateShareResourcesDialog(control)\n        end\n        cancelBtn.OnClick = function(self, modifiers)\n            CreateShareResourcesDialog(control)\n        end\n    end\nend\n\nfunction SetAlliedVictory(state)\n    alliedVictory = state\nend\n\n\n\n--- Unused\n\nlocal EffectHelpers = import(\"/lua/maui/effecthelpers.lua\")\nlocal Text = import(\"/lua/maui/text.lua\").Text\nlocal Edit = import(\"/lua/maui/edit.lua\").Edit\nlocal Checkbox = import(\"/lua/maui/checkbox.lua\").Checkbox\nlocal Button = import(\"/lua/maui/button.lua\").Button\nlocal GameCommon = import(\"/lua/ui/game/gamecommon.lua\")\nlocal NeverAllyWith = {}\n\nif SessionGetScenarioInfo().Options.TeamLock == 'locked' then\n    lockTeams = true\nend", "local LayoutHelpers = import(\"/lua/maui/layouthelpers.lua\")\nlocal NinePatch = import(\"/lua/ui/controls/ninepatch.lua\")\nlocal Prefs = import(\"/lua/user/prefs.lua\")\nlocal Tooltip = import(\"/lua/ui/game/tooltip.lua\")\nlocal UIUtil = import(\"/lua/ui/uiutil.lua\")\n\nlocal Dragger = import(\"/lua/maui/dragger.lua\").Dragger\nlocal Group = import(\"/lua/maui/group.lua\").Group\n\nlocal Lazyvar = import(\"/lua/lazyvar.lua\").Create\nlocal Layouter = LayoutHelpers.ReusedLayoutFor\n\n\n-- seconds to see recall voting results\nlocal reviewResultsDuration = 5\n\nlocal panel\n\nfunction Create(parent)\n    panel = RecallPanel(parent)\n    return panel\nend\n\nfunction SetLayout()\n    Layouter(panel)\n        :AtLeftIn(panel.parent, panel:LoadPosition().left)\n        -- set to uncollapsed position; lets us layout the collapse button and setup the height\n        -- so we know where the panel's actual inital position is\n        :Top(panel.parent.Top() + LayoutHelpers.ScaleNumber(4) + panel.t.Height())\n        :Width(panel.DefaultWidth)\n        :Height(function()\n            local panel = panel\n            local Scale = LayoutHelpers.ScaleNumber\n            local height = Scale(-4) + panel.label.Height() + Scale(5) + panel.votes.Height()\n            -- make sure these register as a dependency\n            local voteHeight = panel.buttonAccept.Height()\n            local progHeight = panel.progressBarBG.Height()\n            if panel.canVote() then\n                height = height + Scale(5) + voteHeight\n                if panel.startTime() > 0 then\n                    height = height + Scale(2) + progHeight\n                end\n            elseif panel.startTime() > 0 then\n                height = height + Scale(10) + progHeight\n            end\n            return height + Scale(-2)\n        end)\n        :Hide()\n        :End()\n    panel.Top:Set(panel.parent.Top() - panel:TotalHeight())\nend\n\nfunction ToggleControl()\n    if panel and not panel.collapseArrow:IsDisabled() then\n        panel.collapseArrow:ToggleCheck()\n    end\nend\n\nfunction RequestHandler(data)\n    if data.CannotRequest ~= nil then\n        import(\"/lua/ui/game/diplomacy.lua\").SetCannotRequestRecallReason(data.CannotRequest)\n    end\n    if data.Open then\n        panel:StartVote(data.Blocks, data.Open, data.CanVote, data.StartTime)\n    end\n    local accept, veto = data.Accept, data.Veto\n    if accept or veto then\n        panel:AddVotes(accept, veto)\n    end\n    if data.Close ~= nil then\n        panel:CloseVote(data.Close)\n    elseif data.Cancel then\n        panel:CancelVote()\n    end\nend\n\n---@class RecallPanel : NinePatch\nRecallPanel = Class(NinePatch.NinePatch) {\n    DefaultWidth = 320,\n\n    __init = function(self, parent)\n        NinePatch.InitStd(self, parent, \"/game/filter-ping-list-panel/panel\")\n\n        self.parent = parent\n        self.collapseArrow = UIUtil.CreateCollapseArrow(parent, \"t\")\n        self.label = UIUtil.CreateText(self, \"<LOC diplomacy_0018>Ready for recall\", 18, UIUtil.bodyFont, true)\n        self.votes = Group(self)\n        self.buttonAccept = UIUtil.CreateButtonStd(self, \"/widgets02/small\", \"<LOC diplomacy_0016>Accept\", 16)\n        self.buttonVeto = UIUtil.CreateButtonStd(self, \"/widgets02/small\", \"<LOC diplomacy_0017>Veto\", 16)\n        self.progressBarBG = UIUtil.CreateBitmapColor(self, \"Gray\")\n        self.progressBar = UIUtil.CreateBitmapColor(self.progressBarBG, \"Yellow\")\n\n        self.progressBarBG.Height:Set(LayoutHelpers.ScaleNumber(4))\n        self.votes.Height:Set(LayoutHelpers.ScaleNumber(1))\n\n        self.votes.blocks = 0\n        self.canVote = Lazyvar(true)\n        self.startTime = Lazyvar(-9999)\n\n        self:Logic()\n    end;\n\n    Layout = function(self)\n        local collapseArrow = Layouter(self.collapseArrow)\n            :Top(self.t.Top() - 7)\n            :AtHorizontalCenterIn(self)\n            :Over(self, 10)\n            :Disable()\n            :Hide()\n            :End()\n\n        local label = Layouter(self.label)\n            :AtTopCenterIn(self, -4)\n            :End()\n\n        local votes = Layouter(self.votes)\n            :AnchorToBottom(label, 5)\n            :AtHorizontalCenterIn(self)\n            :Width(function() return self.Width() - LayoutHelpers.ScaleNumber(16) end)\n            :Height(function()\n                local vote = self.votes[1]\n                if vote then return vote.Height() end\n                return 1\n            end)\n            :End()\n\n        local buttonAccept = Layouter(self.buttonAccept)\n            :AtLeftIn(self, 8)\n            :AnchorToBottom(votes, 5)\n            :End()\n\n        local buttonVeto = Layouter(self.buttonVeto)\n            :AtRightIn(self, 8)\n            :AnchorToBottom(votes, 5)\n            :End()\n\n        local progressBarBG = Layouter(self.progressBarBG)\n            :Width(function() return self.Width() - LayoutHelpers.ScaleNumber(16) end)\n            :Height(4)\n            :AtBottomCenterIn(self, -2)\n            :End()\n\n        Layouter(self.progressBar)\n            :AtHorizontalCenterIn(progressBarBG)\n            :Top(progressBarBG.Top)\n            :Bottom(progressBarBG.Bottom)\n            :Width(function() return self.Width() - LayoutHelpers.ScaleNumber(16) end)\n            :Over(progressBarBG, 10)\n            :End()\n\n        Tooltip.AddCheckboxTooltip(collapseArrow, \"voting_collapse\")\n        Tooltip.AddButtonTooltip(buttonAccept, \"dip_recall_request_accept\")\n        Tooltip.AddButtonTooltip(buttonVeto, \"dip_recall_request_veto\")\n    end;\n\n    LayoutBlocks = function(self, blocks)\n        local votes = self.votes\n        local currentBlocks = votes.blocks\n        if blocks ~= currentBlocks then\n            votes.blocks = blocks\n            for i = currentBlocks, 1, -1 do\n                local block = votes[i]\n                if block then\n                    block:Destroy()\n                end\n                votes[i] = nil\n            end\n            if blocks > 2 then\n                local panelWidth = votes.Width()\n                local width = math.floor(panelWidth / blocks)\n                local offsetX = math.floor((panelWidth - blocks * width) * 0.5) - width\n                for i = 1, blocks do\n                    local vote = Layouter(UIUtil.CreateHorzFillGroup(votes, \"/game/recall-panel/recall-vote\"))\n                        :AtLeftTopIn(votes, offsetX + i * width)\n                        :Width(width)\n                        :End()\n                    votes[i] = vote\n                end\n            else\n                local text\n                if self.canVote() then\n                    text = \"<LOC diplomacy_0026>Your teammate has requested you to recall\"\n                else\n                    text = \"<LOC diplomacy_0025>Waiting for teammate to respond...\"\n                end\n                text = Layouter(UIUtil.CreateText(votes, text, 14))\n                    :AtTopCenterIn(votes)\n                    :End()\n                votes[1] = text\n            end\n            -- manual dirtying of the lazyvar\n            votes.Height[1] = nil\n        end\n    end;\n\n    Logic = function(self)\n        self.collapseArrow.OnCheck = function(_, checked)\n            if UIUtil.GetAnimationPrefs() then\n                if not checked or self:IsHidden() then\n                    PlaySound(Sound {\n                        Cue = \"UI_Score_Window_Open\",\n                        Bank = \"Interface\"\n                    })\n                    self:Show()\n                    self:SetNeedsFrameUpdate(true)\n                    self.Slide = false\n                else\n                    PlaySound(Sound {\n                        Cue = \"UI_Score_Window_Close\",\n                        Bank = \"Interface\"\n                    })\n                    self:SetNeedsFrameUpdate(true)\n                    self.Slide = true\n                end\n            else\n                if not checked or self:IsHidden() then\n                    self:Show()\n                    self.collapseArrow:SetCheck(false, true)\n                else\n                    self:Hide()\n                    self.collapseArrow:SetCheck(true, true)\n                end\n            end\n        end\n        self.collapseArrow.OnHide = function(collapse, hide)\n            if hide ~= collapse:IsDisabled() then\n                return true\n            end\n        end\n\n        local function ShowForVote(button, hide)\n            return not hide and not self.canVote()\n        end\n        self.buttonAccept.OnHide = ShowForVote\n        self.buttonAccept.OnClick = function()\n            SimCallback({\n                Func = \"SetRecallVote\",\n                Args = {\n                    From = GetFocusArmy(),\n                    Vote = true,\n                },\n            })\n            self:SetCanVote(false)\n        end\n        self.buttonVeto.OnHide = ShowForVote\n        self.buttonVeto.OnClick = function()\n            SimCallback({\n                Func = \"SetRecallVote\",\n                Args = {\n                    From = GetFocusArmy(),\n                    Vote = false,\n                },\n            })\n            self:SetCanVote(false)\n        end\n    end;\n\n    SetCanVote = function(self, canVote)\n        local buttonAccept = self.buttonAccept\n        local buttonVeto = self.buttonVeto\n        self.canVote:Set(canVote)\n        if canVote then\n            buttonAccept:Show()\n            buttonVeto:Show()\n        else\n            buttonAccept:Hide()\n            buttonVeto:Hide()\n        end\n    end;\n\n    StartVote = function(self, blocks, duration, canVote, startingTime)\n        self.duration = duration\n        self.startTime:Set(startingTime or GetGameTimeSeconds())\n        self:SetCanVote(canVote)\n        self:LayoutBlocks(blocks) -- can depend on `canVote`, so put after it\n        self.collapseArrow:Enable()\n        self.collapseArrow:Show()\n        self.collapseArrow:SetCheck(false)\n        if not UIUtil.GetAnimationPrefs() then\n            -- update the timer in a more rudimentary fashion\n            self.reviewResultsThread = ForkThread(function(self)\n                local nominalWidth = self.Width() - LayoutHelpers.ScaleNumber(16)\n                local incWidth = nominalWidth / duration\n                for i = 1, duration do\n                    if self.startTime() < 0 then -- accept the close vote signal\n                        break\n                    end\n                    self.progressBar.Width:Set(nominalWidth - i * incWidth)\n                    WaitSeconds(1)\n\n                end\n                self.progressBar.Width:Set(0)\n                WaitSeconds(reviewResultsDuration)\n\n                self:OnResultsReviewed()\n                self.reviewResultsThread = nil\n            end, self)\n        end\n    end;\n\n    CancelVote = function(self)\n        self:SetCanVote(false)\n        self.startTime:Set(-9999) -- make sure the OnFrame animation ends\n        if self.reviewResultsThread then\n            KillThread(self.reviewResultsThread)\n            self.reviewResultsThread = nil\n        end\n        self:OnResultsReviewed()\n    end;\n\n    CloseVote = function(self, accepted)\n        self:SetCanVote(false)\n        self.startTime:Set(-9999) -- make sure the OnFrame animation ends\n        if self.reviewResultsThread then\n            -- continue the OnSecond animation if it exists\n            coroutine.resume(self.reviewResultsThread)\n        else\n            -- otherwise, create our own result reviewing handler\n            self.reviewResultsThread = ForkThread(function(self)\n                WaitSeconds(reviewResultsDuration)\n\n                self:OnResultsReviewed()\n                self.reviewResultsThread = nil\n            end, self)\n        end\n        if accepted then\n            self:OnVoteAccepted()\n        else\n            self:OnVoteVetoed()\n        end\n    end;\n\n    AddVotes = function(self, accept, veto)\n        local votes = self.votes\n        if votes.blocks < 3 then return end\n        local function SetTextures(vote, filename)\n            vote._left:SetTexture(UIUtil.UIFile(filename .. \"_bmp_l.dds\"))\n            vote._middle:SetTexture(UIUtil.UIFile(filename .. \"_bmp_m.dds\"))\n            vote._right:SetTexture(UIUtil.UIFile(filename .. \"_bmp_r.dds\"))\n        end\n        local index = 1\n        for i = 1, votes.blocks do\n            if not votes[i].cast then\n                index = i\n                break\n            end\n        end\n        if accept then\n            for _ = 1, accept do\n                local vote = votes[index]\n                index = index + 1\n                vote.cast = \"accept\"\n                SetTextures(vote, \"/game/recall-panel/recall-accept\")\n            end\n        end\n        if veto then\n            for _ = 1, veto do\n                local vote = votes[index]\n                index = index + 1\n                vote.cast = \"veto\"\n                SetTextures(vote, \"/game/recall-panel/recall-veto\")\n            end\n        end\n    end;\n\n    OnFrame = function(self, delta)\n        local slide = self.Slide\n        local notAnimating = true\n        if slide ~= nil then\n            local newTop = self.t.Top()\n            local topLimit = self.parent.Top()\n            if slide then\n                newTop = newTop - 500 * delta\n                topLimit = topLimit - self:TotalHeight()\n                if newTop < topLimit then\n                    newTop = topLimit\n                    self:Hide()\n                    self:SetNeedsFrameUpdate(false)\n                    self.Slide = nil\n                end\n            else\n                newTop = newTop + 500 * delta + 4\n                if newTop > topLimit then\n                    newTop = topLimit\n                    self.Slide = nil\n                end\n            end\n            self.Top:Set(newTop + self.t.Height())\n            notAnimating = false\n        end\n\n        local time = self.startTime()\n        if time > 0 then\n            local dur = self.duration\n            time = GetGameTimeSeconds() - time\n            local nominalWidth = self.Width() - LayoutHelpers.ScaleNumber(16)\n            if time >= dur then\n                self.startTime:Set(-9999)\n                self.progressBar.Width:Set(0)\n                self.progressBar:Hide()\n            else\n                self.progressBar.Width:Set((1 - time / dur) * nominalWidth)\n            end\n            notAnimating = false\n        end\n        if notAnimating then\n            self:SetNeedsFrameUpdate(false)\n        end\n    end;\n\n    OnResultsReviewed = function(self)\n        local collapse = self.collapseArrow\n        collapse:Disable()\n        collapse:SetCheck(true)\n    end;\n\n    OnVoteAccepted = function(self)\n        import(\"/lua/ui/game/announcement.lua\").CreateAnnouncement(LOC(\"<LOC diplomacy_0021>The recall vote was accepted.\"))\n        self.label:SetText(LOC(\"<LOC diplomacy_0023>Recalling...\"))\n    end;\n\n    OnVoteVetoed = function(self)\n        import(\"/lua/ui/game/announcement.lua\").CreateAnnouncement(LOC(\"<LOC diplomacy_0022>The recall vote was vetoed.\"))\n        self.label:SetText(LOC(\"<LOC diplomacy_0024>Not ready for recall\"))\n    end;\n\n    OnHide = function(self, hide)\n        local supress = import(\"/lua/ui/game/gamecommon.lua\").SupressShowingWhenRestoringUI(self, hide)\n        local collapse = self.collapseArrow\n        if collapse then\n            if supress or collapse:IsDisabled() then\n                collapse:Hide()\n                if not hide then\n                    supress = true\n                end\n            else\n                collapse:Show()\n            end\n        end\n        return supress\n    end;\n\n    HandleEvent = function(self, event)\n        if event.Type == \"ButtonPress\" and event.Modifiers.Middle then\n            local drag = Dragger()\n            local offX = event.MouseX - self.Left()\n            drag.OnMove = function(dragself, x, y)\n                self.Left:Set(math.min(math.max(x - offX, self.parent.Left()), self.parent.Right() - self.Width()))\n                GetCursor():SetTexture(UIUtil.GetCursor(\"W_E\"))\n            end\n            drag.OnRelease = function()\n                self:SavePosition()\n                GetCursor():Reset()\n                drag:Destroy()\n            end\n            PostDragger(self:GetRootFrame(), event.KeyCode, drag)\n            return true\n        end\n        return false\n    end;\n\n    LoadPosition = function(self)\n        return Prefs.GetFromCurrentProfile(\"RecallPanelPos\") or {\n            left = 800,\n        }\n    end;\n\n    SavePosition = function(self)\n        Prefs.SetToCurrentProfile(\"RecallPanelPos\", {\n            left = LayoutHelpers.InvScaleNumber(self.Left()),\n        })\n    end;\n}\n"], "buggy_code_start_loc": [127, 705, 1, 39, 61], "buggy_code_end_loc": [134, 705, 259, 464, 388], "fixing_code_start_loc": [128, 706, 2, 39, 61], "fixing_code_end_loc": [133, 707, 417, 477, 401], "type": "NVD-CWE-Other", "message": "A vulnerability was found in Forged Alliance Forever up to 3746. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the component Vote Handler. The manipulation leads to improper authorization. Upgrading to version 3747 is able to address this issue. The name of the patch is 6880971bd3d73d942384aff62d53058c206ce644. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217555.", "other": {"cve": {"id": "CVE-2022-4879", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-06T11:15:09.557", "lastModified": "2023-01-12T15:48:49.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Forged Alliance Forever up to 3746. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the component Vote Handler. The manipulation leads to improper authorization. Upgrading to version 3747 is able to address this issue. The name of the patch is 6880971bd3d73d942384aff62d53058c206ce644. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217555."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:forged_alliance_forever_project:forged_alliance_forever:*:*:*:*:*:*:*:*", "versionEndExcluding": "3747", "matchCriteriaId": "08E0386C-FB01-49C5-9AC1-EE14CBC6F346"}]}]}], "references": [{"url": "https://github.com/FAForever/fa/commit/6880971bd3d73d942384aff62d53058c206ce644", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FAForever/fa/pull/4398", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FAForever/fa/releases/tag/3747", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217555", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217555", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FAForever/fa/commit/6880971bd3d73d942384aff62d53058c206ce644"}}