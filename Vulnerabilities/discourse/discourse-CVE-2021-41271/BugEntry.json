{"buggy_code": ["# frozen_string_literal: true\n\nrequire_dependency \"mobile_detection\"\nrequire_dependency \"crawler_detection\"\nrequire_dependency \"guardian\"\nrequire_dependency \"http_language_parser\"\n\nmodule Middleware\n  class AnonymousCache\n\n    def self.cache_key_segments\n      @@cache_key_segments ||= {\n        m: 'key_is_mobile?',\n        c: 'key_is_crawler?',\n        b: 'key_has_brotli?',\n        t: 'key_cache_theme_ids',\n        ca: 'key_compress_anon',\n        l: 'key_locale'\n      }\n    end\n\n    # Compile a string builder method that will be called to create\n    # an anonymous cache key\n    def self.compile_key_builder\n      method = +\"def self.__compiled_key_builder(h)\\n  \\\"\"\n      cache_key_segments.each do |k, v|\n        raise \"Invalid key name\" unless k =~ /^[a-z]+$/\n        raise \"Invalid method name\" unless v =~ /^key_[a-z_\\?]+$/\n        method << \"|#{k}=#\\{h.#{v}}\"\n      end\n      method << \"\\\"\\nend\"\n      eval(method)\n      @@compiled = true\n    end\n\n    def self.build_cache_key(helper)\n      compile_key_builder unless defined?(@@compiled)\n      __compiled_key_builder(helper)\n    end\n\n    def self.anon_cache(env, duration)\n      env[\"ANON_CACHE_DURATION\"] = duration\n    end\n\n    # This gives us an API to insert anonymous cache segments\n    class Helper\n      RACK_SESSION     = \"rack.session\"\n      USER_AGENT       = \"HTTP_USER_AGENT\"\n      ACCEPT_ENCODING  = \"HTTP_ACCEPT_ENCODING\"\n      DISCOURSE_RENDER = \"HTTP_DISCOURSE_RENDER\"\n\n      def initialize(env)\n        @env = env\n        @request = Rack::Request.new(@env)\n      end\n\n      def blocked_crawler?\n        @request.get? &&\n        !@request.xhr? &&\n        !@request.path.ends_with?('robots.txt') &&\n        !@request.path.ends_with?('srv/status') &&\n        @request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil? &&\n        CrawlerDetection.is_blocked_crawler?(@env[USER_AGENT])\n      end\n\n      def is_mobile=(val)\n        @is_mobile = val ? :true : :false\n      end\n\n      def is_mobile?\n        @is_mobile ||=\n          begin\n            session = @env[RACK_SESSION]\n            # don't initialize params until later\n            # otherwise you get a broken params on the request\n            params = {}\n\n            MobileDetection.resolve_mobile_view!(@env[USER_AGENT], params, session) ? :true : :false\n          end\n\n        @is_mobile == :true\n      end\n      alias_method :key_is_mobile?, :is_mobile?\n\n      def key_has_brotli?\n        @has_brotli ||=\n          begin\n            @env[ACCEPT_ENCODING].to_s =~ /br/ ? :true : :false\n          end\n        @has_brotli == :true\n      end\n\n      def key_locale\n        if SiteSetting.set_locale_from_accept_language_header\n          HttpLanguageParser.parse(@env[\"HTTP_ACCEPT_LANGUAGE\"])\n        else\n          \"\" # No need to key, it is the same for all anon users\n        end\n      end\n\n      def is_crawler?\n        @is_crawler ||=\n          begin\n            user_agent = @env[USER_AGENT]\n\n            if @env[DISCOURSE_RENDER] == \"crawler\" || CrawlerDetection.crawler?(user_agent, @env[\"HTTP_VIA\"])\n              :true\n            else\n              user_agent.downcase.include?(\"discourse\") && !user_agent.downcase.include?(\"mobile\") ? :true : :false\n            end\n          end\n        @is_crawler == :true\n      end\n      alias_method :key_is_crawler?, :is_crawler?\n\n      def cache_key\n        return @cache_key if defined?(@cache_key)\n\n        @cache_key = +\"ANON_CACHE_#{@env[\"HTTP_ACCEPT\"]}_#{@env[Rack::RACK_URL_SCHEME]}_#{@env[\"HTTP_HOST\"]}#{@env[\"REQUEST_URI\"]}\"\n        @cache_key << AnonymousCache.build_cache_key(self)\n        @cache_key\n      end\n\n      def key_cache_theme_ids\n        theme_ids.join(',')\n      end\n\n      def key_compress_anon\n        GlobalSetting.compress_anon_cache\n      end\n\n      def theme_ids\n        ids, _ = @request.cookies['theme_ids']&.split('|')\n        ids = ids&.split(\",\")&.map(&:to_i)\n        if ids && Guardian.new.allow_themes?(ids)\n          Theme.transform_ids(ids)\n        else\n          []\n        end\n      end\n\n      def cache_key_count\n        @cache_key_count ||= \"#{cache_key}_count\"\n      end\n\n      def cache_key_body\n        @cache_key_body ||= \"#{cache_key}_body\"\n      end\n\n      def cache_key_other\n        @cache_key_other || \"#{cache_key}_other\"\n      end\n\n      def get?\n        @env[\"REQUEST_METHOD\"] == \"GET\"\n      end\n\n      def has_auth_cookie?\n        CurrentUser.has_auth_cookie?(@env)\n      end\n\n      def no_cache_bypass\n        request = Rack::Request.new(@env)\n        request.cookies['_bypass_cache'].nil? &&\n          (request.path != '/srv/status') &&\n          request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n          @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil?\n      end\n\n      def force_anonymous!\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY] = nil\n        @env['HTTP_COOKIE'] = nil\n        @env['rack.request.cookie.hash'] = {}\n        @env['rack.request.cookie.string'] = ''\n        @env['_bypass_cache'] = nil\n        request = Rack::Request.new(@env)\n        request.delete_param('api_username')\n        request.delete_param('api_key')\n      end\n\n      def logged_in_anon_limiter\n        @logged_in_anon_limiter ||= RateLimiter.new(\n          nil,\n          \"logged_in_anon_cache_#{@env[\"HTTP_HOST\"]}/#{@env[\"REQUEST_URI\"]}\",\n          GlobalSetting.force_anonymous_min_per_10_seconds,\n          10\n        )\n      end\n\n      def check_logged_in_rate_limit!\n        !logged_in_anon_limiter.performed!(raise_error: false)\n      end\n\n      MIN_TIME_TO_CHECK = 0.05\n      ADP = \"action_dispatch.request.parameters\"\n\n      def should_force_anonymous?\n        if (queue_time = @env['REQUEST_QUEUE_SECONDS']) && get?\n          if queue_time > GlobalSetting.force_anonymous_min_queue_seconds\n            return check_logged_in_rate_limit!\n          elsif queue_time >= MIN_TIME_TO_CHECK\n            if !logged_in_anon_limiter.can_perform?\n              return check_logged_in_rate_limit!\n            end\n          end\n        end\n\n        false\n      end\n\n      def cacheable?\n        !!(!has_auth_cookie? && get? && no_cache_bypass)\n      end\n\n      def compress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::compress(val)\n        else\n          val\n        end\n      end\n\n      def decompress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::uncompress(val)\n        else\n          val\n        end\n      end\n\n      def cached(env = {})\n        if body = decompress(Discourse.redis.get(cache_key_body))\n          if other = Discourse.redis.get(cache_key_other)\n            other = JSON.parse(other)\n            if req_params = other[1].delete(ADP)\n              env[ADP] = req_params\n            end\n            [other[0], other[1], [body]]\n          end\n        end\n      end\n\n      def cache_duration\n        @env[\"ANON_CACHE_DURATION\"]\n      end\n\n      # NOTE in an ideal world cache still serves out cached content except for one magic worker\n      #  that fills it up, this avoids a herd killing you, we can probably do this using a job or redis tricks\n      #  but coordinating this is tricky\n      def cache(result, env = {})\n        return result if GlobalSetting.anon_cache_store_threshold == 0\n\n        status, headers, response = result\n\n        if status == 200 && cache_duration\n\n          if GlobalSetting.anon_cache_store_threshold > 1\n            count = Discourse.redis.eval(<<~REDIS, [cache_key_count], [cache_duration])\n              local current = redis.call(\"incr\", KEYS[1])\n              redis.call(\"expire\",KEYS[1],ARGV[1])\n              return current\n            REDIS\n\n            # technically lua will cast for us, but might as well be\n            # prudent here, hence the to_i\n            if count.to_i < GlobalSetting.anon_cache_store_threshold\n              headers[\"X-Discourse-Cached\"] = \"skip\"\n              return [status, headers, response]\n            end\n          end\n\n          headers_stripped = headers.dup.delete_if { |k, _| [\"Set-Cookie\", \"X-MiniProfiler-Ids\"].include? k }\n          headers_stripped[\"X-Discourse-Cached\"] = \"true\"\n          parts = []\n          response.each do |part|\n            parts << part\n          end\n\n          if req_params = env[ADP]\n            headers_stripped[ADP] = {\n              \"action\" => req_params[\"action\"],\n              \"controller\" => req_params[\"controller\"]\n            }\n          end\n\n          Discourse.redis.setex(cache_key_body,  cache_duration, compress(parts.join))\n          Discourse.redis.setex(cache_key_other, cache_duration, [status, headers_stripped].to_json)\n\n          headers[\"X-Discourse-Cached\"] = \"store\"\n        else\n          parts = response\n        end\n\n        [status, headers, parts]\n      end\n\n      def clear_cache\n        Discourse.redis.del(cache_key_body)\n        Discourse.redis.del(cache_key_other)\n      end\n\n    end\n\n    def initialize(app, settings = {})\n      @app = app\n    end\n\n    PAYLOAD_INVALID_REQUEST_METHODS = [\"GET\", \"HEAD\"]\n\n    def call(env)\n      if PAYLOAD_INVALID_REQUEST_METHODS.include?(env[Rack::REQUEST_METHOD]) &&\n        env[Rack::RACK_INPUT].size > 0\n\n        return [413, {}, []]\n      end\n\n      helper = Helper.new(env)\n      force_anon = false\n\n      if helper.blocked_crawler?\n        env[\"discourse.request_tracker.skip\"] = true\n        return [403, {}, [\"Crawler is not allowed!\"]]\n      end\n\n      if helper.should_force_anonymous?\n        force_anon = env[\"DISCOURSE_FORCE_ANON\"] = true\n        helper.force_anonymous!\n      end\n\n      if (env[\"HTTP_DISCOURSE_BACKGROUND\"] == \"true\") && (queue_time = env[\"REQUEST_QUEUE_SECONDS\"])\n        max_time = GlobalSetting.background_requests_max_queue_length.to_f\n        if max_time > 0 && queue_time.to_f > max_time\n          return [\n            429,\n            {\n              \"content-type\" => \"application/json; charset=utf-8\"\n            },\n            [{\n              errors: I18n.t(\"rate_limiter.slow_down\"),\n              extras: {\n                wait_seconds: 5 + (5 * rand).round(2)\n              }\n            }.to_json]\n          ]\n        end\n      end\n\n      result =\n        if helper.cacheable?\n          helper.cached(env) || helper.cache(@app.call(env), env)\n        else\n          @app.call(env)\n        end\n\n      if force_anon\n        result[1][\"Set-Cookie\"] = \"dosp=1; Path=/\"\n      end\n\n      result\n    end\n\n  end\n\nend\n", "# frozen_string_literal: true\n\n# since all the rescue from clauses are not caught by the application controller for matches\n# we need to handle certain exceptions here\nmodule Middleware\n  class DiscoursePublicExceptions < ::ActionDispatch::PublicExceptions\n\n    def initialize(path)\n      super\n    end\n\n    def call(env)\n      # this is so so gnarly\n      # sometimes we leak out exceptions prior to creating a controller instance\n      # this can happen if we have an exception in a route constraint in some cases\n      # this code re-dispatches the exception to our application controller so we can\n      # properly translate the exception to a page\n      exception = env[\"action_dispatch.exception\"]\n      response = ActionDispatch::Response.new\n\n      # Special handling for invalid params, in this case we can not re-dispatch\n      # the Request object has a \"broken\" .params which can not be accessed\n      exception = nil if Rack::QueryParser::InvalidParameterError === exception\n\n      # We also can not dispatch bad requests as no proper params\n      exception = nil if ActionController::BadRequest === exception\n\n      if exception\n        begin\n          fake_controller = ApplicationController.new\n          fake_controller.response = response\n          fake_controller.request = request = ActionDispatch::Request.new(env)\n\n          # We can not re-dispatch bad mime types\n          begin\n            request.format\n          rescue Mime::Type::InvalidMimeType\n            return [400, {}, [\"Invalid MIME type\"]]\n          end\n\n          if ApplicationController.rescue_with_handler(exception, object: fake_controller)\n            body = response.body\n            if String === body\n              body = [body]\n            end\n            return [response.status, response.headers, body]\n          end\n        rescue => e\n          Discourse.warn_exception(e, message: \"Failed to handle exception in exception app middleware\")\n        end\n\n      end\n      super\n    end\n\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Middleware::AnonymousCache do\n  let(:middleware) { Middleware::AnonymousCache.new(lambda { |_| [200, {}, []] }) }\n\n  def env(opts = {})\n    Rack::MockRequest.env_for(\"http://test.com/path?bla=1\").merge(opts)\n  end\n\n  describe Middleware::AnonymousCache::Helper do\n    def new_helper(opts = {})\n      Middleware::AnonymousCache::Helper.new(env(opts))\n    end\n\n    context \"cachable?\" do\n      it \"true by default\" do\n        expect(new_helper.cacheable?).to eq(true)\n      end\n\n      it \"is false for non GET\" do\n        expect(new_helper(\"ANON_CACHE_DURATION\" => 10, \"REQUEST_METHOD\" => \"POST\").cacheable?).to eq(false)\n      end\n\n      it \"is false if it has an auth cookie\" do\n        expect(new_helper(\"HTTP_COOKIE\" => \"jack=1; _t=#{\"1\" * 32}; jill=2\").cacheable?).to eq(false)\n      end\n\n      it \"is false for srv/status routes\" do\n        expect(new_helper(\"PATH_INFO\" => \"/srv/status\").cacheable?).to eq(false)\n      end\n    end\n\n    context \"per theme cache\" do\n      it \"handles theme keys\" do\n        theme = Fabricate(:theme, user_selectable: true)\n\n        with_bad_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=abc\").cache_key\n        with_no_theme_key = new_helper().cache_key\n\n        expect(with_bad_theme_key).to eq(with_no_theme_key)\n\n        with_good_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=#{theme.id}\").cache_key\n\n        expect(with_good_theme_key).not_to eq(with_no_theme_key)\n      end\n    end\n\n    context \"with header-based locale locale\" do\n      it \"handles different languages\" do\n        # Normally does not check the language header\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(french1)\n        expect(none).to eq(french2)\n        expect(none).to eq(english)\n\n        SiteSetting.allow_user_locale = true\n        SiteSetting.set_locale_from_accept_language_header = true\n\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(english)\n        expect(french1).to eq(french2)\n        expect(french1).not_to eq(none)\n      end\n    end\n\n    context \"cached\" do\n      let!(:helper) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10)\n      end\n\n      let!(:crawler) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_USER_AGENT\" => \"AdsBot-Google (+http://www.google.com/adsbot.html)\")\n      end\n\n      after do\n        helper.clear_cache\n        crawler.clear_cache\n      end\n\n      before do\n        global_setting :anon_cache_store_threshold, 1\n      end\n\n      it \"compresses body on demand\" do\n        global_setting :compress_anon_cache, true\n\n        payload = \"x\" * 1000\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [payload]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [payload]])\n\n        # depends on i7z implementation, but lets assume it is stable unless we discover\n        # otherwise\n        expect(Discourse.redis.get(helper.cache_key_body).length).to eq(16)\n      end\n\n      it \"handles brotli switching\" do\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_ACCEPT_ENCODING\" => \"gz, br\")\n        expect(helper.cached).to eq(nil)\n      end\n\n      it \"returns cached data for cached requests\" do\n        helper.is_mobile = true\n        expect(helper.cached).to eq(nil)\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        helper.is_mobile = true\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        expect(crawler.cached).to eq(nil)\n        crawler.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"world\"]])\n        expect(crawler.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello world\"]])\n      end\n    end\n  end\n\n  context 'background request rate limit' do\n    it 'will rate limit background requests' do\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :background_requests_max_queue_length, \"0.5\"\n\n      env = {\n        \"HTTP_COOKIE\" => \"_t=#{SecureRandom.hex}\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      }\n\n      # non background ... long request\n      env[\"REQUEST_QUEUE_SECONDS\"] = 2\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n      env[\"HTTP_DISCOURSE_BACKGROUND\"] = \"true\"\n\n      status, headers, body = app.call(env.dup)\n      expect(status).to eq(429)\n      expect(headers[\"content-type\"]).to eq(\"application/json; charset=utf-8\")\n      json = JSON.parse(body.join)\n      expect(json[\"extras\"][\"wait_seconds\"]).to be > 4.9\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.4\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n    end\n  end\n\n  context 'force_anonymous!' do\n    before do\n      RateLimiter.enable\n    end\n\n    after do\n      RateLimiter.disable\n    end\n\n    it 'will revert to anonymous once we reach the limit' do\n\n      RateLimiter.clear_all!\n\n      is_anon = false\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          is_anon = env[\"HTTP_COOKIE\"].nil?\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :force_anonymous_min_per_10_seconds, 2\n      global_setting :force_anonymous_min_queue_seconds, 1\n\n      env = {\n        \"HTTP_COOKIE\" => \"_t=#{SecureRandom.hex}\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      }\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      _status, headers, _body = app.call(env.dup)\n      expect(is_anon).to eq(true)\n      expect(headers['Set-Cookie']).to eq('dosp=1; Path=/')\n\n      # tricky change, a 50ms delay still will trigger protection\n      # once it is tripped\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.05\n      is_anon = false\n\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.01\n\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n    end\n  end\n\n  context 'invalid request payload' do\n    it 'returns 413 for GET request with payload' do\n      status, _, _ = middleware.call(env.tap do |environment|\n        environment[Rack::RACK_INPUT].write(\"test\")\n      end)\n\n      expect(status).to eq(413)\n    end\n  end\n\n  context \"crawler blocking\" do\n    let :non_crawler do\n      {\n        \"HTTP_USER_AGENT\" =>\n        \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36\"\n      }\n    end\n\n    def get(path, options)\n      @env = env({\n        \"REQUEST_URI\" => path,\n        \"PATH_INFO\" => path,\n        \"REQUEST_PATH\" => path\n      }.merge(options[:headers]))\n      @status, @response_header, @response = middleware.call(@env)\n    end\n\n    it \"applies allowed_crawler_user_agents correctly\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Anotherbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n      expect(@response).to be_an(Array)\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n    end\n\n    it \"doesn't block api requests\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n      api_key = Fabricate(:api_key)\n\n      get \"/latest?api_key=#{api_key.key}&api_username=system\", headers: {\n        \"QUERY_STRING\" => \"api_key=#{api_key.key}&api_username=system\"\n      }\n      expect(@status).to eq(200)\n    end\n\n    it \"applies blocked_crawler_user_agents correctly\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Twitterbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block robots.txt\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/robots.txt', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block srv/status\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"blocked crawlers shouldn't log page views\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@env[\"discourse.request_tracker.skip\"]).to eq(true)\n    end\n\n    it \"blocks json requests\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status.json', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n    end\n  end\n\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire_dependency \"mobile_detection\"\nrequire_dependency \"crawler_detection\"\nrequire_dependency \"guardian\"\nrequire_dependency \"http_language_parser\"\n\nmodule Middleware\n  class AnonymousCache\n\n    def self.cache_key_segments\n      @@cache_key_segments ||= {\n        m: 'key_is_mobile?',\n        c: 'key_is_crawler?',\n        b: 'key_has_brotli?',\n        t: 'key_cache_theme_ids',\n        ca: 'key_compress_anon',\n        l: 'key_locale'\n      }\n    end\n\n    # Compile a string builder method that will be called to create\n    # an anonymous cache key\n    def self.compile_key_builder\n      method = +\"def self.__compiled_key_builder(h)\\n  \\\"\"\n      cache_key_segments.each do |k, v|\n        raise \"Invalid key name\" unless k =~ /^[a-z]+$/\n        raise \"Invalid method name\" unless v =~ /^key_[a-z_\\?]+$/\n        method << \"|#{k}=#\\{h.#{v}}\"\n      end\n      method << \"\\\"\\nend\"\n      eval(method)\n      @@compiled = true\n    end\n\n    def self.build_cache_key(helper)\n      compile_key_builder unless defined?(@@compiled)\n      __compiled_key_builder(helper)\n    end\n\n    def self.anon_cache(env, duration)\n      env[\"ANON_CACHE_DURATION\"] = duration\n    end\n\n    # This gives us an API to insert anonymous cache segments\n    class Helper\n      RACK_SESSION     = \"rack.session\"\n      USER_AGENT       = \"HTTP_USER_AGENT\"\n      ACCEPT_ENCODING  = \"HTTP_ACCEPT_ENCODING\"\n      DISCOURSE_RENDER = \"HTTP_DISCOURSE_RENDER\"\n\n      def initialize(env)\n        @env = env\n        @request = Rack::Request.new(@env)\n      end\n\n      def blocked_crawler?\n        @request.get? &&\n        !@request.xhr? &&\n        !@request.path.ends_with?('robots.txt') &&\n        !@request.path.ends_with?('srv/status') &&\n        @request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil? &&\n        CrawlerDetection.is_blocked_crawler?(@env[USER_AGENT])\n      end\n\n      def is_mobile=(val)\n        @is_mobile = val ? :true : :false\n      end\n\n      def is_mobile?\n        @is_mobile ||=\n          begin\n            session = @env[RACK_SESSION]\n            # don't initialize params until later\n            # otherwise you get a broken params on the request\n            params = {}\n\n            MobileDetection.resolve_mobile_view!(@env[USER_AGENT], params, session) ? :true : :false\n          end\n\n        @is_mobile == :true\n      end\n      alias_method :key_is_mobile?, :is_mobile?\n\n      def key_has_brotli?\n        @has_brotli ||=\n          begin\n            @env[ACCEPT_ENCODING].to_s =~ /br/ ? :true : :false\n          end\n        @has_brotli == :true\n      end\n\n      def key_locale\n        if SiteSetting.set_locale_from_accept_language_header\n          HttpLanguageParser.parse(@env[\"HTTP_ACCEPT_LANGUAGE\"])\n        else\n          \"\" # No need to key, it is the same for all anon users\n        end\n      end\n\n      def is_crawler?\n        @is_crawler ||=\n          begin\n            user_agent = @env[USER_AGENT]\n\n            if @env[DISCOURSE_RENDER] == \"crawler\" || CrawlerDetection.crawler?(user_agent, @env[\"HTTP_VIA\"])\n              :true\n            else\n              user_agent.downcase.include?(\"discourse\") && !user_agent.downcase.include?(\"mobile\") ? :true : :false\n            end\n          end\n        @is_crawler == :true\n      end\n      alias_method :key_is_crawler?, :is_crawler?\n\n      def cache_key\n        return @cache_key if defined?(@cache_key)\n\n        @cache_key = +\"ANON_CACHE_#{@env[\"HTTP_ACCEPT\"]}_#{@env[Rack::RACK_URL_SCHEME]}_#{@env[\"HTTP_HOST\"]}#{@env[\"REQUEST_URI\"]}\"\n        @cache_key << AnonymousCache.build_cache_key(self)\n        @cache_key\n      end\n\n      def key_cache_theme_ids\n        theme_ids.join(',')\n      end\n\n      def key_compress_anon\n        GlobalSetting.compress_anon_cache\n      end\n\n      def theme_ids\n        ids, _ = @request.cookies['theme_ids']&.split('|')\n        ids = ids&.split(\",\")&.map(&:to_i)\n        if ids && Guardian.new.allow_themes?(ids)\n          Theme.transform_ids(ids)\n        else\n          []\n        end\n      end\n\n      def cache_key_count\n        @cache_key_count ||= \"#{cache_key}_count\"\n      end\n\n      def cache_key_body\n        @cache_key_body ||= \"#{cache_key}_body\"\n      end\n\n      def cache_key_other\n        @cache_key_other || \"#{cache_key}_other\"\n      end\n\n      def get?\n        @env[\"REQUEST_METHOD\"] == \"GET\"\n      end\n\n      def has_auth_cookie?\n        CurrentUser.has_auth_cookie?(@env)\n      end\n\n      def no_cache_bypass\n        request = Rack::Request.new(@env)\n        request.cookies['_bypass_cache'].nil? &&\n          (request.path != '/srv/status') &&\n          request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n          @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil?\n      end\n\n      def force_anonymous!\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY] = nil\n        @env['HTTP_COOKIE'] = nil\n        @env['rack.request.cookie.hash'] = {}\n        @env['rack.request.cookie.string'] = ''\n        @env['_bypass_cache'] = nil\n        request = Rack::Request.new(@env)\n        request.delete_param('api_username')\n        request.delete_param('api_key')\n      end\n\n      def logged_in_anon_limiter\n        @logged_in_anon_limiter ||= RateLimiter.new(\n          nil,\n          \"logged_in_anon_cache_#{@env[\"HTTP_HOST\"]}/#{@env[\"REQUEST_URI\"]}\",\n          GlobalSetting.force_anonymous_min_per_10_seconds,\n          10\n        )\n      end\n\n      def check_logged_in_rate_limit!\n        !logged_in_anon_limiter.performed!(raise_error: false)\n      end\n\n      MIN_TIME_TO_CHECK = 0.05\n      ADP = \"action_dispatch.request.parameters\"\n\n      def should_force_anonymous?\n        if (queue_time = @env['REQUEST_QUEUE_SECONDS']) && get?\n          if queue_time > GlobalSetting.force_anonymous_min_queue_seconds\n            return check_logged_in_rate_limit!\n          elsif queue_time >= MIN_TIME_TO_CHECK\n            if !logged_in_anon_limiter.can_perform?\n              return check_logged_in_rate_limit!\n            end\n          end\n        end\n\n        false\n      end\n\n      def cacheable?\n        !!(!has_auth_cookie? && get? && no_cache_bypass)\n      end\n\n      def compress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::compress(val)\n        else\n          val\n        end\n      end\n\n      def decompress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::uncompress(val)\n        else\n          val\n        end\n      end\n\n      def cached(env = {})\n        if body = decompress(Discourse.redis.get(cache_key_body))\n          if other = Discourse.redis.get(cache_key_other)\n            other = JSON.parse(other)\n            if req_params = other[1].delete(ADP)\n              env[ADP] = req_params\n            end\n            [other[0], other[1], [body]]\n          end\n        end\n      end\n\n      def cache_duration\n        @env[\"ANON_CACHE_DURATION\"]\n      end\n\n      # NOTE in an ideal world cache still serves out cached content except for one magic worker\n      #  that fills it up, this avoids a herd killing you, we can probably do this using a job or redis tricks\n      #  but coordinating this is tricky\n      def cache(result, env = {})\n        return result if GlobalSetting.anon_cache_store_threshold == 0\n\n        status, headers, response = result\n\n        if status == 200 && cache_duration\n\n          if GlobalSetting.anon_cache_store_threshold > 1\n            count = Discourse.redis.eval(<<~REDIS, [cache_key_count], [cache_duration])\n              local current = redis.call(\"incr\", KEYS[1])\n              redis.call(\"expire\",KEYS[1],ARGV[1])\n              return current\n            REDIS\n\n            # technically lua will cast for us, but might as well be\n            # prudent here, hence the to_i\n            if count.to_i < GlobalSetting.anon_cache_store_threshold\n              headers[\"X-Discourse-Cached\"] = \"skip\"\n              return [status, headers, response]\n            end\n          end\n\n          headers_stripped = headers.dup.delete_if { |k, _| [\"Set-Cookie\", \"X-MiniProfiler-Ids\"].include? k }\n          headers_stripped[\"X-Discourse-Cached\"] = \"true\"\n          parts = []\n          response.each do |part|\n            parts << part\n          end\n\n          if req_params = env[ADP]\n            headers_stripped[ADP] = {\n              \"action\" => req_params[\"action\"],\n              \"controller\" => req_params[\"controller\"]\n            }\n          end\n\n          Discourse.redis.setex(cache_key_body,  cache_duration, compress(parts.join))\n          Discourse.redis.setex(cache_key_other, cache_duration, [status, headers_stripped].to_json)\n\n          headers[\"X-Discourse-Cached\"] = \"store\"\n        else\n          parts = response\n        end\n\n        [status, headers, parts]\n      end\n\n      def clear_cache\n        Discourse.redis.del(cache_key_body)\n        Discourse.redis.del(cache_key_other)\n      end\n\n    end\n\n    def initialize(app, settings = {})\n      @app = app\n    end\n\n    PAYLOAD_INVALID_REQUEST_METHODS = [\"GET\", \"HEAD\"]\n\n    def call(env)\n      if PAYLOAD_INVALID_REQUEST_METHODS.include?(env[Rack::REQUEST_METHOD]) &&\n        env[Rack::RACK_INPUT].size > 0\n\n        return [413, { \"Cache-Control\" => \"private, max-age=0, must-revalidate\" }, []]\n      end\n\n      helper = Helper.new(env)\n      force_anon = false\n\n      if helper.blocked_crawler?\n        env[\"discourse.request_tracker.skip\"] = true\n        return [403, {}, [\"Crawler is not allowed!\"]]\n      end\n\n      if helper.should_force_anonymous?\n        force_anon = env[\"DISCOURSE_FORCE_ANON\"] = true\n        helper.force_anonymous!\n      end\n\n      if (env[\"HTTP_DISCOURSE_BACKGROUND\"] == \"true\") && (queue_time = env[\"REQUEST_QUEUE_SECONDS\"])\n        max_time = GlobalSetting.background_requests_max_queue_length.to_f\n        if max_time > 0 && queue_time.to_f > max_time\n          return [\n            429,\n            {\n              \"content-type\" => \"application/json; charset=utf-8\"\n            },\n            [{\n              errors: I18n.t(\"rate_limiter.slow_down\"),\n              extras: {\n                wait_seconds: 5 + (5 * rand).round(2)\n              }\n            }.to_json]\n          ]\n        end\n      end\n\n      result =\n        if helper.cacheable?\n          helper.cached(env) || helper.cache(@app.call(env), env)\n        else\n          @app.call(env)\n        end\n\n      if force_anon\n        result[1][\"Set-Cookie\"] = \"dosp=1; Path=/\"\n      end\n\n      result\n    end\n\n  end\n\nend\n", "# frozen_string_literal: true\n\n# since all the rescue from clauses are not caught by the application controller for matches\n# we need to handle certain exceptions here\nmodule Middleware\n  class DiscoursePublicExceptions < ::ActionDispatch::PublicExceptions\n\n    def initialize(path)\n      super\n    end\n\n    def call(env)\n      # this is so so gnarly\n      # sometimes we leak out exceptions prior to creating a controller instance\n      # this can happen if we have an exception in a route constraint in some cases\n      # this code re-dispatches the exception to our application controller so we can\n      # properly translate the exception to a page\n      exception = env[\"action_dispatch.exception\"]\n      response = ActionDispatch::Response.new\n\n      # Special handling for invalid params, in this case we can not re-dispatch\n      # the Request object has a \"broken\" .params which can not be accessed\n      exception = nil if Rack::QueryParser::InvalidParameterError === exception\n\n      # We also can not dispatch bad requests as no proper params\n      exception = nil if ActionController::BadRequest === exception\n\n      if exception\n        begin\n          fake_controller = ApplicationController.new\n          fake_controller.response = response\n          fake_controller.request = request = ActionDispatch::Request.new(env)\n\n          # We can not re-dispatch bad mime types\n          begin\n            request.format\n          rescue Mime::Type::InvalidMimeType\n            return [400, { \"Cache-Control\" => \"private, max-age=0, must-revalidate\" }, [\"Invalid MIME type\"]]\n          end\n\n          if ApplicationController.rescue_with_handler(exception, object: fake_controller)\n            body = response.body\n            if String === body\n              body = [body]\n            end\n            return [response.status, response.headers, body]\n          end\n        rescue => e\n          Discourse.warn_exception(e, message: \"Failed to handle exception in exception app middleware\")\n        end\n\n      end\n      super\n    end\n\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Middleware::AnonymousCache do\n  let(:middleware) { Middleware::AnonymousCache.new(lambda { |_| [200, {}, []] }) }\n\n  def env(opts = {})\n    Rack::MockRequest.env_for(\"http://test.com/path?bla=1\").merge(opts)\n  end\n\n  describe Middleware::AnonymousCache::Helper do\n    def new_helper(opts = {})\n      Middleware::AnonymousCache::Helper.new(env(opts))\n    end\n\n    context \"cachable?\" do\n      it \"true by default\" do\n        expect(new_helper.cacheable?).to eq(true)\n      end\n\n      it \"is false for non GET\" do\n        expect(new_helper(\"ANON_CACHE_DURATION\" => 10, \"REQUEST_METHOD\" => \"POST\").cacheable?).to eq(false)\n      end\n\n      it \"is false if it has an auth cookie\" do\n        expect(new_helper(\"HTTP_COOKIE\" => \"jack=1; _t=#{\"1\" * 32}; jill=2\").cacheable?).to eq(false)\n      end\n\n      it \"is false for srv/status routes\" do\n        expect(new_helper(\"PATH_INFO\" => \"/srv/status\").cacheable?).to eq(false)\n      end\n    end\n\n    context \"per theme cache\" do\n      it \"handles theme keys\" do\n        theme = Fabricate(:theme, user_selectable: true)\n\n        with_bad_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=abc\").cache_key\n        with_no_theme_key = new_helper().cache_key\n\n        expect(with_bad_theme_key).to eq(with_no_theme_key)\n\n        with_good_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=#{theme.id}\").cache_key\n\n        expect(with_good_theme_key).not_to eq(with_no_theme_key)\n      end\n    end\n\n    context \"with header-based locale locale\" do\n      it \"handles different languages\" do\n        # Normally does not check the language header\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(french1)\n        expect(none).to eq(french2)\n        expect(none).to eq(english)\n\n        SiteSetting.allow_user_locale = true\n        SiteSetting.set_locale_from_accept_language_header = true\n\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(english)\n        expect(french1).to eq(french2)\n        expect(french1).not_to eq(none)\n      end\n    end\n\n    context \"cached\" do\n      let!(:helper) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10)\n      end\n\n      let!(:crawler) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_USER_AGENT\" => \"AdsBot-Google (+http://www.google.com/adsbot.html)\")\n      end\n\n      after do\n        helper.clear_cache\n        crawler.clear_cache\n      end\n\n      before do\n        global_setting :anon_cache_store_threshold, 1\n      end\n\n      it \"compresses body on demand\" do\n        global_setting :compress_anon_cache, true\n\n        payload = \"x\" * 1000\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [payload]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [payload]])\n\n        # depends on i7z implementation, but lets assume it is stable unless we discover\n        # otherwise\n        expect(Discourse.redis.get(helper.cache_key_body).length).to eq(16)\n      end\n\n      it \"handles brotli switching\" do\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_ACCEPT_ENCODING\" => \"gz, br\")\n        expect(helper.cached).to eq(nil)\n      end\n\n      it \"returns cached data for cached requests\" do\n        helper.is_mobile = true\n        expect(helper.cached).to eq(nil)\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        helper.is_mobile = true\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        expect(crawler.cached).to eq(nil)\n        crawler.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"world\"]])\n        expect(crawler.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello world\"]])\n      end\n    end\n  end\n\n  context 'background request rate limit' do\n    it 'will rate limit background requests' do\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :background_requests_max_queue_length, \"0.5\"\n\n      env = {\n        \"HTTP_COOKIE\" => \"_t=#{SecureRandom.hex}\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      }\n\n      # non background ... long request\n      env[\"REQUEST_QUEUE_SECONDS\"] = 2\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n      env[\"HTTP_DISCOURSE_BACKGROUND\"] = \"true\"\n\n      status, headers, body = app.call(env.dup)\n      expect(status).to eq(429)\n      expect(headers[\"content-type\"]).to eq(\"application/json; charset=utf-8\")\n      json = JSON.parse(body.join)\n      expect(json[\"extras\"][\"wait_seconds\"]).to be > 4.9\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.4\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n    end\n  end\n\n  context 'force_anonymous!' do\n    before do\n      RateLimiter.enable\n    end\n\n    after do\n      RateLimiter.disable\n    end\n\n    it 'will revert to anonymous once we reach the limit' do\n\n      RateLimiter.clear_all!\n\n      is_anon = false\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          is_anon = env[\"HTTP_COOKIE\"].nil?\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :force_anonymous_min_per_10_seconds, 2\n      global_setting :force_anonymous_min_queue_seconds, 1\n\n      env = {\n        \"HTTP_COOKIE\" => \"_t=#{SecureRandom.hex}\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      }\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      _status, headers, _body = app.call(env.dup)\n      expect(is_anon).to eq(true)\n      expect(headers['Set-Cookie']).to eq('dosp=1; Path=/')\n\n      # tricky change, a 50ms delay still will trigger protection\n      # once it is tripped\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.05\n      is_anon = false\n\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.01\n\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n    end\n  end\n\n  context 'invalid request payload' do\n    it 'returns 413 for GET request with payload' do\n      status, headers, _ = middleware.call(env.tap do |environment|\n        environment[Rack::RACK_INPUT].write(\"test\")\n      end)\n\n      expect(status).to eq(413)\n      expect(headers[\"Cache-Control\"]).to eq(\"private, max-age=0, must-revalidate\")\n    end\n  end\n\n  context \"crawler blocking\" do\n    let :non_crawler do\n      {\n        \"HTTP_USER_AGENT\" =>\n        \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36\"\n      }\n    end\n\n    def get(path, options)\n      @env = env({\n        \"REQUEST_URI\" => path,\n        \"PATH_INFO\" => path,\n        \"REQUEST_PATH\" => path\n      }.merge(options[:headers]))\n      @status, @response_header, @response = middleware.call(@env)\n    end\n\n    it \"applies allowed_crawler_user_agents correctly\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Anotherbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n      expect(@response).to be_an(Array)\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n    end\n\n    it \"doesn't block api requests\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n      api_key = Fabricate(:api_key)\n\n      get \"/latest?api_key=#{api_key.key}&api_username=system\", headers: {\n        \"QUERY_STRING\" => \"api_key=#{api_key.key}&api_username=system\"\n      }\n      expect(@status).to eq(200)\n    end\n\n    it \"applies blocked_crawler_user_agents correctly\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Twitterbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block robots.txt\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/robots.txt', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block srv/status\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"blocked crawlers shouldn't log page views\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@env[\"discourse.request_tracker.skip\"]).to eq(true)\n    end\n\n    it \"blocks json requests\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status.json', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n    end\n  end\n\nend\n"], "buggy_code_start_loc": [317, 38, 246], "buggy_code_end_loc": [318, 39, 250], "fixing_code_start_loc": [317, 38, 246], "fixing_code_end_loc": [318, 39, 252], "type": "CWE-200", "message": "Discourse is a platform for community discussion. In affected versions a maliciously crafted request could cause an error response to be cached by intermediate proxies. This could cause a loss of confidentiality for some content. This issue is patched in the latest stable, beta and tests-passed versions of Discourse.", "other": {"cve": {"id": "CVE-2021-41271", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-15T22:15:06.977", "lastModified": "2021-11-17T21:05:34.893", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is a platform for community discussion. In affected versions a maliciously crafted request could cause an error response to be cached by intermediate proxies. This could cause a loss of confidentiality for some content. This issue is patched in the latest stable, beta and tests-passed versions of Discourse."}, {"lang": "es", "value": "Discourse es una plataforma para el debate comunitario. En versiones afectadas, una petici\u00f3n maliciosamente dise\u00f1ada podr\u00eda causar una respuesta de error en la cach\u00e9 de los proxies intermedios. Esto podr\u00eda causar una p\u00e9rdida de confidencialidad para algunos contenidos. Este problema est\u00e1 parcheado en las \u00faltimas versiones estables, beta y de prueba de Discourse"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.7.9", "matchCriteriaId": "4F4E4C94-85B8-496F-AD91-28CFA7D7189E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9E7F8AC4-35D1-45E5-8A3A-B0205000A5D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B9AE12FE-0396-4843-8D30-D8C44FAE01DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F101AEAB-4FB7-4BE3-931B-595702D616C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F6878B7F-2691-4D3F-8116-CB282FDAAAC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "76EABAB9-BEA4-48D4-ADBA-D00746B29C52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "82A255A2-4658-41AD-A4DE-A7F8D018028D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "E5804585-2EA4-4677-8EC1-5F561D5C7D7A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/2da0001965c6d8632d723c46ea5df9f22a1a23f1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-hf6r-mc9j-hf4p", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/2da0001965c6d8632d723c46ea5df9f22a1a23f1"}}