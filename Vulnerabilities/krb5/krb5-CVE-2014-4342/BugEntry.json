{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2001, 2007 by the Massachusetts Institute of Technology.\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Copyright (C) 1998 by the FundsXpress, INC.\n *\n * All rights reserved.\n *\n * Export of this software from the United States of America may require\n * a specific license from the United States Government.  It is the\n * responsibility of any person or organization contemplating export to\n * obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of FundsXpress. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  FundsXpress makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include \"gssapiP_krb5.h\"\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif\n#include <assert.h>\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nstatic OM_uint32\nkg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,\n             conf_state, qop_state, toktype)\n    krb5_context context;\n    OM_uint32 *minor_status;\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    int bodysize;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_error_code code;\n    int conflen = 0;\n    int signalg;\n    int sealalg;\n    gss_buffer_desc token;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    krb5_data plaind;\n    char *data_ptr;\n    unsigned char *plain;\n    unsigned int cksum_len = 0;\n    size_t plainlen;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        message_buffer->length = 0;\n        message_buffer->value = NULL;\n    }\n\n    /* get the sign and seal algorithms */\n\n    signalg = ptr[0] + (ptr[1]<<8);\n    sealalg = ptr[2] + (ptr[3]<<8);\n\n    /* Sanity checks */\n\n    if ((ptr[4] != 0xff) || (ptr[5] != 0xff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((toktype != KG_TOK_SEAL_MSG) &&\n        (sealalg != 0xffff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* in the current spec, there is only one valid seal algorithm per\n       key type, so a simple comparison is ok */\n\n    if ((toktype == KG_TOK_SEAL_MSG) &&\n        !((sealalg == 0xffff) ||\n          (sealalg == ctx->sealalg))) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* there are several mappings of seal algorithms to sign algorithms,\n       but few enough that we can try them all. */\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_SEAL_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n\n    if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,\n                               &seqnum))) {\n        *minor_status = code;\n        return(GSS_S_BAD_SIG);\n    }\n\n    /* decode the message, if SEAL */\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        size_t tmsglen = bodysize-(14+cksum_len);\n        if (sealalg != 0xffff) {\n            if ((plain = (unsigned char *) xmalloc(tmsglen)) == NULL) {\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                int i;\n                store_32_be(seqnum, bigend_seqnum);\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code)\n                {\n                    xfree(plain);\n                    *minor_status = code;\n                    return(GSS_S_FAILURE);\n                }\n\n                assert (enc_key->length == 16);\n                for (i = 0; i <= 15; i++)\n                    ((char *) enc_key->contents)[i] ^=0xf0;\n                code = kg_arcfour_docrypt (enc_key, 0,\n                                           &bigend_seqnum[0], 4,\n                                           ptr+14+cksum_len, tmsglen,\n                                           plain);\n                krb5_free_keyblock (context, enc_key);\n            } else {\n                code = kg_decrypt(context, ctx->enc, KG_USAGE_SEAL, NULL,\n                                  ptr+14+cksum_len, plain, tmsglen);\n            }\n            if (code) {\n                xfree(plain);\n                *minor_status = code;\n                return(GSS_S_FAILURE);\n            }\n        } else {\n            plain = ptr+14+cksum_len;\n        }\n\n        plainlen = tmsglen;\n\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n        token.length = tmsglen - conflen - plain[tmsglen-1];\n\n        if (token.length) {\n            if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {\n                if (sealalg != 0xffff)\n                    xfree(plain);\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            memcpy(token.value, plain+conflen, token.length);\n        } else {\n            token.value = NULL;\n        }\n    } else if (toktype == KG_TOK_SIGN_MSG) {\n        token = *message_buffer;\n        plain = token.value;\n        plainlen = token.length;\n    } else {\n        token.length = 0;\n        token.value = NULL;\n        plain = token.value;\n        plainlen = token.length;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the the cksum */\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort ();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code)\n        return(code);\n    md5cksum.length = sumlen;\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (signalg == 0)\n            cksum.length = 8;\n        else\n            cksum.length = 16;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n\n    case SGN_ALG_MD2_5:\n        if (!ctx->seed_init &&\n            (code = kg_make_seed(context, ctx->subkey, ctx->seed))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (! (data_ptr = xmalloc(sizeof(ctx->seed) + 8 + plainlen))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n        (void) memcpy(data_ptr, ptr-2, 8);\n        (void) memcpy(data_ptr+8, ctx->seed, sizeof(ctx->seed));\n        (void) memcpy(data_ptr+8+sizeof(ctx->seed), plain, plainlen);\n        plaind.length = 8 + sizeof(ctx->seed) + plainlen;\n        plaind.data = data_ptr;\n        krb5_free_checksum_contents(context, &md5cksum);\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, 8);\n        /* Falls through to defective-token??  */\n\n    default:\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    }\n\n    krb5_free_checksum_contents(context, &md5cksum);\n    if (sealalg != 0xffff)\n        xfree(plain);\n\n    /* compare the computed checksum against the transmitted checksum */\n\n    if (code) {\n        if (toktype == KG_TOK_SEAL_MSG)\n            gssalloc_free(token.value);\n        *minor_status = 0;\n        return(GSS_S_BAD_SIG);\n    }\n\n\n    /* it got through unscathed.  Make sure the context is unexpired */\n\n    if (toktype == KG_TOK_SEAL_MSG)\n        *message_buffer = token;\n\n    if (conf_state)\n        *conf_state = (sealalg != 0xffff);\n\n    if (qop_state)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    /* do sequencing checks */\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        if (toktype == KG_TOK_SEAL_MSG) {\n            gssalloc_free(token.value);\n            message_buffer->value = NULL;\n            message_buffer->length = 0;\n        }\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        return(GSS_S_BAD_SIG);\n    }\n\n    retval = g_order_check(&(ctx->seqstate), (gssint_uint64)seqnum);\n\n    /* success or ordering violation */\n\n    *minor_status = 0;\n    return(retval);\n}\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nOM_uint32\nkg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n\n\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n\n    return ret;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap(minor_status, context_handle,\n                input_message_buffer, output_message_buffer,\n                conf_state, qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        input_message_buffer;\n    gss_buffer_t        output_message_buffer;\n    int                 *conf_state;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      input_message_buffer, output_message_buffer,\n                      conf_state, qop_state, KG_TOK_WRAP_MSG);\n    return(rstat);\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic(minor_status, context_handle,\n                    message_buffer, token_buffer,\n                    qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        message_buffer;\n    gss_buffer_t        token_buffer;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      token_buffer, message_buffer,\n                      NULL, qop_state, KG_TOK_MIC_MSG);\n    return(rstat);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/gssapi/krb5/k5unsealiov.c */\n/*\n * Copyright 2008, 2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include <assert.h>\n#include \"k5-platform.h\"        /* for 64-bit support */\n#include \"k5-int.h\"          /* for zap() */\n#include \"gssapiP_krb5.h\"\n#include <stdarg.h>\n\nstatic OM_uint32\nkg_unseal_v1_iov(krb5_context context,\n                 OM_uint32 *minor_status,\n                 krb5_gss_ctx_id_rec *ctx,\n                 gss_iov_buffer_desc *iov,\n                 int iov_count,\n                 size_t token_wrapper_len,\n                 int *conf_state,\n                 gss_qop_t *qop_state,\n                 int toktype)\n{\n    OM_uint32 code;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t trailer;\n    unsigned char *ptr;\n    int sealalg;\n    int signalg;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    size_t cksum_len = 0;\n    size_t conflen = 0;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    md5cksum.length = cksum.length = 0;\n    md5cksum.contents = cksum.contents = NULL;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    assert(header != NULL);\n\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n    if (trailer != NULL && trailer->buffer.length != 0) {\n        *minor_status = (OM_uint32)KRB5_BAD_MSIZE;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (header->buffer.length < token_wrapper_len + 14) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    ptr = (unsigned char *)header->buffer.value + token_wrapper_len;\n\n    signalg  = ptr[0];\n    signalg |= ptr[1] << 8;\n\n    sealalg  = ptr[2];\n    sealalg |= ptr[3] << 8;\n\n    if (ptr[4] != 0xFF || ptr[5] != 0xFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype == KG_TOK_WRAP_MSG &&\n        !(sealalg == 0xFFFF || sealalg == ctx->sealalg)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_WRAP_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n    code = kg_get_seq_num(context, ctx->seq, ptr + 14, ptr + 6, &direction,\n                          &seqnum);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_BAD_SIG;\n    }\n\n    /* decode the message, if SEAL */\n    if (toktype == KG_TOK_WRAP_MSG) {\n        if (sealalg != 0xFFFF) {\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                size_t i;\n\n                store_32_be(seqnum, bigend_seqnum);\n\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code != 0) {\n                    retval = GSS_S_FAILURE;\n                    goto cleanup;\n                }\n\n                assert(enc_key->length == 16);\n\n                for (i = 0; i < enc_key->length; i++)\n                    ((char *)enc_key->contents)[i] ^= 0xF0;\n\n                code = kg_arcfour_docrypt_iov(context, enc_key, 0,\n                                              &bigend_seqnum[0], 4,\n                                              iov, iov_count);\n                krb5_free_keyblock(context, enc_key);\n            } else {\n                code = kg_decrypt_iov(context, 0,\n                                      ((ctx->gss_flags & GSS_C_DCE_STYLE) != 0),\n                                      0 /*EC*/, 0 /*RRC*/,\n                                      ctx->enc, KG_USAGE_SEAL, NULL,\n                                      iov, iov_count);\n            }\n            if (code != 0) {\n                retval = GSS_S_FAILURE;\n                goto cleanup;\n            }\n        }\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n    }\n\n    if (header->buffer.length != token_wrapper_len + 14 + cksum_len + conflen) {\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the checksum */\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n    md5cksum.length = sumlen;\n\n    /* compute the checksum of the message */\n    code = kg_make_checksum_iov_v1(context, md5cksum.checksum_type,\n                                   cksum_len, ctx->seq, ctx->enc,\n                                   sign_usage, iov, iov_count, toktype,\n                                   &md5cksum);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code != 0) {\n            retval = GSS_S_FAILURE;\n            goto cleanup;\n        }\n\n        cksum.length = cksum_len;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    default:\n        code = 0;\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    if (code != 0) {\n        code = 0;\n        retval = GSS_S_BAD_SIG;\n        goto cleanup;\n    }\n\n    /*\n     * For GSS_C_DCE_STYLE, the caller manages the padding, because the\n     * pad length is in the RPC PDU. The value of the padding may be\n     * uninitialized. For normal GSS, the last bytes of the decrypted\n     * data contain the pad length. kg_fixup_padding_iov() will find\n     * this and fixup the last data IOV appropriately.\n     */\n    if (toktype == KG_TOK_WRAP_MSG &&\n        (ctx->gss_flags & GSS_C_DCE_STYLE) == 0) {\n        retval = kg_fixup_padding_iov(&code, iov, iov_count);\n        if (retval != GSS_S_COMPLETE)\n            goto cleanup;\n    }\n\n    if (conf_state != NULL)\n        *conf_state = (sealalg != 0xFFFF);\n\n    if (qop_state != NULL)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        retval = GSS_S_BAD_SIG;\n    }\n\n    code = 0;\n    retval = g_order_check(&ctx->seqstate, (gssint_uint64)seqnum);\n\ncleanup:\n    krb5_free_checksum_contents(context, &md5cksum);\n\n    *minor_status = code;\n\n    return retval;\n}\n\n/*\n * Caller must provide TOKEN | DATA | PADDING | TRAILER, except\n * for DCE in which case it can just provide TOKEN | DATA (must\n * guarantee that DATA is padded)\n */\nstatic OM_uint32\nkg_unseal_iov_token(OM_uint32 *minor_status,\n                    krb5_gss_ctx_id_rec *ctx,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count,\n                    int toktype)\n{\n    krb5_error_code code;\n    krb5_context context = ctx->k5_context;\n    unsigned char *ptr;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t padding;\n    gss_iov_buffer_t trailer;\n    size_t input_length;\n    unsigned int bodysize;\n    int toktype2;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    if (header == NULL) {\n        *minor_status = EINVAL;\n        return GSS_S_FAILURE;\n    }\n\n    padding = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_PADDING);\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n\n    ptr = (unsigned char *)header->buffer.value;\n    input_length = header->buffer.length;\n\n    if ((ctx->gss_flags & GSS_C_DCE_STYLE) == 0 &&\n        toktype == KG_TOK_WRAP_MSG) {\n        size_t data_length, assoc_data_length;\n\n        kg_iov_msglen(iov, iov_count, &data_length, &assoc_data_length);\n\n        input_length += data_length - assoc_data_length;\n\n        if (padding != NULL)\n            input_length += padding->buffer.length;\n\n        if (trailer != NULL)\n            input_length += trailer->buffer.length;\n    }\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 input_length, 0);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        code = gss_krb5int_unseal_v3_iov(context, minor_status, ctx, iov, iov_count,\n                                         conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        code = kg_unseal_v1_iov(context, minor_status, ctx, iov, iov_count,\n                                (size_t)(ptr - (unsigned char *)header->buffer.value),\n                                conf_state, qop_state, toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        code = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (code != 0)\n        save_error_info(*minor_status, context);\n\n    return code;\n}\n\n/*\n * Split a STREAM | SIGN_DATA | DATA into\n *         HEADER | SIGN_DATA | DATA | PADDING | TRAILER\n */\nstatic OM_uint32\nkg_unseal_stream_iov(OM_uint32 *minor_status,\n                     krb5_gss_ctx_id_rec *ctx,\n                     int *conf_state,\n                     gss_qop_t *qop_state,\n                     gss_iov_buffer_desc *iov,\n                     int iov_count,\n                     int toktype)\n{\n    unsigned char *ptr;\n    unsigned int bodysize;\n    OM_uint32 code = 0, major_status = GSS_S_FAILURE;\n    krb5_context context = ctx->k5_context;\n    int conf_req_flag, toktype2;\n    int i = 0, j;\n    gss_iov_buffer_desc *tiov = NULL;\n    gss_iov_buffer_t stream, data = NULL;\n    gss_iov_buffer_t theader, tdata = NULL, tpadding, ttrailer;\n\n    assert(toktype == KG_TOK_WRAP_MSG);\n\n    if (toktype != KG_TOK_WRAP_MSG || (ctx->gss_flags & GSS_C_DCE_STYLE)) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    stream = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM);\n    assert(stream != NULL);\n\n    ptr = (unsigned char *)stream->buffer.value;\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 stream->buffer.length, 0);\n    if (code != 0) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    tiov = (gss_iov_buffer_desc *)calloc((size_t)iov_count + 2, sizeof(gss_iov_buffer_desc));\n    if (tiov == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n\n    /* HEADER */\n    theader = &tiov[i++];\n    theader->type = GSS_IOV_BUFFER_TYPE_HEADER;\n    theader->buffer.value = stream->buffer.value;\n    theader->buffer.length = ptr - (unsigned char *)stream->buffer.value;\n    if (bodysize < 14 ||\n        stream->buffer.length != theader->buffer.length + bodysize) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n    theader->buffer.length += 14;\n\n    /* n[SIGN_DATA] | DATA | m[SIGN_DATA] */\n    for (j = 0; j < iov_count; j++) {\n        OM_uint32 type = GSS_IOV_BUFFER_TYPE(iov[j].type);\n\n        if (type == GSS_IOV_BUFFER_TYPE_DATA) {\n            if (data != NULL) {\n                /* only a single DATA buffer can appear */\n                code = EINVAL;\n                goto cleanup;\n            }\n\n            data = &iov[j];\n            tdata = &tiov[i];\n        }\n        if (type == GSS_IOV_BUFFER_TYPE_DATA ||\n            type == GSS_IOV_BUFFER_TYPE_SIGN_ONLY)\n            tiov[i++] = iov[j];\n    }\n\n    if (data == NULL) {\n        /* a single DATA buffer must be present */\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    /* PADDING | TRAILER */\n    tpadding = &tiov[i++];\n    tpadding->type = GSS_IOV_BUFFER_TYPE_PADDING;\n    tpadding->buffer.length = 0;\n    tpadding->buffer.value = NULL;\n\n    ttrailer = &tiov[i++];\n    ttrailer->type = GSS_IOV_BUFFER_TYPE_TRAILER;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX: {\n        size_t ec, rrc;\n        krb5_enctype enctype;\n        unsigned int k5_headerlen = 0;\n        unsigned int k5_trailerlen = 0;\n\n        if (ctx->have_acceptor_subkey)\n            enctype = ctx->acceptor_subkey->keyblock.enctype;\n        else\n            enctype = ctx->subkey->keyblock.enctype;\n        conf_req_flag = ((ptr[0] & FLAG_WRAP_CONFIDENTIAL) != 0);\n        ec = conf_req_flag ? load_16_be(ptr + 2) : 0;\n        rrc = load_16_be(ptr + 4);\n\n        if (rrc != 0) {\n            if (!gss_krb5int_rotate_left((unsigned char *)stream->buffer.value + 16,\n                                         stream->buffer.length - 16, rrc)) {\n                code = ENOMEM;\n                goto cleanup;\n            }\n            store_16_be(0, ptr + 4); /* set RRC to zero */\n        }\n\n        if (conf_req_flag) {\n            code = krb5_c_crypto_length(context, enctype, KRB5_CRYPTO_TYPE_HEADER, &k5_headerlen);\n            if (code != 0)\n                goto cleanup;\n            theader->buffer.length += k5_headerlen; /* length validated later */\n        }\n\n        /* no PADDING for CFX, EC is used instead */\n        code = krb5_c_crypto_length(context, enctype,\n                                    conf_req_flag ? KRB5_CRYPTO_TYPE_TRAILER : KRB5_CRYPTO_TYPE_CHECKSUM,\n                                    &k5_trailerlen);\n        if (code != 0)\n            goto cleanup;\n\n        ttrailer->buffer.length = ec + (conf_req_flag ? 16 : 0 /* E(Header) */) + k5_trailerlen;\n        ttrailer->buffer.value = (unsigned char *)stream->buffer.value +\n            stream->buffer.length - ttrailer->buffer.length;\n        break;\n    }\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        theader->buffer.length += ctx->cksum_size +\n            kg_confounder_size(context, ctx->enc->keyblock.enctype);\n\n        /*\n         * we can't set the padding accurately until decryption;\n         * kg_fixup_padding_iov() will take care of this\n         */\n        tpadding->buffer.length = 1;\n        tpadding->buffer.value = (unsigned char *)stream->buffer.value + stream->buffer.length - 1;\n\n        /* no TRAILER for pre-CFX */\n        ttrailer->buffer.length = 0;\n        ttrailer->buffer.value = NULL;\n\n        break;\n    default:\n        code = (OM_uint32)G_BAD_TOK_HEADER;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    /* IOV: -----------0-------------+---1---+--2--+----------------3--------------*/\n    /* Old: GSS-Header | Conf        | Data  | Pad |                               */\n    /* CFX: GSS-Header | Kerb-Header | Data  |     | EC | E(Header) | Kerb-Trailer */\n    /* GSS: -------GSS-HEADER--------+-DATA--+-PAD-+----------GSS-TRAILER----------*/\n\n    /* validate lengths */\n    if (stream->buffer.length < theader->buffer.length +\n        tpadding->buffer.length +\n        ttrailer->buffer.length)\n    {\n        code = (OM_uint32)KRB5_BAD_MSIZE;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* setup data */\n    tdata->buffer.length = stream->buffer.length - ttrailer->buffer.length -\n        tpadding->buffer.length - theader->buffer.length;\n\n    assert(data != NULL);\n\n    if (data->type & GSS_IOV_BUFFER_FLAG_ALLOCATE) {\n        code = kg_allocate_iov(tdata, tdata->buffer.length);\n        if (code != 0)\n            goto cleanup;\n        memcpy(tdata->buffer.value,\n               (unsigned char *)stream->buffer.value + theader->buffer.length, tdata->buffer.length);\n    } else\n        tdata->buffer.value = (unsigned char *)stream->buffer.value + theader->buffer.length;\n\n    assert(i <= iov_count + 2);\n\n    major_status = kg_unseal_iov_token(&code, ctx, conf_state, qop_state,\n                                       tiov, i, toktype);\n    if (major_status == GSS_S_COMPLETE)\n        *data = *tdata;\n    else\n        kg_release_iov(tdata, 1);\n\ncleanup:\n    if (tiov != NULL)\n        free(tiov);\n\n    *minor_status = code;\n\n    return major_status;\n}\n\nOM_uint32\nkg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap_iov(OM_uint32 *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 conf_state, qop_state,\n                                 iov, iov_count, KG_TOK_WRAP_MSG);\n\n    return major_status;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic_iov(OM_uint32 *minor_status,\n                        gss_ctx_id_t context_handle,\n                        gss_qop_t *qop_state,\n                        gss_iov_buffer_desc *iov,\n                        int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 NULL, qop_state,\n                                 iov, iov_count, KG_TOK_MIC_MSG);\n\n    return major_status;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2001, 2007 by the Massachusetts Institute of Technology.\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Copyright (C) 1998 by the FundsXpress, INC.\n *\n * All rights reserved.\n *\n * Export of this software from the United States of America may require\n * a specific license from the United States Government.  It is the\n * responsibility of any person or organization contemplating export to\n * obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of FundsXpress. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  FundsXpress makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include \"gssapiP_krb5.h\"\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif\n#include <assert.h>\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nstatic OM_uint32\nkg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,\n             conf_state, qop_state, toktype)\n    krb5_context context;\n    OM_uint32 *minor_status;\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    int bodysize;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_error_code code;\n    int conflen = 0;\n    int signalg;\n    int sealalg;\n    int bad_pad = 0;\n    gss_buffer_desc token;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    krb5_data plaind;\n    char *data_ptr;\n    unsigned char *plain;\n    unsigned int cksum_len = 0;\n    size_t plainlen;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    size_t padlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        message_buffer->length = 0;\n        message_buffer->value = NULL;\n    }\n\n    /* Sanity checks */\n\n    if (ctx->seq == NULL) {\n        /* ctx was established using a newer enctype, and cannot process RFC\n         * 1964 tokens. */\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((bodysize < 22) || (ptr[4] != 0xff) || (ptr[5] != 0xff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    signalg = ptr[0] + (ptr[1]<<8);\n    sealalg = ptr[2] + (ptr[3]<<8);\n\n    if ((toktype != KG_TOK_SEAL_MSG) &&\n        (sealalg != 0xffff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* in the current spec, there is only one valid seal algorithm per\n       key type, so a simple comparison is ok */\n\n    if ((toktype == KG_TOK_SEAL_MSG) &&\n        !((sealalg == 0xffff) ||\n          (sealalg == ctx->sealalg))) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* there are several mappings of seal algorithms to sign algorithms,\n       but few enough that we can try them all. */\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_SEAL_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((size_t)bodysize < 14 + cksum_len) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n\n    if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,\n                               &seqnum))) {\n        *minor_status = code;\n        return(GSS_S_BAD_SIG);\n    }\n\n    /* decode the message, if SEAL */\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        size_t tmsglen = bodysize-(14+cksum_len);\n        if (sealalg != 0xffff) {\n            if ((plain = (unsigned char *) xmalloc(tmsglen)) == NULL) {\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                int i;\n                store_32_be(seqnum, bigend_seqnum);\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code)\n                {\n                    xfree(plain);\n                    *minor_status = code;\n                    return(GSS_S_FAILURE);\n                }\n\n                assert (enc_key->length == 16);\n                for (i = 0; i <= 15; i++)\n                    ((char *) enc_key->contents)[i] ^=0xf0;\n                code = kg_arcfour_docrypt (enc_key, 0,\n                                           &bigend_seqnum[0], 4,\n                                           ptr+14+cksum_len, tmsglen,\n                                           plain);\n                krb5_free_keyblock (context, enc_key);\n            } else {\n                code = kg_decrypt(context, ctx->enc, KG_USAGE_SEAL, NULL,\n                                  ptr+14+cksum_len, plain, tmsglen);\n            }\n            if (code) {\n                xfree(plain);\n                *minor_status = code;\n                return(GSS_S_FAILURE);\n            }\n        } else {\n            plain = ptr+14+cksum_len;\n        }\n\n        plainlen = tmsglen;\n\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n        if (tmsglen < conflen) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            *minor_status = 0;\n            return(GSS_S_DEFECTIVE_TOKEN);\n        }\n        padlen = plain[tmsglen - 1];\n        if (tmsglen - conflen < padlen) {\n            /* Don't error out yet, to avoid padding oracle attacks.  We will\n             * treat this as a checksum failure later on. */\n            padlen = 0;\n            bad_pad = 1;\n        }\n        token.length = tmsglen - conflen - padlen;\n\n        if (token.length) {\n            if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {\n                if (sealalg != 0xffff)\n                    xfree(plain);\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            memcpy(token.value, plain+conflen, token.length);\n        } else {\n            token.value = NULL;\n        }\n    } else if (toktype == KG_TOK_SIGN_MSG) {\n        token = *message_buffer;\n        plain = token.value;\n        plainlen = token.length;\n    } else {\n        token.length = 0;\n        token.value = NULL;\n        plain = token.value;\n        plainlen = token.length;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the the cksum */\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort ();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code)\n        return(code);\n    md5cksum.length = sumlen;\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (signalg == 0)\n            cksum.length = 8;\n        else\n            cksum.length = 16;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n\n    case SGN_ALG_MD2_5:\n        if (!ctx->seed_init &&\n            (code = kg_make_seed(context, ctx->subkey, ctx->seed))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (! (data_ptr = xmalloc(sizeof(ctx->seed) + 8 + plainlen))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n        (void) memcpy(data_ptr, ptr-2, 8);\n        (void) memcpy(data_ptr+8, ctx->seed, sizeof(ctx->seed));\n        (void) memcpy(data_ptr+8+sizeof(ctx->seed), plain, plainlen);\n        plaind.length = 8 + sizeof(ctx->seed) + plainlen;\n        plaind.data = data_ptr;\n        krb5_free_checksum_contents(context, &md5cksum);\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, 8);\n        /* Falls through to defective-token??  */\n\n    default:\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    }\n\n    krb5_free_checksum_contents(context, &md5cksum);\n    if (sealalg != 0xffff)\n        xfree(plain);\n\n    /* compare the computed checksum against the transmitted checksum */\n\n    if (code || bad_pad) {\n        if (toktype == KG_TOK_SEAL_MSG)\n            gssalloc_free(token.value);\n        *minor_status = 0;\n        return(GSS_S_BAD_SIG);\n    }\n\n\n    /* it got through unscathed.  Make sure the context is unexpired */\n\n    if (toktype == KG_TOK_SEAL_MSG)\n        *message_buffer = token;\n\n    if (conf_state)\n        *conf_state = (sealalg != 0xffff);\n\n    if (qop_state)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    /* do sequencing checks */\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        if (toktype == KG_TOK_SEAL_MSG) {\n            gssalloc_free(token.value);\n            message_buffer->value = NULL;\n            message_buffer->length = 0;\n        }\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        return(GSS_S_BAD_SIG);\n    }\n\n    retval = g_order_check(&(ctx->seqstate), (gssint_uint64)seqnum);\n\n    /* success or ordering violation */\n\n    *minor_status = 0;\n    return(retval);\n}\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nOM_uint32\nkg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n\n\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n\n    return ret;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap(minor_status, context_handle,\n                input_message_buffer, output_message_buffer,\n                conf_state, qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        input_message_buffer;\n    gss_buffer_t        output_message_buffer;\n    int                 *conf_state;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      input_message_buffer, output_message_buffer,\n                      conf_state, qop_state, KG_TOK_WRAP_MSG);\n    return(rstat);\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic(minor_status, context_handle,\n                    message_buffer, token_buffer,\n                    qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        message_buffer;\n    gss_buffer_t        token_buffer;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      token_buffer, message_buffer,\n                      NULL, qop_state, KG_TOK_MIC_MSG);\n    return(rstat);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/gssapi/krb5/k5unsealiov.c */\n/*\n * Copyright 2008, 2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include <assert.h>\n#include \"k5-platform.h\"        /* for 64-bit support */\n#include \"k5-int.h\"          /* for zap() */\n#include \"gssapiP_krb5.h\"\n#include <stdarg.h>\n\nstatic OM_uint32\nkg_unseal_v1_iov(krb5_context context,\n                 OM_uint32 *minor_status,\n                 krb5_gss_ctx_id_rec *ctx,\n                 gss_iov_buffer_desc *iov,\n                 int iov_count,\n                 size_t token_wrapper_len,\n                 int *conf_state,\n                 gss_qop_t *qop_state,\n                 int toktype)\n{\n    OM_uint32 code;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t trailer;\n    unsigned char *ptr;\n    int sealalg;\n    int signalg;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    size_t cksum_len = 0;\n    size_t conflen = 0;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    md5cksum.length = cksum.length = 0;\n    md5cksum.contents = cksum.contents = NULL;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    assert(header != NULL);\n\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n    if (trailer != NULL && trailer->buffer.length != 0) {\n        *minor_status = (OM_uint32)KRB5_BAD_MSIZE;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (ctx->seq == NULL) {\n        /* ctx was established using a newer enctype, and cannot process RFC\n         * 1964 tokens. */\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (header->buffer.length < token_wrapper_len + 22) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    ptr = (unsigned char *)header->buffer.value + token_wrapper_len;\n\n    signalg  = ptr[0];\n    signalg |= ptr[1] << 8;\n\n    sealalg  = ptr[2];\n    sealalg |= ptr[3] << 8;\n\n    if (ptr[4] != 0xFF || ptr[5] != 0xFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype == KG_TOK_WRAP_MSG &&\n        !(sealalg == 0xFFFF || sealalg == ctx->sealalg)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_WRAP_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n    code = kg_get_seq_num(context, ctx->seq, ptr + 14, ptr + 6, &direction,\n                          &seqnum);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_BAD_SIG;\n    }\n\n    /* decode the message, if SEAL */\n    if (toktype == KG_TOK_WRAP_MSG) {\n        if (sealalg != 0xFFFF) {\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                size_t i;\n\n                store_32_be(seqnum, bigend_seqnum);\n\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code != 0) {\n                    retval = GSS_S_FAILURE;\n                    goto cleanup;\n                }\n\n                assert(enc_key->length == 16);\n\n                for (i = 0; i < enc_key->length; i++)\n                    ((char *)enc_key->contents)[i] ^= 0xF0;\n\n                code = kg_arcfour_docrypt_iov(context, enc_key, 0,\n                                              &bigend_seqnum[0], 4,\n                                              iov, iov_count);\n                krb5_free_keyblock(context, enc_key);\n            } else {\n                code = kg_decrypt_iov(context, 0,\n                                      ((ctx->gss_flags & GSS_C_DCE_STYLE) != 0),\n                                      0 /*EC*/, 0 /*RRC*/,\n                                      ctx->enc, KG_USAGE_SEAL, NULL,\n                                      iov, iov_count);\n            }\n            if (code != 0) {\n                retval = GSS_S_FAILURE;\n                goto cleanup;\n            }\n        }\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n    }\n\n    if (header->buffer.length != token_wrapper_len + 14 + cksum_len + conflen) {\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the checksum */\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n    md5cksum.length = sumlen;\n\n    /* compute the checksum of the message */\n    code = kg_make_checksum_iov_v1(context, md5cksum.checksum_type,\n                                   cksum_len, ctx->seq, ctx->enc,\n                                   sign_usage, iov, iov_count, toktype,\n                                   &md5cksum);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code != 0) {\n            retval = GSS_S_FAILURE;\n            goto cleanup;\n        }\n\n        cksum.length = cksum_len;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    default:\n        code = 0;\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    if (code != 0) {\n        code = 0;\n        retval = GSS_S_BAD_SIG;\n        goto cleanup;\n    }\n\n    /*\n     * For GSS_C_DCE_STYLE, the caller manages the padding, because the\n     * pad length is in the RPC PDU. The value of the padding may be\n     * uninitialized. For normal GSS, the last bytes of the decrypted\n     * data contain the pad length. kg_fixup_padding_iov() will find\n     * this and fixup the last data IOV appropriately.\n     */\n    if (toktype == KG_TOK_WRAP_MSG &&\n        (ctx->gss_flags & GSS_C_DCE_STYLE) == 0) {\n        retval = kg_fixup_padding_iov(&code, iov, iov_count);\n        if (retval != GSS_S_COMPLETE)\n            goto cleanup;\n    }\n\n    if (conf_state != NULL)\n        *conf_state = (sealalg != 0xFFFF);\n\n    if (qop_state != NULL)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        retval = GSS_S_BAD_SIG;\n    }\n\n    code = 0;\n    retval = g_order_check(&ctx->seqstate, (gssint_uint64)seqnum);\n\ncleanup:\n    krb5_free_checksum_contents(context, &md5cksum);\n\n    *minor_status = code;\n\n    return retval;\n}\n\n/*\n * Caller must provide TOKEN | DATA | PADDING | TRAILER, except\n * for DCE in which case it can just provide TOKEN | DATA (must\n * guarantee that DATA is padded)\n */\nstatic OM_uint32\nkg_unseal_iov_token(OM_uint32 *minor_status,\n                    krb5_gss_ctx_id_rec *ctx,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count,\n                    int toktype)\n{\n    krb5_error_code code;\n    krb5_context context = ctx->k5_context;\n    unsigned char *ptr;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t padding;\n    gss_iov_buffer_t trailer;\n    size_t input_length;\n    unsigned int bodysize;\n    int toktype2;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    if (header == NULL) {\n        *minor_status = EINVAL;\n        return GSS_S_FAILURE;\n    }\n\n    padding = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_PADDING);\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n\n    ptr = (unsigned char *)header->buffer.value;\n    input_length = header->buffer.length;\n\n    if ((ctx->gss_flags & GSS_C_DCE_STYLE) == 0 &&\n        toktype == KG_TOK_WRAP_MSG) {\n        size_t data_length, assoc_data_length;\n\n        kg_iov_msglen(iov, iov_count, &data_length, &assoc_data_length);\n\n        input_length += data_length - assoc_data_length;\n\n        if (padding != NULL)\n            input_length += padding->buffer.length;\n\n        if (trailer != NULL)\n            input_length += trailer->buffer.length;\n    }\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 input_length, 0);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        code = gss_krb5int_unseal_v3_iov(context, minor_status, ctx, iov, iov_count,\n                                         conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        code = kg_unseal_v1_iov(context, minor_status, ctx, iov, iov_count,\n                                (size_t)(ptr - (unsigned char *)header->buffer.value),\n                                conf_state, qop_state, toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        code = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (code != 0)\n        save_error_info(*minor_status, context);\n\n    return code;\n}\n\n/*\n * Split a STREAM | SIGN_DATA | DATA into\n *         HEADER | SIGN_DATA | DATA | PADDING | TRAILER\n */\nstatic OM_uint32\nkg_unseal_stream_iov(OM_uint32 *minor_status,\n                     krb5_gss_ctx_id_rec *ctx,\n                     int *conf_state,\n                     gss_qop_t *qop_state,\n                     gss_iov_buffer_desc *iov,\n                     int iov_count,\n                     int toktype)\n{\n    unsigned char *ptr;\n    unsigned int bodysize;\n    OM_uint32 code = 0, major_status = GSS_S_FAILURE;\n    krb5_context context = ctx->k5_context;\n    int conf_req_flag, toktype2;\n    int i = 0, j;\n    gss_iov_buffer_desc *tiov = NULL;\n    gss_iov_buffer_t stream, data = NULL;\n    gss_iov_buffer_t theader, tdata = NULL, tpadding, ttrailer;\n\n    assert(toktype == KG_TOK_WRAP_MSG);\n\n    if (toktype != KG_TOK_WRAP_MSG || (ctx->gss_flags & GSS_C_DCE_STYLE)) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    stream = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM);\n    assert(stream != NULL);\n\n    ptr = (unsigned char *)stream->buffer.value;\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 stream->buffer.length, 0);\n    if (code != 0) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    tiov = (gss_iov_buffer_desc *)calloc((size_t)iov_count + 2, sizeof(gss_iov_buffer_desc));\n    if (tiov == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n\n    /* HEADER */\n    theader = &tiov[i++];\n    theader->type = GSS_IOV_BUFFER_TYPE_HEADER;\n    theader->buffer.value = stream->buffer.value;\n    theader->buffer.length = ptr - (unsigned char *)stream->buffer.value;\n    if (bodysize < 14 ||\n        stream->buffer.length != theader->buffer.length + bodysize) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n    theader->buffer.length += 14;\n\n    /* n[SIGN_DATA] | DATA | m[SIGN_DATA] */\n    for (j = 0; j < iov_count; j++) {\n        OM_uint32 type = GSS_IOV_BUFFER_TYPE(iov[j].type);\n\n        if (type == GSS_IOV_BUFFER_TYPE_DATA) {\n            if (data != NULL) {\n                /* only a single DATA buffer can appear */\n                code = EINVAL;\n                goto cleanup;\n            }\n\n            data = &iov[j];\n            tdata = &tiov[i];\n        }\n        if (type == GSS_IOV_BUFFER_TYPE_DATA ||\n            type == GSS_IOV_BUFFER_TYPE_SIGN_ONLY)\n            tiov[i++] = iov[j];\n    }\n\n    if (data == NULL) {\n        /* a single DATA buffer must be present */\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    /* PADDING | TRAILER */\n    tpadding = &tiov[i++];\n    tpadding->type = GSS_IOV_BUFFER_TYPE_PADDING;\n    tpadding->buffer.length = 0;\n    tpadding->buffer.value = NULL;\n\n    ttrailer = &tiov[i++];\n    ttrailer->type = GSS_IOV_BUFFER_TYPE_TRAILER;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX: {\n        size_t ec, rrc;\n        krb5_enctype enctype;\n        unsigned int k5_headerlen = 0;\n        unsigned int k5_trailerlen = 0;\n\n        if (ctx->have_acceptor_subkey)\n            enctype = ctx->acceptor_subkey->keyblock.enctype;\n        else\n            enctype = ctx->subkey->keyblock.enctype;\n        conf_req_flag = ((ptr[0] & FLAG_WRAP_CONFIDENTIAL) != 0);\n        ec = conf_req_flag ? load_16_be(ptr + 2) : 0;\n        rrc = load_16_be(ptr + 4);\n\n        if (rrc != 0) {\n            if (!gss_krb5int_rotate_left((unsigned char *)stream->buffer.value + 16,\n                                         stream->buffer.length - 16, rrc)) {\n                code = ENOMEM;\n                goto cleanup;\n            }\n            store_16_be(0, ptr + 4); /* set RRC to zero */\n        }\n\n        if (conf_req_flag) {\n            code = krb5_c_crypto_length(context, enctype, KRB5_CRYPTO_TYPE_HEADER, &k5_headerlen);\n            if (code != 0)\n                goto cleanup;\n            theader->buffer.length += k5_headerlen; /* length validated later */\n        }\n\n        /* no PADDING for CFX, EC is used instead */\n        code = krb5_c_crypto_length(context, enctype,\n                                    conf_req_flag ? KRB5_CRYPTO_TYPE_TRAILER : KRB5_CRYPTO_TYPE_CHECKSUM,\n                                    &k5_trailerlen);\n        if (code != 0)\n            goto cleanup;\n\n        ttrailer->buffer.length = ec + (conf_req_flag ? 16 : 0 /* E(Header) */) + k5_trailerlen;\n        ttrailer->buffer.value = (unsigned char *)stream->buffer.value +\n            stream->buffer.length - ttrailer->buffer.length;\n        break;\n    }\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        theader->buffer.length += ctx->cksum_size +\n            kg_confounder_size(context, ctx->enc->keyblock.enctype);\n\n        /*\n         * we can't set the padding accurately until decryption;\n         * kg_fixup_padding_iov() will take care of this\n         */\n        tpadding->buffer.length = 1;\n        tpadding->buffer.value = (unsigned char *)stream->buffer.value + stream->buffer.length - 1;\n\n        /* no TRAILER for pre-CFX */\n        ttrailer->buffer.length = 0;\n        ttrailer->buffer.value = NULL;\n\n        break;\n    default:\n        code = (OM_uint32)G_BAD_TOK_HEADER;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    /* IOV: -----------0-------------+---1---+--2--+----------------3--------------*/\n    /* Old: GSS-Header | Conf        | Data  | Pad |                               */\n    /* CFX: GSS-Header | Kerb-Header | Data  |     | EC | E(Header) | Kerb-Trailer */\n    /* GSS: -------GSS-HEADER--------+-DATA--+-PAD-+----------GSS-TRAILER----------*/\n\n    /* validate lengths */\n    if (stream->buffer.length < theader->buffer.length +\n        tpadding->buffer.length +\n        ttrailer->buffer.length)\n    {\n        code = (OM_uint32)KRB5_BAD_MSIZE;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* setup data */\n    tdata->buffer.length = stream->buffer.length - ttrailer->buffer.length -\n        tpadding->buffer.length - theader->buffer.length;\n\n    assert(data != NULL);\n\n    if (data->type & GSS_IOV_BUFFER_FLAG_ALLOCATE) {\n        code = kg_allocate_iov(tdata, tdata->buffer.length);\n        if (code != 0)\n            goto cleanup;\n        memcpy(tdata->buffer.value,\n               (unsigned char *)stream->buffer.value + theader->buffer.length, tdata->buffer.length);\n    } else\n        tdata->buffer.value = (unsigned char *)stream->buffer.value + theader->buffer.length;\n\n    assert(i <= iov_count + 2);\n\n    major_status = kg_unseal_iov_token(&code, ctx, conf_state, qop_state,\n                                       tiov, i, toktype);\n    if (major_status == GSS_S_COMPLETE)\n        *data = *tdata;\n    else\n        kg_release_iov(tdata, 1);\n\ncleanup:\n    if (tiov != NULL)\n        free(tiov);\n\n    *minor_status = code;\n\n    return major_status;\n}\n\nOM_uint32\nkg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap_iov(OM_uint32 *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 conf_state, qop_state,\n                                 iov, iov_count, KG_TOK_WRAP_MSG);\n\n    return major_status;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic_iov(OM_uint32 *minor_status,\n                        gss_ctx_id_t context_handle,\n                        gss_qop_t *qop_state,\n                        gss_iov_buffer_desc *iov,\n                        int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 NULL, qop_state,\n                                 iov, iov_count, KG_TOK_MIC_MSG);\n\n    return major_status;\n}\n"], "buggy_code_start_loc": [76, 72], "buggy_code_end_loc": [407, 73], "fixing_code_start_loc": [77, 72], "fixing_code_end_loc": [432, 80], "type": "CWE-119", "message": "MIT Kerberos 5 (aka krb5) 1.7.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (buffer over-read or NULL pointer dereference, and application crash) by injecting invalid tokens into a GSSAPI application session.", "other": {"cve": {"id": "CVE-2014-4342", "sourceIdentifier": "cve@mitre.org", "published": "2014-07-20T11:12:50.870", "lastModified": "2020-01-21T15:46:47.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MIT Kerberos 5 (aka krb5) 1.7.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (buffer over-read or NULL pointer dereference, and application crash) by injecting invalid tokens into a GSSAPI application session."}, {"lang": "es", "value": "MIT Kerberos 5 (tambi\u00e9n conocido como krb5) 1.7.x hasta 1.12.x anterior a 1.12.2 permite a atacantes remotos causar una denegaci\u00f3n de servicio (sobrelectura de buffer o referencia a puntero nulo y ca\u00edda de aplicaci\u00f3n) mediante la inyecci\u00f3n de tokens inv\u00e1lidos en una sesi\u00f3n de la aplicaci\u00f3n GSSAPI."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos:5-1.8:alpha1:*:*:*:*:*:*", "matchCriteriaId": "932A9238-B5F1-440B-92B8-1CD17A2CC274"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos:5-1.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "42238DD3-2CFB-4F88-9CB6-A2B6F71DBB9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos:5-1.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8D48B3D-DE6C-47DA-8002-659AED084A04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos:5-1.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "DB845405-97B7-4609-A61E-68C5CCD374EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.7:*:*:*:*:*:*:*", "matchCriteriaId": "DFB1190E-BE7A-4C6B-862D-D5747C64E980"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "4B09C090-B842-43C7-B8A6-DBF63D80FEC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8:*:*:*:*:*:*:*", "matchCriteriaId": "36823B2B-5C72-4FF3-9301-FB263EB8CE09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "59AFA33E-FEBC-45F5-9EC6-8AA363163FB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "04D83332-B2FD-4E86-A76C-C3F1CD3B3A31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "758A0011-20ED-414A-9DF3-50A161DF8BC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "7768AED0-AE4C-4D4E-8D5D-5B618AB82966"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "534104C5-966E-4740-A354-4F6C210FF25B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "78AF5659-C0E3-49C4-9CA7-FC3917C8AC49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "86738633-C081-4440-9F75-A775D6DF2228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "C7BCFFEE-EA7A-4F26-97AA-31128A179745"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "91A2D7F5-EBDE-4000-AC78-8DD6472E685A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8E92BFA5-723E-4843-A8D8-BC1D32F34569"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "34C27198-9B55-42FB-AA21-D8B4EB60D926"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10:*:*:*:*:*:*:*", "matchCriteriaId": "FC504264-A9E9-4433-B7AA-6D5015A93FF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "77FA352F-520C-4C05-AD52-FC8586DB16B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "9FFB18F7-CB08-4AE4-9DEC-55D047819A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "637E858A-7C16-490C-99A8-F46440E5F504"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "22840B84-2EA4-4E96-A8D8-154AAEADB806"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11:*:*:*:*:*:*:*", "matchCriteriaId": "2D554BDC-CD7D-4572-B1E8-5F627F2C5916"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "65BCD38A-33AD-4FD7-AF5B-8470B24C4139"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "E11F9209-799A-428B-9513-DBD0F19C7BF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "1DA40FAA-B858-4282-8438-247E99FBB002"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "65795542-D886-46C4-8ECB-4630078DF66A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12:*:*:*:*:*:*:*", "matchCriteriaId": "79A9FAE9-7219-4D6A-9E94-FFE20223537D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA68BC90-FCFC-4C9B-8574-9029DB2358E9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2014-0345.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7949", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0439.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3000", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2014:165", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/68908", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1030706", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/94903", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73", "source": "cve@mitre.org", "tags": ["Patch", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73"}}