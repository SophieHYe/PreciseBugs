{"buggy_code": ["/*\n Legal Notice: Some portions of the source code contained in this file were\n derived from the source code of TrueCrypt 7.1a, which is\n Copyright (c) 2003-2012 TrueCrypt Developers Association and which is\n governed by the TrueCrypt License 3.0, also from the source code of\n Encryption for the Masses 2.02a, which is Copyright (c) 1998-2000 Paul Le Roux\n and which is governed by the 'License Agreement for Encryption for the Masses'\n Modifications and additions to the original source code (contained in this file)\n and all other portions of this file are Copyright (c) 2013-2017 IDRIX\n and are governed by the Apache License 2.0 the full text of which is\n contained in the file License.txt included in VeraCrypt binary and source\n code distribution packages. */\n\n#include \"TCdefs.h\"\n#include <ntddk.h>\n#include \"Crypto.h\"\n#include \"Fat.h\"\n#include \"Tests.h\"\n#include \"cpu.h\"\n#include \"Crc.h\"\n\n#include \"Apidrvr.h\"\n#include \"Boot/Windows/BootDefs.h\"\n#include \"EncryptedIoQueue.h\"\n#include \"EncryptionThreadPool.h\"\n#include \"Ntdriver.h\"\n#include \"Ntvol.h\"\n#include \"DriveFilter.h\"\n#include \"DumpFilter.h\"\n#include \"Cache.h\"\n#include \"Volumes.h\"\n#include \"VolumeFilter.h\"\n\n#include <tchar.h>\n#include <initguid.h>\n#include <mountmgr.h>\n#include <mountdev.h>\n#include <ntddvol.h>\n\n#include <Ntstrsafe.h>\n#include <Intsafe.h>\n\n#ifndef IOCTL_DISK_GET_CLUSTER_INFO\n#define IOCTL_DISK_GET_CLUSTER_INFO\t\t\t\tCTL_CODE(IOCTL_DISK_BASE, 0x0085, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#endif\n\n#ifndef IOCTL_DISK_ARE_VOLUMES_READY\n#define IOCTL_DISK_ARE_VOLUMES_READY\t\t\tCTL_CODE(IOCTL_DISK_BASE, 0x0087, METHOD_BUFFERED, FILE_READ_ACCESS)\n#endif\n\n#ifndef FT_BALANCED_READ_MODE\n#define FTTYPE  ((ULONG)'f') \n#define FT_BALANCED_READ_MODE\t\t\t\t\t\tCTL_CODE(FTTYPE, 6, METHOD_NEITHER,  FILE_ANY_ACCESS) \n#endif\n\n#ifndef IOCTL_VOLUME_QUERY_ALLOCATION_HINT\n#define IOCTL_VOLUME_QUERY_ALLOCATION_HINT      CTL_CODE(IOCTL_VOLUME_BASE, 20, METHOD_OUT_DIRECT, FILE_READ_ACCESS)\n#endif\n\n#ifndef IOCTL_DISK_IS_CLUSTERED\n#define IOCTL_DISK_IS_CLUSTERED             CTL_CODE(IOCTL_DISK_BASE, 0x003e, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#endif\n\n#ifndef IOCTL_VOLUME_POST_ONLINE\n#define IOCTL_VOLUME_POST_ONLINE                CTL_CODE(IOCTL_VOLUME_BASE, 25, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)\n#endif\n\n#ifndef IOCTL_VOLUME_IS_DYNAMIC\n#define IOCTL_VOLUME_IS_DYNAMIC                 CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#endif\n\n#ifndef StorageDeviceLBProvisioningProperty\n#define StorageDeviceLBProvisioningProperty 11\n#endif\n\n#ifndef DeviceDsmAction_OffloadRead\n#define DeviceDsmAction_OffloadRead       ( 3  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_OffloadWrite\n#define DeviceDsmAction_OffloadWrite        4\n#endif\n\n#ifndef DeviceDsmAction_Allocation\n#define DeviceDsmAction_Allocation        ( 5  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_Repair\n#define DeviceDsmAction_Repair            ( 6  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_Scrub\n#define DeviceDsmAction_Scrub             ( 7  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_DrtQuery\n#define DeviceDsmAction_DrtQuery          ( 8  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_DrtClear\n#define DeviceDsmAction_DrtClear          ( 9  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_DrtDisable\n#define DeviceDsmAction_DrtDisable        (10  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n/* Init section, which is thrown away as soon as DriverEntry returns */\n#pragma alloc_text(INIT,DriverEntry)\n#pragma alloc_text(INIT,TCCreateRootDeviceObject)\n\n/* We need to silence 'type cast' warning in order to use MmGetSystemRoutineAddress.\n * MmGetSystemRoutineAddress() should have been declare FARPROC instead of PVOID.\n */\n#pragma warning(disable:4055)\n\nPDRIVER_OBJECT TCDriverObject;\nPDEVICE_OBJECT RootDeviceObject = NULL;\nstatic KMUTEX RootDeviceControlMutex;\nBOOL DriverShuttingDown = FALSE;\nBOOL SelfTestsPassed;\nint LastUniqueVolumeId;\nULONG OsMajorVersion = 0;\nULONG OsMinorVersion;\nBOOL DriverUnloadDisabled = FALSE;\nBOOL PortableMode = FALSE;\nBOOL VolumeClassFilterRegistered = FALSE;\nBOOL CacheBootPassword = FALSE;\nBOOL CacheBootPim = FALSE;\nBOOL NonAdminSystemFavoritesAccessDisabled = FALSE;\nBOOL BlockSystemTrimCommand = FALSE;\nBOOL AllowWindowsDefrag = FALSE;\nstatic size_t EncryptionThreadPoolFreeCpuCountLimit = 0;\nstatic BOOL SystemFavoriteVolumeDirty = FALSE;\nstatic BOOL PagingFileCreationPrevented = FALSE;\nstatic BOOL EnableExtendedIoctlSupport = FALSE;\nstatic BOOL AllowTrimCommand = FALSE;\nstatic KeSaveExtendedProcessorStateFn KeSaveExtendedProcessorStatePtr = NULL;\nstatic KeRestoreExtendedProcessorStateFn KeRestoreExtendedProcessorStatePtr = NULL;\n\nPOOL_TYPE ExDefaultNonPagedPoolType = NonPagedPool;\nULONG ExDefaultMdlProtection = 0;\n\nPDEVICE_OBJECT VirtualVolumeDeviceObjects[MAX_MOUNTED_VOLUME_DRIVE_NUMBER + 1];\n\n\nNTSTATUS DriverEntry (PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)\n{\n\tPKEY_VALUE_PARTIAL_INFORMATION startKeyValue;\n\tLONG version;\n\tint i;\n\n\tDump (\"DriverEntry \" TC_APP_NAME \" \" VERSION_STRING \"\\n\");\n\n\tDetectX86Features ();\n\n\tPsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);\n\n\tDump (\"OsMajorVersion=%d OsMinorVersion=%d\\n\", OsMajorVersion, OsMinorVersion);\n\n\t// NX pool support is available starting from Windows 8\n\tif ((OsMajorVersion > 6) || (OsMajorVersion == 6 && OsMinorVersion >= 2))\n\t{\n\t\tExDefaultNonPagedPoolType = (POOL_TYPE) NonPagedPoolNx;\n\t\tExDefaultMdlProtection = MdlMappingNoExecute;\n\t}\n\n\t// KeSaveExtendedProcessorState/KeRestoreExtendedProcessorState are available starting from Windows 7\n\tif ((OsMajorVersion > 6) || (OsMajorVersion == 6 && OsMinorVersion >= 1))\n\t{\n\t\tUNICODE_STRING saveFuncName, restoreFuncName;\n\t\tRtlInitUnicodeString(&saveFuncName, L\"KeSaveExtendedProcessorState\");\n\t\tRtlInitUnicodeString(&restoreFuncName, L\"KeRestoreExtendedProcessorState\");\n\t\tKeSaveExtendedProcessorStatePtr = (KeSaveExtendedProcessorStateFn) MmGetSystemRoutineAddress(&saveFuncName);\n\t\tKeRestoreExtendedProcessorStatePtr = (KeRestoreExtendedProcessorStateFn) MmGetSystemRoutineAddress(&restoreFuncName);\n\t}\n\n\t// Load dump filter if the main driver is already loaded\n\tif (NT_SUCCESS (TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))\n\t\treturn DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);\n\n\tTCDriverObject = DriverObject;\n\tmemset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));\n\n\tReadRegistryConfigFlags (TRUE);\n\tEncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);\n\tSelfTestsPassed = AutoTestAlgorithms();\n\n\t// Enable device class filters and load boot arguments if the driver is set to start at system boot\n\n\tif (NT_SUCCESS (TCReadRegistryKey (RegistryPath, L\"Start\", &startKeyValue)))\n\t{\n\t\tif (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)\n\t\t{\n\t\t\tif (!SelfTestsPassed)\n\t\t\t{\n\t\t\t\t// in case of system encryption, if self-tests fail, disable all extended CPU\n\t\t\t\t// features and try again in order to workaround faulty configurations\n\t\t\t\tDisableCPUExtendedFeatures ();\n\t\t\t\tSelfTestsPassed = AutoTestAlgorithms();\n\n\t\t\t\t// BUG CHECK if the self-tests still fail\n\t\t\t\tif (!SelfTestsPassed)\n\t\t\t\t\tTC_BUG_CHECK (STATUS_INVALID_PARAMETER);\n\t\t\t}\n\n\t\t\tLoadBootArguments();\n\t\t\tVolumeClassFilterRegistered = IsVolumeClassFilterRegistered();\n\n\t\t\tDriverObject->DriverExtension->AddDevice = DriverAddDevice;\n\t\t}\n\n\t\tTCfree (startKeyValue);\n\t}\n\n\tfor (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)\n\t{\n\t\tDriverObject->MajorFunction[i] = TCDispatchQueueIRP;\n\t}\n\n\tDriverObject->DriverUnload = TCUnloadDriver;\n\treturn TCCreateRootDeviceObject (DriverObject);\n}\n\n\nNTSTATUS DriverAddDevice (PDRIVER_OBJECT driverObject, PDEVICE_OBJECT pdo)\n{\n#if defined(DEBUG) || defined (DEBUG_TRACE)\n\tchar nameInfoBuffer[128];\n\tPOBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;\n\tULONG nameInfoSize;\n\tDump (\"AddDevice pdo=%p type=%x name=%ws\\n\", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L\"?\");\n#endif\n\n\tif (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)\n\t{\n\t\tPWSTR interfaceLinks = NULL;\n\t\tif (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)) && interfaceLinks)\n\t\t{\n\t\t\tif (interfaceLinks[0] != UNICODE_NULL)\n\t\t\t{\n\t\t\t\tDump (\"Volume pdo=%p interface=%ws\\n\", pdo, interfaceLinks);\n\t\t\t\tExFreePool (interfaceLinks);\n\n\t\t\t\treturn VolumeFilterAddDevice (driverObject, pdo);\n\t\t\t}\n\n\t\t\tExFreePool (interfaceLinks);\n\t\t}\n\t}\n\n\treturn DriveFilterAddDevice (driverObject, pdo);\n}\n\n\n// Dumps a memory region to debug output\nvoid DumpMemory (void *mem, int size)\n{\n\tunsigned char str[20];\n\tunsigned char *m = mem;\n\tint i,j;\n\n\tfor (j = 0; j < size / 8; j++)\n\t{\n\t\tmemset (str,0,sizeof str);\n\t\tfor (i = 0; i < 8; i++)\n\t\t{\n\t\t\tif (m[i] > ' ' && m[i] <= '~')\n\t\t\t\tstr[i]=m[i];\n\t\t\telse\n\t\t\t\tstr[i]='.';\n\t\t}\n\n\t\tDump (\"0x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s\\n\",\n\t\t\tm, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], str);\n\n\t\tm+=8;\n\t}\n}\n\nBOOL IsAllZeroes (unsigned char* pbData, DWORD dwDataLen)\n{\n\twhile (dwDataLen--)\n\t{\n\t\tif (*pbData)\n\t\t\treturn FALSE;\n\t\tpbData++;\n\t}\n\treturn TRUE;\n}\n\nBOOL ValidateIOBufferSize (PIRP irp, size_t requiredBufferSize, ValidateIOBufferSizeType type)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);\n\tBOOL input = (type == ValidateInput || type == ValidateInputOutput);\n\tBOOL output = (type == ValidateOutput || type == ValidateInputOutput);\n\n\tif ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)\n\t\t|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))\n\t{\n\t\tDump (\"STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\\n\", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\n\t\tirp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;\n\t\tirp->IoStatus.Information = 0;\n\t\treturn FALSE;\n\t}\n\n\tif (!input && output)\n\t\tmemset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\n\treturn TRUE;\n}\n\n\nPDEVICE_OBJECT GetVirtualVolumeDeviceObject (int driveNumber)\n{\n\tif (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)\n\t\treturn NULL;\n\n\treturn VirtualVolumeDeviceObjects[driveNumber];\n}\n\n\n/* TCDispatchQueueIRP queues any IRP's so that they can be processed later\n   by the thread -- or in some cases handles them immediately! */\nNTSTATUS TCDispatchQueueIRP (PDEVICE_OBJECT DeviceObject, PIRP Irp)\n{\n\tPEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\tNTSTATUS ntStatus;\n\n#if defined(_DEBUG) || defined (_DEBUG_TRACE)\n\tif (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))\n\t{\n\t\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\t\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_OPEN_TEST:\n\t\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tcase TC_IOCTL_GET_DEVICE_REFCOUNT:\n\t\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:\n\t\tcase TC_IOCTL_GET_WARNING_FLAGS:\n\t\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\tcase IOCTL_DISK_CHECK_VERIFY:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDump (\"%ls (0x%x %d)\\n\",\n\t\t\t\tTCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),\n\t\t\t\t(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),\n\t\t\t\t(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));\n\t\t}\n\t}\n#endif\n\n\tif (!Extension->bRootDevice)\n\t{\n\t\t// Drive filter IRP\n\t\tif (Extension->IsDriveFilterDevice)\n\t\t\treturn DriveFilterDispatchIrp (DeviceObject, Irp);\n\n\t\t// Volume filter IRP\n\t\tif (Extension->IsVolumeFilterDevice)\n\t\t\treturn VolumeFilterDispatchIrp (DeviceObject, Irp);\n\t}\n\n\tswitch (irpSp->MajorFunction)\n\t{\n\tcase IRP_MJ_CLOSE:\n\tcase IRP_MJ_CREATE:\n\tcase IRP_MJ_CLEANUP:\n\t\treturn COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);\n\n\tcase IRP_MJ_SHUTDOWN:\n\t\tif (Extension->bRootDevice)\n\t\t{\n\t\t\tDump (\"Driver shutting down\\n\");\n\t\t\tDriverShuttingDown = TRUE;\n\n\t\t\tif (EncryptionSetupThread)\n\t\t\t\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);\n\n\t\t\tif (DecoySystemWipeThread)\n\t\t\t\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);\n\n\t\t\tOnShutdownPending();\n\t\t}\n\n\t\treturn COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);\n\n\tcase IRP_MJ_FLUSH_BUFFERS:\n\tcase IRP_MJ_READ:\n\tcase IRP_MJ_WRITE:\n\tcase IRP_MJ_DEVICE_CONTROL:\n\n\t\tif (Extension->bRootDevice)\n\t\t{\n\t\t\tif (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)\n\t\t\t{\n\t\t\t\tNTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);\n\t\t\t\tif (!NT_SUCCESS (status))\n\t\t\t\t\treturn status;\n\n\t\t\t\tstatus = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);\n\n\t\t\t\tKeReleaseMutex (&RootDeviceControlMutex, FALSE);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (Extension->bShuttingDown)\n\t\t{\n\t\t\tDump (\"Device %d shutting down: STATUS_DELETE_PENDING\\n\", Extension->nDosDriveNo);\n\t\t\treturn TCCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);\n\t\t}\n\n\t\tif (Extension->bRemovable\n\t\t\t&& (DeviceObject->Flags & DO_VERIFY_VOLUME)\n\t\t\t&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)\n\t\t\t&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)\n\t\t{\n\t\t\tDump (\"Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\\n\", Extension->nDosDriveNo);\n\t\t\treturn TCCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);\n\t\t}\n\n\t\tswitch (irpSp->MajorFunction)\n\t\t{\n\t\tcase IRP_MJ_READ:\n\t\tcase IRP_MJ_WRITE:\n\t\t\tntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);\n\n\t\t\tif (ntStatus != STATUS_PENDING)\n\t\t\t\tTCCompleteDiskIrp (Irp, ntStatus, 0);\n\n\t\t\treturn ntStatus;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\tntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);\n\t\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\t\treturn TCCompleteIrp (Irp, ntStatus, 0);\n\n\t\t\tIoMarkIrpPending (Irp);\n\n\t\t\tExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);\n\t\t\tKeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);\n\n\t\t\treturn STATUS_PENDING;\n\n\t\tcase IRP_MJ_FLUSH_BUFFERS:\n\t\t\treturn TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);\n\t\t}\n\n\t\tbreak;\n\n\tcase IRP_MJ_PNP:\n\t\tif (!Extension->bRootDevice\n\t\t\t&& Extension->IsVolumeDevice\n\t\t\t&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION\n\t\t\t&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging\n\t\t\t&& irpSp->Parameters.UsageNotification.InPath)\n\t\t{\n\t\t\tPagingFileCreationPrevented = TRUE;\n\t\t\treturn TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n}\n\nNTSTATUS TCCreateRootDeviceObject (PDRIVER_OBJECT DriverObject)\n{\n\tUNICODE_STRING Win32NameString, ntUnicodeString;\n\tWCHAR dosname[32], ntname[32];\n\tPDEVICE_OBJECT DeviceObject;\n\tNTSTATUS ntStatus;\n\tBOOL *bRootExtension;\n\n\tDump (\"TCCreateRootDeviceObject BEGIN\\n\");\n\tASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);\n\n\tRtlStringCbCopyW (dosname, sizeof(dosname),(LPWSTR) DOS_ROOT_PREFIX);\n\tRtlStringCbCopyW (ntname, sizeof(ntname),(LPWSTR) NT_ROOT_PREFIX);\n\tRtlInitUnicodeString (&ntUnicodeString, ntname);\n\tRtlInitUnicodeString (&Win32NameString, dosname);\n\n\tDump (\"Creating root device nt=%ls dos=%ls\\n\", ntname, dosname);\n\n\tntStatus = IoCreateDevice (\n\t\t\t\t\t  DriverObject,\n\t\t\t\t\t  sizeof (BOOL),\n\t\t\t\t\t  &ntUnicodeString,\n\t\t\t\t\t  FILE_DEVICE_UNKNOWN,\n\t\t\t\t\t  FILE_DEVICE_SECURE_OPEN,\n\t\t\t\t\t  FALSE,\n\t\t\t\t\t  &DeviceObject);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"TCCreateRootDeviceObject NTSTATUS = 0x%08x END\\n\", ntStatus);\n\t\treturn ntStatus;/* Failed to create DeviceObject */\n\t}\n\n\tDeviceObject->Flags |= DO_DIRECT_IO;\n\tDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;\n\n\t/* Setup the device extension */\n\tbRootExtension = (BOOL *) DeviceObject->DeviceExtension;\n\t*bRootExtension = TRUE;\n\n\tKeInitializeMutex (&RootDeviceControlMutex, 0);\n\n\tntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"TCCreateRootDeviceObject NTSTATUS = 0x%08x END\\n\", ntStatus);\n\t\tIoDeleteDevice (DeviceObject);\n\t\treturn ntStatus;\n\t}\n\n\tIoRegisterShutdownNotification (DeviceObject);\n\tRootDeviceObject = DeviceObject;\n\n\tDump (\"TCCreateRootDeviceObject STATUS_SUCCESS END\\n\");\n\treturn STATUS_SUCCESS;\n}\n\nNTSTATUS TCCreateDeviceObject (PDRIVER_OBJECT DriverObject,\n\t\t       PDEVICE_OBJECT * ppDeviceObject,\n\t\t       MOUNT_STRUCT * mount)\n{\n\tUNICODE_STRING ntUnicodeString;\n\tWCHAR ntname[32];\n\tPEXTENSION Extension;\n\tNTSTATUS ntStatus;\n\tULONG devChars = 0;\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\tWCHAR dosname[32];\n#endif\n\n\tDump (\"TCCreateDeviceObject BEGIN\\n\");\n\tASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);\n\n\tTCGetNTNameFromNumber (ntname, sizeof(ntname),mount->nDosDriveNo);\n\tRtlInitUnicodeString (&ntUnicodeString, ntname);\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\tTCGetDosNameFromNumber (dosname, sizeof(dosname),mount->nDosDriveNo, DeviceNamespaceDefault);\n#endif\n\n\tdevChars = FILE_DEVICE_SECURE_OPEN;\n\tdevChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;\n\tdevChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;\n\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\tDump (\"Creating device nt=%ls dos=%ls\\n\", ntname, dosname);\n#endif\n\n\tntStatus = IoCreateDevice (\n\t\t\t\t\t  DriverObject,\t\t\t/* Our Driver Object */\n\t\t\t\t\t  sizeof (EXTENSION),\t/* Size of state information */\n\t\t\t\t\t  &ntUnicodeString,\t\t/* Device name \"\\Device\\Name\" */\n\t\t\t\t\t  FILE_DEVICE_DISK,\t\t/* Device type */\n\t\t\t\t\t  devChars,\t\t\t\t/* Device characteristics */\n\t\t\t\t\t  FALSE,\t\t\t\t/* Exclusive device */\n\t\t\t\t\t  ppDeviceObject);\t\t/* Returned ptr to Device Object */\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"TCCreateDeviceObject NTSTATUS = 0x%08x END\\n\", ntStatus);\n\t\treturn ntStatus;/* Failed to create DeviceObject */\n\t}\n\t/* Initialize device object and extension. */\n\n\t(*ppDeviceObject)->Flags |= DO_DIRECT_IO;\n\t(*ppDeviceObject)->StackSize += 6;\t\t// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers\n\n\t/* Setup the device extension */\n\tExtension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;\n\tmemset (Extension, 0, sizeof (EXTENSION));\n\n\tExtension->IsVolumeDevice = TRUE;\n\tExtension->nDosDriveNo = mount->nDosDriveNo;\n\tExtension->bRemovable = mount->bMountRemovable;\n\tExtension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;\n\tExtension->SystemFavorite = mount->SystemFavorite;\n\n\tKeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);\n\tKeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);\n\tKeInitializeSpinLock (&Extension->ListSpinLock);\n\tInitializeListHead (&Extension->ListEntry);\n\tIoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCV', 0, 0);\n\n\tVirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;\n\n\tDump (\"TCCreateDeviceObject STATUS_SUCCESS END\\n\");\n\n\treturn STATUS_SUCCESS;\n}\n\n\nBOOL RootDeviceControlMutexAcquireNoWait ()\n{\n\tNTSTATUS status;\n\tLARGE_INTEGER timeout;\n\ttimeout.QuadPart = 0;\n\n\tstatus = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);\n\treturn NT_SUCCESS (status) && status != STATUS_TIMEOUT;\n}\n\n\nvoid RootDeviceControlMutexRelease ()\n{\n\tKeReleaseMutex (&RootDeviceControlMutex, FALSE);\n}\n\n/*\nIOCTL_STORAGE_GET_DEVICE_NUMBER 0x002D1080 \nIOCTL_STORAGE_GET_HOTPLUG_INFO 0x002D0C14\nIOCTL_STORAGE_QUERY_PROPERTY 0x002D1400\n*/\n\nNTSTATUS ProcessVolumeDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, PIRP Irp)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\n\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t{\n\n\tcase IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_MOUNTDEV_QUERY_DEVICE_NAME)\\n\");\n\t\tif (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))\n\t\t{\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_NAME);\n\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tULONG outLength;\n\t\t\tUNICODE_STRING ntUnicodeString;\n\t\t\tWCHAR ntName[256];\n\t\t\tPMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tTCGetNTNameFromNumber (ntName, sizeof(ntName),Extension->nDosDriveNo);\n\t\t\tRtlInitUnicodeString (&ntUnicodeString, ntName);\n\n\t\t\toutputBuffer->NameLength = ntUnicodeString.Length;\n\t\t\toutLength = ntUnicodeString.Length + sizeof(USHORT);\n\n\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_NAME);\n\t\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = outLength;\n\n\t\t\tDump (\"name = %ls\\n\",ntName);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_MOUNTDEV_QUERY_UNIQUE_ID)\\n\");\n\t\tif (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))\n\t\t{\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);\n\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tULONG outLength;\n\t\t\tUCHAR volId[128], tmp[] = { 0,0 };\n\t\t\tPMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tRtlStringCbCopyA (volId, sizeof(volId),TC_UNIQUE_ID_PREFIX);\n\t\t\ttmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;\n\t\t\tRtlStringCbCatA (volId, sizeof(volId),tmp);\n\n\t\t\toutputBuffer->UniqueIdLength = (USHORT) strlen (volId);\n\t\t\toutLength = (ULONG) (strlen (volId) + sizeof (USHORT));\n\n\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);\n\t\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = outLength;\n\n\t\t\tDump (\"id = %s\\n\",volId);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME)\\n\");\n\t\t{\n\t\t\tULONG outLength;\n\t\t\tUNICODE_STRING ntUnicodeString;\n\t\t\tWCHAR ntName[256];\n\t\t\tPMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tTCGetDosNameFromNumber (ntName, sizeof(ntName),Extension->nDosDriveNo, DeviceNamespaceDefault);\n\t\t\tRtlInitUnicodeString (&ntUnicodeString, ntName);\n\n\t\t\toutLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;\n\n\t\t\toutputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;\n\t\t\toutputBuffer->NameLength = ntUnicodeString.Length;\n\n\t\t\tif(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);\n\t\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = outLength;\n\n\t\t\tDump (\"link = %ls\\n\",ntName);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_MEDIA_TYPES:\n\tcase IOCTL_DISK_GET_DRIVE_GEOMETRY:\n\tcase IOCTL_STORAGE_GET_MEDIA_TYPES:\n\tcase IOCTL_DISK_UPDATE_DRIVE_SIZE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_GEOMETRY)\\n\");\n\t\t/* Return the drive geometry for the disk.  Note that we\n\t\t   return values which were made up to suit the disk size.  */\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))\n\t\t{\n\t\t\tPDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;\n\t\t\toutputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\toutputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\toutputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\toutputBuffer->BytesPerSector = Extension->BytesPerSector;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_GEOMETRY_EX)\\n\");\n\t\t{\n\t\t\tULONG minOutputSize = IsOSAtLeast (WIN_SERVER_2003)? sizeof (DISK_GEOMETRY_EX) : sizeof (DISK_GEOMETRY) + sizeof (LARGE_INTEGER);\n\t\t\tULONG fullOutputSize = sizeof (DISK_GEOMETRY) + sizeof (LARGE_INTEGER) + sizeof (DISK_PARTITION_INFO) + sizeof (DISK_DETECTION_INFO);\n\n\t\t\tif (ValidateIOBufferSize (Irp, minOutputSize, ValidateOutput))\n\t\t\t{\n\t\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\t\tBOOL bFullBuffer = (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= fullOutputSize)? TRUE : FALSE;\n\t\t\t\tPDISK_GEOMETRY_EX outputBuffer = (PDISK_GEOMETRY_EX) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\toutputBuffer->Geometry.MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;\n\t\t\t\toutputBuffer->Geometry.Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\t\toutputBuffer->Geometry.TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\t\toutputBuffer->Geometry.SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\t\toutputBuffer->Geometry.BytesPerSector = Extension->BytesPerSector;\n\t\t\t\t/* add one sector to DiskLength since our partition size is DiskLength and its offset if BytesPerSector */\n\t\t\t\toutputBuffer->DiskSize.QuadPart = Extension->DiskLength + Extension->BytesPerSector;\n\n\t\t\t\tif (bFullBuffer)\n\t\t\t\t{\n\t\t\t\t\tPDISK_PARTITION_INFO pPartInfo = (PDISK_PARTITION_INFO)(((ULONG_PTR) outputBuffer) + sizeof (DISK_GEOMETRY) + sizeof (LARGE_INTEGER));\n\t\t\t\t\tPDISK_DETECTION_INFO pDetectInfo = ((PDISK_DETECTION_INFO)((((ULONG_PTR) pPartInfo) + sizeof (DISK_PARTITION_INFO))));\n\n\t\t\t\t\tpPartInfo->SizeOfPartitionInfo = sizeof (DISK_PARTITION_INFO);\n\t\t\t\t\tpPartInfo->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\t\t\tpPartInfo->Mbr.Signature = GetCrc32((unsigned char*) &(Extension->UniqueVolumeId), 4);\n\n\t\t\t\t\tpDetectInfo->SizeOfDetectInfo = sizeof (DISK_DETECTION_INFO);\n\n\t\t\t\t\tIrp->IoStatus.Information = fullOutputSize;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (DISK_GEOMETRY_EX))\n\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX);\n\t\t\t\t\telse\n\t\t\t\t\t\tIrp->IoStatus.Information = minOutputSize;\n\t\t\t\t}\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_GET_MEDIA_TYPES_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_GET_MEDIA_TYPES_EX)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (GET_MEDIA_TYPES), ValidateOutput))\n\t\t{\n\t\t\tPGET_MEDIA_TYPES outputBuffer = (PGET_MEDIA_TYPES)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_MEDIA_INFO mediaInfo = &outputBuffer->MediaInfo[0];\n\n\t\t\toutputBuffer->DeviceType = FILE_DEVICE_DISK;\n\t\t\toutputBuffer->MediaInfoCount = 1;\n\n\t\t\tif (Extension->bRemovable)\n\t\t\t{\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;\n\t\t\t\tif (Extension->bReadOnly)\n\t\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_ONLY | MEDIA_WRITE_PROTECTED);\n\t\t\t\telse\n\t\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_WRITE);\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = (STORAGE_MEDIA_TYPE) RemovableMedia;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = Extension->BytesPerSector;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.NumberMediaSides = 1;\n\t\t\t\tif (Extension->bReadOnly)\n\t\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_ONLY | MEDIA_WRITE_PROTECTED);\n\t\t\t\telse\n\t\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_WRITE);\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.MediaType = (STORAGE_MEDIA_TYPE) FixedMedia;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.BytesPerSector = Extension->BytesPerSector;\n\t\t\t}\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (GET_MEDIA_TYPES);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_QUERY_PROPERTY:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_QUERY_PROPERTY)\\n\");\t\t\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport || Extension->TrimEnabled)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_PROPERTY_QUERY), ValidateInput))\n\t\t\t{\n\t\t\t\tPSTORAGE_PROPERTY_QUERY pStoragePropQuery = (PSTORAGE_PROPERTY_QUERY) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\tSTORAGE_QUERY_TYPE type = pStoragePropQuery->QueryType;\n\n\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - PropertyId = %d, type = %d, InputBufferLength = %d, OutputBufferLength = %d\\n\", pStoragePropQuery->PropertyId, type, (int) irpSp->Parameters.DeviceIoControl.InputBufferLength, (int) irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\n\t\t\t\tif (Extension->bRawDevice &&\n\t\t\t\t\t\t(pStoragePropQuery->PropertyId == (STORAGE_PROPERTY_ID) StorageDeviceLBProvisioningProperty)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: sending IOCTL_STORAGE_QUERY_PROPERTY (%d) to device\\n\", (int) pStoragePropQuery->PropertyId);\n\t\t\t\t\tIrp->IoStatus.Status = ZwDeviceIoControlFile (\n\t\t\t\t\t\tExtension->hDeviceFile,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\tIOCTL_STORAGE_QUERY_PROPERTY,\n\t\t\t\t\t\tIrp->AssociatedIrp.SystemBuffer,\n\t\t\t\t\t\tirpSp->Parameters.DeviceIoControl.InputBufferLength,\n\t\t\t\t\t\tIrp->AssociatedIrp.SystemBuffer,\n\t\t\t\t\t\tirpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: ZwDeviceIoControlFile returned 0x%.8X\\n\", (DWORD) Irp->IoStatus.Status);\n\t\t\t\t\tif (Irp->IoStatus.Status == STATUS_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\tIrp->IoStatus.Status = IoStatus.Status;\n\t\t\t\t\t\tIrp->IoStatus.Information = IoStatus.Information;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (\t(pStoragePropQuery->PropertyId == StorageAccessAlignmentProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageDeviceProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageAdapterProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageDeviceSeekPenaltyProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageDeviceTrimProperty)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tif (type == PropertyExistsQuery)\n\t\t\t\t\t{\n\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (type == PropertyStandardQuery)\n\t\t\t\t\t{\n\t\t\t\t\t\tULONG descriptorSize;\n\t\t\t\t\t\tswitch (pStoragePropQuery->PropertyId)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase StorageDeviceProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceProperty\\n\");\n\t\t\t\t\t\t\t\t\t/* Add 0x00 for NULL terminating string used as ProductId, ProductRevision, SerialNumber, VendorId */\n\t\t\t\t\t\t\t\t\tdescriptorSize = sizeof (STORAGE_DEVICE_DESCRIPTOR) + 1;\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, descriptorSize, ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DEVICE_DESCRIPTOR outputBuffer = (PSTORAGE_DEVICE_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->DeviceType = FILE_DEVICE_DISK;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->RemovableMedia = Extension->bRemovable? TRUE : FALSE;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->ProductIdOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->SerialNumberOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->ProductRevisionOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->VendorIdOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BusType = BusTypeVirtual;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = descriptorSize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageAdapterProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageAdapterProperty\\n\");\n\t\t\t\t\t\t\t\t\tdescriptorSize = sizeof (STORAGE_ADAPTER_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, descriptorSize, ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_ADAPTER_DESCRIPTOR outputBuffer = (PSTORAGE_ADAPTER_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->MaximumTransferLength = Extension->HostMaximumTransferLength;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->MaximumPhysicalPages = Extension->HostMaximumPhysicalPages;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->AlignmentMask = Extension->HostAlignmentMask;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BusType = BusTypeVirtual;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = descriptorSize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageAccessAlignmentProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageAccessAlignmentProperty\\n\");\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR), ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR outputBuffer = (PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BytesPerLogicalSector = Extension->BytesPerSector;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BytesPerPhysicalSector = Extension->HostBytesPerPhysicalSector;\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageDeviceSeekPenaltyProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceSeekPenaltyProperty\\n\");\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DEVICE_SEEK_PENALTY_DESCRIPTOR), ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPDEVICE_SEEK_PENALTY_DESCRIPTOR outputBuffer = (PDEVICE_SEEK_PENALTY_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceSeekPenaltyProperty: set IncursSeekPenalty to %s\\n\", Extension->IncursSeekPenalty? \"TRUE\" : \"FALSE\");\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->IncursSeekPenalty = (BOOLEAN) Extension->IncursSeekPenalty;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageDeviceTrimProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceTrimProperty\\n\");\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DEVICE_TRIM_DESCRIPTOR), ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPDEVICE_TRIM_DESCRIPTOR outputBuffer = (PDEVICE_TRIM_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceTrimProperty: set TrimEnabled to %s\\n\", Extension->TrimEnabled? \"TRUE\" : \"FALSE\");\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->TrimEnabled = (BOOLEAN) Extension->TrimEnabled;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_PARTITION_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_PARTITION_INFO)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))\n\t\t{\n\t\t\tPPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->PartitionType = Extension->PartitionType;\n\t\t\toutputBuffer->BootIndicator = FALSE;\n\t\t\toutputBuffer->RecognizedPartition = TRUE;\n\t\t\toutputBuffer->RewritePartition = FALSE;\n\t\t\toutputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\toutputBuffer->PartitionLength.QuadPart= Extension->DiskLength;\n\t\t\toutputBuffer->PartitionNumber = 1;\n\t\t\toutputBuffer->HiddenSectors = 0;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (PARTITION_INFORMATION);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_PARTITION_INFO_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_PARTITION_INFO_EX)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))\n\t\t{\n\t\t\tPPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\toutputBuffer->RewritePartition = FALSE;\n\t\t\toutputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\toutputBuffer->PartitionLength.QuadPart= Extension->DiskLength;\n\t\t\toutputBuffer->PartitionNumber = 1;\n\t\t\toutputBuffer->Mbr.PartitionType = Extension->PartitionType;\n\t\t\toutputBuffer->Mbr.BootIndicator = FALSE;\n\t\t\toutputBuffer->Mbr.RecognizedPartition = TRUE;\n\t\t\toutputBuffer->Mbr.HiddenSectors = 0;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_DRIVE_LAYOUT:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_LAYOUT)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))\n\t\t{\n\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\tBOOL bFullBuffer = (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= (sizeof (DRIVE_LAYOUT_INFORMATION) + 3*sizeof(PARTITION_INFORMATION)))? TRUE : FALSE;\n\t\t\tPDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->PartitionCount = bFullBuffer? 4 : 1;\n\t\t\toutputBuffer->Signature = GetCrc32((unsigned char*) &(Extension->UniqueVolumeId), 4);\n\n\t\t\toutputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;\n\t\t\toutputBuffer->PartitionEntry->BootIndicator = FALSE;\n\t\t\toutputBuffer->PartitionEntry->RecognizedPartition = TRUE;\n\t\t\toutputBuffer->PartitionEntry->RewritePartition = FALSE;\n\t\t\toutputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\toutputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;\n\t\t\toutputBuffer->PartitionEntry->PartitionNumber = 1;\n\t\t\toutputBuffer->PartitionEntry->HiddenSectors = 0;\t\t\t\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (DRIVE_LAYOUT_INFORMATION);\n\t\t\tif (bFullBuffer)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information += 3*sizeof(PARTITION_INFORMATION);\n\t\t\t\tmemset (((BYTE*) Irp->AssociatedIrp.SystemBuffer) + sizeof (DRIVE_LAYOUT_INFORMATION), 0, 3*sizeof(PARTITION_INFORMATION));\n\t\t\t}\t\t\t\t\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_DRIVE_LAYOUT_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_LAYOUT_EX)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION_EX), ValidateOutput))\n\t\t\t{\n\t\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\t\tBOOL bFullBuffer = (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= (sizeof (DRIVE_LAYOUT_INFORMATION_EX) + 3*sizeof(PARTITION_INFORMATION_EX)))? TRUE : FALSE;\n\t\t\t\tPDRIVE_LAYOUT_INFORMATION_EX outputBuffer = (PDRIVE_LAYOUT_INFORMATION_EX)\n\t\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\toutputBuffer->PartitionCount = bFullBuffer? 4 : 1;\n\t\t\t\toutputBuffer->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\t\toutputBuffer->Mbr.Signature = GetCrc32((unsigned char*) &(Extension->UniqueVolumeId), 4);\n\n\t\t\t\toutputBuffer->PartitionEntry->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.BootIndicator = FALSE;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.RecognizedPartition = TRUE;\n\t\t\t\toutputBuffer->PartitionEntry->RewritePartition = FALSE;\n\t\t\t\toutputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\t\toutputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;\n\t\t\t\toutputBuffer->PartitionEntry->PartitionNumber = 1;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.HiddenSectors = 0;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.PartitionType = Extension->PartitionType;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (DRIVE_LAYOUT_INFORMATION_EX);\n\t\t\t\tif (bFullBuffer)\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Information += 3*sizeof(PARTITION_INFORMATION_EX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_LENGTH_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_LENGTH_INFO)\\n\");\n\t\tif (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\tIrp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->Length.QuadPart = Extension->DiskLength;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_VERIFY:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_VERIFY)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))\n\t\t{\n\t\t\tHRESULT hResult;\n\t\t\tULONGLONG ullStartingOffset, ullNewOffset, ullEndOffset;\n\t\t\tPVERIFY_INFORMATION pVerifyInformation;\n\t\t\tpVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tullStartingOffset = (ULONGLONG) pVerifyInformation->StartingOffset.QuadPart;\n\t\t\thResult = ULongLongAdd(ullStartingOffset,\n\t\t\t\t(ULONGLONG) Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset,\n\t\t\t\t&ullNewOffset);\n\t\t\tif (hResult != S_OK)\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\telse if (S_OK != ULongLongAdd(ullStartingOffset, (ULONGLONG) pVerifyInformation->Length, &ullEndOffset))\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\telse if (ullEndOffset > (ULONGLONG) Extension->DiskLength)\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\telse\n\t\t\t{\n\t\t\t\tIO_STATUS_BLOCK ioStatus;\n\t\t\t\tPVOID buffer = TCalloc (max (pVerifyInformation->Length, PAGE_SIZE));\n\n\t\t\t\tif (!buffer)\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLARGE_INTEGER offset = pVerifyInformation->StartingOffset;\n\t\t\t\t\toffset.QuadPart = ullNewOffset;\n\n\t\t\t\t\tIrp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);\n\t\t\t\t\tTCfree (buffer);\n\n\t\t\t\t\tif (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)\n\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_CHECK_VERIFY:\n\tcase IOCTL_STORAGE_CHECK_VERIFY:\n\tcase IOCTL_STORAGE_CHECK_VERIFY2:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_CHECK_VERIFY)\\n\");\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))\n\t\t\t{\n\t\t\t\t*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ULONG);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_IS_WRITABLE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_IS_WRITABLE)\\n\");\n\t\t{\n\t\t\tif (Extension->bReadOnly)\n\t\t\t\tIrp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;\n\t\t\telse\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_ONLINE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_ONLINE)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_POST_ONLINE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_POST_ONLINE)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS)\\n\");\n\t\t// Vista's, Windows 8.1 and later filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.\n\t\tif (!(OsMajorVersion == 6 && OsMinorVersion == 0) \n\t\t\t&& !(IsOSAtLeast (WIN_8_1) && AllowWindowsDefrag && Extension->bRawDevice)\n\t\t\t)\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\telse if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))\n\t\t{\n\t\t\tVOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\n\n\t\t\tif (IsOSAtLeast (WIN_8_1))\n\t\t\t{\n\t\t\t\t// Windows 10 filesystem defragmenter works only if we report an extent with a real disk number\n\t\t\t\t// So in the case of a VeraCrypt disk based volume, we use the disk number\n\t\t\t\t// of the underlaying physical disk and we report a single extent \n\t\t\t\textents->NumberOfDiskExtents = 1;\n\t\t\t\textents->Extents[0].DiskNumber = Extension->DeviceNumber;\n\t\t\t\textents->Extents[0].StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\t\textents->Extents[0].ExtentLength.QuadPart = Extension->DiskLength;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Vista: No extent data can be returned as this is not a physical drive.\t\t\t\t\n\t\t\t\tmemset (extents, 0, sizeof (*extents));\n\t\t\t\textents->NumberOfDiskExtents = 0;\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (*extents);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_READ_CAPACITY:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_READ_CAPACITY)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_READ_CAPACITY), ValidateOutput))\n\t\t\t{\n\t\t\t\tSTORAGE_READ_CAPACITY *capacity = (STORAGE_READ_CAPACITY *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tcapacity->Version = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\tcapacity->Size = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\tcapacity->BlockLength = Extension->BytesPerSector;\n\t\t\t\tcapacity->NumberOfBlocks.QuadPart = (Extension->DiskLength / Extension->BytesPerSector) + 1;\n\t\t\t\tcapacity->DiskLength.QuadPart = Extension->DiskLength + Extension->BytesPerSector;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t/*case IOCTL_STORAGE_GET_DEVICE_NUMBER:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_GET_DEVICE_NUMBER)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_DEVICE_NUMBER), ValidateOutput))\n\t\t\t{\n\t\t\t\tSTORAGE_DEVICE_NUMBER *storage = (STORAGE_DEVICE_NUMBER *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tstorage->DeviceType = FILE_DEVICE_DISK;\n\t\t\t\tstorage->DeviceNumber = (ULONG) -1;\n\t\t\t\tstorage->PartitionNumber = 1;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DEVICE_NUMBER);\n\t\t\t}\n\t\t}\n\t\tbreak;*/\n\n\tcase IOCTL_STORAGE_GET_HOTPLUG_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_GET_HOTPLUG_INFO)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_HOTPLUG_INFO), ValidateOutput))\n\t\t\t{\n\t\t\t\tSTORAGE_HOTPLUG_INFO *info = (STORAGE_HOTPLUG_INFO *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tinfo->Size = sizeof (STORAGE_HOTPLUG_INFO);\n\t\t\t\tinfo->MediaRemovable = Extension->bRemovable? TRUE : FALSE;\n\t\t\t\tinfo->MediaHotplug = FALSE;\n\t\t\t\tinfo->DeviceHotplug = FALSE;\n\t\t\t\tinfo->WriteCacheEnableOverride = FALSE;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_HOTPLUG_INFO);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_IS_DYNAMIC:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_IS_DYNAMIC)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (BOOLEAN), ValidateOutput))\n\t\t\t{\n\t\t\t\tBOOLEAN *pbDynamic = (BOOLEAN*) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t*pbDynamic = FALSE;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (BOOLEAN);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_IS_CLUSTERED:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_IS_CLUSTERED)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (BOOLEAN), ValidateOutput))\n\t\t\t{\n\t\t\t\tBOOLEAN *pbIsClustered = (BOOLEAN*) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t*pbIsClustered = FALSE;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (BOOLEAN);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_GET_GPT_ATTRIBUTES:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_GET_GPT_ATTRIBUTES)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (VOLUME_GET_GPT_ATTRIBUTES_INFORMATION), ValidateOutput))\n\t\t\t{\n\t\t\t\tVOLUME_GET_GPT_ATTRIBUTES_INFORMATION *pGptAttr = (VOLUME_GET_GPT_ATTRIBUTES_INFORMATION*) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tpGptAttr->GptAttributes = 0; // we are MBR not GPT\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (VOLUME_GET_GPT_ATTRIBUTES_INFORMATION);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_UNKNOWN_WINDOWS10_EFS_ACCESS:\n\t\t// This undocumented IOCTL is sent when handling EFS data\n\t\t// We must return success otherwise EFS operations fail\n\t\tDump (\"ProcessVolumeDeviceControlIrp (unknown IOCTL 0x%.8X, OutputBufferLength = %d). Returning fake success\\n\", irpSp->Parameters.DeviceIoControl.IoControlCode, (int) irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_UPDATE_PROPERTIES:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_SUCCESS for IOCTL_DISK_UPDATE_PROPERTIES\\n\");\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_MEDIA_REMOVAL:\n\tcase IOCTL_STORAGE_MEDIA_REMOVAL:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_SUCCESS for %ls\\n\", TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode));\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_CLUSTER_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_NOT_SUPPORTED for %ls\\n\", TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode));\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (Extension->bRawDevice && Extension->TrimEnabled)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DEVICE_MANAGE_DATA_SET_ATTRIBUTES), ValidateInput))\n\t\t\t{\n\t\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\t\tDWORD inputLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;\n\t\t\t\tPDEVICE_MANAGE_DATA_SET_ATTRIBUTES pInputAttrs = (PDEVICE_MANAGE_DATA_SET_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\tDEVICE_DATA_MANAGEMENT_SET_ACTION action = pInputAttrs->Action;\n\t\t\t\tBOOL bEntireSet = pInputAttrs->Flags & DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE? TRUE : FALSE;\n\t\t\t\tULONGLONG minSizedataSet = (ULONGLONG) pInputAttrs->DataSetRangesOffset + (ULONGLONG) pInputAttrs->DataSetRangesLength;\n\t\t\t\tULONGLONG minSizeParameter = (ULONGLONG) pInputAttrs->ParameterBlockOffset + (ULONGLONG) pInputAttrs->ParameterBlockLength;\n\t\t\t\tULONGLONG minSizeGeneric = sizeof(DEVICE_MANAGE_DATA_SET_ATTRIBUTES) + (ULONGLONG) pInputAttrs->ParameterBlockLength + (ULONGLONG) pInputAttrs->DataSetRangesLength;\n\t\t\t\tPDEVICE_MANAGE_DATA_SET_ATTRIBUTES pNewSetAttrs = NULL;\n\t\t\t\tULONG ulNewInputLength = 0;\n\t\t\t\tBOOL bForwardIoctl = FALSE;\n\n\t\t\t\tif (inputLength >= minSizeGeneric && inputLength >= minSizedataSet && inputLength >= minSizeParameter)\n\t\t\t\t{\n\t\t\t\t\tif (bEntireSet)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (minSizedataSet)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE set but data set range specified=> Error.\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDWORD dwDataSetOffset = ALIGN_VALUE (inputLength, sizeof(DEVICE_DATA_SET_RANGE));\n\t\t\t\t\t\t\tDWORD dwDataSetLength = sizeof(DEVICE_DATA_SET_RANGE);\n\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE set. Setting data range to all volume.\\n\");\n\n\t\t\t\t\t\t\tulNewInputLength = dwDataSetOffset + dwDataSetLength;\n\t\t\t\t\t\t\tpNewSetAttrs = (PDEVICE_MANAGE_DATA_SET_ATTRIBUTES) TCalloc (ulNewInputLength);\n\t\t\t\t\t\t\tif (pNewSetAttrs)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPDEVICE_DATA_SET_RANGE pRange = (PDEVICE_DATA_SET_RANGE) (((unsigned char*) pNewSetAttrs) + dwDataSetOffset);\n\n\t\t\t\t\t\t\t\tmemcpy (pNewSetAttrs, pInputAttrs, inputLength);\n\n\t\t\t\t\t\t\t\tpRange->StartingOffset = (ULONGLONG) Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;\n\t\t\t\t\t\t\t\tpRange->LengthInBytes = Extension->DiskLength;\n\n\t\t\t\t\t\t\t\tpNewSetAttrs->Size = sizeof(DEVICE_MANAGE_DATA_SET_ATTRIBUTES);\n\t\t\t\t\t\t\t\tpNewSetAttrs->Action = action;\n\t\t\t\t\t\t\t\tpNewSetAttrs->Flags = pInputAttrs->Flags & (~DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE);\n\t\t\t\t\t\t\t\tpNewSetAttrs->ParameterBlockOffset = pInputAttrs->ParameterBlockOffset;\n\t\t\t\t\t\t\t\tpNewSetAttrs->ParameterBlockLength = pInputAttrs->ParameterBlockLength;\n\t\t\t\t\t\t\t\tpNewSetAttrs->DataSetRangesOffset = dwDataSetOffset;\n\t\t\t\t\t\t\t\tpNewSetAttrs->DataSetRangesLength = dwDataSetLength;\n\n\t\t\t\t\t\t\t\tbForwardIoctl = TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - Failed to allocate memory.\\n\");\n\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - creating new data set range from input range.\\n\");\n\t\t\t\t\t\tulNewInputLength = inputLength;\n\t\t\t\t\t\tpNewSetAttrs = (PDEVICE_MANAGE_DATA_SET_ATTRIBUTES) TCalloc (inputLength);\n\t\t\t\t\t\tif (pNewSetAttrs)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPDEVICE_DATA_SET_RANGE pNewRanges = (PDEVICE_DATA_SET_RANGE) (((unsigned char*) pNewSetAttrs) + pInputAttrs->DataSetRangesOffset);\n\t\t\t\t\t\t\tPDEVICE_DATA_SET_RANGE pInputRanges = (PDEVICE_DATA_SET_RANGE) (((unsigned char*) pInputAttrs) + pInputAttrs->DataSetRangesOffset);\n\t\t\t\t\t\t\tDWORD dwInputRangesCount = 0, dwNewRangesCount = 0, i;\n\t\t\t\t\t\t\tULONGLONG ullStartingOffset, ullNewOffset, ullEndOffset;\n\t\t\t\t\t\t\tHRESULT hResult;\n\n\t\t\t\t\t\t\tmemcpy (pNewSetAttrs, pInputAttrs, inputLength);\n\n\t\t\t\t\t\t\tdwInputRangesCount = pInputAttrs->DataSetRangesLength / sizeof(DEVICE_DATA_SET_RANGE);\n\n\t\t\t\t\t\t\tfor (i = 0; i < dwInputRangesCount; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tullStartingOffset = (ULONGLONG) pInputRanges[i].StartingOffset;\n\t\t\t\t\t\t\t\thResult = ULongLongAdd(ullStartingOffset,\n\t\t\t\t\t\t\t\t\t(ULONGLONG) Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset,\n\t\t\t\t\t\t\t\t\t&ullNewOffset);\n\t\t\t\t\t\t\t\tif (hResult != S_OK)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\telse if (S_OK != ULongLongAdd(ullStartingOffset, (ULONGLONG) pInputRanges[i].LengthInBytes, &ullEndOffset))\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\telse if (ullEndOffset > (ULONGLONG) Extension->DiskLength)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\telse if (ullNewOffset > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpNewRanges[dwNewRangesCount].StartingOffset = (LONGLONG) ullNewOffset;\n\t\t\t\t\t\t\t\t\tpNewRanges[dwNewRangesCount].LengthInBytes = pInputRanges[i].LengthInBytes;\n\n\t\t\t\t\t\t\t\t\tdwNewRangesCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - %d valid range processed from %d range in input.\\n\", (int) dwNewRangesCount, (int) dwInputRangesCount);\n\n\t\t\t\t\t\t\tpNewSetAttrs->DataSetRangesLength = dwNewRangesCount * sizeof (DEVICE_DATA_SET_RANGE);\n\n\t\t\t\t\t\t\tbForwardIoctl = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - Failed to allocate memory.\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - buffer containing DEVICE_MANAGE_DATA_SET_ATTRIBUTES has invalid length.\\n\");\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\n\n\t\t\t\tif (bForwardIoctl)\n\t\t\t\t{\n\t\t\t\t\tif (action == DeviceDsmAction_Trim)\n\t\t\t\t\t{\n\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Trim.\\n\");\n\n\t\t\t\t\t\tif (Extension->cryptoInfo->hiddenVolume || !AllowTrimCommand)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: TRIM command filtered\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: sending TRIM to device\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = ZwDeviceIoControlFile (\n\t\t\t\t\t\t\t\tExtension->hDeviceFile,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\tIOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES,\n\t\t\t\t\t\t\t\t(PVOID) pNewSetAttrs,\n\t\t\t\t\t\t\t\tulNewInputLength,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t0);\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: ZwDeviceIoControlFile returned 0x%.8X\\n\", (DWORD) Irp->IoStatus.Status);\n\t\t\t\t\t\t\tif (Irp->IoStatus.Status == STATUS_SUCCESS)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tIrp->IoStatus.Status = IoStatus.Status;\n\t\t\t\t\t\t\t\tIrp->IoStatus.Information = IoStatus.Information;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DeviceDsmAction_Notification: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Notification\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_OffloadRead: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_OffloadRead\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_OffloadWrite: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_OffloadWrite\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_Allocation: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Allocation\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_Scrub: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Scrub\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_DrtQuery: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_DrtQuery\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_DrtClear: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_DrtClear\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_DrtDisable: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_DrtDisable\\n\"); break;\n\t\t\t\t\t\t\tdefault: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - unknown action %d\\n\", (int) action); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pNewSetAttrs)\n\t\t\t\t\tTCfree (pNewSetAttrs);\n\t\t\t}\n\t\t}\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\t\telse\n\t\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_INVALID_DEVICE_REQUEST for IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES\\n\");\n#endif\n\t\tbreak;\n\t\n\tcase IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT:\n\tcase IOCTL_VOLUME_QUERY_ALLOCATION_HINT:\n\tcase FT_BALANCED_READ_MODE:\n\tcase IOCTL_STORAGE_GET_DEVICE_NUMBER:\n\tcase IOCTL_MOUNTDEV_LINK_CREATED:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_INVALID_DEVICE_REQUEST for %ls\\n\", TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode));\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\t\t\n\t\tbreak;\n\tdefault:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (unknown code 0x%.8X)\\n\", irpSp->Parameters.DeviceIoControl.IoControlCode);\n\t\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n\t}\n\n#if defined(DEBUG) || defined (DEBG_TRACE)\n\tif (!NT_SUCCESS (Irp->IoStatus.Status))\n\t{\n\t\tDump (\"IOCTL error 0x%08x (0x%x %d)\\n\",\n\t\t\tIrp->IoStatus.Status,\n\t\t\t(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),\n\t\t\t(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));\n\t}\n#endif\n\n\treturn TCCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);\n}\n\n\nNTSTATUS ProcessMainDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, PIRP Irp)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\tNTSTATUS ntStatus;\n\n\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t{\n\tcase TC_IOCTL_GET_DRIVER_VERSION:\n\tcase TC_IOCTL_LEGACY_GET_DRIVER_VERSION:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))\n\t\t{\n\t\t\tLONG tmp = VERSION_NUM;\n\t\t\tmemcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);\n\t\t\tIrp->IoStatus.Information = sizeof (LONG);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DEVICE_REFCOUNT:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tLONG deviceObjectCount = 0;\n\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;\n\n\t\t\tif (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_ANY_VOLUME_MOUNTED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tint drive;\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tif (GetVirtualVolumeDeviceObject (drive))\n\t\t\t\t{\n\t\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (IsBootDriveMounted())\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_OPEN_TEST:\n\t\t{\n\t\t\tOPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tACCESS_MASK access = FILE_READ_ATTRIBUTES;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\tEnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));\n\t\t\tRtlInitUnicodeString (&FullFileName, opentest->wszFileName);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\taccess |= FILE_READ_DATA;\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\t\t\t SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\t\t\t 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\topentest->TCBootLoaderDetected = FALSE;\n\t\t\t\topentest->FilesystemDetected = FALSE;\n\t\t\t\tmemset (opentest->VolumeIDComputed, 0, sizeof (opentest->VolumeIDComputed));\n\t\t\t\tmemset (opentest->volumeIDs, 0, sizeof (opentest->volumeIDs));\n\n\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\t{\n\t\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\t\tif (!readBuffer)\n\t\t\t\t\t{\n\t\t\t\t\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Determine if the first sector contains a portion of the VeraCrypt Boot Loader\n\n\t\t\t\t\t\t\toffset.QuadPart = 0;\n\n\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t\tif (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Search for the string \"VeraCrypt\"\n\t\t\t\t\t\t\t\t\tfor (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\topentest->TCBootLoaderDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tswitch (BE64 (*(uint64 *) readBuffer))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase 0xEB52904E54465320ULL: // NTFS\n\t\t\t\t\t\t\t\t\tcase 0xEB3C904D53444F53ULL: // FAT16/FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB58904D53444F53ULL: // FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB76904558464154ULL: // exFAT\n\t\t\t\t\t\t\t\t\tcase 0x0000005265465300ULL: // ReFS\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B66732EULL: // FAT32 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B646F73ULL: // FAT32 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B66732EULL: // FAT16/FAT12 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B646F73ULL: // FAT16/FAT12 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 0x0000000000000000ULL:\n\t\t\t\t\t\t\t\t\t\t// all 512 bytes are zeroes => unencrypted filesystem like Microsoft reserved partition\n\t\t\t\t\t\t\t\t\t\tif (IsAllZeroes (readBuffer + 8, TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8))\n\t\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opentest->bComputeVolumeIDs && (!opentest->DetectFilesystem || !opentest->FilesystemDetected))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint volumeType;\n\t\t\t\t\t\t\t// Go through all volume types (e.g., normal, hidden)\n\t\t\t\t\t\t\tfor (volumeType = TC_VOLUME_TYPE_NORMAL;\n\t\t\t\t\t\t\t\tvolumeType < TC_VOLUME_TYPE_COUNT;\n\t\t\t\t\t\t\t\tvolumeType++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Read the volume header */\n\t\t\t\t\t\t\t\tswitch (volumeType)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_NORMAL:\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_HIDDEN:\n\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/* compute the ID of this volume: SHA-256 of the effective header */\n\t\t\t\t\t\t\t\t\tsha256 (opentest->volumeIDs[volumeType], readBuffer, TC_VOLUME_HEADER_EFFECTIVE_SIZE);\n\t\t\t\t\t\t\t\t\topentest->VolumeIDComputed[volumeType] = TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tTCfree (readBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\t\t\t\tDump (\"Open test on file %ls success.\\n\", opentest->wszFileName);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#if 0\n\t\t\t\tDump (\"Open test on file %ls failed NTSTATUS 0x%08x\\n\", opentest->wszFileName, ntStatus);\n#endif\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;\n\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:\n\t\t{\n\t\t\tGetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tbyte readBuffer [TC_SECTOR_SIZE_BIOS];\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\tEnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));\n\t\t\tRtlInitUnicodeString (&FullFileName, request->DevicePath);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\tSYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\tFILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\t// Determine if the first sector contains a portion of the VeraCrypt Boot Loader\n\t\t\t\toffset.QuadPart = 0;\t// MBR\n\n\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\tNULL,\n\t\t\t\t\tNULL,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&IoStatus,\n\t\t\t\t\treadBuffer,\n\t\t\t\t\tsizeof(readBuffer),\n\t\t\t\t\t&offset,\n\t\t\t\t\tNULL);\n\n\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t{\n\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t// Check for dynamic drive\n\t\t\t\t\trequest->DriveIsDynamic = FALSE;\n\n\t\t\t\t\tif (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)\n\t\t\t\t\t{\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequest->DriveIsDynamic = TRUE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trequest->BootLoaderVersion = 0;\n\t\t\t\t\trequest->Configuration = 0;\n\t\t\t\t\trequest->UserConfiguration = 0;\n\t\t\t\t\trequest->CustomUserMessage[0] = 0;\n\n\t\t\t\t\t// Search for the string \"VeraCrypt\"\n\t\t\t\t\tfor (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequest->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));\n\t\t\t\t\t\t\trequest->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];\n\n\t\t\t\t\t\t\tif (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequest->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];\n\t\t\t\t\t\t\t\tmemcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_WIPE_PASSWORD_CACHE:\n\t\tWipeCache ();\n\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tIrp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tif (!UserCanAccessDriveDevice())\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPortableMode = TRUE;\n\t\t\tDump (\"Setting portable mode\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tIrp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))\n\t\t{\n\t\t\tMOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice;\n\t\t\tint drive;\n\n\t\t\tlist->ulMountedDrives = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension;\n\n\t\t\t\tListDevice = GetVirtualVolumeDeviceObject (drive);\n\t\t\t\tif (!ListDevice)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tlist->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);\n\t\t\t\t\tRtlStringCbCopyW (list->wszVolume[ListExtension->nDosDriveNo], sizeof(list->wszVolume[ListExtension->nDosDriveNo]),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (list->wszLabel[ListExtension->nDosDriveNo], sizeof(list->wszLabel[ListExtension->nDosDriveNo]),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (list->volumeID[ListExtension->nDosDriveNo], ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tlist->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;\n\t\t\t\t\tlist->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tif (ListExtension->cryptoInfo->hiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;\t// Hidden volume\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;\t// Normal/outer volume (hidden volume protected AND write already prevented)\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;\t// Normal/outer volume (hidden volume protected)\n\t\t\t\t\telse\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;\t// Normal volume\n\t\t\t\t\tlist->truecryptMode[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->bTrueCryptMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))\n\t\t{\n\t\t\t// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.\n\t\t\t// The user could render the system unbootable by downgrading when boot encryption\n\t\t\t// is active or being set up.\n\n\t\t\tmemset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\t*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_VOLUME_PROPERTIES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tVOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);\n\n\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tprop->uniqueId = ListExtension->UniqueVolumeId;\n\t\t\t\t\tRtlStringCbCopyW (prop->wszVolume, sizeof(prop->wszVolume),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (prop->wszLabel, sizeof(prop->wszLabel),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (prop->volumeID, ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tprop->bDriverSetLabel = ListExtension->bDriverSetLabel;\n\t\t\t\t\tprop->diskLength = ListExtension->DiskLength;\n\t\t\t\t\tprop->ea = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tprop->mode = ListExtension->cryptoInfo->mode;\n\t\t\t\t\tprop->pkcs5 = ListExtension->cryptoInfo->pkcs5;\n\t\t\t\t\tprop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;\n\t\t\t\t\tprop->volumePim = ListExtension->cryptoInfo->volumePim;\n#if 0\n\t\t\t\t\tprop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;\n\t\t\t\t\tprop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;\n#endif\n\t\t\t\t\tprop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;\n\t\t\t\t\tprop->readOnly = ListExtension->bReadOnly;\n\t\t\t\t\tprop->removable = ListExtension->bRemovable;\n\t\t\t\t\tprop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;\n\t\t\t\t\tprop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;\n\n\t\t\t\t\tif (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tprop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;\n\t\t\t\t\telse\n\t\t\t\t\t\tprop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;\n\n\t\t\t\t\tprop->totalBytesRead = ListExtension->Queue.TotalBytesRead;\n\t\t\t\t\tprop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;\n\n\t\t\t\t\tprop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;\n\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tRESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));\n\n\t\t\t\tntStatus = SymbolicLinkToTarget (resolve->symLinkName,\n\t\t\t\t\tresolve->targetName,\n\t\t\t\t\tsizeof (resolve->targetName));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tPARTITION_INFORMATION_EX pi;\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));\n\n\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));\n\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t{\n\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\n\t\t\t\t\tinfo->partInfo.PartitionLength = pi.PartitionLength;\n\t\t\t\t\tinfo->partInfo.PartitionNumber = pi.PartitionNumber;\n\t\t\t\t\tinfo->partInfo.StartingOffset = pi.StartingOffset;\n\n\t\t\t\t\tif (pi.PartitionStyle == PARTITION_STYLE_MBR)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo->partInfo.PartitionType = pi.Mbr.PartitionType;\n\t\t\t\t\t\tinfo->partInfo.BootIndicator = pi.Mbr.BootIndicator;\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));\n\t\t\t\t\tinfo->IsGPT = FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\t\t{\n\t\t\t\t\tGET_LENGTH_INFORMATION lengthInfo;\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));\n\n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\t\t\t\t\t\tinfo->partInfo.PartitionLength = lengthInfo.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinfo->IsDynamic = FALSE;\n\n\t\t\t\tif (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)\n\t\t\t\t{\n#\t\t\t\t\tdefine IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\t\t\t\t\tif (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))\n\t\t\t\t\t\tinfo->IsDynamic = FALSE;\n\t\t\t\t}\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_GEOMETRY:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\n\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\tNULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_DRIVE_GEOMETRY_EX:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_EX_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_EX_STRUCT *g = (DISK_GEOMETRY_EX_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\t\t\t\tPVOID buffer = TCalloc (256); // enough for DISK_GEOMETRY_EX and padded data\n\t\t\t\tif (buffer)\n\t\t\t\t{\n\t\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY_EX on %ls\\n\", g->deviceName);\n\n\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY_EX,\n\t\t\t\t\t\tNULL, 0, buffer, 256);\n\n\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tPDISK_GEOMETRY_EX pGeo = (PDISK_GEOMETRY_EX) buffer;\n\t\t\t\t\t\tmemcpy (&g->diskGeometry, &pGeo->Geometry, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\tg->DiskSize.QuadPart = pGeo->DiskSize.QuadPart;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDISK_GEOMETRY dg = {0};\n\t\t\t\t\t\tDump (\"Failed. Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\t\t\tNULL, 0, &dg, sizeof (dg));\n\n\t\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy (&g->diskGeometry, &dg, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\t\tg->DiskSize.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;\n\n\t\t\t\t\t\t\tif (OsMajorVersion >= 6)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSTORAGE_READ_CAPACITY storage = {0};\n\t\t\t\t\t\t\t\tNTSTATUS lStatus;\n\t\t\t\t\t\t\t\tstorage.Version = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\t\t\t\t\tDump (\"Calling IOCTL_STORAGE_READ_CAPACITY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\t\t\tlStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\t\t\tIOCTL_STORAGE_READ_CAPACITY,\n\t\t\t\t\t\t\t\t\tNULL, 0, &storage, sizeof (STORAGE_READ_CAPACITY));\n\t\t\t\t\t\t\t\tif (\tNT_SUCCESS(lStatus)\n\t\t\t\t\t\t\t\t\t&& (storage.Size == sizeof (STORAGE_READ_CAPACITY))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tg->DiskSize.QuadPart = storage.DiskLength.QuadPart;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTCfree (buffer);\n\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX_STRUCT);\n\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_PROBE_REAL_DRIVE_SIZE:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))\n\t\t{\n\t\t\tProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tNTSTATUS status;\n\t\t\tUNICODE_STRING name;\n\t\t\tPFILE_OBJECT fileObject;\n\t\t\tPDEVICE_OBJECT deviceObject;\n\n\t\t\tEnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));\n\n\t\t\tRtlInitUnicodeString (&name, request->DeviceName);\n\t\t\tstatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);\n\t\t\tif (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);\n\t\t\tObDereferenceObject (fileObject);\n\n\t\t\tif (status == STATUS_TIMEOUT)\n\t\t\t{\n\t\t\t\trequest->TimeOut = TRUE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t}\n\t\t\telse if (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trequest->TimeOut = FALSE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_MOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tMOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tif (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD\n\t\t\t\t||\tmount->pkcs5_prf < 0 || mount->pkcs5_prf > LAST_PRF_ID\n\t\t\t\t||\tmount->VolumePim < -1 || mount->VolumePim == INT_MAX\n\t\t\t\t|| mount->ProtectedHidVolPkcs5Prf < 0 || mount->ProtectedHidVolPkcs5Prf > LAST_PRF_ID\n\t\t\t\t|| (mount->bTrueCryptMode != FALSE && mount->bTrueCryptMode != TRUE)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));\n\t\t\tEnsureNullTerminatedString (mount->wszLabel, sizeof (mount->wszLabel));\n\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = MountDevice (DeviceObject, mount);\n\n\t\t\tburn (&mount->VolumePassword, sizeof (mount->VolumePassword));\n\t\t\tburn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));\n\t\t\tburn (&mount->pkcs5_prf, sizeof (mount->pkcs5_prf));\n\t\t\tburn (&mount->VolumePim, sizeof (mount->VolumePim));\n\t\t\tburn (&mount->bTrueCryptMode, sizeof (mount->bTrueCryptMode));\n\t\t\tburn (&mount->ProtectedHidVolPkcs5Prf, sizeof (mount->ProtectedHidVolPkcs5Prf));\n\t\t\tburn (&mount->ProtectedHidVolPim, sizeof (mount->ProtectedHidVolPim));\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);\n\n\t\t\tunmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t\tunmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_ALL_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tunmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = AbortBootEncryptionSetup();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tGetBootEncryptionStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:\n\t\tIrp->IoStatus.Information = 0;\n\t\tIrp->IoStatus.Status = GetSetupResult();\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tGetBootDriveVolumeProperties (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_LOADER_VERSION:\n\t\tGetBootLoaderVersion (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:\n\t\tReopenBootVolumeHeader (Irp, irpSp);\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT:\n\t\tGetBootLoaderFingerprint (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:\n\t\tGetBootEncryptionAlgorithmName (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_START_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = AbortDecoySystemWipe();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:\n\t\tIrp->IoStatus.Status = GetDecoySystemWipeResult();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:\n\t\tGetDecoySystemWipeStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:\n\t\tIrp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_WARNING_FLAGS:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))\n\t\t{\n\t\t\tGetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tflags->PagingFileCreationPrevented = PagingFileCreationPrevented;\n\t\t\tPagingFileCreationPrevented = FALSE;\n\t\t\tflags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;\n\t\t\tSystemFavoriteVolumeDirty = FALSE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (GetWarningFlagsRequest);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:\n\t\tif (UserCanAccessDriveDevice())\n\t\t{\n\t\t\tSystemFavoriteVolumeDirty = TRUE;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\telse\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_REREAD_DRIVER_CONFIG:\n\t\tIrp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:\n\t\tif (\t(ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))\n\t\t\t&&\t(Irp->RequestorMode == KernelMode)\n\t\t\t)\n\t\t{\n\t\t\tGetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\trequest->BootDriveFilterExtension = GetBootDriveFilterExtension();\n\t\t\tif (IsBootDriveMounted() && request->BootDriveFilterExtension)\n\t\t\t{\n\t\t\t\trequest->HwEncryptionEnabled = IsHwEncryptionEnabled();\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n\t}\n\n\n#if defined(DEBUG) || defined(DEBUG_TRACE)\n\tif (!NT_SUCCESS (Irp->IoStatus.Status))\n\t{\n\t\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\t\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_OPEN_TEST:\n\t\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDump (\"IOCTL error 0x%08x\\n\", Irp->IoStatus.Status);\n\t\t}\n\t}\n#endif\n\n\treturn TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);\n}\n\n\nNTSTATUS TCStartThread (PKSTART_ROUTINE threadProc, PVOID threadArg, PKTHREAD *kThread)\n{\n\treturn TCStartThreadInProcess (threadProc, threadArg, kThread, NULL);\n}\n\n\nNTSTATUS TCStartThreadInProcess (PKSTART_ROUTINE threadProc, PVOID threadArg, PKTHREAD *kThread, PEPROCESS process)\n{\n\tNTSTATUS status;\n\tHANDLE threadHandle;\n\tHANDLE processHandle = NULL;\n\tOBJECT_ATTRIBUTES threadObjAttributes;\n\n\tif (process)\n\t{\n\t\tstatus = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);\n\t\tif (!NT_SUCCESS (status))\n\t\t\treturn status;\n\t}\n\n\tInitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tstatus = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tstatus = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);\n\tif (!NT_SUCCESS (status))\n\t{\n\t\tZwClose (threadHandle);\n\t\t*kThread = NULL;\n\t\treturn status;\n\t}\n\n\tif (processHandle)\n\t\tZwClose (processHandle);\n\n\tZwClose (threadHandle);\n\treturn STATUS_SUCCESS;\n}\n\n\nvoid TCStopThread (PKTHREAD kThread, PKEVENT wakeUpEvent)\n{\n\tif (wakeUpEvent)\n\t\tKeSetEvent (wakeUpEvent, 0, FALSE);\n\n\tKeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);\n\tObDereferenceObject (kThread);\n}\n\n\nNTSTATUS TCStartVolumeThread (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, MOUNT_STRUCT * mount)\n{\n\tPTHREAD_BLOCK pThreadBlock = TCalloc (sizeof (THREAD_BLOCK));\n\tHANDLE hThread;\n\tNTSTATUS ntStatus;\n\tOBJECT_ATTRIBUTES threadObjAttributes;\n\tSECURITY_QUALITY_OF_SERVICE qos;\n\n\tDump (\"Starting thread...\\n\");\n\n\tif (pThreadBlock == NULL)\n\t{\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\t}\n\telse\n\t{\n\t\tpThreadBlock->DeviceObject = DeviceObject;\n\t\tpThreadBlock->mount = mount;\n\t}\n\n\tqos.Length = sizeof (qos);\n\tqos.ContextTrackingMode = SECURITY_STATIC_TRACKING;\n\tqos.EffectiveOnly = TRUE;\n\tqos.ImpersonationLevel = SecurityImpersonation;\n\n\tntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);\n\tif (!NT_SUCCESS (ntStatus))\n\t\tgoto ret;\n\n\tExtension->SecurityClientContextValid = TRUE;\n\n\tExtension->bThreadShouldQuit = FALSE;\n\n\tInitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tntStatus = PsCreateSystemThread (&hThread,\n\t\t\t\t\t THREAD_ALL_ACCESS,\n\t\t\t\t\t &threadObjAttributes,\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL,\n\t\t\t\t\t VolumeThreadProc,\n\t\t\t\t\t pThreadBlock);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"PsCreateSystemThread Failed END\\n\");\n\t\tgoto ret;\n\t}\n\n\tntStatus = ObReferenceObjectByHandle (hThread,\n\t\t\t\t   THREAD_ALL_ACCESS,\n\t\t\t\t   NULL,\n\t\t\t\t   KernelMode,\n\t\t\t\t   &Extension->peThread,\n\t\t\t\t   NULL);\n\n\tZwClose (hThread);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\tgoto ret;\n\n\tDump (\"Waiting for thread to initialize...\\n\");\n\n\tKeWaitForSingleObject (&Extension->keCreateEvent,\n\t\t\t       Executive,\n\t\t\t       KernelMode,\n\t\t\t       FALSE,\n\t\t\t       NULL);\n\n\tDump (\"Waiting completed! Thread returns 0x%08x\\n\", pThreadBlock->ntCreateStatus);\n\tntStatus = pThreadBlock->ntCreateStatus;\n\nret:\n\tTCfree (pThreadBlock);\n\treturn ntStatus;\n}\n\nvoid TCStopVolumeThread (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension)\n{\n\tNTSTATUS ntStatus;\n\n\tUNREFERENCED_PARAMETER (DeviceObject);\t/* Remove compiler warning */\n\n\tDump (\"Signalling thread to quit...\\n\");\n\n\tExtension->bThreadShouldQuit = TRUE;\n\n\tKeReleaseSemaphore (&Extension->RequestSemaphore,\n\t\t\t    0,\n\t\t\t    1,\n\t\t\t    TRUE);\n\n\tntStatus = KeWaitForSingleObject (Extension->peThread,\n\t\t\t\t\t  Executive,\n\t\t\t\t\t  KernelMode,\n\t\t\t\t\t  FALSE,\n\t\t\t\t\t  NULL);\n\n\tASSERT (NT_SUCCESS (ntStatus));\n\n\tObDereferenceObject (Extension->peThread);\n\tExtension->peThread = NULL;\n\n\tDump (\"Thread exited\\n\");\n}\n\n\n// Suspend current thread for a number of milliseconds\nvoid TCSleep (int milliSeconds)\n{\n\tPKTIMER timer = (PKTIMER) TCalloc (sizeof (KTIMER));\n\tLARGE_INTEGER duetime;\n\n\tif (!timer)\n\t\treturn;\n\n\tduetime.QuadPart = (__int64) milliSeconds * -10000;\n\tKeInitializeTimerEx(timer, NotificationTimer);\n\tKeSetTimerEx(timer, duetime, 0, NULL);\n\n\tKeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);\n\n\tTCfree (timer);\n}\n\nBOOL IsDeviceName(wchar_t wszVolume[TC_MAX_PATH])\n{\n\tif\t(\t(wszVolume[0] == '\\\\')\n\t\t&&\t(wszVolume[1] == 'D' || wszVolume[1] == 'd')\n\t\t&&\t(wszVolume[2] == 'E' || wszVolume[2] == 'e')\n\t\t&&\t(wszVolume[3] == 'V' || wszVolume[3] == 'v')\n\t\t&&\t(wszVolume[4] == 'I' || wszVolume[4] == 'i')\n\t\t&&\t(wszVolume[5] == 'C' || wszVolume[5] == 'c')\n\t\t&&\t(wszVolume[6] == 'E' || wszVolume[6] == 'e')\n\t\t)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t\treturn FALSE;\n}\n\n/* VolumeThreadProc does all the work of processing IRP's, and dispatching them\n   to either the ReadWrite function or the DeviceControl function */\nVOID VolumeThreadProc (PVOID Context)\n{\n\tPTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;\n\tPDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;\n\tPEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;\n\tBOOL bDevice;\n\n\t/* Set thread priority to lowest realtime level. */\n\tKeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);\n\n\tDump (\"Mount THREAD OPENING VOLUME BEGIN\\n\");\n\n\tif ( !IsDeviceName (pThreadBlock->mount->wszVolume))\n\t{\n\t\tRtlStringCbCopyW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),WIDE (\"\\\\??\\\\\"));\n\t\tRtlStringCbCatW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),pThreadBlock->mount->wszVolume);\n\t\tbDevice = FALSE;\n\t}\n\telse\n\t{\n\t\tpThreadBlock->wszMountVolume[0] = 0;\n\t\tRtlStringCbCatW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),pThreadBlock->mount->wszVolume);\n\t\tbDevice = TRUE;\n\t}\n\n\tDump (\"Mount THREAD request for File %ls DriveNumber %d Device = %d\\n\",\n\t      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);\n\n\tpThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,\n\t\tExtension,\n\t\tpThreadBlock->mount,\n\t\tpThreadBlock->wszMountVolume,\n\t\tbDevice);\n\n\tif (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)\n\t{\n\t\tKeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n\t\tPsTerminateSystemThread (STATUS_SUCCESS);\n\t}\n\n\t// Start IO queue\n\tExtension->Queue.IsFilterDevice = FALSE;\n\tExtension->Queue.DeviceObject = DeviceObject;\n\tExtension->Queue.CryptoInfo = Extension->cryptoInfo;\n\tExtension->Queue.HostFileHandle = Extension->hDeviceFile;\n\tExtension->Queue.VirtualDeviceLength = Extension->DiskLength;\n\tExtension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;\n\n\tif (Extension->SecurityClientContextValid)\n\t\tExtension->Queue.SecurityClientContext = &Extension->SecurityClientContext;\n\telse\n\t\tExtension->Queue.SecurityClientContext = NULL;\n\n\tpThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);\n\n\tif (!NT_SUCCESS (pThreadBlock->ntCreateStatus))\n\t{\n\t\tTCCloseVolume (DeviceObject, Extension);\n\n\t\tpThreadBlock->mount->nReturnCode = ERR_OS_ERROR;\n\t\tKeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n\t\tPsTerminateSystemThread (STATUS_SUCCESS);\n\t}\n\n\tKeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n\t/* From this point on pThreadBlock cannot be used as it will have been released! */\n\tpThreadBlock = NULL;\n\n\tfor (;;)\n\t{\n\t\t/* Wait for a request from the dispatch routines. */\n\t\tKeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);\n\n\t\tfor (;;)\n\t\t{\n\t\t\tPIO_STACK_LOCATION irpSp;\n\t\t\tPLIST_ENTRY request;\n\t\t\tPIRP irp;\n\n\t\t\trequest = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);\n\t\t\tif (request == NULL)\n\t\t\t\tbreak;\n\n\t\t\tirp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);\n\t\t\tirpSp = IoGetCurrentIrpStackLocation (irp);\n\n\t\t\tASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);\n\n\t\t\tProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);\n\t\t\tIoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);\n\t\t}\n\n\t\tif (Extension->bThreadShouldQuit)\n\t\t{\n\t\t\tDump (\"Closing volume\\n\");\n\t\t\tEncryptedIoQueueStop (&Extension->Queue);\n\n\t\t\tTCCloseVolume (DeviceObject, Extension);\n\t\t\tPsTerminateSystemThread (STATUS_SUCCESS);\n\t\t}\n\t}\n}\n\nvoid TCGetNTNameFromNumber (LPWSTR ntname, int cbNtName, int nDriveNo)\n{\n\tWCHAR tmp[2] =\n\t{0, 0};\n\tint j = nDriveNo + (WCHAR) 'A';\n\n\ttmp[0] = (short) j;\n\tRtlStringCbCopyW (ntname, cbNtName,(LPWSTR) NT_MOUNT_PREFIX);\n\tRtlStringCbCatW (ntname, cbNtName, tmp);\n}\n\nvoid TCGetDosNameFromNumber (LPWSTR dosname,int cbDosName, int nDriveNo, DeviceNamespaceType namespaceType)\n{\n\tWCHAR tmp[3] =\n\t{0, ':', 0};\n\tint j = nDriveNo + (WCHAR) 'A';\n\n\ttmp[0] = (short) j;\n\n\tif (DeviceNamespaceGlobal == namespaceType)\n\t{\n\t\tRtlStringCbCopyW (dosname, cbDosName, (LPWSTR) DOS_MOUNT_PREFIX_GLOBAL);\n\t}\n\telse\n\t{\n\t\tRtlStringCbCopyW (dosname, cbDosName, (LPWSTR) DOS_MOUNT_PREFIX_DEFAULT);\n\t}\n\n\tRtlStringCbCatW (dosname, cbDosName, tmp);\n}\n\n#if defined(_DEBUG) || defined (_DEBUG_TRACE)\nLPWSTR TCTranslateCode (ULONG ulCode)\n{\n\tswitch (ulCode)\n\t{\n#define TC_CASE_RET_NAME(CODE) case CODE : return L###CODE\n\n\t\tTC_CASE_RET_NAME (TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_BOOT_ENCRYPTION_SETUP);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_ALL_VOLUMES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_VOLUME);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_LOADER_VERSION);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DEVICE_REFCOUNT);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_GEOMETRY);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_PARTITION_INFO);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DRIVER_VERSION);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_MOUNTED_VOLUMES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_PASSWORD_CACHE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_PORTABLE_MODE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_SET_PORTABLE_MODE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_RESOLVED_SYMLINK);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_VOLUME_PROPERTIES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_WARNING_FLAGS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_DISK_IS_WRITABLE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_IS_ANY_VOLUME_MOUNTED);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_MOUNT_VOLUME);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_OPEN_TEST);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_PROBE_REAL_DRIVE_SIZE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_REREAD_DRIVER_CONFIG);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_START_DECOY_SYSTEM_WIPE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_WIPE_PASSWORD_CACHE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR);\n\t\tTC_CASE_RET_NAME (VC_IOCTL_GET_DRIVE_GEOMETRY_EX);\n\n\t\tTC_CASE_RET_NAME (IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS);\n\n#undef TC_CASE_RET_NAME\n\t}\n\n\tif (ulCode ==\t\t\t IOCTL_DISK_GET_DRIVE_GEOMETRY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_GEOMETRY\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_DRIVE_GEOMETRY_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_GEOMETRY_EX\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_QUERY_DEVICE_NAME)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_DEVICE_NAME\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_QUERY_UNIQUE_ID)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_UNIQUE_ID\");\n\telse if (ulCode ==\t\t IOCTL_VOLUME_ONLINE)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_ONLINE\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_LINK_CREATED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_LINK_CREATED\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_LINK_DELETED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_LINK_DELETED\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTMGR_QUERY_POINTS)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTMGR_QUERY_POINTS\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_LENGTH_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_LENGTH_INFO\");\n\telse if (ulCode ==\t\t IOCTL_STORAGE_GET_DEVICE_NUMBER)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_GET_DEVICE_NUMBER\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_PARTITION_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_PARTITION_INFO\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_PARTITION_INFO_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_PARTITION_INFO_EX\");\n\telse if (ulCode ==\t\t IOCTL_DISK_SET_PARTITION_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_SET_PARTITION_INFO\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_DRIVE_LAYOUT)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_LAYOUT\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_DRIVE_LAYOUT_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_LAYOUT_EX\");\n\telse if (ulCode ==\t\t IOCTL_DISK_SET_DRIVE_LAYOUT_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_SET_DRIVE_LAYOUT_EX\");\n\telse if (ulCode ==\t\t IOCTL_DISK_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_FORMAT_TRACKS)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_FORMAT_TRACKS\");\n\telse if (ulCode == IOCTL_DISK_REASSIGN_BLOCKS)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_REASSIGN_BLOCKS\");\n\telse if (ulCode == IOCTL_DISK_PERFORMANCE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_PERFORMANCE\");\n\telse if (ulCode == IOCTL_DISK_IS_WRITABLE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_IS_WRITABLE\");\n\telse if (ulCode == IOCTL_DISK_LOGGING)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_LOGGING\");\n\telse if (ulCode == IOCTL_DISK_FORMAT_TRACKS_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_FORMAT_TRACKS_EX\");\n\telse if (ulCode == IOCTL_DISK_HISTOGRAM_STRUCTURE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_HISTOGRAM_STRUCTURE\");\n\telse if (ulCode == IOCTL_DISK_HISTOGRAM_DATA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_HISTOGRAM_DATA\");\n\telse if (ulCode == IOCTL_DISK_HISTOGRAM_RESET)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_HISTOGRAM_RESET\");\n\telse if (ulCode == IOCTL_DISK_REQUEST_STRUCTURE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_REQUEST_STRUCTURE\");\n\telse if (ulCode == IOCTL_DISK_REQUEST_DATA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_REQUEST_DATA\");\n\telse if (ulCode == IOCTL_DISK_CONTROLLER_NUMBER)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_CONTROLLER_NUMBER\");\n\telse if (ulCode == SMART_GET_VERSION)\n\t\treturn (LPWSTR) _T (\"SMART_GET_VERSION\");\n\telse if (ulCode == SMART_SEND_DRIVE_COMMAND)\n\t\treturn (LPWSTR) _T (\"SMART_SEND_DRIVE_COMMAND\");\n\telse if (ulCode == SMART_RCV_DRIVE_DATA)\n\t\treturn (LPWSTR) _T (\"SMART_RCV_DRIVE_DATA\");\n\telse if (ulCode == IOCTL_DISK_INTERNAL_SET_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_INTERNAL_SET_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_INTERNAL_CLEAR_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_INTERNAL_CLEAR_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_CHECK_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_CHECK_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_MEDIA_REMOVAL)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_MEDIA_REMOVAL\");\n\telse if (ulCode == IOCTL_DISK_EJECT_MEDIA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_EJECT_MEDIA\");\n\telse if (ulCode == IOCTL_DISK_LOAD_MEDIA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_LOAD_MEDIA\");\n\telse if (ulCode == IOCTL_DISK_RESERVE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_RESERVE\");\n\telse if (ulCode == IOCTL_DISK_RELEASE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_RELEASE\");\n\telse if (ulCode == IOCTL_DISK_FIND_NEW_DEVICES)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_FIND_NEW_DEVICES\");\n\telse if (ulCode == IOCTL_DISK_GET_MEDIA_TYPES)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_MEDIA_TYPES\");\n\telse if (ulCode == IOCTL_DISK_IS_CLUSTERED)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_IS_CLUSTERED\");\t\n\telse if (ulCode == IOCTL_DISK_UPDATE_DRIVE_SIZE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_UPDATE_DRIVE_SIZE\");\n\telse if (ulCode == IOCTL_STORAGE_GET_MEDIA_TYPES)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_GET_MEDIA_TYPES\");\n\telse if (ulCode == IOCTL_STORAGE_GET_HOTPLUG_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_GET_HOTPLUG_INFO\");\n\telse if (ulCode == IOCTL_STORAGE_SET_HOTPLUG_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_SET_HOTPLUG_INFO\");\n\telse if (ulCode == IOCTL_STORAGE_QUERY_PROPERTY)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_QUERY_PROPERTY\");\n\telse if (ulCode == IOCTL_VOLUME_GET_GPT_ATTRIBUTES)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_GET_GPT_ATTRIBUTES\");\t\n\telse if (ulCode == FT_BALANCED_READ_MODE)\n\t\treturn (LPWSTR) _T (\"FT_BALANCED_READ_MODE\");\n\telse if (ulCode == IOCTL_VOLUME_QUERY_ALLOCATION_HINT)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_QUERY_ALLOCATION_HINT\");\n\telse if (ulCode == IOCTL_DISK_GET_CLUSTER_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_CLUSTER_INFO\");\n\telse if (ulCode == IOCTL_DISK_ARE_VOLUMES_READY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_ARE_VOLUMES_READY\");\t\t\t\n\telse if (ulCode == IOCTL_VOLUME_IS_DYNAMIC)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_IS_DYNAMIC\");\n\telse if (ulCode == IOCTL_MOUNTDEV_QUERY_STABLE_GUID)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_STABLE_GUID\");\n\telse if (ulCode == IOCTL_VOLUME_POST_ONLINE)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_POST_ONLINE\");\n\telse if (ulCode == IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT\");\n\telse if (ulCode == IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES\");\n\telse if (ulCode == IRP_MJ_READ)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_READ\");\n\telse if (ulCode == IRP_MJ_WRITE)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_WRITE\");\n\telse if (ulCode == IRP_MJ_CREATE)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_CREATE\");\n\telse if (ulCode == IRP_MJ_CLOSE)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_CLOSE\");\n\telse if (ulCode == IRP_MJ_CLEANUP)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_CLEANUP\");\n\telse if (ulCode == IRP_MJ_FLUSH_BUFFERS)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_FLUSH_BUFFERS\");\n\telse if (ulCode == IRP_MJ_SHUTDOWN)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_SHUTDOWN\");\n\telse if (ulCode == IRP_MJ_DEVICE_CONTROL)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_DEVICE_CONTROL\");\n\telse\n\t{\n\t\treturn (LPWSTR) _T (\"IOCTL\");\n\t}\n}\n\n#endif\n\nvoid TCDeleteDeviceObject (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension)\n{\n\tUNICODE_STRING Win32NameString;\n\tNTSTATUS ntStatus;\n\n\tDump (\"TCDeleteDeviceObject BEGIN\\n\");\n\n\tif (Extension->bRootDevice)\n\t{\n\t\tRtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);\n\t\tntStatus = IoDeleteSymbolicLink (&Win32NameString);\n\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\tDump (\"IoDeleteSymbolicLink failed ntStatus = 0x%08x\\n\", ntStatus);\n\n\t\tRootDeviceObject = NULL;\n\t}\n\telse\n\t{\n\t\tif (Extension->peThread != NULL)\n\t\t\tTCStopVolumeThread (DeviceObject, Extension);\n\n\t\tif (Extension->UserSid)\n\t\t\tTCfree (Extension->UserSid);\n\n\t\tif (Extension->SecurityClientContextValid)\n\t\t{\n\t\t\tif (OsMajorVersion == 5 && OsMinorVersion == 0)\n\t\t\t{\n\t\t\t\tObDereferenceObject (Extension->SecurityClientContext.ClientToken);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().\n\t\t\t\t// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.\n\n\t\t\t\tVOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);\n\t\t\t\tUNICODE_STRING name;\n\t\t\t\tRtlInitUnicodeString (&name, L\"PsDereferenceImpersonationToken\");\n\n\t\t\t\tPsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);\n\t\t\t\tif (!PsDereferenceImpersonationTokenD)\n\t\t\t\t\tTC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);\n\n#\t\t\t\tdefine PsDereferencePrimaryToken\n#\t\t\t\tdefine PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD\n\n\t\t\t\tSeDeleteClientSecurity (&Extension->SecurityClientContext);\n\n#\t\t\t\tundef PsDereferencePrimaryToken\n#\t\t\t\tundef PsDereferenceImpersonationToken\n\t\t\t}\n\t\t}\n\n\t\tVirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;\n\t}\n\n\tIoDeleteDevice (DeviceObject);\n\n\tDump (\"TCDeleteDeviceObject END\\n\");\n}\n\n\nVOID TCUnloadDriver (PDRIVER_OBJECT DriverObject)\n{\n\tDump (\"TCUnloadDriver BEGIN\\n\");\n\n\tOnShutdownPending();\n\n\tif (IsBootDriveMounted())\n\t\tTC_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);\n\n\tEncryptionThreadPoolStop();\n\tTCDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);\n\n\tDump (\"TCUnloadDriver END\\n\");\n}\n\n\nvoid OnShutdownPending ()\n{\n\tUNMOUNT_STRUCT unmount;\n\tmemset (&unmount, 0, sizeof (unmount));\n\tunmount.ignoreOpenFiles = TRUE;\n\n\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)\n\t\tunmount.HiddenVolumeProtectionTriggered = FALSE;\n\n\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);\n}\n\n\nNTSTATUS TCDeviceIoControl (PWSTR deviceName, ULONG IoControlCode, void *InputBuffer, ULONG InputBufferSize, void *OutputBuffer, ULONG OutputBufferSize)\n{\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tNTSTATUS ntStatus;\n\tPIRP irp;\n\tPFILE_OBJECT fileObject;\n\tPDEVICE_OBJECT deviceObject;\n\tKEVENT event;\n\tUNICODE_STRING name;\n\n\tRtlInitUnicodeString(&name, deviceName);\n\tntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\treturn ntStatus;\n\n\tKeInitializeEvent(&event, NotificationEvent, FALSE);\n\n\tirp = IoBuildDeviceIoControlRequest (IoControlCode,\n\t\t\t\t\t     deviceObject,\n\t\t\t\t\t     InputBuffer, InputBufferSize,\n\t\t\t\t\t     OutputBuffer, OutputBufferSize,\n\t\t\t\t\t     FALSE,\n\t\t\t\t\t     &event,\n\t\t\t\t\t     &ioStatusBlock);\n\n\tif (irp == NULL)\n\t{\n\t\tDump (\"IRP allocation failed\\n\");\n\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\tgoto ret;\n\t}\n\n\tIoGetNextIrpStackLocation (irp)->FileObject = fileObject;\n\n\tntStatus = IoCallDriver (deviceObject, irp);\n\tif (ntStatus == STATUS_PENDING)\n\t{\n\t\tKeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);\n\t\tntStatus = ioStatusBlock.Status;\n\t}\n\nret:\n\tObDereferenceObject (fileObject);\n\treturn ntStatus;\n}\n\n\ntypedef struct\n{\n\tPDEVICE_OBJECT deviceObject; ULONG ioControlCode; void *inputBuffer; int inputBufferSize; void *outputBuffer; int outputBufferSize;\n\tNTSTATUS Status;\n\tKEVENT WorkItemCompletedEvent;\n} SendDeviceIoControlRequestWorkItemArgs;\n\n\nstatic VOID SendDeviceIoControlRequestWorkItemRoutine (PDEVICE_OBJECT rootDeviceObject, SendDeviceIoControlRequestWorkItemArgs *arg)\n{\n\targ->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);\n\tKeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);\n}\n\n\nNTSTATUS SendDeviceIoControlRequest (PDEVICE_OBJECT deviceObject, ULONG ioControlCode, void *inputBuffer, int inputBufferSize, void *outputBuffer, int outputBufferSize)\n{\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tNTSTATUS status;\n\tPIRP irp;\n\tKEVENT event;\n\n\tif (KeGetCurrentIrql() > APC_LEVEL)\n\t{\n\t\tSendDeviceIoControlRequestWorkItemArgs args;\n\n\t\tPIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);\n\t\tif (!workItem)\n\t\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\t\targs.deviceObject = deviceObject;\n\t\targs.ioControlCode = ioControlCode;\n\t\targs.inputBuffer = inputBuffer;\n\t\targs.inputBufferSize = inputBufferSize;\n\t\targs.outputBuffer = outputBuffer;\n\t\targs.outputBufferSize = outputBufferSize;\n\n\t\tKeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);\n\t\tIoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args);\n\n\t\tKeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);\n\t\tIoFreeWorkItem (workItem);\n\n\t\treturn args.Status;\n\t}\n\n\tKeInitializeEvent (&event, NotificationEvent, FALSE);\n\n\tirp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,\n\t\toutputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);\n\n\tif (!irp)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tObReferenceObject (deviceObject);\n\n\tstatus = IoCallDriver (deviceObject, irp);\n\tif (status == STATUS_PENDING)\n\t{\n\t\tKeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);\n\t\tstatus = ioStatusBlock.Status;\n\t}\n\n\tObDereferenceObject (deviceObject);\n\treturn status;\n}\n\n\nNTSTATUS ProbeRealDriveSize (PDEVICE_OBJECT driveDeviceObject, LARGE_INTEGER *driveSize)\n{\n\tNTSTATUS status;\n\tLARGE_INTEGER sysLength;\n\tLARGE_INTEGER offset;\n\tbyte *sectorBuffer;\n\tULONGLONG startTime;\n\n\tif (!UserCanAccessDriveDevice())\n\t\treturn STATUS_ACCESS_DENIED;\n\n\tsectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);\n\tif (!sectorBuffer)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tstatus = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,\n\t\tNULL, 0, &sysLength, sizeof (sysLength));\n\n\tif (!NT_SUCCESS (status))\n\t{\n\t\tDump (\"Failed to get drive size - error %x\\n\", status);\n\t\tTCfree (sectorBuffer);\n\t\treturn status;\n\t}\n\n\tstartTime = KeQueryInterruptTime ();\n\tfor (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)\n\t{\n\t\tstatus = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);\n\n\t\tif (NT_SUCCESS (status))\n\t\t\tstatus = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);\n\n\t\tif (!NT_SUCCESS (status))\n\t\t{\n\t\t\tdriveSize->QuadPart = offset.QuadPart;\n\t\t\tDump (\"Real drive size = %I64d bytes (%I64d hidden)\\n\", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);\n\t\t\tTCfree (sectorBuffer);\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\n\t\tif (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)\n\t\t{\n\t\t\t// Abort if probing for more than 3 minutes\n\t\t\tdriveSize->QuadPart = sysLength.QuadPart;\n\t\t\tTCfree (sectorBuffer);\n\t\t\treturn STATUS_TIMEOUT;\n\t\t}\n\t}\n}\n\n\nNTSTATUS TCOpenFsVolume (PEXTENSION Extension, PHANDLE volumeHandle, PFILE_OBJECT * fileObject)\n{\n\tNTSTATUS ntStatus;\n\tOBJECT_ATTRIBUTES objectAttributes;\n\tUNICODE_STRING fullFileName;\n\tIO_STATUS_BLOCK ioStatus;\n\tWCHAR volumeName[TC_MAX_PATH];\n\n\tTCGetNTNameFromNumber (volumeName, sizeof(volumeName),Extension->nDosDriveNo);\n\tRtlInitUnicodeString (&fullFileName, volumeName);\n\tInitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tntStatus = ZwCreateFile (volumeHandle,\n\t\tSYNCHRONIZE | GENERIC_READ,\n\t\t&objectAttributes,\n\t\t&ioStatus,\n\t\tNULL,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE,\n\t\tFILE_OPEN,\n\t\tFILE_SYNCHRONOUS_IO_NONALERT,\n\t\tNULL,\n\t\t0);\n\n\tDump (\"Volume %ls open NTSTATUS 0x%08x\\n\", volumeName, ntStatus);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\treturn ntStatus;\n\n\tntStatus = ObReferenceObjectByHandle (*volumeHandle,\n\t\tFILE_READ_DATA,\n\t\tNULL,\n\t\tKernelMode,\n\t\tfileObject,\n\t\tNULL);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\tZwClose (*volumeHandle);\n\n\treturn ntStatus;\n}\n\n\nvoid TCCloseFsVolume (HANDLE volumeHandle, PFILE_OBJECT fileObject)\n{\n\tObDereferenceObject (fileObject);\n\tZwClose (volumeHandle);\n}\n\n\nstatic NTSTATUS TCReadWriteDevice (BOOL write, PDEVICE_OBJECT deviceObject, PVOID buffer, LARGE_INTEGER offset, ULONG length)\n{\n\tNTSTATUS status;\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tPIRP irp;\n\tKEVENT completionEvent;\n\n\tASSERT (KeGetCurrentIrql() <= APC_LEVEL);\n\n\tKeInitializeEvent (&completionEvent, NotificationEvent, FALSE);\n\tirp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);\n\tif (!irp)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tObReferenceObject (deviceObject);\n\tstatus = IoCallDriver (deviceObject, irp);\n\n\tif (status == STATUS_PENDING)\n\t{\n\t\tstatus = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);\n\t\tif (NT_SUCCESS (status))\n\t\t\tstatus = ioStatusBlock.Status;\n\t}\n\n\tObDereferenceObject (deviceObject);\n\treturn status;\n}\n\n\nNTSTATUS TCReadDevice (PDEVICE_OBJECT deviceObject, PVOID buffer, LARGE_INTEGER offset, ULONG length)\n{\n\treturn TCReadWriteDevice (FALSE, deviceObject, buffer, offset, length);\n}\n\n\nNTSTATUS TCWriteDevice (PDEVICE_OBJECT deviceObject, PVOID buffer, LARGE_INTEGER offset, ULONG length)\n{\n\treturn TCReadWriteDevice (TRUE, deviceObject, buffer, offset, length);\n}\n\n\nNTSTATUS TCFsctlCall (PFILE_OBJECT fileObject, LONG IoControlCode,\n\tvoid *InputBuffer, int InputBufferSize, void *OutputBuffer, int OutputBufferSize)\n{\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tNTSTATUS ntStatus;\n\tPIRP irp;\n\tKEVENT event;\n\tPIO_STACK_LOCATION stack;\n\tPDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);\n\n\tKeInitializeEvent(&event, NotificationEvent, FALSE);\n\n\tirp = IoBuildDeviceIoControlRequest (IoControlCode,\n\t\t\t\t\t     deviceObject,\n\t\t\t\t\t     InputBuffer, InputBufferSize,\n\t\t\t\t\t     OutputBuffer, OutputBufferSize,\n\t\t\t\t\t     FALSE,\n\t\t\t\t\t     &event,\n\t\t\t\t\t     &ioStatusBlock);\n\n\tif (irp == NULL)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tstack = IoGetNextIrpStackLocation(irp);\n\n\tstack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;\n\tstack->MinorFunction = IRP_MN_USER_FS_REQUEST;\n\tstack->FileObject = fileObject;\n\n\tntStatus = IoCallDriver (deviceObject, irp);\n\tif (ntStatus == STATUS_PENDING)\n\t{\n\t\tKeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);\n\t\tntStatus = ioStatusBlock.Status;\n\t}\n\n\treturn ntStatus;\n}\n\n\nNTSTATUS CreateDriveLink (int nDosDriveNo)\n{\n\tWCHAR dev[128], link[128];\n\tUNICODE_STRING deviceName, symLink;\n\tNTSTATUS ntStatus;\n\n\tTCGetNTNameFromNumber (dev, sizeof(dev),nDosDriveNo);\n\tTCGetDosNameFromNumber (link, sizeof(link),nDosDriveNo, DeviceNamespaceDefault);\n\n\tRtlInitUnicodeString (&deviceName, dev);\n\tRtlInitUnicodeString (&symLink, link);\n\n\tntStatus = IoCreateSymbolicLink (&symLink, &deviceName);\n\tDump (\"IoCreateSymbolicLink returned %X\\n\", ntStatus);\n\treturn ntStatus;\n}\n\n\nNTSTATUS RemoveDriveLink (int nDosDriveNo)\n{\n\tWCHAR link[256];\n\tUNICODE_STRING symLink;\n\tNTSTATUS ntStatus;\n\n\tTCGetDosNameFromNumber (link, sizeof(link),nDosDriveNo, DeviceNamespaceDefault);\n\tRtlInitUnicodeString (&symLink, link);\n\n\tntStatus = IoDeleteSymbolicLink (&symLink);\n\tDump (\"IoDeleteSymbolicLink returned %X\\n\", ntStatus);\n\treturn ntStatus;\n}\n\n\nNTSTATUS MountManagerMount (MOUNT_STRUCT *mount)\n{\n\tNTSTATUS ntStatus;\n\tWCHAR arrVolume[256];\n\tchar buf[200];\n\tPMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;\n\tPMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;\n\n\tTCGetNTNameFromNumber (arrVolume, sizeof(arrVolume),mount->nDosDriveNo);\n\tin->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;\n\tRtlStringCbCopyW(in->DeviceName, sizeof(buf) - sizeof(in->DeviceNameLength),arrVolume);\n\n\tntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,\n\t\tin, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);\n\n\tmemset (buf, 0, sizeof buf);\n\tTCGetDosNameFromNumber ((PWSTR) &point[1], sizeof(buf) - sizeof(MOUNTMGR_CREATE_POINT_INPUT),mount->nDosDriveNo, DeviceNamespaceDefault);\n\n\tpoint->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);\n\tpoint->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;\n\n\tpoint->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;\n\tTCGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), sizeof(buf) - point->DeviceNameOffset,mount->nDosDriveNo);\n\tpoint->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;\n\n\tntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,\n\t\t\tpoint->DeviceNameOffset + point->DeviceNameLength, 0, 0);\n\n\treturn ntStatus;\n}\n\n\nNTSTATUS MountManagerUnmount (int nDosDriveNo)\n{\n\tNTSTATUS ntStatus;\n\tchar buf[256], out[300];\n\tPMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;\n\n\tmemset (buf, 0, sizeof buf);\n\n\tTCGetDosNameFromNumber ((PWSTR) &in[1], sizeof(buf) - sizeof(MOUNTMGR_MOUNT_POINT),nDosDriveNo, DeviceNamespaceDefault);\n\n\t// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.\n\tin->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);\n\tin->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;\n\n\tntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,\n\t\tin, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);\n\n\tDump (\"IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\\n\", ntStatus);\n\n\treturn ntStatus;\n}\n\n\nNTSTATUS MountDevice (PDEVICE_OBJECT DeviceObject, MOUNT_STRUCT *mount)\n{\n\tPDEVICE_OBJECT NewDeviceObject;\n\tNTSTATUS ntStatus;\n\n\t// Make sure the user is asking for a reasonable nDosDriveNo\n\tif (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25\n\t\t&& IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceDefault) // drive letter must not exist both locally and globally\n\t\t&& IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceGlobal)\n\t\t)\n\t{\n\t\tDump (\"Mount request looks valid\\n\");\n\t}\n\telse\n\t{\n\t\tDump (\"WARNING: MOUNT DRIVE LETTER INVALID\\n\");\n\t\tmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\t\treturn ERR_DRIVE_NOT_FOUND;\n\t}\n\n\tif (!SelfTestsPassed)\n\t{\n\t\tDump (\"Failure of built-in automatic self-tests! Mounting not allowed.\\n\");\n\t\tmount->nReturnCode = ERR_SELF_TESTS_FAILED;\n\t\treturn ERR_SELF_TESTS_FAILED;\n\t}\n\n\tntStatus = TCCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\\n\", ntStatus);\n\t\treturn ntStatus;\n\t}\n\telse\n\t{\n\t\tPEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;\n\t\tSECURITY_SUBJECT_CONTEXT subContext;\n\t\tPACCESS_TOKEN accessToken;\n\n\t\tSeCaptureSubjectContext (&subContext);\n\t\tSeLockSubjectContext(&subContext);\n\t\tif (subContext.ClientToken && subContext.ImpersonationLevel >= SecurityImpersonation)\n\t\t\taccessToken = subContext.ClientToken;\n\t\telse\n\t\t\taccessToken = subContext.PrimaryToken;\n\n\t\tif (!accessToken)\n\t\t{\n\t\t\tntStatus = STATUS_INVALID_PARAMETER;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPTOKEN_USER tokenUser;\n\n\t\t\tntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\tULONG sidLength = RtlLengthSid (tokenUser->User.Sid);\n\n\t\t\t\tNewExtension->UserSid = TCalloc (sidLength);\n\t\t\t\tif (!NewExtension->UserSid)\n\t\t\t\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\telse\n\t\t\t\t\tntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);\n\n\t\t\t\tExFreePool (tokenUser);\t\t// Documented in newer versions of WDK\n\t\t\t}\n\t\t}\n\n\t\tSeUnlockSubjectContext(&subContext);\n\t\tSeReleaseSubjectContext (&subContext);\n\n\t\tif (NT_SUCCESS (ntStatus))\n\t\t\tntStatus = TCStartVolumeThread (NewDeviceObject, NewExtension, mount);\n\n\t\tif (!NT_SUCCESS (ntStatus))\n\t\t{\n\t\t\tDump (\"Mount FAILURE NT ERROR, ntStatus = 0x%08x\\n\", ntStatus);\n\t\t\tTCDeleteDeviceObject (NewDeviceObject, NewExtension);\n\t\t\treturn ntStatus;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mount->nReturnCode == 0)\n\t\t\t{\n\t\t\t\tHANDLE volumeHandle;\n\t\t\t\tPFILE_OBJECT volumeFileObject;\n\t\t\t\tULONG labelLen = (ULONG) wcslen (mount->wszLabel);\n\t\t\t\tBOOL bIsNTFS = FALSE;\n\t\t\t\tULONG labelMaxLen, labelEffectiveLen;\n\n\t\t\t\tDump (\"Mount SUCCESS TC code = 0x%08x READ-ONLY = %d\\n\", mount->nReturnCode, NewExtension->bReadOnly);\n\n\t\t\t\tif (NewExtension->bReadOnly)\n\t\t\t\t\tNewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;\n\n\t\t\t\tNewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;\n\n\t\t\t\tNewExtension->UniqueVolumeId = LastUniqueVolumeId++;\n\n\t\t\t\t// check again that the drive letter is available globally and locally\n\t\t\t\tif (\t!IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceDefault)\n\t\t\t\t\t|| !IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceGlobal)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t\tTCDeleteDeviceObject (NewDeviceObject, NewExtension);\n\t\t\t\t\t\tmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\t\t\t\t\t\treturn ERR_DRIVE_NOT_FOUND;\n\t\t\t\t}\n\n\t\t\t\tif (mount->bMountManager)\n\t\t\t\t\tMountManagerMount (mount);\n\n\t\t\t\tNewExtension->bMountManager = mount->bMountManager;\n\n\t\t\t\t// We create symbolic link even if mount manager is notified of\n\t\t\t\t// arriving volume as it apparently sometimes fails to create the link\n\t\t\t\tCreateDriveLink (mount->nDosDriveNo);\n\n\t\t\t\tmount->FilesystemDirty = FALSE;\n\n\t\t\t\tif (NT_SUCCESS (TCOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))\n\t\t\t\t{\n\t\t\t\t\t__try\n\t\t\t\t\t{\n\t\t\t\t\t\tULONG fsStatus;\n\n\t\t\t\t\t\tif (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))\n\t\t\t\t\t\t\t&& (fsStatus & VOLUME_IS_DIRTY))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmount->FilesystemDirty = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t\t\t\t{\n\t\t\t\t\t\tmount->FilesystemDirty = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// detect if the filesystem is NTFS or FAT\n\t\t\t\t\t__try\n\t\t\t\t\t{\n\t\t\t\t\t\tNTFS_VOLUME_DATA_BUFFER ntfsData;\n\t\t\t\t\t\tif (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbIsNTFS = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t\t\t\t{\n\t\t\t\t\t\tbIsNTFS = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tNewExtension->bIsNTFS = bIsNTFS;\n\t\t\t\t\tmount->bIsNTFS = bIsNTFS;\n\n\t\t\t\t\tif (labelLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (bIsNTFS)\n\t\t\t\t\t\t\tlabelMaxLen = 32; // NTFS maximum label length\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlabelMaxLen = 11; // FAT maximum label length\n\n\t\t\t\t\t\t// calculate label effective length\n\t\t\t\t\t\tlabelEffectiveLen = labelLen > labelMaxLen? labelMaxLen : labelLen;\n\n\t\t\t\t\t\t// correct the label in the device\n\t\t\t\t\t\tmemset (&NewExtension->wszLabel[labelEffectiveLen], 0, 33 - labelEffectiveLen);\n\t\t\t\t\t\tmemcpy (mount->wszLabel, NewExtension->wszLabel, 33);\n\n\t\t\t\t\t\t// set the volume label\n\t\t\t\t\t\t__try\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIO_STATUS_BLOCK ioblock;\n\t\t\t\t\t\t\tULONG labelInfoSize = sizeof(FILE_FS_LABEL_INFORMATION) + (labelEffectiveLen * sizeof(WCHAR));\n\t\t\t\t\t\t\tFILE_FS_LABEL_INFORMATION* labelInfo = (FILE_FS_LABEL_INFORMATION*) TCalloc (labelInfoSize);\n\t\t\t\t\t\t\tif (labelInfo)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlabelInfo->VolumeLabelLength = labelEffectiveLen * sizeof(WCHAR);\n\t\t\t\t\t\t\t\tmemcpy (labelInfo->VolumeLabel, mount->wszLabel, labelInfo->VolumeLabelLength);\n\n\t\t\t\t\t\t\t\tif (STATUS_SUCCESS == ZwSetVolumeInformationFile (volumeHandle, &ioblock, labelInfo, labelInfoSize, FileFsLabelInformation))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmount->bDriverSetLabel = TRUE;\n\t\t\t\t\t\t\t\t\tNewExtension->bDriverSetLabel = TRUE;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tTCfree(labelInfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDump (\"Mount FAILURE TC code = 0x%08x\\n\", mount->nReturnCode);\n\t\t\t\tTCDeleteDeviceObject (NewDeviceObject, NewExtension);\n\t\t\t}\n\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\t}\n}\n\nNTSTATUS UnmountDevice (UNMOUNT_STRUCT *unmountRequest, PDEVICE_OBJECT deviceObject, BOOL ignoreOpenFiles)\n{\n\tPEXTENSION extension = deviceObject->DeviceExtension;\n\tNTSTATUS ntStatus;\n\tHANDLE volumeHandle;\n\tPFILE_OBJECT volumeFileObject;\n\n\tDump (\"UnmountDevice %d\\n\", extension->nDosDriveNo);\n\n\tntStatus = TCOpenFsVolume (extension, &volumeHandle, &volumeFileObject);\n\n\tif (NT_SUCCESS (ntStatus))\n\t{\n\t\tint dismountRetry;\n\n\t\t// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7\n\t\tif (IsOSAtLeast (WIN_7) && !extension->bReadOnly)\n\t\t{\n\t\t\tNTFS_VOLUME_DATA_BUFFER ntfsData;\n\n\t\t\tif (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))\n\t\t\t\tDriverUnloadDisabled = TRUE;\n\t\t}\n\n\t\t// Lock volume\n\t\tntStatus = TCFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);\n\t\tDump (\"FSCTL_LOCK_VOLUME returned %X\\n\", ntStatus);\n\n\t\tif (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)\n\t\t{\n\t\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\t\t\treturn ERR_FILES_OPEN;\n\t\t}\n\n\t\t// Dismount volume\n\t\tfor (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)\n\t\t{\n\t\t\tntStatus = TCFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);\n\t\t\tDump (\"FSCTL_DISMOUNT_VOLUME returned %X\\n\", ntStatus);\n\n\t\t\tif (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)\n\t\t\t\tbreak;\n\n\t\t\tif (!ignoreOpenFiles)\n\t\t\t{\n\t\t\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\t\t\t\treturn ERR_FILES_OPEN;\n\t\t\t}\n\n\t\t\tTCSleep (100);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Volume cannot be opened => force dismount if allowed\n\t\tif (!ignoreOpenFiles)\n\t\t\treturn ERR_FILES_OPEN;\n\t\telse\n\t\t\tvolumeHandle = NULL;\n\t}\n\n\tif (extension->bMountManager)\n\t\tMountManagerUnmount (extension->nDosDriveNo);\n\n\t// We always remove symbolic link as mount manager might fail to do so\n\tRemoveDriveLink (extension->nDosDriveNo);\n\n\textension->bShuttingDown = TRUE;\n\n\tntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);\n\tASSERT (NT_SUCCESS (ntStatus));\n\tIoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);\n\n\tif (volumeHandle != NULL)\n\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\n\tif (unmountRequest)\n\t{\n\t\tPCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;\n\t\tunmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);\n\t}\n\n\tTCDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);\n\treturn 0;\n}\n\n\nstatic PDEVICE_OBJECT FindVolumeWithHighestUniqueId (int maxUniqueId)\n{\n\tPDEVICE_OBJECT highestIdDevice = NULL;\n\tint highestId = -1;\n\tint drive;\n\n\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t{\n\t\tPDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);\n\t\tif (device)\n\t\t{\n\t\t\tPEXTENSION extension = (PEXTENSION) device->DeviceExtension;\n\t\t\tif (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)\n\t\t\t{\n\t\t\t\thighestId = extension->UniqueVolumeId;\n\t\t\t\thighestIdDevice = device;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn highestIdDevice;\n}\n\n\nNTSTATUS UnmountAllDevices (UNMOUNT_STRUCT *unmountRequest, BOOL ignoreOpenFiles)\n{\n\tNTSTATUS status = 0;\n\tPDEVICE_OBJECT ListDevice;\n\tint maxUniqueId = LastUniqueVolumeId;\n\n\tDump (\"Unmounting all volumes\\n\");\n\n\tif (unmountRequest)\n\t\tunmountRequest->HiddenVolumeProtectionTriggered = FALSE;\n\n\t// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes\n\twhile ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)\n\t{\n\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\tmaxUniqueId = ListExtension->UniqueVolumeId - 1;\n\n\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t{\n\t\t\tNTSTATUS ntStatus;\n\n\t\t\tif (unmountRequest)\n\t\t\t\tunmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;\n\n\t\t\tntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);\n\t\t\tstatus = ntStatus == 0 ? status : ntStatus;\n\n\t\t\tif (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n// Resolves symbolic link name to its target name\nNTSTATUS SymbolicLinkToTarget (PWSTR symlinkName, PWSTR targetName, USHORT maxTargetNameLength)\n{\n\tNTSTATUS ntStatus;\n\tOBJECT_ATTRIBUTES objectAttributes;\n\tUNICODE_STRING fullFileName;\n\tHANDLE handle;\n\n\tRtlInitUnicodeString (&fullFileName, symlinkName);\n\tInitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n\tntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);\n\n\tif (NT_SUCCESS (ntStatus))\n\t{\n\t\tUNICODE_STRING target;\n\t\ttarget.Buffer = targetName;\n\t\ttarget.Length = 0;\n\t\ttarget.MaximumLength = maxTargetNameLength;\n\t\tmemset (targetName, 0, maxTargetNameLength);\n\n\t\tntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);\n\n\t\tZwClose (handle);\n\t}\n\n\treturn ntStatus;\n}\n\n\n// Checks if two regions overlap (borders are parts of regions)\nBOOL RegionsOverlap (unsigned __int64 start1, unsigned __int64 end1, unsigned __int64 start2, unsigned __int64 end2)\n{\n\treturn (start1 < start2) ? (end1 >= start2) : (start1 <= end2);\n}\n\n\nvoid GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)\n{\n\tuint64 end1 = start1 + length1 - 1;\n\tuint64 intersectEnd = (end1 <= end2) ? end1 : end2;\n\n\t*intersectStart = (start1 >= start2) ? start1 : start2;\n\t*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);\n\n\tif (*intersectLength == 0)\n\t\t*intersectStart = start1;\n}\n\n\nBOOL IsAccessibleByUser (PUNICODE_STRING objectFileName, BOOL readOnly)\n{\n\tOBJECT_ATTRIBUTES fileObjAttributes;\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tHANDLE fileHandle;\n\tNTSTATUS status;\n\n\tASSERT (!IoIsSystemThread (PsGetCurrentThread()));\n\n\tInitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tstatus = ZwCreateFile (&fileHandle,\n\t\treadOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,\n\t\t&fileObjAttributes,\n\t\t&ioStatusBlock,\n\t\tNULL,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n\t\tFILE_OPEN,\n\t\tFILE_SYNCHRONOUS_IO_NONALERT,\n\t\tNULL,\n\t\t0);\n\n\tif (NT_SUCCESS (status))\n\t{\n\t\tZwClose (fileHandle);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\n\nBOOL UserCanAccessDriveDevice ()\n{\n\tUNICODE_STRING name;\n\tRtlInitUnicodeString (&name, L\"\\\\Device\\\\MountPointManager\");\n\n\treturn IsAccessibleByUser (&name, FALSE);\n}\n\nBOOL IsDriveLetterAvailable (int nDosDriveNo, DeviceNamespaceType namespaceType)\n{\n\tOBJECT_ATTRIBUTES objectAttributes;\n\tUNICODE_STRING objectName;\n\tWCHAR link[128];\n\tHANDLE handle;\n\tNTSTATUS ntStatus;\n\n\tTCGetDosNameFromNumber (link, sizeof(link),nDosDriveNo, namespaceType);\n\tRtlInitUnicodeString (&objectName, link);\n\tInitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n\tif (NT_SUCCESS (ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes)))\n\t{\n\t\tZwClose (handle);\n\t\treturn FALSE;\n\t}\n\n\treturn (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND)? TRUE : FALSE;\n}\n\n\nNTSTATUS TCCompleteIrp (PIRP irp, NTSTATUS status, ULONG_PTR information)\n{\n\tirp->IoStatus.Status = status;\n\tirp->IoStatus.Information = information;\n\tIoCompleteRequest (irp, IO_NO_INCREMENT);\n\treturn status;\n}\n\n\nNTSTATUS TCCompleteDiskIrp (PIRP irp, NTSTATUS status, ULONG_PTR information)\n{\n\tirp->IoStatus.Status = status;\n\tirp->IoStatus.Information = information;\n\tIoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);\n\treturn status;\n}\n\n\nsize_t GetCpuCount ()\n{\n\tKAFFINITY activeCpuMap = KeQueryActiveProcessors();\n\tsize_t mapSize = sizeof (activeCpuMap) * 8;\n\tsize_t cpuCount = 0;\n\n\twhile (mapSize--)\n\t{\n\t\tif (activeCpuMap & 1)\n\t\t\t++cpuCount;\n\n\t\tactiveCpuMap >>= 1;\n\t}\n\n\tif (cpuCount == 0)\n\t\treturn 1;\n\n\treturn cpuCount;\n}\n\n\nvoid EnsureNullTerminatedString (wchar_t *str, size_t maxSizeInBytes)\n{\n\tASSERT ((maxSizeInBytes & 1) == 0);\n\tstr[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;\n}\n\n\nvoid *AllocateMemoryWithTimeout (size_t size, int retryDelay, int timeout)\n{\n\tLARGE_INTEGER waitInterval;\n\twaitInterval.QuadPart = retryDelay * -10000;\n\n\tASSERT (KeGetCurrentIrql() <= APC_LEVEL);\n\tASSERT (retryDelay > 0 && retryDelay <= timeout);\n\n\twhile (TRUE)\n\t{\n\t\tvoid *memory = TCalloc (size);\n\t\tif (memory)\n\t\t\treturn memory;\n\n\t\ttimeout -= retryDelay;\n\t\tif (timeout <= 0)\n\t\t\tbreak;\n\n\t\tKeDelayExecutionThread (KernelMode, FALSE, &waitInterval);\n\t}\n\n\treturn NULL;\n}\n\n\nNTSTATUS TCReadRegistryKey (PUNICODE_STRING keyPath, wchar_t *keyValueName, PKEY_VALUE_PARTIAL_INFORMATION *keyData)\n{\n\tOBJECT_ATTRIBUTES regObjAttribs;\n\tHANDLE regKeyHandle;\n\tNTSTATUS status;\n\tUNICODE_STRING valName;\n\tULONG size = 0;\n\tULONG resultSize;\n\n\tInitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\tstatus = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tRtlInitUnicodeString (&valName, keyValueName);\n\tstatus = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);\n\n\tif (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)\n\t{\n\t\tZwClose (regKeyHandle);\n\t\treturn status;\n\t}\n\n\tif (size == 0)\n\t{\n\t\tZwClose (regKeyHandle);\n\t\treturn STATUS_NO_DATA_DETECTED;\n\t}\n\n\t*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) TCalloc (size);\n\tif (!*keyData)\n\t{\n\t\tZwClose (regKeyHandle);\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\t}\n\n\tstatus = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);\n\n\tZwClose (regKeyHandle);\n\treturn status;\n}\n\n\nNTSTATUS TCWriteRegistryKey (PUNICODE_STRING keyPath, wchar_t *keyValueName, ULONG keyValueType, void *valueData, ULONG valueSize)\n{\n\tOBJECT_ATTRIBUTES regObjAttribs;\n\tHANDLE regKeyHandle;\n\tNTSTATUS status;\n\tUNICODE_STRING valName;\n\n\tInitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\tstatus = ZwOpenKey (&regKeyHandle, KEY_READ | KEY_WRITE, &regObjAttribs);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tRtlInitUnicodeString (&valName, keyValueName);\n\n\tstatus = ZwSetValueKey (regKeyHandle, &valName, 0, keyValueType, valueData, valueSize);\n\n\tZwClose (regKeyHandle);\n\treturn status;\n}\n\n\nBOOL IsVolumeClassFilterRegistered ()\n{\n\tUNICODE_STRING name;\n\tNTSTATUS status;\n\tBOOL registered = FALSE;\n\n\tPKEY_VALUE_PARTIAL_INFORMATION data;\n\n\tRtlInitUnicodeString (&name, L\"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Class\\\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}\");\n\tstatus = TCReadRegistryKey (&name, L\"UpperFilters\", &data);\n\n\tif (NT_SUCCESS (status))\n\t{\n\t\tif (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))\n\t\t{\n\t\t\t// Search for the string \"veracrypt\"\n\t\t\tULONG i;\n\t\t\tfor (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)\n\t\t\t{\n\t\t\t\tif (memcmp (data->Data + i, L\"veracrypt\", 9 * sizeof (wchar_t)) == 0)\n\t\t\t\t{\n\t\t\t\t\tDump (\"Volume class filter active\\n\");\n\t\t\t\t\tregistered = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTCfree (data);\n\t}\n\n\treturn registered;\n}\n\n\nNTSTATUS ReadRegistryConfigFlags (BOOL driverEntry)\n{\n\tPKEY_VALUE_PARTIAL_INFORMATION data;\n\tUNICODE_STRING name;\n\tNTSTATUS status;\n\tuint32 flags = 0;\n\n\tRtlInitUnicodeString (&name, L\"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\veracrypt\");\n\tstatus = TCReadRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, &data);\n\n\tif (NT_SUCCESS (status))\n\t{\n\t\tif (data->Type == REG_DWORD)\n\t\t{\n\t\t\tflags = *(uint32 *) data->Data;\n\t\t\tDump (\"Configuration flags = 0x%x\\n\", flags);\n\n\t\t\tif (driverEntry)\n\t\t\t{\n\t\t\t\tif (flags & (TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))\n\t\t\t\t\tCacheBootPassword = TRUE;\n\n\t\t\t\tif (flags & TC_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)\n\t\t\t\t\tNonAdminSystemFavoritesAccessDisabled = TRUE;\n\n\t\t\t\tif (flags & TC_DRIVER_CONFIG_CACHE_BOOT_PIM)\n\t\t\t\t\tCacheBootPim = TRUE;\n\n\t\t\t\tif (flags & VC_DRIVER_CONFIG_BLOCK_SYS_TRIM)\n\t\t\t\t\tBlockSystemTrimCommand = TRUE;\n\t\t\t}\n\n\t\t\tEnableHwEncryption ((flags & TC_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);\n\n\t\t\tEnableExtendedIoctlSupport = (flags & TC_DRIVER_CONFIG_ENABLE_EXTENDED_IOCTL)? TRUE : FALSE;\n\t\t\tAllowTrimCommand = (flags & VC_DRIVER_CONFIG_ALLOW_NONSYS_TRIM)? TRUE : FALSE;\n\t\t\tAllowWindowsDefrag = (flags & VC_DRIVER_CONFIG_ALLOW_WINDOWS_DEFRAG)? TRUE : FALSE;\n\t\t}\n\t\telse\n\t\t\tstatus = STATUS_INVALID_PARAMETER;\n\n\t\tTCfree (data);\n\t}\n\n\tif (driverEntry && NT_SUCCESS (TCReadRegistryKey (&name, TC_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))\n\t{\n\t\tif (data->Type == REG_DWORD)\n\t\t\tEncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;\n\n\t\tTCfree (data);\n\t}\n\n\treturn status;\n}\n\n\nNTSTATUS WriteRegistryConfigFlags (uint32 flags)\n{\n\tUNICODE_STRING name;\n\tRtlInitUnicodeString (&name, L\"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\veracrypt\");\n\n\treturn TCWriteRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, REG_DWORD, &flags, sizeof (flags));\n}\n\n\nNTSTATUS GetDeviceSectorSize (PDEVICE_OBJECT deviceObject, ULONG *bytesPerSector)\n{\n\tNTSTATUS status;\n\tDISK_GEOMETRY geometry;\n\n\tstatus = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\t*bytesPerSector = geometry.BytesPerSector;\n\t\n\treturn STATUS_SUCCESS;\n}\n\n\nNTSTATUS ZeroUnreadableSectors (PDEVICE_OBJECT deviceObject, LARGE_INTEGER startOffset, ULONG size, uint64 *zeroedSectorCount)\n{\n\tNTSTATUS status;\n\tULONG sectorSize;\n\tULONG sectorCount;\n\tbyte *sectorBuffer = NULL;\n\n\t*zeroedSectorCount = 0;\n\n\tstatus = GetDeviceSectorSize (deviceObject, &sectorSize);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tsectorBuffer = TCalloc (sectorSize);\n\tif (!sectorBuffer)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tfor (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)\n\t{\n\t\tstatus = TCReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);\n\t\tif (!NT_SUCCESS (status))\n\t\t{\n\t\t\tDump (\"Zeroing sector at %I64d\\n\", startOffset.QuadPart);\n\t\t\tmemset (sectorBuffer, 0, sectorSize);\n\n\t\t\tstatus = TCWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);\n\t\t\tif (!NT_SUCCESS (status))\n\t\t\t\tgoto err;\n\n\t\t\t++(*zeroedSectorCount);\n\t\t}\n\t}\n\n\tstatus = STATUS_SUCCESS;\n\nerr:\n\tif (sectorBuffer)\n\t\tTCfree (sectorBuffer);\n\n\treturn status;\n}\n\n\nNTSTATUS ReadDeviceSkipUnreadableSectors (PDEVICE_OBJECT deviceObject, byte *buffer, LARGE_INTEGER startOffset, ULONG size, uint64 *badSectorCount)\n{\n\tNTSTATUS status;\n\tULONG sectorSize;\n\tULONG sectorCount;\n\n\t*badSectorCount = 0;\n\n\tstatus = GetDeviceSectorSize (deviceObject, &sectorSize);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tfor (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)\n\t{\n\t\tstatus = TCReadDevice (deviceObject, buffer, startOffset, sectorSize);\n\t\tif (!NT_SUCCESS (status))\n\t\t{\n\t\t\tDump (\"Skipping bad sector at %I64d\\n\", startOffset.QuadPart);\n\t\t\tmemset (buffer, 0, sectorSize);\n\t\t\t++(*badSectorCount);\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\n\nBOOL IsVolumeAccessibleByCurrentUser (PEXTENSION volumeDeviceExtension)\n{\n\tSECURITY_SUBJECT_CONTEXT subContext;\n\tPACCESS_TOKEN accessToken;\n\tPTOKEN_USER tokenUser;\n\tBOOL result = FALSE;\n\n\tif (IoIsSystemThread (PsGetCurrentThread())\n\t\t|| UserCanAccessDriveDevice()\n\t\t|| !volumeDeviceExtension->UserSid\n\t\t|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))\n\t{\n\t\treturn TRUE;\n\t}\n\n\tSeCaptureSubjectContext (&subContext);\n\tSeLockSubjectContext(&subContext);\n\tif (subContext.ClientToken && subContext.ImpersonationLevel >= SecurityImpersonation)\n\t\taccessToken = subContext.ClientToken;\n\telse\n\t\taccessToken = subContext.PrimaryToken;\n\n\tif (!accessToken)\n\t\tgoto ret;\n\n\tif (SeTokenIsAdmin (accessToken))\n\t{\n\t\tresult = TRUE;\n\t\tgoto ret;\n\t}\n\n\tif (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))\n\t\tgoto ret;\n\n\tresult = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);\n\tExFreePool (tokenUser);\t\t// Documented in newer versions of WDK\n\nret:\n\tSeUnlockSubjectContext(&subContext);\n\tSeReleaseSubjectContext (&subContext);\n\treturn result;\n}\n\n\nvoid GetElapsedTimeInit (LARGE_INTEGER *lastPerfCounter)\n{\n\t*lastPerfCounter = KeQueryPerformanceCounter (NULL);\n}\n\n\n// Returns elapsed time in microseconds since last call\nint64 GetElapsedTime (LARGE_INTEGER *lastPerfCounter)\n{\n\tLARGE_INTEGER freq;\n\tLARGE_INTEGER counter = KeQueryPerformanceCounter (&freq);\n\n\tint64 elapsed = (counter.QuadPart - lastPerfCounter->QuadPart) * 1000000LL / freq.QuadPart;\n\t*lastPerfCounter = counter;\n\n\treturn elapsed;\n}\n\n\nBOOL IsOSAtLeast (OSVersionEnum reqMinOS)\n{\n\t/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */\n\n\tULONG major = 0, minor = 0;\n\n\tASSERT (OsMajorVersion != 0);\n\n\tswitch (reqMinOS)\n\t{\n\tcase WIN_2000:\t\t\tmajor = 5; minor = 0; break;\n\tcase WIN_XP:\t\t\tmajor = 5; minor = 1; break;\n\tcase WIN_SERVER_2003:\tmajor = 5; minor = 2; break;\n\tcase WIN_VISTA:\t\t\tmajor = 6; minor = 0; break;\n\tcase WIN_7:\t\t\t\tmajor = 6; minor = 1; break;\n\tcase WIN_8:\t\t\t\tmajor = 6; minor = 2; break;\n\tcase WIN_8_1:\t\t\tmajor = 6; minor = 3; break;\n\tcase WIN_10:\t\t\tmajor = 10; minor = 0; break;\n\n\tdefault:\n\t\tTC_THROW_FATAL_EXCEPTION;\n\t\tbreak;\n\t}\n\n\treturn ((OsMajorVersion << 16 | OsMinorVersion << 8)\n\t\t>= (major << 16 | minor << 8));\n}\n\nNTSTATUS NTAPI KeSaveExtendedProcessorState (\n    __in ULONG64 Mask,\n    PXSTATE_SAVE XStateSave\n    )\n{\n\tif (KeSaveExtendedProcessorStatePtr)\n\t{\n\t\treturn (KeSaveExtendedProcessorStatePtr) (Mask, XStateSave);\n\t}\n\telse\n\t{\n\t\treturn STATUS_SUCCESS;\n\t}\n}\n\nVOID NTAPI KeRestoreExtendedProcessorState (\n\tPXSTATE_SAVE XStateSave\n\t)\n{\n\tif (KeRestoreExtendedProcessorStatePtr)\n\t{\n\t\t(KeRestoreExtendedProcessorStatePtr) (XStateSave);\n\t}\n}"], "fixing_code": ["/*\n Legal Notice: Some portions of the source code contained in this file were\n derived from the source code of TrueCrypt 7.1a, which is\n Copyright (c) 2003-2012 TrueCrypt Developers Association and which is\n governed by the TrueCrypt License 3.0, also from the source code of\n Encryption for the Masses 2.02a, which is Copyright (c) 1998-2000 Paul Le Roux\n and which is governed by the 'License Agreement for Encryption for the Masses'\n Modifications and additions to the original source code (contained in this file)\n and all other portions of this file are Copyright (c) 2013-2017 IDRIX\n and are governed by the Apache License 2.0 the full text of which is\n contained in the file License.txt included in VeraCrypt binary and source\n code distribution packages. */\n\n#include \"TCdefs.h\"\n#include <ntddk.h>\n#include \"Crypto.h\"\n#include \"Fat.h\"\n#include \"Tests.h\"\n#include \"cpu.h\"\n#include \"Crc.h\"\n\n#include \"Apidrvr.h\"\n#include \"Boot/Windows/BootDefs.h\"\n#include \"EncryptedIoQueue.h\"\n#include \"EncryptionThreadPool.h\"\n#include \"Ntdriver.h\"\n#include \"Ntvol.h\"\n#include \"DriveFilter.h\"\n#include \"DumpFilter.h\"\n#include \"Cache.h\"\n#include \"Volumes.h\"\n#include \"VolumeFilter.h\"\n\n#include <tchar.h>\n#include <initguid.h>\n#include <mountmgr.h>\n#include <mountdev.h>\n#include <ntddvol.h>\n\n#include <Ntstrsafe.h>\n#include <Intsafe.h>\n\n#ifndef IOCTL_DISK_GET_CLUSTER_INFO\n#define IOCTL_DISK_GET_CLUSTER_INFO\t\t\t\tCTL_CODE(IOCTL_DISK_BASE, 0x0085, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#endif\n\n#ifndef IOCTL_DISK_ARE_VOLUMES_READY\n#define IOCTL_DISK_ARE_VOLUMES_READY\t\t\tCTL_CODE(IOCTL_DISK_BASE, 0x0087, METHOD_BUFFERED, FILE_READ_ACCESS)\n#endif\n\n#ifndef FT_BALANCED_READ_MODE\n#define FTTYPE  ((ULONG)'f') \n#define FT_BALANCED_READ_MODE\t\t\t\t\t\tCTL_CODE(FTTYPE, 6, METHOD_NEITHER,  FILE_ANY_ACCESS) \n#endif\n\n#ifndef IOCTL_VOLUME_QUERY_ALLOCATION_HINT\n#define IOCTL_VOLUME_QUERY_ALLOCATION_HINT      CTL_CODE(IOCTL_VOLUME_BASE, 20, METHOD_OUT_DIRECT, FILE_READ_ACCESS)\n#endif\n\n#ifndef IOCTL_DISK_IS_CLUSTERED\n#define IOCTL_DISK_IS_CLUSTERED             CTL_CODE(IOCTL_DISK_BASE, 0x003e, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#endif\n\n#ifndef IOCTL_VOLUME_POST_ONLINE\n#define IOCTL_VOLUME_POST_ONLINE                CTL_CODE(IOCTL_VOLUME_BASE, 25, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)\n#endif\n\n#ifndef IOCTL_VOLUME_IS_DYNAMIC\n#define IOCTL_VOLUME_IS_DYNAMIC                 CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#endif\n\n#ifndef StorageDeviceLBProvisioningProperty\n#define StorageDeviceLBProvisioningProperty 11\n#endif\n\n#ifndef DeviceDsmAction_OffloadRead\n#define DeviceDsmAction_OffloadRead       ( 3  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_OffloadWrite\n#define DeviceDsmAction_OffloadWrite        4\n#endif\n\n#ifndef DeviceDsmAction_Allocation\n#define DeviceDsmAction_Allocation        ( 5  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_Repair\n#define DeviceDsmAction_Repair            ( 6  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_Scrub\n#define DeviceDsmAction_Scrub             ( 7  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_DrtQuery\n#define DeviceDsmAction_DrtQuery          ( 8  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_DrtClear\n#define DeviceDsmAction_DrtClear          ( 9  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n#ifndef DeviceDsmAction_DrtDisable\n#define DeviceDsmAction_DrtDisable        (10  | DeviceDsmActionFlag_NonDestructive)\n#endif\n\n/* Init section, which is thrown away as soon as DriverEntry returns */\n#pragma alloc_text(INIT,DriverEntry)\n#pragma alloc_text(INIT,TCCreateRootDeviceObject)\n\n/* We need to silence 'type cast' warning in order to use MmGetSystemRoutineAddress.\n * MmGetSystemRoutineAddress() should have been declare FARPROC instead of PVOID.\n */\n#pragma warning(disable:4055)\n\nPDRIVER_OBJECT TCDriverObject;\nPDEVICE_OBJECT RootDeviceObject = NULL;\nstatic KMUTEX RootDeviceControlMutex;\nBOOL DriverShuttingDown = FALSE;\nBOOL SelfTestsPassed;\nint LastUniqueVolumeId;\nULONG OsMajorVersion = 0;\nULONG OsMinorVersion;\nBOOL DriverUnloadDisabled = FALSE;\nBOOL PortableMode = FALSE;\nBOOL VolumeClassFilterRegistered = FALSE;\nBOOL CacheBootPassword = FALSE;\nBOOL CacheBootPim = FALSE;\nBOOL NonAdminSystemFavoritesAccessDisabled = FALSE;\nBOOL BlockSystemTrimCommand = FALSE;\nBOOL AllowWindowsDefrag = FALSE;\nstatic size_t EncryptionThreadPoolFreeCpuCountLimit = 0;\nstatic BOOL SystemFavoriteVolumeDirty = FALSE;\nstatic BOOL PagingFileCreationPrevented = FALSE;\nstatic BOOL EnableExtendedIoctlSupport = FALSE;\nstatic BOOL AllowTrimCommand = FALSE;\nstatic KeSaveExtendedProcessorStateFn KeSaveExtendedProcessorStatePtr = NULL;\nstatic KeRestoreExtendedProcessorStateFn KeRestoreExtendedProcessorStatePtr = NULL;\n\nPOOL_TYPE ExDefaultNonPagedPoolType = NonPagedPool;\nULONG ExDefaultMdlProtection = 0;\n\nPDEVICE_OBJECT VirtualVolumeDeviceObjects[MAX_MOUNTED_VOLUME_DRIVE_NUMBER + 1];\n\n\nNTSTATUS DriverEntry (PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)\n{\n\tPKEY_VALUE_PARTIAL_INFORMATION startKeyValue;\n\tLONG version;\n\tint i;\n\n\tDump (\"DriverEntry \" TC_APP_NAME \" \" VERSION_STRING \"\\n\");\n\n\tDetectX86Features ();\n\n\tPsGetVersion (&OsMajorVersion, &OsMinorVersion, NULL, NULL);\n\n\tDump (\"OsMajorVersion=%d OsMinorVersion=%d\\n\", OsMajorVersion, OsMinorVersion);\n\n\t// NX pool support is available starting from Windows 8\n\tif ((OsMajorVersion > 6) || (OsMajorVersion == 6 && OsMinorVersion >= 2))\n\t{\n\t\tExDefaultNonPagedPoolType = (POOL_TYPE) NonPagedPoolNx;\n\t\tExDefaultMdlProtection = MdlMappingNoExecute;\n\t}\n\n\t// KeSaveExtendedProcessorState/KeRestoreExtendedProcessorState are available starting from Windows 7\n\tif ((OsMajorVersion > 6) || (OsMajorVersion == 6 && OsMinorVersion >= 1))\n\t{\n\t\tUNICODE_STRING saveFuncName, restoreFuncName;\n\t\tRtlInitUnicodeString(&saveFuncName, L\"KeSaveExtendedProcessorState\");\n\t\tRtlInitUnicodeString(&restoreFuncName, L\"KeRestoreExtendedProcessorState\");\n\t\tKeSaveExtendedProcessorStatePtr = (KeSaveExtendedProcessorStateFn) MmGetSystemRoutineAddress(&saveFuncName);\n\t\tKeRestoreExtendedProcessorStatePtr = (KeRestoreExtendedProcessorStateFn) MmGetSystemRoutineAddress(&restoreFuncName);\n\t}\n\n\t// Load dump filter if the main driver is already loaded\n\tif (NT_SUCCESS (TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version))))\n\t\treturn DumpFilterEntry ((PFILTER_EXTENSION) DriverObject, (PFILTER_INITIALIZATION_DATA) RegistryPath);\n\n\tTCDriverObject = DriverObject;\n\tmemset (VirtualVolumeDeviceObjects, 0, sizeof (VirtualVolumeDeviceObjects));\n\n\tReadRegistryConfigFlags (TRUE);\n\tEncryptionThreadPoolStart (EncryptionThreadPoolFreeCpuCountLimit);\n\tSelfTestsPassed = AutoTestAlgorithms();\n\n\t// Enable device class filters and load boot arguments if the driver is set to start at system boot\n\n\tif (NT_SUCCESS (TCReadRegistryKey (RegistryPath, L\"Start\", &startKeyValue)))\n\t{\n\t\tif (startKeyValue->Type == REG_DWORD && *((uint32 *) startKeyValue->Data) == SERVICE_BOOT_START)\n\t\t{\n\t\t\tif (!SelfTestsPassed)\n\t\t\t{\n\t\t\t\t// in case of system encryption, if self-tests fail, disable all extended CPU\n\t\t\t\t// features and try again in order to workaround faulty configurations\n\t\t\t\tDisableCPUExtendedFeatures ();\n\t\t\t\tSelfTestsPassed = AutoTestAlgorithms();\n\n\t\t\t\t// BUG CHECK if the self-tests still fail\n\t\t\t\tif (!SelfTestsPassed)\n\t\t\t\t\tTC_BUG_CHECK (STATUS_INVALID_PARAMETER);\n\t\t\t}\n\n\t\t\tLoadBootArguments();\n\t\t\tVolumeClassFilterRegistered = IsVolumeClassFilterRegistered();\n\n\t\t\tDriverObject->DriverExtension->AddDevice = DriverAddDevice;\n\t\t}\n\n\t\tTCfree (startKeyValue);\n\t}\n\n\tfor (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)\n\t{\n\t\tDriverObject->MajorFunction[i] = TCDispatchQueueIRP;\n\t}\n\n\tDriverObject->DriverUnload = TCUnloadDriver;\n\treturn TCCreateRootDeviceObject (DriverObject);\n}\n\n\nNTSTATUS DriverAddDevice (PDRIVER_OBJECT driverObject, PDEVICE_OBJECT pdo)\n{\n#if defined(DEBUG) || defined (DEBUG_TRACE)\n\tchar nameInfoBuffer[128];\n\tPOBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION) nameInfoBuffer;\n\tULONG nameInfoSize;\n\tDump (\"AddDevice pdo=%p type=%x name=%ws\\n\", pdo, pdo->DeviceType, NT_SUCCESS (ObQueryNameString (pdo, nameInfo, sizeof (nameInfoBuffer), &nameInfoSize)) ? nameInfo->Name.Buffer : L\"?\");\n#endif\n\n\tif (VolumeClassFilterRegistered && BootArgsValid && BootArgs.HiddenSystemPartitionStart != 0)\n\t{\n\t\tPWSTR interfaceLinks = NULL;\n\t\tif (NT_SUCCESS (IoGetDeviceInterfaces (&GUID_DEVINTERFACE_VOLUME, pdo, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &interfaceLinks)) && interfaceLinks)\n\t\t{\n\t\t\tif (interfaceLinks[0] != UNICODE_NULL)\n\t\t\t{\n\t\t\t\tDump (\"Volume pdo=%p interface=%ws\\n\", pdo, interfaceLinks);\n\t\t\t\tExFreePool (interfaceLinks);\n\n\t\t\t\treturn VolumeFilterAddDevice (driverObject, pdo);\n\t\t\t}\n\n\t\t\tExFreePool (interfaceLinks);\n\t\t}\n\t}\n\n\treturn DriveFilterAddDevice (driverObject, pdo);\n}\n\n\n// Dumps a memory region to debug output\nvoid DumpMemory (void *mem, int size)\n{\n\tunsigned char str[20];\n\tunsigned char *m = mem;\n\tint i,j;\n\n\tfor (j = 0; j < size / 8; j++)\n\t{\n\t\tmemset (str,0,sizeof str);\n\t\tfor (i = 0; i < 8; i++)\n\t\t{\n\t\t\tif (m[i] > ' ' && m[i] <= '~')\n\t\t\t\tstr[i]=m[i];\n\t\t\telse\n\t\t\t\tstr[i]='.';\n\t\t}\n\n\t\tDump (\"0x%08p  %02x %02x %02x %02x %02x %02x %02x %02x  %s\\n\",\n\t\t\tm, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], str);\n\n\t\tm+=8;\n\t}\n}\n\nBOOL IsAllZeroes (unsigned char* pbData, DWORD dwDataLen)\n{\n\twhile (dwDataLen--)\n\t{\n\t\tif (*pbData)\n\t\t\treturn FALSE;\n\t\tpbData++;\n\t}\n\treturn TRUE;\n}\n\nBOOL ValidateIOBufferSize (PIRP irp, size_t requiredBufferSize, ValidateIOBufferSizeType type)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);\n\tBOOL input = (type == ValidateInput || type == ValidateInputOutput);\n\tBOOL output = (type == ValidateOutput || type == ValidateInputOutput);\n\n\tif ((input && irpSp->Parameters.DeviceIoControl.InputBufferLength < requiredBufferSize)\n\t\t|| (output && irpSp->Parameters.DeviceIoControl.OutputBufferLength < requiredBufferSize))\n\t{\n\t\tDump (\"STATUS_BUFFER_TOO_SMALL ioctl=0x%x,%d in=%d out=%d reqsize=%d insize=%d outsize=%d\\n\", (int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16), (int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2), input, output, requiredBufferSize, irpSp->Parameters.DeviceIoControl.InputBufferLength, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\n\t\tirp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;\n\t\tirp->IoStatus.Information = 0;\n\t\treturn FALSE;\n\t}\n\n\tif (!input && output)\n\t\tmemset (irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\n\treturn TRUE;\n}\n\n\nPDEVICE_OBJECT GetVirtualVolumeDeviceObject (int driveNumber)\n{\n\tif (driveNumber < MIN_MOUNTED_VOLUME_DRIVE_NUMBER || driveNumber > MAX_MOUNTED_VOLUME_DRIVE_NUMBER)\n\t\treturn NULL;\n\n\treturn VirtualVolumeDeviceObjects[driveNumber];\n}\n\n\n/* TCDispatchQueueIRP queues any IRP's so that they can be processed later\n   by the thread -- or in some cases handles them immediately! */\nNTSTATUS TCDispatchQueueIRP (PDEVICE_OBJECT DeviceObject, PIRP Irp)\n{\n\tPEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\tNTSTATUS ntStatus;\n\n#if defined(_DEBUG) || defined (_DEBUG_TRACE)\n\tif (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL && (Extension->bRootDevice || Extension->IsVolumeDevice))\n\t{\n\t\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\t\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_OPEN_TEST:\n\t\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tcase TC_IOCTL_GET_DEVICE_REFCOUNT:\n\t\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:\n\t\tcase TC_IOCTL_GET_WARNING_FLAGS:\n\t\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\tcase IOCTL_DISK_CHECK_VERIFY:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDump (\"%ls (0x%x %d)\\n\",\n\t\t\t\tTCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode),\n\t\t\t\t(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),\n\t\t\t\t(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));\n\t\t}\n\t}\n#endif\n\n\tif (!Extension->bRootDevice)\n\t{\n\t\t// Drive filter IRP\n\t\tif (Extension->IsDriveFilterDevice)\n\t\t\treturn DriveFilterDispatchIrp (DeviceObject, Irp);\n\n\t\t// Volume filter IRP\n\t\tif (Extension->IsVolumeFilterDevice)\n\t\t\treturn VolumeFilterDispatchIrp (DeviceObject, Irp);\n\t}\n\n\tswitch (irpSp->MajorFunction)\n\t{\n\tcase IRP_MJ_CLOSE:\n\tcase IRP_MJ_CREATE:\n\tcase IRP_MJ_CLEANUP:\n\t\treturn COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);\n\n\tcase IRP_MJ_SHUTDOWN:\n\t\tif (Extension->bRootDevice)\n\t\t{\n\t\t\tDump (\"Driver shutting down\\n\");\n\t\t\tDriverShuttingDown = TRUE;\n\n\t\t\tif (EncryptionSetupThread)\n\t\t\t\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);\n\n\t\t\tif (DecoySystemWipeThread)\n\t\t\t\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);\n\n\t\t\tOnShutdownPending();\n\t\t}\n\n\t\treturn COMPLETE_IRP (DeviceObject, Irp, STATUS_SUCCESS, 0);\n\n\tcase IRP_MJ_FLUSH_BUFFERS:\n\tcase IRP_MJ_READ:\n\tcase IRP_MJ_WRITE:\n\tcase IRP_MJ_DEVICE_CONTROL:\n\n\t\tif (Extension->bRootDevice)\n\t\t{\n\t\t\tif (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)\n\t\t\t{\n\t\t\t\tNTSTATUS status = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, NULL);\n\t\t\t\tif (!NT_SUCCESS (status))\n\t\t\t\t\treturn status;\n\n\t\t\t\tstatus = ProcessMainDeviceControlIrp (DeviceObject, Extension, Irp);\n\n\t\t\t\tKeReleaseMutex (&RootDeviceControlMutex, FALSE);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (Extension->bShuttingDown)\n\t\t{\n\t\t\tDump (\"Device %d shutting down: STATUS_DELETE_PENDING\\n\", Extension->nDosDriveNo);\n\t\t\treturn TCCompleteDiskIrp (Irp, STATUS_DELETE_PENDING, 0);\n\t\t}\n\n\t\tif (Extension->bRemovable\n\t\t\t&& (DeviceObject->Flags & DO_VERIFY_VOLUME)\n\t\t\t&& !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)\n\t\t\t&& irpSp->MajorFunction != IRP_MJ_FLUSH_BUFFERS)\n\t\t{\n\t\t\tDump (\"Removable device %d has DO_VERIFY_VOLUME flag: STATUS_DEVICE_NOT_READY\\n\", Extension->nDosDriveNo);\n\t\t\treturn TCCompleteDiskIrp (Irp, STATUS_DEVICE_NOT_READY, 0);\n\t\t}\n\n\t\tswitch (irpSp->MajorFunction)\n\t\t{\n\t\tcase IRP_MJ_READ:\n\t\tcase IRP_MJ_WRITE:\n\t\t\tntStatus = EncryptedIoQueueAddIrp (&Extension->Queue, Irp);\n\n\t\t\tif (ntStatus != STATUS_PENDING)\n\t\t\t\tTCCompleteDiskIrp (Irp, ntStatus, 0);\n\n\t\t\treturn ntStatus;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\tntStatus = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);\n\t\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\t\treturn TCCompleteIrp (Irp, ntStatus, 0);\n\n\t\t\tIoMarkIrpPending (Irp);\n\n\t\t\tExInterlockedInsertTailList (&Extension->ListEntry, &Irp->Tail.Overlay.ListEntry, &Extension->ListSpinLock);\n\t\t\tKeReleaseSemaphore (&Extension->RequestSemaphore, IO_DISK_INCREMENT, 1, FALSE);\n\n\t\t\treturn STATUS_PENDING;\n\n\t\tcase IRP_MJ_FLUSH_BUFFERS:\n\t\t\treturn TCCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);\n\t\t}\n\n\t\tbreak;\n\n\tcase IRP_MJ_PNP:\n\t\tif (!Extension->bRootDevice\n\t\t\t&& Extension->IsVolumeDevice\n\t\t\t&& irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION\n\t\t\t&& irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging\n\t\t\t&& irpSp->Parameters.UsageNotification.InPath)\n\t\t{\n\t\t\tPagingFileCreationPrevented = TRUE;\n\t\t\treturn TCCompleteIrp (Irp, STATUS_UNSUCCESSFUL, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n}\n\nNTSTATUS TCCreateRootDeviceObject (PDRIVER_OBJECT DriverObject)\n{\n\tUNICODE_STRING Win32NameString, ntUnicodeString;\n\tWCHAR dosname[32], ntname[32];\n\tPDEVICE_OBJECT DeviceObject;\n\tNTSTATUS ntStatus;\n\tBOOL *bRootExtension;\n\n\tDump (\"TCCreateRootDeviceObject BEGIN\\n\");\n\tASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);\n\n\tRtlStringCbCopyW (dosname, sizeof(dosname),(LPWSTR) DOS_ROOT_PREFIX);\n\tRtlStringCbCopyW (ntname, sizeof(ntname),(LPWSTR) NT_ROOT_PREFIX);\n\tRtlInitUnicodeString (&ntUnicodeString, ntname);\n\tRtlInitUnicodeString (&Win32NameString, dosname);\n\n\tDump (\"Creating root device nt=%ls dos=%ls\\n\", ntname, dosname);\n\n\tntStatus = IoCreateDevice (\n\t\t\t\t\t  DriverObject,\n\t\t\t\t\t  sizeof (BOOL),\n\t\t\t\t\t  &ntUnicodeString,\n\t\t\t\t\t  FILE_DEVICE_UNKNOWN,\n\t\t\t\t\t  FILE_DEVICE_SECURE_OPEN,\n\t\t\t\t\t  FALSE,\n\t\t\t\t\t  &DeviceObject);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"TCCreateRootDeviceObject NTSTATUS = 0x%08x END\\n\", ntStatus);\n\t\treturn ntStatus;/* Failed to create DeviceObject */\n\t}\n\n\tDeviceObject->Flags |= DO_DIRECT_IO;\n\tDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;\n\n\t/* Setup the device extension */\n\tbRootExtension = (BOOL *) DeviceObject->DeviceExtension;\n\t*bRootExtension = TRUE;\n\n\tKeInitializeMutex (&RootDeviceControlMutex, 0);\n\n\tntStatus = IoCreateSymbolicLink (&Win32NameString, &ntUnicodeString);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"TCCreateRootDeviceObject NTSTATUS = 0x%08x END\\n\", ntStatus);\n\t\tIoDeleteDevice (DeviceObject);\n\t\treturn ntStatus;\n\t}\n\n\tIoRegisterShutdownNotification (DeviceObject);\n\tRootDeviceObject = DeviceObject;\n\n\tDump (\"TCCreateRootDeviceObject STATUS_SUCCESS END\\n\");\n\treturn STATUS_SUCCESS;\n}\n\nNTSTATUS TCCreateDeviceObject (PDRIVER_OBJECT DriverObject,\n\t\t       PDEVICE_OBJECT * ppDeviceObject,\n\t\t       MOUNT_STRUCT * mount)\n{\n\tUNICODE_STRING ntUnicodeString;\n\tWCHAR ntname[32];\n\tPEXTENSION Extension;\n\tNTSTATUS ntStatus;\n\tULONG devChars = 0;\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\tWCHAR dosname[32];\n#endif\n\n\tDump (\"TCCreateDeviceObject BEGIN\\n\");\n\tASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);\n\n\tTCGetNTNameFromNumber (ntname, sizeof(ntname),mount->nDosDriveNo);\n\tRtlInitUnicodeString (&ntUnicodeString, ntname);\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\tTCGetDosNameFromNumber (dosname, sizeof(dosname),mount->nDosDriveNo, DeviceNamespaceDefault);\n#endif\n\n\tdevChars = FILE_DEVICE_SECURE_OPEN;\n\tdevChars |= mount->bMountReadOnly ? FILE_READ_ONLY_DEVICE : 0;\n\tdevChars |= mount->bMountRemovable ? FILE_REMOVABLE_MEDIA : 0;\n\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\tDump (\"Creating device nt=%ls dos=%ls\\n\", ntname, dosname);\n#endif\n\n\tntStatus = IoCreateDevice (\n\t\t\t\t\t  DriverObject,\t\t\t/* Our Driver Object */\n\t\t\t\t\t  sizeof (EXTENSION),\t/* Size of state information */\n\t\t\t\t\t  &ntUnicodeString,\t\t/* Device name \"\\Device\\Name\" */\n\t\t\t\t\t  FILE_DEVICE_DISK,\t\t/* Device type */\n\t\t\t\t\t  devChars,\t\t\t\t/* Device characteristics */\n\t\t\t\t\t  FALSE,\t\t\t\t/* Exclusive device */\n\t\t\t\t\t  ppDeviceObject);\t\t/* Returned ptr to Device Object */\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"TCCreateDeviceObject NTSTATUS = 0x%08x END\\n\", ntStatus);\n\t\treturn ntStatus;/* Failed to create DeviceObject */\n\t}\n\t/* Initialize device object and extension. */\n\n\t(*ppDeviceObject)->Flags |= DO_DIRECT_IO;\n\t(*ppDeviceObject)->StackSize += 6;\t\t// Reduce occurrence of NO_MORE_IRP_STACK_LOCATIONS bug check caused by buggy drivers\n\n\t/* Setup the device extension */\n\tExtension = (PEXTENSION) (*ppDeviceObject)->DeviceExtension;\n\tmemset (Extension, 0, sizeof (EXTENSION));\n\n\tExtension->IsVolumeDevice = TRUE;\n\tExtension->nDosDriveNo = mount->nDosDriveNo;\n\tExtension->bRemovable = mount->bMountRemovable;\n\tExtension->PartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;\n\tExtension->SystemFavorite = mount->SystemFavorite;\n\n\tKeInitializeEvent (&Extension->keCreateEvent, SynchronizationEvent, FALSE);\n\tKeInitializeSemaphore (&Extension->RequestSemaphore, 0L, MAXLONG);\n\tKeInitializeSpinLock (&Extension->ListSpinLock);\n\tInitializeListHead (&Extension->ListEntry);\n\tIoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCV', 0, 0);\n\n\tVirtualVolumeDeviceObjects[mount->nDosDriveNo] = *ppDeviceObject;\n\n\tDump (\"TCCreateDeviceObject STATUS_SUCCESS END\\n\");\n\n\treturn STATUS_SUCCESS;\n}\n\n\nBOOL RootDeviceControlMutexAcquireNoWait ()\n{\n\tNTSTATUS status;\n\tLARGE_INTEGER timeout;\n\ttimeout.QuadPart = 0;\n\n\tstatus = KeWaitForMutexObject (&RootDeviceControlMutex, Executive, KernelMode, FALSE, &timeout);\n\treturn NT_SUCCESS (status) && status != STATUS_TIMEOUT;\n}\n\n\nvoid RootDeviceControlMutexRelease ()\n{\n\tKeReleaseMutex (&RootDeviceControlMutex, FALSE);\n}\n\n/*\nIOCTL_STORAGE_GET_DEVICE_NUMBER 0x002D1080 \nIOCTL_STORAGE_GET_HOTPLUG_INFO 0x002D0C14\nIOCTL_STORAGE_QUERY_PROPERTY 0x002D1400\n*/\n\nNTSTATUS ProcessVolumeDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, PIRP Irp)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\n\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t{\n\n\tcase IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_MOUNTDEV_QUERY_DEVICE_NAME)\\n\");\n\t\tif (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_NAME), ValidateOutput))\n\t\t{\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_NAME);\n\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tULONG outLength;\n\t\t\tUNICODE_STRING ntUnicodeString;\n\t\t\tWCHAR ntName[256];\n\t\t\tPMOUNTDEV_NAME outputBuffer = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tTCGetNTNameFromNumber (ntName, sizeof(ntName),Extension->nDosDriveNo);\n\t\t\tRtlInitUnicodeString (&ntUnicodeString, ntName);\n\n\t\t\toutputBuffer->NameLength = ntUnicodeString.Length;\n\t\t\toutLength = ntUnicodeString.Length + sizeof(USHORT);\n\n\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_NAME);\n\t\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = outLength;\n\n\t\t\tDump (\"name = %ls\\n\",ntName);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_MOUNTDEV_QUERY_UNIQUE_ID)\\n\");\n\t\tif (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_UNIQUE_ID), ValidateOutput))\n\t\t{\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);\n\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tULONG outLength;\n\t\t\tUCHAR volId[128], tmp[] = { 0,0 };\n\t\t\tPMOUNTDEV_UNIQUE_ID outputBuffer = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tRtlStringCbCopyA (volId, sizeof(volId),TC_UNIQUE_ID_PREFIX);\n\t\t\ttmp[0] = 'A' + (UCHAR) Extension->nDosDriveNo;\n\t\t\tRtlStringCbCatA (volId, sizeof(volId),tmp);\n\n\t\t\toutputBuffer->UniqueIdLength = (USHORT) strlen (volId);\n\t\t\toutLength = (ULONG) (strlen (volId) + sizeof (USHORT));\n\n\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_UNIQUE_ID);\n\t\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRtlCopyMemory ((PCHAR)outputBuffer->UniqueId, volId, strlen (volId));\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = outLength;\n\n\t\t\tDump (\"id = %s\\n\",volId);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME)\\n\");\n\t\t{\n\t\t\tULONG outLength;\n\t\t\tUNICODE_STRING ntUnicodeString;\n\t\t\tWCHAR ntName[256];\n\t\t\tPMOUNTDEV_SUGGESTED_LINK_NAME outputBuffer = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (MOUNTDEV_SUGGESTED_LINK_NAME), ValidateOutput))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tTCGetDosNameFromNumber (ntName, sizeof(ntName),Extension->nDosDriveNo, DeviceNamespaceDefault);\n\t\t\tRtlInitUnicodeString (&ntUnicodeString, ntName);\n\n\t\t\toutLength = FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME,Name) + ntUnicodeString.Length;\n\n\t\t\toutputBuffer->UseOnlyIfThereAreNoOtherLinks = FALSE;\n\t\t\toutputBuffer->NameLength = ntUnicodeString.Length;\n\n\t\t\tif(irpSp->Parameters.DeviceIoControl.OutputBufferLength < outLength)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = sizeof (MOUNTDEV_SUGGESTED_LINK_NAME);\n\t\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tRtlCopyMemory ((PCHAR)outputBuffer->Name,ntUnicodeString.Buffer, ntUnicodeString.Length);\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = outLength;\n\n\t\t\tDump (\"link = %ls\\n\",ntName);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_MEDIA_TYPES:\n\tcase IOCTL_DISK_GET_DRIVE_GEOMETRY:\n\tcase IOCTL_STORAGE_GET_MEDIA_TYPES:\n\tcase IOCTL_DISK_UPDATE_DRIVE_SIZE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_GEOMETRY)\\n\");\n\t\t/* Return the drive geometry for the disk.  Note that we\n\t\t   return values which were made up to suit the disk size.  */\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY), ValidateOutput))\n\t\t{\n\t\t\tPDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;\n\t\t\toutputBuffer->Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\toutputBuffer->TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\toutputBuffer->SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\toutputBuffer->BytesPerSector = Extension->BytesPerSector;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_GEOMETRY_EX)\\n\");\n\t\t{\n\t\t\tULONG minOutputSize = IsOSAtLeast (WIN_SERVER_2003)? sizeof (DISK_GEOMETRY_EX) : sizeof (DISK_GEOMETRY) + sizeof (LARGE_INTEGER);\n\t\t\tULONG fullOutputSize = sizeof (DISK_GEOMETRY) + sizeof (LARGE_INTEGER) + sizeof (DISK_PARTITION_INFO) + sizeof (DISK_DETECTION_INFO);\n\n\t\t\tif (ValidateIOBufferSize (Irp, minOutputSize, ValidateOutput))\n\t\t\t{\n\t\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\t\tBOOL bFullBuffer = (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= fullOutputSize)? TRUE : FALSE;\n\t\t\t\tPDISK_GEOMETRY_EX outputBuffer = (PDISK_GEOMETRY_EX) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\toutputBuffer->Geometry.MediaType = Extension->bRemovable ? RemovableMedia : FixedMedia;\n\t\t\t\toutputBuffer->Geometry.Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\t\toutputBuffer->Geometry.TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\t\toutputBuffer->Geometry.SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\t\toutputBuffer->Geometry.BytesPerSector = Extension->BytesPerSector;\n\t\t\t\t/* add one sector to DiskLength since our partition size is DiskLength and its offset if BytesPerSector */\n\t\t\t\toutputBuffer->DiskSize.QuadPart = Extension->DiskLength + Extension->BytesPerSector;\n\n\t\t\t\tif (bFullBuffer)\n\t\t\t\t{\n\t\t\t\t\tPDISK_PARTITION_INFO pPartInfo = (PDISK_PARTITION_INFO)(((ULONG_PTR) outputBuffer) + sizeof (DISK_GEOMETRY) + sizeof (LARGE_INTEGER));\n\t\t\t\t\tPDISK_DETECTION_INFO pDetectInfo = ((PDISK_DETECTION_INFO)((((ULONG_PTR) pPartInfo) + sizeof (DISK_PARTITION_INFO))));\n\n\t\t\t\t\tpPartInfo->SizeOfPartitionInfo = sizeof (DISK_PARTITION_INFO);\n\t\t\t\t\tpPartInfo->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\t\t\tpPartInfo->Mbr.Signature = GetCrc32((unsigned char*) &(Extension->UniqueVolumeId), 4);\n\n\t\t\t\t\tpDetectInfo->SizeOfDetectInfo = sizeof (DISK_DETECTION_INFO);\n\n\t\t\t\t\tIrp->IoStatus.Information = fullOutputSize;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (DISK_GEOMETRY_EX))\n\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX);\n\t\t\t\t\telse\n\t\t\t\t\t\tIrp->IoStatus.Information = minOutputSize;\n\t\t\t\t}\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_GET_MEDIA_TYPES_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_GET_MEDIA_TYPES_EX)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (GET_MEDIA_TYPES), ValidateOutput))\n\t\t{\n\t\t\tPGET_MEDIA_TYPES outputBuffer = (PGET_MEDIA_TYPES)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_MEDIA_INFO mediaInfo = &outputBuffer->MediaInfo[0];\n\n\t\t\toutputBuffer->DeviceType = FILE_DEVICE_DISK;\n\t\t\toutputBuffer->MediaInfoCount = 1;\n\n\t\t\tif (Extension->bRemovable)\n\t\t\t{\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;\n\t\t\t\tif (Extension->bReadOnly)\n\t\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_ONLY | MEDIA_WRITE_PROTECTED);\n\t\t\t\telse\n\t\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_WRITE);\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = (STORAGE_MEDIA_TYPE) RemovableMedia;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\t\tmediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = Extension->BytesPerSector;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.NumberMediaSides = 1;\n\t\t\t\tif (Extension->bReadOnly)\n\t\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_ONLY | MEDIA_WRITE_PROTECTED);\n\t\t\t\telse\n\t\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_WRITE);\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.MediaType = (STORAGE_MEDIA_TYPE) FixedMedia;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.Cylinders.QuadPart = Extension->NumberOfCylinders;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.TracksPerCylinder = Extension->TracksPerCylinder;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.SectorsPerTrack = Extension->SectorsPerTrack;\n\t\t\t\tmediaInfo->DeviceSpecific.DiskInfo.BytesPerSector = Extension->BytesPerSector;\n\t\t\t}\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (GET_MEDIA_TYPES);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_QUERY_PROPERTY:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_QUERY_PROPERTY)\\n\");\t\t\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport || Extension->TrimEnabled)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_PROPERTY_QUERY), ValidateInput))\n\t\t\t{\n\t\t\t\tPSTORAGE_PROPERTY_QUERY pStoragePropQuery = (PSTORAGE_PROPERTY_QUERY) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\tSTORAGE_QUERY_TYPE type = pStoragePropQuery->QueryType;\n\n\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - PropertyId = %d, type = %d, InputBufferLength = %d, OutputBufferLength = %d\\n\", pStoragePropQuery->PropertyId, type, (int) irpSp->Parameters.DeviceIoControl.InputBufferLength, (int) irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\n\t\t\t\tif (Extension->bRawDevice &&\n\t\t\t\t\t\t(pStoragePropQuery->PropertyId == (STORAGE_PROPERTY_ID) StorageDeviceLBProvisioningProperty)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: sending IOCTL_STORAGE_QUERY_PROPERTY (%d) to device\\n\", (int) pStoragePropQuery->PropertyId);\n\t\t\t\t\tIrp->IoStatus.Status = ZwDeviceIoControlFile (\n\t\t\t\t\t\tExtension->hDeviceFile,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\tIOCTL_STORAGE_QUERY_PROPERTY,\n\t\t\t\t\t\tIrp->AssociatedIrp.SystemBuffer,\n\t\t\t\t\t\tirpSp->Parameters.DeviceIoControl.InputBufferLength,\n\t\t\t\t\t\tIrp->AssociatedIrp.SystemBuffer,\n\t\t\t\t\t\tirpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: ZwDeviceIoControlFile returned 0x%.8X\\n\", (DWORD) Irp->IoStatus.Status);\n\t\t\t\t\tif (Irp->IoStatus.Status == STATUS_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\tIrp->IoStatus.Status = IoStatus.Status;\n\t\t\t\t\t\tIrp->IoStatus.Information = IoStatus.Information;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (\t(pStoragePropQuery->PropertyId == StorageAccessAlignmentProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageDeviceProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageAdapterProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageDeviceSeekPenaltyProperty)\n\t\t\t\t\t||\t(pStoragePropQuery->PropertyId == StorageDeviceTrimProperty)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tif (type == PropertyExistsQuery)\n\t\t\t\t\t{\n\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (type == PropertyStandardQuery)\n\t\t\t\t\t{\n\t\t\t\t\t\tULONG descriptorSize;\n\t\t\t\t\t\tswitch (pStoragePropQuery->PropertyId)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase StorageDeviceProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceProperty\\n\");\n\t\t\t\t\t\t\t\t\t/* Add 0x00 for NULL terminating string used as ProductId, ProductRevision, SerialNumber, VendorId */\n\t\t\t\t\t\t\t\t\tdescriptorSize = sizeof (STORAGE_DEVICE_DESCRIPTOR) + 1;\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, descriptorSize, ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DEVICE_DESCRIPTOR outputBuffer = (PSTORAGE_DEVICE_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->DeviceType = FILE_DEVICE_DISK;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->RemovableMedia = Extension->bRemovable? TRUE : FALSE;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->ProductIdOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->SerialNumberOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->ProductRevisionOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->VendorIdOffset = sizeof (STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BusType = BusTypeVirtual;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = descriptorSize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageAdapterProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageAdapterProperty\\n\");\n\t\t\t\t\t\t\t\t\tdescriptorSize = sizeof (STORAGE_ADAPTER_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, descriptorSize, ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_ADAPTER_DESCRIPTOR outputBuffer = (PSTORAGE_ADAPTER_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->MaximumTransferLength = Extension->HostMaximumTransferLength;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->MaximumPhysicalPages = Extension->HostMaximumPhysicalPages;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->AlignmentMask = Extension->HostAlignmentMask;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BusType = BusTypeVirtual;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = descriptorSize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = descriptorSize;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageAccessAlignmentProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageAccessAlignmentProperty\\n\");\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR), ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR outputBuffer = (PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BytesPerLogicalSector = Extension->BytesPerSector;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->BytesPerPhysicalSector = Extension->HostBytesPerPhysicalSector;\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageDeviceSeekPenaltyProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceSeekPenaltyProperty\\n\");\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DEVICE_SEEK_PENALTY_DESCRIPTOR), ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPDEVICE_SEEK_PENALTY_DESCRIPTOR outputBuffer = (PDEVICE_SEEK_PENALTY_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceSeekPenaltyProperty: set IncursSeekPenalty to %s\\n\", Extension->IncursSeekPenalty? \"TRUE\" : \"FALSE\");\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->IncursSeekPenalty = (BOOLEAN) Extension->IncursSeekPenalty;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_SEEK_PENALTY_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase StorageDeviceTrimProperty:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceTrimProperty\\n\");\n\t\t\t\t\t\t\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DEVICE_TRIM_DESCRIPTOR), ValidateOutput))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPDEVICE_TRIM_DESCRIPTOR outputBuffer = (PDEVICE_TRIM_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\tDump (\"IOCTL_STORAGE_QUERY_PROPERTY - StorageDeviceTrimProperty: set TrimEnabled to %s\\n\", Extension->TrimEnabled? \"TRUE\" : \"FALSE\");\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->TrimEnabled = (BOOLEAN) Extension->TrimEnabled;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof (STORAGE_DESCRIPTOR_HEADER))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPSTORAGE_DESCRIPTOR_HEADER outputBuffer = (PSTORAGE_DESCRIPTOR_HEADER) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Version = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\toutputBuffer->Size = sizeof(DEVICE_TRIM_DESCRIPTOR);\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DESCRIPTOR_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_PARTITION_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_PARTITION_INFO)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION), ValidateOutput))\n\t\t{\n\t\t\tPPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->PartitionType = Extension->PartitionType;\n\t\t\toutputBuffer->BootIndicator = FALSE;\n\t\t\toutputBuffer->RecognizedPartition = TRUE;\n\t\t\toutputBuffer->RewritePartition = FALSE;\n\t\t\toutputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\toutputBuffer->PartitionLength.QuadPart= Extension->DiskLength;\n\t\t\toutputBuffer->PartitionNumber = 1;\n\t\t\toutputBuffer->HiddenSectors = 0;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (PARTITION_INFORMATION);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_PARTITION_INFO_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_PARTITION_INFO_EX)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (PARTITION_INFORMATION_EX), ValidateOutput))\n\t\t{\n\t\t\tPPARTITION_INFORMATION_EX outputBuffer = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\toutputBuffer->RewritePartition = FALSE;\n\t\t\toutputBuffer->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\toutputBuffer->PartitionLength.QuadPart= Extension->DiskLength;\n\t\t\toutputBuffer->PartitionNumber = 1;\n\t\t\toutputBuffer->Mbr.PartitionType = Extension->PartitionType;\n\t\t\toutputBuffer->Mbr.BootIndicator = FALSE;\n\t\t\toutputBuffer->Mbr.RecognizedPartition = TRUE;\n\t\t\toutputBuffer->Mbr.HiddenSectors = 0;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (PARTITION_INFORMATION_EX);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_DRIVE_LAYOUT:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_LAYOUT)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION), ValidateOutput))\n\t\t{\n\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\tBOOL bFullBuffer = (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= (sizeof (DRIVE_LAYOUT_INFORMATION) + 3*sizeof(PARTITION_INFORMATION)))? TRUE : FALSE;\n\t\t\tPDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION)\n\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->PartitionCount = bFullBuffer? 4 : 1;\n\t\t\toutputBuffer->Signature = GetCrc32((unsigned char*) &(Extension->UniqueVolumeId), 4);\n\n\t\t\toutputBuffer->PartitionEntry->PartitionType = Extension->PartitionType;\n\t\t\toutputBuffer->PartitionEntry->BootIndicator = FALSE;\n\t\t\toutputBuffer->PartitionEntry->RecognizedPartition = TRUE;\n\t\t\toutputBuffer->PartitionEntry->RewritePartition = FALSE;\n\t\t\toutputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\toutputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;\n\t\t\toutputBuffer->PartitionEntry->PartitionNumber = 1;\n\t\t\toutputBuffer->PartitionEntry->HiddenSectors = 0;\t\t\t\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (DRIVE_LAYOUT_INFORMATION);\n\t\t\tif (bFullBuffer)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information += 3*sizeof(PARTITION_INFORMATION);\n\t\t\t\tmemset (((BYTE*) Irp->AssociatedIrp.SystemBuffer) + sizeof (DRIVE_LAYOUT_INFORMATION), 0, 3*sizeof(PARTITION_INFORMATION));\n\t\t\t}\t\t\t\t\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_DRIVE_LAYOUT_EX:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_DRIVE_LAYOUT_EX)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DRIVE_LAYOUT_INFORMATION_EX), ValidateOutput))\n\t\t\t{\n\t\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\t\tBOOL bFullBuffer = (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= (sizeof (DRIVE_LAYOUT_INFORMATION_EX) + 3*sizeof(PARTITION_INFORMATION_EX)))? TRUE : FALSE;\n\t\t\t\tPDRIVE_LAYOUT_INFORMATION_EX outputBuffer = (PDRIVE_LAYOUT_INFORMATION_EX)\n\t\t\t\tIrp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\toutputBuffer->PartitionCount = bFullBuffer? 4 : 1;\n\t\t\t\toutputBuffer->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\t\toutputBuffer->Mbr.Signature = GetCrc32((unsigned char*) &(Extension->UniqueVolumeId), 4);\n\n\t\t\t\toutputBuffer->PartitionEntry->PartitionStyle = PARTITION_STYLE_MBR;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.BootIndicator = FALSE;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.RecognizedPartition = TRUE;\n\t\t\t\toutputBuffer->PartitionEntry->RewritePartition = FALSE;\n\t\t\t\toutputBuffer->PartitionEntry->StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\t\toutputBuffer->PartitionEntry->PartitionLength.QuadPart = Extension->DiskLength;\n\t\t\t\toutputBuffer->PartitionEntry->PartitionNumber = 1;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.HiddenSectors = 0;\n\t\t\t\toutputBuffer->PartitionEntry->Mbr.PartitionType = Extension->PartitionType;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (DRIVE_LAYOUT_INFORMATION_EX);\n\t\t\t\tif (bFullBuffer)\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Information += 3*sizeof(PARTITION_INFORMATION_EX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_LENGTH_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_GET_LENGTH_INFO)\\n\");\n\t\tif (!ValidateIOBufferSize (Irp, sizeof (GET_LENGTH_INFORMATION), ValidateOutput))\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\tIrp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPGET_LENGTH_INFORMATION outputBuffer = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\toutputBuffer->Length.QuadPart = Extension->DiskLength;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (GET_LENGTH_INFORMATION);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_VERIFY:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_VERIFY)\\n\");\n\t\tif (ValidateIOBufferSize (Irp, sizeof (VERIFY_INFORMATION), ValidateInput))\n\t\t{\n\t\t\tHRESULT hResult;\n\t\t\tULONGLONG ullStartingOffset, ullNewOffset, ullEndOffset;\n\t\t\tPVERIFY_INFORMATION pVerifyInformation;\n\t\t\tpVerifyInformation = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tullStartingOffset = (ULONGLONG) pVerifyInformation->StartingOffset.QuadPart;\n\t\t\thResult = ULongLongAdd(ullStartingOffset,\n\t\t\t\t(ULONGLONG) Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset,\n\t\t\t\t&ullNewOffset);\n\t\t\tif (hResult != S_OK)\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\telse if (S_OK != ULongLongAdd(ullStartingOffset, (ULONGLONG) pVerifyInformation->Length, &ullEndOffset))\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\telse if (ullEndOffset > (ULONGLONG) Extension->DiskLength)\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\telse\n\t\t\t{\n\t\t\t\tIO_STATUS_BLOCK ioStatus;\n\t\t\t\tPVOID buffer = TCalloc (max (pVerifyInformation->Length, PAGE_SIZE));\n\n\t\t\t\tif (!buffer)\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLARGE_INTEGER offset = pVerifyInformation->StartingOffset;\n\t\t\t\t\toffset.QuadPart = ullNewOffset;\n\n\t\t\t\t\tIrp->IoStatus.Status = ZwReadFile (Extension->hDeviceFile, NULL, NULL, NULL, &ioStatus, buffer, pVerifyInformation->Length, &offset, NULL);\n\t\t\t\t\tTCfree (buffer);\n\n\t\t\t\t\tif (NT_SUCCESS (Irp->IoStatus.Status) && ioStatus.Information != pVerifyInformation->Length)\n\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_CHECK_VERIFY:\n\tcase IOCTL_STORAGE_CHECK_VERIFY:\n\tcase IOCTL_STORAGE_CHECK_VERIFY2:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_CHECK_VERIFY)\\n\");\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t\tif (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof (ULONG))\n\t\t\t{\n\t\t\t\t*((ULONG *) Irp->AssociatedIrp.SystemBuffer) = 0;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ULONG);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_IS_WRITABLE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_IS_WRITABLE)\\n\");\n\t\t{\n\t\t\tif (Extension->bReadOnly)\n\t\t\t\tIrp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;\n\t\t\telse\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_ONLINE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_ONLINE)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_POST_ONLINE:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_POST_ONLINE)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS)\\n\");\n\t\t// Vista's, Windows 8.1 and later filesystem defragmenter fails if IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS does not succeed.\n\t\tif (!(OsMajorVersion == 6 && OsMinorVersion == 0) \n\t\t\t&& !(IsOSAtLeast (WIN_8_1) && AllowWindowsDefrag && Extension->bRawDevice)\n\t\t\t)\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\telse if (ValidateIOBufferSize (Irp, sizeof (VOLUME_DISK_EXTENTS), ValidateOutput))\n\t\t{\n\t\t\tVOLUME_DISK_EXTENTS *extents = (VOLUME_DISK_EXTENTS *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\n\n\t\t\tif (IsOSAtLeast (WIN_8_1))\n\t\t\t{\n\t\t\t\t// Windows 10 filesystem defragmenter works only if we report an extent with a real disk number\n\t\t\t\t// So in the case of a VeraCrypt disk based volume, we use the disk number\n\t\t\t\t// of the underlaying physical disk and we report a single extent \n\t\t\t\textents->NumberOfDiskExtents = 1;\n\t\t\t\textents->Extents[0].DiskNumber = Extension->DeviceNumber;\n\t\t\t\textents->Extents[0].StartingOffset.QuadPart = Extension->BytesPerSector;\n\t\t\t\textents->Extents[0].ExtentLength.QuadPart = Extension->DiskLength;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Vista: No extent data can be returned as this is not a physical drive.\t\t\t\t\n\t\t\t\tmemset (extents, 0, sizeof (*extents));\n\t\t\t\textents->NumberOfDiskExtents = 0;\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (*extents);\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_READ_CAPACITY:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_READ_CAPACITY)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_READ_CAPACITY), ValidateOutput))\n\t\t\t{\n\t\t\t\tSTORAGE_READ_CAPACITY *capacity = (STORAGE_READ_CAPACITY *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tcapacity->Version = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\tcapacity->Size = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\tcapacity->BlockLength = Extension->BytesPerSector;\n\t\t\t\tcapacity->NumberOfBlocks.QuadPart = (Extension->DiskLength / Extension->BytesPerSector) + 1;\n\t\t\t\tcapacity->DiskLength.QuadPart = Extension->DiskLength + Extension->BytesPerSector;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t/*case IOCTL_STORAGE_GET_DEVICE_NUMBER:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_GET_DEVICE_NUMBER)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_DEVICE_NUMBER), ValidateOutput))\n\t\t\t{\n\t\t\t\tSTORAGE_DEVICE_NUMBER *storage = (STORAGE_DEVICE_NUMBER *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tstorage->DeviceType = FILE_DEVICE_DISK;\n\t\t\t\tstorage->DeviceNumber = (ULONG) -1;\n\t\t\t\tstorage->PartitionNumber = 1;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_DEVICE_NUMBER);\n\t\t\t}\n\t\t}\n\t\tbreak;*/\n\n\tcase IOCTL_STORAGE_GET_HOTPLUG_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_STORAGE_GET_HOTPLUG_INFO)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (STORAGE_HOTPLUG_INFO), ValidateOutput))\n\t\t\t{\n\t\t\t\tSTORAGE_HOTPLUG_INFO *info = (STORAGE_HOTPLUG_INFO *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tinfo->Size = sizeof (STORAGE_HOTPLUG_INFO);\n\t\t\t\tinfo->MediaRemovable = Extension->bRemovable? TRUE : FALSE;\n\t\t\t\tinfo->MediaHotplug = FALSE;\n\t\t\t\tinfo->DeviceHotplug = FALSE;\n\t\t\t\tinfo->WriteCacheEnableOverride = FALSE;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (STORAGE_HOTPLUG_INFO);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_IS_DYNAMIC:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_IS_DYNAMIC)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (BOOLEAN), ValidateOutput))\n\t\t\t{\n\t\t\t\tBOOLEAN *pbDynamic = (BOOLEAN*) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t*pbDynamic = FALSE;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (BOOLEAN);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_DISK_IS_CLUSTERED:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_DISK_IS_CLUSTERED)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (BOOLEAN), ValidateOutput))\n\t\t\t{\n\t\t\t\tBOOLEAN *pbIsClustered = (BOOLEAN*) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\t*pbIsClustered = FALSE;\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (BOOLEAN);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_VOLUME_GET_GPT_ATTRIBUTES:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (IOCTL_VOLUME_GET_GPT_ATTRIBUTES)\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (VOLUME_GET_GPT_ATTRIBUTES_INFORMATION), ValidateOutput))\n\t\t\t{\n\t\t\t\tVOLUME_GET_GPT_ATTRIBUTES_INFORMATION *pGptAttr = (VOLUME_GET_GPT_ATTRIBUTES_INFORMATION*) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\t\tpGptAttr->GptAttributes = 0; // we are MBR not GPT\n\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (VOLUME_GET_GPT_ATTRIBUTES_INFORMATION);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_UNKNOWN_WINDOWS10_EFS_ACCESS:\n\t\t// This undocumented IOCTL is sent when handling EFS data\n\t\t// We must return success otherwise EFS operations fail\n\t\tDump (\"ProcessVolumeDeviceControlIrp (unknown IOCTL 0x%.8X, OutputBufferLength = %d). Returning fake success\\n\", irpSp->Parameters.DeviceIoControl.IoControlCode, (int) irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_UPDATE_PROPERTIES:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_SUCCESS for IOCTL_DISK_UPDATE_PROPERTIES\\n\");\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_MEDIA_REMOVAL:\n\tcase IOCTL_STORAGE_MEDIA_REMOVAL:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_SUCCESS for %ls\\n\", TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode));\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\n\t\tbreak;\n\n\tcase IOCTL_DISK_GET_CLUSTER_INFO:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_NOT_SUPPORTED for %ls\\n\", TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode));\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (EnableExtendedIoctlSupport)\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\tbreak;\n\n\tcase IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES\\n\");\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\n\t\tif (Extension->bRawDevice && Extension->TrimEnabled)\n\t\t{\n\t\t\tif (ValidateIOBufferSize (Irp, sizeof (DEVICE_MANAGE_DATA_SET_ATTRIBUTES), ValidateInput))\n\t\t\t{\n\t\t\t\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\t\t\t\tDWORD inputLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;\n\t\t\t\tPDEVICE_MANAGE_DATA_SET_ATTRIBUTES pInputAttrs = (PDEVICE_MANAGE_DATA_SET_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t\tDEVICE_DATA_MANAGEMENT_SET_ACTION action = pInputAttrs->Action;\n\t\t\t\tBOOL bEntireSet = pInputAttrs->Flags & DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE? TRUE : FALSE;\n\t\t\t\tULONGLONG minSizedataSet = (ULONGLONG) pInputAttrs->DataSetRangesOffset + (ULONGLONG) pInputAttrs->DataSetRangesLength;\n\t\t\t\tULONGLONG minSizeParameter = (ULONGLONG) pInputAttrs->ParameterBlockOffset + (ULONGLONG) pInputAttrs->ParameterBlockLength;\n\t\t\t\tULONGLONG minSizeGeneric = sizeof(DEVICE_MANAGE_DATA_SET_ATTRIBUTES) + (ULONGLONG) pInputAttrs->ParameterBlockLength + (ULONGLONG) pInputAttrs->DataSetRangesLength;\n\t\t\t\tPDEVICE_MANAGE_DATA_SET_ATTRIBUTES pNewSetAttrs = NULL;\n\t\t\t\tULONG ulNewInputLength = 0;\n\t\t\t\tBOOL bForwardIoctl = FALSE;\n\n\t\t\t\tif (inputLength >= minSizeGeneric && inputLength >= minSizedataSet && inputLength >= minSizeParameter)\n\t\t\t\t{\n\t\t\t\t\tif (bEntireSet)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (minSizedataSet)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE set but data set range specified=> Error.\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDWORD dwDataSetOffset = ALIGN_VALUE (inputLength, sizeof(DEVICE_DATA_SET_RANGE));\n\t\t\t\t\t\t\tDWORD dwDataSetLength = sizeof(DEVICE_DATA_SET_RANGE);\n\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE set. Setting data range to all volume.\\n\");\n\n\t\t\t\t\t\t\tulNewInputLength = dwDataSetOffset + dwDataSetLength;\n\t\t\t\t\t\t\tpNewSetAttrs = (PDEVICE_MANAGE_DATA_SET_ATTRIBUTES) TCalloc (ulNewInputLength);\n\t\t\t\t\t\t\tif (pNewSetAttrs)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPDEVICE_DATA_SET_RANGE pRange = (PDEVICE_DATA_SET_RANGE) (((unsigned char*) pNewSetAttrs) + dwDataSetOffset);\n\n\t\t\t\t\t\t\t\tmemcpy (pNewSetAttrs, pInputAttrs, inputLength);\n\n\t\t\t\t\t\t\t\tpRange->StartingOffset = (ULONGLONG) Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset;\n\t\t\t\t\t\t\t\tpRange->LengthInBytes = Extension->DiskLength;\n\n\t\t\t\t\t\t\t\tpNewSetAttrs->Size = sizeof(DEVICE_MANAGE_DATA_SET_ATTRIBUTES);\n\t\t\t\t\t\t\t\tpNewSetAttrs->Action = action;\n\t\t\t\t\t\t\t\tpNewSetAttrs->Flags = pInputAttrs->Flags & (~DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE);\n\t\t\t\t\t\t\t\tpNewSetAttrs->ParameterBlockOffset = pInputAttrs->ParameterBlockOffset;\n\t\t\t\t\t\t\t\tpNewSetAttrs->ParameterBlockLength = pInputAttrs->ParameterBlockLength;\n\t\t\t\t\t\t\t\tpNewSetAttrs->DataSetRangesOffset = dwDataSetOffset;\n\t\t\t\t\t\t\t\tpNewSetAttrs->DataSetRangesLength = dwDataSetLength;\n\n\t\t\t\t\t\t\t\tbForwardIoctl = TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - Failed to allocate memory.\\n\");\n\t\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - creating new data set range from input range.\\n\");\n\t\t\t\t\t\tulNewInputLength = inputLength;\n\t\t\t\t\t\tpNewSetAttrs = (PDEVICE_MANAGE_DATA_SET_ATTRIBUTES) TCalloc (inputLength);\n\t\t\t\t\t\tif (pNewSetAttrs)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPDEVICE_DATA_SET_RANGE pNewRanges = (PDEVICE_DATA_SET_RANGE) (((unsigned char*) pNewSetAttrs) + pInputAttrs->DataSetRangesOffset);\n\t\t\t\t\t\t\tPDEVICE_DATA_SET_RANGE pInputRanges = (PDEVICE_DATA_SET_RANGE) (((unsigned char*) pInputAttrs) + pInputAttrs->DataSetRangesOffset);\n\t\t\t\t\t\t\tDWORD dwInputRangesCount = 0, dwNewRangesCount = 0, i;\n\t\t\t\t\t\t\tULONGLONG ullStartingOffset, ullNewOffset, ullEndOffset;\n\t\t\t\t\t\t\tHRESULT hResult;\n\n\t\t\t\t\t\t\tmemcpy (pNewSetAttrs, pInputAttrs, inputLength);\n\n\t\t\t\t\t\t\tdwInputRangesCount = pInputAttrs->DataSetRangesLength / sizeof(DEVICE_DATA_SET_RANGE);\n\n\t\t\t\t\t\t\tfor (i = 0; i < dwInputRangesCount; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tullStartingOffset = (ULONGLONG) pInputRanges[i].StartingOffset;\n\t\t\t\t\t\t\t\thResult = ULongLongAdd(ullStartingOffset,\n\t\t\t\t\t\t\t\t\t(ULONGLONG) Extension->cryptoInfo->hiddenVolume ? Extension->cryptoInfo->hiddenVolumeOffset : Extension->cryptoInfo->volDataAreaOffset,\n\t\t\t\t\t\t\t\t\t&ullNewOffset);\n\t\t\t\t\t\t\t\tif (hResult != S_OK)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\telse if (S_OK != ULongLongAdd(ullStartingOffset, (ULONGLONG) pInputRanges[i].LengthInBytes, &ullEndOffset))\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\telse if (ullEndOffset > (ULONGLONG) Extension->DiskLength)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\telse if (ullNewOffset > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpNewRanges[dwNewRangesCount].StartingOffset = (LONGLONG) ullNewOffset;\n\t\t\t\t\t\t\t\t\tpNewRanges[dwNewRangesCount].LengthInBytes = pInputRanges[i].LengthInBytes;\n\n\t\t\t\t\t\t\t\t\tdwNewRangesCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - %d valid range processed from %d range in input.\\n\", (int) dwNewRangesCount, (int) dwInputRangesCount);\n\n\t\t\t\t\t\t\tpNewSetAttrs->DataSetRangesLength = dwNewRangesCount * sizeof (DEVICE_DATA_SET_RANGE);\n\n\t\t\t\t\t\t\tbForwardIoctl = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - Failed to allocate memory.\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - buffer containing DEVICE_MANAGE_DATA_SET_ATTRIBUTES has invalid length.\\n\");\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\n\n\t\t\t\tif (bForwardIoctl)\n\t\t\t\t{\n\t\t\t\t\tif (action == DeviceDsmAction_Trim)\n\t\t\t\t\t{\n\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Trim.\\n\");\n\n\t\t\t\t\t\tif (Extension->cryptoInfo->hiddenVolume || !AllowTrimCommand)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: TRIM command filtered\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: sending TRIM to device\\n\");\n\t\t\t\t\t\t\tIrp->IoStatus.Status = ZwDeviceIoControlFile (\n\t\t\t\t\t\t\t\tExtension->hDeviceFile,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\tIOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES,\n\t\t\t\t\t\t\t\t(PVOID) pNewSetAttrs,\n\t\t\t\t\t\t\t\tulNewInputLength,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t0);\n\t\t\t\t\t\t\tDump (\"ProcessVolumeDeviceControlIrp: ZwDeviceIoControlFile returned 0x%.8X\\n\", (DWORD) Irp->IoStatus.Status);\n\t\t\t\t\t\t\tif (Irp->IoStatus.Status == STATUS_SUCCESS)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tIrp->IoStatus.Status = IoStatus.Status;\n\t\t\t\t\t\t\t\tIrp->IoStatus.Information = IoStatus.Information;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DeviceDsmAction_Notification: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Notification\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_OffloadRead: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_OffloadRead\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_OffloadWrite: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_OffloadWrite\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_Allocation: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Allocation\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_Scrub: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_Scrub\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_DrtQuery: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_DrtQuery\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_DrtClear: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_DrtClear\\n\"); break;\n\t\t\t\t\t\t\tcase DeviceDsmAction_DrtDisable: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - DeviceDsmAction_DrtDisable\\n\"); break;\n\t\t\t\t\t\t\tdefault: Dump (\"ProcessVolumeDeviceControlIrp: IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES - unknown action %d\\n\", (int) action); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pNewSetAttrs)\n\t\t\t\t\tTCfree (pNewSetAttrs);\n\t\t\t}\n\t\t}\n#if defined (DEBUG) || defined (DEBUG_TRACE)\n\t\telse\n\t\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_INVALID_DEVICE_REQUEST for IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES\\n\");\n#endif\n\t\tbreak;\n\t\n\tcase IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT:\n\tcase IOCTL_VOLUME_QUERY_ALLOCATION_HINT:\n\tcase FT_BALANCED_READ_MODE:\n\tcase IOCTL_STORAGE_GET_DEVICE_NUMBER:\n\tcase IOCTL_MOUNTDEV_LINK_CREATED:\n\t\tDump (\"ProcessVolumeDeviceControlIrp: returning STATUS_INVALID_DEVICE_REQUEST for %ls\\n\", TCTranslateCode (irpSp->Parameters.DeviceIoControl.IoControlCode));\n\t\tIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\tIrp->IoStatus.Information = 0;\t\t\n\t\tbreak;\n\tdefault:\n\t\tDump (\"ProcessVolumeDeviceControlIrp (unknown code 0x%.8X)\\n\", irpSp->Parameters.DeviceIoControl.IoControlCode);\n\t\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n\t}\n\n#if defined(DEBUG) || defined (DEBG_TRACE)\n\tif (!NT_SUCCESS (Irp->IoStatus.Status))\n\t{\n\t\tDump (\"IOCTL error 0x%08x (0x%x %d)\\n\",\n\t\t\tIrp->IoStatus.Status,\n\t\t\t(int) (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16),\n\t\t\t(int) ((irpSp->Parameters.DeviceIoControl.IoControlCode & 0x1FFF) >> 2));\n\t}\n#endif\n\n\treturn TCCompleteDiskIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);\n}\n\n\nNTSTATUS ProcessMainDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, PIRP Irp)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\tNTSTATUS ntStatus;\n\n\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t{\n\tcase TC_IOCTL_GET_DRIVER_VERSION:\n\tcase TC_IOCTL_LEGACY_GET_DRIVER_VERSION:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))\n\t\t{\n\t\t\tLONG tmp = VERSION_NUM;\n\t\t\tmemcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);\n\t\t\tIrp->IoStatus.Information = sizeof (LONG);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DEVICE_REFCOUNT:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tLONG deviceObjectCount = 0;\n\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;\n\n\t\t\tif (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_ANY_VOLUME_MOUNTED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tint drive;\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tif (GetVirtualVolumeDeviceObject (drive))\n\t\t\t\t{\n\t\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (IsBootDriveMounted())\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_OPEN_TEST:\n\t\t{\n\t\t\tOPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tACCESS_MASK access = FILE_READ_ATTRIBUTES;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\tEnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));\n\t\t\tRtlInitUnicodeString (&FullFileName, opentest->wszFileName);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\taccess |= FILE_READ_DATA;\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\t\t\t SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\t\t\t 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\topentest->TCBootLoaderDetected = FALSE;\n\t\t\t\topentest->FilesystemDetected = FALSE;\n\t\t\t\tmemset (opentest->VolumeIDComputed, 0, sizeof (opentest->VolumeIDComputed));\n\t\t\t\tmemset (opentest->volumeIDs, 0, sizeof (opentest->volumeIDs));\n\n\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\t{\n\t\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\t\tif (!readBuffer)\n\t\t\t\t\t{\n\t\t\t\t\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Determine if the first sector contains a portion of the VeraCrypt Boot Loader\n\n\t\t\t\t\t\t\toffset.QuadPart = 0;\n\n\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t\tif (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Search for the string \"VeraCrypt\"\n\t\t\t\t\t\t\t\t\tfor (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\topentest->TCBootLoaderDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tswitch (BE64 (*(uint64 *) readBuffer))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase 0xEB52904E54465320ULL: // NTFS\n\t\t\t\t\t\t\t\t\tcase 0xEB3C904D53444F53ULL: // FAT16/FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB58904D53444F53ULL: // FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB76904558464154ULL: // exFAT\n\t\t\t\t\t\t\t\t\tcase 0x0000005265465300ULL: // ReFS\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B66732EULL: // FAT32 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B646F73ULL: // FAT32 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B66732EULL: // FAT16/FAT12 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B646F73ULL: // FAT16/FAT12 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 0x0000000000000000ULL:\n\t\t\t\t\t\t\t\t\t\t// all 512 bytes are zeroes => unencrypted filesystem like Microsoft reserved partition\n\t\t\t\t\t\t\t\t\t\tif (IsAllZeroes (readBuffer + 8, TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8))\n\t\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opentest->bComputeVolumeIDs && (!opentest->DetectFilesystem || !opentest->FilesystemDetected))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint volumeType;\n\t\t\t\t\t\t\t// Go through all volume types (e.g., normal, hidden)\n\t\t\t\t\t\t\tfor (volumeType = TC_VOLUME_TYPE_NORMAL;\n\t\t\t\t\t\t\t\tvolumeType < TC_VOLUME_TYPE_COUNT;\n\t\t\t\t\t\t\t\tvolumeType++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Read the volume header */\n\t\t\t\t\t\t\t\tswitch (volumeType)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_NORMAL:\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_HIDDEN:\n\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/* compute the ID of this volume: SHA-256 of the effective header */\n\t\t\t\t\t\t\t\t\tsha256 (opentest->volumeIDs[volumeType], readBuffer, TC_VOLUME_HEADER_EFFECTIVE_SIZE);\n\t\t\t\t\t\t\t\t\topentest->VolumeIDComputed[volumeType] = TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tTCfree (readBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\t\t\t\tDump (\"Open test on file %ls success.\\n\", opentest->wszFileName);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#if 0\n\t\t\t\tDump (\"Open test on file %ls failed NTSTATUS 0x%08x\\n\", opentest->wszFileName, ntStatus);\n#endif\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;\n\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:\n\t\t{\n\t\t\tGetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tsize_t devicePathLen = 0;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\t// check that request->DevicePath has the expected format \"\\\\Device\\\\HarddiskXXX\\\\Partition0\"\n\t\t\tif (\t!NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))\n\t\t\t\t||\t(devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum\n\t\t\t\t||\t(devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum\n\t\t\t\t||\t(memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))\n\t\t\t\t||\t(memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));\n\t\t\tRtlInitUnicodeString (&FullFileName, request->DevicePath);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\tSYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\tFILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\tif (!readBuffer)\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Determine if the first sector contains a portion of the VeraCrypt Boot Loader\n\t\t\t\t\toffset.QuadPart = 0;\t// MBR\n\n\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t&offset,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\t// check that we could read all needed data\n\t\t\t\t\t\tif (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t// Check for dynamic drive\n\t\t\t\t\t\t\trequest->DriveIsDynamic = FALSE;\n\n\t\t\t\t\t\t\tif (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint i;\n\t\t\t\t\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequest->DriveIsDynamic = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trequest->BootLoaderVersion = 0;\n\t\t\t\t\t\t\trequest->Configuration = 0;\n\t\t\t\t\t\t\trequest->UserConfiguration = 0;\n\t\t\t\t\t\t\trequest->CustomUserMessage[0] = 0;\n\n\t\t\t\t\t\t\t// Search for the string \"VeraCrypt\"\n\t\t\t\t\t\t\tfor (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trequest->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));\n\t\t\t\t\t\t\t\t\trequest->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];\n\n\t\t\t\t\t\t\t\t\tif (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequest->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];\n\t\t\t\t\t\t\t\t\t\tmemcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tTCfree (readBuffer);\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_WIPE_PASSWORD_CACHE:\n\t\tWipeCache ();\n\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tIrp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tif (!UserCanAccessDriveDevice())\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPortableMode = TRUE;\n\t\t\tDump (\"Setting portable mode\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tIrp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))\n\t\t{\n\t\t\tMOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice;\n\t\t\tint drive;\n\n\t\t\tlist->ulMountedDrives = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension;\n\n\t\t\t\tListDevice = GetVirtualVolumeDeviceObject (drive);\n\t\t\t\tif (!ListDevice)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tlist->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);\n\t\t\t\t\tRtlStringCbCopyW (list->wszVolume[ListExtension->nDosDriveNo], sizeof(list->wszVolume[ListExtension->nDosDriveNo]),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (list->wszLabel[ListExtension->nDosDriveNo], sizeof(list->wszLabel[ListExtension->nDosDriveNo]),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (list->volumeID[ListExtension->nDosDriveNo], ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tlist->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;\n\t\t\t\t\tlist->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tif (ListExtension->cryptoInfo->hiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;\t// Hidden volume\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;\t// Normal/outer volume (hidden volume protected AND write already prevented)\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;\t// Normal/outer volume (hidden volume protected)\n\t\t\t\t\telse\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;\t// Normal volume\n\t\t\t\t\tlist->truecryptMode[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->bTrueCryptMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))\n\t\t{\n\t\t\t// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.\n\t\t\t// The user could render the system unbootable by downgrading when boot encryption\n\t\t\t// is active or being set up.\n\n\t\t\tmemset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\t*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_VOLUME_PROPERTIES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tVOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);\n\n\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tprop->uniqueId = ListExtension->UniqueVolumeId;\n\t\t\t\t\tRtlStringCbCopyW (prop->wszVolume, sizeof(prop->wszVolume),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (prop->wszLabel, sizeof(prop->wszLabel),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (prop->volumeID, ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tprop->bDriverSetLabel = ListExtension->bDriverSetLabel;\n\t\t\t\t\tprop->diskLength = ListExtension->DiskLength;\n\t\t\t\t\tprop->ea = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tprop->mode = ListExtension->cryptoInfo->mode;\n\t\t\t\t\tprop->pkcs5 = ListExtension->cryptoInfo->pkcs5;\n\t\t\t\t\tprop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;\n\t\t\t\t\tprop->volumePim = ListExtension->cryptoInfo->volumePim;\n#if 0\n\t\t\t\t\tprop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;\n\t\t\t\t\tprop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;\n#endif\n\t\t\t\t\tprop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;\n\t\t\t\t\tprop->readOnly = ListExtension->bReadOnly;\n\t\t\t\t\tprop->removable = ListExtension->bRemovable;\n\t\t\t\t\tprop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;\n\t\t\t\t\tprop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;\n\n\t\t\t\t\tif (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tprop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;\n\t\t\t\t\telse\n\t\t\t\t\t\tprop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;\n\n\t\t\t\t\tprop->totalBytesRead = ListExtension->Queue.TotalBytesRead;\n\t\t\t\t\tprop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;\n\n\t\t\t\t\tprop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;\n\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tRESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));\n\n\t\t\t\tntStatus = SymbolicLinkToTarget (resolve->symLinkName,\n\t\t\t\t\tresolve->targetName,\n\t\t\t\t\tsizeof (resolve->targetName));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tPARTITION_INFORMATION_EX pi;\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));\n\n\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));\n\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t{\n\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\n\t\t\t\t\tinfo->partInfo.PartitionLength = pi.PartitionLength;\n\t\t\t\t\tinfo->partInfo.PartitionNumber = pi.PartitionNumber;\n\t\t\t\t\tinfo->partInfo.StartingOffset = pi.StartingOffset;\n\n\t\t\t\t\tif (pi.PartitionStyle == PARTITION_STYLE_MBR)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo->partInfo.PartitionType = pi.Mbr.PartitionType;\n\t\t\t\t\t\tinfo->partInfo.BootIndicator = pi.Mbr.BootIndicator;\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));\n\t\t\t\t\tinfo->IsGPT = FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\t\t{\n\t\t\t\t\tGET_LENGTH_INFORMATION lengthInfo;\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));\n\n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\t\t\t\t\t\tinfo->partInfo.PartitionLength = lengthInfo.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinfo->IsDynamic = FALSE;\n\n\t\t\t\tif (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)\n\t\t\t\t{\n#\t\t\t\t\tdefine IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\t\t\t\t\tif (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))\n\t\t\t\t\t\tinfo->IsDynamic = FALSE;\n\t\t\t\t}\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_GEOMETRY:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\n\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\tNULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_DRIVE_GEOMETRY_EX:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_EX_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_EX_STRUCT *g = (DISK_GEOMETRY_EX_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\t\t\t\tPVOID buffer = TCalloc (256); // enough for DISK_GEOMETRY_EX and padded data\n\t\t\t\tif (buffer)\n\t\t\t\t{\n\t\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY_EX on %ls\\n\", g->deviceName);\n\n\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY_EX,\n\t\t\t\t\t\tNULL, 0, buffer, 256);\n\n\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tPDISK_GEOMETRY_EX pGeo = (PDISK_GEOMETRY_EX) buffer;\n\t\t\t\t\t\tmemcpy (&g->diskGeometry, &pGeo->Geometry, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\tg->DiskSize.QuadPart = pGeo->DiskSize.QuadPart;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDISK_GEOMETRY dg = {0};\n\t\t\t\t\t\tDump (\"Failed. Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\t\t\tNULL, 0, &dg, sizeof (dg));\n\n\t\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy (&g->diskGeometry, &dg, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\t\tg->DiskSize.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;\n\n\t\t\t\t\t\t\tif (OsMajorVersion >= 6)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSTORAGE_READ_CAPACITY storage = {0};\n\t\t\t\t\t\t\t\tNTSTATUS lStatus;\n\t\t\t\t\t\t\t\tstorage.Version = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\t\t\t\t\tDump (\"Calling IOCTL_STORAGE_READ_CAPACITY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\t\t\tlStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\t\t\tIOCTL_STORAGE_READ_CAPACITY,\n\t\t\t\t\t\t\t\t\tNULL, 0, &storage, sizeof (STORAGE_READ_CAPACITY));\n\t\t\t\t\t\t\t\tif (\tNT_SUCCESS(lStatus)\n\t\t\t\t\t\t\t\t\t&& (storage.Size == sizeof (STORAGE_READ_CAPACITY))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tg->DiskSize.QuadPart = storage.DiskLength.QuadPart;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTCfree (buffer);\n\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX_STRUCT);\n\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_PROBE_REAL_DRIVE_SIZE:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))\n\t\t{\n\t\t\tProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tNTSTATUS status;\n\t\t\tUNICODE_STRING name;\n\t\t\tPFILE_OBJECT fileObject;\n\t\t\tPDEVICE_OBJECT deviceObject;\n\n\t\t\tEnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));\n\n\t\t\tRtlInitUnicodeString (&name, request->DeviceName);\n\t\t\tstatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);\n\t\t\tif (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);\n\t\t\tObDereferenceObject (fileObject);\n\n\t\t\tif (status == STATUS_TIMEOUT)\n\t\t\t{\n\t\t\t\trequest->TimeOut = TRUE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t}\n\t\t\telse if (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trequest->TimeOut = FALSE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_MOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tMOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tif (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD\n\t\t\t\t||\tmount->pkcs5_prf < 0 || mount->pkcs5_prf > LAST_PRF_ID\n\t\t\t\t||\tmount->VolumePim < -1 || mount->VolumePim == INT_MAX\n\t\t\t\t|| mount->ProtectedHidVolPkcs5Prf < 0 || mount->ProtectedHidVolPkcs5Prf > LAST_PRF_ID\n\t\t\t\t|| (mount->bTrueCryptMode != FALSE && mount->bTrueCryptMode != TRUE)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));\n\t\t\tEnsureNullTerminatedString (mount->wszLabel, sizeof (mount->wszLabel));\n\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = MountDevice (DeviceObject, mount);\n\n\t\t\tburn (&mount->VolumePassword, sizeof (mount->VolumePassword));\n\t\t\tburn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));\n\t\t\tburn (&mount->pkcs5_prf, sizeof (mount->pkcs5_prf));\n\t\t\tburn (&mount->VolumePim, sizeof (mount->VolumePim));\n\t\t\tburn (&mount->bTrueCryptMode, sizeof (mount->bTrueCryptMode));\n\t\t\tburn (&mount->ProtectedHidVolPkcs5Prf, sizeof (mount->ProtectedHidVolPkcs5Prf));\n\t\t\tburn (&mount->ProtectedHidVolPim, sizeof (mount->ProtectedHidVolPim));\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);\n\n\t\t\tunmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t\tunmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_ALL_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tunmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = AbortBootEncryptionSetup();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tGetBootEncryptionStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:\n\t\tIrp->IoStatus.Information = 0;\n\t\tIrp->IoStatus.Status = GetSetupResult();\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tGetBootDriveVolumeProperties (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_LOADER_VERSION:\n\t\tGetBootLoaderVersion (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:\n\t\tReopenBootVolumeHeader (Irp, irpSp);\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT:\n\t\tGetBootLoaderFingerprint (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:\n\t\tGetBootEncryptionAlgorithmName (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_START_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = AbortDecoySystemWipe();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:\n\t\tIrp->IoStatus.Status = GetDecoySystemWipeResult();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:\n\t\tGetDecoySystemWipeStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:\n\t\tIrp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_WARNING_FLAGS:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))\n\t\t{\n\t\t\tGetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tflags->PagingFileCreationPrevented = PagingFileCreationPrevented;\n\t\t\tPagingFileCreationPrevented = FALSE;\n\t\t\tflags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;\n\t\t\tSystemFavoriteVolumeDirty = FALSE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (GetWarningFlagsRequest);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:\n\t\tif (UserCanAccessDriveDevice())\n\t\t{\n\t\t\tSystemFavoriteVolumeDirty = TRUE;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\telse\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_REREAD_DRIVER_CONFIG:\n\t\tIrp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:\n\t\tif (\t(ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))\n\t\t\t&&\t(Irp->RequestorMode == KernelMode)\n\t\t\t)\n\t\t{\n\t\t\tGetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\trequest->BootDriveFilterExtension = GetBootDriveFilterExtension();\n\t\t\tif (IsBootDriveMounted() && request->BootDriveFilterExtension)\n\t\t\t{\n\t\t\t\trequest->HwEncryptionEnabled = IsHwEncryptionEnabled();\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n\t}\n\n\n#if defined(DEBUG) || defined(DEBUG_TRACE)\n\tif (!NT_SUCCESS (Irp->IoStatus.Status))\n\t{\n\t\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\t\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_OPEN_TEST:\n\t\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDump (\"IOCTL error 0x%08x\\n\", Irp->IoStatus.Status);\n\t\t}\n\t}\n#endif\n\n\treturn TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);\n}\n\n\nNTSTATUS TCStartThread (PKSTART_ROUTINE threadProc, PVOID threadArg, PKTHREAD *kThread)\n{\n\treturn TCStartThreadInProcess (threadProc, threadArg, kThread, NULL);\n}\n\n\nNTSTATUS TCStartThreadInProcess (PKSTART_ROUTINE threadProc, PVOID threadArg, PKTHREAD *kThread, PEPROCESS process)\n{\n\tNTSTATUS status;\n\tHANDLE threadHandle;\n\tHANDLE processHandle = NULL;\n\tOBJECT_ATTRIBUTES threadObjAttributes;\n\n\tif (process)\n\t{\n\t\tstatus = ObOpenObjectByPointer (process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &processHandle);\n\t\tif (!NT_SUCCESS (status))\n\t\t\treturn status;\n\t}\n\n\tInitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tstatus = PsCreateSystemThread (&threadHandle, THREAD_ALL_ACCESS, &threadObjAttributes, processHandle, NULL, threadProc, threadArg);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tstatus = ObReferenceObjectByHandle (threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *) kThread, NULL);\n\tif (!NT_SUCCESS (status))\n\t{\n\t\tZwClose (threadHandle);\n\t\t*kThread = NULL;\n\t\treturn status;\n\t}\n\n\tif (processHandle)\n\t\tZwClose (processHandle);\n\n\tZwClose (threadHandle);\n\treturn STATUS_SUCCESS;\n}\n\n\nvoid TCStopThread (PKTHREAD kThread, PKEVENT wakeUpEvent)\n{\n\tif (wakeUpEvent)\n\t\tKeSetEvent (wakeUpEvent, 0, FALSE);\n\n\tKeWaitForSingleObject (kThread, Executive, KernelMode, FALSE, NULL);\n\tObDereferenceObject (kThread);\n}\n\n\nNTSTATUS TCStartVolumeThread (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, MOUNT_STRUCT * mount)\n{\n\tPTHREAD_BLOCK pThreadBlock = TCalloc (sizeof (THREAD_BLOCK));\n\tHANDLE hThread;\n\tNTSTATUS ntStatus;\n\tOBJECT_ATTRIBUTES threadObjAttributes;\n\tSECURITY_QUALITY_OF_SERVICE qos;\n\n\tDump (\"Starting thread...\\n\");\n\n\tif (pThreadBlock == NULL)\n\t{\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\t}\n\telse\n\t{\n\t\tpThreadBlock->DeviceObject = DeviceObject;\n\t\tpThreadBlock->mount = mount;\n\t}\n\n\tqos.Length = sizeof (qos);\n\tqos.ContextTrackingMode = SECURITY_STATIC_TRACKING;\n\tqos.EffectiveOnly = TRUE;\n\tqos.ImpersonationLevel = SecurityImpersonation;\n\n\tntStatus = SeCreateClientSecurity (PsGetCurrentThread(), &qos, FALSE, &Extension->SecurityClientContext);\n\tif (!NT_SUCCESS (ntStatus))\n\t\tgoto ret;\n\n\tExtension->SecurityClientContextValid = TRUE;\n\n\tExtension->bThreadShouldQuit = FALSE;\n\n\tInitializeObjectAttributes (&threadObjAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tntStatus = PsCreateSystemThread (&hThread,\n\t\t\t\t\t THREAD_ALL_ACCESS,\n\t\t\t\t\t &threadObjAttributes,\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL,\n\t\t\t\t\t VolumeThreadProc,\n\t\t\t\t\t pThreadBlock);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"PsCreateSystemThread Failed END\\n\");\n\t\tgoto ret;\n\t}\n\n\tntStatus = ObReferenceObjectByHandle (hThread,\n\t\t\t\t   THREAD_ALL_ACCESS,\n\t\t\t\t   NULL,\n\t\t\t\t   KernelMode,\n\t\t\t\t   &Extension->peThread,\n\t\t\t\t   NULL);\n\n\tZwClose (hThread);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\tgoto ret;\n\n\tDump (\"Waiting for thread to initialize...\\n\");\n\n\tKeWaitForSingleObject (&Extension->keCreateEvent,\n\t\t\t       Executive,\n\t\t\t       KernelMode,\n\t\t\t       FALSE,\n\t\t\t       NULL);\n\n\tDump (\"Waiting completed! Thread returns 0x%08x\\n\", pThreadBlock->ntCreateStatus);\n\tntStatus = pThreadBlock->ntCreateStatus;\n\nret:\n\tTCfree (pThreadBlock);\n\treturn ntStatus;\n}\n\nvoid TCStopVolumeThread (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension)\n{\n\tNTSTATUS ntStatus;\n\n\tUNREFERENCED_PARAMETER (DeviceObject);\t/* Remove compiler warning */\n\n\tDump (\"Signalling thread to quit...\\n\");\n\n\tExtension->bThreadShouldQuit = TRUE;\n\n\tKeReleaseSemaphore (&Extension->RequestSemaphore,\n\t\t\t    0,\n\t\t\t    1,\n\t\t\t    TRUE);\n\n\tntStatus = KeWaitForSingleObject (Extension->peThread,\n\t\t\t\t\t  Executive,\n\t\t\t\t\t  KernelMode,\n\t\t\t\t\t  FALSE,\n\t\t\t\t\t  NULL);\n\n\tASSERT (NT_SUCCESS (ntStatus));\n\n\tObDereferenceObject (Extension->peThread);\n\tExtension->peThread = NULL;\n\n\tDump (\"Thread exited\\n\");\n}\n\n\n// Suspend current thread for a number of milliseconds\nvoid TCSleep (int milliSeconds)\n{\n\tPKTIMER timer = (PKTIMER) TCalloc (sizeof (KTIMER));\n\tLARGE_INTEGER duetime;\n\n\tif (!timer)\n\t\treturn;\n\n\tduetime.QuadPart = (__int64) milliSeconds * -10000;\n\tKeInitializeTimerEx(timer, NotificationTimer);\n\tKeSetTimerEx(timer, duetime, 0, NULL);\n\n\tKeWaitForSingleObject (timer, Executive, KernelMode, FALSE, NULL);\n\n\tTCfree (timer);\n}\n\nBOOL IsDeviceName(wchar_t wszVolume[TC_MAX_PATH])\n{\n\tif\t(\t(wszVolume[0] == '\\\\')\n\t\t&&\t(wszVolume[1] == 'D' || wszVolume[1] == 'd')\n\t\t&&\t(wszVolume[2] == 'E' || wszVolume[2] == 'e')\n\t\t&&\t(wszVolume[3] == 'V' || wszVolume[3] == 'v')\n\t\t&&\t(wszVolume[4] == 'I' || wszVolume[4] == 'i')\n\t\t&&\t(wszVolume[5] == 'C' || wszVolume[5] == 'c')\n\t\t&&\t(wszVolume[6] == 'E' || wszVolume[6] == 'e')\n\t\t)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t\treturn FALSE;\n}\n\n/* VolumeThreadProc does all the work of processing IRP's, and dispatching them\n   to either the ReadWrite function or the DeviceControl function */\nVOID VolumeThreadProc (PVOID Context)\n{\n\tPTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;\n\tPDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;\n\tPEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;\n\tBOOL bDevice;\n\n\t/* Set thread priority to lowest realtime level. */\n\tKeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);\n\n\tDump (\"Mount THREAD OPENING VOLUME BEGIN\\n\");\n\n\tif ( !IsDeviceName (pThreadBlock->mount->wszVolume))\n\t{\n\t\tRtlStringCbCopyW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),WIDE (\"\\\\??\\\\\"));\n\t\tRtlStringCbCatW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),pThreadBlock->mount->wszVolume);\n\t\tbDevice = FALSE;\n\t}\n\telse\n\t{\n\t\tpThreadBlock->wszMountVolume[0] = 0;\n\t\tRtlStringCbCatW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),pThreadBlock->mount->wszVolume);\n\t\tbDevice = TRUE;\n\t}\n\n\tDump (\"Mount THREAD request for File %ls DriveNumber %d Device = %d\\n\",\n\t      pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);\n\n\tpThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,\n\t\tExtension,\n\t\tpThreadBlock->mount,\n\t\tpThreadBlock->wszMountVolume,\n\t\tbDevice);\n\n\tif (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)\n\t{\n\t\tKeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n\t\tPsTerminateSystemThread (STATUS_SUCCESS);\n\t}\n\n\t// Start IO queue\n\tExtension->Queue.IsFilterDevice = FALSE;\n\tExtension->Queue.DeviceObject = DeviceObject;\n\tExtension->Queue.CryptoInfo = Extension->cryptoInfo;\n\tExtension->Queue.HostFileHandle = Extension->hDeviceFile;\n\tExtension->Queue.VirtualDeviceLength = Extension->DiskLength;\n\tExtension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;\n\n\tif (Extension->SecurityClientContextValid)\n\t\tExtension->Queue.SecurityClientContext = &Extension->SecurityClientContext;\n\telse\n\t\tExtension->Queue.SecurityClientContext = NULL;\n\n\tpThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);\n\n\tif (!NT_SUCCESS (pThreadBlock->ntCreateStatus))\n\t{\n\t\tTCCloseVolume (DeviceObject, Extension);\n\n\t\tpThreadBlock->mount->nReturnCode = ERR_OS_ERROR;\n\t\tKeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n\t\tPsTerminateSystemThread (STATUS_SUCCESS);\n\t}\n\n\tKeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n\t/* From this point on pThreadBlock cannot be used as it will have been released! */\n\tpThreadBlock = NULL;\n\n\tfor (;;)\n\t{\n\t\t/* Wait for a request from the dispatch routines. */\n\t\tKeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);\n\n\t\tfor (;;)\n\t\t{\n\t\t\tPIO_STACK_LOCATION irpSp;\n\t\t\tPLIST_ENTRY request;\n\t\t\tPIRP irp;\n\n\t\t\trequest = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);\n\t\t\tif (request == NULL)\n\t\t\t\tbreak;\n\n\t\t\tirp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);\n\t\t\tirpSp = IoGetCurrentIrpStackLocation (irp);\n\n\t\t\tASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);\n\n\t\t\tProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);\n\t\t\tIoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);\n\t\t}\n\n\t\tif (Extension->bThreadShouldQuit)\n\t\t{\n\t\t\tDump (\"Closing volume\\n\");\n\t\t\tEncryptedIoQueueStop (&Extension->Queue);\n\n\t\t\tTCCloseVolume (DeviceObject, Extension);\n\t\t\tPsTerminateSystemThread (STATUS_SUCCESS);\n\t\t}\n\t}\n}\n\nvoid TCGetNTNameFromNumber (LPWSTR ntname, int cbNtName, int nDriveNo)\n{\n\tWCHAR tmp[2] =\n\t{0, 0};\n\tint j = nDriveNo + (WCHAR) 'A';\n\n\ttmp[0] = (short) j;\n\tRtlStringCbCopyW (ntname, cbNtName,(LPWSTR) NT_MOUNT_PREFIX);\n\tRtlStringCbCatW (ntname, cbNtName, tmp);\n}\n\nvoid TCGetDosNameFromNumber (LPWSTR dosname,int cbDosName, int nDriveNo, DeviceNamespaceType namespaceType)\n{\n\tWCHAR tmp[3] =\n\t{0, ':', 0};\n\tint j = nDriveNo + (WCHAR) 'A';\n\n\ttmp[0] = (short) j;\n\n\tif (DeviceNamespaceGlobal == namespaceType)\n\t{\n\t\tRtlStringCbCopyW (dosname, cbDosName, (LPWSTR) DOS_MOUNT_PREFIX_GLOBAL);\n\t}\n\telse\n\t{\n\t\tRtlStringCbCopyW (dosname, cbDosName, (LPWSTR) DOS_MOUNT_PREFIX_DEFAULT);\n\t}\n\n\tRtlStringCbCatW (dosname, cbDosName, tmp);\n}\n\n#if defined(_DEBUG) || defined (_DEBUG_TRACE)\nLPWSTR TCTranslateCode (ULONG ulCode)\n{\n\tswitch (ulCode)\n\t{\n#define TC_CASE_RET_NAME(CODE) case CODE : return L###CODE\n\n\t\tTC_CASE_RET_NAME (TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_BOOT_ENCRYPTION_SETUP);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_ALL_VOLUMES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_DISMOUNT_VOLUME);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_BOOT_LOADER_VERSION);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DEVICE_REFCOUNT);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_GEOMETRY);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DRIVE_PARTITION_INFO);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_DRIVER_VERSION);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_MOUNTED_VOLUMES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_PASSWORD_CACHE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_PORTABLE_MODE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_SET_PORTABLE_MODE_STATUS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_RESOLVED_SYMLINK);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_VOLUME_PROPERTIES);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_GET_WARNING_FLAGS);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_DISK_IS_WRITABLE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_IS_ANY_VOLUME_MOUNTED);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_MOUNT_VOLUME);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_OPEN_TEST);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_PROBE_REAL_DRIVE_SIZE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_REREAD_DRIVER_CONFIG);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_START_DECOY_SYSTEM_WIPE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_WIPE_PASSWORD_CACHE);\n\t\tTC_CASE_RET_NAME (TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR);\n\t\tTC_CASE_RET_NAME (VC_IOCTL_GET_DRIVE_GEOMETRY_EX);\n\n\t\tTC_CASE_RET_NAME (IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS);\n\n#undef TC_CASE_RET_NAME\n\t}\n\n\tif (ulCode ==\t\t\t IOCTL_DISK_GET_DRIVE_GEOMETRY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_GEOMETRY\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_DRIVE_GEOMETRY_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_GEOMETRY_EX\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_QUERY_DEVICE_NAME)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_DEVICE_NAME\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_QUERY_UNIQUE_ID)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_UNIQUE_ID\");\n\telse if (ulCode ==\t\t IOCTL_VOLUME_ONLINE)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_ONLINE\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_LINK_CREATED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_LINK_CREATED\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTDEV_LINK_DELETED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_LINK_DELETED\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTMGR_QUERY_POINTS)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTMGR_QUERY_POINTS\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED\");\n\telse if (ulCode ==\t\t IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_LENGTH_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_LENGTH_INFO\");\n\telse if (ulCode ==\t\t IOCTL_STORAGE_GET_DEVICE_NUMBER)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_GET_DEVICE_NUMBER\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_PARTITION_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_PARTITION_INFO\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_PARTITION_INFO_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_PARTITION_INFO_EX\");\n\telse if (ulCode ==\t\t IOCTL_DISK_SET_PARTITION_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_SET_PARTITION_INFO\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_DRIVE_LAYOUT)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_LAYOUT\");\n\telse if (ulCode ==\t\t IOCTL_DISK_GET_DRIVE_LAYOUT_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_DRIVE_LAYOUT_EX\");\n\telse if (ulCode ==\t\t IOCTL_DISK_SET_DRIVE_LAYOUT_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_SET_DRIVE_LAYOUT_EX\");\n\telse if (ulCode ==\t\t IOCTL_DISK_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_FORMAT_TRACKS)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_FORMAT_TRACKS\");\n\telse if (ulCode == IOCTL_DISK_REASSIGN_BLOCKS)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_REASSIGN_BLOCKS\");\n\telse if (ulCode == IOCTL_DISK_PERFORMANCE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_PERFORMANCE\");\n\telse if (ulCode == IOCTL_DISK_IS_WRITABLE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_IS_WRITABLE\");\n\telse if (ulCode == IOCTL_DISK_LOGGING)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_LOGGING\");\n\telse if (ulCode == IOCTL_DISK_FORMAT_TRACKS_EX)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_FORMAT_TRACKS_EX\");\n\telse if (ulCode == IOCTL_DISK_HISTOGRAM_STRUCTURE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_HISTOGRAM_STRUCTURE\");\n\telse if (ulCode == IOCTL_DISK_HISTOGRAM_DATA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_HISTOGRAM_DATA\");\n\telse if (ulCode == IOCTL_DISK_HISTOGRAM_RESET)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_HISTOGRAM_RESET\");\n\telse if (ulCode == IOCTL_DISK_REQUEST_STRUCTURE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_REQUEST_STRUCTURE\");\n\telse if (ulCode == IOCTL_DISK_REQUEST_DATA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_REQUEST_DATA\");\n\telse if (ulCode == IOCTL_DISK_CONTROLLER_NUMBER)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_CONTROLLER_NUMBER\");\n\telse if (ulCode == SMART_GET_VERSION)\n\t\treturn (LPWSTR) _T (\"SMART_GET_VERSION\");\n\telse if (ulCode == SMART_SEND_DRIVE_COMMAND)\n\t\treturn (LPWSTR) _T (\"SMART_SEND_DRIVE_COMMAND\");\n\telse if (ulCode == SMART_RCV_DRIVE_DATA)\n\t\treturn (LPWSTR) _T (\"SMART_RCV_DRIVE_DATA\");\n\telse if (ulCode == IOCTL_DISK_INTERNAL_SET_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_INTERNAL_SET_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_INTERNAL_CLEAR_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_INTERNAL_CLEAR_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_CHECK_VERIFY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_CHECK_VERIFY\");\n\telse if (ulCode == IOCTL_DISK_MEDIA_REMOVAL)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_MEDIA_REMOVAL\");\n\telse if (ulCode == IOCTL_DISK_EJECT_MEDIA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_EJECT_MEDIA\");\n\telse if (ulCode == IOCTL_DISK_LOAD_MEDIA)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_LOAD_MEDIA\");\n\telse if (ulCode == IOCTL_DISK_RESERVE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_RESERVE\");\n\telse if (ulCode == IOCTL_DISK_RELEASE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_RELEASE\");\n\telse if (ulCode == IOCTL_DISK_FIND_NEW_DEVICES)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_FIND_NEW_DEVICES\");\n\telse if (ulCode == IOCTL_DISK_GET_MEDIA_TYPES)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_MEDIA_TYPES\");\n\telse if (ulCode == IOCTL_DISK_IS_CLUSTERED)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_IS_CLUSTERED\");\t\n\telse if (ulCode == IOCTL_DISK_UPDATE_DRIVE_SIZE)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_UPDATE_DRIVE_SIZE\");\n\telse if (ulCode == IOCTL_STORAGE_GET_MEDIA_TYPES)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_GET_MEDIA_TYPES\");\n\telse if (ulCode == IOCTL_STORAGE_GET_HOTPLUG_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_GET_HOTPLUG_INFO\");\n\telse if (ulCode == IOCTL_STORAGE_SET_HOTPLUG_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_SET_HOTPLUG_INFO\");\n\telse if (ulCode == IOCTL_STORAGE_QUERY_PROPERTY)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_QUERY_PROPERTY\");\n\telse if (ulCode == IOCTL_VOLUME_GET_GPT_ATTRIBUTES)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_GET_GPT_ATTRIBUTES\");\t\n\telse if (ulCode == FT_BALANCED_READ_MODE)\n\t\treturn (LPWSTR) _T (\"FT_BALANCED_READ_MODE\");\n\telse if (ulCode == IOCTL_VOLUME_QUERY_ALLOCATION_HINT)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_QUERY_ALLOCATION_HINT\");\n\telse if (ulCode == IOCTL_DISK_GET_CLUSTER_INFO)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_GET_CLUSTER_INFO\");\n\telse if (ulCode == IOCTL_DISK_ARE_VOLUMES_READY)\n\t\treturn (LPWSTR) _T (\"IOCTL_DISK_ARE_VOLUMES_READY\");\t\t\t\n\telse if (ulCode == IOCTL_VOLUME_IS_DYNAMIC)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_IS_DYNAMIC\");\n\telse if (ulCode == IOCTL_MOUNTDEV_QUERY_STABLE_GUID)\n\t\treturn (LPWSTR) _T (\"IOCTL_MOUNTDEV_QUERY_STABLE_GUID\");\n\telse if (ulCode == IOCTL_VOLUME_POST_ONLINE)\n\t\treturn (LPWSTR) _T (\"IOCTL_VOLUME_POST_ONLINE\");\n\telse if (ulCode == IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT\");\n\telse if (ulCode == IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES)\n\t\treturn (LPWSTR) _T (\"IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES\");\n\telse if (ulCode == IRP_MJ_READ)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_READ\");\n\telse if (ulCode == IRP_MJ_WRITE)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_WRITE\");\n\telse if (ulCode == IRP_MJ_CREATE)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_CREATE\");\n\telse if (ulCode == IRP_MJ_CLOSE)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_CLOSE\");\n\telse if (ulCode == IRP_MJ_CLEANUP)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_CLEANUP\");\n\telse if (ulCode == IRP_MJ_FLUSH_BUFFERS)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_FLUSH_BUFFERS\");\n\telse if (ulCode == IRP_MJ_SHUTDOWN)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_SHUTDOWN\");\n\telse if (ulCode == IRP_MJ_DEVICE_CONTROL)\n\t\treturn (LPWSTR) _T (\"IRP_MJ_DEVICE_CONTROL\");\n\telse\n\t{\n\t\treturn (LPWSTR) _T (\"IOCTL\");\n\t}\n}\n\n#endif\n\nvoid TCDeleteDeviceObject (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension)\n{\n\tUNICODE_STRING Win32NameString;\n\tNTSTATUS ntStatus;\n\n\tDump (\"TCDeleteDeviceObject BEGIN\\n\");\n\n\tif (Extension->bRootDevice)\n\t{\n\t\tRtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);\n\t\tntStatus = IoDeleteSymbolicLink (&Win32NameString);\n\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\tDump (\"IoDeleteSymbolicLink failed ntStatus = 0x%08x\\n\", ntStatus);\n\n\t\tRootDeviceObject = NULL;\n\t}\n\telse\n\t{\n\t\tif (Extension->peThread != NULL)\n\t\t\tTCStopVolumeThread (DeviceObject, Extension);\n\n\t\tif (Extension->UserSid)\n\t\t\tTCfree (Extension->UserSid);\n\n\t\tif (Extension->SecurityClientContextValid)\n\t\t{\n\t\t\tif (OsMajorVersion == 5 && OsMinorVersion == 0)\n\t\t\t{\n\t\t\t\tObDereferenceObject (Extension->SecurityClientContext.ClientToken);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().\n\t\t\t\t// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.\n\n\t\t\t\tVOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);\n\t\t\t\tUNICODE_STRING name;\n\t\t\t\tRtlInitUnicodeString (&name, L\"PsDereferenceImpersonationToken\");\n\n\t\t\t\tPsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);\n\t\t\t\tif (!PsDereferenceImpersonationTokenD)\n\t\t\t\t\tTC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);\n\n#\t\t\t\tdefine PsDereferencePrimaryToken\n#\t\t\t\tdefine PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD\n\n\t\t\t\tSeDeleteClientSecurity (&Extension->SecurityClientContext);\n\n#\t\t\t\tundef PsDereferencePrimaryToken\n#\t\t\t\tundef PsDereferenceImpersonationToken\n\t\t\t}\n\t\t}\n\n\t\tVirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;\n\t}\n\n\tIoDeleteDevice (DeviceObject);\n\n\tDump (\"TCDeleteDeviceObject END\\n\");\n}\n\n\nVOID TCUnloadDriver (PDRIVER_OBJECT DriverObject)\n{\n\tDump (\"TCUnloadDriver BEGIN\\n\");\n\n\tOnShutdownPending();\n\n\tif (IsBootDriveMounted())\n\t\tTC_BUG_CHECK (STATUS_INVALID_DEVICE_STATE);\n\n\tEncryptionThreadPoolStop();\n\tTCDeleteDeviceObject (RootDeviceObject, (PEXTENSION) RootDeviceObject->DeviceExtension);\n\n\tDump (\"TCUnloadDriver END\\n\");\n}\n\n\nvoid OnShutdownPending ()\n{\n\tUNMOUNT_STRUCT unmount;\n\tmemset (&unmount, 0, sizeof (unmount));\n\tunmount.ignoreOpenFiles = TRUE;\n\n\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_DISMOUNT_ALL_VOLUMES, &unmount, sizeof (unmount), &unmount, sizeof (unmount)) == STATUS_INSUFFICIENT_RESOURCES || unmount.HiddenVolumeProtectionTriggered)\n\t\tunmount.HiddenVolumeProtectionTriggered = FALSE;\n\n\twhile (SendDeviceIoControlRequest (RootDeviceObject, TC_IOCTL_WIPE_PASSWORD_CACHE, NULL, 0, NULL, 0) == STATUS_INSUFFICIENT_RESOURCES);\n}\n\n\nNTSTATUS TCDeviceIoControl (PWSTR deviceName, ULONG IoControlCode, void *InputBuffer, ULONG InputBufferSize, void *OutputBuffer, ULONG OutputBufferSize)\n{\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tNTSTATUS ntStatus;\n\tPIRP irp;\n\tPFILE_OBJECT fileObject;\n\tPDEVICE_OBJECT deviceObject;\n\tKEVENT event;\n\tUNICODE_STRING name;\n\n\tRtlInitUnicodeString(&name, deviceName);\n\tntStatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\treturn ntStatus;\n\n\tKeInitializeEvent(&event, NotificationEvent, FALSE);\n\n\tirp = IoBuildDeviceIoControlRequest (IoControlCode,\n\t\t\t\t\t     deviceObject,\n\t\t\t\t\t     InputBuffer, InputBufferSize,\n\t\t\t\t\t     OutputBuffer, OutputBufferSize,\n\t\t\t\t\t     FALSE,\n\t\t\t\t\t     &event,\n\t\t\t\t\t     &ioStatusBlock);\n\n\tif (irp == NULL)\n\t{\n\t\tDump (\"IRP allocation failed\\n\");\n\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\tgoto ret;\n\t}\n\n\tIoGetNextIrpStackLocation (irp)->FileObject = fileObject;\n\n\tntStatus = IoCallDriver (deviceObject, irp);\n\tif (ntStatus == STATUS_PENDING)\n\t{\n\t\tKeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);\n\t\tntStatus = ioStatusBlock.Status;\n\t}\n\nret:\n\tObDereferenceObject (fileObject);\n\treturn ntStatus;\n}\n\n\ntypedef struct\n{\n\tPDEVICE_OBJECT deviceObject; ULONG ioControlCode; void *inputBuffer; int inputBufferSize; void *outputBuffer; int outputBufferSize;\n\tNTSTATUS Status;\n\tKEVENT WorkItemCompletedEvent;\n} SendDeviceIoControlRequestWorkItemArgs;\n\n\nstatic VOID SendDeviceIoControlRequestWorkItemRoutine (PDEVICE_OBJECT rootDeviceObject, SendDeviceIoControlRequestWorkItemArgs *arg)\n{\n\targ->Status = SendDeviceIoControlRequest (arg->deviceObject, arg->ioControlCode, arg->inputBuffer, arg->inputBufferSize, arg->outputBuffer, arg->outputBufferSize);\n\tKeSetEvent (&arg->WorkItemCompletedEvent, IO_NO_INCREMENT, FALSE);\n}\n\n\nNTSTATUS SendDeviceIoControlRequest (PDEVICE_OBJECT deviceObject, ULONG ioControlCode, void *inputBuffer, int inputBufferSize, void *outputBuffer, int outputBufferSize)\n{\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tNTSTATUS status;\n\tPIRP irp;\n\tKEVENT event;\n\n\tif (KeGetCurrentIrql() > APC_LEVEL)\n\t{\n\t\tSendDeviceIoControlRequestWorkItemArgs args;\n\n\t\tPIO_WORKITEM workItem = IoAllocateWorkItem (RootDeviceObject);\n\t\tif (!workItem)\n\t\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\t\targs.deviceObject = deviceObject;\n\t\targs.ioControlCode = ioControlCode;\n\t\targs.inputBuffer = inputBuffer;\n\t\targs.inputBufferSize = inputBufferSize;\n\t\targs.outputBuffer = outputBuffer;\n\t\targs.outputBufferSize = outputBufferSize;\n\n\t\tKeInitializeEvent (&args.WorkItemCompletedEvent, SynchronizationEvent, FALSE);\n\t\tIoQueueWorkItem (workItem, SendDeviceIoControlRequestWorkItemRoutine, DelayedWorkQueue, &args);\n\n\t\tKeWaitForSingleObject (&args.WorkItemCompletedEvent, Executive, KernelMode, FALSE, NULL);\n\t\tIoFreeWorkItem (workItem);\n\n\t\treturn args.Status;\n\t}\n\n\tKeInitializeEvent (&event, NotificationEvent, FALSE);\n\n\tirp = IoBuildDeviceIoControlRequest (ioControlCode, deviceObject, inputBuffer, inputBufferSize,\n\t\toutputBuffer, outputBufferSize, FALSE, &event, &ioStatusBlock);\n\n\tif (!irp)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tObReferenceObject (deviceObject);\n\n\tstatus = IoCallDriver (deviceObject, irp);\n\tif (status == STATUS_PENDING)\n\t{\n\t\tKeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);\n\t\tstatus = ioStatusBlock.Status;\n\t}\n\n\tObDereferenceObject (deviceObject);\n\treturn status;\n}\n\n\nNTSTATUS ProbeRealDriveSize (PDEVICE_OBJECT driveDeviceObject, LARGE_INTEGER *driveSize)\n{\n\tNTSTATUS status;\n\tLARGE_INTEGER sysLength;\n\tLARGE_INTEGER offset;\n\tbyte *sectorBuffer;\n\tULONGLONG startTime;\n\n\tif (!UserCanAccessDriveDevice())\n\t\treturn STATUS_ACCESS_DENIED;\n\n\tsectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);\n\tif (!sectorBuffer)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tstatus = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,\n\t\tNULL, 0, &sysLength, sizeof (sysLength));\n\n\tif (!NT_SUCCESS (status))\n\t{\n\t\tDump (\"Failed to get drive size - error %x\\n\", status);\n\t\tTCfree (sectorBuffer);\n\t\treturn status;\n\t}\n\n\tstartTime = KeQueryInterruptTime ();\n\tfor (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)\n\t{\n\t\tstatus = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);\n\n\t\tif (NT_SUCCESS (status))\n\t\t\tstatus = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);\n\n\t\tif (!NT_SUCCESS (status))\n\t\t{\n\t\t\tdriveSize->QuadPart = offset.QuadPart;\n\t\t\tDump (\"Real drive size = %I64d bytes (%I64d hidden)\\n\", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);\n\t\t\tTCfree (sectorBuffer);\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\n\t\tif (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)\n\t\t{\n\t\t\t// Abort if probing for more than 3 minutes\n\t\t\tdriveSize->QuadPart = sysLength.QuadPart;\n\t\t\tTCfree (sectorBuffer);\n\t\t\treturn STATUS_TIMEOUT;\n\t\t}\n\t}\n}\n\n\nNTSTATUS TCOpenFsVolume (PEXTENSION Extension, PHANDLE volumeHandle, PFILE_OBJECT * fileObject)\n{\n\tNTSTATUS ntStatus;\n\tOBJECT_ATTRIBUTES objectAttributes;\n\tUNICODE_STRING fullFileName;\n\tIO_STATUS_BLOCK ioStatus;\n\tWCHAR volumeName[TC_MAX_PATH];\n\n\tTCGetNTNameFromNumber (volumeName, sizeof(volumeName),Extension->nDosDriveNo);\n\tRtlInitUnicodeString (&fullFileName, volumeName);\n\tInitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tntStatus = ZwCreateFile (volumeHandle,\n\t\tSYNCHRONIZE | GENERIC_READ,\n\t\t&objectAttributes,\n\t\t&ioStatus,\n\t\tNULL,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE,\n\t\tFILE_OPEN,\n\t\tFILE_SYNCHRONOUS_IO_NONALERT,\n\t\tNULL,\n\t\t0);\n\n\tDump (\"Volume %ls open NTSTATUS 0x%08x\\n\", volumeName, ntStatus);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\treturn ntStatus;\n\n\tntStatus = ObReferenceObjectByHandle (*volumeHandle,\n\t\tFILE_READ_DATA,\n\t\tNULL,\n\t\tKernelMode,\n\t\tfileObject,\n\t\tNULL);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t\tZwClose (*volumeHandle);\n\n\treturn ntStatus;\n}\n\n\nvoid TCCloseFsVolume (HANDLE volumeHandle, PFILE_OBJECT fileObject)\n{\n\tObDereferenceObject (fileObject);\n\tZwClose (volumeHandle);\n}\n\n\nstatic NTSTATUS TCReadWriteDevice (BOOL write, PDEVICE_OBJECT deviceObject, PVOID buffer, LARGE_INTEGER offset, ULONG length)\n{\n\tNTSTATUS status;\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tPIRP irp;\n\tKEVENT completionEvent;\n\n\tASSERT (KeGetCurrentIrql() <= APC_LEVEL);\n\n\tKeInitializeEvent (&completionEvent, NotificationEvent, FALSE);\n\tirp = IoBuildSynchronousFsdRequest (write ? IRP_MJ_WRITE : IRP_MJ_READ, deviceObject, buffer, length, &offset, &completionEvent, &ioStatusBlock);\n\tif (!irp)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tObReferenceObject (deviceObject);\n\tstatus = IoCallDriver (deviceObject, irp);\n\n\tif (status == STATUS_PENDING)\n\t{\n\t\tstatus = KeWaitForSingleObject (&completionEvent, Executive, KernelMode, FALSE, NULL);\n\t\tif (NT_SUCCESS (status))\n\t\t\tstatus = ioStatusBlock.Status;\n\t}\n\n\tObDereferenceObject (deviceObject);\n\treturn status;\n}\n\n\nNTSTATUS TCReadDevice (PDEVICE_OBJECT deviceObject, PVOID buffer, LARGE_INTEGER offset, ULONG length)\n{\n\treturn TCReadWriteDevice (FALSE, deviceObject, buffer, offset, length);\n}\n\n\nNTSTATUS TCWriteDevice (PDEVICE_OBJECT deviceObject, PVOID buffer, LARGE_INTEGER offset, ULONG length)\n{\n\treturn TCReadWriteDevice (TRUE, deviceObject, buffer, offset, length);\n}\n\n\nNTSTATUS TCFsctlCall (PFILE_OBJECT fileObject, LONG IoControlCode,\n\tvoid *InputBuffer, int InputBufferSize, void *OutputBuffer, int OutputBufferSize)\n{\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tNTSTATUS ntStatus;\n\tPIRP irp;\n\tKEVENT event;\n\tPIO_STACK_LOCATION stack;\n\tPDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject (fileObject);\n\n\tKeInitializeEvent(&event, NotificationEvent, FALSE);\n\n\tirp = IoBuildDeviceIoControlRequest (IoControlCode,\n\t\t\t\t\t     deviceObject,\n\t\t\t\t\t     InputBuffer, InputBufferSize,\n\t\t\t\t\t     OutputBuffer, OutputBufferSize,\n\t\t\t\t\t     FALSE,\n\t\t\t\t\t     &event,\n\t\t\t\t\t     &ioStatusBlock);\n\n\tif (irp == NULL)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tstack = IoGetNextIrpStackLocation(irp);\n\n\tstack->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;\n\tstack->MinorFunction = IRP_MN_USER_FS_REQUEST;\n\tstack->FileObject = fileObject;\n\n\tntStatus = IoCallDriver (deviceObject, irp);\n\tif (ntStatus == STATUS_PENDING)\n\t{\n\t\tKeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);\n\t\tntStatus = ioStatusBlock.Status;\n\t}\n\n\treturn ntStatus;\n}\n\n\nNTSTATUS CreateDriveLink (int nDosDriveNo)\n{\n\tWCHAR dev[128], link[128];\n\tUNICODE_STRING deviceName, symLink;\n\tNTSTATUS ntStatus;\n\n\tTCGetNTNameFromNumber (dev, sizeof(dev),nDosDriveNo);\n\tTCGetDosNameFromNumber (link, sizeof(link),nDosDriveNo, DeviceNamespaceDefault);\n\n\tRtlInitUnicodeString (&deviceName, dev);\n\tRtlInitUnicodeString (&symLink, link);\n\n\tntStatus = IoCreateSymbolicLink (&symLink, &deviceName);\n\tDump (\"IoCreateSymbolicLink returned %X\\n\", ntStatus);\n\treturn ntStatus;\n}\n\n\nNTSTATUS RemoveDriveLink (int nDosDriveNo)\n{\n\tWCHAR link[256];\n\tUNICODE_STRING symLink;\n\tNTSTATUS ntStatus;\n\n\tTCGetDosNameFromNumber (link, sizeof(link),nDosDriveNo, DeviceNamespaceDefault);\n\tRtlInitUnicodeString (&symLink, link);\n\n\tntStatus = IoDeleteSymbolicLink (&symLink);\n\tDump (\"IoDeleteSymbolicLink returned %X\\n\", ntStatus);\n\treturn ntStatus;\n}\n\n\nNTSTATUS MountManagerMount (MOUNT_STRUCT *mount)\n{\n\tNTSTATUS ntStatus;\n\tWCHAR arrVolume[256];\n\tchar buf[200];\n\tPMOUNTMGR_TARGET_NAME in = (PMOUNTMGR_TARGET_NAME) buf;\n\tPMOUNTMGR_CREATE_POINT_INPUT point = (PMOUNTMGR_CREATE_POINT_INPUT) buf;\n\n\tTCGetNTNameFromNumber (arrVolume, sizeof(arrVolume),mount->nDosDriveNo);\n\tin->DeviceNameLength = (USHORT) wcslen (arrVolume) * 2;\n\tRtlStringCbCopyW(in->DeviceName, sizeof(buf) - sizeof(in->DeviceNameLength),arrVolume);\n\n\tntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,\n\t\tin, (ULONG) (sizeof (in->DeviceNameLength) + wcslen (arrVolume) * 2), 0, 0);\n\n\tmemset (buf, 0, sizeof buf);\n\tTCGetDosNameFromNumber ((PWSTR) &point[1], sizeof(buf) - sizeof(MOUNTMGR_CREATE_POINT_INPUT),mount->nDosDriveNo, DeviceNamespaceDefault);\n\n\tpoint->SymbolicLinkNameOffset = sizeof (MOUNTMGR_CREATE_POINT_INPUT);\n\tpoint->SymbolicLinkNameLength = (USHORT) wcslen ((PWSTR) &point[1]) * 2;\n\n\tpoint->DeviceNameOffset = point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;\n\tTCGetNTNameFromNumber ((PWSTR) (buf + point->DeviceNameOffset), sizeof(buf) - point->DeviceNameOffset,mount->nDosDriveNo);\n\tpoint->DeviceNameLength = (USHORT) wcslen ((PWSTR) (buf + point->DeviceNameOffset)) * 2;\n\n\tntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_CREATE_POINT, point,\n\t\t\tpoint->DeviceNameOffset + point->DeviceNameLength, 0, 0);\n\n\treturn ntStatus;\n}\n\n\nNTSTATUS MountManagerUnmount (int nDosDriveNo)\n{\n\tNTSTATUS ntStatus;\n\tchar buf[256], out[300];\n\tPMOUNTMGR_MOUNT_POINT in = (PMOUNTMGR_MOUNT_POINT) buf;\n\n\tmemset (buf, 0, sizeof buf);\n\n\tTCGetDosNameFromNumber ((PWSTR) &in[1], sizeof(buf) - sizeof(MOUNTMGR_MOUNT_POINT),nDosDriveNo, DeviceNamespaceDefault);\n\n\t// Only symbolic link can be deleted with IOCTL_MOUNTMGR_DELETE_POINTS. If any other entry is specified, the mount manager will ignore subsequent IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for the same volume ID.\n\tin->SymbolicLinkNameOffset = sizeof (MOUNTMGR_MOUNT_POINT);\n\tin->SymbolicLinkNameLength = (USHORT) wcslen ((PWCHAR) &in[1]) * 2;\n\n\tntStatus = TCDeviceIoControl (MOUNTMGR_DEVICE_NAME, IOCTL_MOUNTMGR_DELETE_POINTS,\n\t\tin, sizeof(MOUNTMGR_MOUNT_POINT) + in->SymbolicLinkNameLength, out, sizeof out);\n\n\tDump (\"IOCTL_MOUNTMGR_DELETE_POINTS returned 0x%08x\\n\", ntStatus);\n\n\treturn ntStatus;\n}\n\n\nNTSTATUS MountDevice (PDEVICE_OBJECT DeviceObject, MOUNT_STRUCT *mount)\n{\n\tPDEVICE_OBJECT NewDeviceObject;\n\tNTSTATUS ntStatus;\n\n\t// Make sure the user is asking for a reasonable nDosDriveNo\n\tif (mount->nDosDriveNo >= 0 && mount->nDosDriveNo <= 25\n\t\t&& IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceDefault) // drive letter must not exist both locally and globally\n\t\t&& IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceGlobal)\n\t\t)\n\t{\n\t\tDump (\"Mount request looks valid\\n\");\n\t}\n\telse\n\t{\n\t\tDump (\"WARNING: MOUNT DRIVE LETTER INVALID\\n\");\n\t\tmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\t\treturn ERR_DRIVE_NOT_FOUND;\n\t}\n\n\tif (!SelfTestsPassed)\n\t{\n\t\tDump (\"Failure of built-in automatic self-tests! Mounting not allowed.\\n\");\n\t\tmount->nReturnCode = ERR_SELF_TESTS_FAILED;\n\t\treturn ERR_SELF_TESTS_FAILED;\n\t}\n\n\tntStatus = TCCreateDeviceObject (DeviceObject->DriverObject, &NewDeviceObject, mount);\n\n\tif (!NT_SUCCESS (ntStatus))\n\t{\n\t\tDump (\"Mount CREATE DEVICE ERROR, ntStatus = 0x%08x\\n\", ntStatus);\n\t\treturn ntStatus;\n\t}\n\telse\n\t{\n\t\tPEXTENSION NewExtension = (PEXTENSION) NewDeviceObject->DeviceExtension;\n\t\tSECURITY_SUBJECT_CONTEXT subContext;\n\t\tPACCESS_TOKEN accessToken;\n\n\t\tSeCaptureSubjectContext (&subContext);\n\t\tSeLockSubjectContext(&subContext);\n\t\tif (subContext.ClientToken && subContext.ImpersonationLevel >= SecurityImpersonation)\n\t\t\taccessToken = subContext.ClientToken;\n\t\telse\n\t\t\taccessToken = subContext.PrimaryToken;\n\n\t\tif (!accessToken)\n\t\t{\n\t\t\tntStatus = STATUS_INVALID_PARAMETER;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPTOKEN_USER tokenUser;\n\n\t\t\tntStatus = SeQueryInformationToken (accessToken, TokenUser, &tokenUser);\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\tULONG sidLength = RtlLengthSid (tokenUser->User.Sid);\n\n\t\t\t\tNewExtension->UserSid = TCalloc (sidLength);\n\t\t\t\tif (!NewExtension->UserSid)\n\t\t\t\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\telse\n\t\t\t\t\tntStatus = RtlCopySid (sidLength, NewExtension->UserSid, tokenUser->User.Sid);\n\n\t\t\t\tExFreePool (tokenUser);\t\t// Documented in newer versions of WDK\n\t\t\t}\n\t\t}\n\n\t\tSeUnlockSubjectContext(&subContext);\n\t\tSeReleaseSubjectContext (&subContext);\n\n\t\tif (NT_SUCCESS (ntStatus))\n\t\t\tntStatus = TCStartVolumeThread (NewDeviceObject, NewExtension, mount);\n\n\t\tif (!NT_SUCCESS (ntStatus))\n\t\t{\n\t\t\tDump (\"Mount FAILURE NT ERROR, ntStatus = 0x%08x\\n\", ntStatus);\n\t\t\tTCDeleteDeviceObject (NewDeviceObject, NewExtension);\n\t\t\treturn ntStatus;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mount->nReturnCode == 0)\n\t\t\t{\n\t\t\t\tHANDLE volumeHandle;\n\t\t\t\tPFILE_OBJECT volumeFileObject;\n\t\t\t\tULONG labelLen = (ULONG) wcslen (mount->wszLabel);\n\t\t\t\tBOOL bIsNTFS = FALSE;\n\t\t\t\tULONG labelMaxLen, labelEffectiveLen;\n\n\t\t\t\tDump (\"Mount SUCCESS TC code = 0x%08x READ-ONLY = %d\\n\", mount->nReturnCode, NewExtension->bReadOnly);\n\n\t\t\t\tif (NewExtension->bReadOnly)\n\t\t\t\t\tNewDeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;\n\n\t\t\t\tNewDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;\n\n\t\t\t\tNewExtension->UniqueVolumeId = LastUniqueVolumeId++;\n\n\t\t\t\t// check again that the drive letter is available globally and locally\n\t\t\t\tif (\t!IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceDefault)\n\t\t\t\t\t|| !IsDriveLetterAvailable (mount->nDosDriveNo, DeviceNamespaceGlobal)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t\tTCDeleteDeviceObject (NewDeviceObject, NewExtension);\n\t\t\t\t\t\tmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\t\t\t\t\t\treturn ERR_DRIVE_NOT_FOUND;\n\t\t\t\t}\n\n\t\t\t\tif (mount->bMountManager)\n\t\t\t\t\tMountManagerMount (mount);\n\n\t\t\t\tNewExtension->bMountManager = mount->bMountManager;\n\n\t\t\t\t// We create symbolic link even if mount manager is notified of\n\t\t\t\t// arriving volume as it apparently sometimes fails to create the link\n\t\t\t\tCreateDriveLink (mount->nDosDriveNo);\n\n\t\t\t\tmount->FilesystemDirty = FALSE;\n\n\t\t\t\tif (NT_SUCCESS (TCOpenFsVolume (NewExtension, &volumeHandle, &volumeFileObject)))\n\t\t\t\t{\n\t\t\t\t\t__try\n\t\t\t\t\t{\n\t\t\t\t\t\tULONG fsStatus;\n\n\t\t\t\t\t\tif (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &fsStatus, sizeof (fsStatus)))\n\t\t\t\t\t\t\t&& (fsStatus & VOLUME_IS_DIRTY))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmount->FilesystemDirty = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t\t\t\t{\n\t\t\t\t\t\tmount->FilesystemDirty = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// detect if the filesystem is NTFS or FAT\n\t\t\t\t\t__try\n\t\t\t\t\t{\n\t\t\t\t\t\tNTFS_VOLUME_DATA_BUFFER ntfsData;\n\t\t\t\t\t\tif (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbIsNTFS = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t\t\t\t{\n\t\t\t\t\t\tbIsNTFS = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tNewExtension->bIsNTFS = bIsNTFS;\n\t\t\t\t\tmount->bIsNTFS = bIsNTFS;\n\n\t\t\t\t\tif (labelLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (bIsNTFS)\n\t\t\t\t\t\t\tlabelMaxLen = 32; // NTFS maximum label length\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlabelMaxLen = 11; // FAT maximum label length\n\n\t\t\t\t\t\t// calculate label effective length\n\t\t\t\t\t\tlabelEffectiveLen = labelLen > labelMaxLen? labelMaxLen : labelLen;\n\n\t\t\t\t\t\t// correct the label in the device\n\t\t\t\t\t\tmemset (&NewExtension->wszLabel[labelEffectiveLen], 0, 33 - labelEffectiveLen);\n\t\t\t\t\t\tmemcpy (mount->wszLabel, NewExtension->wszLabel, 33);\n\n\t\t\t\t\t\t// set the volume label\n\t\t\t\t\t\t__try\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIO_STATUS_BLOCK ioblock;\n\t\t\t\t\t\t\tULONG labelInfoSize = sizeof(FILE_FS_LABEL_INFORMATION) + (labelEffectiveLen * sizeof(WCHAR));\n\t\t\t\t\t\t\tFILE_FS_LABEL_INFORMATION* labelInfo = (FILE_FS_LABEL_INFORMATION*) TCalloc (labelInfoSize);\n\t\t\t\t\t\t\tif (labelInfo)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlabelInfo->VolumeLabelLength = labelEffectiveLen * sizeof(WCHAR);\n\t\t\t\t\t\t\t\tmemcpy (labelInfo->VolumeLabel, mount->wszLabel, labelInfo->VolumeLabelLength);\n\n\t\t\t\t\t\t\t\tif (STATUS_SUCCESS == ZwSetVolumeInformationFile (volumeHandle, &ioblock, labelInfo, labelInfoSize, FileFsLabelInformation))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmount->bDriverSetLabel = TRUE;\n\t\t\t\t\t\t\t\t\tNewExtension->bDriverSetLabel = TRUE;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tTCfree(labelInfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDump (\"Mount FAILURE TC code = 0x%08x\\n\", mount->nReturnCode);\n\t\t\t\tTCDeleteDeviceObject (NewDeviceObject, NewExtension);\n\t\t\t}\n\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\t}\n}\n\nNTSTATUS UnmountDevice (UNMOUNT_STRUCT *unmountRequest, PDEVICE_OBJECT deviceObject, BOOL ignoreOpenFiles)\n{\n\tPEXTENSION extension = deviceObject->DeviceExtension;\n\tNTSTATUS ntStatus;\n\tHANDLE volumeHandle;\n\tPFILE_OBJECT volumeFileObject;\n\n\tDump (\"UnmountDevice %d\\n\", extension->nDosDriveNo);\n\n\tntStatus = TCOpenFsVolume (extension, &volumeHandle, &volumeFileObject);\n\n\tif (NT_SUCCESS (ntStatus))\n\t{\n\t\tint dismountRetry;\n\n\t\t// Dismounting a writable NTFS filesystem prevents the driver from being unloaded on Windows 7\n\t\tif (IsOSAtLeast (WIN_7) && !extension->bReadOnly)\n\t\t{\n\t\t\tNTFS_VOLUME_DATA_BUFFER ntfsData;\n\n\t\t\tif (NT_SUCCESS (TCFsctlCall (volumeFileObject, FSCTL_GET_NTFS_VOLUME_DATA, NULL, 0, &ntfsData, sizeof (ntfsData))))\n\t\t\t\tDriverUnloadDisabled = TRUE;\n\t\t}\n\n\t\t// Lock volume\n\t\tntStatus = TCFsctlCall (volumeFileObject, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);\n\t\tDump (\"FSCTL_LOCK_VOLUME returned %X\\n\", ntStatus);\n\n\t\tif (!NT_SUCCESS (ntStatus) && !ignoreOpenFiles)\n\t\t{\n\t\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\t\t\treturn ERR_FILES_OPEN;\n\t\t}\n\n\t\t// Dismount volume\n\t\tfor (dismountRetry = 0; dismountRetry < 200; ++dismountRetry)\n\t\t{\n\t\t\tntStatus = TCFsctlCall (volumeFileObject, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);\n\t\t\tDump (\"FSCTL_DISMOUNT_VOLUME returned %X\\n\", ntStatus);\n\n\t\t\tif (NT_SUCCESS (ntStatus) || ntStatus == STATUS_VOLUME_DISMOUNTED)\n\t\t\t\tbreak;\n\n\t\t\tif (!ignoreOpenFiles)\n\t\t\t{\n\t\t\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\t\t\t\treturn ERR_FILES_OPEN;\n\t\t\t}\n\n\t\t\tTCSleep (100);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Volume cannot be opened => force dismount if allowed\n\t\tif (!ignoreOpenFiles)\n\t\t\treturn ERR_FILES_OPEN;\n\t\telse\n\t\t\tvolumeHandle = NULL;\n\t}\n\n\tif (extension->bMountManager)\n\t\tMountManagerUnmount (extension->nDosDriveNo);\n\n\t// We always remove symbolic link as mount manager might fail to do so\n\tRemoveDriveLink (extension->nDosDriveNo);\n\n\textension->bShuttingDown = TRUE;\n\n\tntStatus = IoAcquireRemoveLock (&extension->Queue.RemoveLock, NULL);\n\tASSERT (NT_SUCCESS (ntStatus));\n\tIoReleaseRemoveLockAndWait (&extension->Queue.RemoveLock, NULL);\n\n\tif (volumeHandle != NULL)\n\t\tTCCloseFsVolume (volumeHandle, volumeFileObject);\n\n\tif (unmountRequest)\n\t{\n\t\tPCRYPTO_INFO cryptoInfo = ((PEXTENSION) deviceObject->DeviceExtension)->cryptoInfo;\n\t\tunmountRequest->HiddenVolumeProtectionTriggered = (cryptoInfo->bProtectHiddenVolume && cryptoInfo->bHiddenVolProtectionAction);\n\t}\n\n\tTCDeleteDeviceObject (deviceObject, (PEXTENSION) deviceObject->DeviceExtension);\n\treturn 0;\n}\n\n\nstatic PDEVICE_OBJECT FindVolumeWithHighestUniqueId (int maxUniqueId)\n{\n\tPDEVICE_OBJECT highestIdDevice = NULL;\n\tint highestId = -1;\n\tint drive;\n\n\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t{\n\t\tPDEVICE_OBJECT device = GetVirtualVolumeDeviceObject (drive);\n\t\tif (device)\n\t\t{\n\t\t\tPEXTENSION extension = (PEXTENSION) device->DeviceExtension;\n\t\t\tif (extension->UniqueVolumeId > highestId && extension->UniqueVolumeId <= maxUniqueId)\n\t\t\t{\n\t\t\t\thighestId = extension->UniqueVolumeId;\n\t\t\t\thighestIdDevice = device;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn highestIdDevice;\n}\n\n\nNTSTATUS UnmountAllDevices (UNMOUNT_STRUCT *unmountRequest, BOOL ignoreOpenFiles)\n{\n\tNTSTATUS status = 0;\n\tPDEVICE_OBJECT ListDevice;\n\tint maxUniqueId = LastUniqueVolumeId;\n\n\tDump (\"Unmounting all volumes\\n\");\n\n\tif (unmountRequest)\n\t\tunmountRequest->HiddenVolumeProtectionTriggered = FALSE;\n\n\t// Dismount volumes in the reverse order they were mounted to properly dismount nested volumes\n\twhile ((ListDevice = FindVolumeWithHighestUniqueId (maxUniqueId)) != NULL)\n\t{\n\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\tmaxUniqueId = ListExtension->UniqueVolumeId - 1;\n\n\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t{\n\t\t\tNTSTATUS ntStatus;\n\n\t\t\tif (unmountRequest)\n\t\t\t\tunmountRequest->nDosDriveNo = ListExtension->nDosDriveNo;\n\n\t\t\tntStatus = UnmountDevice (unmountRequest, ListDevice, ignoreOpenFiles);\n\t\t\tstatus = ntStatus == 0 ? status : ntStatus;\n\n\t\t\tif (unmountRequest && unmountRequest->HiddenVolumeProtectionTriggered)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n// Resolves symbolic link name to its target name\nNTSTATUS SymbolicLinkToTarget (PWSTR symlinkName, PWSTR targetName, USHORT maxTargetNameLength)\n{\n\tNTSTATUS ntStatus;\n\tOBJECT_ATTRIBUTES objectAttributes;\n\tUNICODE_STRING fullFileName;\n\tHANDLE handle;\n\n\tRtlInitUnicodeString (&fullFileName, symlinkName);\n\tInitializeObjectAttributes (&objectAttributes, &fullFileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n\tntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);\n\n\tif (NT_SUCCESS (ntStatus))\n\t{\n\t\tUNICODE_STRING target;\n\t\ttarget.Buffer = targetName;\n\t\ttarget.Length = 0;\n\t\ttarget.MaximumLength = maxTargetNameLength;\n\t\tmemset (targetName, 0, maxTargetNameLength);\n\n\t\tntStatus = ZwQuerySymbolicLinkObject (handle, &target, NULL);\n\n\t\tZwClose (handle);\n\t}\n\n\treturn ntStatus;\n}\n\n\n// Checks if two regions overlap (borders are parts of regions)\nBOOL RegionsOverlap (unsigned __int64 start1, unsigned __int64 end1, unsigned __int64 start2, unsigned __int64 end2)\n{\n\treturn (start1 < start2) ? (end1 >= start2) : (start1 <= end2);\n}\n\n\nvoid GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)\n{\n\tuint64 end1 = start1 + length1 - 1;\n\tuint64 intersectEnd = (end1 <= end2) ? end1 : end2;\n\n\t*intersectStart = (start1 >= start2) ? start1 : start2;\n\t*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);\n\n\tif (*intersectLength == 0)\n\t\t*intersectStart = start1;\n}\n\n\nBOOL IsAccessibleByUser (PUNICODE_STRING objectFileName, BOOL readOnly)\n{\n\tOBJECT_ATTRIBUTES fileObjAttributes;\n\tIO_STATUS_BLOCK ioStatusBlock;\n\tHANDLE fileHandle;\n\tNTSTATUS status;\n\n\tASSERT (!IoIsSystemThread (PsGetCurrentThread()));\n\n\tInitializeObjectAttributes (&fileObjAttributes, objectFileName, OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\tstatus = ZwCreateFile (&fileHandle,\n\t\treadOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,\n\t\t&fileObjAttributes,\n\t\t&ioStatusBlock,\n\t\tNULL,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n\t\tFILE_OPEN,\n\t\tFILE_SYNCHRONOUS_IO_NONALERT,\n\t\tNULL,\n\t\t0);\n\n\tif (NT_SUCCESS (status))\n\t{\n\t\tZwClose (fileHandle);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\n\nBOOL UserCanAccessDriveDevice ()\n{\n\tUNICODE_STRING name;\n\tRtlInitUnicodeString (&name, L\"\\\\Device\\\\MountPointManager\");\n\n\treturn IsAccessibleByUser (&name, FALSE);\n}\n\nBOOL IsDriveLetterAvailable (int nDosDriveNo, DeviceNamespaceType namespaceType)\n{\n\tOBJECT_ATTRIBUTES objectAttributes;\n\tUNICODE_STRING objectName;\n\tWCHAR link[128];\n\tHANDLE handle;\n\tNTSTATUS ntStatus;\n\n\tTCGetDosNameFromNumber (link, sizeof(link),nDosDriveNo, namespaceType);\n\tRtlInitUnicodeString (&objectName, link);\n\tInitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n\tif (NT_SUCCESS (ntStatus = ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes)))\n\t{\n\t\tZwClose (handle);\n\t\treturn FALSE;\n\t}\n\n\treturn (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND)? TRUE : FALSE;\n}\n\n\nNTSTATUS TCCompleteIrp (PIRP irp, NTSTATUS status, ULONG_PTR information)\n{\n\tirp->IoStatus.Status = status;\n\tirp->IoStatus.Information = information;\n\tIoCompleteRequest (irp, IO_NO_INCREMENT);\n\treturn status;\n}\n\n\nNTSTATUS TCCompleteDiskIrp (PIRP irp, NTSTATUS status, ULONG_PTR information)\n{\n\tirp->IoStatus.Status = status;\n\tirp->IoStatus.Information = information;\n\tIoCompleteRequest (irp, NT_SUCCESS (status) ? IO_DISK_INCREMENT : IO_NO_INCREMENT);\n\treturn status;\n}\n\n\nsize_t GetCpuCount ()\n{\n\tKAFFINITY activeCpuMap = KeQueryActiveProcessors();\n\tsize_t mapSize = sizeof (activeCpuMap) * 8;\n\tsize_t cpuCount = 0;\n\n\twhile (mapSize--)\n\t{\n\t\tif (activeCpuMap & 1)\n\t\t\t++cpuCount;\n\n\t\tactiveCpuMap >>= 1;\n\t}\n\n\tif (cpuCount == 0)\n\t\treturn 1;\n\n\treturn cpuCount;\n}\n\n\nvoid EnsureNullTerminatedString (wchar_t *str, size_t maxSizeInBytes)\n{\n\tASSERT ((maxSizeInBytes & 1) == 0);\n\tstr[maxSizeInBytes / sizeof (wchar_t) - 1] = 0;\n}\n\n\nvoid *AllocateMemoryWithTimeout (size_t size, int retryDelay, int timeout)\n{\n\tLARGE_INTEGER waitInterval;\n\twaitInterval.QuadPart = retryDelay * -10000;\n\n\tASSERT (KeGetCurrentIrql() <= APC_LEVEL);\n\tASSERT (retryDelay > 0 && retryDelay <= timeout);\n\n\twhile (TRUE)\n\t{\n\t\tvoid *memory = TCalloc (size);\n\t\tif (memory)\n\t\t\treturn memory;\n\n\t\ttimeout -= retryDelay;\n\t\tif (timeout <= 0)\n\t\t\tbreak;\n\n\t\tKeDelayExecutionThread (KernelMode, FALSE, &waitInterval);\n\t}\n\n\treturn NULL;\n}\n\n\nNTSTATUS TCReadRegistryKey (PUNICODE_STRING keyPath, wchar_t *keyValueName, PKEY_VALUE_PARTIAL_INFORMATION *keyData)\n{\n\tOBJECT_ATTRIBUTES regObjAttribs;\n\tHANDLE regKeyHandle;\n\tNTSTATUS status;\n\tUNICODE_STRING valName;\n\tULONG size = 0;\n\tULONG resultSize;\n\n\tInitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\tstatus = ZwOpenKey (&regKeyHandle, KEY_READ, &regObjAttribs);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tRtlInitUnicodeString (&valName, keyValueName);\n\tstatus = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, NULL, 0, &size);\n\n\tif (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL)\n\t{\n\t\tZwClose (regKeyHandle);\n\t\treturn status;\n\t}\n\n\tif (size == 0)\n\t{\n\t\tZwClose (regKeyHandle);\n\t\treturn STATUS_NO_DATA_DETECTED;\n\t}\n\n\t*keyData = (PKEY_VALUE_PARTIAL_INFORMATION) TCalloc (size);\n\tif (!*keyData)\n\t{\n\t\tZwClose (regKeyHandle);\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\t}\n\n\tstatus = ZwQueryValueKey (regKeyHandle, &valName, KeyValuePartialInformation, *keyData, size, &resultSize);\n\n\tZwClose (regKeyHandle);\n\treturn status;\n}\n\n\nNTSTATUS TCWriteRegistryKey (PUNICODE_STRING keyPath, wchar_t *keyValueName, ULONG keyValueType, void *valueData, ULONG valueSize)\n{\n\tOBJECT_ATTRIBUTES regObjAttribs;\n\tHANDLE regKeyHandle;\n\tNTSTATUS status;\n\tUNICODE_STRING valName;\n\n\tInitializeObjectAttributes (&regObjAttribs, keyPath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);\n\tstatus = ZwOpenKey (&regKeyHandle, KEY_READ | KEY_WRITE, &regObjAttribs);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tRtlInitUnicodeString (&valName, keyValueName);\n\n\tstatus = ZwSetValueKey (regKeyHandle, &valName, 0, keyValueType, valueData, valueSize);\n\n\tZwClose (regKeyHandle);\n\treturn status;\n}\n\n\nBOOL IsVolumeClassFilterRegistered ()\n{\n\tUNICODE_STRING name;\n\tNTSTATUS status;\n\tBOOL registered = FALSE;\n\n\tPKEY_VALUE_PARTIAL_INFORMATION data;\n\n\tRtlInitUnicodeString (&name, L\"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Class\\\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}\");\n\tstatus = TCReadRegistryKey (&name, L\"UpperFilters\", &data);\n\n\tif (NT_SUCCESS (status))\n\t{\n\t\tif (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))\n\t\t{\n\t\t\t// Search for the string \"veracrypt\"\n\t\t\tULONG i;\n\t\t\tfor (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)\n\t\t\t{\n\t\t\t\tif (memcmp (data->Data + i, L\"veracrypt\", 9 * sizeof (wchar_t)) == 0)\n\t\t\t\t{\n\t\t\t\t\tDump (\"Volume class filter active\\n\");\n\t\t\t\t\tregistered = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTCfree (data);\n\t}\n\n\treturn registered;\n}\n\n\nNTSTATUS ReadRegistryConfigFlags (BOOL driverEntry)\n{\n\tPKEY_VALUE_PARTIAL_INFORMATION data;\n\tUNICODE_STRING name;\n\tNTSTATUS status;\n\tuint32 flags = 0;\n\n\tRtlInitUnicodeString (&name, L\"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\veracrypt\");\n\tstatus = TCReadRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, &data);\n\n\tif (NT_SUCCESS (status))\n\t{\n\t\tif (data->Type == REG_DWORD)\n\t\t{\n\t\t\tflags = *(uint32 *) data->Data;\n\t\t\tDump (\"Configuration flags = 0x%x\\n\", flags);\n\n\t\t\tif (driverEntry)\n\t\t\t{\n\t\t\t\tif (flags & (TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD | TC_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))\n\t\t\t\t\tCacheBootPassword = TRUE;\n\n\t\t\t\tif (flags & TC_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS)\n\t\t\t\t\tNonAdminSystemFavoritesAccessDisabled = TRUE;\n\n\t\t\t\tif (flags & TC_DRIVER_CONFIG_CACHE_BOOT_PIM)\n\t\t\t\t\tCacheBootPim = TRUE;\n\n\t\t\t\tif (flags & VC_DRIVER_CONFIG_BLOCK_SYS_TRIM)\n\t\t\t\t\tBlockSystemTrimCommand = TRUE;\n\t\t\t}\n\n\t\t\tEnableHwEncryption ((flags & TC_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION) ? FALSE : TRUE);\n\n\t\t\tEnableExtendedIoctlSupport = (flags & TC_DRIVER_CONFIG_ENABLE_EXTENDED_IOCTL)? TRUE : FALSE;\n\t\t\tAllowTrimCommand = (flags & VC_DRIVER_CONFIG_ALLOW_NONSYS_TRIM)? TRUE : FALSE;\n\t\t\tAllowWindowsDefrag = (flags & VC_DRIVER_CONFIG_ALLOW_WINDOWS_DEFRAG)? TRUE : FALSE;\n\t\t}\n\t\telse\n\t\t\tstatus = STATUS_INVALID_PARAMETER;\n\n\t\tTCfree (data);\n\t}\n\n\tif (driverEntry && NT_SUCCESS (TCReadRegistryKey (&name, TC_ENCRYPTION_FREE_CPU_COUNT_REG_VALUE_NAME, &data)))\n\t{\n\t\tif (data->Type == REG_DWORD)\n\t\t\tEncryptionThreadPoolFreeCpuCountLimit = *(uint32 *) data->Data;\n\n\t\tTCfree (data);\n\t}\n\n\treturn status;\n}\n\n\nNTSTATUS WriteRegistryConfigFlags (uint32 flags)\n{\n\tUNICODE_STRING name;\n\tRtlInitUnicodeString (&name, L\"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\veracrypt\");\n\n\treturn TCWriteRegistryKey (&name, TC_DRIVER_CONFIG_REG_VALUE_NAME, REG_DWORD, &flags, sizeof (flags));\n}\n\n\nNTSTATUS GetDeviceSectorSize (PDEVICE_OBJECT deviceObject, ULONG *bytesPerSector)\n{\n\tNTSTATUS status;\n\tDISK_GEOMETRY geometry;\n\n\tstatus = SendDeviceIoControlRequest (deviceObject, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry));\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\t*bytesPerSector = geometry.BytesPerSector;\n\t\n\treturn STATUS_SUCCESS;\n}\n\n\nNTSTATUS ZeroUnreadableSectors (PDEVICE_OBJECT deviceObject, LARGE_INTEGER startOffset, ULONG size, uint64 *zeroedSectorCount)\n{\n\tNTSTATUS status;\n\tULONG sectorSize;\n\tULONG sectorCount;\n\tbyte *sectorBuffer = NULL;\n\n\t*zeroedSectorCount = 0;\n\n\tstatus = GetDeviceSectorSize (deviceObject, &sectorSize);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tsectorBuffer = TCalloc (sectorSize);\n\tif (!sectorBuffer)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tfor (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize)\n\t{\n\t\tstatus = TCReadDevice (deviceObject, sectorBuffer, startOffset, sectorSize);\n\t\tif (!NT_SUCCESS (status))\n\t\t{\n\t\t\tDump (\"Zeroing sector at %I64d\\n\", startOffset.QuadPart);\n\t\t\tmemset (sectorBuffer, 0, sectorSize);\n\n\t\t\tstatus = TCWriteDevice (deviceObject, sectorBuffer, startOffset, sectorSize);\n\t\t\tif (!NT_SUCCESS (status))\n\t\t\t\tgoto err;\n\n\t\t\t++(*zeroedSectorCount);\n\t\t}\n\t}\n\n\tstatus = STATUS_SUCCESS;\n\nerr:\n\tif (sectorBuffer)\n\t\tTCfree (sectorBuffer);\n\n\treturn status;\n}\n\n\nNTSTATUS ReadDeviceSkipUnreadableSectors (PDEVICE_OBJECT deviceObject, byte *buffer, LARGE_INTEGER startOffset, ULONG size, uint64 *badSectorCount)\n{\n\tNTSTATUS status;\n\tULONG sectorSize;\n\tULONG sectorCount;\n\n\t*badSectorCount = 0;\n\n\tstatus = GetDeviceSectorSize (deviceObject, &sectorSize);\n\tif (!NT_SUCCESS (status))\n\t\treturn status;\n\n\tfor (sectorCount = size / sectorSize; sectorCount > 0; --sectorCount, startOffset.QuadPart += sectorSize, buffer += sectorSize)\n\t{\n\t\tstatus = TCReadDevice (deviceObject, buffer, startOffset, sectorSize);\n\t\tif (!NT_SUCCESS (status))\n\t\t{\n\t\t\tDump (\"Skipping bad sector at %I64d\\n\", startOffset.QuadPart);\n\t\t\tmemset (buffer, 0, sectorSize);\n\t\t\t++(*badSectorCount);\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\n\nBOOL IsVolumeAccessibleByCurrentUser (PEXTENSION volumeDeviceExtension)\n{\n\tSECURITY_SUBJECT_CONTEXT subContext;\n\tPACCESS_TOKEN accessToken;\n\tPTOKEN_USER tokenUser;\n\tBOOL result = FALSE;\n\n\tif (IoIsSystemThread (PsGetCurrentThread())\n\t\t|| UserCanAccessDriveDevice()\n\t\t|| !volumeDeviceExtension->UserSid\n\t\t|| (volumeDeviceExtension->SystemFavorite && !NonAdminSystemFavoritesAccessDisabled))\n\t{\n\t\treturn TRUE;\n\t}\n\n\tSeCaptureSubjectContext (&subContext);\n\tSeLockSubjectContext(&subContext);\n\tif (subContext.ClientToken && subContext.ImpersonationLevel >= SecurityImpersonation)\n\t\taccessToken = subContext.ClientToken;\n\telse\n\t\taccessToken = subContext.PrimaryToken;\n\n\tif (!accessToken)\n\t\tgoto ret;\n\n\tif (SeTokenIsAdmin (accessToken))\n\t{\n\t\tresult = TRUE;\n\t\tgoto ret;\n\t}\n\n\tif (!NT_SUCCESS (SeQueryInformationToken (accessToken, TokenUser, &tokenUser)))\n\t\tgoto ret;\n\n\tresult = RtlEqualSid (volumeDeviceExtension->UserSid, tokenUser->User.Sid);\n\tExFreePool (tokenUser);\t\t// Documented in newer versions of WDK\n\nret:\n\tSeUnlockSubjectContext(&subContext);\n\tSeReleaseSubjectContext (&subContext);\n\treturn result;\n}\n\n\nvoid GetElapsedTimeInit (LARGE_INTEGER *lastPerfCounter)\n{\n\t*lastPerfCounter = KeQueryPerformanceCounter (NULL);\n}\n\n\n// Returns elapsed time in microseconds since last call\nint64 GetElapsedTime (LARGE_INTEGER *lastPerfCounter)\n{\n\tLARGE_INTEGER freq;\n\tLARGE_INTEGER counter = KeQueryPerformanceCounter (&freq);\n\n\tint64 elapsed = (counter.QuadPart - lastPerfCounter->QuadPart) * 1000000LL / freq.QuadPart;\n\t*lastPerfCounter = counter;\n\n\treturn elapsed;\n}\n\n\nBOOL IsOSAtLeast (OSVersionEnum reqMinOS)\n{\n\t/* When updating this function, update IsOSVersionAtLeast() in Dlgcode.c too. */\n\n\tULONG major = 0, minor = 0;\n\n\tASSERT (OsMajorVersion != 0);\n\n\tswitch (reqMinOS)\n\t{\n\tcase WIN_2000:\t\t\tmajor = 5; minor = 0; break;\n\tcase WIN_XP:\t\t\tmajor = 5; minor = 1; break;\n\tcase WIN_SERVER_2003:\tmajor = 5; minor = 2; break;\n\tcase WIN_VISTA:\t\t\tmajor = 6; minor = 0; break;\n\tcase WIN_7:\t\t\t\tmajor = 6; minor = 1; break;\n\tcase WIN_8:\t\t\t\tmajor = 6; minor = 2; break;\n\tcase WIN_8_1:\t\t\tmajor = 6; minor = 3; break;\n\tcase WIN_10:\t\t\tmajor = 10; minor = 0; break;\n\n\tdefault:\n\t\tTC_THROW_FATAL_EXCEPTION;\n\t\tbreak;\n\t}\n\n\treturn ((OsMajorVersion << 16 | OsMinorVersion << 8)\n\t\t>= (major << 16 | minor << 8));\n}\n\nNTSTATUS NTAPI KeSaveExtendedProcessorState (\n    __in ULONG64 Mask,\n    PXSTATE_SAVE XStateSave\n    )\n{\n\tif (KeSaveExtendedProcessorStatePtr)\n\t{\n\t\treturn (KeSaveExtendedProcessorStatePtr) (Mask, XStateSave);\n\t}\n\telse\n\t{\n\t\treturn STATUS_SUCCESS;\n\t}\n}\n\nVOID NTAPI KeRestoreExtendedProcessorState (\n\tPXSTATE_SAVE XStateSave\n\t)\n{\n\tif (KeRestoreExtendedProcessorStatePtr)\n\t{\n\t\t(KeRestoreExtendedProcessorStatePtr) (XStateSave);\n\t}\n}"], "buggy_code_start_loc": [1905], "buggy_code_end_loc": [1983], "fixing_code_start_loc": [1905], "fixing_code_end_loc": [2016], "type": "CWE-119", "message": "IDRIX, Truecrypt Veracrypt, Truecrypt Prior to 1.23-Hotfix-1 (Veracrypt), all versions (Truecrypt) is affected by: Buffer Overflow. The impact is: Minor information disclosure of kernel stack. The component is: Veracrypt NT Driver (veracrypt.sys). The attack vector is: Locally executed code, IOCTL request to driver. The fixed version is: 1.23-Hotfix-1.", "other": {"cve": {"id": "CVE-2019-1010208", "sourceIdentifier": "josh@bress.net", "published": "2019-07-23T14:15:13.653", "lastModified": "2019-08-05T15:38:45.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "IDRIX, Truecrypt Veracrypt, Truecrypt Prior to 1.23-Hotfix-1 (Veracrypt), all versions (Truecrypt) is affected by: Buffer Overflow. The impact is: Minor information disclosure of kernel stack. The component is: Veracrypt NT Driver (veracrypt.sys). The attack vector is: Locally executed code, IOCTL request to driver. The fixed version is: 1.23-Hotfix-1."}, {"lang": "es", "value": "IDRIX, Truecrypt Veracrypt, Truecrypt Anterior de 1.23-Hotfix-1 (Veracrypt), todas las versiones (Truecrypt) se ven afectadas por: Desbordamiento de b\u00fafer. El impacto es: Divulgaci\u00f3n de informaci\u00f3n menor de la pila del Kernel. El componente es: Veracrypt NT Driver (veracrypt.sys). El vector de ataque es: C\u00f3digo ejecutado localmente, solicitud IOCTL al controlador. La versi\u00f3n fija es: 1.23-Hotfix-1."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:idrix:truecrypt:*:*:*:*:*:*:*:*", "matchCriteriaId": "13EECFB7-E7D4-4F13-B81E-E93BC115A4AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:idrix:veracrypt:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.23", "matchCriteriaId": "6C6722F8-DB59-465A-9044-AF4F61F579C3"}]}]}], "references": [{"url": "https://github.com/veracrypt/VeraCrypt/commit/f30f9339c9a0b9bbcc6f5ad38804af39db1f479e", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/veracrypt/VeraCrypt/commit/f30f9339c9a0b9bbcc6f5ad38804af39db1f479e"}}