{"buggy_code": ["\nStarlette includes a `Request` class that gives you a nicer interface onto\nthe incoming request, rather than accessing the ASGI scope and receive channel directly.\n\n### Request\n\nSignature: `Request(scope, receive=None)`\n\n```python\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    content = '%s %s' % (request.method, request.url.path)\n    response = Response(content, media_type='text/plain')\n    await response(scope, receive, send)\n```\n\nRequests present a mapping interface, so you can use them in the same\nway as a `scope`.\n\nFor instance: `request['path']` will return the ASGI path.\n\nIf you don't need to access the request body you can instantiate a request\nwithout providing an argument to `receive`.\n\n#### Method\n\nThe request method is accessed as `request.method`.\n\n#### URL\n\nThe request URL is accessed as `request.url`.\n\nThe property is a string-like object that exposes all the\ncomponents that can be parsed out of the URL.\n\nFor example: `request.url.path`, `request.url.port`, `request.url.scheme`.\n\n#### Headers\n\nHeaders are exposed as an immutable, case-insensitive, multi-dict.\n\nFor example: `request.headers['content-type']`\n\n#### Query Parameters\n\nQuery parameters are exposed as an immutable multi-dict.\n\nFor example: `request.query_params['search']`\n\n#### Path Parameters\n\nRouter path parameters are exposed as a dictionary interface.\n\nFor example: `request.path_params['username']`\n\n#### Client Address\n\nThe client's remote address is exposed as a named two-tuple `request.client`.\nEither item in the tuple may be `None`.\n\nThe hostname or IP address: `request.client.host`\n\nThe port number from which the client is connecting: `request.client.port`\n\n#### Cookies\n\nCookies are exposed as a regular dictionary interface.\n\nFor example: `request.cookies.get('mycookie')`\n\nCookies are ignored in case of an invalid cookie. (RFC2109)\n\n#### Body\n\nThere are a few different interfaces for returning the body of the request:\n\nThe request body as bytes: `await request.body()`\n\nThe request body, parsed as form data or multipart: `async with request.form() as form:`\n\nThe request body, parsed as JSON: `await request.json()`\n\nYou can also access the request body as a stream, using the `async for` syntax:\n\n```python\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\n    \nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    body = b''\n    async for chunk in request.stream():\n        body += chunk\n    response = Response(body, media_type='text/plain')\n    await response(scope, receive, send)\n```\n\nIf you access `.stream()` then the byte chunks are provided without storing\nthe entire body to memory. Any subsequent calls to `.body()`, `.form()`, or `.json()`\nwill raise an error.\n\nIn some cases such as long-polling, or streaming responses you might need to\ndetermine if the client has dropped the connection. You can determine this\nstate with `disconnected = await request.is_disconnected()`.\n\n#### Request Files\n\nRequest files are normally sent as multipart form data (`multipart/form-data`).\n\nWhen you call `async with request.form() as form` you receive a `starlette.datastructures.FormData` which is an immutable\nmultidict, containing both file uploads and text input. File upload items are represented as instances of `starlette.datastructures.UploadFile`.\n\n`UploadFile` has the following attributes:\n\n* `filename`: An `str` with the original file name that was uploaded or `None` if its not available (e.g. `myimage.jpg`).\n* `content_type`: An `str` with the content type (MIME type / media type) or `None` if it's not available (e.g. `image/jpeg`).\n* `file`: A <a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" target=\"_blank\">`SpooledTemporaryFile`</a> (a <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" target=\"_blank\">file-like</a> object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object.\n* `headers`: A `Headers` object. Often this will only be the `Content-Type` header, but if additional headers were included in the multipart field they will be included here. Note that these headers have no relationship with the headers in `Request.headers`.\n* `size`: An `int` with uploaded file's size in bytes. This value is calculated from request's contents, making it better choice to find uploaded file's size than `Content-Length` header. `None` if not set.\n\n`UploadFile` has the following `async` methods. They all call the corresponding file methods underneath (using the internal `SpooledTemporaryFile`).\n\n* `async write(data)`: Writes `data` (`bytes`) to the file.\n* `async read(size)`: Reads `size` (`int`) bytes of the file.\n* `async seek(offset)`: Goes to the byte position `offset` (`int`) in the file.\n    * E.g., `await myfile.seek(0)` would go to the start of the file.\n* `async close()`: Closes the file.\n\nAs all these methods are `async` methods, you need to \"await\" them.\n\nFor example, you can get the file name and the contents with:\n\n```python\nasync with request.form() as form:\n    filename = form[\"upload_file\"].filename\n    contents = await form[\"upload_file\"].read()\n```\n\n!!! info\n    As settled in [RFC-7578: 4.2](https://www.ietf.org/rfc/rfc7578.txt), form-data content part that contains file \n    assumed to have `name` and `filename` fields in `Content-Disposition` header: `Content-Disposition: form-data;\n    name=\"user\"; filename=\"somefile\"`. Though `filename` field is optional according to RFC-7578, it helps \n    Starlette to differentiate which data should be treated as file. If `filename` field was supplied, `UploadFile` \n    object will be created to access underlying file, otherwise form-data part will be parsed and available as a raw \n    string.\n\n#### Application\n\nThe originating Starlette application can be accessed via `request.app`.\n\n#### Other state\n\nIf you want to store additional information on the request you can do so\nusing `request.state`.\n\nFor example:\n\n`request.state.time_started = time.time()`\n", "import typing\nfrom enum import Enum\nfrom tempfile import SpooledTemporaryFile\nfrom urllib.parse import unquote_plus\n\nfrom starlette.datastructures import FormData, Headers, UploadFile\n\ntry:\n    import multipart\n    from multipart.multipart import parse_options_header\nexcept ImportError:  # pragma: nocover\n    parse_options_header = None\n    multipart = None\n\n\nclass FormMessage(Enum):\n    FIELD_START = 1\n    FIELD_NAME = 2\n    FIELD_DATA = 3\n    FIELD_END = 4\n    END = 5\n\n\nclass MultiPartMessage(Enum):\n    PART_BEGIN = 1\n    PART_DATA = 2\n    PART_END = 3\n    HEADER_FIELD = 4\n    HEADER_VALUE = 5\n    HEADER_END = 6\n    HEADERS_FINISHED = 7\n    END = 8\n\n\ndef _user_safe_decode(src: bytes, codec: str) -> str:\n    try:\n        return src.decode(codec)\n    except (UnicodeDecodeError, LookupError):\n        return src.decode(\"latin-1\")\n\n\nclass MultiPartException(Exception):\n    def __init__(self, message: str) -> None:\n        self.message = message\n\n\nclass FormParser:\n    def __init__(\n        self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]\n    ) -> None:\n        assert (\n            multipart is not None\n        ), \"The `python-multipart` library must be installed to use form parsing.\"\n        self.headers = headers\n        self.stream = stream\n        self.messages: typing.List[typing.Tuple[FormMessage, bytes]] = []\n\n    def on_field_start(self) -> None:\n        message = (FormMessage.FIELD_START, b\"\")\n        self.messages.append(message)\n\n    def on_field_name(self, data: bytes, start: int, end: int) -> None:\n        message = (FormMessage.FIELD_NAME, data[start:end])\n        self.messages.append(message)\n\n    def on_field_data(self, data: bytes, start: int, end: int) -> None:\n        message = (FormMessage.FIELD_DATA, data[start:end])\n        self.messages.append(message)\n\n    def on_field_end(self) -> None:\n        message = (FormMessage.FIELD_END, b\"\")\n        self.messages.append(message)\n\n    def on_end(self) -> None:\n        message = (FormMessage.END, b\"\")\n        self.messages.append(message)\n\n    async def parse(self) -> FormData:\n        # Callbacks dictionary.\n        callbacks = {\n            \"on_field_start\": self.on_field_start,\n            \"on_field_name\": self.on_field_name,\n            \"on_field_data\": self.on_field_data,\n            \"on_field_end\": self.on_field_end,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.QuerystringParser(callbacks)\n        field_name = b\"\"\n        field_value = b\"\"\n\n        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []\n\n        # Feed the parser with data from the request.\n        async for chunk in self.stream:\n            if chunk:\n                parser.write(chunk)\n            else:\n                parser.finalize()\n            messages = list(self.messages)\n            self.messages.clear()\n            for message_type, message_bytes in messages:\n                if message_type == FormMessage.FIELD_START:\n                    field_name = b\"\"\n                    field_value = b\"\"\n                elif message_type == FormMessage.FIELD_NAME:\n                    field_name += message_bytes\n                elif message_type == FormMessage.FIELD_DATA:\n                    field_value += message_bytes\n                elif message_type == FormMessage.FIELD_END:\n                    name = unquote_plus(field_name.decode(\"latin-1\"))\n                    value = unquote_plus(field_value.decode(\"latin-1\"))\n                    items.append((name, value))\n\n        return FormData(items)\n\n\nclass MultiPartParser:\n    max_file_size = 1024 * 1024\n\n    def __init__(\n        self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]\n    ) -> None:\n        assert (\n            multipart is not None\n        ), \"The `python-multipart` library must be installed to use form parsing.\"\n        self.headers = headers\n        self.stream = stream\n        self.messages: typing.List[typing.Tuple[MultiPartMessage, bytes]] = []\n\n    def on_part_begin(self) -> None:\n        message = (MultiPartMessage.PART_BEGIN, b\"\")\n        self.messages.append(message)\n\n    def on_part_data(self, data: bytes, start: int, end: int) -> None:\n        message = (MultiPartMessage.PART_DATA, data[start:end])\n        self.messages.append(message)\n\n    def on_part_end(self) -> None:\n        message = (MultiPartMessage.PART_END, b\"\")\n        self.messages.append(message)\n\n    def on_header_field(self, data: bytes, start: int, end: int) -> None:\n        message = (MultiPartMessage.HEADER_FIELD, data[start:end])\n        self.messages.append(message)\n\n    def on_header_value(self, data: bytes, start: int, end: int) -> None:\n        message = (MultiPartMessage.HEADER_VALUE, data[start:end])\n        self.messages.append(message)\n\n    def on_header_end(self) -> None:\n        message = (MultiPartMessage.HEADER_END, b\"\")\n        self.messages.append(message)\n\n    def on_headers_finished(self) -> None:\n        message = (MultiPartMessage.HEADERS_FINISHED, b\"\")\n        self.messages.append(message)\n\n    def on_end(self) -> None:\n        message = (MultiPartMessage.END, b\"\")\n        self.messages.append(message)\n\n    async def parse(self) -> FormData:\n        # Parse the Content-Type header to get the multipart boundary.\n        _, params = parse_options_header(self.headers[\"Content-Type\"])\n        charset = params.get(b\"charset\", \"utf-8\")\n        if type(charset) == bytes:\n            charset = charset.decode(\"latin-1\")\n        try:\n            boundary = params[b\"boundary\"]\n        except KeyError:\n            raise MultiPartException(\"Missing boundary in multipart.\")\n\n        # Callbacks dictionary.\n        callbacks = {\n            \"on_part_begin\": self.on_part_begin,\n            \"on_part_data\": self.on_part_data,\n            \"on_part_end\": self.on_part_end,\n            \"on_header_field\": self.on_header_field,\n            \"on_header_value\": self.on_header_value,\n            \"on_header_end\": self.on_header_end,\n            \"on_headers_finished\": self.on_headers_finished,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.MultipartParser(boundary, callbacks)\n        header_field = b\"\"\n        header_value = b\"\"\n        content_disposition = None\n        field_name = \"\"\n        data = b\"\"\n        file: typing.Optional[UploadFile] = None\n\n        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []\n        item_headers: typing.List[typing.Tuple[bytes, bytes]] = []\n\n        # Feed the parser with data from the request.\n        async for chunk in self.stream:\n            parser.write(chunk)\n            messages = list(self.messages)\n            self.messages.clear()\n            for message_type, message_bytes in messages:\n                if message_type == MultiPartMessage.PART_BEGIN:\n                    content_disposition = None\n                    data = b\"\"\n                    item_headers = []\n                elif message_type == MultiPartMessage.HEADER_FIELD:\n                    header_field += message_bytes\n                elif message_type == MultiPartMessage.HEADER_VALUE:\n                    header_value += message_bytes\n                elif message_type == MultiPartMessage.HEADER_END:\n                    field = header_field.lower()\n                    if field == b\"content-disposition\":\n                        content_disposition = header_value\n                    item_headers.append((field, header_value))\n                    header_field = b\"\"\n                    header_value = b\"\"\n                elif message_type == MultiPartMessage.HEADERS_FINISHED:\n                    disposition, options = parse_options_header(content_disposition)\n                    try:\n                        field_name = _user_safe_decode(options[b\"name\"], charset)\n                    except KeyError:\n                        raise MultiPartException(\n                            'The Content-Disposition header field \"name\" must be '\n                            \"provided.\"\n                        )\n                    if b\"filename\" in options:\n                        filename = _user_safe_decode(options[b\"filename\"], charset)\n                        tempfile = SpooledTemporaryFile(max_size=self.max_file_size)\n                        file = UploadFile(\n                            file=tempfile,  # type: ignore[arg-type]\n                            size=0,\n                            filename=filename,\n                            headers=Headers(raw=item_headers),\n                        )\n                    else:\n                        file = None\n                elif message_type == MultiPartMessage.PART_DATA:\n                    if file is None:\n                        data += message_bytes\n                    else:\n                        await file.write(message_bytes)\n                elif message_type == MultiPartMessage.PART_END:\n                    if file is None:\n                        items.append((field_name, _user_safe_decode(data, charset)))\n                    else:\n                        await file.seek(0)\n                        items.append((field_name, file))\n\n        parser.finalize()\n        return FormData(items)\n", "import json\nimport typing\nfrom http import cookies as http_cookies\n\nimport anyio\n\nfrom starlette._utils import AwaitableOrContextManager, AwaitableOrContextManagerWrapper\nfrom starlette.datastructures import URL, Address, FormData, Headers, QueryParams, State\nfrom starlette.exceptions import HTTPException\nfrom starlette.formparsers import FormParser, MultiPartException, MultiPartParser\nfrom starlette.types import Message, Receive, Scope, Send\n\ntry:\n    from multipart.multipart import parse_options_header\nexcept ImportError:  # pragma: nocover\n    parse_options_header = None\n\n\nif typing.TYPE_CHECKING:\n    from starlette.routing import Router\n\n\nSERVER_PUSH_HEADERS_TO_COPY = {\n    \"accept\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"cache-control\",\n    \"user-agent\",\n}\n\n\ndef cookie_parser(cookie_string: str) -> typing.Dict[str, str]:\n    \"\"\"\n    This function parses a ``Cookie`` HTTP header into a dict of key/value pairs.\n\n    It attempts to mimic browser cookie parsing behavior: browsers and web servers\n    frequently disregard the spec (RFC 6265) when setting and reading cookies,\n    so we attempt to suit the common scenarios here.\n\n    This function has been adapted from Django 3.1.0.\n    Note: we are explicitly _NOT_ using `SimpleCookie.load` because it is based\n    on an outdated spec and will fail on lots of input we want to support\n    \"\"\"\n    cookie_dict: typing.Dict[str, str] = {}\n    for chunk in cookie_string.split(\";\"):\n        if \"=\" in chunk:\n            key, val = chunk.split(\"=\", 1)\n        else:\n            # Assume an empty name per\n            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091\n            key, val = \"\", chunk\n        key, val = key.strip(), val.strip()\n        if key or val:\n            # unquote using Python's algorithm.\n            cookie_dict[key] = http_cookies._unquote(val)\n    return cookie_dict\n\n\nclass ClientDisconnect(Exception):\n    pass\n\n\nclass HTTPConnection(typing.Mapping[str, typing.Any]):\n    \"\"\"\n    A base class for incoming HTTP connections, that is used to provide\n    any functionality that is common to both `Request` and `WebSocket`.\n    \"\"\"\n\n    def __init__(self, scope: Scope, receive: typing.Optional[Receive] = None) -> None:\n        assert scope[\"type\"] in (\"http\", \"websocket\")\n        self.scope = scope\n\n    def __getitem__(self, key: str) -> typing.Any:\n        return self.scope[key]\n\n    def __iter__(self) -> typing.Iterator[str]:\n        return iter(self.scope)\n\n    def __len__(self) -> int:\n        return len(self.scope)\n\n    # Don't use the `abc.Mapping.__eq__` implementation.\n    # Connection instances should never be considered equal\n    # unless `self is other`.\n    __eq__ = object.__eq__\n    __hash__ = object.__hash__\n\n    @property\n    def app(self) -> typing.Any:\n        return self.scope[\"app\"]\n\n    @property\n    def url(self) -> URL:\n        if not hasattr(self, \"_url\"):\n            self._url = URL(scope=self.scope)\n        return self._url\n\n    @property\n    def base_url(self) -> URL:\n        if not hasattr(self, \"_base_url\"):\n            base_url_scope = dict(self.scope)\n            base_url_scope[\"path\"] = \"/\"\n            base_url_scope[\"query_string\"] = b\"\"\n            base_url_scope[\"root_path\"] = base_url_scope.get(\n                \"app_root_path\", base_url_scope.get(\"root_path\", \"\")\n            )\n            self._base_url = URL(scope=base_url_scope)\n        return self._base_url\n\n    @property\n    def headers(self) -> Headers:\n        if not hasattr(self, \"_headers\"):\n            self._headers = Headers(scope=self.scope)\n        return self._headers\n\n    @property\n    def query_params(self) -> QueryParams:\n        if not hasattr(self, \"_query_params\"):\n            self._query_params = QueryParams(self.scope[\"query_string\"])\n        return self._query_params\n\n    @property\n    def path_params(self) -> typing.Dict[str, typing.Any]:\n        return self.scope.get(\"path_params\", {})\n\n    @property\n    def cookies(self) -> typing.Dict[str, str]:\n        if not hasattr(self, \"_cookies\"):\n            cookies: typing.Dict[str, str] = {}\n            cookie_header = self.headers.get(\"cookie\")\n\n            if cookie_header:\n                cookies = cookie_parser(cookie_header)\n            self._cookies = cookies\n        return self._cookies\n\n    @property\n    def client(self) -> typing.Optional[Address]:\n        # client is a 2 item tuple of (host, port), None or missing\n        host_port = self.scope.get(\"client\")\n        if host_port is not None:\n            return Address(*host_port)\n        return None\n\n    @property\n    def session(self) -> typing.Dict[str, typing.Any]:\n        assert (\n            \"session\" in self.scope\n        ), \"SessionMiddleware must be installed to access request.session\"\n        return self.scope[\"session\"]\n\n    @property\n    def auth(self) -> typing.Any:\n        assert (\n            \"auth\" in self.scope\n        ), \"AuthenticationMiddleware must be installed to access request.auth\"\n        return self.scope[\"auth\"]\n\n    @property\n    def user(self) -> typing.Any:\n        assert (\n            \"user\" in self.scope\n        ), \"AuthenticationMiddleware must be installed to access request.user\"\n        return self.scope[\"user\"]\n\n    @property\n    def state(self) -> State:\n        if not hasattr(self, \"_state\"):\n            # Ensure 'state' has an empty dict if it's not already populated.\n            self.scope.setdefault(\"state\", {})\n            # Create a state instance with a reference to the dict in which it should\n            # store info\n            self._state = State(self.scope[\"state\"])\n        return self._state\n\n    def url_for(self, name: str, **path_params: typing.Any) -> str:\n        router: Router = self.scope[\"router\"]\n        url_path = router.url_path_for(name, **path_params)\n        return url_path.make_absolute_url(base_url=self.base_url)\n\n\nasync def empty_receive() -> typing.NoReturn:\n    raise RuntimeError(\"Receive channel has not been made available\")\n\n\nasync def empty_send(message: Message) -> typing.NoReturn:\n    raise RuntimeError(\"Send channel has not been made available\")\n\n\nclass Request(HTTPConnection):\n    _form: typing.Optional[FormData]\n\n    def __init__(\n        self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send\n    ):\n        super().__init__(scope)\n        assert scope[\"type\"] == \"http\"\n        self._receive = receive\n        self._send = send\n        self._stream_consumed = False\n        self._is_disconnected = False\n        self._form = None\n\n    @property\n    def method(self) -> str:\n        return self.scope[\"method\"]\n\n    @property\n    def receive(self) -> Receive:\n        return self._receive\n\n    async def stream(self) -> typing.AsyncGenerator[bytes, None]:\n        if hasattr(self, \"_body\"):\n            yield self._body\n            yield b\"\"\n            return\n        if self._stream_consumed:\n            raise RuntimeError(\"Stream consumed\")\n        self._stream_consumed = True\n        while True:\n            message = await self._receive()\n            if message[\"type\"] == \"http.request\":\n                body = message.get(\"body\", b\"\")\n                if body:\n                    yield body\n                if not message.get(\"more_body\", False):\n                    break\n            elif message[\"type\"] == \"http.disconnect\":\n                self._is_disconnected = True\n                raise ClientDisconnect()\n        yield b\"\"\n\n    async def body(self) -> bytes:\n        if not hasattr(self, \"_body\"):\n            chunks: \"typing.List[bytes]\" = []\n            async for chunk in self.stream():\n                chunks.append(chunk)\n            self._body = b\"\".join(chunks)\n        return self._body\n\n    async def json(self) -> typing.Any:\n        if not hasattr(self, \"_json\"):\n            body = await self.body()\n            self._json = json.loads(body)\n        return self._json\n\n    async def _get_form(self) -> FormData:\n        if self._form is None:\n            assert (\n                parse_options_header is not None\n            ), \"The `python-multipart` library must be installed to use form parsing.\"\n            content_type_header = self.headers.get(\"Content-Type\")\n            content_type: bytes\n            content_type, _ = parse_options_header(content_type_header)\n            if content_type == b\"multipart/form-data\":\n                try:\n                    multipart_parser = MultiPartParser(self.headers, self.stream())\n                    self._form = await multipart_parser.parse()\n                except MultiPartException as exc:\n                    if \"app\" in self.scope:\n                        raise HTTPException(status_code=400, detail=exc.message)\n                    raise exc\n            elif content_type == b\"application/x-www-form-urlencoded\":\n                form_parser = FormParser(self.headers, self.stream())\n                self._form = await form_parser.parse()\n            else:\n                self._form = FormData()\n        return self._form\n\n    def form(self) -> AwaitableOrContextManager[FormData]:\n        return AwaitableOrContextManagerWrapper(self._get_form())\n\n    async def close(self) -> None:\n        if self._form is not None:\n            await self._form.close()\n\n    async def is_disconnected(self) -> bool:\n        if not self._is_disconnected:\n            message: Message = {}\n\n            # If message isn't immediately available, move on\n            with anyio.CancelScope() as cs:\n                cs.cancel()\n                message = await self._receive()\n\n            if message.get(\"type\") == \"http.disconnect\":\n                self._is_disconnected = True\n\n        return self._is_disconnected\n\n    async def send_push_promise(self, path: str) -> None:\n        if \"http.response.push\" in self.scope.get(\"extensions\", {}):\n            raw_headers: \"typing.List[typing.Tuple[bytes, bytes]]\" = []\n            for name in SERVER_PUSH_HEADERS_TO_COPY:\n                for value in self.headers.getlist(name):\n                    raw_headers.append(\n                        (name.encode(\"latin-1\"), value.encode(\"latin-1\"))\n                    )\n            await self._send(\n                {\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers}\n            )\n", "import os\nimport typing\nfrom contextlib import nullcontext as does_not_raise\n\nimport pytest\n\nfrom starlette.applications import Starlette\nfrom starlette.formparsers import MultiPartException, UploadFile, _user_safe_decode\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Mount\n\n\nclass ForceMultipartDict(dict):\n    def __bool__(self):\n        return True\n\n\n# FORCE_MULTIPART is an empty dict that boolean-evaluates as `True`.\nFORCE_MULTIPART = ForceMultipartDict()\n\n\nasync def app(scope, receive, send):\n    request = Request(scope, receive)\n    data = await request.form()\n    output: typing.Dict[str, typing.Any] = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"size\": value.size,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n            }\n        else:\n            output[key] = value\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\nasync def multi_items_app(scope, receive, send):\n    request = Request(scope, receive)\n    data = await request.form()\n    output: typing.Dict[str, list] = {}\n    for key, value in data.multi_items():\n        if key not in output:\n            output[key] = []\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key].append(\n                {\n                    \"filename\": value.filename,\n                    \"size\": value.size,\n                    \"content\": content.decode(),\n                    \"content_type\": value.content_type,\n                }\n            )\n        else:\n            output[key].append(value)\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\nasync def app_with_headers(scope, receive, send):\n    request = Request(scope, receive)\n    data = await request.form()\n    output: typing.Dict[str, typing.Any] = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"size\": value.size,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n                \"headers\": list(value.headers.items()),\n            }\n        else:\n            output[key] = value\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\nasync def app_read_body(scope, receive, send):\n    request = Request(scope, receive)\n    # Read bytes, to force request.stream() to return the already parsed body\n    await request.body()\n    data = await request.form()\n    output = {}\n    for key, value in data.items():\n        output[key] = value\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\ndef test_multipart_request_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"data\"}, files=FORCE_MULTIPART)\n    assert response.json() == {\"some\": \"data\"}\n\n\ndef test_multipart_request_files(tmpdir, test_client_factory):\n    path = os.path.join(tmpdir, \"test.txt\")\n    with open(path, \"wb\") as file:\n        file.write(b\"<file content>\")\n\n    client = test_client_factory(app)\n    with open(path, \"rb\") as f:\n        response = client.post(\"/\", files={\"test\": f})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"size\": 14,\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_files_with_content_type(tmpdir, test_client_factory):\n    path = os.path.join(tmpdir, \"test.txt\")\n    with open(path, \"wb\") as file:\n        file.write(b\"<file content>\")\n\n    client = test_client_factory(app)\n    with open(path, \"rb\") as f:\n        response = client.post(\"/\", files={\"test\": (\"test.txt\", f, \"text/plain\")})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"size\": 14,\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_multiple_files(tmpdir, test_client_factory):\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(app)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\", files={\"test1\": f1, \"test2\": (\"test2.txt\", f2, \"text/plain\")}\n        )\n        assert response.json() == {\n            \"test1\": {\n                \"filename\": \"test1.txt\",\n                \"size\": 15,\n                \"content\": \"<file1 content>\",\n                \"content_type\": \"text/plain\",\n            },\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"size\": 15,\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n            },\n        }\n\n\ndef test_multipart_request_multiple_files_with_headers(tmpdir, test_client_factory):\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(app_with_headers)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\",\n            files=[\n                (\"test1\", (None, f1)),\n                (\"test2\", (\"test2.txt\", f2, \"text/plain\", {\"x-custom\": \"f2\"})),\n            ],\n        )\n        assert response.json() == {\n            \"test1\": \"<file1 content>\",\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"size\": 15,\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n                \"headers\": [\n                    [\n                        \"content-disposition\",\n                        'form-data; name=\"test2\"; filename=\"test2.txt\"',\n                    ],\n                    [\"x-custom\", \"f2\"],\n                    [\"content-type\", \"text/plain\"],\n                ],\n            },\n        }\n\n\ndef test_multi_items(tmpdir, test_client_factory):\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(multi_items_app)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\",\n            data={\"test1\": \"abc\"},\n            files=[(\"test1\", f1), (\"test1\", (\"test2.txt\", f2, \"text/plain\"))],\n        )\n        assert response.json() == {\n            \"test1\": [\n                \"abc\",\n                {\n                    \"filename\": \"test1.txt\",\n                    \"size\": 15,\n                    \"content\": \"<file1 content>\",\n                    \"content_type\": \"text/plain\",\n                },\n                {\n                    \"filename\": \"test2.txt\",\n                    \"size\": 15,\n                    \"content\": \"<file2 content>\",\n                    \"content_type\": \"text/plain\",\n                },\n            ]\n        }\n\n\ndef test_multipart_request_mixed_files_and_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # data\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"field0\"\\r\\n\\r\\n'\n            b\"value0\\r\\n\"\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"file.txt\"\\r\\n'\n            b\"Content-Type: text/plain\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            # data\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"field1\"\\r\\n\\r\\n'\n            b\"value1\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n            )\n        },\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"file.txt\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"text/plain\",\n        },\n        \"field0\": \"value0\",\n        \"field1\": \"value1\",\n    }\n\n\ndef test_multipart_request_with_charset_for_filename(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'  # noqa: E501\n            b\"Content-Type: text/plain\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; charset=utf-8; \"\n                \"boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n            )\n        },\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"\u6587\u66f8.txt\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"text/plain\",\n        }\n    }\n\n\ndef test_multipart_request_without_charset_for_filename(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe7\\x94\\xbb\\xe5\\x83\\x8f.jpg\"\\r\\n'  # noqa: E501\n            b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n            )\n        },\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"\u753b\u50cf.jpg\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"image/jpeg\",\n        }\n    }\n\n\ndef test_multipart_request_with_encoded_value(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            b\"--20b303e711c4ab8c443184ac833ab00f\\r\\n\"\n            b\"Content-Disposition: form-data; \"\n            b'name=\"value\"\\r\\n\\r\\n'\n            b\"Transf\\xc3\\xa9rer\\r\\n\"\n            b\"--20b303e711c4ab8c443184ac833ab00f--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; charset=utf-8; \"\n                \"boundary=20b303e711c4ab8c443184ac833ab00f\"\n            )\n        },\n    )\n    assert response.json() == {\"value\": \"Transf\u00e9rer\"}\n\n\ndef test_urlencoded_request_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"data\"})\n    assert response.json() == {\"some\": \"data\"}\n\n\ndef test_no_request_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\")\n    assert response.json() == {}\n\n\ndef test_urlencoded_percent_encoding(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"da ta\"})\n    assert response.json() == {\"some\": \"da ta\"}\n\n\ndef test_urlencoded_percent_encoding_keys(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"so me\": \"data\"})\n    assert response.json() == {\"so me\": \"data\"}\n\n\ndef test_urlencoded_multi_field_app_reads_body(tmpdir, test_client_factory):\n    client = test_client_factory(app_read_body)\n    response = client.post(\"/\", data={\"some\": \"data\", \"second\": \"key pair\"})\n    assert response.json() == {\"some\": \"data\", \"second\": \"key pair\"}\n\n\ndef test_multipart_multi_field_app_reads_body(tmpdir, test_client_factory):\n    client = test_client_factory(app_read_body)\n    response = client.post(\n        \"/\", data={\"some\": \"data\", \"second\": \"key pair\"}, files=FORCE_MULTIPART\n    )\n    assert response.json() == {\"some\": \"data\", \"second\": \"key pair\"}\n\n\ndef test_user_safe_decode_helper():\n    result = _user_safe_decode(b\"\\xc4\\x99\\xc5\\xbc\\xc4\\x87\", \"utf-8\")\n    assert result == \"\u0119\u017c\u0107\"\n\n\ndef test_user_safe_decode_ignores_wrong_charset():\n    result = _user_safe_decode(b\"abc\", \"latin-8\")\n    assert result == \"abc\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_missing_boundary_parameter(app, expectation, test_client_factory) -> None:\n    client = test_client_factory(app)\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=(\n                # file\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'  # noqa: E501\n                b\"Content-Type: text/plain\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; charset=utf-8\"},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Missing boundary in multipart.\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_missing_name_parameter_on_content_disposition(\n    app, expectation, test_client_factory\n):\n    client = test_client_factory(app)\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=(\n                # data\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; =\"field0\"\\r\\n\\r\\n'\n                b\"value0\\r\\n\"\n            ),\n            headers={\n                \"Content-Type\": (\n                    \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n                )\n            },\n        )\n        assert res.status_code == 400\n        assert (\n            res.text == 'The Content-Disposition header field \"name\" must be provided.'\n        )\n"], "fixing_code": ["\nStarlette includes a `Request` class that gives you a nicer interface onto\nthe incoming request, rather than accessing the ASGI scope and receive channel directly.\n\n### Request\n\nSignature: `Request(scope, receive=None)`\n\n```python\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    content = '%s %s' % (request.method, request.url.path)\n    response = Response(content, media_type='text/plain')\n    await response(scope, receive, send)\n```\n\nRequests present a mapping interface, so you can use them in the same\nway as a `scope`.\n\nFor instance: `request['path']` will return the ASGI path.\n\nIf you don't need to access the request body you can instantiate a request\nwithout providing an argument to `receive`.\n\n#### Method\n\nThe request method is accessed as `request.method`.\n\n#### URL\n\nThe request URL is accessed as `request.url`.\n\nThe property is a string-like object that exposes all the\ncomponents that can be parsed out of the URL.\n\nFor example: `request.url.path`, `request.url.port`, `request.url.scheme`.\n\n#### Headers\n\nHeaders are exposed as an immutable, case-insensitive, multi-dict.\n\nFor example: `request.headers['content-type']`\n\n#### Query Parameters\n\nQuery parameters are exposed as an immutable multi-dict.\n\nFor example: `request.query_params['search']`\n\n#### Path Parameters\n\nRouter path parameters are exposed as a dictionary interface.\n\nFor example: `request.path_params['username']`\n\n#### Client Address\n\nThe client's remote address is exposed as a named two-tuple `request.client`.\nEither item in the tuple may be `None`.\n\nThe hostname or IP address: `request.client.host`\n\nThe port number from which the client is connecting: `request.client.port`\n\n#### Cookies\n\nCookies are exposed as a regular dictionary interface.\n\nFor example: `request.cookies.get('mycookie')`\n\nCookies are ignored in case of an invalid cookie. (RFC2109)\n\n#### Body\n\nThere are a few different interfaces for returning the body of the request:\n\nThe request body as bytes: `await request.body()`\n\nThe request body, parsed as form data or multipart: `async with request.form() as form:`\n\nThe request body, parsed as JSON: `await request.json()`\n\nYou can also access the request body as a stream, using the `async for` syntax:\n\n```python\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\n    \nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    body = b''\n    async for chunk in request.stream():\n        body += chunk\n    response = Response(body, media_type='text/plain')\n    await response(scope, receive, send)\n```\n\nIf you access `.stream()` then the byte chunks are provided without storing\nthe entire body to memory. Any subsequent calls to `.body()`, `.form()`, or `.json()`\nwill raise an error.\n\nIn some cases such as long-polling, or streaming responses you might need to\ndetermine if the client has dropped the connection. You can determine this\nstate with `disconnected = await request.is_disconnected()`.\n\n#### Request Files\n\nRequest files are normally sent as multipart form data (`multipart/form-data`).\n\nSignature: `request.form(max_files=1000, max_fields=1000)`\n\nYou can configure the number of maximum fields or files with the parameters `max_files` and `max_fields`:\n\n```python\nasync with request.form(max_files=1000, max_fields=1000):\n    ...\n```\n\n!!! info\n    These limits are for security reasons, allowing an unlimited number of fields or files could lead to a denial of service attack by consuming a lot of CPU and memory parsing too many empty fields.\n\nWhen you call `async with request.form() as form` you receive a `starlette.datastructures.FormData` which is an immutable\nmultidict, containing both file uploads and text input. File upload items are represented as instances of `starlette.datastructures.UploadFile`.\n\n`UploadFile` has the following attributes:\n\n* `filename`: An `str` with the original file name that was uploaded or `None` if its not available (e.g. `myimage.jpg`).\n* `content_type`: An `str` with the content type (MIME type / media type) or `None` if it's not available (e.g. `image/jpeg`).\n* `file`: A <a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" target=\"_blank\">`SpooledTemporaryFile`</a> (a <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" target=\"_blank\">file-like</a> object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object.\n* `headers`: A `Headers` object. Often this will only be the `Content-Type` header, but if additional headers were included in the multipart field they will be included here. Note that these headers have no relationship with the headers in `Request.headers`.\n* `size`: An `int` with uploaded file's size in bytes. This value is calculated from request's contents, making it better choice to find uploaded file's size than `Content-Length` header. `None` if not set.\n\n`UploadFile` has the following `async` methods. They all call the corresponding file methods underneath (using the internal `SpooledTemporaryFile`).\n\n* `async write(data)`: Writes `data` (`bytes`) to the file.\n* `async read(size)`: Reads `size` (`int`) bytes of the file.\n* `async seek(offset)`: Goes to the byte position `offset` (`int`) in the file.\n    * E.g., `await myfile.seek(0)` would go to the start of the file.\n* `async close()`: Closes the file.\n\nAs all these methods are `async` methods, you need to \"await\" them.\n\nFor example, you can get the file name and the contents with:\n\n```python\nasync with request.form() as form:\n    filename = form[\"upload_file\"].filename\n    contents = await form[\"upload_file\"].read()\n```\n\n!!! info\n    As settled in [RFC-7578: 4.2](https://www.ietf.org/rfc/rfc7578.txt), form-data content part that contains file \n    assumed to have `name` and `filename` fields in `Content-Disposition` header: `Content-Disposition: form-data;\n    name=\"user\"; filename=\"somefile\"`. Though `filename` field is optional according to RFC-7578, it helps \n    Starlette to differentiate which data should be treated as file. If `filename` field was supplied, `UploadFile` \n    object will be created to access underlying file, otherwise form-data part will be parsed and available as a raw \n    string.\n\n#### Application\n\nThe originating Starlette application can be accessed via `request.app`.\n\n#### Other state\n\nIf you want to store additional information on the request you can do so\nusing `request.state`.\n\nFor example:\n\n`request.state.time_started = time.time()`\n", "import typing\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom tempfile import SpooledTemporaryFile\nfrom urllib.parse import unquote_plus\n\nfrom starlette.datastructures import FormData, Headers, UploadFile\n\ntry:\n    import multipart\n    from multipart.multipart import parse_options_header\nexcept ImportError:  # pragma: nocover\n    parse_options_header = None\n    multipart = None\n\n\nclass FormMessage(Enum):\n    FIELD_START = 1\n    FIELD_NAME = 2\n    FIELD_DATA = 3\n    FIELD_END = 4\n    END = 5\n\n\n@dataclass\nclass MultipartPart:\n    content_disposition: typing.Optional[bytes] = None\n    field_name: str = \"\"\n    data: bytes = b\"\"\n    file: typing.Optional[UploadFile] = None\n    item_headers: typing.List[typing.Tuple[bytes, bytes]] = field(default_factory=list)\n\n\ndef _user_safe_decode(src: bytes, codec: str) -> str:\n    try:\n        return src.decode(codec)\n    except (UnicodeDecodeError, LookupError):\n        return src.decode(\"latin-1\")\n\n\nclass MultiPartException(Exception):\n    def __init__(self, message: str) -> None:\n        self.message = message\n\n\nclass FormParser:\n    def __init__(\n        self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]\n    ) -> None:\n        assert (\n            multipart is not None\n        ), \"The `python-multipart` library must be installed to use form parsing.\"\n        self.headers = headers\n        self.stream = stream\n        self.messages: typing.List[typing.Tuple[FormMessage, bytes]] = []\n\n    def on_field_start(self) -> None:\n        message = (FormMessage.FIELD_START, b\"\")\n        self.messages.append(message)\n\n    def on_field_name(self, data: bytes, start: int, end: int) -> None:\n        message = (FormMessage.FIELD_NAME, data[start:end])\n        self.messages.append(message)\n\n    def on_field_data(self, data: bytes, start: int, end: int) -> None:\n        message = (FormMessage.FIELD_DATA, data[start:end])\n        self.messages.append(message)\n\n    def on_field_end(self) -> None:\n        message = (FormMessage.FIELD_END, b\"\")\n        self.messages.append(message)\n\n    def on_end(self) -> None:\n        message = (FormMessage.END, b\"\")\n        self.messages.append(message)\n\n    async def parse(self) -> FormData:\n        # Callbacks dictionary.\n        callbacks = {\n            \"on_field_start\": self.on_field_start,\n            \"on_field_name\": self.on_field_name,\n            \"on_field_data\": self.on_field_data,\n            \"on_field_end\": self.on_field_end,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.QuerystringParser(callbacks)\n        field_name = b\"\"\n        field_value = b\"\"\n\n        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []\n\n        # Feed the parser with data from the request.\n        async for chunk in self.stream:\n            if chunk:\n                parser.write(chunk)\n            else:\n                parser.finalize()\n            messages = list(self.messages)\n            self.messages.clear()\n            for message_type, message_bytes in messages:\n                if message_type == FormMessage.FIELD_START:\n                    field_name = b\"\"\n                    field_value = b\"\"\n                elif message_type == FormMessage.FIELD_NAME:\n                    field_name += message_bytes\n                elif message_type == FormMessage.FIELD_DATA:\n                    field_value += message_bytes\n                elif message_type == FormMessage.FIELD_END:\n                    name = unquote_plus(field_name.decode(\"latin-1\"))\n                    value = unquote_plus(field_value.decode(\"latin-1\"))\n                    items.append((name, value))\n\n        return FormData(items)\n\n\nclass MultiPartParser:\n    max_file_size = 1024 * 1024\n\n    def __init__(\n        self,\n        headers: Headers,\n        stream: typing.AsyncGenerator[bytes, None],\n        *,\n        max_files: typing.Union[int, float] = 1000,\n        max_fields: typing.Union[int, float] = 1000,\n    ) -> None:\n        assert (\n            multipart is not None\n        ), \"The `python-multipart` library must be installed to use form parsing.\"\n        self.headers = headers\n        self.stream = stream\n        self.max_files = max_files\n        self.max_fields = max_fields\n        self.items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []\n        self._current_files = 0\n        self._current_fields = 0\n        self._current_partial_header_name: bytes = b\"\"\n        self._current_partial_header_value: bytes = b\"\"\n        self._current_part = MultipartPart()\n        self._charset = \"\"\n        self._file_parts_to_write: typing.List[typing.Tuple[MultipartPart, bytes]] = []\n        self._file_parts_to_finish: typing.List[MultipartPart] = []\n\n    def on_part_begin(self) -> None:\n        self._current_part = MultipartPart()\n\n    def on_part_data(self, data: bytes, start: int, end: int) -> None:\n        message_bytes = data[start:end]\n        if self._current_part.file is None:\n            self._current_part.data += message_bytes\n        else:\n            self._file_parts_to_write.append((self._current_part, message_bytes))\n\n    def on_part_end(self) -> None:\n        if self._current_part.file is None:\n            self.items.append(\n                (\n                    self._current_part.field_name,\n                    _user_safe_decode(self._current_part.data, self._charset),\n                )\n            )\n        else:\n            self._file_parts_to_finish.append(self._current_part)\n            # The file can be added to the items right now even though it's not\n            # finished yet, because it will be finished in the `parse()` method, before\n            # self.items is used in the return value.\n            self.items.append((self._current_part.field_name, self._current_part.file))\n\n    def on_header_field(self, data: bytes, start: int, end: int) -> None:\n        self._current_partial_header_name += data[start:end]\n\n    def on_header_value(self, data: bytes, start: int, end: int) -> None:\n        self._current_partial_header_value += data[start:end]\n\n    def on_header_end(self) -> None:\n        field = self._current_partial_header_name.lower()\n        if field == b\"content-disposition\":\n            self._current_part.content_disposition = self._current_partial_header_value\n        self._current_part.item_headers.append(\n            (field, self._current_partial_header_value)\n        )\n        self._current_partial_header_name = b\"\"\n        self._current_partial_header_value = b\"\"\n\n    def on_headers_finished(self) -> None:\n        disposition, options = parse_options_header(\n            self._current_part.content_disposition\n        )\n        try:\n            self._current_part.field_name = _user_safe_decode(\n                options[b\"name\"], self._charset\n            )\n        except KeyError:\n            raise MultiPartException(\n                'The Content-Disposition header field \"name\" must be ' \"provided.\"\n            )\n        if b\"filename\" in options:\n            self._current_files += 1\n            if self._current_files > self.max_files:\n                raise MultiPartException(\n                    f\"Too many files. Maximum number of files is {self.max_files}.\"\n                )\n            filename = _user_safe_decode(options[b\"filename\"], self._charset)\n            tempfile = SpooledTemporaryFile(max_size=self.max_file_size)\n            self._current_part.file = UploadFile(\n                file=tempfile,  # type: ignore[arg-type]\n                size=0,\n                filename=filename,\n                headers=Headers(raw=self._current_part.item_headers),\n            )\n        else:\n            self._current_fields += 1\n            if self._current_fields > self.max_fields:\n                raise MultiPartException(\n                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"\n                )\n            self._current_part.file = None\n\n    def on_end(self) -> None:\n        pass\n\n    async def parse(self) -> FormData:\n        # Parse the Content-Type header to get the multipart boundary.\n        _, params = parse_options_header(self.headers[\"Content-Type\"])\n        charset = params.get(b\"charset\", \"utf-8\")\n        if type(charset) == bytes:\n            charset = charset.decode(\"latin-1\")\n        self._charset = charset\n        try:\n            boundary = params[b\"boundary\"]\n        except KeyError:\n            raise MultiPartException(\"Missing boundary in multipart.\")\n\n        # Callbacks dictionary.\n        callbacks = {\n            \"on_part_begin\": self.on_part_begin,\n            \"on_part_data\": self.on_part_data,\n            \"on_part_end\": self.on_part_end,\n            \"on_header_field\": self.on_header_field,\n            \"on_header_value\": self.on_header_value,\n            \"on_header_end\": self.on_header_end,\n            \"on_headers_finished\": self.on_headers_finished,\n            \"on_end\": self.on_end,\n        }\n\n        # Create the parser.\n        parser = multipart.MultipartParser(boundary, callbacks)\n        # Feed the parser with data from the request.\n        async for chunk in self.stream:\n            parser.write(chunk)\n            # Write file data, it needs to use await with the UploadFile methods that\n            # call the corresponding file methods *in a threadpool*, otherwise, if\n            # they were called directly in the callback methods above (regular,\n            # non-async functions), that would block the event loop in the main thread.\n            for part, data in self._file_parts_to_write:\n                assert part.file  # for type checkers\n                await part.file.write(data)\n            for part in self._file_parts_to_finish:\n                assert part.file  # for type checkers\n                await part.file.seek(0)\n            self._file_parts_to_write.clear()\n            self._file_parts_to_finish.clear()\n\n        parser.finalize()\n        return FormData(self.items)\n", "import json\nimport typing\nfrom http import cookies as http_cookies\n\nimport anyio\n\nfrom starlette._utils import AwaitableOrContextManager, AwaitableOrContextManagerWrapper\nfrom starlette.datastructures import URL, Address, FormData, Headers, QueryParams, State\nfrom starlette.exceptions import HTTPException\nfrom starlette.formparsers import FormParser, MultiPartException, MultiPartParser\nfrom starlette.types import Message, Receive, Scope, Send\n\ntry:\n    from multipart.multipart import parse_options_header\nexcept ImportError:  # pragma: nocover\n    parse_options_header = None\n\n\nif typing.TYPE_CHECKING:\n    from starlette.routing import Router\n\n\nSERVER_PUSH_HEADERS_TO_COPY = {\n    \"accept\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"cache-control\",\n    \"user-agent\",\n}\n\n\ndef cookie_parser(cookie_string: str) -> typing.Dict[str, str]:\n    \"\"\"\n    This function parses a ``Cookie`` HTTP header into a dict of key/value pairs.\n\n    It attempts to mimic browser cookie parsing behavior: browsers and web servers\n    frequently disregard the spec (RFC 6265) when setting and reading cookies,\n    so we attempt to suit the common scenarios here.\n\n    This function has been adapted from Django 3.1.0.\n    Note: we are explicitly _NOT_ using `SimpleCookie.load` because it is based\n    on an outdated spec and will fail on lots of input we want to support\n    \"\"\"\n    cookie_dict: typing.Dict[str, str] = {}\n    for chunk in cookie_string.split(\";\"):\n        if \"=\" in chunk:\n            key, val = chunk.split(\"=\", 1)\n        else:\n            # Assume an empty name per\n            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091\n            key, val = \"\", chunk\n        key, val = key.strip(), val.strip()\n        if key or val:\n            # unquote using Python's algorithm.\n            cookie_dict[key] = http_cookies._unquote(val)\n    return cookie_dict\n\n\nclass ClientDisconnect(Exception):\n    pass\n\n\nclass HTTPConnection(typing.Mapping[str, typing.Any]):\n    \"\"\"\n    A base class for incoming HTTP connections, that is used to provide\n    any functionality that is common to both `Request` and `WebSocket`.\n    \"\"\"\n\n    def __init__(self, scope: Scope, receive: typing.Optional[Receive] = None) -> None:\n        assert scope[\"type\"] in (\"http\", \"websocket\")\n        self.scope = scope\n\n    def __getitem__(self, key: str) -> typing.Any:\n        return self.scope[key]\n\n    def __iter__(self) -> typing.Iterator[str]:\n        return iter(self.scope)\n\n    def __len__(self) -> int:\n        return len(self.scope)\n\n    # Don't use the `abc.Mapping.__eq__` implementation.\n    # Connection instances should never be considered equal\n    # unless `self is other`.\n    __eq__ = object.__eq__\n    __hash__ = object.__hash__\n\n    @property\n    def app(self) -> typing.Any:\n        return self.scope[\"app\"]\n\n    @property\n    def url(self) -> URL:\n        if not hasattr(self, \"_url\"):\n            self._url = URL(scope=self.scope)\n        return self._url\n\n    @property\n    def base_url(self) -> URL:\n        if not hasattr(self, \"_base_url\"):\n            base_url_scope = dict(self.scope)\n            base_url_scope[\"path\"] = \"/\"\n            base_url_scope[\"query_string\"] = b\"\"\n            base_url_scope[\"root_path\"] = base_url_scope.get(\n                \"app_root_path\", base_url_scope.get(\"root_path\", \"\")\n            )\n            self._base_url = URL(scope=base_url_scope)\n        return self._base_url\n\n    @property\n    def headers(self) -> Headers:\n        if not hasattr(self, \"_headers\"):\n            self._headers = Headers(scope=self.scope)\n        return self._headers\n\n    @property\n    def query_params(self) -> QueryParams:\n        if not hasattr(self, \"_query_params\"):\n            self._query_params = QueryParams(self.scope[\"query_string\"])\n        return self._query_params\n\n    @property\n    def path_params(self) -> typing.Dict[str, typing.Any]:\n        return self.scope.get(\"path_params\", {})\n\n    @property\n    def cookies(self) -> typing.Dict[str, str]:\n        if not hasattr(self, \"_cookies\"):\n            cookies: typing.Dict[str, str] = {}\n            cookie_header = self.headers.get(\"cookie\")\n\n            if cookie_header:\n                cookies = cookie_parser(cookie_header)\n            self._cookies = cookies\n        return self._cookies\n\n    @property\n    def client(self) -> typing.Optional[Address]:\n        # client is a 2 item tuple of (host, port), None or missing\n        host_port = self.scope.get(\"client\")\n        if host_port is not None:\n            return Address(*host_port)\n        return None\n\n    @property\n    def session(self) -> typing.Dict[str, typing.Any]:\n        assert (\n            \"session\" in self.scope\n        ), \"SessionMiddleware must be installed to access request.session\"\n        return self.scope[\"session\"]\n\n    @property\n    def auth(self) -> typing.Any:\n        assert (\n            \"auth\" in self.scope\n        ), \"AuthenticationMiddleware must be installed to access request.auth\"\n        return self.scope[\"auth\"]\n\n    @property\n    def user(self) -> typing.Any:\n        assert (\n            \"user\" in self.scope\n        ), \"AuthenticationMiddleware must be installed to access request.user\"\n        return self.scope[\"user\"]\n\n    @property\n    def state(self) -> State:\n        if not hasattr(self, \"_state\"):\n            # Ensure 'state' has an empty dict if it's not already populated.\n            self.scope.setdefault(\"state\", {})\n            # Create a state instance with a reference to the dict in which it should\n            # store info\n            self._state = State(self.scope[\"state\"])\n        return self._state\n\n    def url_for(self, name: str, **path_params: typing.Any) -> str:\n        router: Router = self.scope[\"router\"]\n        url_path = router.url_path_for(name, **path_params)\n        return url_path.make_absolute_url(base_url=self.base_url)\n\n\nasync def empty_receive() -> typing.NoReturn:\n    raise RuntimeError(\"Receive channel has not been made available\")\n\n\nasync def empty_send(message: Message) -> typing.NoReturn:\n    raise RuntimeError(\"Send channel has not been made available\")\n\n\nclass Request(HTTPConnection):\n    _form: typing.Optional[FormData]\n\n    def __init__(\n        self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send\n    ):\n        super().__init__(scope)\n        assert scope[\"type\"] == \"http\"\n        self._receive = receive\n        self._send = send\n        self._stream_consumed = False\n        self._is_disconnected = False\n        self._form = None\n\n    @property\n    def method(self) -> str:\n        return self.scope[\"method\"]\n\n    @property\n    def receive(self) -> Receive:\n        return self._receive\n\n    async def stream(self) -> typing.AsyncGenerator[bytes, None]:\n        if hasattr(self, \"_body\"):\n            yield self._body\n            yield b\"\"\n            return\n        if self._stream_consumed:\n            raise RuntimeError(\"Stream consumed\")\n        self._stream_consumed = True\n        while True:\n            message = await self._receive()\n            if message[\"type\"] == \"http.request\":\n                body = message.get(\"body\", b\"\")\n                if body:\n                    yield body\n                if not message.get(\"more_body\", False):\n                    break\n            elif message[\"type\"] == \"http.disconnect\":\n                self._is_disconnected = True\n                raise ClientDisconnect()\n        yield b\"\"\n\n    async def body(self) -> bytes:\n        if not hasattr(self, \"_body\"):\n            chunks: \"typing.List[bytes]\" = []\n            async for chunk in self.stream():\n                chunks.append(chunk)\n            self._body = b\"\".join(chunks)\n        return self._body\n\n    async def json(self) -> typing.Any:\n        if not hasattr(self, \"_json\"):\n            body = await self.body()\n            self._json = json.loads(body)\n        return self._json\n\n    async def _get_form(\n        self,\n        *,\n        max_files: typing.Union[int, float] = 1000,\n        max_fields: typing.Union[int, float] = 1000,\n    ) -> FormData:\n        if self._form is None:\n            assert (\n                parse_options_header is not None\n            ), \"The `python-multipart` library must be installed to use form parsing.\"\n            content_type_header = self.headers.get(\"Content-Type\")\n            content_type: bytes\n            content_type, _ = parse_options_header(content_type_header)\n            if content_type == b\"multipart/form-data\":\n                try:\n                    multipart_parser = MultiPartParser(\n                        self.headers,\n                        self.stream(),\n                        max_files=max_files,\n                        max_fields=max_fields,\n                    )\n                    self._form = await multipart_parser.parse()\n                except MultiPartException as exc:\n                    if \"app\" in self.scope:\n                        raise HTTPException(status_code=400, detail=exc.message)\n                    raise exc\n            elif content_type == b\"application/x-www-form-urlencoded\":\n                form_parser = FormParser(self.headers, self.stream())\n                self._form = await form_parser.parse()\n            else:\n                self._form = FormData()\n        return self._form\n\n    def form(\n        self,\n        *,\n        max_files: typing.Union[int, float] = 1000,\n        max_fields: typing.Union[int, float] = 1000,\n    ) -> AwaitableOrContextManager[FormData]:\n        return AwaitableOrContextManagerWrapper(\n            self._get_form(max_files=max_files, max_fields=max_fields)\n        )\n\n    async def close(self) -> None:\n        if self._form is not None:\n            await self._form.close()\n\n    async def is_disconnected(self) -> bool:\n        if not self._is_disconnected:\n            message: Message = {}\n\n            # If message isn't immediately available, move on\n            with anyio.CancelScope() as cs:\n                cs.cancel()\n                message = await self._receive()\n\n            if message.get(\"type\") == \"http.disconnect\":\n                self._is_disconnected = True\n\n        return self._is_disconnected\n\n    async def send_push_promise(self, path: str) -> None:\n        if \"http.response.push\" in self.scope.get(\"extensions\", {}):\n            raw_headers: \"typing.List[typing.Tuple[bytes, bytes]]\" = []\n            for name in SERVER_PUSH_HEADERS_TO_COPY:\n                for value in self.headers.getlist(name):\n                    raw_headers.append(\n                        (name.encode(\"latin-1\"), value.encode(\"latin-1\"))\n                    )\n            await self._send(\n                {\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers}\n            )\n", "import os\nimport typing\nfrom contextlib import nullcontext as does_not_raise\n\nimport pytest\n\nfrom starlette.applications import Starlette\nfrom starlette.formparsers import MultiPartException, UploadFile, _user_safe_decode\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Mount\n\n\nclass ForceMultipartDict(dict):\n    def __bool__(self):\n        return True\n\n\n# FORCE_MULTIPART is an empty dict that boolean-evaluates as `True`.\nFORCE_MULTIPART = ForceMultipartDict()\n\n\nasync def app(scope, receive, send):\n    request = Request(scope, receive)\n    data = await request.form()\n    output: typing.Dict[str, typing.Any] = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"size\": value.size,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n            }\n        else:\n            output[key] = value\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\nasync def multi_items_app(scope, receive, send):\n    request = Request(scope, receive)\n    data = await request.form()\n    output: typing.Dict[str, list] = {}\n    for key, value in data.multi_items():\n        if key not in output:\n            output[key] = []\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key].append(\n                {\n                    \"filename\": value.filename,\n                    \"size\": value.size,\n                    \"content\": content.decode(),\n                    \"content_type\": value.content_type,\n                }\n            )\n        else:\n            output[key].append(value)\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\nasync def app_with_headers(scope, receive, send):\n    request = Request(scope, receive)\n    data = await request.form()\n    output: typing.Dict[str, typing.Any] = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"size\": value.size,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n                \"headers\": list(value.headers.items()),\n            }\n        else:\n            output[key] = value\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\nasync def app_read_body(scope, receive, send):\n    request = Request(scope, receive)\n    # Read bytes, to force request.stream() to return the already parsed body\n    await request.body()\n    data = await request.form()\n    output = {}\n    for key, value in data.items():\n        output[key] = value\n    await request.close()\n    response = JSONResponse(output)\n    await response(scope, receive, send)\n\n\ndef make_app_max_parts(max_files: int = 1000, max_fields: int = 1000):\n    async def app(scope, receive, send):\n        request = Request(scope, receive)\n        data = await request.form(max_files=max_files, max_fields=max_fields)\n        output: typing.Dict[str, typing.Any] = {}\n        for key, value in data.items():\n            if isinstance(value, UploadFile):\n                content = await value.read()\n                output[key] = {\n                    \"filename\": value.filename,\n                    \"size\": value.size,\n                    \"content\": content.decode(),\n                    \"content_type\": value.content_type,\n                }\n            else:\n                output[key] = value\n        await request.close()\n        response = JSONResponse(output)\n        await response(scope, receive, send)\n\n    return app\n\n\ndef test_multipart_request_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"data\"}, files=FORCE_MULTIPART)\n    assert response.json() == {\"some\": \"data\"}\n\n\ndef test_multipart_request_files(tmpdir, test_client_factory):\n    path = os.path.join(tmpdir, \"test.txt\")\n    with open(path, \"wb\") as file:\n        file.write(b\"<file content>\")\n\n    client = test_client_factory(app)\n    with open(path, \"rb\") as f:\n        response = client.post(\"/\", files={\"test\": f})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"size\": 14,\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_files_with_content_type(tmpdir, test_client_factory):\n    path = os.path.join(tmpdir, \"test.txt\")\n    with open(path, \"wb\") as file:\n        file.write(b\"<file content>\")\n\n    client = test_client_factory(app)\n    with open(path, \"rb\") as f:\n        response = client.post(\"/\", files={\"test\": (\"test.txt\", f, \"text/plain\")})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"size\": 14,\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_multiple_files(tmpdir, test_client_factory):\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(app)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\", files={\"test1\": f1, \"test2\": (\"test2.txt\", f2, \"text/plain\")}\n        )\n        assert response.json() == {\n            \"test1\": {\n                \"filename\": \"test1.txt\",\n                \"size\": 15,\n                \"content\": \"<file1 content>\",\n                \"content_type\": \"text/plain\",\n            },\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"size\": 15,\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n            },\n        }\n\n\ndef test_multipart_request_multiple_files_with_headers(tmpdir, test_client_factory):\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(app_with_headers)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\",\n            files=[\n                (\"test1\", (None, f1)),\n                (\"test2\", (\"test2.txt\", f2, \"text/plain\", {\"x-custom\": \"f2\"})),\n            ],\n        )\n        assert response.json() == {\n            \"test1\": \"<file1 content>\",\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"size\": 15,\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n                \"headers\": [\n                    [\n                        \"content-disposition\",\n                        'form-data; name=\"test2\"; filename=\"test2.txt\"',\n                    ],\n                    [\"x-custom\", \"f2\"],\n                    [\"content-type\", \"text/plain\"],\n                ],\n            },\n        }\n\n\ndef test_multi_items(tmpdir, test_client_factory):\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(multi_items_app)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\",\n            data={\"test1\": \"abc\"},\n            files=[(\"test1\", f1), (\"test1\", (\"test2.txt\", f2, \"text/plain\"))],\n        )\n        assert response.json() == {\n            \"test1\": [\n                \"abc\",\n                {\n                    \"filename\": \"test1.txt\",\n                    \"size\": 15,\n                    \"content\": \"<file1 content>\",\n                    \"content_type\": \"text/plain\",\n                },\n                {\n                    \"filename\": \"test2.txt\",\n                    \"size\": 15,\n                    \"content\": \"<file2 content>\",\n                    \"content_type\": \"text/plain\",\n                },\n            ]\n        }\n\n\ndef test_multipart_request_mixed_files_and_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # data\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"field0\"\\r\\n\\r\\n'\n            b\"value0\\r\\n\"\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"file.txt\"\\r\\n'\n            b\"Content-Type: text/plain\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            # data\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"field1\"\\r\\n\\r\\n'\n            b\"value1\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n            )\n        },\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"file.txt\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"text/plain\",\n        },\n        \"field0\": \"value0\",\n        \"field1\": \"value1\",\n    }\n\n\ndef test_multipart_request_with_charset_for_filename(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'  # noqa: E501\n            b\"Content-Type: text/plain\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; charset=utf-8; \"\n                \"boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n            )\n        },\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"\u6587\u66f8.txt\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"text/plain\",\n        }\n    }\n\n\ndef test_multipart_request_without_charset_for_filename(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe7\\x94\\xbb\\xe5\\x83\\x8f.jpg\"\\r\\n'  # noqa: E501\n            b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n            )\n        },\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"\u753b\u50cf.jpg\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"image/jpeg\",\n        }\n    }\n\n\ndef test_multipart_request_with_encoded_value(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            b\"--20b303e711c4ab8c443184ac833ab00f\\r\\n\"\n            b\"Content-Disposition: form-data; \"\n            b'name=\"value\"\\r\\n\\r\\n'\n            b\"Transf\\xc3\\xa9rer\\r\\n\"\n            b\"--20b303e711c4ab8c443184ac833ab00f--\\r\\n\"\n        ),\n        headers={\n            \"Content-Type\": (\n                \"multipart/form-data; charset=utf-8; \"\n                \"boundary=20b303e711c4ab8c443184ac833ab00f\"\n            )\n        },\n    )\n    assert response.json() == {\"value\": \"Transf\u00e9rer\"}\n\n\ndef test_urlencoded_request_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"data\"})\n    assert response.json() == {\"some\": \"data\"}\n\n\ndef test_no_request_data(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\")\n    assert response.json() == {}\n\n\ndef test_urlencoded_percent_encoding(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"da ta\"})\n    assert response.json() == {\"some\": \"da ta\"}\n\n\ndef test_urlencoded_percent_encoding_keys(tmpdir, test_client_factory):\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"so me\": \"data\"})\n    assert response.json() == {\"so me\": \"data\"}\n\n\ndef test_urlencoded_multi_field_app_reads_body(tmpdir, test_client_factory):\n    client = test_client_factory(app_read_body)\n    response = client.post(\"/\", data={\"some\": \"data\", \"second\": \"key pair\"})\n    assert response.json() == {\"some\": \"data\", \"second\": \"key pair\"}\n\n\ndef test_multipart_multi_field_app_reads_body(tmpdir, test_client_factory):\n    client = test_client_factory(app_read_body)\n    response = client.post(\n        \"/\", data={\"some\": \"data\", \"second\": \"key pair\"}, files=FORCE_MULTIPART\n    )\n    assert response.json() == {\"some\": \"data\", \"second\": \"key pair\"}\n\n\ndef test_user_safe_decode_helper():\n    result = _user_safe_decode(b\"\\xc4\\x99\\xc5\\xbc\\xc4\\x87\", \"utf-8\")\n    assert result == \"\u0119\u017c\u0107\"\n\n\ndef test_user_safe_decode_ignores_wrong_charset():\n    result = _user_safe_decode(b\"abc\", \"latin-8\")\n    assert result == \"abc\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_missing_boundary_parameter(app, expectation, test_client_factory) -> None:\n    client = test_client_factory(app)\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=(\n                # file\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'  # noqa: E501\n                b\"Content-Type: text/plain\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; charset=utf-8\"},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Missing boundary in multipart.\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_missing_name_parameter_on_content_disposition(\n    app, expectation, test_client_factory\n):\n    client = test_client_factory(app)\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=(\n                # data\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; =\"field0\"\\r\\n\\r\\n'\n                b\"value0\\r\\n\"\n            ),\n            headers={\n                \"Content-Type\": (\n                    \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"\n                )\n            },\n        )\n        assert res.status_code == 400\n        assert (\n            res.text == 'The Content-Disposition header field \"name\" must be provided.'\n        )\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_too_many_fields_raise(app, expectation, test_client_factory):\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        fields.append(\n            \"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\"\n        )\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many fields. Maximum number of fields is 1000.\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_too_many_files_raise(app, expectation, test_client_factory):\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        fields.append(\n            \"--B\\r\\n\"\n            f'Content-Disposition: form-data; name=\"N{i}\"; filename=\"F{i}\";\\r\\n\\r\\n'\n            \"\\r\\n\"\n        )\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1000.\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_too_many_files_single_field_raise(app, expectation, test_client_factory):\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        # This uses the same field name \"N\" for all files, equivalent to a\n        # multifile upload form field\n        fields.append(\n            \"--B\\r\\n\"\n            f'Content-Disposition: form-data; name=\"N\"; filename=\"F{i}\";\\r\\n\\r\\n'\n            \"\\r\\n\"\n        )\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1000.\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (app, pytest.raises(MultiPartException)),\n        (Starlette(routes=[Mount(\"/\", app=app)]), does_not_raise()),\n    ],\n)\ndef test_too_many_files_and_fields_raise(app, expectation, test_client_factory):\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        fields.append(\n            \"--B\\r\\n\"\n            f'Content-Disposition: form-data; name=\"F{i}\"; filename=\"F{i}\";\\r\\n\\r\\n'\n            \"\\r\\n\"\n        )\n        fields.append(\n            \"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\"\n        )\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1000.\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (make_app_max_parts(max_fields=1), pytest.raises(MultiPartException)),\n        (\n            Starlette(routes=[Mount(\"/\", app=make_app_max_parts(max_fields=1))]),\n            does_not_raise(),\n        ),\n    ],\n)\ndef test_max_fields_is_customizable_low_raises(app, expectation, test_client_factory):\n    client = test_client_factory(app)\n    fields = []\n    for i in range(2):\n        fields.append(\n            \"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\"\n        )\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many fields. Maximum number of fields is 1.\"\n\n\n@pytest.mark.parametrize(\n    \"app,expectation\",\n    [\n        (make_app_max_parts(max_files=1), pytest.raises(MultiPartException)),\n        (\n            Starlette(routes=[Mount(\"/\", app=make_app_max_parts(max_files=1))]),\n            does_not_raise(),\n        ),\n    ],\n)\ndef test_max_files_is_customizable_low_raises(app, expectation, test_client_factory):\n    client = test_client_factory(app)\n    fields = []\n    for i in range(2):\n        fields.append(\n            \"--B\\r\\n\"\n            f'Content-Disposition: form-data; name=\"F{i}\"; filename=\"F{i}\";\\r\\n\\r\\n'\n            \"\\r\\n\"\n        )\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1.\"\n\n\ndef test_max_fields_is_customizable_high(test_client_factory):\n    client = test_client_factory(make_app_max_parts(max_fields=2000, max_files=2000))\n    fields = []\n    for i in range(2000):\n        fields.append(\n            \"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\"\n        )\n        fields.append(\n            \"--B\\r\\n\"\n            f'Content-Disposition: form-data; name=\"F{i}\"; filename=\"F{i}\";\\r\\n\\r\\n'\n            \"\\r\\n\"\n        )\n    data = \"\".join(fields).encode(\"utf-8\")\n    data += b\"--B--\\r\\n\"\n    res = client.post(\n        \"/\",\n        data=data,\n        headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n    )\n    assert res.status_code == 200\n    res_data = res.json()\n    assert res_data[\"N1999\"] == \"\"\n    assert res_data[\"F1999\"] == {\n        \"filename\": \"F1999\",\n        \"size\": 0,\n        \"content\": \"\",\n        \"content_type\": None,\n    }\n"], "buggy_code_start_loc": [116, 1, 247, 98], "buggy_code_end_loc": [116, 254, 272, 462], "fixing_code_start_loc": [117, 2, 247, 99], "fixing_code_end_loc": [129, 268, 289, 685], "type": "CWE-400", "message": "There MultipartParser usage in Encode's Starlette python framework before versions 0.25.0 allows an unauthenticated and remote attacker to specify any number of form fields or files which can cause excessive memory usage resulting in denial of service of the HTTP service.", "other": {"cve": {"id": "CVE-2023-30798", "sourceIdentifier": "disclosure@vulncheck.com", "published": "2023-04-21T16:15:07.510", "lastModified": "2023-04-28T03:47:52.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There MultipartParser usage in Encode's Starlette python framework before versions 0.25.0 allows an unauthenticated and remote attacker to specify any number of form fields or files which can cause excessive memory usage resulting in denial of service of the HTTP service."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "disclosure@vulncheck.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "disclosure@vulncheck.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:encode:starlette:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.25.0", "matchCriteriaId": "B31CE462-E658-420A-96B2-76266F0DC699"}]}]}], "references": [{"url": "https://github.com/encode/starlette/commit/8c74c2c8dba7030154f8af18e016136bea1938fa", "source": "disclosure@vulncheck.com", "tags": ["Patch"]}, {"url": "https://github.com/encode/starlette/security/advisories/GHSA-74m5-2c7w-9w3x", "source": "disclosure@vulncheck.com", "tags": ["Mitigation", "Vendor Advisory"]}, {"url": "https://vulncheck.com/advisories/starlette-multipartparser-dos", "source": "disclosure@vulncheck.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/encode/starlette/commit/8c74c2c8dba7030154f8af18e016136bea1938fa"}}