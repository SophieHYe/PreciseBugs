{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"psd-private.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include <tiffconf.h>\n# endif\n# include <tiff.h>\n# include <tiffio.h>\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n# if defined(COMPRESSION_ZSTD) && defined(MAGICKCORE_ZSTD_DELEGATE)\n#   include <zstd.h>\n# endif\n\n#if defined(MAGICKCORE_HAVE_STDINT_H) && (TIFFLIB_VERSION >= 20201219)\n#  undef uint16\n#  define uint16  uint16_t\n#  undef uint32\n#  define uint32  uint32_t\n#endif\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\ntypedef struct _PhotoshopProfile\n{\n  StringInfo\n    *data;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    length,\n    extent,\n    quantum;\n} PhotoshopProfile;\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (MAGICK_SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (MAGICK_SSIZE_MIN-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n\nstatic MagickOffsetType TIFFTellCustomStream(void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  return(profile->offset);\n}\n\nstatic void InitPSDInfo(const Image *image,PSDInfo *info)\n{\n  (void) memset(info,0,sizeof(*info));\n  info->version=1;\n  info->columns=image->columns;\n  info->rows=image->rows;\n  info->mode=10; /* Set the mode to a value that won't change the colorspace */\n  info->channels=1U;\n  info->min_channels=1U;\n  info->has_merged_image=MagickFalse;\n  if (image->storage_class == PseudoClass)\n    info->mode=2; /* indexed mode */\n  else\n    {\n      info->channels=(unsigned short) image->number_channels;\n      info->min_channels=info->channels;\n      if (image->alpha_trait == BlendPixelTrait)\n        info->min_channels--;\n    }\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  if (length != 10)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(unsigned int) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(unsigned int) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  if (ferror(file) != 0)\n    {\n      (void) fclose(file);\n      ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n    }\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  message[MagickPathExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic MagickBooleanType TIFFGetProfiles(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  uint32\n    length = 0;\n\n  unsigned char\n    *profile = (unsigned char *) NULL;\n\n  status=MagickTrue;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC) && (TIFFLIB_VERSION >= 20191103)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      const TIFFField\n        *field;\n\n      field=TIFFFieldWithTag(tiff,TIFFTAG_RICHTIFFIPTC);\n      if (TIFFFieldDataType(field) == TIFF_LONG)\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n      else\n        status=ReadProfile(image,\"iptc\",profile,length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      StringInfo\n        *dng;\n\n      status=ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      dng=BlobToStringInfo(profile,length);\n      if (dng != (StringInfo *) NULL)\n        {\n          const char\n            *target = \"dc:format=\\\"image/dng\\\"\";\n\n          if (strstr((char *) GetStringInfoDatum(dng),target) != (char *) NULL)\n            (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n          dng=DestroyStringInfo(dng);\n        }\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n  return(status);\n}\n\nstatic MagickBooleanType TIFFGetProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  MagickBooleanType\n    status;\n\n  uint32\n    count,\n    type;\n\n  text=(char *) NULL;\n  status=MagickTrue;\n  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:artist\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:document\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"comment\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:make\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:model\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"label\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:software\",text,exception);\n  if ((TIFFGetField(tiff,33423,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if ((TIFFGetField(tiff,36867,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  return(status);\n}\n\nstatic MagickBooleanType TIFFSetImageProperties(TIFF *tiff,Image *image,\n  const char *tag,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  int\n    unique_file;\n\n  /*\n    Set EXIF or GPS image properties.\n  */\n  unique_file=AcquireUniqueFileResource(filename);\n  file=(FILE *) NULL;\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"rb+\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      (void) ThrowMagickException(exception,GetMagickModule(),WandError,\n        \"UnableToCreateTemporaryFile\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  TIFFPrintDirectory(tiff,file,0);\n  (void) fseek(file,0,SEEK_SET);\n  while (fgets(buffer,(int) sizeof(buffer),file) != NULL)\n  {\n    char\n      *p,\n      property[MagickPathExtent],\n      value[MagickPathExtent];\n\n    StripString(buffer);\n    p=strchr(buffer,':');\n    if (p == (char *) NULL)\n      continue;\n    *p='\\0';\n    (void) sprintf(property,\"%s%.1024s\",tag,buffer);\n    (void) sprintf(value,\"%s\",p+1);\n    StripString(value);\n    (void) SetImageProperty(image,property,value,exception);\n  }\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  MagickBooleanType\n    status;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return(MagickFalse);\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return(MagickFalse);\n    }\n  status=TIFFSetImageProperties(tiff,image,\"exif:\",exception);\n  TIFFSetDirectory(tiff,directory);\n  return(status);\n#else\n  (void) tiff;\n  (void) image;\n  return(MagickTrue);\n#endif\n}\n\nstatic MagickBooleanType TIFFGetGPSProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADGPSDIRECTORY)\n  MagickBooleanType\n    status;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  /*\n    Read GPS properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_GPSIFD,&offset) != 1)\n    return(MagickFalse);\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadGPSDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return(MagickFalse);\n    }\n  status=TIFFSetImageProperties(tiff,image,\"exif:GPS\",exception);\n  TIFFSetDirectory(tiff,directory);\n  return(status);\n#else\n  magick_unreferenced(tiff);\n  magick_unreferenced(image);\n  magick_unreferenced(exception);\n  return(MagickTrue);\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,const tsample_t sample,const ssize_t row,\n  tdata_t scanline)\n{\n  int32\n    status;\n\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  message[MagickPathExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    *value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /*\n    Only support 8 bit for now.\n  */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /*\n    Search for Adobe APP14 JPEG marker.\n  */\n  value=NULL;\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value) || (value == NULL))\n    return(ReadStripMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadStripMethod);\n  method=ReadStripMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  size_t\n    total;\n\n  MagickOffsetType\n    remaining;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForReading(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamReader(custom_stream,TIFFReadCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic void TIFFReadPhotoshopLayers(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *layers;\n\n  ImageInfo\n    *clone_info;\n\n  PhotoshopProfile\n    photoshop_profile;\n\n  PSDInfo\n    info;\n\n  ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  profile=GetImageProfile(image,\"tiff:37724\");\n  if (profile == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) profile->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (profile->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (profile->length-8))\n    return;\n  photoshop_profile.data=(StringInfo *) profile;\n  photoshop_profile.length=profile->length;\n  custom_stream=TIFFAcquireCustomStreamForReading(&photoshop_profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return;\n  layers=CloneImage(image,0,0,MagickTrue,exception);\n  if (layers == (Image *) NULL)\n    {\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      return;\n    }\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachCustomStream(layers->blob,custom_stream);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  InitPSDInfo(layers,&info);\n  clone_info=CloneImageInfo(image_info);\n  clone_info->number_scenes=0;\n  (void) ReadPSDLayers(layers,clone_info,&info,exception);\n  clone_info=DestroyImageInfo(clone_info);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[4] = { NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetEXIFProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetGPSProperties(tiff,image,exception);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->resolution.x-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->resolution.y-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace,exception);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                    exception);\n                }\n          }\n      }\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          buffer[MagickPathExtent];\n\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",buffer,exception);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          Quantum\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (tiff_status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=2*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=TIFFTileSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=columns*sizeof(uint64);\n#else\n        extent+=columns*sizeof(uint32);\n#endif\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                Quantum\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo * ) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n#if defined(TIFF_VERSION_BIG)\n        number_pixels+=image->columns*sizeof(uint64);\n#else\n        number_pixels+=image->columns*sizeof(uint32);\n#endif\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if (status != MagickFalse)\n    TIFFReadPhotoshopLayers(image_info,image,exception);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  /*\n    This also sets field_bit to 0 (FIELD_IGNORE).\n  */\n  (void) memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n#endif\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      DestroyBlob(pyramid_image);\n      pyramid_image->blob=ReferenceBlob(next->blob);\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  status=MagickFalse;\n  if (images != (Image *) NULL)\n    {\n      /*\n        Write pyramid-encoded TIFF image.\n      */\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n#define TIFFStripSizeDefault  1048576\n\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) memset(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    {\n      size_t\n        extent;\n\n      uint32\n        rows,\n        rows_per_strip;\n\n      extent=TIFFScanlineSize(tiff);\n      rows_per_strip=TIFFStripSizeDefault/(extent == 0 ? 1 : (uint32) extent);\n      rows_per_strip=16*(((rows_per_strip < 16 ? 16 : rows_per_strip)+1)/16);\n      TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&rows);\n      if (rows_per_strip > rows)\n        rows_per_strip=rows;\n      option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n      if (option != (const char *) NULL)\n        rows_per_strip=(uint32) strtoul(option,(char **) NULL,10);\n      rows_per_strip=TIFFDefaultStripSize(tiff,rows_per_strip);\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      return(MagickTrue);\n    }\n  /*\n    Create tiled TIFF, ignore \"tiff:rows-per-strip\".\n  */\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  if ((TIFFScanlineSize(tiff) <= 0) || (TIFFTileSize(tiff) <= 0))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  ssize_t\n    i;\n\n  unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) memcpy(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic ssize_t TIFFWriteCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  if ((profile->offset+(MagickOffsetType) count) >=\n        (MagickOffsetType) profile->extent)\n    {\n      profile->extent+=count+profile->quantum;\n      profile->quantum<<=1;\n      SetStringInfoLength(profile->data,profile->extent);\n    }\n  (void) memcpy(profile->data->datum+profile->offset,data,count);\n  profile->offset+=count;\n  return(count);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForWriting(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamWriter(custom_stream,TIFFWriteCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *base_image,\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  base_image=CloneImage(image,0,0,MagickFalse,exception);\n  if (base_image == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(base_image);\n  base_image->blob=blob;\n  next=base_image;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  AttachCustomStream(base_image->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  base_image->endian=endian;\n  WriteBlobString(base_image,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(base_image,0);\n  WriteBlobString(base_image,base_image->endian == LSBEndian ? \"MIB8ryaL\" :\n    \"8BIMLayr\");\n  status=WritePSDLayers(base_image,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  next=base_image;\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const MagickBooleanType adjoin,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    adjoin,\n    preserve_compression,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  size_t\n    imageListLength,\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric,\n    predictor;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;\n    }\n  mode=endian_type == LSBEndian ? \"wl\" : \"wb\";\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    mode=endian_type == LSBEndian ? \"wl8\" : \"wb8\";\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      return(MagickFalse);\n    }\n  (void) DeleteImageProfile(image,\"tiff:37724\");\n  scene=0;\n  adjoin=image_info->adjoin;\n  imageListLength=GetImageListLength(image);\n  option=GetImageOption(image_info,\"tiff:preserve-compression\");\n  preserve_compression=IsStringTrue(option);\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType) &&\n        (image_info->type != image->type))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=image_info->compression;\n    if (preserve_compression != MagickFalse)\n      compression=image->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if (IsImageMonochrome(image) == MagickFalse)\n          {\n            if (IsImageGray(image) == MagickFalse)\n              (void) SetImageType(image,BilevelType,exception);\n            else\n              (void) SetImageDepth(image,1,exception);\n          }\n        image->depth=1;\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          {\n            quantum_info=DestroyQuantumInfo(quantum_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n#if defined(COMPRESSION_ZSTD)\n      case ZstdCompression:\n      {\n        compress_tag=COMPRESSION_ZSTD;\n        break;\n      }\n#endif\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n            MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              status=SetQuantumDepth(image,quantum_info,8);\n              if (status == MagickFalse)\n                ThrowWriterException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if ((image->storage_class == PseudoClass) &&\n                  (image->alpha_trait == UndefinedPixelTrait))\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) ||\n        (compress_tag == COMPRESSION_CCITTFAX4))\n      {\n         if ((photometric != PHOTOMETRIC_MINISWHITE) &&\n             (photometric != PHOTOMETRIC_MINISBLACK))\n          {\n            compress_tag=COMPRESSION_NONE;\n            endian=FILLORDER_MSB2LSB;\n          }\n      }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel,sans);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    predictor=0;\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n                }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        break;\n      }\n#if defined(WEBP_SUPPORT) && defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_WEBP_LEVEL,image_info->quality);\n        if (image_info->quality >= 100)\n          (void) TIFFSetField(tiff,TIFFTAG_WEBP_LOSSLESS,1);\n        break;\n      }\n#endif\n#if defined(ZSTD_SUPPORT) && defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZSTD_LEVEL,22*image_info->quality/\n          100.0);\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    if (quantum_info->format == FloatingPointQuantumFormat)\n      predictor=PREDICTOR_FLOATINGPOINT;\n    option=GetImageOption(image_info,\"tiff:predictor\");\n    if (option != (const char * ) NULL)\n      predictor=(uint16) strtol(option,(char **) NULL,10);\n    if (predictor != 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,predictor);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    option=GetImageOption(image_info,\"tiff:write-layers\");\n    if (IsStringTrue(option) != MagickFalse)\n      {\n        (void) TIFFWritePhotoshopLayers(image,image_info,endian_type,exception);\n        adjoin=MagickFalse;\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (adjoin != MagickFalse) && (imageListLength > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            imageListLength);\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    else\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) imageListLength;\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,adjoin,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (compress_tag == COMPRESSION_CCITTFAX4)\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,(uint32) image->rows);\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          {\n            if (red != (uint16 *) NULL)\n              red=(uint16 *) RelinquishMagickMemory(red);\n            if (green != (uint16 *) NULL)\n              green=(uint16 *) RelinquishMagickMemory(green);\n            if (blue != (uint16 *) NULL)\n              blue=(uint16 *) RelinquishMagickMemory(blue);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) memset(red,0,65536*sizeof(*red));\n        (void) memset(green,0,65536*sizeof(*green));\n        (void) memset(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    if (TIFFWriteDirectory(tiff) == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(status);\n}\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"psd-private.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include <tiffconf.h>\n# endif\n# include <tiff.h>\n# include <tiffio.h>\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n# if defined(COMPRESSION_ZSTD) && defined(MAGICKCORE_ZSTD_DELEGATE)\n#   include <zstd.h>\n# endif\n\n#if defined(MAGICKCORE_HAVE_STDINT_H) && (TIFFLIB_VERSION >= 20201219)\n#  undef uint16\n#  define uint16  uint16_t\n#  undef uint32\n#  define uint32  uint32_t\n#endif\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\ntypedef struct _PhotoshopProfile\n{\n  StringInfo\n    *data;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    length,\n    extent,\n    quantum;\n} PhotoshopProfile;\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (MAGICK_SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (MAGICK_SSIZE_MIN-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n\nstatic MagickOffsetType TIFFTellCustomStream(void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  return(profile->offset);\n}\n\nstatic void InitPSDInfo(const Image *image,PSDInfo *info)\n{\n  (void) memset(info,0,sizeof(*info));\n  info->version=1;\n  info->columns=image->columns;\n  info->rows=image->rows;\n  info->mode=10; /* Set the mode to a value that won't change the colorspace */\n  info->channels=1U;\n  info->min_channels=1U;\n  info->has_merged_image=MagickFalse;\n  if (image->storage_class == PseudoClass)\n    info->mode=2; /* indexed mode */\n  else\n    {\n      info->channels=(unsigned short) image->number_channels;\n      info->min_channels=info->channels;\n      if (image->alpha_trait == BlendPixelTrait)\n        info->min_channels--;\n    }\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  if (length != 10)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(unsigned int) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(unsigned int) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  if (ferror(file) != 0)\n    {\n      (void) fclose(file);\n      ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n    }\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  message[MagickPathExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic MagickBooleanType TIFFGetProfiles(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  uint32\n    length = 0;\n\n  unsigned char\n    *profile = (unsigned char *) NULL;\n\n  status=MagickTrue;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC) && (TIFFLIB_VERSION >= 20191103)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      const TIFFField\n        *field;\n\n      field=TIFFFieldWithTag(tiff,TIFFTAG_RICHTIFFIPTC);\n      if (TIFFFieldDataType(field) == TIFF_LONG)\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n      else\n        status=ReadProfile(image,\"iptc\",profile,length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      StringInfo\n        *dng;\n\n      status=ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      dng=BlobToStringInfo(profile,length);\n      if (dng != (StringInfo *) NULL)\n        {\n          const char\n            *target = \"dc:format=\\\"image/dng\\\"\";\n\n          if (strstr((char *) GetStringInfoDatum(dng),target) != (char *) NULL)\n            (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n          dng=DestroyStringInfo(dng);\n        }\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n  return(status);\n}\n\nstatic MagickBooleanType TIFFGetProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  MagickBooleanType\n    status;\n\n  uint32\n    count,\n    type;\n\n  text=(char *) NULL;\n  status=MagickTrue;\n  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:artist\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:document\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"comment\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:make\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:model\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"label\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:software\",text,exception);\n  if ((TIFFGetField(tiff,33423,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if ((TIFFGetField(tiff,36867,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  return(status);\n}\n\nstatic MagickBooleanType TIFFSetImageProperties(TIFF *tiff,Image *image,\n  const char *tag,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  int\n    unique_file;\n\n  /*\n    Set EXIF or GPS image properties.\n  */\n  unique_file=AcquireUniqueFileResource(filename);\n  file=(FILE *) NULL;\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"rb+\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      (void) ThrowMagickException(exception,GetMagickModule(),WandError,\n        \"UnableToCreateTemporaryFile\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  TIFFPrintDirectory(tiff,file,0);\n  (void) fseek(file,0,SEEK_SET);\n  while (fgets(buffer,(int) sizeof(buffer),file) != NULL)\n  {\n    char\n      *p,\n      property[MagickPathExtent],\n      value[MagickPathExtent];\n\n    StripString(buffer);\n    p=strchr(buffer,':');\n    if (p == (char *) NULL)\n      continue;\n    *p='\\0';\n    (void) sprintf(property,\"%s%.1024s\",tag,buffer);\n    (void) sprintf(value,\"%s\",p+1);\n    StripString(value);\n    (void) SetImageProperty(image,property,value,exception);\n  }\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  MagickBooleanType\n    status;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return(MagickFalse);\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return(MagickFalse);\n    }\n  status=TIFFSetImageProperties(tiff,image,\"exif:\",exception);\n  TIFFSetDirectory(tiff,directory);\n  return(status);\n#else\n  (void) tiff;\n  (void) image;\n  return(MagickTrue);\n#endif\n}\n\nstatic MagickBooleanType TIFFGetGPSProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADGPSDIRECTORY)\n  MagickBooleanType\n    status;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  /*\n    Read GPS properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_GPSIFD,&offset) != 1)\n    return(MagickFalse);\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadGPSDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return(MagickFalse);\n    }\n  status=TIFFSetImageProperties(tiff,image,\"exif:GPS\",exception);\n  TIFFSetDirectory(tiff,directory);\n  return(status);\n#else\n  magick_unreferenced(tiff);\n  magick_unreferenced(image);\n  magick_unreferenced(exception);\n  return(MagickTrue);\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,const tsample_t sample,const ssize_t row,\n  tdata_t scanline)\n{\n  int32\n    status;\n\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  message[MagickPathExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    *value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /*\n    Only support 8 bit for now.\n  */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /*\n    Search for Adobe APP14 JPEG marker.\n  */\n  value=NULL;\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value) || (value == NULL))\n    return(ReadStripMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadStripMethod);\n  method=ReadStripMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  size_t\n    total;\n\n  MagickOffsetType\n    remaining;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForReading(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamReader(custom_stream,TIFFReadCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic void TIFFReadPhotoshopLayers(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *layers;\n\n  ImageInfo\n    *clone_info;\n\n  PhotoshopProfile\n    photoshop_profile;\n\n  PSDInfo\n    info;\n\n  ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  profile=GetImageProfile(image,\"tiff:37724\");\n  if (profile == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) profile->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (profile->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (profile->length-8))\n    return;\n  photoshop_profile.data=(StringInfo *) profile;\n  photoshop_profile.length=profile->length;\n  custom_stream=TIFFAcquireCustomStreamForReading(&photoshop_profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return;\n  layers=CloneImage(image,0,0,MagickTrue,exception);\n  if (layers == (Image *) NULL)\n    {\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      return;\n    }\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachCustomStream(layers->blob,custom_stream);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  InitPSDInfo(layers,&info);\n  clone_info=CloneImageInfo(image_info);\n  clone_info->number_scenes=0;\n  (void) ReadPSDLayers(layers,clone_info,&info,exception);\n  clone_info=DestroyImageInfo(clone_info);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[4] = { NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetEXIFProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetGPSProperties(tiff,image,exception);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->resolution.x-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->resolution.y-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace,exception);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                    exception);\n                }\n          }\n      }\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          buffer[MagickPathExtent];\n\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",buffer,exception);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          Quantum\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (tiff_status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=TIFFTileSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=columns*sizeof(uint64);\n#else\n        extent+=columns*sizeof(uint32);\n#endif\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                Quantum\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo * ) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n#if defined(TIFF_VERSION_BIG)\n        number_pixels+=image->columns*sizeof(uint64);\n#else\n        number_pixels+=image->columns*sizeof(uint32);\n#endif\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if (status != MagickFalse)\n    TIFFReadPhotoshopLayers(image_info,image,exception);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  /*\n    This also sets field_bit to 0 (FIELD_IGNORE).\n  */\n  (void) memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n#endif\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      DestroyBlob(pyramid_image);\n      pyramid_image->blob=ReferenceBlob(next->blob);\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  status=MagickFalse;\n  if (images != (Image *) NULL)\n    {\n      /*\n        Write pyramid-encoded TIFF image.\n      */\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n#define TIFFStripSizeDefault  1048576\n\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) memset(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    {\n      size_t\n        extent;\n\n      uint32\n        rows,\n        rows_per_strip;\n\n      extent=TIFFScanlineSize(tiff);\n      rows_per_strip=TIFFStripSizeDefault/(extent == 0 ? 1 : (uint32) extent);\n      rows_per_strip=16*(((rows_per_strip < 16 ? 16 : rows_per_strip)+1)/16);\n      TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&rows);\n      if (rows_per_strip > rows)\n        rows_per_strip=rows;\n      option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n      if (option != (const char *) NULL)\n        rows_per_strip=(uint32) strtoul(option,(char **) NULL,10);\n      rows_per_strip=TIFFDefaultStripSize(tiff,rows_per_strip);\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      return(MagickTrue);\n    }\n  /*\n    Create tiled TIFF, ignore \"tiff:rows-per-strip\".\n  */\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  if ((TIFFScanlineSize(tiff) <= 0) || (TIFFTileSize(tiff) <= 0))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  ssize_t\n    i;\n\n  unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) memcpy(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic ssize_t TIFFWriteCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  if ((profile->offset+(MagickOffsetType) count) >=\n        (MagickOffsetType) profile->extent)\n    {\n      profile->extent+=count+profile->quantum;\n      profile->quantum<<=1;\n      SetStringInfoLength(profile->data,profile->extent);\n    }\n  (void) memcpy(profile->data->datum+profile->offset,data,count);\n  profile->offset+=count;\n  return(count);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForWriting(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamWriter(custom_stream,TIFFWriteCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *base_image,\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  base_image=CloneImage(image,0,0,MagickFalse,exception);\n  if (base_image == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(base_image);\n  base_image->blob=blob;\n  next=base_image;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  AttachCustomStream(base_image->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  base_image->endian=endian;\n  WriteBlobString(base_image,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(base_image,0);\n  WriteBlobString(base_image,base_image->endian == LSBEndian ? \"MIB8ryaL\" :\n    \"8BIMLayr\");\n  status=WritePSDLayers(base_image,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  next=base_image;\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const MagickBooleanType adjoin,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    adjoin,\n    preserve_compression,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  size_t\n    imageListLength,\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric,\n    predictor;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;\n    }\n  mode=endian_type == LSBEndian ? \"wl\" : \"wb\";\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    mode=endian_type == LSBEndian ? \"wl8\" : \"wb8\";\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      return(MagickFalse);\n    }\n  (void) DeleteImageProfile(image,\"tiff:37724\");\n  scene=0;\n  adjoin=image_info->adjoin;\n  imageListLength=GetImageListLength(image);\n  option=GetImageOption(image_info,\"tiff:preserve-compression\");\n  preserve_compression=IsStringTrue(option);\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType) &&\n        (image_info->type != image->type))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=image_info->compression;\n    if (preserve_compression != MagickFalse)\n      compression=image->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if (IsImageMonochrome(image) == MagickFalse)\n          {\n            if (IsImageGray(image) == MagickFalse)\n              (void) SetImageType(image,BilevelType,exception);\n            else\n              (void) SetImageDepth(image,1,exception);\n          }\n        image->depth=1;\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          {\n            quantum_info=DestroyQuantumInfo(quantum_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n#if defined(COMPRESSION_ZSTD)\n      case ZstdCompression:\n      {\n        compress_tag=COMPRESSION_ZSTD;\n        break;\n      }\n#endif\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n            MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              status=SetQuantumDepth(image,quantum_info,8);\n              if (status == MagickFalse)\n                ThrowWriterException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if ((image->storage_class == PseudoClass) &&\n                  (image->alpha_trait == UndefinedPixelTrait))\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) ||\n        (compress_tag == COMPRESSION_CCITTFAX4))\n      {\n         if ((photometric != PHOTOMETRIC_MINISWHITE) &&\n             (photometric != PHOTOMETRIC_MINISBLACK))\n          {\n            compress_tag=COMPRESSION_NONE;\n            endian=FILLORDER_MSB2LSB;\n          }\n      }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel,sans);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    predictor=0;\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n                }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        break;\n      }\n#if defined(WEBP_SUPPORT) && defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_WEBP_LEVEL,image_info->quality);\n        if (image_info->quality >= 100)\n          (void) TIFFSetField(tiff,TIFFTAG_WEBP_LOSSLESS,1);\n        break;\n      }\n#endif\n#if defined(ZSTD_SUPPORT) && defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZSTD_LEVEL,22*image_info->quality/\n          100.0);\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    if (quantum_info->format == FloatingPointQuantumFormat)\n      predictor=PREDICTOR_FLOATINGPOINT;\n    option=GetImageOption(image_info,\"tiff:predictor\");\n    if (option != (const char * ) NULL)\n      predictor=(uint16) strtol(option,(char **) NULL,10);\n    if (predictor != 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,predictor);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    option=GetImageOption(image_info,\"tiff:write-layers\");\n    if (IsStringTrue(option) != MagickFalse)\n      {\n        (void) TIFFWritePhotoshopLayers(image,image_info,endian_type,exception);\n        adjoin=MagickFalse;\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (adjoin != MagickFalse) && (imageListLength > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            imageListLength);\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    else\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) imageListLength;\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,adjoin,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (compress_tag == COMPRESSION_CCITTFAX4)\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,(uint32) image->rows);\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          {\n            if (red != (uint16 *) NULL)\n              red=(uint16 *) RelinquishMagickMemory(red);\n            if (green != (uint16 *) NULL)\n              green=(uint16 *) RelinquishMagickMemory(green);\n            if (blue != (uint16 *) NULL)\n              blue=(uint16 *) RelinquishMagickMemory(blue);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) memset(red,0,65536*sizeof(*red));\n        (void) memset(green,0,65536*sizeof(*green));\n        (void) memset(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    if (TIFFWriteDirectory(tiff) == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(status);\n}\n#endif\n"], "buggy_code_start_loc": [1903], "buggy_code_end_loc": [1904], "fixing_code_start_loc": [1903], "fixing_code_end_loc": [1904], "type": "CWE-125", "message": "A heap-based buffer overflow vulnerability was found in ImageMagick in versions prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is due to an incorrect setting of the pixel array size, which can lead to a crash and segmentation fault.", "other": {"cve": {"id": "CVE-2021-3610", "sourceIdentifier": "secalert@redhat.com", "published": "2022-02-24T19:15:09.213", "lastModified": "2023-06-06T14:01:31.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap-based buffer overflow vulnerability was found in ImageMagick in versions prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is due to an incorrect setting of the pixel array size, which can lead to a crash and segmentation fault."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad de desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en ImageMagick en las versiones anteriores a 7.0.11-14 en la funci\u00f3n ReadTIFFImage() en el archivo coders/tiff.c. Este problema es debido a un ajuste incorrecto del tama\u00f1o de la matriz de p\u00edxeles, que puede conllevar un fallo de bloqueo y segmentaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.9.10.88", "versionEndExcluding": "6.9.12-14", "matchCriteriaId": "4B402469-D9D7-42B8-B2E5-365A0C17B333"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.11-14", "matchCriteriaId": "8C4ED8DF-FA1F-4CB5-8724-9E8B1C3B10AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/05/29/4", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/06/05/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1973689", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/930ff0d1a9bc42925a7856e9ea53f5fc9f318bf3", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/930ff0d1a9bc42925a7856e9ea53f5fc9f318bf3"}}