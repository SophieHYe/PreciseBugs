{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%              M   M   OOO   GGGGG  RRRR   IIIII  FFFFF  Y   Y                %\n%              MM MM  O   O  G      R   R    I    F       Y Y                 %\n%              M M M  O   O  G GGG  RRRR     I    FFF      Y                  %\n%              M   M  O   O  G   G  R R      I    F        Y                  %\n%              M   M   OOO   GGGG   R  R   IIIII  F        Y                  %\n%                                                                             %\n%                                                                             %\n%                         MagickWand Module Methods                           %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                March 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Use the mogrify program to resize an image, blur, crop, despeckle, dither,\n%  draw on, flip, join, re-sample, and much more. This tool is similiar to\n%  convert except that the original image file is overwritten (unless you\n%  change the file suffix with the -format option) with any changes you\n%  request.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/mogrify-private.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_HAVE_UTIME_H)\n#include <utime.h>\n#endif\n\f\n/*\n  Constant declaration.\n*/\nstatic const char\n  MogrifyAlphaColor[] = \"#bdbdbd\",  /* gray */\n  MogrifyBackgroundColor[] = \"#ffffff\",  /* white */\n  MogrifyBorderColor[] = \"#dfdfdf\";  /* gray */\n\f\n/*\n  Define declarations.\n*/\n#define UndefinedCompressionQuality  0UL\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     M a g i c k C o m m a n d G e n e s i s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickCommandGenesis() applies image processing options to an image as\n%  prescribed by command line options.\n%\n%  It wiil look for special options like \"-debug\", \"-bench\", and\n%  \"-distribute-cache\" that needs to be applied even before the main\n%  processing begins, and may completely overrule normal command processing.\n%  Such 'Genesis' Options can only be given on the CLI, (not in a script)\n%  and are typically ignored (as they have been handled) if seen later.\n%\n%  The format of the MagickCommandGenesis method is:\n%\n%      MagickBooleanType MagickCommandGenesis(ImageInfo *image_info,\n%        MagickCommand command,int argc,char **argv,char **metadata,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o command: Choose from ConvertImageCommand, IdentifyImageCommand,\n%      MogrifyImageCommand, CompositeImageCommand, CompareImagesCommand,\n%      ConjureImageCommand, StreamImageCommand, ImportImageCommand,\n%      DisplayImageCommand, or AnimateImageCommand.\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o metadata: any metadata is returned here.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MagickCommandGenesis(ImageInfo *image_info,\n  MagickCommand command,int argc,char **argv,char **metadata,\n  ExceptionInfo *exception)\n{\n  char\n    client_name[MaxTextExtent],\n    *option;\n\n  double\n    duration,\n    serial;\n\n  MagickBooleanType\n    concurrent,\n    regard_warnings,\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    iterations,\n    number_threads;\n\n  ssize_t\n    n;\n\n  (void) setlocale(LC_ALL,\"\");\n  (void) setlocale(LC_NUMERIC,\"C\");\n  GetPathComponent(argv[0],TailPath,client_name);\n  (void) SetClientName(client_name);\n  concurrent=MagickFalse;\n  duration=(-1.0);\n  iterations=1;\n  status=MagickTrue;\n  regard_warnings=MagickFalse;\n  for (i=1; i < (ssize_t) (argc-1); i++)\n  {\n    option=argv[i];\n    if ((strlen(option) == 1) || ((*option != '-') && (*option != '+')))\n      continue;\n    if (LocaleCompare(\"-bench\",option) == 0)\n      iterations=StringToUnsignedLong(argv[++i]);\n    if (LocaleCompare(\"-concurrent\",option) == 0)\n      concurrent=MagickTrue;\n    if (LocaleCompare(\"-debug\",option) == 0)\n      (void) SetLogEventMask(argv[++i]);\n    if (LocaleCompare(\"-distribute-cache\",option) == 0)\n      {\n        DistributePixelCacheServer(StringToInteger(argv[++i]),exception);\n        exit(0);\n      }\n    if (LocaleCompare(\"-duration\",option) == 0)\n      duration=StringToDouble(argv[++i],(char **) NULL);\n    if (LocaleCompare(\"-regard-warnings\",option) == 0)\n      regard_warnings=MagickTrue;\n  }\n  if (iterations == 1)\n    {\n      char\n        *text;\n\n      text=(char *) NULL;\n      status=command(image_info,argc,argv,&text,exception);\n      if (exception->severity != UndefinedException)\n        {\n          if ((exception->severity > ErrorException) ||\n              (regard_warnings != MagickFalse))\n            status=MagickFalse;\n          CatchException(exception);\n        }\n      if (text != (char *) NULL)\n        {\n          if (metadata != (char **) NULL)\n            (void) ConcatenateString(&(*metadata),text);\n          text=DestroyString(text);\n        }\n      return(status);\n    }\n  number_threads=GetOpenMPMaximumThreads();\n  serial=0.0;\n  for (n=1; n <= (ssize_t) number_threads; n++)\n  {\n    double\n      e,\n      parallel,\n      user_time;\n\n    TimerInfo\n      *timer;\n\n    (void) SetMagickResourceLimit(ThreadResource,(MagickSizeType) n);\n    timer=AcquireTimerInfo();\n    if (concurrent == MagickFalse)\n      {\n        for (i=0; i < (ssize_t) iterations; i++)\n        {\n          char\n            *text;\n\n          text=(char *) NULL;\n          if (status == MagickFalse)\n            continue;\n          if (duration > 0)\n            {\n              if (GetElapsedTime(timer) > duration)\n                continue;\n              (void) ContinueTimer(timer);\n            }\n          status=command(image_info,argc,argv,&text,exception);\n          if (exception->severity != UndefinedException)\n            {\n              if ((exception->severity > ErrorException) ||\n                  (regard_warnings != MagickFalse))\n                status=MagickFalse;\n              CatchException(exception);\n            }\n          if (text != (char *) NULL)\n            {\n              if (metadata != (char **) NULL)\n                (void) ConcatenateString(&(*metadata),text);\n              text=DestroyString(text);\n            }\n          }\n      }\n    else\n      {\n        SetOpenMPNested(1);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        # pragma omp parallel for shared(status)\n#endif\n        for (i=0; i < (ssize_t) iterations; i++)\n        {\n          char\n            *text;\n\n          text=(char *) NULL;\n          if (status == MagickFalse)\n            continue;\n          if (duration > 0)\n            {\n              if (GetElapsedTime(timer) > duration)\n                continue;\n              (void) ContinueTimer(timer);\n            }\n          status=command(image_info,argc,argv,&text,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          # pragma omp critical (MagickCore_MagickCommandGenesis)\n#endif\n          {\n            if (exception->severity != UndefinedException)\n              {\n                if ((exception->severity > ErrorException) ||\n                    (regard_warnings != MagickFalse))\n                  status=MagickFalse;\n                CatchException(exception);\n              }\n            if (text != (char *) NULL)\n              {\n                if (metadata != (char **) NULL)\n                  (void) ConcatenateString(&(*metadata),text);\n                text=DestroyString(text);\n              }\n          }\n        }\n      }\n    user_time=GetUserTime(timer);\n    parallel=GetElapsedTime(timer);\n    e=1.0;\n    if (n == 1)\n      serial=parallel;\n    else\n      e=((1.0/(1.0/((serial/(serial+parallel))+(1.0-(serial/(serial+parallel)))/\n        (double) n)))-(1.0/(double) n))/(1.0-1.0/(double) n);\n    (void) FormatLocaleFile(stderr,\n      \"  Performance[%.20g]: %.20gi %0.3fips %0.6fe %0.6fu %lu:%02lu.%03lu\\n\",\n      (double) n,(double) iterations,(double) iterations/parallel,e,user_time,\n      (unsigned long) (parallel/60.0),(unsigned long) floor(fmod(parallel,\n      60.0)),(unsigned long) (1000.0*(parallel-floor(parallel))+0.5));\n    timer=DestroyTimerInfo(timer);\n  }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImage() applies simple single image processing options to a single\n%  image that may be part of a large list, but also handles any 'region'\n%  image handling.\n%\n%  The image in the list may be modified in three different ways...\n%\n%    * directly modified (EG: -negate, -gamma, -level, -annotate, -draw),\n%    * replaced by a new image (EG: -spread, -resize, -rotate, -morphology)\n%    * replace by a list of images (only the -separate option!)\n%\n%  In each case the result is returned into the list, and a pointer to the\n%  modified image (last image added if replaced by a list of images) is\n%  returned.\n%\n%  ASIDE: The -crop is present but restricted to non-tile single image crops\n%\n%  This means if all the images are being processed (such as by\n%  MogrifyImages(), next image to be processed will be as per the pointer\n%  (*image)->next.  Also the image list may grow as a result of some specific\n%  operations but as images are never merged or deleted, it will never shrink\n%  in length.  Typically the list will remain the same length.\n%\n%  WARNING: As the image pointed to may be replaced, the first image in the\n%  list may also change.  GetFirstImageInList() should be used by caller if\n%  they wish return the Image pointer to the first image in list.\n%\n%\n%  The format of the MogrifyImage method is:\n%\n%      MagickBooleanType MogrifyImage(ImageInfo *image_info,const int argc,\n%        const char **argv,Image **image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  /*\n    Read an image into a image cache (for repeated usage) if not already in\n    cache.  Then return the image that is in the cache.\n  */\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\nstatic inline MagickBooleanType IsPathWritable(const char *path)\n{\n  if (IsPathAccessible(path) == MagickFalse)\n    return(MagickFalse);\n  if (access_utf8(path,W_OK) != 0)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType MonitorProgress(const char *text,\n  const MagickOffsetType offset,const MagickSizeType extent,\n  void *wand_unused(client_data))\n{\n  char\n    message[MagickPathExtent],\n    tag[MagickPathExtent];\n\n  const char\n    *locale_message;\n\n  register char\n    *p;\n\n  magick_unreferenced(client_data);\n\n  if ((extent <= 1) || (offset < 0) || (offset >= (MagickOffsetType) extent))\n    return(MagickTrue);\n  if ((offset != (MagickOffsetType) (extent-1)) && ((offset % 50) != 0))\n    return(MagickTrue);\n  (void) CopyMagickString(tag,text,MagickPathExtent);\n  p=strrchr(tag,'/');\n  if (p != (char *) NULL)\n    *p='\\0';\n  (void) FormatLocaleString(message,MagickPathExtent,\"Monitor/%s\",tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == message)\n    locale_message=tag;\n  if (p == (char *) NULL)\n    (void) FormatLocaleFile(stderr,\"%s: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  else\n    (void) FormatLocaleFile(stderr,\"%s[%s]: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,p+1,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  if (offset == (MagickOffsetType) (extent-1))\n    (void) FormatLocaleFile(stderr,\"\\n\");\n  (void) fflush(stderr);\n  return(MagickTrue);\n}\n\nstatic Image *SparseColorOption(const Image *image,\n  const SparseColorMethod method,const char *arguments,\n  const MagickBooleanType color_from_image,ExceptionInfo *exception)\n{\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    *sparse_arguments;\n\n  Image\n    *sparse_image;\n\n  PixelInfo\n    color;\n\n  MagickBooleanType\n    error;\n\n  register size_t\n    x;\n\n  size_t\n    number_arguments,\n    number_colors;\n\n  /*\n    SparseColorOption() parses the complex -sparse-color argument into an an\n    array of floating point values then calls SparseColorImage().  Argument is\n    a complex mix of floating-point pixel coodinates, and color specifications\n    (or direct floating point numbers).  The number of floats needed to\n    represent a color varies depending on the current channel setting.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Limit channels according to image - and add up number of color channel.\n  */\n  number_colors=0;\n  if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    number_colors++;\n  if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->alpha_trait != UndefinedPixelTrait))\n    number_colors++;\n\n  /*\n    Read string, to determine number of arguments needed,\n  */\n  p=arguments;\n  x=0;\n  while( *p != '\\0' )\n  {\n    GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == ',' ) continue;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      if ( color_from_image ) {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color arg given, when colors are coming from image\");\n        return( (Image *) NULL);\n      }\n      x += number_colors;  /* color argument */\n    }\n    else {\n      x++;   /* floating point argument */\n    }\n  }\n  error=MagickTrue;\n  if ( color_from_image ) {\n    /* just the control points are being given */\n    error = ( x % 2 != 0 ) ? MagickTrue : MagickFalse;\n    number_arguments=(x/2)*(2+number_colors);\n  }\n  else {\n    /* control points and color values */\n    error = ( x % (2+number_colors) != 0 ) ? MagickTrue : MagickFalse;\n    number_arguments=x;\n  }\n  if ( error ) {\n    (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n               \"Invalid number of Arguments\");\n    return( (Image *) NULL);\n  }\n\n  /* Allocate and fill in the floating point arguments */\n  sparse_arguments=(double *) AcquireQuantumMemory(number_arguments,\n    sizeof(*sparse_arguments));\n  if (sparse_arguments == (double *) NULL) {\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"  MemoryAllocationFailed\\n\"\"%s\",\"SparseColorOption\");\n    return( (Image *) NULL);\n  }\n  (void) memset(sparse_arguments,0,number_arguments*\n    sizeof(*sparse_arguments));\n  p=arguments;\n  x=0;\n  while( *p != '\\0' && x < number_arguments ) {\n    /* X coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of X-coord\");\n      error = MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* Y coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of Y-coord\");\n      error = MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* color values for this control point */\n#if 0\n    if ( (color_from_image ) {\n      /* get color from image */\n      /* HOW??? */\n    }\n    else\n#endif\n    {\n      /* color name or function given in string argument */\n      token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n      if ( token[0] == '\\0' ) break;\n      if ( isalpha((int) token[0]) || token[0] == '#' ) {\n        /* Color string given */\n        (void) QueryColorCompliance(token,AllCompliance,&color,exception);\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          sparse_arguments[x++] = QuantumScale*color.red;\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          sparse_arguments[x++] = QuantumScale*color.green;\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          sparse_arguments[x++] = QuantumScale*color.blue;\n        if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->colorspace == CMYKColorspace))\n          sparse_arguments[x++] = QuantumScale*color.black;\n        if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->alpha_trait != UndefinedPixelTrait))\n          sparse_arguments[x++] = QuantumScale*color.alpha;\n      }\n      else {\n        /* Colors given as a set of floating point values - experimental */\n        /* NB: token contains the first floating point value to use! */\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->colorspace == CMYKColorspace))\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->alpha_trait != UndefinedPixelTrait))\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n      }\n    }\n  }\n  if ( number_arguments != x && !error ) {\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"  InvalidArgument\",\"'%s': %s\",\"sparse-color\",\"Argument Parsing Error\");\n    sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n    return( (Image *) NULL);\n  }\n  if ( error )\n    return( (Image *) NULL);\n\n  /* Call the Interpolation function with the parsed arguments */\n  sparse_image=SparseColorImage(image,method,number_arguments,sparse_arguments,\n    exception);\n  sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n  return( sparse_image );\n}\n\nWandExport MagickBooleanType MogrifyImage(ImageInfo *image_info,const int argc,\n  const char **argv,Image **image,ExceptionInfo *exception)\n{\n  CompositeOperator\n    compose;\n\n  const char\n    *format,\n    *option;\n\n  double\n    attenuate;\n\n  DrawInfo\n    *draw_info;\n\n  GeometryInfo\n    geometry_info;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  PixelInfo\n    fill;\n\n  MagickStatusType\n    flags;\n\n  PixelInterpolateMethod\n    interpolate_method;\n\n  QuantizeInfo\n    *quantize_info;\n\n  RectangleInfo\n    geometry,\n    region_geometry;\n\n  register ssize_t\n    i;\n\n  /*\n    Initialize method variables.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  if (argc < 0)\n    return(MagickTrue);\n  mogrify_info=CloneImageInfo(image_info);\n  draw_info=CloneDrawInfo(mogrify_info,(DrawInfo *) NULL);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  SetGeometryInfo(&geometry_info);\n  GetPixelInfo(*image,&fill);\n  fill=(*image)->background_color;\n  attenuate=1.0;\n  compose=(*image)->compose;\n  interpolate_method=UndefinedInterpolatePixel;\n  format=GetImageOption(mogrify_info,\"format\");\n  SetGeometry(*image,&region_geometry);\n  /*\n    Transmogrify the image.\n  */\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    Image\n      *mogrify_image;\n\n    ssize_t\n      count;\n\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=MagickMax(ParseCommandOption(MagickCommandOptions,MagickFalse,option),\n      0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    mogrify_image=(Image *) NULL;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n          {\n            /*\n              Adaptive blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=AdaptiveBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n          {\n            /*\n              Adaptive resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=AdaptiveResizeImage(*image,geometry.width,\n              geometry.height,exception);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n          {\n            /*\n              Adaptive sharpen image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=AdaptiveSharpenImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"affine\",option+1) == 0)\n          {\n            /*\n              Affine matrix.\n            */\n            if (*option == '+')\n              {\n                GetAffineMatrix(&draw_info->affine);\n                break;\n              }\n            (void) ParseAffineGeometry(argv[i+1],&draw_info->affine,exception);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",option+1) == 0)\n          {\n            AlphaChannelOption\n              alpha_type;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            alpha_type=(AlphaChannelOption) ParseCommandOption(\n              MagickAlphaChannelOptions,MagickFalse,argv[i+1]);\n            (void) SetImageAlphaChannel(*image,alpha_type,exception);\n            break;\n          }\n        if (LocaleCompare(\"annotate\",option+1) == 0)\n          {\n            char\n              *text,\n              geometry_str[MagickPathExtent];\n\n            /*\n              Annotate image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            SetGeometryInfo(&geometry_info);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            text=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (text == (char *) NULL)\n              break;\n            (void) CloneString(&draw_info->text,text);\n            text=DestroyString(text);\n            (void) FormatLocaleString(geometry_str,MagickPathExtent,\"%+f%+f\",\n              geometry_info.xi,geometry_info.psi);\n            (void) CloneString(&draw_info->geometry,geometry_str);\n            draw_info->affine.sx=cos(DegreesToRadians(\n              fmod(geometry_info.rho,360.0)));\n            draw_info->affine.rx=sin(DegreesToRadians(\n              fmod(geometry_info.rho,360.0)));\n            draw_info->affine.ry=(-sin(DegreesToRadians(\n              fmod(geometry_info.sigma,360.0))));\n            draw_info->affine.sy=cos(DegreesToRadians(\n              fmod(geometry_info.sigma,360.0)));\n            (void) AnnotateImage(*image,draw_info,exception);\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          {\n            draw_info->stroke_antialias=(*option == '-') ? MagickTrue :\n              MagickFalse;\n            draw_info->text_antialias=(*option == '-') ? MagickTrue :\n              MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"attenuate\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                attenuate=1.0;\n                break;\n              }\n            attenuate=StringToDouble(argv[i+1],(char **) NULL);\n            break;\n          }\n        if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n          {\n            /*\n              Auto Adjust Gamma of image based on its mean\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) AutoGammaImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"auto-level\",option+1) == 0)\n          {\n            /*\n              Perfectly Normalize (max/min stretch) the image\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) AutoLevelImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"auto-orient\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=AutoOrientImage(*image,(*image)->orientation,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n          {\n            AutoThresholdMethod\n              method;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(AutoThresholdMethod) ParseCommandOption(\n              MagickAutoThresholdOptions,MagickFalse,argv[i+1]);\n            (void) AutoThresholdImage(*image,method,exception);\n            break;\n          }\n        break;\n      }\n      case 'b':\n      {\n        if (LocaleCompare(\"black-threshold\",option+1) == 0)\n          {\n            /*\n              Black threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) BlackThresholdImage(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"blue-shift\",option+1) == 0)\n          {\n            /*\n              Blue shift image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            geometry_info.rho=1.5;\n            if (*option == '-')\n              flags=ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=BlueShiftImage(*image,geometry_info.rho,exception);\n            break;\n          }\n        if (LocaleCompare(\"blur\",option+1) == 0)\n          {\n            /*\n              Gaussian blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.0;\n            mogrify_image=BlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"border\",option+1) == 0)\n          {\n            /*\n              Surround image with a border of solid color.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=BorderImage(*image,&geometry,compose,exception);\n            break;\n          }\n        if (LocaleCompare(\"bordercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n                  &draw_info->border_color,exception);\n                break;\n              }\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &draw_info->border_color,exception);\n            break;\n          }\n        if (LocaleCompare(\"box\",option+1) == 0)\n          {\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &draw_info->undercolor,exception);\n            break;\n          }\n        if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n          {\n            double\n              brightness,\n              contrast;\n\n            /*\n              Brightness / contrast image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            brightness=geometry_info.rho;\n            contrast=0.0;\n            if ((flags & SigmaValue) != 0)\n              contrast=geometry_info.sigma;\n            (void) BrightnessContrastImage(*image,brightness,contrast,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"canny\",option+1) == 0)\n          {\n            /*\n              Detect edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.10;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=0.30;\n            if ((flags & PercentValue) != 0)\n              {\n                geometry_info.xi/=100.0;\n                geometry_info.psi/=100.0;\n              }\n            mogrify_image=CannyEdgeImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n            break;\n          }\n        if (LocaleCompare(\"cdl\",option+1) == 0)\n          {\n            char\n              *color_correction_collection;\n\n            /*\n              Color correct with a color decision list.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            color_correction_collection=FileToString(argv[i+1],~0UL,exception);\n            if (color_correction_collection == (char *) NULL)\n              break;\n            (void) ColorDecisionListImage(*image,color_correction_collection,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ChannelType\n              channel;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetPixelChannelMask(*image,DefaultChannels);\n                break;\n              }\n            channel=(ChannelType) ParseChannelOption(argv[i+1]);\n            (void) SetPixelChannelMask(*image,channel);\n            break;\n          }\n        if (LocaleCompare(\"charcoal\",option+1) == 0)\n          {\n            /*\n              Charcoal image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=1.0;\n            mogrify_image=CharcoalImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"chop\",option+1) == 0)\n          {\n            /*\n              Chop the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ChopImage(*image,&geometry,exception);\n            break;\n          }\n        if (LocaleCompare(\"clahe\",option+1) == 0)\n          {\n            /*\n              Contrast limited adaptive histogram equalization.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            (void) CLAHEImage(*image,geometry.width,geometry.height,\n              (size_t) geometry.x,geometry_info.psi,exception);\n            break;\n          }\n        if (LocaleCompare(\"clip\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            (void) ClipImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"clip-mask\",option+1) == 0)\n          {\n            Image\n              *clip_mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            clip_mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (clip_mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,WritePixelMask,clip_mask,exception);\n            clip_mask=DestroyImage(clip_mask);\n            break;\n          }\n        if (LocaleCompare(\"clip-path\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ClipImagePath(*image,argv[i+1],*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"colorize\",option+1) == 0)\n          {\n            /*\n              Colorize the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=ColorizeImage(*image,argv[i+1],&fill,exception);\n            break;\n          }\n        if (LocaleCompare(\"color-matrix\",option+1) == 0)\n          {\n            KernelInfo\n              *kernel;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            kernel=AcquireKernelInfo(argv[i+1],exception);\n            if (kernel == (KernelInfo *) NULL)\n              break;\n            /* FUTURE: check on size of the matrix */\n            mogrify_image=ColorMatrixImage(*image,kernel,exception);\n            kernel=DestroyKernelInfo(kernel);\n            break;\n          }\n        if (LocaleCompare(\"colors\",option+1) == 0)\n          {\n            /*\n              Reduce the number of colors in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            quantize_info->number_colors=StringToUnsignedLong(argv[i+1]);\n            if (quantize_info->number_colors == 0)\n              break;\n            if (((*image)->storage_class == DirectClass) ||\n                (*image)->colors > quantize_info->number_colors)\n              (void) QuantizeImage(quantize_info,*image,exception);\n            else\n              (void) CompressImageColormap(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ColorspaceType\n              colorspace;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) TransformImageColorspace(*image,sRGBColorspace,\n                  exception);\n                break;\n              }\n            colorspace=(ColorspaceType) ParseCommandOption(\n              MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            (void) TransformImageColorspace(*image,colorspace,exception);\n            break;\n          }\n        if (LocaleCompare(\"compose\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"connected-components\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=ConnectedComponentsImage(*image,(size_t)\n              StringToInteger(argv[i+1]),(CCObjectInfo **) NULL,exception);\n            break;\n          }\n        if (LocaleCompare(\"contrast\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ContrastImage(*image,(*option == '-') ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n          {\n            double\n              black_point,\n              white_point;\n\n            /*\n              Contrast stretch image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            black_point=geometry_info.rho;\n            white_point=(flags & SigmaValue) != 0 ? geometry_info.sigma :\n              black_point;\n            if ((flags & PercentValue) != 0)\n              {\n                black_point*=(double) (*image)->columns*(*image)->rows/100.0;\n                white_point*=(double) (*image)->columns*(*image)->rows/100.0;\n              }\n            white_point=(double) (*image)->columns*(*image)->rows-\n              white_point;\n            (void) ContrastStretchImage(*image,black_point,white_point,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"convolve\",option+1) == 0)\n          {\n            double\n              gamma;\n\n            KernelInfo\n              *kernel_info;\n\n            register ssize_t\n              j;\n\n            size_t\n              extent;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            kernel_info=AcquireKernelInfo(argv[i+1],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              break;\n            extent=kernel_info->width*kernel_info->height;\n            gamma=0.0;\n            for (j=0; j < (ssize_t) extent; j++)\n              gamma+=kernel_info->values[j];\n            gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma);\n            for (j=0; j < (ssize_t) extent; j++)\n              kernel_info->values[j]*=gamma;\n            mogrify_image=MorphologyImage(*image,CorrelateMorphology,1,\n              kernel_info,exception);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"crop\",option+1) == 0)\n          {\n            /*\n              Crop a image to a smaller size\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=CropImageToTiles(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"cycle\",option+1) == 0)\n          {\n            /*\n              Cycle an image colormap.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) CycleColormapImage(*image,(ssize_t) StringToLong(argv[i+1]),\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"decipher\",option+1) == 0)\n          {\n            StringInfo\n              *passkey;\n\n            /*\n              Decipher pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            passkey=FileToStringInfo(argv[i+1],~0UL,exception);\n            if (passkey != (StringInfo *) NULL)\n              {\n                (void) PasskeyDecipherImage(*image,passkey,exception);\n                passkey=DestroyStringInfo(passkey);\n              }\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            /*\n              Set image density.\n            */\n            (void) CloneString(&draw_info->density,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetImageDepth(*image,MAGICKCORE_QUANTUM_DEPTH,exception);\n                break;\n              }\n            (void) SetImageDepth(*image,StringToUnsignedLong(argv[i+1]),\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"deskew\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            /*\n              Straighten the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              threshold=40.0*QuantumRange/100.0;\n            else\n              threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n                1.0);\n            mogrify_image=DeskewImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"despeckle\",option+1) == 0)\n          {\n            /*\n              Reduce the speckles within an image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=DespeckleImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"display\",option+1) == 0)\n          {\n            (void) CloneString(&draw_info->server_name,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"distort\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            DistortMethod\n              method;\n\n            double\n              *arguments;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            /*\n              Distort image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(DistortMethod) ParseCommandOption(MagickDistortOptions,\n              MagickFalse,argv[i+1]);\n            if (method == ResizeDistortion)\n              {\n                 double\n                   resize_args[2];\n\n                 /*\n                   Special Case - Argument is actually a resize geometry!\n                   Convert that to an appropriate distortion argument array.\n                 */\n                 (void) ParseRegionGeometry(*image,argv[i+2],&geometry,\n                   exception);\n                 resize_args[0]=(double) geometry.width;\n                 resize_args[1]=(double) geometry.height;\n                 mogrify_image=DistortImage(*image,method,(size_t)2,\n                   resize_args,MagickTrue,exception);\n                 break;\n              }\n            args=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*image)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            mogrify_image=DistortImage(*image,method,number_arguments,arguments,\n              (*option == '+') ? MagickTrue : MagickFalse,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither_method=NoDitherMethod;\n                break;\n              }\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"draw\",option+1) == 0)\n          {\n            /*\n              Draw image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) CloneString(&draw_info->primitive,argv[i+1]);\n            (void) DrawImage(*image,draw_info,exception);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"edge\",option+1) == 0)\n          {\n            /*\n              Enhance edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=EdgeImage(*image,geometry_info.rho,exception);\n            break;\n          }\n        if (LocaleCompare(\"emboss\",option+1) == 0)\n          {\n            /*\n              Emboss image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=EmbossImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"encipher\",option+1) == 0)\n          {\n            StringInfo\n              *passkey;\n\n            /*\n              Encipher pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            passkey=FileToStringInfo(argv[i+1],~0UL,exception);\n            if (passkey != (StringInfo *) NULL)\n              {\n                (void) PasskeyEncipherImage(*image,passkey,exception);\n                passkey=DestroyStringInfo(passkey);\n              }\n            break;\n          }\n        if (LocaleCompare(\"encoding\",option+1) == 0)\n          {\n            (void) CloneString(&draw_info->encoding,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"enhance\",option+1) == 0)\n          {\n            /*\n              Enhance image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=EnhanceImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"equalize\",option+1) == 0)\n          {\n            /*\n              Equalize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) EqualizeImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"evaluate\",option+1) == 0)\n          {\n            double\n              constant;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            constant=StringToDoubleInterval(argv[i+2],(double) QuantumRange+\n              1.0);\n            (void) EvaluateImage(*image,op,constant,exception);\n            break;\n          }\n        if (LocaleCompare(\"extent\",option+1) == 0)\n          {\n            /*\n              Set the image extent.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            if (geometry.width == 0)\n              geometry.width=(*image)->columns;\n            if (geometry.height == 0)\n              geometry.height=(*image)->rows;\n            mogrify_image=ExtentImage(*image,&geometry,exception);\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"family\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (draw_info->family != (char *) NULL)\n                  draw_info->family=DestroyString(draw_info->family);\n                break;\n              }\n            (void) CloneString(&draw_info->family,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"features\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageArtifact(*image,\"identify:features\");\n                break;\n              }\n            (void) SetImageArtifact(*image,\"identify:features\",argv[i+1]);\n            (void) SetImageArtifact(*image,\"verbose\",\"true\");\n            break;\n          }\n        if (LocaleCompare(\"fill\",option+1) == 0)\n          {\n            ExceptionInfo\n              *sans;\n\n            PixelInfo\n              color;\n\n            GetPixelInfo(*image,&fill);\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(\"none\",AllCompliance,&fill,\n                  exception);\n                draw_info->fill=fill;\n                if (draw_info->fill_pattern != (Image *) NULL)\n                  draw_info->fill_pattern=DestroyImage(draw_info->fill_pattern);\n                break;\n              }\n            sans=AcquireExceptionInfo();\n            status=QueryColorCompliance(argv[i+1],AllCompliance,&color,sans);\n            sans=DestroyExceptionInfo(sans);\n            if (status == MagickFalse)\n              draw_info->fill_pattern=GetImageCache(mogrify_info,argv[i+1],\n                exception);\n            else\n              draw_info->fill=fill=color;\n            break;\n          }\n        if (LocaleCompare(\"flip\",option+1) == 0)\n          {\n            /*\n              Flip image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=FlipImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"floodfill\",option+1) == 0)\n          {\n            PixelInfo\n              target;\n\n            /*\n              Floodfill image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            (void) QueryColorCompliance(argv[i+2],AllCompliance,&target,\n              exception);\n            (void) FloodfillPaintImage(*image,draw_info,&target,geometry.x,\n              geometry.y,*option == '-' ? MagickFalse : MagickTrue,exception);\n            break;\n          }\n        if (LocaleCompare(\"flop\",option+1) == 0)\n          {\n            /*\n              Flop image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=FlopImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"font\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (draw_info->font != (char *) NULL)\n                  draw_info->font=DestroyString(draw_info->font);\n                break;\n              }\n            (void) CloneString(&draw_info->font,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            format=argv[i+1];\n            break;\n          }\n        if (LocaleCompare(\"frame\",option+1) == 0)\n          {\n            FrameInfo\n              frame_info;\n\n            /*\n              Surround image with an ornamental border.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            frame_info.width=geometry.width;\n            frame_info.height=geometry.height;\n            frame_info.outer_bevel=geometry.x;\n            frame_info.inner_bevel=geometry.y;\n            frame_info.x=(ssize_t) frame_info.width;\n            frame_info.y=(ssize_t) frame_info.height;\n            frame_info.width=(*image)->columns+2*frame_info.width;\n            frame_info.height=(*image)->rows+2*frame_info.height;\n            mogrify_image=FrameImage(*image,&frame_info,compose,exception);\n            break;\n          }\n        if (LocaleCompare(\"function\",option+1) == 0)\n          {\n            char\n              *arguments,\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            double\n              *parameters;\n\n            MagickFunction\n              function;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_parameters;\n\n            /*\n              Function Modify Image Values\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            function=(MagickFunction) ParseCommandOption(MagickFunctionOptions,\n              MagickFalse,argv[i+1]);\n            arguments=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (arguments == (char *) NULL)\n              break;\n            p=(char *) arguments;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n            }\n            number_parameters=(size_t) x;\n            parameters=(double *) AcquireQuantumMemory(number_parameters,\n              sizeof(*parameters));\n            if (parameters == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*image)->filename);\n            (void) memset(parameters,0,number_parameters*\n              sizeof(*parameters));\n            p=(char *) arguments;\n            for (x=0; (x < (ssize_t) number_parameters) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n              parameters[x]=StringToDouble(token,(char **) NULL);\n            }\n            arguments=DestroyString(arguments);\n            (void) FunctionImage(*image,function,number_parameters,parameters,\n              exception);\n            parameters=(double *) RelinquishMagickMemory(parameters);\n            break;\n          }\n        break;\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gamma\",option+1) == 0)\n          {\n            /*\n              Gamma image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              (*image)->gamma=StringToDouble(argv[i+1],(char **) NULL);\n            else\n              (void) GammaImage(*image,StringToDouble(argv[i+1],(char **) NULL),\n                exception);\n            break;\n          }\n        if ((LocaleCompare(\"gaussian-blur\",option+1) == 0) ||\n            (LocaleCompare(\"gaussian\",option+1) == 0))\n          {\n            /*\n              Gaussian blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=GaussianBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"geometry\",option+1) == 0)\n          {\n              /*\n                Record Image offset, Resize last image.\n              */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                if ((*image)->geometry != (char *) NULL)\n                  (*image)->geometry=DestroyString((*image)->geometry);\n                break;\n              }\n            flags=ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n              (void) CloneString(&(*image)->geometry,argv[i+1]);\n            else\n              mogrify_image=ResizeImage(*image,geometry.width,geometry.height,\n                (*image)->filter,exception);\n            break;\n          }\n        if (LocaleCompare(\"gravity\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                draw_info->gravity=UndefinedGravity;\n                break;\n              }\n            draw_info->gravity=(GravityType) ParseCommandOption(\n              MagickGravityOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"grayscale\",option+1) == 0)\n          {\n            PixelIntensityMethod\n              method;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(PixelIntensityMethod) ParseCommandOption(\n              MagickPixelIntensityOptions,MagickFalse,argv[i+1]);\n            (void) GrayscaleImage(*image,method,exception);\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"highlight-color\",option+1) == 0)\n          {\n            (void) SetImageArtifact(*image,\"compare:highlight-color\",argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"hough-lines\",option+1) == 0)\n          {\n            /*\n              Detect edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=40;\n            mogrify_image=HoughLineImage(*image,(size_t) geometry_info.rho,\n              (size_t) geometry_info.sigma,(size_t) geometry_info.xi,exception);\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"identify\",option+1) == 0)\n          {\n            char\n              *text;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (format == (char *) NULL)\n              {\n                (void) IdentifyImage(*image,stdout,mogrify_info->verbose,\n                  exception);\n                break;\n              }\n            text=InterpretImageProperties(mogrify_info,*image,format,\n              exception);\n            if (text == (char *) NULL)\n              break;\n            (void) fputs(text,stdout);\n            text=DestroyString(text);\n            break;\n          }\n        if (LocaleCompare(\"implode\",option+1) == 0)\n          {\n            /*\n              Implode image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=ImplodeImage(*image,geometry_info.rho,\n              interpolate_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"0\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->interline_spacing=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            interpolate_method=(PixelInterpolateMethod) ParseCommandOption(\n              MagickInterpolateOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"0\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->interword_spacing=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"interpolative-resize\",option+1) == 0)\n          {\n            /*\n              Interpolative resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=InterpolativeResizeImage(*image,geometry.width,\n              geometry.height,interpolate_method,exception);\n            break;\n          }\n        break;\n      }\n      case 'k':\n      {\n        if (LocaleCompare(\"kerning\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"0\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->kerning=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"kuwahara\",option+1) == 0)\n          {\n            /*\n              Edge preserving blur.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho-0.5;\n            mogrify_image=KuwaharaImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"lat\",option+1) == 0)\n          {\n            /*\n              Local adaptive threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & PercentValue) != 0)\n              geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n            mogrify_image=AdaptiveThresholdImage(*image,(size_t)\n              geometry_info.rho,(size_t) geometry_info.sigma,(double)\n              geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"level\",option+1) == 0)\n          {\n            double\n              black_point,\n              gamma,\n              white_point;\n\n            /*\n              Parse levels.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            black_point=geometry_info.rho;\n            white_point=(double) QuantumRange;\n            if ((flags & SigmaValue) != 0)\n              white_point=geometry_info.sigma;\n            gamma=1.0;\n            if ((flags & XiValue) != 0)\n              gamma=geometry_info.xi;\n            if ((flags & PercentValue) != 0)\n              {\n                black_point*=(double) (QuantumRange/100.0);\n                white_point*=(double) (QuantumRange/100.0);\n              }\n            if ((flags & SigmaValue) == 0)\n              white_point=(double) QuantumRange-black_point;\n            if ((*option == '+') || ((flags & AspectValue) != 0))\n              (void) LevelizeImage(*image,black_point,white_point,gamma,\n                exception);\n            else\n              (void) LevelImage(*image,black_point,white_point,gamma,\n                exception);\n            break;\n          }\n        if (LocaleCompare(\"level-colors\",option+1) == 0)\n          {\n            char\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            PixelInfo\n              black_point,\n              white_point;\n\n            p=(const char *) argv[i+1];\n            GetNextToken(p,&p,MagickPathExtent,token);  /* get black point color */\n            if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n              (void) QueryColorCompliance(token,AllCompliance,\n                &black_point,exception);\n            else\n              (void) QueryColorCompliance(\"#000000\",AllCompliance,\n                &black_point,exception);\n            if (isalpha((int) token[0]) || (token[0] == '#'))\n              GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == '\\0')\n              white_point=black_point; /* set everything to that color */\n            else\n              {\n                if ((isalpha((int) *token) == 0) && ((*token == '#') == 0))\n                  GetNextToken(p,&p,MagickPathExtent,token); /* Get white point color. */\n                if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n                  (void) QueryColorCompliance(token,AllCompliance,\n                    &white_point,exception);\n                else\n                  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,\n                    &white_point,exception);\n              }\n            (void) LevelImageColors(*image,&black_point,&white_point,\n              *option == '+' ? MagickTrue : MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"linear-stretch\",option+1) == 0)\n          {\n            double\n              black_point,\n              white_point;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            black_point=geometry_info.rho;\n            white_point=(double) (*image)->columns*(*image)->rows;\n            if ((flags & SigmaValue) != 0)\n              white_point=geometry_info.sigma;\n            if ((flags & PercentValue) != 0)\n              {\n                black_point*=(double) (*image)->columns*(*image)->rows/100.0;\n                white_point*=(double) (*image)->columns*(*image)->rows/100.0;\n              }\n            if ((flags & SigmaValue) == 0)\n              white_point=(double) (*image)->columns*(*image)->rows-\n                black_point;\n            (void) LinearStretchImage(*image,black_point,white_point,exception);\n            break;\n          }\n        if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n          {\n            /*\n              Liquid rescale image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            if ((flags & XValue) == 0)\n              geometry.x=1;\n            if ((flags & YValue) == 0)\n              geometry.y=0;\n            mogrify_image=LiquidRescaleImage(*image,geometry.width,\n              geometry.height,1.0*geometry.x,1.0*geometry.y,exception);\n            break;\n          }\n        if (LocaleCompare(\"local-contrast\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & RhoValue) == 0)\n              geometry_info.rho=10;\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=12.5;\n            mogrify_image=LocalContrastImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"lowlight-color\",option+1) == 0)\n          {\n            (void) SetImageArtifact(*image,\"compare:lowlight-color\",argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"magnify\",option+1) == 0)\n          {\n            /*\n              Double image size.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=MagnifyImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            Image\n              *remap_image;\n\n            /*\n              Transform image colors to match this set of colors.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              break;\n            remap_image=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (remap_image == (Image *) NULL)\n              break;\n            (void) RemapImage(quantize_info,*image,remap_image,exception);\n            remap_image=DestroyImage(remap_image);\n            break;\n          }\n        if (LocaleCompare(\"mask\",option+1) == 0)\n          {\n            Image\n              *mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,WritePixelMask,mask,exception);\n            mask=DestroyImage(mask);\n            break;\n          }\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          {\n            (void) SetImageAlphaChannel(*image,(*option == '-') ?\n              SetAlphaChannel : DeactivateAlphaChannel,exception);\n            break;\n          }\n        if (LocaleCompare(\"mean-shift\",option+1) == 0)\n          {\n            /*\n              Detect edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.10*QuantumRange;\n            if ((flags & PercentValue) != 0)\n              geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n            mogrify_image=MeanShiftImage(*image,(size_t) geometry_info.rho,\n              (size_t) geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"median\",option+1) == 0)\n          {\n            /*\n              Median filter image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=StatisticImage(*image,MedianStatistic,(size_t)\n              geometry_info.rho,(size_t) geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"mode\",option+1) == 0)\n          {\n            /*\n              Mode image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=StatisticImage(*image,ModeStatistic,(size_t)\n              geometry_info.rho,(size_t) geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"modulate\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ModulateImage(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"moments\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageArtifact(*image,\"identify:moments\");\n                break;\n              }\n            (void) SetImageArtifact(*image,\"identify:moments\",argv[i+1]);\n            (void) SetImageArtifact(*image,\"verbose\",\"true\");\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageProgressMonitor(*image,\n                  (MagickProgressMonitor) NULL,(void *) NULL);\n                break;\n              }\n            (void) SetImageProgressMonitor(*image,MonitorProgress,\n              (void *) NULL);\n            break;\n          }\n        if (LocaleCompare(\"monochrome\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) SetImageType(*image,BilevelType,exception);\n            break;\n          }\n        if (LocaleCompare(\"morphology\",option+1) == 0)\n          {\n            char\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            KernelInfo\n              *kernel;\n\n            MorphologyMethod\n              method;\n\n            ssize_t\n              iterations;\n\n            /*\n              Morphological Image Operation\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            p=argv[i+1];\n            GetNextToken(p,&p,MagickPathExtent,token);\n            method=(MorphologyMethod) ParseCommandOption(\n              MagickMorphologyOptions,MagickFalse,token);\n            iterations=1L;\n            GetNextToken(p,&p,MagickPathExtent,token);\n            if ((*p == ':') || (*p == ','))\n              GetNextToken(p,&p,MagickPathExtent,token);\n            if ((*p != '\\0'))\n              iterations=(ssize_t) StringToLong(p);\n            kernel=AcquireKernelInfo(argv[i+2],exception);\n            if (kernel == (KernelInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"UnabletoParseKernel\",\"morphology\");\n                status=MagickFalse;\n                break;\n              }\n            mogrify_image=MorphologyImage(*image,method,iterations,kernel,\n              exception);\n            kernel=DestroyKernelInfo(kernel);\n            break;\n          }\n        if (LocaleCompare(\"motion-blur\",option+1) == 0)\n          {\n            /*\n              Motion blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=MotionBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        break;\n      }\n      case 'n':\n      {\n        if (LocaleCompare(\"negate\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) NegateImage(*image,*option == '+' ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"noise\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '-')\n              {\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                mogrify_image=StatisticImage(*image,NonpeakStatistic,(size_t)\n                  geometry_info.rho,(size_t) geometry_info.sigma,exception);\n              }\n            else\n              {\n                NoiseType\n                  noise;\n\n                noise=(NoiseType) ParseCommandOption(MagickNoiseOptions,\n                  MagickFalse,argv[i+1]);\n                mogrify_image=AddNoiseImage(*image,noise,attenuate,exception);\n              }\n            break;\n          }\n        if (LocaleCompare(\"normalize\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) NormalizeImage(*image,exception);\n            break;\n          }\n        break;\n      }\n      case 'o':\n      {\n        if (LocaleCompare(\"opaque\",option+1) == 0)\n          {\n            PixelInfo\n              target;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,&target,\n              exception);\n            (void) OpaquePaintImage(*image,&target,&fill,*option == '-' ?\n              MagickFalse : MagickTrue,exception);\n            break;\n          }\n        if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) OrderedDitherImage(*image,argv[i+1],exception);\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"paint\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=OilPaintImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"perceptible\",option+1) == 0)\n          {\n            /*\n              Perceptible image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) PerceptibleImage(*image,StringToDouble(argv[i+1],\n              (char **) NULL),exception);\n            break;\n          }\n        if (LocaleCompare(\"pointsize\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"12\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->pointsize=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"polaroid\",option+1) == 0)\n          {\n            const char\n              *caption;\n\n            double\n              angle;\n\n            RandomInfo\n              *random_info;\n\n            /*\n              Simulate a Polaroid picture.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            random_info=AcquireRandomInfo();\n            angle=22.5*(GetPseudoRandomValue(random_info)-0.5);\n            random_info=DestroyRandomInfo(random_info);\n            if (*option == '-')\n              {\n                SetGeometryInfo(&geometry_info);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                angle=geometry_info.rho;\n              }\n            caption=GetImageProperty(*image,\"caption\",exception);\n            mogrify_image=PolaroidImage(*image,draw_info,caption,angle,\n              interpolate_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"posterize\",option+1) == 0)\n          {\n            /*\n              Posterize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) PosterizeImage(*image,StringToUnsignedLong(argv[i+1]),\n              quantize_info->dither_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"preview\",option+1) == 0)\n          {\n            PreviewType\n              preview_type;\n\n            /*\n              Preview image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              preview_type=UndefinedPreview;\n            else\n              preview_type=(PreviewType) ParseCommandOption(\n                MagickPreviewOptions,MagickFalse,argv[i+1]);\n            mogrify_image=PreviewImage(*image,preview_type,exception);\n            break;\n          }\n        if (LocaleCompare(\"profile\",option+1) == 0)\n          {\n            const char\n              *name;\n\n            const StringInfo\n              *profile;\n\n            Image\n              *profile_image;\n\n            ImageInfo\n              *profile_info;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a profile from the image.\n                */\n                (void) ProfileImage(*image,argv[i+1],(const unsigned char *)\n                  NULL,0,exception);\n                break;\n              }\n            /*\n              Associate a profile with the image.\n            */\n            profile_info=CloneImageInfo(mogrify_info);\n            profile=GetImageProfile(*image,\"iptc\");\n            if (profile != (StringInfo *) NULL)\n              profile_info->profile=(void *) CloneStringInfo(profile);\n            profile_image=GetImageCache(profile_info,argv[i+1],exception);\n            profile_info=DestroyImageInfo(profile_info);\n            if (profile_image == (Image *) NULL)\n              {\n                StringInfo\n                  *file_data;\n\n                profile_info=CloneImageInfo(mogrify_info);\n                (void) CopyMagickString(profile_info->filename,argv[i+1],\n                  MagickPathExtent);\n                file_data=FileToStringInfo(profile_info->filename,~0UL,\n                  exception);\n                if (file_data != (StringInfo *) NULL)\n                  {\n                    (void) SetImageInfo(profile_info,0,exception);\n                    (void) ProfileImage(*image,profile_info->magick,\n                      GetStringInfoDatum(file_data),\n                      GetStringInfoLength(file_data),exception);\n                    file_data=DestroyStringInfo(file_data);\n                  }\n                profile_info=DestroyImageInfo(profile_info);\n                break;\n              }\n            ResetImageProfileIterator(profile_image);\n            name=GetNextImageProfile(profile_image);\n            while (name != (const char *) NULL)\n            {\n              profile=GetImageProfile(profile_image,name);\n              if (profile != (StringInfo *) NULL)\n                (void) ProfileImage(*image,name,GetStringInfoDatum(profile),\n                  (size_t) GetStringInfoLength(profile),exception);\n              name=GetNextImageProfile(profile_image);\n            }\n            profile_image=DestroyImage(profile_image);\n            break;\n          }\n        break;\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quantize\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->colorspace=UndefinedColorspace;\n                break;\n              }\n            quantize_info->colorspace=(ColorspaceType) ParseCommandOption(\n              MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n          {\n            /*\n              Rotational blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=RotationalBlurImage(*image,geometry_info.rho,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"raise\",option+1) == 0)\n          {\n            /*\n              Surround image with a raise of solid color.\n            */\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            (void) RaiseImage(*image,&geometry,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"random-threshold\",option+1) == 0)\n          {\n            /*\n              Random threshold image.\n            */\n            double\n              min_threshold,\n              max_threshold;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            min_threshold=0.0;\n            max_threshold=(double) QuantumRange;\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            min_threshold=geometry_info.rho;\n            max_threshold=geometry_info.sigma;\n            if ((flags & SigmaValue) == 0)\n              max_threshold=min_threshold;\n            if (strchr(argv[i+1],'%') != (char *) NULL)\n              {\n                max_threshold*=(double) (0.01*QuantumRange);\n                min_threshold*=(double) (0.01*QuantumRange);\n              }\n            (void) RandomThresholdImage(*image,min_threshold,max_threshold,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"range-threshold\",option+1) == 0)\n          {\n            /*\n              Range threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=geometry_info.sigma;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=geometry_info.xi;\n            if (strchr(argv[i+1],'%') != (char *) NULL)\n              {\n                geometry_info.rho*=(double) (0.01*QuantumRange);\n                geometry_info.sigma*=(double) (0.01*QuantumRange);\n                geometry_info.xi*=(double) (0.01*QuantumRange);\n                geometry_info.psi*=(double) (0.01*QuantumRange);\n              }\n            (void) RangeThresholdImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n            break;\n          }\n        if (LocaleCompare(\"read-mask\",option+1) == 0)\n          {\n            Image\n              *mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,ReadPixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,ReadPixelMask,mask,exception);\n            mask=DestroyImage(mask);\n            break;\n          }\n        if (LocaleCompare(\"region\",option+1) == 0)\n          {\n            /*\n              Apply read mask as defined by a region geometry.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetImageRegionMask(*image,WritePixelMask,\n                  (const RectangleInfo *) NULL,exception);\n                break;\n              }\n            (void) ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            (void) SetImageRegionMask(*image,WritePixelMask,&geometry,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"render\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            draw_info->render=(*option == '+') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"remap\",option+1) == 0)\n          {\n            Image\n              *remap_image;\n\n            /*\n              Transform image colors to match this set of colors.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              break;\n            remap_image=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (remap_image == (Image *) NULL)\n              break;\n            (void) RemapImage(quantize_info,*image,remap_image,exception);\n            remap_image=DestroyImage(remap_image);\n            break;\n          }\n        if (LocaleCompare(\"repage\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) ParseAbsoluteGeometry(\"0x0+0+0\",&(*image)->page);\n                break;\n              }\n            (void) ResetImagePage(*image,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"resample\",option+1) == 0)\n          {\n            /*\n              Resample image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=ResampleImage(*image,geometry_info.rho,\n              geometry_info.sigma,(*image)->filter,exception);\n            break;\n          }\n        if (LocaleCompare(\"resize\",option+1) == 0)\n          {\n            /*\n              Resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ResizeImage(*image,geometry.width,geometry.height,\n              (*image)->filter,exception);\n            break;\n          }\n        if (LocaleCompare(\"roll\",option+1) == 0)\n          {\n            /*\n              Roll image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            if ((flags & PercentValue) != 0)\n              {\n                geometry.x*=(double) (*image)->columns/100.0;\n                geometry.y*=(double) (*image)->rows/100.0;\n              }\n            mogrify_image=RollImage(*image,geometry.x,geometry.y,exception);\n            break;\n          }\n        if (LocaleCompare(\"rotate\",option+1) == 0)\n          {\n            char\n              *rotation;\n\n            /*\n              Check for conditional image rotation.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (strchr(argv[i+1],'>') != (char *) NULL)\n              if ((*image)->columns <= (*image)->rows)\n                break;\n            if (strchr(argv[i+1],'<') != (char *) NULL)\n              if ((*image)->columns >= (*image)->rows)\n                break;\n            /*\n              Rotate image.\n            */\n            rotation=ConstantString(argv[i+1]);\n            (void) SubstituteString(&rotation,\">\",\"\");\n            (void) SubstituteString(&rotation,\"<\",\"\");\n            (void) ParseGeometry(rotation,&geometry_info);\n            rotation=DestroyString(rotation);\n            mogrify_image=RotateImage(*image,geometry_info.rho,exception);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sample\",option+1) == 0)\n          {\n            /*\n              Sample image with pixel replication.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=SampleImage(*image,geometry.width,geometry.height,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"scale\",option+1) == 0)\n          {\n            /*\n              Resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ScaleImage(*image,geometry.width,geometry.height,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"selective-blur\",option+1) == 0)\n          {\n            /*\n              Selectively blur pixels within a contrast threshold.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & PercentValue) != 0)\n              geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n            mogrify_image=SelectiveBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"separate\",option+1) == 0)\n          {\n            /*\n              Break channels into separate images.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=SeparateImages(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            /*\n              Sepia-tone image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n              1.0);\n            mogrify_image=SepiaToneImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"segment\",option+1) == 0)\n          {\n            /*\n              Segment image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            (void) SegmentImage(*image,(*image)->colorspace,\n              mogrify_info->verbose,geometry_info.rho,geometry_info.sigma,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            char\n              *value;\n\n            /*\n              Set image option.\n            */\n            if (*option == '+')\n              {\n                if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n                  (void) DeleteImageRegistry(argv[i+1]+9);\n                else\n                  if (LocaleNCompare(argv[i+1],\"option:\",7) == 0)\n                    {\n                      (void) DeleteImageOption(mogrify_info,argv[i+1]+7);\n                      (void) DeleteImageArtifact(*image,argv[i+1]+7);\n                    }\n                  else\n                    (void) DeleteImageProperty(*image,argv[i+1]);\n                break;\n              }\n            value=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (value == (char *) NULL)\n              break;\n            if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n              (void) SetImageRegistry(StringRegistryType,argv[i+1]+9,value,\n                exception);\n            else\n              if (LocaleNCompare(argv[i+1],\"option:\",7) == 0)\n                {\n                  (void) SetImageOption(image_info,argv[i+1]+7,value);\n                  (void) SetImageOption(mogrify_info,argv[i+1]+7,value);\n                  (void) SetImageArtifact(*image,argv[i+1]+7,value);\n                }\n              else\n                (void) SetImageProperty(*image,argv[i+1],value,exception);\n            value=DestroyString(value);\n            break;\n          }\n        if (LocaleCompare(\"shade\",option+1) == 0)\n          {\n            /*\n              Shade image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=ShadeImage(*image,(*option == '-') ? MagickTrue :\n              MagickFalse,geometry_info.rho,geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"shadow\",option+1) == 0)\n          {\n            /*\n              Shadow image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=4.0;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=4.0;\n            mogrify_image=ShadowImage(*image,geometry_info.rho,\n              geometry_info.sigma,(ssize_t) ceil(geometry_info.xi-0.5),\n              (ssize_t) ceil(geometry_info.psi-0.5),exception);\n            break;\n          }\n        if (LocaleCompare(\"sharpen\",option+1) == 0)\n          {\n            /*\n              Sharpen image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.0;\n            mogrify_image=SharpenImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"shave\",option+1) == 0)\n          {\n            /*\n              Shave the image edges.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ShaveImage(*image,&geometry,exception);\n            break;\n          }\n        if (LocaleCompare(\"shear\",option+1) == 0)\n          {\n            /*\n              Shear image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=ShearImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n          {\n            /*\n              Sigmoidal non-linearity contrast control.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=(double) QuantumRange/2.0;\n            if ((flags & PercentValue) != 0)\n              geometry_info.sigma=(double) QuantumRange*geometry_info.sigma/\n                100.0;\n            (void) SigmoidalContrastImage(*image,(*option == '-') ?\n              MagickTrue : MagickFalse,geometry_info.rho,geometry_info.sigma,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"sketch\",option+1) == 0)\n          {\n            /*\n              Sketch image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=SketchImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"solarize\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n              1.0);\n            (void) SolarizeImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"sparse-color\",option+1) == 0)\n          {\n            SparseColorMethod\n              method;\n\n            char\n              *arguments;\n\n            /*\n              Sparse Color Interpolated Gradient\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(SparseColorMethod) ParseCommandOption(\n              MagickSparseColorOptions,MagickFalse,argv[i+1]);\n            arguments=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (arguments == (char *) NULL)\n              break;\n            mogrify_image=SparseColorOption(*image,method,arguments,\n              option[0] == '+' ? MagickTrue : MagickFalse,exception);\n            arguments=DestroyString(arguments);\n            break;\n          }\n        if (LocaleCompare(\"splice\",option+1) == 0)\n          {\n            /*\n              Splice a solid color into the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=SpliceImage(*image,&geometry,exception);\n            break;\n          }\n        if (LocaleCompare(\"spread\",option+1) == 0)\n          {\n            /*\n              Spread an image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=SpreadImage(*image,interpolate_method,\n              geometry_info.rho,exception);\n            break;\n          }\n        if (LocaleCompare(\"statistic\",option+1) == 0)\n          {\n            StatisticType\n              type;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            type=(StatisticType) ParseCommandOption(MagickStatisticOptions,\n              MagickFalse,argv[i+1]);\n            (void) ParseGeometry(argv[i+2],&geometry_info);\n            mogrify_image=StatisticImage(*image,type,(size_t) geometry_info.rho,\n              (size_t) geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"stretch\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                draw_info->stretch=UndefinedStretch;\n                break;\n              }\n            draw_info->stretch=(StretchType) ParseCommandOption(\n              MagickStretchOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"strip\",option+1) == 0)\n          {\n            /*\n              Strip image of profiles and comments.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) StripImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",option+1) == 0)\n          {\n            ExceptionInfo\n              *sans;\n\n            PixelInfo\n              color;\n\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(\"none\",AllCompliance,\n                  &draw_info->stroke,exception);\n                if (draw_info->stroke_pattern != (Image *) NULL)\n                  draw_info->stroke_pattern=DestroyImage(\n                    draw_info->stroke_pattern);\n                break;\n              }\n            sans=AcquireExceptionInfo();\n            status=QueryColorCompliance(argv[i+1],AllCompliance,&color,sans);\n            sans=DestroyExceptionInfo(sans);\n            if (status == MagickFalse)\n              draw_info->stroke_pattern=GetImageCache(mogrify_info,argv[i+1],\n                exception);\n            else\n              draw_info->stroke=color;\n            break;\n          }\n        if (LocaleCompare(\"strokewidth\",option+1) == 0)\n          {\n            draw_info->stroke_width=StringToDouble(argv[i+1],(char **) NULL);\n            break;\n          }\n        if (LocaleCompare(\"style\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                draw_info->style=UndefinedStyle;\n                break;\n              }\n            draw_info->style=(StyleType) ParseCommandOption(MagickStyleOptions,\n              MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"swirl\",option+1) == 0)\n          {\n            /*\n              Swirl image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=SwirlImage(*image,geometry_info.rho,\n              interpolate_method,exception);\n            break;\n          }\n        break;\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"threshold\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            /*\n              Threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              threshold=(double) QuantumRange/2;\n            else\n              threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n                1.0);\n            (void) BilevelImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"thumbnail\",option+1) == 0)\n          {\n            /*\n              Thumbnail image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ThumbnailImage(*image,geometry.width,geometry.height,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"tile\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (draw_info->fill_pattern != (Image *) NULL)\n                  draw_info->fill_pattern=DestroyImage(draw_info->fill_pattern);\n                break;\n              }\n            draw_info->fill_pattern=GetImageCache(mogrify_info,argv[i+1],\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"tint\",option+1) == 0)\n          {\n            /*\n              Tint the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TintImage(*image,argv[i+1],&fill,exception);\n            break;\n          }\n        if (LocaleCompare(\"transform\",option+1) == 0)\n          {\n            /*\n              Affine transform image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=AffineTransformImage(*image,&draw_info->affine,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"transparent\",option+1) == 0)\n          {\n            PixelInfo\n              target;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,&target,\n              exception);\n            (void) TransparentPaintImage(*image,&target,(Quantum)\n              TransparentAlpha,*option == '-' ? MagickFalse : MagickTrue,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"transpose\",option+1) == 0)\n          {\n            /*\n              Transpose image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TransposeImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"transverse\",option+1) == 0)\n          {\n            /*\n              Transverse image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TransverseImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"treedepth\",option+1) == 0)\n          {\n            quantize_info->tree_depth=StringToUnsignedLong(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"trim\",option+1) == 0)\n          {\n            /*\n              Trim image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TrimImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"type\",option+1) == 0)\n          {\n            ImageType\n              type;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              type=UndefinedType;\n            else\n              type=(ImageType) ParseCommandOption(MagickTypeOptions,MagickFalse,\n                argv[i+1]);\n            (*image)->type=UndefinedType;\n            (void) SetImageType(*image,type,exception);\n            break;\n          }\n        break;\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"undercolor\",option+1) == 0)\n          {\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &draw_info->undercolor,exception);\n            break;\n          }\n        if (LocaleCompare(\"unique\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageArtifact(*image,\"identify:unique-colors\");\n                break;\n              }\n            (void) SetImageArtifact(*image,\"identify:unique-colors\",\"true\");\n            (void) SetImageArtifact(*image,\"verbose\",\"true\");\n            break;\n          }\n        if (LocaleCompare(\"unique-colors\",option+1) == 0)\n          {\n            /*\n              Unique image colors.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=UniqueImageColors(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"unsharp\",option+1) == 0)\n          {\n            /*\n              Unsharp mask image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=1.0;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=0.05;\n            mogrify_image=UnsharpMaskImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,geometry_info.psi,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            (void) SetImageArtifact(*image,option+1,\n              *option == '+' ? \"false\" : \"true\");\n            break;\n          }\n        if (LocaleCompare(\"vignette\",option+1) == 0)\n          {\n            /*\n              Vignette image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.1*(*image)->columns;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=0.1*(*image)->rows;\n            if ((flags & PercentValue) != 0)\n              {\n                geometry_info.xi*=(double) (*image)->columns/100.0;\n                geometry_info.psi*=(double) (*image)->rows/100.0;\n              }\n            mogrify_image=VignetteImage(*image,geometry_info.rho,\n              geometry_info.sigma,(ssize_t) ceil(geometry_info.xi-0.5),\n              (ssize_t) ceil(geometry_info.psi-0.5),exception);\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageVirtualPixelMethod(*image,\n                  UndefinedVirtualPixelMethod,exception);\n                break;\n              }\n            (void) SetImageVirtualPixelMethod(*image,(VirtualPixelMethod)\n              ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i+1]),exception);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"wave\",option+1) == 0)\n          {\n            /*\n              Wave image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=WaveImage(*image,geometry_info.rho,\n              geometry_info.sigma,interpolate_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n          {\n            /*\n              Wavelet denoise image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & PercentValue) != 0)\n              {\n                geometry_info.rho=QuantumRange*geometry_info.rho/100.0;\n                geometry_info.sigma=QuantumRange*geometry_info.sigma/100.0;\n              }\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=0.0;\n            mogrify_image=WaveletDenoiseImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"weight\",option+1) == 0)\n          {\n            ssize_t\n              weight;\n\n            weight=ParseCommandOption(MagickWeightOptions,MagickFalse,\n              argv[i+1]);\n            if (weight == -1)\n              weight=(ssize_t) StringToUnsignedLong(argv[i+1]);\n            draw_info->weight=(size_t) weight;\n            break;\n          }\n        if (LocaleCompare(\"white-threshold\",option+1) == 0)\n          {\n            /*\n              White threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) WhiteThresholdImage(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"write-mask\",option+1) == 0)\n          {\n            Image\n              *mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,WritePixelMask,mask,exception);\n            mask=DestroyImage(mask);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    /*\n       Replace current image with any image that was generated\n    */\n    if (mogrify_image != (Image *) NULL)\n      ReplaceImageInListReturnLast(image,mogrify_image);\n    i+=count;\n  }\n  /*\n    Free resources.\n  */\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status=(MagickStatusType) (exception->severity < ErrorException ? 1 : 0);\n  return(status == 0 ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+    M o g r i f y I m a g e C o m m a n d                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImageCommand() transforms an image or a sequence of images. These\n%  transforms include image scaling, image rotation, color reduction, and\n%  others. The transmogrified image overwrites the original image.\n%\n%  The format of the MogrifyImageCommand method is:\n%\n%      MagickBooleanType MogrifyImageCommand(ImageInfo *image_info,int argc,\n%        const char **argv,char **metadata,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o metadata: any metadata is returned here.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType MogrifyUsage(void)\n{\n  static const char\n    channel_operators[] =\n      \"  -channel-fx expression\\n\"\n      \"                       exchange, extract, or transfer one or more image channels\\n\"\n      \"  -separate            separate an image channel into a grayscale image\",\n    miscellaneous[] =\n      \"  -debug events        display copious debugging information\\n\"\n      \"  -distribute-cache port\\n\"\n      \"                       distributed pixel cache spanning one or more servers\\n\"\n      \"  -help                print program options\\n\"\n      \"  -list type           print a list of supported option arguments\\n\"\n      \"  -log format          format of debugging information\\n\"\n      \"  -version             print version information\",\n    operators[] =\n      \"  -adaptive-blur geometry\\n\"\n      \"                       adaptively blur pixels; decrease effect near edges\\n\"\n      \"  -adaptive-resize geometry\\n\"\n      \"                       adaptively resize image using 'mesh' interpolation\\n\"\n      \"  -adaptive-sharpen geometry\\n\"\n      \"                       adaptively sharpen pixels; increase effect near edges\\n\"\n      \"  -alpha option        on, activate, off, deactivate, set, opaque, copy\\n\"\n      \"                       transparent, extract, background, or shape\\n\"\n      \"  -annotate geometry text\\n\"\n      \"                       annotate the image with text\\n\"\n      \"  -auto-gamma          automagically adjust gamma level of image\\n\"\n      \"  -auto-level          automagically adjust color levels of image\\n\"\n      \"  -auto-orient         automagically orient (rotate) image\\n\"\n      \"  -auto-threshold method\\n\"\n      \"                       automatically perform image thresholding\\n\"\n      \"  -bench iterations    measure performance\\n\"\n      \"  -black-threshold value\\n\"\n      \"                       force all pixels below the threshold into black\\n\"\n      \"  -blue-shift          simulate a scene at nighttime in the moonlight\\n\"\n      \"  -blur geometry       reduce image noise and reduce detail levels\\n\"\n      \"  -border geometry     surround image with a border of color\\n\"\n      \"  -bordercolor color   border color\\n\"\n      \"  -brightness-contrast geometry\\n\"\n      \"                       improve brightness / contrast of the image\\n\"\n      \"  -canny geometry      detect edges in the image\\n\"\n      \"  -cdl filename        color correct with a color decision list\\n\"\n      \"  -channel mask        set the image channel mask\\n\"\n      \"  -charcoal geometry   simulate a charcoal drawing\\n\"\n      \"  -chop geometry       remove pixels from the image interior\\n\"\n      \"  -clahe geometry      contrast limited adaptive histogram equalization\\n\"\n      \"  -clamp               keep pixel values in range (0-QuantumRange)\\n\"\n      \"  -clip                clip along the first path from the 8BIM profile\\n\"\n      \"  -clip-mask filename  associate a clip mask with the image\\n\"\n      \"  -clip-path id        clip along a named path from the 8BIM profile\\n\"\n      \"  -colorize value      colorize the image with the fill color\\n\"\n      \"  -color-matrix matrix apply color correction to the image\\n\"\n      \"  -connected-components connectivity\\n\"\n      \"                       connected-components uniquely labeled\\n\"\n      \"  -contrast            enhance or reduce the image contrast\\n\"\n      \"  -contrast-stretch geometry\\n\"\n      \"                       improve contrast by 'stretching' the intensity range\\n\"\n      \"  -convolve coefficients\\n\"\n      \"                       apply a convolution kernel to the image\\n\"\n      \"  -cycle amount        cycle the image colormap\\n\"\n      \"  -decipher filename   convert cipher pixels to plain pixels\\n\"\n      \"  -deskew threshold    straighten an image\\n\"\n      \"  -despeckle           reduce the speckles within an image\\n\"\n      \"  -distort method args\\n\"\n      \"                       distort images according to given method ad args\\n\"\n      \"  -draw string         annotate the image with a graphic primitive\\n\"\n      \"  -edge radius         apply a filter to detect edges in the image\\n\"\n      \"  -encipher filename   convert plain pixels to cipher pixels\\n\"\n      \"  -emboss radius       emboss an image\\n\"\n      \"  -enhance             apply a digital filter to enhance a noisy image\\n\"\n      \"  -equalize            perform histogram equalization to an image\\n\"\n      \"  -evaluate operator value\\n\"\n      \"                       evaluate an arithmetic, relational, or logical expression\\n\"\n      \"  -extent geometry     set the image size\\n\"\n      \"  -extract geometry    extract area from image\\n\"\n      \"  -fft                 implements the discrete Fourier transform (DFT)\\n\"\n      \"  -flip                flip image vertically\\n\"\n      \"  -floodfill geometry color\\n\"\n      \"                       floodfill the image with color\\n\"\n      \"  -flop                flop image horizontally\\n\"\n      \"  -frame geometry      surround image with an ornamental border\\n\"\n      \"  -function name parameters\\n\"\n      \"                       apply function over image values\\n\"\n      \"  -gamma value         level of gamma correction\\n\"\n      \"  -gaussian-blur geometry\\n\"\n      \"                       reduce image noise and reduce detail levels\\n\"\n      \"  -geometry geometry   preferred size or location of the image\\n\"\n      \"  -grayscale method    convert image to grayscale\\n\"\n      \"  -hough-lines geometry\\n\"\n      \"                       identify lines in the image\\n\"\n      \"  -identify            identify the format and characteristics of the image\\n\"\n      \"  -ift                 implements the inverse discrete Fourier transform (DFT)\\n\"\n      \"  -implode amount      implode image pixels about the center\\n\"\n      \"  -interpolative-resize geometry\\n\"\n      \"                       resize image using interpolation\\n\"\n      \"  -kuwahara geometry   edge preserving noise reduction filter\\n\"\n      \"  -lat geometry        local adaptive thresholding\\n\"\n      \"  -level value         adjust the level of image contrast\\n\"\n      \"  -level-colors color,color\\n\"\n      \"                       level image with the given colors\\n\"\n      \"  -linear-stretch geometry\\n\"\n      \"                       improve contrast by 'stretching with saturation'\\n\"\n      \"  -liquid-rescale geometry\\n\"\n      \"                       rescale image with seam-carving\\n\"\n      \"  -local-contrast geometry\\n\"\n      \"                       enhance local contrast\\n\"\n      \"  -magnify             double the size of the image with pixel art scaling\\n\"\n      \"  -mean-shift geometry delineate arbitrarily shaped clusters in the image\\n\"\n      \"  -median geometry     apply a median filter to the image\\n\"\n      \"  -mode geometry       make each pixel the 'predominant color' of the\\n\"\n      \"                       neighborhood\\n\"\n      \"  -modulate value      vary the brightness, saturation, and hue\\n\"\n      \"  -monochrome          transform image to black and white\\n\"\n      \"  -morphology method kernel\\n\"\n      \"                       apply a morphology method to the image\\n\"\n      \"  -motion-blur geometry\\n\"\n      \"                       simulate motion blur\\n\"\n      \"  -negate              replace every pixel with its complementary color \\n\"\n      \"  -noise geometry      add or reduce noise in an image\\n\"\n      \"  -normalize           transform image to span the full range of colors\\n\"\n      \"  -opaque color        change this color to the fill color\\n\"\n      \"  -ordered-dither NxN\\n\"\n      \"                       add a noise pattern to the image with specific\\n\"\n      \"                       amplitudes\\n\"\n      \"  -paint radius        simulate an oil painting\\n\"\n      \"  -perceptible epsilon\\n\"\n      \"                       pixel value less than |epsilon| become epsilon or\\n\"\n      \"                       -epsilon\\n\"\n      \"  -polaroid angle      simulate a Polaroid picture\\n\"\n      \"  -posterize levels    reduce the image to a limited number of color levels\\n\"\n      \"  -profile filename    add, delete, or apply an image profile\\n\"\n      \"  -quantize colorspace reduce colors in this colorspace\\n\"\n      \"  -raise value         lighten/darken image edges to create a 3-D effect\\n\"\n      \"  -random-threshold low,high\\n\"\n      \"                       random threshold the image\\n\"\n      \"  -range-threshold values\\n\"\n      \"                       perform either hard or soft thresholding within some range of values in an image\\n\"\n      \"  -region geometry     apply options to a portion of the image\\n\"\n      \"  -render              render vector graphics\\n\"\n      \"  -repage geometry     size and location of an image canvas\\n\"\n      \"  -resample geometry   change the resolution of an image\\n\"\n      \"  -resize geometry     resize the image\\n\"\n      \"  -roll geometry       roll an image vertically or horizontally\\n\"\n      \"  -rotate degrees      apply Paeth rotation to the image\\n\"\n      \"  -rotational-blur angle\\n\"\n      \"                       rotational blur the image\\n\"\n      \"  -sample geometry     scale image with pixel sampling\\n\"\n      \"  -scale geometry      scale the image\\n\"\n      \"  -segment values      segment an image\\n\"\n      \"  -selective-blur geometry\\n\"\n      \"                       selectively blur pixels within a contrast threshold\\n\"\n      \"  -sepia-tone threshold\\n\"\n      \"                       simulate a sepia-toned photo\\n\"\n      \"  -set property value  set an image property\\n\"\n      \"  -shade degrees       shade the image using a distant light source\\n\"\n      \"  -shadow geometry     simulate an image shadow\\n\"\n      \"  -sharpen geometry    sharpen the image\\n\"\n      \"  -shave geometry      shave pixels from the image edges\\n\"\n      \"  -shear geometry      slide one edge of the image along the X or Y axis\\n\"\n      \"  -sigmoidal-contrast geometry\\n\"\n      \"                       increase the contrast without saturating highlights or\\n\"\n      \"                       shadows\\n\"\n      \"  -sketch geometry     simulate a pencil sketch\\n\"\n      \"  -solarize threshold  negate all pixels above the threshold level\\n\"\n      \"  -sparse-color method args\\n\"\n      \"                       fill in a image based on a few color points\\n\"\n      \"  -splice geometry     splice the background color into the image\\n\"\n      \"  -spread radius       displace image pixels by a random amount\\n\"\n      \"  -statistic type radius\\n\"\n      \"                       replace each pixel with corresponding statistic from the neighborhood\\n\"\n      \"  -strip               strip image of all profiles and comments\\n\"\n      \"  -swirl degrees       swirl image pixels about the center\\n\"\n      \"  -threshold value     threshold the image\\n\"\n      \"  -thumbnail geometry  create a thumbnail of the image\\n\"\n      \"  -tile filename       tile image when filling a graphic primitive\\n\"\n      \"  -tint value          tint the image with the fill color\\n\"\n      \"  -transform           affine transform image\\n\"\n      \"  -transparent color   make this color transparent within the image\\n\"\n      \"  -transpose           flip image vertically and rotate 90 degrees\\n\"\n      \"  -transverse          flop image horizontally and rotate 270 degrees\\n\"\n      \"  -trim                trim image edges\\n\"\n      \"  -type type           image type\\n\"\n      \"  -unique-colors       discard all but one of any pixel color\\n\"\n      \"  -unsharp geometry    sharpen the image\\n\"\n      \"  -vignette geometry   soften the edges of the image in vignette style\\n\"\n      \"  -wave geometry       alter an image along a sine wave\\n\"\n      \"  -wavelet-denoise threshold\\n\"\n      \"                       removes noise from the image using a wavelet transform\\n\"\n      \"  -white-threshold value\\n\"\n      \"                       force all pixels above the threshold into white\",\n    sequence_operators[] =\n      \"  -affinity filename   transform image colors to match this set of colors\\n\"\n      \"  -append              append an image sequence\\n\"\n      \"  -clut                apply a color lookup table to the image\\n\"\n      \"  -coalesce            merge a sequence of images\\n\"\n      \"  -combine             combine a sequence of images\\n\"\n      \"  -compare             mathematically and visually annotate the difference between an image and its reconstruction\\n\"\n      \"  -complex operator    perform complex mathematics on an image sequence\\n\"\n      \"  -composite           composite image\\n\"\n      \"  -copy geometry offset\\n\"\n      \"                       copy pixels from one area of an image to another\\n\"\n      \"  -crop geometry       cut out a rectangular region of the image\\n\"\n      \"  -deconstruct         break down an image sequence into constituent parts\\n\"\n      \"  -evaluate-sequence operator\\n\"\n      \"                       evaluate an arithmetic, relational, or logical expression\\n\"\n      \"  -flatten             flatten a sequence of images\\n\"\n      \"  -fx expression       apply mathematical expression to an image channel(s)\\n\"\n      \"  -hald-clut           apply a Hald color lookup table to the image\\n\"\n      \"  -layers method       optimize, merge, or compare image layers\\n\"\n      \"  -morph value         morph an image sequence\\n\"\n      \"  -mosaic              create a mosaic from an image sequence\\n\"\n      \"  -poly terms          build a polynomial from the image sequence and the corresponding\\n\"\n      \"                       terms (coefficients and degree pairs).\\n\"\n      \"  -print string        interpret string and print to console\\n\"\n      \"  -process arguments   process the image with a custom image filter\\n\"\n      \"  -smush geometry      smush an image sequence together\\n\"\n      \"  -write filename      write images to this file\",\n    settings[] =\n      \"  -adjoin              join images into a single multi-image file\\n\"\n      \"  -affine matrix       affine transform matrix\\n\"\n      \"  -alpha option        activate, deactivate, reset, or set the alpha channel\\n\"\n      \"  -antialias           remove pixel-aliasing\\n\"\n      \"  -authenticate password\\n\"\n      \"                       decipher image with this password\\n\"\n      \"  -attenuate value     lessen (or intensify) when adding noise to an image\\n\"\n      \"  -background color    background color\\n\"\n      \"  -bias value          add bias when convolving an image\\n\"\n      \"  -black-point-compensation\\n\"\n      \"                       use black point compensation\\n\"\n      \"  -blue-primary point  chromaticity blue primary point\\n\"\n      \"  -bordercolor color   border color\\n\"\n      \"  -caption string      assign a caption to an image\\n\"\n      \"  -colors value        preferred number of colors in the image\\n\"\n      \"  -colorspace type     alternate image colorspace\\n\"\n      \"  -comment string      annotate image with comment\\n\"\n      \"  -compose operator    set image composite operator\\n\"\n      \"  -compress type       type of pixel compression when writing the image\\n\"\n      \"  -define format:option=value\\n\"\n      \"                       define one or more image format options\\n\"\n      \"  -delay value         display the next image after pausing\\n\"\n      \"  -density geometry    horizontal and vertical density of the image\\n\"\n      \"  -depth value         image depth\\n\"\n      \"  -direction type      render text right-to-left or left-to-right\\n\"\n      \"  -display server      get image or font from this X server\\n\"\n      \"  -dispose method      layer disposal method\\n\"\n      \"  -dither method       apply error diffusion to image\\n\"\n      \"  -encoding type       text encoding type\\n\"\n      \"  -endian type         endianness (MSB or LSB) of the image\\n\"\n      \"  -family name         render text with this font family\\n\"\n      \"  -features distance   analyze image features (e.g. contrast, correlation)\\n\"\n      \"  -fill color          color to use when filling a graphic primitive\\n\"\n      \"  -filter type         use this filter when resizing an image\\n\"\n      \"  -font name           render text with this font\\n\"\n      \"  -format \\\"string\\\"   output formatted image characteristics\\n\"\n      \"  -fuzz distance       colors within this distance are considered equal\\n\"\n      \"  -gravity type        horizontal and vertical text placement\\n\"\n      \"  -green-primary point chromaticity green primary point\\n\"\n      \"  -intensity method    method to generate an intensity value from a pixel\\n\"\n      \"  -intent type         type of rendering intent when managing the image color\\n\"\n      \"  -interlace type      type of image interlacing scheme\\n\"\n      \"  -interline-spacing value\\n\"\n      \"                       set the space between two text lines\\n\"\n      \"  -interpolate method  pixel color interpolation method\\n\"\n      \"  -interword-spacing value\\n\"\n      \"                       set the space between two words\\n\"\n      \"  -kerning value       set the space between two letters\\n\"\n      \"  -label string        assign a label to an image\\n\"\n      \"  -limit type value    pixel cache resource limit\\n\"\n      \"  -loop iterations     add Netscape loop extension to your GIF animation\\n\"\n      \"  -matte               store matte channel if the image has one\\n\"\n      \"  -mattecolor color    frame color\\n\"\n      \"  -monitor             monitor progress\\n\"\n      \"  -orient type         image orientation\\n\"\n      \"  -page geometry       size and location of an image canvas (setting)\\n\"\n      \"  -path path           write images to this path on disk\\n\"\n      \"  -ping                efficiently determine image attributes\\n\"\n      \"  -pointsize value     font point size\\n\"\n      \"  -precision value     maximum number of significant digits to print\\n\"\n      \"  -preview type        image preview type\\n\"\n      \"  -quality value       JPEG/MIFF/PNG compression level\\n\"\n      \"  -quiet               suppress all warning messages\\n\"\n      \"  -read-mask filename  associate a read mask with the image\\n\"\n      \"  -red-primary point   chromaticity red primary point\\n\"\n      \"  -regard-warnings     pay attention to warning messages\\n\"\n      \"  -remap filename      transform image colors to match this set of colors\\n\"\n      \"  -respect-parentheses settings remain in effect until parenthesis boundary\\n\"\n      \"  -sampling-factor geometry\\n\"\n      \"                       horizontal and vertical sampling factor\\n\"\n      \"  -scene value         image scene number\\n\"\n      \"  -seed value          seed a new sequence of pseudo-random numbers\\n\"\n      \"  -size geometry       width and height of image\\n\"\n      \"  -stretch type        render text with this font stretch\\n\"\n      \"  -stroke color        graphic primitive stroke color\\n\"\n      \"  -strokewidth value   graphic primitive stroke width\\n\"\n      \"  -style type          render text with this font style\\n\"\n      \"  -synchronize         synchronize image to storage device\\n\"\n      \"  -taint               declare the image as modified\\n\"\n      \"  -texture filename    name of texture to tile onto the image background\\n\"\n      \"  -tile-offset geometry\\n\"\n      \"                       tile offset\\n\"\n      \"  -treedepth value     color tree depth\\n\"\n      \"  -transparent-color color\\n\"\n      \"                       transparent color\\n\"\n      \"  -undercolor color    annotation bounding box color\\n\"\n      \"  -units type          the units of image resolution\\n\"\n      \"  -verbose             print detailed information about the image\\n\"\n      \"  -view                FlashPix viewing transforms\\n\"\n      \"  -virtual-pixel method\\n\"\n      \"                       virtual pixel access method\\n\"\n      \"  -weight type         render text with this font weight\\n\"\n      \"  -white-point point   chromaticity white point\\n\"\n      \"  -write-mask filename associate a write mask with the image\",\n    stack_operators[] =\n      \"  -delete indexes      delete the image from the image sequence\\n\"\n      \"  -duplicate count,indexes\\n\"\n      \"                       duplicate an image one or more times\\n\"\n      \"  -insert index        insert last image into the image sequence\\n\"\n      \"  -reverse             reverse image sequence\\n\"\n      \"  -swap indexes        swap two images in the image sequence\";\n\n  ListMagickVersion(stdout);\n  (void) printf(\"Usage: %s [options ...] file [ [options ...] file ...]\\n\",\n    GetClientName());\n  (void) printf(\"\\nImage Settings:\\n\");\n  (void) puts(settings);\n  (void) printf(\"\\nImage Operators:\\n\");\n  (void) puts(operators);\n  (void) printf(\"\\nImage Channel Operators:\\n\");\n  (void) puts(channel_operators);\n  (void) printf(\"\\nImage Sequence Operators:\\n\");\n  (void) puts(sequence_operators);\n  (void) printf(\"\\nImage Stack Operators:\\n\");\n  (void) puts(stack_operators);\n  (void) printf(\"\\nMiscellaneous Options:\\n\");\n  (void) puts(miscellaneous);\n  (void) printf(\n    \"\\nBy default, the image format of 'file' is determined by its magic\\n\");\n  (void) printf(\n    \"number.  To specify a particular image format, precede the filename\\n\");\n  (void) printf(\n    \"with an image format name and a colon (i.e. ps:image) or specify the\\n\");\n  (void) printf(\n    \"image type as the filename suffix (i.e. image.ps).  Specify 'file' as\\n\");\n  (void) printf(\"'-' for standard input or output.\\n\");\n  return(MagickFalse);\n}\n\nWandExport MagickBooleanType MogrifyImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **wand_unused(metadata),ExceptionInfo *exception)\n{\n#define DestroyMogrify() \\\n{ \\\n  if (format != (char *) NULL) \\\n    format=DestroyString(format); \\\n  if (path != (char *) NULL) \\\n    path=DestroyString(path); \\\n  DestroyImageStack(); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowMogrifyException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n    option); \\\n  DestroyMogrify(); \\\n  return(MagickFalse); \\\n}\n#define ThrowMogrifyInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",argument,option); \\\n  DestroyMogrify(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    *format,\n    *option,\n    *path;\n\n  Image\n    *image;\n\n  ImageStack\n    image_stack[MaxImageStackDepth+1];\n\n  MagickBooleanType\n    global_colormap;\n\n  MagickBooleanType\n    fire,\n    pend,\n    respect_parenthesis;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j,\n    k;\n\n  wand_unreferenced(metadata);\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc == 2)\n    {\n      option=argv[1];\n      if ((LocaleCompare(\"version\",option+1) == 0) ||\n          (LocaleCompare(\"-version\",option+1) == 0))\n        {\n          ListMagickVersion(stdout);\n          return(MagickTrue);\n        }\n    }\n  if (argc < 2)\n    return(MogrifyUsage());\n  format=(char *) NULL;\n  path=(char *) NULL;\n  global_colormap=MagickFalse;\n  k=0;\n  j=1;\n  NewImageStack();\n  option=(char *) NULL;\n  pend=MagickFalse;\n  respect_parenthesis=MagickFalse;\n  status=MagickTrue;\n  /*\n    Parse command line.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowMogrifyException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (LocaleCompare(option,\"(\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,pend);\n        if (k == MaxImageStackDepth)\n          ThrowMogrifyException(OptionError,\"ParenthesisNestedTooDeeply\",\n            option);\n        PushImageStack();\n        continue;\n      }\n    if (LocaleCompare(option,\")\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n        if (k == 0)\n          ThrowMogrifyException(OptionError,\"UnableToParseExpression\",option);\n        PopImageStack();\n        continue;\n      }\n    if (IsCommandOption(option) == MagickFalse)\n      {\n        char\n          backup_filename[MagickPathExtent],\n          *filename;\n\n        Image\n          *images;\n\n        struct stat\n          properties;\n\n        /*\n          Option is a file name: begin by reading image from specified file.\n        */\n        FireImageStack(MagickFalse,MagickFalse,pend);\n        filename=argv[i];\n        if ((LocaleCompare(filename,\"--\") == 0) && (i < (ssize_t) (argc-1)))\n          filename=argv[++i];\n        images=ReadImages(image_info,filename,exception);\n        status&=(images != (Image *) NULL) &&\n          (exception->severity < ErrorException);\n        if (images == (Image *) NULL)\n          continue;\n        properties=(*GetBlobProperties(images));\n        if (format != (char *) NULL)\n          (void) CopyMagickString(images->filename,images->magick_filename,\n            MagickPathExtent);\n        if (path != (char *) NULL)\n          {\n            GetPathComponent(option,TailPath,filename);\n            (void) FormatLocaleString(images->filename,MagickPathExtent,\n              \"%s%c%s\",path,*DirectorySeparator,filename);\n          }\n        if (format != (char *) NULL)\n          AppendImageFormat(format,images->filename);\n        AppendImageStack(images);\n        FinalizeImageSettings(image_info,image,MagickFalse);\n        if (global_colormap != MagickFalse)\n          {\n            QuantizeInfo\n              *quantize_info;\n\n            quantize_info=AcquireQuantizeInfo(image_info);\n            (void) RemapImages(quantize_info,images,(Image *) NULL,exception);\n            quantize_info=DestroyQuantizeInfo(quantize_info);\n          }\n        *backup_filename='\\0';\n        if ((LocaleCompare(image->filename,\"-\") != 0) &&\n            (IsPathWritable(image->filename) != MagickFalse))\n          {\n            /*\n              Rename image file as backup.\n            */\n            (void) CopyMagickString(backup_filename,image->filename,\n              MagickPathExtent);\n            for (j=0; j < 6; j++)\n            {\n              (void) ConcatenateMagickString(backup_filename,\"~\",\n                MagickPathExtent);\n              if (IsPathAccessible(backup_filename) == MagickFalse)\n                break;\n            }\n            if ((IsPathAccessible(backup_filename) != MagickFalse) ||\n                (rename_utf8(image->filename,backup_filename) != 0))\n              *backup_filename='\\0';\n          }\n        /*\n          Write transmogrified image to disk.\n        */\n        image_info->synchronize=MagickTrue;\n        status&=WriteImages(image_info,image,image->filename,exception);\n        if (status != MagickFalse)\n          {\n#if defined(MAGICKCORE_HAVE_UTIME)\n            {\n              MagickBooleanType\n                preserve_timestamp;\n\n              preserve_timestamp=IsStringTrue(GetImageOption(image_info,\n                \"preserve-timestamp\"));\n              if (preserve_timestamp != MagickFalse)\n                {\n                  struct utimbuf\n                    timestamp;\n\n                  timestamp.actime=properties.st_atime;\n                  timestamp.modtime=properties.st_mtime;\n                  (void) utime(image->filename,&timestamp);\n                }\n            }\n#endif\n            if (*backup_filename != '\\0')\n              (void) remove_utf8(backup_filename);\n          }\n        RemoveAllImageStack();\n        continue;\n      }\n    pend=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"affine\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,\n              argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\n                \"UnrecognizedAlphaChannelOption\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"annotate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"append\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"attenuate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"auto-level\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"auto-orient\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickAutoThresholdOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedThresholdMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'b':\n      {\n        if (LocaleCompare(\"background\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"bias\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"black-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"blue-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"blue-shift\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"border\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"bordercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"box\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"canny\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"caption\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            channel=ParseChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"channel-fx\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            channel=ParsePixelChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"cdl\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"charcoal\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"chop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"clahe\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"clamp\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"clip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"clip-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"colorize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"color-matrix\",option+1) == 0)\n          {\n            KernelInfo\n              *kernel_info;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            kernel_info=AcquireKernelInfo(argv[i],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"colors\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"compare\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"comment\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"compress\",option+1) == 0)\n          {\n            ssize_t\n              compress;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            compress=ParseCommandOption(MagickCompressOptions,MagickFalse,\n              argv[i]);\n            if (compress < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageCompression\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"connected-components\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"contrast\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"convolve\",option+1) == 0)\n          {\n            KernelInfo\n              *kernel_info;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            kernel_info=AcquireKernelInfo(argv[i],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"crop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"cycle\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"decipher\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                const char\n                  *define;\n\n                define=GetImageOption(image_info,argv[i]);\n                if (define == (const char *) NULL)\n                  ThrowMogrifyException(OptionError,\"NoSuchOption\",argv[i]);\n                break;\n              }\n            break;\n          }\n        if (LocaleCompare(\"delay\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"deskew\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"despeckle\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"dft\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"direction\",option+1) == 0)\n          {\n            ssize_t\n              direction;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,\n              argv[i]);\n            if (direction < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDirectionType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"display\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"dispose\",option+1) == 0)\n          {\n            ssize_t\n              dispose;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n              argv[i]);\n            if (dispose < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDisposeMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"distort\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickDistortOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDistortMethod\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickDitherOptions,MagickFalse,argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDitherMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"draw\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"edge\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"emboss\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"encipher\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"encoding\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"endian\",option+1) == 0)\n          {\n            ssize_t\n              endian;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            endian=ParseCommandOption(MagickEndianOptions,MagickFalse,argv[i]);\n            if (endian < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEndianType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"enhance\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"equalize\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"evaluate\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickEvaluateOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEvaluateOperator\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickEvaluateOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEvaluateOperator\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"extent\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"extract\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"family\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"features\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"fill\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"filter\",option+1) == 0)\n          {\n            ssize_t\n              filter;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            filter=ParseCommandOption(MagickFilterOptions,MagickFalse,argv[i]);\n            if (filter < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageFilter\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"flip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"flop\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"floodfill\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"font\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            (void) CopyMagickString(argv[i]+1,\"sans\",MagickPathExtent);\n            (void) CloneString(&format,(char *) NULL);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            (void) CloneString(&format,argv[i]);\n            (void) CopyMagickString(image_info->filename,format,\n              MagickPathExtent);\n            (void) ConcatenateMagickString(image_info->filename,\":\",\n              MagickPathExtent);\n            (void) SetImageInfo(image_info,0,exception);\n            if (*image_info->magick == '\\0')\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageFormat\",\n                format);\n            break;\n          }\n        if (LocaleCompare(\"frame\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"function\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickFunctionOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedFunction\",argv[i]);\n             i++;\n             if (i == (ssize_t) argc)\n               ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"fuzz\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gamma\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if ((LocaleCompare(\"gaussian-blur\",option+1) == 0) ||\n            (LocaleCompare(\"gaussian\",option+1) == 0))\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"geometry\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"gravity\",option+1) == 0)\n          {\n            ssize_t\n              gravity;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,\n              argv[i]);\n            if (gravity < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedGravityType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"grayscale\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedIntensityMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"green-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          break;\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          return(MogrifyUsage());\n        if (LocaleCompare(\"hough-lines\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"identify\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"idft\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"implode\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"intensity\",option+1) == 0)\n          {\n            ssize_t\n              intensity;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            intensity=ParseCommandOption(MagickPixelIntensityOptions,\n              MagickFalse,argv[i]);\n            if (intensity < 0)\n              ThrowMogrifyException(OptionError,\n                \"UnrecognizedPixelIntensityMethod\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"intent\",option+1) == 0)\n          {\n            ssize_t\n              intent;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            intent=ParseCommandOption(MagickIntentOptions,MagickFalse,argv[i]);\n            if (intent < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedIntentType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            ssize_t\n              interlace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            interlace=ParseCommandOption(MagickInterlaceOptions,MagickFalse,\n              argv[i]);\n            if (interlace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedInterlaceType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            ssize_t\n              interpolate;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n              argv[i]);\n            if (interpolate < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedInterpolateMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'k':\n      {\n        if (LocaleCompare(\"kerning\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"kuwahara\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"label\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"lat\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n          }\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickLayerOptions,MagickFalse,argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedLayerMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"level\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"level-colors\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            char\n              *p;\n\n            double\n              value;\n\n            ssize_t\n              resource;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            resource=ParseCommandOption(MagickResourceOptions,MagickFalse,\n              argv[i]);\n            if (resource < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedResourceType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            value=StringToDouble(argv[i],&p);\n            (void) value;\n            if ((p == argv[i]) && (LocaleCompare(\"unlimited\",argv[i]) != 0))\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i]);\n            if (list < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedListType\",argv[i]);\n            status=MogrifyImageInfo(image_info,(int) (i-j+1),(const char **)\n              argv+j,exception);\n            return(status == 0 ? MagickFalse : MagickTrue);\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if ((i == (ssize_t) argc) ||\n                (strchr(argv[i],'%') == (char *) NULL))\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"loop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"magnify\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            global_colormap=(*option == '+') ? MagickTrue : MagickFalse;\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"mattecolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"mean-shift\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"median\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"metric\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickMetricOptions,MagickTrue,argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedMetricType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"modulate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"mode\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"monochrome\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"morphology\",option+1) == 0)\n          {\n            char\n              token[MagickPathExtent];\n\n            KernelInfo\n              *kernel_info;\n\n            ssize_t\n              op;\n\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            GetNextToken(argv[i],(const char **) NULL,MagickPathExtent,token);\n            op=ParseCommandOption(MagickMorphologyOptions,MagickFalse,token);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedMorphologyMethod\",\n                token);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            kernel_info=AcquireKernelInfo(argv[i],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"motion-blur\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'n':\n      {\n        if (LocaleCompare(\"negate\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"noise\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                ssize_t\n                  noise;\n\n                noise=ParseCommandOption(MagickNoiseOptions,MagickFalse,\n                  argv[i]);\n                if (noise < 0)\n                  ThrowMogrifyException(OptionError,\"UnrecognizedNoiseType\",\n                    argv[i]);\n                break;\n              }\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"noop\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"normalize\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'o':\n      {\n        if (LocaleCompare(\"opaque\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"orient\",option+1) == 0)\n          {\n            ssize_t\n              orientation;\n\n            orientation=UndefinedOrientation;\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            orientation=ParseCommandOption(MagickOrientationOptions,MagickFalse,\n              argv[i]);\n            if (orientation < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageOrientation\",\n                argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"page\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"paint\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"path\",option+1) == 0)\n          {\n            (void) CloneString(&path,(char *) NULL);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            (void) CloneString(&path,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"perceptible\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"pointsize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"polaroid\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"posterize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"precision\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"profile\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quality\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"quantize\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"raise\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"random-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"range-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"read-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"red-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n          }\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"region\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"remap\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"render\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"repage\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"resample\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"resize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleNCompare(\"respect-parentheses\",option+1,17) == 0)\n          {\n            respect_parenthesis=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"roll\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"rotate\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sample\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"scale\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"scene\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"segment\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"selective-blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"separate\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"shade\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"shadow\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sharpen\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"shave\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"shear\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sketch\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"solarize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sparse-color\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickSparseColorOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedSparseColorMethod\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"splice\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"spread\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"statistic\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickStatisticOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedStatisticType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"stretch\",option+1) == 0)\n          {\n            ssize_t\n              stretch;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,\n              argv[i]);\n            if (stretch < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedStyleType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"strip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"stroke\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"strokewidth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"style\",option+1) == 0)\n          {\n            ssize_t\n              style;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            style=ParseCommandOption(MagickStyleOptions,MagickFalse,argv[i]);\n            if (style < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedStyleType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"swirl\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"synchronize\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"taint\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"texture\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"tile\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"tile-offset\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"tint\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"transform\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"transpose\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"transverse\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"thumbnail\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"transparent\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"transparent-color\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"treedepth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"trim\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"type\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickTypeOptions,MagickFalse,argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageType\",\n                argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"undercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"unique-colors\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"units\",option+1) == 0)\n          {\n            ssize_t\n              units;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            units=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n              argv[i]);\n            if (units < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedUnitsType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"unsharp\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            image_info->verbose=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            break;\n          }\n        if (LocaleCompare(\"vignette\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\n                \"UnrecognizedVirtualPixelMethod\",argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"wave\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"weight\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"white-point\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"white-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"write-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case '?':\n        break;\n      default:\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n    }\n    fire=(GetCommandOptionFlags(MagickCommandOptions,MagickFalse,option) &\n      FireOptionFlag) == 0 ?  MagickFalse : MagickTrue;\n    if (fire != MagickFalse)\n      FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n  }\n  if (k != 0)\n    ThrowMogrifyException(OptionError,\"UnbalancedParenthesis\",argv[i]);\n  if (i != (ssize_t) argc)\n    ThrowMogrifyException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  DestroyMogrify();\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e I n f o                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImageInfo() applies image processing settings to the image as\n%  prescribed by command line options.\n%\n%  The format of the MogrifyImageInfo method is:\n%\n%      MagickBooleanType MogrifyImageInfo(ImageInfo *image_info,const int argc,\n%        const char **argv,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MogrifyImageInfo(ImageInfo *image_info,\n  const int argc,const char **argv,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  GeometryInfo\n    geometry_info;\n\n  ssize_t\n    count;\n\n  register ssize_t\n    i;\n\n  /*\n    Initialize method variables.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  if (argc < 0)\n    return(MagickTrue);\n  /*\n    Set the image settings.\n  */\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"adjoin\",option+1) == 0)\n          {\n            image_info->adjoin=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          {\n            image_info->antialias=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) DeleteImageOption(image_info,option+1);\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'b':\n      {\n        if (LocaleCompare(\"background\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                (void) QueryColorCompliance(MogrifyBackgroundColor,\n                  AllCompliance,&image_info->background_color,exception);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->background_color,exception);\n            break;\n          }\n        if (LocaleCompare(\"bias\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,\"convolve:bias\",\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,\"convolve:bias\",argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"false\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,\"true\");\n            break;\n          }\n        if (LocaleCompare(\"blue-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"bordercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n                  &image_info->border_color,exception);\n                break;\n              }\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->border_color,exception);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"box\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,\"undercolor\",\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,\"undercolor\",argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            MagickSizeType\n              limit;\n\n            limit=MagickResourceInfinity;\n            if (LocaleCompare(\"unlimited\",argv[i+1]) != 0)\n              limit=(MagickSizeType) SiPrefixToDoubleInterval(argv[i+1],\n                100.0);\n            (void) SetMagickResourceLimit(MemoryResource,limit);\n            (void) SetMagickResourceLimit(MapResource,2*limit);\n            break;\n          }\n        if (LocaleCompare(\"caption\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->colorspace=UndefinedColorspace;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->colorspace=(ColorspaceType) ParseCommandOption(\n              MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"comment\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"compose\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"compress\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->compression=UndefinedCompression;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->compression=(CompressionType) ParseCommandOption(\n              MagickCompressOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetLogEventMask(\"none\");\n            else\n              (void) SetLogEventMask(argv[i+1]);\n            image_info->debug=IsEventLogging();\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n                  (void) DeleteImageRegistry(argv[i+1]+9);\n                else\n                  (void) DeleteImageOption(image_info,argv[i+1]);\n                break;\n              }\n            if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n              {\n                (void) DefineImageRegistry(StringRegistryType,argv[i+1]+9,\n                  exception);\n                break;\n              }\n            (void) DefineImageOption(image_info,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"delay\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            /*\n              Set image density.\n            */\n            if (*option == '+')\n              {\n                if (image_info->density != (char *) NULL)\n                  image_info->density=DestroyString(image_info->density);\n                (void) SetImageOption(image_info,option+1,\"72\");\n                break;\n              }\n            (void) CloneString(&image_info->density,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->depth=MAGICKCORE_QUANTUM_DEPTH;\n                break;\n              }\n            image_info->depth=StringToUnsignedLong(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"direction\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"display\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->server_name != (char *) NULL)\n                  image_info->server_name=DestroyString(\n                    image_info->server_name);\n                break;\n              }\n            (void) CloneString(&image_info->server_name,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"dispose\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->dither=MagickFalse;\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            image_info->dither=MagickTrue;\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"encoding\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"endian\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->endian=UndefinedEndian;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->endian=(EndianType) ParseCommandOption(\n              MagickEndianOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"extract\",option+1) == 0)\n          {\n            /*\n              Set image extract geometry.\n            */\n            if (*option == '+')\n              {\n                if (image_info->extract != (char *) NULL)\n                  image_info->extract=DestroyString(image_info->extract);\n                break;\n              }\n            (void) CloneString(&image_info->extract,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"family\",option+1) == 0)\n          {\n            if (*option != '+')\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"fill\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"filter\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"font\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->font != (char *) NULL)\n                  image_info->font=DestroyString(image_info->font);\n                break;\n              }\n            (void) CloneString(&image_info->font,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            register const char\n              *q;\n\n            for (q=strchr(argv[i+1],'%'); q != (char *) NULL; q=strchr(q+1,'%'))\n              if (strchr(\"Agkrz@[#\",*(q+1)) != (char *) NULL)\n                image_info->ping=MagickFalse;\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"fuzz\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->fuzz=0.0;\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            image_info->fuzz=StringToDoubleInterval(argv[i+1],(double)\n              QuantumRange+1.0);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gravity\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"green-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"intensity\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"intent\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->interlace=UndefinedInterlace;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->interlace=(InterlaceType) ParseCommandOption(\n              MagickInterlaceOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'k':\n      {\n        if (LocaleCompare(\"kerning\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"label\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            MagickSizeType\n              limit;\n\n            ResourceType\n              type;\n\n            if (*option == '+')\n              break;\n            type=(ResourceType) ParseCommandOption(MagickResourceOptions,\n              MagickFalse,argv[i+1]);\n            limit=MagickResourceInfinity;\n            if (LocaleCompare(\"unlimited\",argv[i+2]) != 0)\n              limit=(MagickSizeType) SiPrefixToDoubleInterval(argv[i+2],100.0);\n            (void) SetMagickResourceLimit(type,limit);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            /*\n              Display configuration list.\n            */\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i+1]);\n            switch (list)\n            {\n              case MagickCoderOptions:\n              {\n                (void) ListCoderInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickColorOptions:\n              {\n                (void) ListColorInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickConfigureOptions:\n              {\n                (void) ListConfigureInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickDelegateOptions:\n              {\n                (void) ListDelegateInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickFontOptions:\n              {\n                (void) ListTypeInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickFormatOptions:\n              {\n                (void) ListMagickInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickLocaleOptions:\n              {\n                (void) ListLocaleInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickLogOptions:\n              {\n                (void) ListLogInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickMagicOptions:\n              {\n                (void) ListMagicInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickMimeOptions:\n              {\n                (void) ListMimeInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickModuleOptions:\n              {\n                (void) ListModuleInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickPolicyOptions:\n              {\n                (void) ListPolicyInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickResourceOptions:\n              {\n                (void) ListMagickResourceInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickThresholdOptions:\n              {\n                (void) ListThresholdMaps((FILE *) NULL,exception);\n                break;\n              }\n              default:\n              {\n                (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n                  exception);\n                break;\n              }\n            }\n            break;\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            (void) SetLogFormat(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"loop\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"false\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,\"true\");\n            break;\n          }\n        if (LocaleCompare(\"mattecolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,argv[i+1]);\n                (void) QueryColorCompliance(MogrifyAlphaColor,AllCompliance,\n                  &image_info->matte_color,exception);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->matte_color,exception);\n            break;\n          }\n        if (LocaleCompare(\"metric\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) DeleteImageOption(image_info,option+1);\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          {\n            (void) SetImageInfoProgressMonitor(image_info,MonitorProgress,\n              (void *) NULL);\n            break;\n          }\n        if (LocaleCompare(\"monochrome\",option+1) == 0)\n          {\n            image_info->monochrome=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        break;\n      }\n      case 'o':\n      {\n        if (LocaleCompare(\"orient\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->orientation=UndefinedOrientation;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->orientation=(OrientationType) ParseCommandOption(\n              MagickOrientationOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"page\",option+1) == 0)\n          {\n            char\n              *canonical_page,\n              page[MagickPathExtent];\n\n            const char\n              *image_option;\n\n            MagickStatusType\n              flags;\n\n            RectangleInfo\n              geometry;\n\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                (void) CloneString(&image_info->page,(char *) NULL);\n                break;\n              }\n            (void) memset(&geometry,0,sizeof(geometry));\n            image_option=GetImageOption(image_info,\"page\");\n            if (image_option != (const char *) NULL)\n              flags=ParseAbsoluteGeometry(image_option,&geometry);\n            canonical_page=GetPageGeometry(argv[i+1]);\n            flags=ParseAbsoluteGeometry(canonical_page,&geometry);\n            canonical_page=DestroyString(canonical_page);\n            (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu\",\n              (unsigned long) geometry.width,(unsigned long) geometry.height);\n            if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n              (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu%+ld%+ld\",\n                (unsigned long) geometry.width,(unsigned long) geometry.height,\n                (long) geometry.x,(long) geometry.y);\n            (void) SetImageOption(image_info,option+1,page);\n            (void) CloneString(&image_info->page,page);\n            break;\n          }\n        if (LocaleCompare(\"ping\",option+1) == 0)\n          {\n            image_info->ping=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"pointsize\",option+1) == 0)\n          {\n            if (*option == '+')\n              geometry_info.rho=0.0;\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            image_info->pointsize=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"precision\",option+1) == 0)\n          {\n            (void) SetMagickPrecision(StringToInteger(argv[i+1]));\n            break;\n          }\n        break;\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quality\",option+1) == 0)\n          {\n            /*\n              Set image compression quality.\n            */\n            if (*option == '+')\n              {\n                image_info->quality=UndefinedCompressionQuality;\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            image_info->quality=StringToUnsignedLong(argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          {\n            static WarningHandler\n              warning_handler = (WarningHandler) NULL;\n\n            if (*option == '+')\n              {\n                /*\n                  Restore error or warning messages.\n                */\n                warning_handler=SetWarningHandler(warning_handler);\n                break;\n              }\n            /*\n              Suppress error or warning messages.\n            */\n            warning_handler=SetWarningHandler((WarningHandler) NULL);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"red-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            /*\n              Set image sampling factor.\n            */\n            if (*option == '+')\n              {\n                if (image_info->sampling_factor != (char *) NULL)\n                  image_info->sampling_factor=DestroyString(\n                    image_info->sampling_factor);\n                break;\n              }\n            (void) CloneString(&image_info->sampling_factor,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"scene\",option+1) == 0)\n          {\n            /*\n              Set image scene.\n            */\n            if (*option == '+')\n              {\n                image_info->scene=0;\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            image_info->scene=StringToUnsignedLong(argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            unsigned long\n              seed;\n\n            if (*option == '+')\n              {\n                seed=(unsigned long) time((time_t *) NULL);\n                SetRandomSecretKey(seed);\n                break;\n              }\n            seed=StringToUnsignedLong(argv[i+1]);\n            SetRandomSecretKey(seed);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->size != (char *) NULL)\n                  image_info->size=DestroyString(image_info->size);\n                break;\n              }\n            (void) CloneString(&image_info->size,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"strokewidth\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"style\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"synchronize\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->synchronize=MagickFalse;\n                break;\n              }\n            image_info->synchronize=MagickTrue;\n            break;\n          }\n        break;\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"taint\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"false\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,\"true\");\n            break;\n          }\n        if (LocaleCompare(\"texture\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->texture != (char *) NULL)\n                  image_info->texture=DestroyString(image_info->texture);\n                break;\n              }\n            (void) CloneString(&image_info->texture,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"tile-offset\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"transparent-color\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(\"none\",AllCompliance,\n                  &image_info->transparent_color,exception);\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->transparent_color,exception);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"type\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->type=UndefinedType;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->type=(ImageType) ParseCommandOption(MagickTypeOptions,\n              MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"undercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) DeleteImageOption(image_info,option+1);\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"units\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->units=UndefinedResolution;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->units=(ResolutionType) ParseCommandOption(\n              MagickResolutionOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->verbose=MagickFalse;\n                break;\n              }\n            image_info->verbose=MagickTrue;\n            image_info->ping=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"undefined\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"weight\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"white-point\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0.0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImageList() applies any command line options that might affect the\n%  entire image list (e.g. -append, -coalesce, etc.).\n%\n%  The format of the MogrifyImage method is:\n%\n%      MagickBooleanType MogrifyImageList(ImageInfo *image_info,const int argc,\n%        const char **argv,Image **images,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o images: pointer to pointer of the first image in image list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n  const int argc,const char **argv,Image **images,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  PixelInterpolateMethod\n   interpolate_method;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index;\n\n  /*\n    Apply options to the image list.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image **) NULL);\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  interpolate_method=UndefinedInterpolatePixel;\n  mogrify_info=CloneImageInfo(image_info);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    if (*images == (Image *) NULL)\n      break;\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"affinity\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"append\",option+1) == 0)\n          {\n            Image\n              *append_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            append_image=AppendImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            if (append_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=append_image;\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          {\n            Image\n              *average_image;\n\n            /*\n              Average an image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            average_image=EvaluateImages(*images,MeanEvaluateOperator,\n              exception);\n            if (average_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=average_image;\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"channel-fx\",option+1) == 0)\n          {\n            Image\n              *channel_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            channel_image=ChannelFxImage(*images,argv[i+1],exception);\n            if (channel_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=channel_image;\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          {\n            Image\n              *clut_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            clut_image=RemoveFirstImageFromList(images);\n            if (clut_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) ClutImage(image,clut_image,interpolate_method,exception);\n            clut_image=DestroyImage(clut_image);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          {\n            Image\n              *coalesce_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            coalesce_image=CoalesceImages(*images,exception);\n            if (coalesce_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=coalesce_image;\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            ColorspaceType\n              colorspace;\n\n            Image\n              *combine_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            colorspace=(*images)->colorspace;\n            if ((*images)->number_channels < GetImageListLength(*images))\n              colorspace=sRGBColorspace;\n            if (*option == '+')\n              colorspace=(ColorspaceType) ParseCommandOption(\n                MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            combine_image=CombineImages(*images,colorspace,exception);\n            if (combine_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=combine_image;\n            break;\n          }\n        if (LocaleCompare(\"compare\",option+1) == 0)\n          {\n            double\n              distortion;\n\n            Image\n              *difference_image,\n              *image,\n              *reconstruct_image;\n\n            MetricType\n              metric;\n\n            /*\n              Mathematically and visually annotate the difference between an\n              image and its reconstruction.\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            reconstruct_image=RemoveFirstImageFromList(images);\n            if (reconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            metric=UndefinedErrorMetric;\n            option=GetImageOption(mogrify_info,\"metric\");\n            if (option != (const char *) NULL)\n              metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n                MagickFalse,option);\n            difference_image=CompareImages(image,reconstruct_image,metric,\n              &distortion,exception);\n            if (difference_image == (Image *) NULL)\n              break;\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=difference_image;\n            break;\n          }\n        if (LocaleCompare(\"complex\",option+1) == 0)\n          {\n            ComplexOperator\n              op;\n\n            Image\n              *complex_images;\n\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            op=(ComplexOperator) ParseCommandOption(MagickComplexOptions,\n              MagickFalse,argv[i+1]);\n            complex_images=ComplexImages(*images,op,exception);\n            if (complex_images == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=complex_images;\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          {\n            CompositeOperator\n              compose;\n\n            const char*\n              value;\n\n            MagickBooleanType\n              clip_to_self;\n\n            Image\n              *mask_image,\n              *new_images,\n              *source_image;\n\n            RectangleInfo\n              geometry;\n\n            /* Compose value from \"-compose\" option only */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            value=GetImageOption(mogrify_info,\"compose\");\n            if (value == (const char *) NULL)\n              compose=OverCompositeOp;  /* use Over not source_image->compose */\n            else\n              compose=(CompositeOperator) ParseCommandOption(\n                MagickComposeOptions,MagickFalse,value);\n\n            /* Get \"clip-to-self\" expert setting (false is normal) */\n            clip_to_self=GetCompositeClipToSelf(compose);\n            value=GetImageOption(mogrify_info,\"compose:clip-to-self\");\n            if (value != (const char *) NULL)\n              clip_to_self=IsStringTrue(value);\n            value=GetImageOption(mogrify_info,\"compose:outside-overlay\");\n            if (value != (const char *) NULL)\n              clip_to_self=IsStringFalse(value);  /* deprecated */\n\n            new_images=RemoveFirstImageFromList(images);\n            source_image=RemoveFirstImageFromList(images);\n            if (source_image == (Image *) NULL)\n              break; /* FUTURE - produce Exception, rather than silent fail */\n\n            /* FUTURE: this should not be here! - should be part of -geometry */\n            if (source_image->geometry != (char *) NULL)\n              {\n                RectangleInfo\n                  resize_geometry;\n\n                (void) ParseRegionGeometry(source_image,source_image->geometry,\n                  &resize_geometry,exception);\n                if ((source_image->columns != resize_geometry.width) ||\n                    (source_image->rows != resize_geometry.height))\n                  {\n                    Image\n                      *resize_image;\n\n                    resize_image=ResizeImage(source_image,resize_geometry.width,\n                      resize_geometry.height,source_image->filter,exception);\n                    if (resize_image != (Image *) NULL)\n                      {\n                        source_image=DestroyImage(source_image);\n                        source_image=resize_image;\n                      }\n                  }\n              }\n            SetGeometry(source_image,&geometry);\n            (void) ParseAbsoluteGeometry(source_image->geometry,&geometry);\n            GravityAdjustGeometry(new_images->columns,new_images->rows,\n              new_images->gravity,&geometry);\n            mask_image=RemoveFirstImageFromList(images);\n            if (mask_image == (Image *) NULL)\n              status&=CompositeImage(new_images,source_image,compose,\n                clip_to_self,geometry.x,geometry.y,exception);\n            else\n              {\n                if ((compose == DisplaceCompositeOp) ||\n                    (compose == DistortCompositeOp))\n                  {\n                    status&=CompositeImage(source_image,mask_image,\n                      CopyGreenCompositeOp,MagickTrue,0,0,exception);\n                    status&=CompositeImage(new_images,source_image,compose,\n                      clip_to_self,geometry.x,geometry.y,exception);\n                  }\n                else\n                  {\n                    Image\n                      *clone_image;\n\n                    clone_image=CloneImage(new_images,0,0,MagickTrue,exception);\n                    if (clone_image == (Image *) NULL)\n                      break;\n                    status&=CompositeImage(new_images,source_image,compose,\n                      clip_to_self,geometry.x,geometry.y,exception);\n                    status&=CompositeImage(new_images,mask_image,\n                      CopyAlphaCompositeOp,MagickTrue,0,0,exception);\n                    status&=CompositeImage(clone_image,new_images,\n                      OverCompositeOp,clip_to_self,0,0,exception);\n                    new_images=DestroyImageList(new_images);\n                    new_images=clone_image;\n                  }\n                mask_image=DestroyImage(mask_image);\n              }\n            source_image=DestroyImage(source_image);\n            *images=DestroyImageList(*images);\n            *images=new_images;\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            (void) ParsePageGeometry(*images,argv[i+2],&geometry,exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=(*images);\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,argv[i+1],&geometry,\n              exception);\n            status=CopyImagePixels(*images,source_image,&geometry,&offset,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          {\n            Image\n              *deconstruct_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            deconstruct_image=CompareImagesLayers(*images,CompareAnyLayer,\n              exception);\n            if (deconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=deconstruct_image;\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              DeleteImages(images,\"-1\",exception);\n            else\n              DeleteImages(images,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither_method=NoDitherMethod;\n                break;\n              }\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            Image\n              *duplicate_images;\n\n            if (*option == '+')\n              duplicate_images=DuplicateImages(*images,1,\"-1\",exception);\n            else\n              {\n                const char\n                  *p;\n\n                size_t\n                  number_duplicates;\n\n                number_duplicates=(size_t) StringToLong(argv[i+1]);\n                p=strchr(argv[i+1],',');\n                if (p == (const char *) NULL)\n                  duplicate_images=DuplicateImages(*images,number_duplicates,\n                    \"-1\",exception);\n                else\n                  duplicate_images=DuplicateImages(*images,number_duplicates,p,\n                    exception);\n              }\n            AppendImageToList(images, duplicate_images);\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            Image\n              *evaluate_image;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            evaluate_image=EvaluateImages(*images,op,exception);\n            if (evaluate_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=evaluate_image;\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"fft\",option+1) == 0)\n          {\n            Image\n              *fourier_image;\n\n            /*\n              Implements the discrete Fourier transform (DFT).\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            fourier_image=ForwardFourierTransformImage(*images,*option == '-' ?\n              MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          {\n            Image\n              *flatten_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            flatten_image=MergeImageLayers(*images,FlattenLayer,exception);\n            if (flatten_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=flatten_image;\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            Image\n              *fx_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            fx_image=FxImage(*images,argv[i+1],exception);\n            if (fx_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=fx_image;\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          {\n            Image\n              *hald_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            hald_image=RemoveFirstImageFromList(images);\n            if (hald_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) HaldClutImage(image,hald_image,exception);\n            hald_image=DestroyImage(hald_image);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"ift\",option+1) == 0)\n          {\n            Image\n              *fourier_image,\n              *magnitude_image,\n              *phase_image;\n\n            /*\n              Implements the inverse fourier discrete Fourier transform (DFT).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            magnitude_image=RemoveFirstImageFromList(images);\n            phase_image=RemoveFirstImageFromList(images);\n            if (phase_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            fourier_image=InverseFourierTransformImage(magnitude_image,\n              phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"insert\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q;\n\n            index=0;\n            if (*option != '+')\n              index=(ssize_t) StringToLong(argv[i+1]);\n            p=RemoveLastImageFromList(images);\n            if (p == (Image *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                status=MagickFalse;\n                break;\n              }\n            q=p;\n            if (index == 0)\n              PrependImageToList(images,q);\n            else\n              if (index == (ssize_t) GetImageListLength(*images))\n                AppendImageToList(images,q);\n              else\n                {\n                   q=GetImageFromList(*images,index-1);\n                   if (q == (Image *) NULL)\n                     {\n                       (void) ThrowMagickException(exception,GetMagickModule(),\n                         OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                       status=MagickFalse;\n                       break;\n                     }\n                  InsertImageInList(&q,p);\n                }\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            interpolate_method=(PixelInterpolateMethod) ParseCommandOption(\n              MagickInterpolateOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            Image\n              *layers;\n\n            LayerMethod\n              method;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            layers=(Image *) NULL;\n            method=(LayerMethod) ParseCommandOption(MagickLayerOptions,\n              MagickFalse,argv[i+1]);\n            switch (method)\n            {\n              case CoalesceLayer:\n              {\n                layers=CoalesceImages(*images,exception);\n                break;\n              }\n              case CompareAnyLayer:\n              case CompareClearLayer:\n              case CompareOverlayLayer:\n              default:\n              {\n                layers=CompareImagesLayers(*images,method,exception);\n                break;\n              }\n              case MergeLayer:\n              case FlattenLayer:\n              case MosaicLayer:\n              case TrimBoundsLayer:\n              {\n                layers=MergeImageLayers(*images,method,exception);\n                break;\n              }\n              case DisposeLayer:\n              {\n                layers=DisposeImages(*images,exception);\n                break;\n              }\n              case OptimizeImageLayer:\n              {\n                layers=OptimizeImageLayers(*images,exception);\n                break;\n              }\n              case OptimizePlusLayer:\n              {\n                layers=OptimizePlusImageLayers(*images,exception);\n                break;\n              }\n              case OptimizeTransLayer:\n              {\n                OptimizeImageTransparency(*images,exception);\n                break;\n              }\n              case RemoveDupsLayer:\n              {\n                RemoveDuplicateLayers(images,exception);\n                break;\n              }\n              case RemoveZeroLayer:\n              {\n                RemoveZeroDelayLayers(images,exception);\n                break;\n              }\n              case OptimizeLayer:\n              {\n                /*\n                  General Purpose, GIF Animation Optimizer.\n                */\n                layers=CoalesceImages(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=OptimizeImageLayers(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=(Image *) NULL;\n                OptimizeImageTransparency(*images,exception);\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n              case CompositeLayer:\n              {\n                CompositeOperator\n                  compose;\n\n                Image\n                  *source;\n\n                RectangleInfo\n                  geometry;\n\n                /*\n                  Split image sequence at the first 'NULL:' image.\n                */\n                source=(*images);\n                while (source != (Image *) NULL)\n                {\n                  source=GetNextImageInList(source);\n                  if ((source != (Image *) NULL) &&\n                      (LocaleCompare(source->magick,\"NULL\") == 0))\n                    break;\n                }\n                if (source != (Image *) NULL)\n                  {\n                    if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                        (GetNextImageInList(source) == (Image *) NULL))\n                      source=(Image *) NULL;\n                    else\n                      {\n                        /*\n                          Separate the two lists, junk the null: image.\n                        */\n                        source=SplitImageList(source->previous);\n                        DeleteImageFromList(&source);\n                      }\n                  }\n                if (source == (Image *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                    status=MagickFalse;\n                    break;\n                  }\n                /*\n                  Adjust offset with gravity and virtual canvas.\n                */\n                SetGeometry(*images,&geometry);\n                (void) ParseAbsoluteGeometry((*images)->geometry,&geometry);\n                geometry.width=source->page.width != 0 ?\n                  source->page.width : source->columns;\n                geometry.height=source->page.height != 0 ?\n                 source->page.height : source->rows;\n                GravityAdjustGeometry((*images)->page.width != 0 ?\n                  (*images)->page.width : (*images)->columns,\n                  (*images)->page.height != 0 ? (*images)->page.height :\n                  (*images)->rows,(*images)->gravity,&geometry);\n                compose=OverCompositeOp;\n                option=GetImageOption(mogrify_info,\"compose\");\n                if (option != (const char *) NULL)\n                  compose=(CompositeOperator) ParseCommandOption(\n                    MagickComposeOptions,MagickFalse,option);\n                CompositeLayers(*images,compose,source,geometry.x,geometry.y,\n                  exception);\n                source=DestroyImageList(source);\n                break;\n              }\n            }\n            if (layers == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=layers;\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          {\n            Image\n              *maximum_image;\n\n            /*\n              Maximum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            maximum_image=EvaluateImages(*images,MaxEvaluateOperator,exception);\n            if (maximum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=maximum_image;\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          {\n            Image\n              *minimum_image;\n\n            /*\n              Minimum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            minimum_image=EvaluateImages(*images,MinEvaluateOperator,exception);\n            if (minimum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=minimum_image;\n            break;\n          }\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            Image\n              *morph_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            morph_image=MorphImages(*images,StringToUnsignedLong(argv[i+1]),\n              exception);\n            if (morph_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=morph_image;\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          {\n            Image\n              *mosaic_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            mosaic_image=MergeImageLayers(*images,MosaicLayer,exception);\n            if (mosaic_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=mosaic_image;\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            double\n              *arguments;\n\n            Image\n              *polynomial_image;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            /*\n              Polynomial image.\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            args=InterpretImageProperties(mogrify_info,*images,argv[i+1],\n              exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*images)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            polynomial_image=PolynomialImage(*images,number_arguments >> 1,\n              arguments,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            if (polynomial_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=polynomial_image;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            char\n              *string;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            string=InterpretImageProperties(mogrify_info,*images,argv[i+1],\n              exception);\n            if (string == (char *) NULL)\n              break;\n            (void) FormatLocaleFile(stdout,\"%s\",string);\n            string=DestroyString(string);\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            char\n              **arguments;\n\n            int\n              j,\n              number_arguments;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            arguments=StringToArgv(argv[i+1],&number_arguments);\n            if (arguments == (char **) NULL)\n              break;\n            if ((argc > 1) && (strchr(arguments[1],'=') != (char *) NULL))\n              {\n                char\n                  breaker,\n                  quote,\n                  *token;\n\n                const char\n                  *argument;\n\n                int\n                  next,\n                  token_status;\n\n                size_t\n                  length;\n\n                TokenInfo\n                  *token_info;\n\n                /*\n                  Support old style syntax, filter=\"-option arg\".\n                */\n                length=strlen(argv[i+1]);\n                token=(char *) NULL;\n                if (~length >= (MagickPathExtent-1))\n                  token=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n                    sizeof(*token));\n                if (token == (char *) NULL)\n                  break;\n                next=0;\n                argument=argv[i+1];\n                token_info=AcquireTokenInfo();\n                token_status=Tokenizer(token_info,0,token,length,argument,\"\",\n                  \"=\",\"\\\"\",'\\0',&breaker,&next,&quote);\n                token_info=DestroyTokenInfo(token_info);\n                if (token_status == 0)\n                  {\n                    const char\n                      *arg;\n\n                    arg=(&(argument[next]));\n                    (void) InvokeDynamicImageFilter(token,&(*images),1,&arg,\n                      exception);\n                  }\n                token=DestroyString(token);\n                break;\n              }\n            (void) SubstituteString(&arguments[1],\"-\",\"\");\n            (void) InvokeDynamicImageFilter(arguments[1],&(*images),\n              number_arguments-2,(const char **) arguments+2,exception);\n            for (j=0; j < number_arguments; j++)\n              arguments[j]=DestroyString(arguments[j]);\n            arguments=(char **) RelinquishMagickMemory(arguments);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          {\n            ReverseImageList(images);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            Image\n              *smush_image;\n\n            ssize_t\n              offset;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            offset=(ssize_t) StringToLong(argv[i+1]);\n            smush_image=SmushImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,offset,exception);\n            if (smush_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=smush_image;\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q,\n              *u,\n              *v;\n\n            ssize_t\n              swap_index;\n\n            index=(-1);\n            swap_index=(-2);\n            if (*option != '+')\n              {\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                swap_index=(-1);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                index=(ssize_t) geometry_info.rho;\n                if ((flags & SigmaValue) != 0)\n                  swap_index=(ssize_t) geometry_info.sigma;\n              }\n            p=GetImageFromList(*images,index);\n            q=GetImageFromList(*images,swap_index);\n            if ((p == (Image *) NULL) || (q == (Image *) NULL))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",(*images)->filename);\n                status=MagickFalse;\n                break;\n              }\n            if (p == q)\n              break;\n            u=CloneImage(p,0,0,MagickTrue,exception);\n            if (u == (Image *) NULL)\n              break;\n            v=CloneImage(q,0,0,MagickTrue,exception);\n            if (v == (Image *) NULL)\n              {\n                u=DestroyImage(u);\n                break;\n              }\n            ReplaceImageInList(&p,v);\n            ReplaceImageInList(&q,u);\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            char\n              key[MagickPathExtent];\n\n            Image\n              *write_images;\n\n            ImageInfo\n              *write_info;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",\n              argv[i+1]);\n            (void) DeleteImageRegistry(key);\n            write_images=(*images);\n            if (*option == '+')\n              write_images=CloneImageList(*images,exception);\n            write_info=CloneImageInfo(mogrify_info);\n            status&=WriteImages(write_info,write_images,argv[i+1],exception);\n            write_info=DestroyImageInfo(write_info);\n            if (*option == '+')\n              write_images=DestroyImageList(write_images);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status&=MogrifyImageInfo(image_info,argc,argv,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImages() applies image processing options to a sequence of images as\n%  prescribed by command line options.\n%\n%  The format of the MogrifyImage method is:\n%\n%      MagickBooleanType MogrifyImages(ImageInfo *image_info,\n%        const MagickBooleanType post,const int argc,const char **argv,\n%        Image **images,Exceptioninfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o post: If true, post process image list operators otherwise pre-process.\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o images: pointer to a pointer of the first image in image list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MogrifyImages(ImageInfo *image_info,\n  const MagickBooleanType post,const int argc,const char **argv,\n  Image **images,ExceptionInfo *exception)\n{\n#define MogrifyImageTag  \"Mogrify/Image\"\n\n  MagickStatusType\n    status;\n\n  MagickBooleanType\n    proceed;\n\n  size_t\n    n;\n\n  register ssize_t\n    i;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (images == (Image **) NULL)\n    return(MogrifyImage(image_info,argc,argv,images,exception));\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  (void) SetImageInfoProgressMonitor(image_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  status=MagickTrue;\n#if 0\n  (void) FormatLocaleFile(stderr, \"mogrify start %s %d (%s)\\n\",argv[0],argc,\n    post?\"post\":\"pre\");\n#endif\n  /*\n    Pre-process multi-image sequence operators\n  */\n  if (post == MagickFalse)\n    status&=MogrifyImageList(image_info,argc,argv,images,exception);\n  /*\n    For each image, process simple single image operators\n  */\n  i=0;\n  n=GetImageListLength(*images);\n  for ( ; ; )\n  {\n#if 0\n  (void) FormatLocaleFile(stderr,\"mogrify %ld of %ld\\n\",(long)\n    GetImageIndexInList(*images),(long)GetImageListLength(*images));\n#endif\n    status&=MogrifyImage(image_info,argc,argv,images,exception);\n    proceed=SetImageProgress(*images,MogrifyImageTag,(MagickOffsetType) i, n);\n    if (proceed == MagickFalse)\n      break;\n    if ( (*images)->next == (Image *) NULL )\n      break;\n    *images=(*images)->next;\n    i++;\n  }\n  assert( *images != (Image *) NULL );\n#if 0\n  (void) FormatLocaleFile(stderr,\"mogrify end %ld of %ld\\n\",(long)\n    GetImageIndexInList(*images),(long)GetImageListLength(*images));\n#endif\n  /*\n    Post-process, multi-image sequence operators\n  */\n  *images=GetFirstImageInList(*images);\n  if (post != MagickFalse)\n    status&=MogrifyImageList(image_info,argc,argv,images,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%          OOO   PPPP   EEEE  RRRR    AA   TTTTT  III   OOO   N   N           %\n%         O   O  P   P  E     R   R  A  A    T     I   O   O  NN  N           %\n%         O   O  PPPP   EEE   RRRR   AAAA    T     I   O   O  N N N           %\n%         O   O  P      E     R R    A  A    T     I   O   O  N  NN           %\n%          OOO   P      EEEE  R  RR  A  A    T    III   OOO   N   N           %\n%                                                                             %\n%                                                                             %\n%                         CLI Magick Option Methods                           %\n%                                                                             %\n%                              Dragon Computing                               %\n%                              Anthony Thyssen                                %\n%                               September 2011                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Apply the given options (settings, and simple, or sequence operations) to\n% the given image(s) according to the current \"image_info\", \"draw_info\", and\n% \"quantize_info\" settings, stored in a special CLI Image Wand.\n%\n% The final goal is to allow the execution in a strict one option at a time\n% manner that is needed for 'pipelining and file scripting' of options in\n% IMv7.\n%\n% Anthony Thyssen, September 2011\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/mogrify.h\"\n#include \"MagickWand/operation.h\"\n#include \"MagickWand/wand.h\"\n#include \"MagickWand/wandcli.h\"\n#include \"MagickWand/wandcli-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nstatic const char\n  MogrifyAlphaColor[] = \"#bdbdbd\",  /* slightly darker gray */\n  MogrifyBackgroundColor[] = \"#fff\",  /* white */\n  MogrifyBorderColor[] = \"#dfdfdf\";  /* sRGB gray */\n\f\n/*\n  Define declarations.\n*/\n#define USE_WAND_METHODS  1\n#define MAX_STACK_DEPTH  32\n#define UNDEFINED_COMPRESSION_QUALITY  0UL\n\n/* FUTURE: why is this default so specific? */\n#define DEFAULT_DISSIMILARITY_THRESHOLD \"0.31830988618379067154\"\n\n/* For Debugging Geometry Input */\n#define ReportGeometry(flags,info) \\\n  (void) FormatLocaleFile(stderr, \"Geometry = 0x%04X : %lg x %lg %+lg %+lg\\n\", \\\n       flags, info.rho, info.sigma, info.xi, info.psi )\n\f\n/*\n** Function to report on the progress of image operations\n*/\nstatic MagickBooleanType MonitorProgress(const char *text,\n  const MagickOffsetType offset,const MagickSizeType extent,\n  void *wand_unused(client_data))\n{\n  char\n    message[MagickPathExtent],\n    tag[MagickPathExtent];\n\n  const char\n    *locale_message;\n\n  register char\n    *p;\n\n  magick_unreferenced(client_data);\n\n  if ((extent <= 1) || (offset < 0) || (offset >= (MagickOffsetType) extent))\n    return(MagickTrue);\n  if ((offset != (MagickOffsetType) (extent-1)) && ((offset % 50) != 0))\n    return(MagickTrue);\n  (void) CopyMagickString(tag,text,MagickPathExtent);\n  p=strrchr(tag,'/');\n  if (p != (char *) NULL)\n    *p='\\0';\n  (void) FormatLocaleString(message,MagickPathExtent,\"Monitor/%s\",tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == message)\n    locale_message=tag;\n  if (p == (char *) NULL)\n    (void) FormatLocaleFile(stderr,\"%s: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  else\n    (void) FormatLocaleFile(stderr,\"%s[%s]: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,p+1,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  if (offset == (MagickOffsetType) (extent-1))\n    (void) FormatLocaleFile(stderr,\"\\n\");\n  (void) fflush(stderr);\n  return(MagickTrue);\n}\n\n/*\n** GetImageCache() will read an image into a image cache if not already\n** present then return the image that is in the cache under that filename.\n*/\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  if (path != (const char *) NULL)\n    (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\n/*\n  SparseColorOption() parse the complex -sparse-color argument into an\n  an array of floating point values than call SparseColorImage().\n  Argument is a complex mix of floating-point pixel coodinates, and color\n  specifications (or direct floating point numbers).  The number of floats\n  needed to represent a color varies depending on the current channel\n  setting.\n\n  This really should be in MagickCore, so that other API's can make use of it.\n*/\nstatic Image *SparseColorOption(const Image *image,\n  const SparseColorMethod method,const char *arguments,ExceptionInfo *exception)\n{\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    *sparse_arguments;\n\n  Image\n    *sparse_image;\n\n  PixelInfo\n    color;\n\n  MagickBooleanType\n    error;\n\n  register size_t\n    x;\n\n  size_t\n    number_arguments,\n    number_colors;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Limit channels according to image\n    add up number of values needed per color.\n  */\n  number_colors=0;\n  if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    number_colors++;\n  if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n      image->alpha_trait != UndefinedPixelTrait)\n    number_colors++;\n\n  /*\n    Read string, to determine number of arguments needed,\n  */\n  p=arguments;\n  x=0;\n  while( *p != '\\0' )\n  {\n    GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == ',' ) continue;\n    if ( isalpha((int) token[0]) || token[0] == '#' )\n      x += number_colors;  /* color argument found */\n    else\n      x++;   /* floating point argument */\n  }\n  /* control points and color values */\n  if ((x % (2+number_colors)) != 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\", \"sparse-color\",\n        \"Invalid number of Arguments\");\n      return( (Image *) NULL);\n    }\n  error=MagickFalse;\n  number_arguments=x;\n\n  /* Allocate and fill in the floating point arguments */\n  sparse_arguments=(double *) AcquireQuantumMemory(number_arguments,\n    sizeof(*sparse_arguments));\n  if (sparse_arguments == (double *) NULL) {\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"MemoryAllocationFailed\",\"%s\",\"SparseColorOption\");\n    return( (Image *) NULL);\n  }\n  (void) memset(sparse_arguments,0,number_arguments*\n    sizeof(*sparse_arguments));\n  p=arguments;\n  x=0;\n  while( *p != '\\0' && x < number_arguments ) {\n    /* X coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of X-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* Y coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of Y-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* color name or function given in string argument */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      /* Color string given */\n      (void) QueryColorCompliance(token,AllCompliance,&color,\n                exception);\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.red;\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.green;\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.blue;\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        sparse_arguments[x++] = QuantumScale*color.black;\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        sparse_arguments[x++] = QuantumScale*color.alpha;\n    }\n    else {\n      /* Colors given as a set of floating point values - experimental */\n      /* NB: token contains the first floating point value to use! */\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n    }\n  }\n  if (error != MagickFalse)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      return((Image *) NULL);\n    }\n  if (number_arguments != x)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\",\"sparse-color\",\"Argument Parsing Error\");\n      return((Image *) NULL);\n    }\n  /* Call the Sparse Color Interpolation function with the parsed arguments */\n  sparse_image=SparseColorImage(image,method,number_arguments,sparse_arguments,\n    exception);\n  sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n  return( sparse_image );\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C L I S e t t i n g O p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISettingOptionInfo() applies a single settings option into a CLI wand\n%  holding the image_info, draw_info, quantize_info structures that will be\n%  used when processing the images.\n%\n%  These options do no require images to be present in the CLI wand for them\n%  to be able to be set, in which case they will generally be applied to image\n%  that are read in later\n%\n%  Options handled by this function are listed in CommandOptions[] of\n%  \"option.c\" that is one of \"SettingOptionFlags\" option flags.\n%\n%  The format of the CLISettingOptionInfo method is:\n%\n%    void CLISettingOptionInfo(MagickCLI *cli_wand,\n%               const char *option, const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option: The option string to be set\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently only used by \"-limit\"\n%\n*/\nWandPrivate void CLISettingOptionInfo(MagickCLI *cli_wand,\n     const char *option,const char *arg1n, const char *arg2n)\n{\n  ssize_t\n    parse;     /* option argument parsing (string to value table lookup) */\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define IfSetOption       (*option=='-')\n#define ArgBoolean        IfSetOption ? MagickTrue : MagickFalse\n#define ArgBooleanNot     IfSetOption ? MagickFalse : MagickTrue\n#define ArgBooleanString  (IfSetOption?\"true\":\"false\")\n#define ArgOption(def)    (IfSetOption?arg1:(const char *)(def))\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Setting Option: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1n,arg2n);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n#if 1\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n#endif\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adjoin\",option+1) == 0)\n        {\n          _image_info->adjoin = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"affine\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-draw 'affine ...'\");\n          if (IfSetOption)\n            (void) ParseAffineGeometry(arg1,&_draw_info->affine,_exception);\n          else\n            GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"antialias\",option+1) == 0)\n        {\n          _image_info->antialias =\n            _draw_info->stroke_antialias =\n              _draw_info->text_antialias = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"attenuate\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"1.0\"));\n          break;\n        }\n      if (LocaleCompare(\"authenticate\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used directly for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: if _image_info->background_color is not set then\n             we should fall back to per-image background_color\n\n             At this time -background will 'wipe out' the per-image\n             background color!\n\n             Better error handling of QueryColorCompliance() needed.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyBackgroundColor),AllCompliance,\n             &_image_info->background_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"bias\",option+1) == 0)\n        {\n          /* FUTURE: bias OBSOLETED, replaced by Artifact \"convolve:bias\"\n             as it is actually rarely used except in direct convolve operations\n             Usage outside a direct convolve operation is actally non-sensible!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,\"convolve:bias\",ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"blue-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders including PNG\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"bordercolor\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             SyncImageSettings() used to set per-image attribute.\n             Better error checking of QueryColorCompliance().\n          */\n          if (IfSetOption)\n            {\n              (void) SetImageOption(_image_info,option+1,arg1);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_image_info->border_color,_exception);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_draw_info->border_color,_exception);\n              break;\n            }\n          (void) DeleteImageOption(_image_info,option+1);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_image_info->border_color,_exception);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_draw_info->border_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"box\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-undercolor\");\n          CLISettingOptionInfo(cli_wand,\"-undercolor\",arg1, arg2);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"cache\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          limit=MagickResourceInfinity;\n          if (LocaleCompare(\"unlimited\",arg1) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg1,100.0);\n          (void) SetMagickResourceLimit(MemoryResource,limit);\n          (void) SetMagickResourceLimit(MapResource,2*limit);\n          break;\n        }\n      if (LocaleCompare(\"caption\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* Setting used for new images via AquireImage()\n             But also used as a SimpleImageOperator\n             Undefined colorspace means don't modify images on\n             read or as a operation */\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n             ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          _image_info->colorspace=(ColorspaceType) parse;\n          break;\n        }\n      if (LocaleCompare(\"comment\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compose\",option+1) == 0)\n        {\n          /* FUTURE: _image_info should be used,\n             SyncImageSettings() used to set per-image attribute. - REMOVE\n\n             This setting should NOT be used to set image 'compose'\n             \"-layer\" operators shoud use _image_info if defined otherwise\n             they should use a per-image compose setting.\n          */\n          parse = ParseCommandOption(MagickComposeOptions,MagickFalse,\n                          ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedComposeOperator\",\n                                      option,arg1);\n          _image_info->compose=(CompositeOperator) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compress\",option+1) == 0)\n        {\n          /* FUTURE: What should be used?  _image_info  or ImageOption ???\n             The former is more efficent, but Crisy prefers the latter!\n             SyncImageSettings() used to set per-image attribute.\n\n             The coders appears to use _image_info, not Image_Option\n             however the image attribute (for save) is set from the\n             ImageOption!\n\n             Note that \"undefined\" is a different setting to \"none\".\n          */\n          parse = ParseCommandOption(MagickCompressOptions,MagickFalse,\n                     ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageCompression\",\n                                      option,arg1);\n          _image_info->compression=(CompressionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"debug\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"none\");\n          parse = ParseCommandOption(MagickLogEventOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEventType\",\n                                      option,arg1);\n          (void) SetLogEventMask(arg1);\n          _image_info->debug=IsEventLogging();   /* extract logging*/\n          cli_wand->wand.debug=IsEventLogging();\n          break;\n        }\n      if (LocaleCompare(\"define\",option+1) == 0)\n        {\n          if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n            {\n              if (IfSetOption)\n                (void) DefineImageRegistry(StringRegistryType,arg1+9,_exception);\n              else\n                (void) DeleteImageRegistry(arg1+9);\n              break;\n            }\n          /* DefineImageOption() equals SetImageOption() but with '=' */\n          if (IfSetOption)\n            (void) DefineImageOption(_image_info,arg1);\n          else if (DeleteImageOption(_image_info,arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"NoSuchOption\",option,arg1);\n          break;\n        }\n      if (LocaleCompare(\"delay\",option+1) == 0)\n        {\n          /* Only used for new images via AcquireImage()\n             FUTURE: Option should also be used for \"-morph\" (color morphing)\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"density\",option+1) == 0)\n        {\n          /* FUTURE: strings used in _image_info attr and _draw_info!\n             Basically as density can be in a XxY form!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) CloneString(&_image_info->density,ArgOption(NULL));\n          (void) CloneString(&_draw_info->density,_image_info->density);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* This is also a SimpleImageOperator! for 8->16 vaule trunc !!!!\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->depth=IfSetOption?StringToUnsignedLong(arg1)\n                                       :MAGICKCORE_QUANTUM_DEPTH;\n          break;\n        }\n      if (LocaleCompare(\"direction\",option+1) == 0)\n        {\n          /* Image Option is only used to set _draw_info */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDirectionOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDirectionType\",\n                                      option,arg1);\n          _draw_info->direction=(DirectionType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"display\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->server_name,ArgOption(NULL));\n          (void) CloneString(&_draw_info->server_name,_image_info->server_name);\n          break;\n        }\n      if (LocaleCompare(\"dispose\",option+1) == 0)\n        {\n          /* only used in setting new images */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDisposeOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDisposeMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"undefined\"));\n          break;\n        }\n      if (LocaleCompare(\"dissimilarity-threshold\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          arg1=ArgOption(DEFAULT_DISSIMILARITY_THRESHOLD);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"dither\",option+1) == 0)\n        {\n          /* _image_info attr (on/off), _quantize_info attr (on/off)\n             but also ImageInfo and _quantize_info method!\n             FUTURE: merge the duality of the dithering options\n          */\n          _image_info->dither = ArgBoolean;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"none\"));\n          _quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n             MagickDitherOptions,MagickFalse,ArgOption(\"none\"));\n          if (_quantize_info->dither_method == NoDitherMethod)\n            _image_info->dither = MagickFalse;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"encoding\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->encoding,ArgOption(\"undefined\"));\n          (void) SetImageOption(_image_info,option+1,_draw_info->encoding);\n          break;\n        }\n      if (LocaleCompare(\"endian\",option+1) == 0)\n        {\n          /* Both _image_info attr and ImageInfo */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickEndianOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEndianType\",\n                                      option,arg1);\n          /* FUTURE: check alloc/free of endian string!  - remove? */\n          _image_info->endian=(EndianType) (*arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"extract\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->extract,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"family\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->family,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"features\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:features\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"fill\",option+1) == 0)\n        {\n          /* Set \"fill\" OR \"fill-pattern\" in _draw_info\n             The original fill color is preserved if a fill-pattern is given.\n             That way it does not effect other operations that directly using\n             the fill color and, can be retored using \"+tile\".\n          */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->fill_pattern != (Image *) NULL)\n            _draw_info->fill_pattern=DestroyImage(_draw_info->fill_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->fill_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->fill=color;\n          break;\n        }\n      if (LocaleCompare(\"filter\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickFilterOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageFilter\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"font\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->font,ArgOption(NULL));\n          (void) CloneString(&_image_info->font,_draw_info->font);\n          break;\n        }\n      if (LocaleCompare(\"format\",option+1) == 0)\n        {\n          /* FUTURE: why the ping test, you could set ping after this! */\n          /*\n          register const char\n            *q;\n\n          for (q=strchr(arg1,'%'); q != (char *) NULL; q=strchr(q+1,'%'))\n            if (strchr(\"Agkrz@[#\",*(q+1)) != (char *) NULL)\n              _image_info->ping=MagickFalse;\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"fuzz\",option+1) == 0)\n        {\n          /* Option used to set image fuzz! unless blank canvas (from color)\n             Image attribute used for color compare operations\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: Can't find anything else using _image_info->fuzz directly!\n                     convert structure attribute to 'option' string\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->fuzz=StringToDoubleInterval(arg1,(double)\n                QuantumRange+1.0);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gravity\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"none\");\n          parse = ParseCommandOption(MagickGravityOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedGravityType\",\n                                      option,arg1);\n          _draw_info->gravity=(GravityType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"green-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             SyncImageSettings() used to set per-image attribute.\n             Used directly by many coders\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"highlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:highlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",option+1) == 0)\n        {\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n            arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityType\",\n              option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"intent\",option+1) == 0)\n        {\n          /* Only used by coders: MIFF, MPC, BMP, PNG\n             and for image profile call to AcquireTransformThreadSet()\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickIntentOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntentType\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interlace\",option+1) == 0)\n        {\n          /* _image_info is directly used by coders (so why an image setting?)\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterlaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterlaceType\",\n                                      option,arg1);\n          _image_info->interlace=(InterlaceType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interline_spacing=StringToDouble(ArgOption(\"0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"interpolate\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterpolateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterpolateMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interword_spacing=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kerning\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->kerning=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"label\",option+1) == 0)\n        {\n          /* only used for new images - not in SyncImageOptions() */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"limit\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          limit=MagickResourceInfinity;\n          parse= ParseCommandOption(MagickResourceOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedResourceType\",\n                option,arg1);\n          if (LocaleCompare(\"unlimited\",arg2) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg2,100.0);\n          (void) SetMagickResourceLimit((ResourceType)parse,limit);\n          break;\n        }\n      if (LocaleCompare(\"log\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if ((strchr(arg1,'%') == (char *) NULL))\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) SetLogFormat(arg1);\n          }\n          break;\n        }\n      if (LocaleCompare(\"lowlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:lowlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"loop\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"mattecolor\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyAlphaColor),\n            AllCompliance,&_image_info->matte_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          parse=ParseCommandOption(MagickMetricOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedMetricType\",\n                option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"moments\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:moments\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageInfoProgressMonitor(_image_info, IfSetOption?\n                MonitorProgress: (MagickProgressMonitor) NULL, (void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          /* Setting (used by some input coders!) -- why?\n             Warning: This is also Special '-type' SimpleOperator\n          */\n          _image_info->monochrome= ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"orient\",option+1) == 0)\n        {\n          /* Is not used when defining for new images.\n             This makes it more of a 'operation' than a setting\n             FUTURE: make set meta-data operator instead.\n             SyncImageSettings() used to set per-image attribute.\n          */\n          parse=ParseCommandOption(MagickOrientationOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageOrientation\",\n                                      option,arg1);\n          _image_info->orientation=(OrientationType)parse;\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",option+1) == 0)\n        {\n          /* Only used for new images and image generators.\n             SyncImageSettings() used to set per-image attribute. ?????\n             That last is WRONG!!!!\n             FUTURE: adjust named 'page' sizes according density\n          */\n          char\n            *canonical_page,\n            page[MagickPathExtent];\n\n          const char\n            *image_option;\n\n          MagickStatusType\n            flags;\n\n          RectangleInfo\n            geometry;\n\n          if (!IfSetOption)\n            {\n              (void) DeleteImageOption(_image_info,option+1);\n              (void) CloneString(&_image_info->page,(char *) NULL);\n              break;\n            }\n          (void) memset(&geometry,0,sizeof(geometry));\n          image_option=GetImageOption(_image_info,\"page\");\n          if (image_option != (const char *) NULL)\n            flags=ParseAbsoluteGeometry(image_option,&geometry);\n          canonical_page=GetPageGeometry(arg1);\n          flags=ParseAbsoluteGeometry(canonical_page,&geometry);\n          canonical_page=DestroyString(canonical_page);\n          (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu\",\n            (unsigned long) geometry.width,(unsigned long) geometry.height);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu%+ld%+ld\",\n              (unsigned long) geometry.width,(unsigned long) geometry.height,\n              (long) geometry.x,(long) geometry.y);\n          (void) SetImageOption(_image_info,option+1,page);\n          (void) CloneString(&_image_info->page,page);\n          break;\n        }\n      if (LocaleCompare(\"ping\",option+1) == 0)\n        {\n          _image_info->ping = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"pointsize\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            _image_info->pointsize =\n            _draw_info->pointsize =\n              StringToDouble(arg1,(char **) NULL);\n          }\n          else {\n            _image_info->pointsize=0.0; /* unset pointsize */\n            _draw_info->pointsize=12.0;\n          }\n          break;\n        }\n      if (LocaleCompare(\"precision\",option+1) == 0)\n        {\n          arg1=ArgOption(\"-1\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetMagickPrecision(StringToInteger(arg1));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'q':\n    {\n      if (LocaleCompare(\"quality\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->quality= IfSetOption ? StringToUnsignedLong(arg1)\n                                            : UNDEFINED_COMPRESSION_QUALITY;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"quantize\",option+1) == 0)\n        {\n          /* Just a set direct in _quantize_info */\n          arg1=ArgOption(\"undefined\");\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",\n                 option,arg1);\n          _quantize_info->colorspace=(ColorspaceType)parse;\n          break;\n        }\n      if (LocaleCompare(\"quiet\",option+1) == 0)\n        {\n          /* FUTURE: if two -quiet is performed you can not do +quiet!\n             This needs to be checked over thoughly.\n          */\n          static WarningHandler\n            warning_handler = (WarningHandler) NULL;\n\n          WarningHandler\n            tmp = SetWarningHandler((WarningHandler) NULL);\n\n          if ( tmp != (WarningHandler) NULL)\n            warning_handler = tmp; /* remember the old handler */\n          if (!IfSetOption)        /* set the old handler */\n            warning_handler=SetWarningHandler(warning_handler);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"red-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n        /* FUTURE: to be replaced by a 'fatal-level' type setting */\n        break;\n      if (LocaleCompare(\"render\",option+1) == 0)\n        {\n          /* _draw_info only setting */\n          _draw_info->render= ArgBooleanNot;\n          break;\n        }\n      if (LocaleCompare(\"respect-parenthesis\",option+1) == 0)\n        {\n          /* link image and setting stacks - option is itself saved on stack! */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n        {\n          /* FUTURE: should be converted to jpeg:sampling_factor */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CloneString(&_image_info->sampling_factor,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"scene\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set this as a per-image attribute.\n             What ??? Why ????\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _image_info->scene=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"seed\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          SetRandomSecretKey(\n               IfSetOption ? (unsigned long) StringToUnsignedLong(arg1)\n                           : (unsigned long) time((time_t *) NULL));\n          break;\n        }\n      if (LocaleCompare(\"size\",option+1) == 0)\n        {\n          /* FUTURE: string in _image_info -- convert to Option ???\n             Look at the special handling for \"size\" in SetImageOption()\n           */\n          (void) CloneString(&_image_info->size,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"stretch\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStretchOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStretchType\",\n                 option,arg1);\n          _draw_info->stretch=(StretchType) parse;\n          break;\n        }\n      if (LocaleCompare(\"stroke\",option+1) == 0)\n        {\n          /* set stroke color OR stroke-pattern\n             UPDATE: ensure stroke color is not destroyed is a pattern\n             is given. Just in case the color is also used for other purposes.\n           */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->stroke_pattern != (Image *) NULL)\n            _draw_info->stroke_pattern=DestroyImage(_draw_info->stroke_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->stroke_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->stroke=color;\n          break;\n        }\n      if (LocaleCompare(\"strokewidth\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->stroke_width=StringToDouble(ArgOption(\"1.0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"style\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStyleOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStyleType\",\n                 option,arg1);\n          _draw_info->style=(StyleType) parse;\n          break;\n        }\n#if 0\n      if (LocaleCompare(\"subimage-search\",option+1) == 0)\n        {\n        /* FUTURE: this is only used by CompareImages() which is used\n            only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n#endif\n      if (LocaleCompare(\"synchronize\",option+1) == 0)\n        {\n          /* FUTURE: syncronize to storage - but what does that mean? */\n          _image_info->synchronize = ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"taint\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"texture\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          /* FUTURE: move _image_info string to option splay-tree\n             Other than \"montage\" what uses \"texture\" ????\n          */\n          (void) CloneString(&_image_info->texture,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"tile\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          _draw_info->fill_pattern=IfSetOption\n                                 ?GetImageCache(_image_info,arg1,_exception)\n                                 :DestroyImage(_draw_info->fill_pattern);\n          break;\n        }\n      if (LocaleCompare(\"tile-offset\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. ??? */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"transparent-color\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             Note that +transparent-color, means fall-back to image\n             attribute so ImageOption is deleted, not set to a default.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n              &_image_info->transparent_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"treedepth\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _quantize_info->tree_depth=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          parse=ParseCommandOption(MagickTypeOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageType\",\n                 option,arg1);\n          _image_info->type=(ImageType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"undercolor\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n               &_draw_info->undercolor,_exception);\n          break;\n        }\n      if (LocaleCompare(\"units\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             Should this effect _draw_info X and Y resolution?\n             FUTURE: this probably should be part of the density setting\n          */\n          parse=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedUnitsType\",\n                 option,arg1);\n          _image_info->units=(ResolutionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: Remember all options become image artifacts\n             _image_info->verbose is only used by coders.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          _image_info->verbose= ArgBoolean;\n          _image_info->ping=MagickFalse; /* verbose can't be a ping */\n          break;\n        }\n      if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             This is VERY deep in the image caching structure.\n          */\n          parse=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedVirtualPixelMethod\",\n                 option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"weight\",option+1) == 0)\n        {\n          ssize_t\n            weight;\n\n          weight=ParseCommandOption(MagickWeightOptions,MagickFalse,arg1);\n          if (weight == -1)\n            weight=(ssize_t) StringToUnsignedLong(arg1);\n          _draw_info->weight=(size_t) weight;\n          break;\n        }\n      if (LocaleCompare(\"white-point\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if ((arg1 && arg1n) && (arg1 != arg1n ))\n    arg1=DestroyString((char *) arg1);\n  if ((arg2 && arg2n) && (arg2 != arg2n ))\n    arg2=DestroyString((char *) arg2);\n\n#undef _image_info\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfSetOption\n#undef ArgBoolean\n#undef ArgBooleanNot\n#undef ArgBooleanString\n#undef ArgOption\n\n  return;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I S i m p l e O p e r a t o r I m a g e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISimpleOperatorImages() applys one simple image operation given to all\n%  the images in the CLI wand, using any per-image or global settings that was\n%  previously saved in the CLI wand.\n%\n%  It is assumed that any such settings are up-to-date.\n%\n%  The format of the WandSimpleOperatorImages method is:\n%\n%    MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,const char *option,\n%      const char *arg1, const char *arg2,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings and images to be operated on\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%\n*/\n\n/*\n  CLISimpleOperatorImage() is an Internal subrountine to apply one simple\n  image operation to the current image pointed to by the CLI wand.\n\n  The image in the list may be modified in three different ways...\n    * directly modified (EG: -negate, -gamma, -level, -annotate, -draw),\n    * replaced by a new image (EG: -spread, -resize, -rotate, -morphology)\n    * one image replace by a list of images (-separate and -crop only!)\n\n  In each case the result replaces the single original image in the list, as\n  well as the pointer to the modified image (last image added if replaced by a\n  list of images) is returned.\n\n  As the image pointed to may be replaced, the first image in the list may\n  also change.  GetFirstImageInList() should be used by caller if they wish\n  return the Image pointer to the first image in list.\n*/\nstatic MagickBooleanType CLISimpleOperatorImage(MagickCLI *cli_wand,\n  const char *option, const char *arg1n, const char *arg2n,\n  ExceptionInfo *exception)\n{\n  Image *\n    new_image;\n\n  GeometryInfo\n    geometry_info;\n\n  RectangleInfo\n    geometry;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    parse;\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp        (*option=='-')\n#define IfPlusOp          (*option!='-')\n#define IsNormalOp        IfNormalOp ? MagickTrue : MagickFalse\n#define IsPlusOp          IfNormalOp ? MagickFalse : MagickTrue\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_image != (Image *) NULL);             /* an image must be present */\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",cli_wand->wand.name);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n#if 0\n  (void) FormatLocaleFile(stderr,\n    \"CLISimpleOperatorImage: \\\"%s\\\" \\\"%s\\\" \\\"%s\\\"\\n\",option,arg1,arg2);\n#endif\n\n  new_image = (Image *) NULL; /* the replacement image, if not null at end */\n  SetGeometryInfo(&geometry_info);\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=AdaptiveResizeImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveSharpenImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"alpha\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedAlphaChannelOption\",\n              option,arg1);\n          (void) SetImageAlphaChannel(_image,(AlphaChannelOption) parse,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"annotate\",option+1) == 0)\n        {\n          char\n            geometry[MagickPathExtent];\n\n          SetGeometryInfo(&geometry_info);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (flags == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          (void) CloneString(&_draw_info->text,arg2);\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"%+f%+f\",\n            geometry_info.xi,geometry_info.psi);\n          (void) CloneString(&_draw_info->geometry,geometry);\n          _draw_info->affine.sx=cos(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.rx=sin(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.ry=(-sin(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0))));\n          _draw_info->affine.sy=cos(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0)));\n          (void) AnnotateImage(_image,_draw_info,_exception);\n          GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n        {\n          (void) AutoGammaImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-level\",option+1) == 0)\n        {\n          (void) AutoLevelImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-orient\",option+1) == 0)\n        {\n          new_image=AutoOrientImage(_image,_image->orientation,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n        {\n          AutoThresholdMethod\n            method;\n\n          method=(AutoThresholdMethod) ParseCommandOption(\n            MagickAutoThresholdOptions,MagickFalse,arg1);\n          (void) AutoThresholdImage(_image,method,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"black-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) BlackThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blue-shift\",option+1) == 0)\n        {\n          geometry_info.rho=1.5;\n          if (IfNormalOp) {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          }\n          new_image=BlueShiftImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=BlurImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"border\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & (WidthValue | HeightValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          compose=OverCompositeOp;\n          value=GetImageOption(_image_info,\"compose\");\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          new_image=BorderImage(_image,&geometry,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n        {\n          double\n            brightness,\n            contrast;\n\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          brightness=geometry_info.rho;\n          contrast=0.0;\n          if ((flags & SigmaValue) != 0)\n            contrast=geometry_info.sigma;\n          (void) BrightnessContrastImage(_image,brightness,contrast,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"canny\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=10;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=30;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi/=100.0;\n              geometry_info.psi/=100.0;\n            }\n          new_image=CannyEdgeImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cdl\",option+1) == 0)\n        {\n          char\n            *color_correction_collection; /* Note: arguments do not have percent escapes expanded */\n\n          /*\n            Color correct with a color decision list.\n          */\n          color_correction_collection=FileToString(arg1,~0UL,_exception);\n          if (color_correction_collection == (char *) NULL)\n            break;\n          (void) ColorDecisionListImage(_image,color_correction_collection,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"channel\",option+1) == 0)\n        {\n          if (IfPlusOp)\n            {\n              (void) SetPixelChannelMask(_image,DefaultChannels);\n              break;\n            }\n          parse=ParseChannelOption(arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedChannelType\",option,\n              arg1);\n          (void) SetPixelChannelMask(_image,(ChannelType) parse);\n          break;\n        }\n      if (LocaleCompare(\"charcoal\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          new_image=CharcoalImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"chop\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=ChopImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clahe\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          (void) CLAHEImage(_image,geometry.width,geometry.height,\n            (size_t) geometry.x,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clamp\",option+1) == 0)\n        {\n          (void) ClampImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clip\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            (void) ClipImage(_image,_exception);\n          else /* \"+mask\" remove the write mask */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n              _exception);\n          break;\n        }\n      if (LocaleCompare(\"clip-mask\",option+1) == 0)\n        {\n          Image\n            *clip_mask;\n\n          if (IfPlusOp) {\n            /* use \"+clip-mask\" Remove the write mask for -clip-path */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,_exception);\n            break;\n          }\n          clip_mask=GetImageCache(_image_info,arg1,_exception);\n          if (clip_mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,clip_mask,_exception);\n          clip_mask=DestroyImage(clip_mask);\n          break;\n        }\n      if (LocaleCompare(\"clip-path\",option+1) == 0)\n        {\n          (void) ClipImagePath(_image,arg1,IsNormalOp,_exception);\n          /* Note: Use \"+clip-mask\" remove the write mask added */\n          break;\n        }\n      if (LocaleCompare(\"colorize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorizeImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"color-matrix\",option+1) == 0)\n        {\n          KernelInfo\n            *kernel;\n\n          kernel=AcquireKernelInfo(arg1,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorMatrixImage(_image,kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"colors\",option+1) == 0)\n        {\n          /* Reduce the number of colors in the image.\n             FUTURE: also provide 'plus version with image 'color counts'\n          */\n          _quantize_info->number_colors=StringToUnsignedLong(arg1);\n          if (_quantize_info->number_colors == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((_image->storage_class == DirectClass) ||\n              _image->colors > _quantize_info->number_colors)\n            (void) QuantizeImage(_quantize_info,_image,_exception);\n          else\n            (void) CompressImageColormap(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* WARNING: this is both a image_info setting (already done)\n                      and a operator to change image colorspace.\n\n             FUTURE: default colorspace should be sRGB!\n             Unless some type of 'linear colorspace' mode is set.\n\n             Note that +colorspace sets \"undefined\" or no effect on\n             new images, but forces images already in memory back to RGB!\n             That seems to be a little strange!\n          */\n          (void) TransformImageColorspace(_image,\n                    IfNormalOp ? _image_info->colorspace : sRGBColorspace,\n                    _exception);\n          break;\n        }\n      if (LocaleCompare(\"connected-components\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ConnectedComponentsImage(_image,(size_t)\n            StringToInteger(arg1),(CCObjectInfo **) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-level\":\"+level\");\n          (void) ContrastImage(_image,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(flags & SigmaValue) != 0 ? geometry_info.sigma :\n            black_point;\n          if ((flags & PercentValue) != 0) {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          white_point=(double) _image->columns*_image->rows-white_point;\n          (void) ContrastStretchImage(_image,black_point,white_point,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"convolve\",option+1) == 0)\n        {\n          double\n            gamma;\n\n          KernelInfo\n            *kernel_info;\n\n          register ssize_t\n            j;\n\n          kernel_info=AcquireKernelInfo(arg1,exception);\n          if (kernel_info == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          gamma=0.0;\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            gamma+=kernel_info->values[j];\n          gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma);\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            kernel_info->values[j]*=gamma;\n          new_image=MorphologyImage(_image,CorrelateMorphology,1,kernel_info,\n            _exception);\n          kernel_info=DestroyKernelInfo(kernel_info);\n          break;\n        }\n      if (LocaleCompare(\"crop\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=CropImageToTiles(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cycle\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CycleColormapImage(_image,(ssize_t) StringToLong(arg1),\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"decipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey == (StringInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n\n          (void) PasskeyDecipherImage(_image,passkey,_exception);\n          passkey=DestroyStringInfo(passkey);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* The _image_info->depth setting has already been set\n             We just need to apply it to all images in current sequence\n\n             WARNING: Depth from 8 to 16 causes 'quantum rounding to images!\n             That is it really is an operation, not a setting! Arrgghhh\n\n             FUTURE: this should not be an operator!!!\n          */\n          (void) SetImageDepth(_image,_image_info->depth,_exception);\n          break;\n        }\n      if (LocaleCompare(\"deskew\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          else\n            threshold=40.0*QuantumRange/100.0;\n          new_image=DeskewImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"despeckle\",option+1) == 0)\n        {\n          new_image=DespeckleImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"distort\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse = ParseCommandOption(MagickDistortOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n             CLIWandExceptArgBreak(OptionError,\"UnrecognizedDistortMethod\",\n                                      option,arg1);\n          if ((DistortMethod) parse == ResizeDistortion)\n            {\n               double\n                 resize_args[2];\n               /* Special Case - Argument is actually a resize geometry!\n               ** Convert that to an appropriate distortion argument array.\n               ** FUTURE: make a separate special resize operator\n                    Roll into a resize special operator */\n               if (IsGeometry(arg2) == MagickFalse)\n                 CLIWandExceptArgBreak(OptionError,\"InvalidGeometry\",\n                                           option,arg2);\n               (void) ParseRegionGeometry(_image,arg2,&geometry,_exception);\n               resize_args[0]=(double) geometry.width;\n               resize_args[1]=(double) geometry.height;\n               new_image=DistortImage(_image,(DistortMethod) parse,\n                    (size_t)2,resize_args,MagickTrue,_exception);\n               break;\n            }\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          new_image=DistortImage(_image,(DistortMethod) parse,(size_t)\n             count,args,IsPlusOp,_exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"draw\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->primitive,arg1);\n          (void) DrawImage(_image,_draw_info,_exception);\n          (void) CloneString(&_draw_info->primitive,(char *) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"edge\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=EdgeImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"emboss\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=EmbossImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"encipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey != (StringInfo *) NULL)\n            {\n              (void) PasskeyEncipherImage(_image,passkey,_exception);\n              passkey=DestroyStringInfo(passkey);\n            }\n          break;\n        }\n      if (LocaleCompare(\"enhance\",option+1) == 0)\n        {\n          new_image=EnhanceImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"equalize\",option+1) == 0)\n        {\n          (void) EqualizeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"evaluate\",option+1) == 0)\n        {\n          double\n            constant;\n\n          parse = ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n                 option,arg1);\n          if (IsGeometry(arg2) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          constant=StringToDoubleInterval(arg2,(double) QuantumRange+1.0);\n          (void) EvaluateImage(_image,(MagickEvaluateOperator)parse,constant,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"extent\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          if (geometry.width == 0)\n            geometry.width=_image->columns;\n          if (geometry.height == 0)\n            geometry.height=_image->rows;\n          new_image=ExtentImage(_image,&geometry,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"flip\",option+1) == 0)\n        {\n          new_image=FlipImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"flop\",option+1) == 0)\n        {\n          new_image=FlopImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"floodfill\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) QueryColorCompliance(arg2,AllCompliance,&target,_exception);\n          (void) FloodfillPaintImage(_image,_draw_info,&target,geometry.x,\n            geometry.y,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"frame\",option+1) == 0)\n        {\n          FrameInfo\n            frame_info;\n\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          value=GetImageOption(_image_info,\"compose\");\n            compose=OverCompositeOp;  /* use Over not _image->compose */\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          frame_info.width=geometry.width;\n          frame_info.height=geometry.height;\n          frame_info.outer_bevel=geometry.x;\n          frame_info.inner_bevel=geometry.y;\n          frame_info.x=(ssize_t) frame_info.width;\n          frame_info.y=(ssize_t) frame_info.height;\n          frame_info.width=_image->columns+2*frame_info.width;\n          frame_info.height=_image->rows+2*frame_info.height;\n          new_image=FrameImage(_image,&frame_info,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"function\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse=ParseCommandOption(MagickFunctionOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",\n                 option,arg1);\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          (void) FunctionImage(_image,(MagickFunction)parse,(size_t) count,args,\n               _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",option+1) == 0)\n        {\n          double\n            constant;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          constant=StringToDouble(arg1,(char **) NULL);\n#if 0\n          /* Using Gamma, via a cache */\n          if (IfPlusOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) GammaImage(_image,constant,_exception);\n#else\n          /* Using Evaluate POW, direct update of values - more accurite */\n          if (IfNormalOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) EvaluateImage(_image,PowEvaluateOperator,constant,_exception);\n          _image->gamma*=StringToDouble(arg1,(char **) NULL);\n#endif\n          /* Set gamma setting -- Old meaning of \"+gamma\"\n           * _image->gamma=StringToDouble(arg1,(char **) NULL);\n           */\n          break;\n        }\n      if (LocaleCompare(\"gaussian-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=GaussianBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"gaussian\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-gaussian-blur\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-gaussian-blur\",arg1,NULL,exception);\n        }\n      if (LocaleCompare(\"geometry\",option+1) == 0)\n        {\n          /*\n            Record Image offset for composition. (A Setting)\n            Resize last _image. (ListOperator)  -- DEPRECIATE\n            FUTURE: Why if no 'offset' does this resize ALL images?\n            Also why is the setting recorded in the IMAGE non-sense!\n          */\n          if (IfPlusOp)\n            { /* remove the previous composition geometry offset! */\n              if (_image->geometry != (char *) NULL)\n                _image->geometry=DestroyString(_image->geometry);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) CloneString(&_image->geometry,arg1);\n          else\n            new_image=ResizeImage(_image,geometry.width,geometry.height,\n              _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"grayscale\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickPixelIntensityOptions,\n            MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityMethod\",\n              option,arg1);\n          (void) GrayscaleImage(_image,(PixelIntensityMethod) parse,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hough-lines\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=40;\n          new_image=HoughLineImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,(size_t) geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"identify\",option+1) == 0)\n        {\n          const char\n            *format,\n            *text;\n\n          format=GetImageOption(_image_info,\"format\");\n          if (format == (char *) NULL)\n            {\n              (void) IdentifyImage(_image,stdout,_image_info->verbose,\n                _exception);\n              break;\n            }\n          text=InterpretImageProperties(_image_info,_image,format,_exception);\n          if (text == (char *) NULL)\n            CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n              option);\n          (void) fputs(text,stdout);\n          text=DestroyString((char *)text);\n          break;\n        }\n      if (LocaleCompare(\"implode\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ImplodeImage(_image,geometry_info.rho,_image->interpolate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"interpolative-resize\",option+1) == 0)\n        {\n          /* FUTURE: New to IMv7\n               Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=InterpolativeResizeImage(_image,geometry.width,\n               geometry.height,_image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kuwahara\",option+1) == 0)\n        {\n          /*\n            Edge preserving blur.\n          */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho-0.5;\n          new_image=KuwaharaImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"lat\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=AdaptiveThresholdImage(_image,(size_t) geometry_info.rho,\n               (size_t) geometry_info.sigma,(double) geometry_info.xi,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"level\",option+1) == 0)\n        {\n          double\n            black_point,\n            gamma,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) QuantumRange;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          gamma=1.0;\n          if ((flags & XiValue) != 0)\n            gamma=geometry_info.xi;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) (QuantumRange/100.0);\n              white_point*=(double) (QuantumRange/100.0);\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) QuantumRange-black_point;\n          if (IfPlusOp || ((flags & AspectValue) != 0))\n            (void) LevelizeImage(_image,black_point,white_point,gamma,_exception);\n          else\n            (void) LevelImage(_image,black_point,white_point,gamma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"level-colors\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          PixelInfo\n            black_point,\n            white_point;\n\n          p=(const char *) arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);  /* get black point color */\n          if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n            (void) QueryColorCompliance(token,AllCompliance,\n                      &black_point,_exception);\n          else\n            (void) QueryColorCompliance(\"#000000\",AllCompliance,\n                      &black_point,_exception);\n          if (isalpha((int) token[0]) || (token[0] == '#'))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == '\\0')\n            white_point=black_point; /* set everything to that color */\n          else\n            {\n              if ((isalpha((int) *token) == 0) && ((*token == '#') == 0))\n                GetNextToken(p,&p,MagickPathExtent,token); /* Get white point color. */\n              if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n                (void) QueryColorCompliance(token,AllCompliance,\n                           &white_point,_exception);\n              else\n                (void) QueryColorCompliance(\"#ffffff\",AllCompliance,\n                           &white_point,_exception);\n            }\n          (void) LevelImageColors(_image,&black_point,&white_point,\n                     IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"linear-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) _image->columns*_image->rows;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) _image->columns*_image->rows-\n              black_point;\n          (void) LinearStretchImage(_image,black_point,white_point,_exception);\n          break;\n        }\n      if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & XValue) == 0)\n            geometry.x=1;\n          if ((flags & YValue) == 0)\n            geometry.y=0;\n          new_image=LiquidRescaleImage(_image,geometry.width,\n            geometry.height,1.0*geometry.x,1.0*geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"local-contrast\",option+1) == 0)\n        {\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            geometry_info.rho=10;\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=12.5;\n          new_image=LocalContrastImage(_image,geometry_info.rho,\n            geometry_info.sigma,exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magnify\",option+1) == 0)\n        {\n          new_image=MagnifyImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-remap\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-remap\",NULL,NULL,exception);\n          break;\n        }\n      if (LocaleCompare(\"mask\",option+1) == 0)\n        {\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            {\n              /*\n                Remove a mask.\n              */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /*\n            Set the image mask.\n          */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"matte\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-alpha Set\":\"-alpha Off\");\n          (void) SetImageAlphaChannel(_image,IfNormalOp ? SetAlphaChannel :\n            DeactivateAlphaChannel, _exception);\n          break;\n        }\n      if (LocaleCompare(\"mean-shift\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.10*QuantumRange;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=MeanShiftImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"median\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-statistic Median\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Median\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"mode\",option+1) == 0)\n        {\n          /* FUTURE: note this is also a special \"montage\" option */\n          CLIWandWarnReplaced(\"-statistic Mode\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Mode\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"modulate\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ModulateImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageProgressMonitor(_image, IfNormalOp ? MonitorProgress :\n                (MagickProgressMonitor) NULL,(void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          (void) SetImageType(_image,BilevelType,_exception);\n          break;\n        }\n      if (LocaleCompare(\"morphology\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          KernelInfo\n            *kernel;\n\n          ssize_t\n            iterations;\n\n          p=arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          parse=ParseCommandOption(MagickMorphologyOptions,MagickFalse,token);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",option,\n              arg1);\n          iterations=1L;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p == ':') || (*p == ','))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p != '\\0'))\n            iterations=(ssize_t) StringToLong(p);\n          kernel=AcquireKernelInfo(arg2,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"UnabletoParseKernel\",option,arg2);\n          new_image=MorphologyImage(_image,(MorphologyMethod)parse,iterations,\n            kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"motion-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=MotionBlurImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'n':\n    {\n      if (LocaleCompare(\"negate\",option+1) == 0)\n        {\n          (void) NegateImage(_image, IsPlusOp, _exception);\n          break;\n        }\n      if (LocaleCompare(\"noise\",option+1) == 0)\n        {\n          double\n            attenuate;\n\n          const char*\n            value;\n\n          if (IfNormalOp)\n            {\n              CLIWandWarnReplaced(\"-statistic NonPeak\");\n              (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"NonPeak\",arg1,exception);\n              break;\n            }\n          parse=ParseCommandOption(MagickNoiseOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedNoiseType\",\n                option,arg1);\n          attenuate=1.0;\n          value=GetImageOption(_image_info,\"attenuate\");\n          if  (value != (const char *) NULL)\n            attenuate=StringToDouble(value,(char **) NULL);\n          new_image=AddNoiseImage(_image,(NoiseType)parse,attenuate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"normalize\",option+1) == 0)\n        {\n          (void) NormalizeImage(_image,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) OpaquePaintImage(_image,&target,&_draw_info->fill,IsPlusOp,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n        {\n          (void) OrderedDitherImage(_image,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"paint\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=OilPaintImage(_image,geometry_info.rho,geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"perceptible\",option+1) == 0)\n        {\n          (void) PerceptibleImage(_image,StringToDouble(arg1,(char **) NULL),\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"polaroid\",option+1) == 0)\n        {\n          const char\n            *caption;\n\n          double\n            angle;\n\n          if (IfPlusOp) {\n            RandomInfo\n              *random_info;\n\n            random_info=AcquireRandomInfo();\n            angle=22.5*(GetPseudoRandomValue(random_info)-0.5);\n            random_info=DestroyRandomInfo(random_info);\n          }\n          else {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            angle=geometry_info.rho;\n          }\n          caption=GetImageProperty(_image,\"caption\",_exception);\n          new_image=PolaroidImage(_image,_draw_info,caption,angle,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"posterize\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) PosterizeImage(_image,(size_t) geometry_info.rho,\n            _quantize_info->dither_method,_exception);\n          break;\n        }\n      if (LocaleCompare(\"preview\",option+1) == 0)\n        {\n          /* FUTURE: should be a 'Genesis' option?\n             Option however is also in WandSettingOptionInfo()\n             Why???\n          */\n          parse=ParseCommandOption(MagickPreviewOptions, MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedPreviewType\",\n                option,arg1);\n          new_image=PreviewImage(_image,(PreviewType)parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"profile\",option+1) == 0)\n        {\n          const char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          Image\n            *profile_image;\n\n          ImageInfo\n            *profile_info;\n\n          /* Note: arguments do not have percent escapes expanded */\n          if (IfPlusOp)\n            { /* Remove a profile from the _image.  */\n              (void) ProfileImage(_image,arg1,(const unsigned char *)\n                NULL,0,_exception);\n              break;\n            }\n          /* Associate a profile with the _image.  */\n          profile_info=CloneImageInfo(_image_info);\n          profile=GetImageProfile(_image,\"iptc\");\n          if (profile != (StringInfo *) NULL)\n            profile_info->profile=(void *) CloneStringInfo(profile);\n          profile_image=GetImageCache(profile_info,arg1,_exception);\n          profile_info=DestroyImageInfo(profile_info);\n          if (profile_image == (Image *) NULL)\n            {\n              StringInfo\n                *profile;\n\n              profile_info=CloneImageInfo(_image_info);\n              (void) CopyMagickString(profile_info->filename,arg1,\n                MagickPathExtent);\n              profile=FileToStringInfo(profile_info->filename,~0UL,_exception);\n              if (profile != (StringInfo *) NULL)\n                {\n                  (void) SetImageInfo(profile_info,0,_exception);\n                  (void) ProfileImage(_image,profile_info->magick,\n                    GetStringInfoDatum(profile),(size_t)\n                    GetStringInfoLength(profile),_exception);\n                  profile=DestroyStringInfo(profile);\n                }\n              profile_info=DestroyImageInfo(profile_info);\n              break;\n            }\n          ResetImageProfileIterator(profile_image);\n          name=GetNextImageProfile(profile_image);\n          while (name != (const char *) NULL)\n          {\n            profile=GetImageProfile(profile_image,name);\n            if (profile != (StringInfo *) NULL)\n              (void) ProfileImage(_image,name,GetStringInfoDatum(profile),\n                (size_t) GetStringInfoLength(profile),_exception);\n            name=GetNextImageProfile(profile_image);\n          }\n          profile_image=DestroyImage(profile_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"raise\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) RaiseImage(_image,&geometry,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"random-threshold\",option+1) == 0)\n        {\n          double\n            min_threshold,\n            max_threshold;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          min_threshold=0.0;\n          max_threshold=(double) QuantumRange;\n          flags=ParseGeometry(arg1,&geometry_info);\n          min_threshold=geometry_info.rho;\n          max_threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            max_threshold=min_threshold;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              max_threshold*=(double) (0.01*QuantumRange);\n              min_threshold*=(double) (0.01*QuantumRange);\n            }\n          (void) RandomThresholdImage(_image,min_threshold,max_threshold,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"range-threshold\",option+1) == 0)\n        {\n          /*\n            Range threshold image.\n          */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=geometry_info.sigma;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=geometry_info.xi;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              geometry_info.rho*=(double) (0.01*QuantumRange);\n              geometry_info.sigma*=(double) (0.01*QuantumRange);\n              geometry_info.xi*=(double) (0.01*QuantumRange);\n              geometry_info.psi*=(double) (0.01*QuantumRange);\n            }\n          (void) RangeThresholdImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n          break;\n        }\n      if (LocaleCompare(\"read-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,ReadPixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,ReadPixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"recolor\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-color-matrix\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-color-matrix\",arg1,NULL,\n            exception);\n        }\n      if (LocaleCompare(\"region\",option+1) == 0)\n        {\n          if (*option == '+')\n            {\n              (void) SetImageRegionMask(_image,WritePixelMask,\n                (const RectangleInfo *) NULL,_exception);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          (void) SetImageRegionMask(_image,WritePixelMask,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *remap_image;\n\n          remap_image=GetImageCache(_image_info,arg1,_exception);\n          if (remap_image == (Image *) NULL)\n            break;\n          (void) RemapImage(_quantize_info,_image,remap_image,_exception);\n          remap_image=DestroyImage(remap_image);\n          break;\n        }\n      if (LocaleCompare(\"repage\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                  arg1);\n              (void) ResetImagePage(_image,arg1);\n            }\n          else\n            (void) ParseAbsoluteGeometry(\"0x0+0+0\",&_image->page);\n          break;\n        }\n      if (LocaleCompare(\"resample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operation */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ResampleImage(_image,geometry_info.rho,\n            geometry_info.sigma,_image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"resize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ResizeImage(_image,geometry.width,geometry.height,\n            _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"roll\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry.x*=(double) _image->columns/100.0;\n              geometry.y*=(double) _image->rows/100.0;\n            }\n          new_image=RollImage(_image,geometry.x,geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotate\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & GreaterValue) != 0 && (_image->columns <= _image->rows))\n            break;\n          if ((flags & LessValue) != 0 && (_image->columns >= _image->rows))\n            break;\n          new_image=RotateImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=RotationalBlurImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=SampleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"scale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ScaleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"segment\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          (void) SegmentImage(_image,_image->colorspace,\n            _image_info->verbose,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"selective-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=SelectiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"separate\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          /* FUTURE - this may be replaced by a \"-channel\" method */\n          new_image=SeparateImages(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SepiaToneImage(_image,StringToDoubleInterval(arg1,\n                 (double) QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"shade\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (((flags & RhoValue) == 0) || ((flags & SigmaValue) == 0))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ShadeImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shadow\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=4.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=4.0;\n          new_image=ShadowImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.0;\n          new_image=SharpenImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"shave\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          new_image=ShaveImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shear\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ShearImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=(double) QuantumRange/2.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.sigma=(double) QuantumRange*geometry_info.sigma/\n              100.0;\n          (void) SigmoidalContrastImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sketch\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=SketchImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"solarize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SolarizeImage(_image,StringToDoubleInterval(arg1,(double)\n                 QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sparse-color\",option+1) == 0)\n        {\n          parse= ParseCommandOption(MagickSparseColorOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedSparseColorMethod\",\n                option,arg1);\n          new_image=SparseColorOption(_image,(SparseColorMethod)parse,arg2,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"splice\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=SpliceImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"spread\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          new_image=SpreadImage(_image,_image->interpolate,geometry_info.rho,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"statistic\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickStatisticOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStatisticType\",\n                 option,arg1);\n          flags=ParseGeometry(arg2,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=StatisticImage(_image,(StatisticType)parse,\n               (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"strip\",option+1) == 0)\n        {\n          (void) StripImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"swirl\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SwirlImage(_image,geometry_info.rho,\n            _image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"threshold\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          threshold=(double) QuantumRange/2;\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          (void) BilevelImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"thumbnail\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ThumbnailImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"tint\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=TintImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transform\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+distort AffineProjection\");\n          new_image=AffineTransformImage(_image,&_draw_info->affine,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transparent\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) TransparentPaintImage(_image,&target,(Quantum)\n            TransparentAlpha,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transpose\",option+1) == 0)\n        {\n          new_image=TransposeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transverse\",option+1) == 0)\n        {\n          new_image=TransverseImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"trim\",option+1) == 0)\n        {\n          new_image=TrimImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* Note that \"type\" setting should have already been defined */\n          (void) SetImageType(_image,_image_info->type,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcqireImage()???\n             Option is not documented, bt appears to be for \"identify\".\n             We may need a identify specific verbose!\n          */\n          if (IsPlusOp) {\n              (void) DeleteImageArtifact(_image,\"identify:unique-colors\");\n              break;\n            }\n          (void) SetImageArtifact(_image,\"identify:unique-colors\",\"true\");\n          (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"unique-colors\",option+1) == 0)\n        {\n          new_image=UniqueImageColors(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"unsharp\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.05;\n          new_image=UnsharpMaskImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcquireImage()???\n             three places!   ImageArtifact   ImageOption  _image_info->verbose\n             Some how new images also get this artifact!\n          */\n          (void) SetImageArtifact(_image,option+1,\n                           IfNormalOp ? \"true\" : \"false\" );\n          break;\n        }\n      if (LocaleCompare(\"vignette\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.1*_image->columns;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.1*_image->rows;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi*=(double) _image->columns/100.0;\n              geometry_info.psi*=(double) _image->rows/100.0;\n            }\n          new_image=VignetteImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"wave\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=WaveImage(_image,geometry_info.rho,geometry_info.sigma,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.rho=QuantumRange*geometry_info.rho/100.0;\n              geometry_info.sigma=QuantumRange*geometry_info.sigma/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=0.0;\n          new_image=WaveletDenoiseImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"white-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) WhiteThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"write-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* Replace current image with any image that was generated\n     and set image point to last image (so image->next is correct) */\n  if (new_image != (Image *) NULL)\n    ReplaceImageInListReturnLast(&_image,new_image);\n\n  return(MagickTrue);\n#undef _image_info\n#undef _draw_info\n#undef _quantize_info\n#undef _image\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n#undef IsPlusOp\n}\n\nWandPrivate MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1,const char *arg2,ExceptionInfo *exception)\n{\n#if !USE_WAND_METHODS\n  size_t\n    n,\n    i;\n#endif\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(cli_wand->wand.images != (Image *) NULL); /* images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Simple Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1,arg2);\n\n#if !USE_WAND_METHODS\n  /* FUTURE add appropriate tracing */\n  i=0;\n  n=GetImageListLength(cli_wand->wand.images);\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n  while (1) {\n    i++;\n    CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n    if ( cli_wand->wand.images->next == (Image *) NULL )\n      break;\n    cli_wand->wand.images=cli_wand->wand.images->next;\n  }\n  assert( i == n );\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n#else\n  MagickResetIterator(&cli_wand->wand);\n  while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n    (void) CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n  MagickResetIterator(&cli_wand->wand);\n#endif\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I L i s t O p e r a t o r I m a g e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIListOperatorImages() applies a single operation that is apply to the\n%  entire image list as a whole. The result is often a complete replacment\n%  of the image list with a completely new list, or with just a single image\n%  result.\n%\n%  The format of the MogrifyImage method is:\n%\n%    MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n%      const char *option,const char *arg1,const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently not used\n%\n*/\nWandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n  Image\n    *new_images;\n\n  MagickStatusType\n    status;\n\n  ssize_t\n    parse;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _draw_info      (cli_wand->draw_info)\n#define _quantize_info  (cli_wand->quantize_info)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n#define IsNormalOp      IfNormalOp ? MagickTrue : MagickFalse\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_images != (Image *) NULL);             /* _images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n       \"- List Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n       arg1n == (const char *) NULL ? \"null\" : arg1n,\n       arg2n == (const char *) NULL ? \"null\" : arg2n);\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  status=MagickTrue;\n  new_images=NewImageList();\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"append\",option+1) == 0)\n        {\n          new_images=AppendImages(_images,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"average\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-evaluate-sequence Mean\");\n          (void) CLIListOperatorImages(cli_wand,\"-evaluate-sequence\",\"Mean\",\n            NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channel-fx\",option+1) == 0)\n        {\n          new_images=ChannelFxImage(_images,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clut\",option+1) == 0)\n        {\n          Image\n            *clut_image;\n\n          /* FUTURE - make this a compose option, and thus can be used\n             with layers compose or even compose last image over all other\n             _images.\n          */\n          new_images=RemoveFirstImageFromList(&_images);\n          clut_image=RemoveLastImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (clut_image == (Image *) NULL)\n            break;\n          (void) ClutImage(new_images,clut_image,new_images->interpolate,\n            _exception);\n          clut_image=DestroyImage(clut_image);\n          break;\n        }\n      if (LocaleCompare(\"coalesce\",option+1) == 0)\n        {\n          new_images=CoalesceImages(_images,_exception);\n          break;\n        }\n      if (LocaleCompare(\"combine\",option+1) == 0)\n        {\n          parse=(ssize_t) _images->colorspace;\n          if (_images->number_channels < GetImageListLength(_images))\n            parse=sRGBColorspace;\n          if ( IfPlusOp )\n            parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          new_images=CombineImages(_images,(ColorspaceType) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"compare\",option+1) == 0)\n        {\n          double\n            distortion;\n\n          Image\n            *image,\n            *reconstruct_image;\n\n          MetricType\n            metric;\n\n          /*\n            Mathematically and visually annotate the difference between an\n            image and its reconstruction.\n          */\n          image=RemoveFirstImageFromList(&_images);\n          reconstruct_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (reconstruct_image == (Image *) NULL)\n            { \n              image=DestroyImage(image);\n              break;\n            }\n          metric=UndefinedErrorMetric;\n          option=GetImageOption(_image_info,\"metric\");\n          if (option != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,option);\n          new_images=CompareImages(image,reconstruct_image,metric,&distortion,\n            _exception);\n          (void) distortion;\n          reconstruct_image=DestroyImage(reconstruct_image);\n          image=DestroyImage(image);\n          break;\n        }\n      if (LocaleCompare(\"complex\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickComplexOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=ComplexImages(_images,(ComplexOperator) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"composite\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          MagickBooleanType\n            clip_to_self;\n\n          Image\n            *mask_image,\n            *source_image;\n\n          RectangleInfo\n            geometry;\n\n          /* Compose value from \"-compose\" option only */\n          value=GetImageOption(_image_info,\"compose\");\n          if (value == (const char *) NULL)\n            compose=OverCompositeOp;  /* use Over not source_image->compose */\n          else\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n\n          /* Get \"clip-to-self\" expert setting (false is normal) */\n          clip_to_self=GetCompositeClipToSelf(compose);\n          value=GetImageOption(_image_info,\"compose:clip-to-self\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringTrue(value);\n          value=GetImageOption(_image_info,\"compose:outside-overlay\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringFalse(value);  /* deprecated */\n\n          new_images=RemoveFirstImageFromList(&_images);\n          source_image=RemoveFirstImageFromList(&_images);\n          if (source_image == (Image *) NULL)\n            break; /* FUTURE - produce Exception, rather than silent fail */\n\n          /* FUTURE - this should not be here! - should be part of -geometry */\n          if (source_image->geometry != (char *) NULL)\n            {\n              RectangleInfo\n                resize_geometry;\n\n              (void) ParseRegionGeometry(source_image,source_image->geometry,\n                &resize_geometry,_exception);\n              if ((source_image->columns != resize_geometry.width) ||\n                  (source_image->rows != resize_geometry.height))\n                {\n                  Image\n                    *resize_image;\n\n                  resize_image=ResizeImage(source_image,resize_geometry.width,\n                    resize_geometry.height,source_image->filter,_exception);\n                  if (resize_image != (Image *) NULL)\n                    {\n                      source_image=DestroyImage(source_image);\n                      source_image=resize_image;\n                    }\n                }\n            }\n          SetGeometry(source_image,&geometry);\n          (void) ParseAbsoluteGeometry(source_image->geometry,&geometry);\n          GravityAdjustGeometry(new_images->columns,new_images->rows,\n            new_images->gravity, &geometry);\n          mask_image=RemoveFirstImageFromList(&_images);\n          if (mask_image == (Image *) NULL)\n            status&=CompositeImage(new_images,source_image,compose,clip_to_self,\n              geometry.x,geometry.y,_exception);\n          else\n            {\n              if ((compose == DisplaceCompositeOp) ||\n                  (compose == DistortCompositeOp))\n                {\n                  status&=CompositeImage(source_image,mask_image,\n                    CopyGreenCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                }\n              else\n                {\n                  Image\n                    *clone_image;\n\n                  clone_image=CloneImage(new_images,0,0,MagickTrue,_exception);\n                  if (clone_image == (Image *) NULL)\n                    break;\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                  status&=CompositeImage(new_images,mask_image,\n                    CopyAlphaCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(clone_image,new_images,OverCompositeOp,\n                    clip_to_self,0,0,_exception);\n                  new_images=DestroyImageList(new_images);\n                  new_images=clone_image;\n                }\n              mask_image=DestroyImage(mask_image);\n            }\n          source_image=DestroyImage(source_image);\n          break;\n        }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            if (IsGeometry(arg2) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) ParsePageGeometry(_images,arg2,&geometry,_exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=_images;\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,arg1,&geometry,_exception);\n            (void) CopyImagePixels(_images,source_image,&geometry,&offset,\n              _exception);\n            break;\n          }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"deconstruct\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-layer CompareAny\");\n          (void) CLIListOperatorImages(cli_wand,\"-layer\",\"CompareAny\",NULL);\n          break;\n        }\n      if (LocaleCompare(\"delete\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            DeleteImages(&_images,arg1,_exception);\n          else\n            DeleteImages(&_images,\"-1\",_exception);\n          break;\n        }\n      if (LocaleCompare(\"duplicate\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              const char\n                *p;\n\n              size_t\n                number_duplicates;\n\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                      arg1);\n              number_duplicates=(size_t) StringToLong(arg1);\n              p=strchr(arg1,',');\n              if (p == (const char *) NULL)\n                new_images=DuplicateImages(_images,number_duplicates,\"-1\",\n                  _exception);\n              else\n                new_images=DuplicateImages(_images,number_duplicates,p,\n                  _exception);\n            }\n          else\n            new_images=DuplicateImages(_images,1,\"-1\",_exception);\n          AppendImageToList(&_images, new_images);\n          new_images=(Image *) NULL;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=EvaluateImages(_images,(MagickEvaluateOperator) parse,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"fft\",option+1) == 0)\n        {\n          new_images=ForwardFourierTransformImage(_images,IsNormalOp,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"flatten\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers flatten instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      if (LocaleCompare(\"fx\",option+1) == 0)\n        {\n          new_images=FxImage(_images,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hald-clut\",option+1) == 0)\n        {\n          /* FUTURE - make this a compose option (and thus layers compose )\n             or perhaps compose last image over all other _images.\n          */\n          Image\n            *hald_image;\n\n          new_images=RemoveFirstImageFromList(&_images);\n          hald_image=RemoveLastImageFromList(&_images);\n          if (hald_image == (Image *) NULL)\n            break;\n          (void) HaldClutImage(new_images,hald_image,_exception);\n          hald_image=DestroyImage(hald_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"ift\",option+1) == 0)\n        {\n          Image\n            *magnitude_image,\n            *phase_image;\n\n           magnitude_image=RemoveFirstImageFromList(&_images);\n           phase_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n           if (phase_image == (Image *) NULL)\n             break;\n           new_images=InverseFourierTransformImage(magnitude_image,phase_image,\n             IsNormalOp,_exception);\n           magnitude_image=DestroyImage(magnitude_image);\n           phase_image=DestroyImage(phase_image);\n          break;\n        }\n      if (LocaleCompare(\"insert\",option+1) == 0)\n        {\n          Image\n            *insert_image,\n            *index_image;\n\n          ssize_t\n            index;\n\n          if (IfNormalOp && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=0;\n          insert_image=RemoveLastImageFromList(&_images);\n          if (IfNormalOp)\n            index=(ssize_t) StringToLong(arg1);\n          index_image=insert_image;\n          if (index == 0)\n            PrependImageToList(&_images,insert_image);\n          else if (index == (ssize_t) GetImageListLength(_images))\n            AppendImageToList(&_images,insert_image);\n          else\n            {\n               index_image=GetImageFromList(_images,index-1);\n               if (index_image == (Image *) NULL)\n                 CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n              InsertImageInList(&index_image,insert_image);\n            }\n          _images=GetFirstImageInList(index_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"layers\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickLayerOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedLayerMethod\",\n                 option,arg1);\n          switch ((LayerMethod) parse)\n          {\n            case CoalesceLayer:\n            {\n              new_images=CoalesceImages(_images,_exception);\n              break;\n            }\n            case CompareAnyLayer:\n            case CompareClearLayer:\n            case CompareOverlayLayer:\n            default:\n            {\n              new_images=CompareImagesLayers(_images,(LayerMethod) parse,\n                   _exception);\n              break;\n            }\n            case MergeLayer:\n            case FlattenLayer:\n            case MosaicLayer:\n            case TrimBoundsLayer:\n            {\n              new_images=MergeImageLayers(_images,(LayerMethod) parse,\n                _exception);\n              break;\n            }\n            case DisposeLayer:\n            {\n              new_images=DisposeImages(_images,_exception);\n              break;\n            }\n            case OptimizeImageLayer:\n            {\n              new_images=OptimizeImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizePlusLayer:\n            {\n              new_images=OptimizePlusImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizeTransLayer:\n            {\n              OptimizeImageTransparency(_images,_exception);\n              break;\n            }\n            case RemoveDupsLayer:\n            {\n              RemoveDuplicateLayers(&_images,_exception);\n              break;\n            }\n            case RemoveZeroLayer:\n            {\n              RemoveZeroDelayLayers(&_images,_exception);\n              break;\n            }\n            case OptimizeLayer:\n            { /* General Purpose, GIF Animation Optimizer.  */\n              new_images=CoalesceImages(_images,_exception);\n              if (new_images == (Image *) NULL)\n                break;\n              _images=DestroyImageList(_images);\n              _images=OptimizeImageLayers(new_images,_exception);\n              if (_images == (Image *) NULL)\n                break;\n              new_images=DestroyImageList(new_images);\n              OptimizeImageTransparency(_images,_exception);\n              (void) RemapImages(_quantize_info,_images,(Image *) NULL,\n                _exception);\n              break;\n            }\n            case CompositeLayer:\n            {\n              Image\n                *source;\n\n              RectangleInfo\n                geometry;\n\n              CompositeOperator\n                compose;\n\n              const char*\n                value;\n\n              value=GetImageOption(_image_info,\"compose\");\n              compose=OverCompositeOp;  /* Default to Over */\n              if (value != (const char *) NULL)\n                compose=(CompositeOperator) ParseCommandOption(\n                      MagickComposeOptions,MagickFalse,value);\n\n              /* Split image sequence at the first 'NULL:' image. */\n              source=_images;\n              while (source != (Image *) NULL)\n              {\n                source=GetNextImageInList(source);\n                if ((source != (Image *) NULL) &&\n                    (LocaleCompare(source->magick,\"NULL\") == 0))\n                  break;\n              }\n              if (source != (Image *) NULL)\n                {\n                  if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                      (GetNextImageInList(source) == (Image *) NULL))\n                    source=(Image *) NULL;\n                  else\n                    { /* Separate the two lists, junk the null: image.  */\n                      source=SplitImageList(source->previous);\n                      DeleteImageFromList(&source);\n                    }\n                }\n              if (source == (Image *) NULL)\n                {\n                  (void) ThrowMagickException(_exception,GetMagickModule(),\n                    OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                  break;\n                }\n              /* Adjust offset with gravity and virtual canvas.  */\n              SetGeometry(_images,&geometry);\n              (void) ParseAbsoluteGeometry(_images->geometry,&geometry);\n              geometry.width=source->page.width != 0 ?\n                source->page.width : source->columns;\n              geometry.height=source->page.height != 0 ?\n               source->page.height : source->rows;\n              GravityAdjustGeometry(_images->page.width != 0 ?\n                _images->page.width : _images->columns,\n                _images->page.height != 0 ? _images->page.height :\n                _images->rows,_images->gravity,&geometry);\n\n              /* Compose the two image sequences together */\n              CompositeLayers(_images,compose,source,geometry.x,geometry.y,\n                _exception);\n              source=DestroyImageList(source);\n              break;\n            }\n          }\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+remap\");\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"morph\",option+1) == 0)\n        {\n          Image\n            *morph_image;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          morph_image=MorphImages(_images,StringToUnsignedLong(arg1),\n            _exception);\n          if (morph_image == (Image *) NULL)\n            break;\n          _images=DestroyImageList(_images);\n          _images=morph_image;\n          break;\n        }\n      if (LocaleCompare(\"mosaic\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers mosaic instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"poly\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg1,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg1);\n          new_images=PolynomialImage(_images,(size_t) (count >> 1),args,\n           _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"process\",option+1) == 0)\n        {\n          /* FUTURE: better parsing using ScriptToken() from string ??? */\n          char\n            **arguments;\n\n          int\n            j,\n            number_arguments;\n\n          arguments=StringToArgv(arg1,&number_arguments);\n          if (arguments == (char **) NULL)\n            break;\n          if (strchr(arguments[1],'=') != (char *) NULL)\n            {\n              char\n                breaker,\n                quote,\n                *token;\n\n              const char\n                *arguments;\n\n              int\n                next,\n                status;\n\n              size_t\n                length;\n\n              TokenInfo\n                *token_info;\n\n              /*\n                Support old style syntax, filter=\"-option arg1\".\n              */\n              assert(arg1 != (const char *) NULL);\n              length=strlen(arg1);\n              token=(char *) NULL;\n              if (~length >= (MagickPathExtent-1))\n                token=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n                  sizeof(*token));\n              if (token == (char *) NULL)\n                break;\n              next=0;\n              arguments=arg1;\n              token_info=AcquireTokenInfo();\n              status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",\n                \"\\\"\",'\\0',&breaker,&next,&quote);\n              token_info=DestroyTokenInfo(token_info);\n              if (status == 0)\n                {\n                  const char\n                    *argv;\n\n                  argv=(&(arguments[next]));\n                  (void) InvokeDynamicImageFilter(token,&_images,1,&argv,\n                    _exception);\n                }\n              token=DestroyString(token);\n              break;\n            }\n          (void) SubstituteString(&arguments[1],\"-\",\"\");\n          (void) InvokeDynamicImageFilter(arguments[1],&_images,\n            number_arguments-2,(const char **) arguments+2,_exception);\n          for (j=0; j < number_arguments; j++)\n            arguments[j]=DestroyString(arguments[j]);\n          arguments=(char **) RelinquishMagickMemory(arguments);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"reverse\",option+1) == 0)\n        {\n          ReverseImageList(&_images);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"smush\",option+1) == 0)\n        {\n          /* FUTURE: this option needs more work to make better */\n          ssize_t\n            offset;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          offset=(ssize_t) StringToLong(arg1);\n          new_images=SmushImages(_images,IsNormalOp,offset,_exception);\n          break;\n        }\n      if (LocaleCompare(\"subimage\",option+1) == 0)\n        {\n          Image\n            *base_image,\n            *compare_image;\n\n          const char\n            *value;\n\n          MetricType\n            metric;\n\n          double\n            similarity;\n\n          RectangleInfo\n            offset;\n\n          base_image=GetImageFromList(_images,0);\n          compare_image=GetImageFromList(_images,1);\n\n          /* Comparision Metric */\n          metric=UndefinedErrorMetric;\n          value=GetImageOption(_image_info,\"metric\");\n          if (value != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,value);\n\n          new_images=SimilarityImage(base_image,compare_image,metric,0.0,\n            &offset,&similarity,_exception);\n\n          if (new_images != (Image *) NULL)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%lf\",\n                similarity);\n              (void) SetImageProperty(new_images,\"subimage:similarity\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.x);\n              (void) SetImageProperty(new_images,\"subimage:x\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.y);\n              (void) SetImageProperty(new_images,\"subimage:y\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\n                \"%lux%lu%+ld%+ld\",(unsigned long) offset.width,(unsigned long)\n                offset.height,(long) offset.x,(long) offset.y);\n              (void) SetImageProperty(new_images,\"subimage:offset\",result,\n                _exception);\n            }\n          break;\n        }\n      if (LocaleCompare(\"swap\",option+1) == 0)\n        {\n        Image\n          *p,\n          *q,\n          *swap;\n\n        ssize_t\n          index,\n          swap_index;\n\n        index=(-1);\n        swap_index=(-2);\n        if (IfNormalOp) {\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          swap_index=(-1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=(ssize_t) geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            swap_index=(ssize_t) geometry_info.sigma;\n        }\n        p=GetImageFromList(_images,index);\n        q=GetImageFromList(_images,swap_index);\n        if ((p == (Image *) NULL) || (q == (Image *) NULL)) {\n          if (IfNormalOp)\n            CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1)\n          else\n            CLIWandExceptionBreak(OptionError,\"TwoOrMoreImagesRequired\",option);\n        }\n        if (p == q)\n          CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1);\n        swap=CloneImage(p,0,0,MagickTrue,_exception);\n        if (swap == (Image *) NULL)\n          CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n        ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,_exception));\n        ReplaceImageInList(&q,swap);\n        _images=GetFirstImageInList(q);\n        break;\n      }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* if new image list generated, replace existing image list */\n  if (new_images == (Image *) NULL)\n    return(status == 0 ? MagickFalse : MagickTrue);\n  _images=DestroyImageList(_images);\n  _images=GetFirstImageInList(new_images);\n  return(status == 0 ? MagickFalse : MagickTrue);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I N o I m a g e O p e r a t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLINoImageOperator() Applies operations that may not actually need images\n%  in an image list.\n%\n%  The classic operators of this type is \"-read\", which actually creates\n%  images even when no images are present.  Or image stack operators, which\n%  can be applied (push or pop) to an empty image list.\n%\n%  Note that these operators may involve other special 'option' prefix\n%  characters other  than '-' or '+', namely parenthesis and braces.\n%\n%  The format of the CLINoImageOption method is:\n%\n%      void CLINoImageOption(MagickCLI *cli_wand,const char *option,\n%           const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use. (sometimes not required)\n%\n%    o option: The special option (with any switch char) to process\n%\n%    o arg1 & arg2: Argument for option, if required\n%                   Currently arg2 is not used.\n%\n*/\nWandPrivate void CLINoImageOperator(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n      \"- NoImage Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n      arg1n != (char *) NULL ? arg1n : \"\",\n      arg2n != (char *) NULL ? arg2n : \"\");\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  do {  /* break to exit code */\n    /*\n      No-op options  (ignore these)\n    */\n    if (LocaleCompare(\"noop\",option+1) == 0)   /* zero argument */\n      break;\n    if (LocaleCompare(\"sans\",option+1) == 0)   /* one argument */\n      break;\n    if (LocaleCompare(\"sans0\",option+1) == 0)  /* zero argument */\n      break;\n    if (LocaleCompare(\"sans1\",option+1) == 0)  /* one argument */\n      break;\n    if (LocaleCompare(\"sans2\",option+1) == 0)  /* two arguments */\n      break;\n    /*\n      Image Reading\n    */\n    if ( ( LocaleCompare(\"read\",option+1) == 0 ) ||\n      ( LocaleCompare(\"--\",option) == 0 ) ) {\n      /* Do Glob filename Expansion for 'arg1' then read all images.\n      *\n      * Expansion handles '@', '~', '*', and '?' meta-characters while ignoring\n      * (but attaching to the filenames in the generated argument list) any\n      * [...] read modifiers that may be present.\n      *\n      * For example: It will expand '*.gif[20x20]' into a list such as\n      * 'abc.gif[20x20]',  'foobar.gif[20x20]',  'xyzzy.gif[20x20]'\n      *\n      * NOTE: In IMv6 this was done globally across all images. This\n      * meant you could include IM options in '@filename' lists, but you\n      * could not include comments.   Doing it only for image read makes\n      * it far more secure.\n      *\n      * Note: arguments do not have percent escapes expanded for security\n      * reasons.\n      */\n      int      argc;\n      char     **argv;\n      ssize_t  i;\n\n      argc = 1;\n      argv = (char **) &arg1;\n\n      /* Expand 'glob' expressions in the given filename.\n        Expansion handles any 'coder:' prefix, or read modifiers attached\n        to the filename, including them in the resulting expanded list.\n      */\n      if (ExpandFilenames(&argc,&argv) == MagickFalse)\n        CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n\n      /* loop over expanded filename list, and read then all in */\n      for (i=0; i < (ssize_t) argc; i++) {\n        Image *\n          new_images;\n        if (_image_info->ping != MagickFalse)\n          new_images=PingImages(_image_info,argv[i],_exception);\n        else\n          new_images=ReadImages(_image_info,argv[i],_exception);\n        AppendImageToList(&_images, new_images);\n        argv[i]=DestroyString(argv[i]);\n      }\n      argv=(char **) RelinquishMagickMemory(argv);\n      break;\n    }\n    /*\n      Image Writing\n      Note: Writing a empty image list is valid in specific cases\n    */\n    if (LocaleCompare(\"write\",option+1) == 0) {\n      /* Note: arguments do not have percent escapes expanded */\n      char\n        key[MagickPathExtent];\n\n      Image\n        *write_images;\n\n      ImageInfo\n        *write_info;\n\n      /* Need images, unless a \"null:\" output coder is used */\n      if ( _images == (Image *) NULL ) {\n        if ( LocaleCompare(arg1,\"null:\") == 0 )\n          break;\n        CLIWandExceptArgBreak(OptionError,\"NoImagesForWrite\",option,arg1);\n      }\n\n      (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",arg1);\n      (void) DeleteImageRegistry(key);\n      write_images=_images;\n      if (IfPlusOp)\n        write_images=CloneImageList(_images,_exception);\n      write_info=CloneImageInfo(_image_info);\n      (void) WriteImages(write_info,write_images,arg1,_exception);\n      write_info=DestroyImageInfo(write_info);\n      if (IfPlusOp)\n        write_images=DestroyImageList(write_images);\n      break;\n    }\n    /*\n      Parenthesis and Brace operations\n    */\n    if (LocaleCompare(\"(\",option) == 0) {\n      /* stack 'push' images */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_list_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"ParenthesisNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n      node->data = (void *)cli_wand->wand.images;\n      node->next = cli_wand->image_list_stack;\n      cli_wand->image_list_stack = node;\n      cli_wand->wand.images = NewImageList();\n\n      /* handle respect-parenthesis */\n      if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,\n                    \"respect-parenthesis\")) != MagickFalse)\n        option=\"{\"; /* fall-thru so as to push image settings too */\n      else\n        break;\n      /* fall thru to operation */\n    }\n    if (LocaleCompare(\"{\",option) == 0) {\n      /* stack 'push' of image_info settings */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_info_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"CurlyBracesNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n\n      node->data = (void *)cli_wand->wand.image_info;\n      node->next = cli_wand->image_info_stack;\n\n      cli_wand->image_info_stack = node;\n      cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);\n      if (cli_wand->wand.image_info == (ImageInfo *) NULL) {\n        CLIWandException(ResourceLimitFatalError,\"MemoryAllocationFailed\",\n            option);\n        cli_wand->wand.image_info = (ImageInfo *)node->data;\n        node = (Stack *)RelinquishMagickMemory(node);\n        break;\n      }\n\n      break;\n    }\n    if (LocaleCompare(\")\",option) == 0) {\n      /* pop images from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_list_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedParenthesis\",option);\n      cli_wand->image_list_stack = node->next;\n\n      AppendImageToList((Image **)&node->data,cli_wand->wand.images);\n      cli_wand->wand.images= (Image *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      /* handle respect-parenthesis - of the previous 'pushed' settings */\n      node = cli_wand->image_info_stack;\n      if ( node != (Stack *) NULL)\n        {\n          if (IsStringTrue(GetImageOption(\n                cli_wand->wand.image_info,\"respect-parenthesis\")) != MagickFalse)\n            option=\"}\"; /* fall-thru so as to pop image settings too */\n          else\n            break;\n        }\n      else\n        break;\n      /* fall thru to next if */\n    }\n    if (LocaleCompare(\"}\",option) == 0) {\n      /* pop image_info settings from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_info_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedCurlyBraces\",option);\n      cli_wand->image_info_stack = node->next;\n\n      (void) DestroyImageInfo(cli_wand->wand.image_info);\n      cli_wand->wand.image_info = (ImageInfo *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);\n      cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);\n      cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);\n\n      break;\n    }\n      if (LocaleCompare(\"print\",option+1) == 0)\n        {\n          (void) FormatLocaleFile(stdout,\"%s\",arg1);\n          break;\n        }\n    if (LocaleCompare(\"set\",option+1) == 0)\n      {\n        /* Settings are applied to each image in memory in turn (if any).\n           While a option: only need to be applied once globally.\n\n           NOTE: rguments have not been automatically percent expaneded\n        */\n\n        /* escape the 'key' once only, using first image. */\n        arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n        if (arg1 == (char *) NULL)\n          CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                option);\n\n        if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n          {\n            if (IfPlusOp)\n              {\n                (void) DeleteImageRegistry(arg1+9);\n                arg1=DestroyString((char *)arg1);\n                break;\n              }\n            arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n            if (arg2 == (char *) NULL) {\n              arg1=DestroyString((char *)arg1);\n              CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                    option);\n            }\n            (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        if (LocaleNCompare(arg1,\"option:\",7) == 0)\n          {\n            /* delete equivelent artifact from all images (if any) */\n            if (_images != (Image *) NULL)\n              {\n                MagickResetIterator(&cli_wand->wand);\n                while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n                  (void) DeleteImageArtifact(_images,arg1+7);\n                MagickResetIterator(&cli_wand->wand);\n              }\n            /* now set/delete the global option as needed */\n            /* FUTURE: make escapes in a global 'option:' delayed */\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            (void) SetImageOption(_image_info,arg1+7,arg2);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        /* Set Artifacts/Properties/Attributes all images (required) */\n        if ( _images == (Image *) NULL )\n          CLIWandExceptArgBreak(OptionWarning,\"NoImageForProperty\",option,arg1);\n\n        MagickResetIterator(&cli_wand->wand);\n        while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n          {\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            if (LocaleNCompare(arg1,\"artifact:\",9) == 0)\n              (void) SetImageArtifact(_images,arg1+9,arg2);\n            else if (LocaleNCompare(arg1,\"property:\",9) == 0)\n              (void) SetImageProperty(_images,arg1+9,arg2,_exception);\n            else\n              (void) SetImageProperty(_images,arg1,arg2,_exception);\n            arg2=DestroyString((char *)arg2);\n          }\n        MagickResetIterator(&cli_wand->wand);\n        arg1=DestroyString((char *)arg1);\n        break;\n     }\n    if (LocaleCompare(\"clone\",option+1) == 0) {\n        Image\n          *new_images;\n\n        if (*option == '+')\n          arg1=AcquireString(\"-1\");\n        if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)\n          CLIWandExceptionBreak(OptionError,\"InvalidArgument\",option);\n        if ( cli_wand->image_list_stack == (Stack *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images = (Image *)cli_wand->image_list_stack->data;\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images=CloneImages(new_images,arg1,_exception);\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"NoSuchImage\",option);\n        AppendImageToList(&_images,new_images);\n        break;\n      }\n    /*\n       Informational Operations.\n\n       Note that these do not require either a cli-wand or images!\n       Though currently a cli-wand much be provided regardless.\n    */\n    if (LocaleCompare(\"version\",option+1) == 0)\n      {\n        ListMagickVersion(stdout);\n        break;\n      }\n    if (LocaleCompare(\"list\",option+1) == 0) {\n      /*\n         FUTURE: This 'switch' should really be part of MagickCore\n      */\n      ssize_t\n        list;\n\n      list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);\n      if ( list < 0 ) {\n        CLIWandExceptionArg(OptionError,\"UnrecognizedListType\",option,arg1);\n        break;\n      }\n      switch (list)\n      {\n        case MagickCoderOptions:\n        {\n          (void) ListCoderInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickColorOptions:\n        {\n          (void) ListColorInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickConfigureOptions:\n        {\n          (void) ListConfigureInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickDelegateOptions:\n        {\n          (void) ListDelegateInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFontOptions:\n        {\n          (void) ListTypeInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFormatOptions:\n          (void) ListMagickInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLocaleOptions:\n          (void) ListLocaleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLogOptions:\n          (void) ListLogInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMagicOptions:\n          (void) ListMagicInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMimeOptions:\n          (void) ListMimeInfo((FILE *) NULL,_exception);\n          break;\n        case MagickModuleOptions:\n          (void) ListModuleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickPolicyOptions:\n          (void) ListPolicyInfo((FILE *) NULL,_exception);\n          break;\n        case MagickResourceOptions:\n          (void) ListMagickResourceInfo((FILE *) NULL,_exception);\n          break;\n        case MagickThresholdOptions:\n          (void) ListThresholdMaps((FILE *) NULL,_exception);\n          break;\n        default:\n          (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n            _exception);\n          break;\n      }\n      break;\n    }\n\n    CLIWandException(OptionError,\"UnrecognizedOption\",option);\n\nDisableMSCWarning(4127)\n  } while (0);  /* break to exit code. */\nRestoreMSCWarning\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I O p t i o n                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIOption() Processes the given option using the given CLI Magick Wand.\n%  The option arguments can be variable in number, though at this time no more\n%  that two is actually used by any option (this may change). Excess options\n%  are simply ignored.\n%\n%  If the cli_wand->command pointer is non-null, then it is assumed that the\n%  option has already been search for up from the CommandOptions[] table in\n%  \"MagickCore/options.c\" using  GetCommandOptionInfo().  If not set this\n%  routine will do the lookup instead. The pointer is reset afterward.\n%\n%  This action allows the caller to lookup and pre-handle any 'special'\n%  options, (such as implicit reads) before calling this general option\n%  handler to deal with 'standard' command line options.\n%\n%  The format of the CLIOption method is:\n%\n%       void CLIOption(MagickCLI *cli_wand,const char *option, ...)\n%\n%  A description of each parameter follows:\n%\n%     o cli_wand: the main CLI Wand to use.\n%\n%     o option: The special option (with any switch char) to process\n%\n%     o args: any required arguments for an option (variable number)\n%\n%  Example Usage...\n%\n%    CLIoption(cli_wand,\"-read\",\"rose:\");\n%    CLIoption(cli_wand,\"-virtual-pixel\",\"transparent\");\n%    CLIoption(cli_wand,\"-distort\",\"SRT:\",\"30\");\n%    CLIoption(cli_wand,\"-write\",\"rotated_rose.png\");\n%\n*/\nWandExport void CLIOption(MagickCLI *cli_wand,const char *option,...)\n{\n  const char    /* extracted option args from args */\n    *arg1,\n    *arg2;\n\n  CommandOptionFlags\n    option_type;\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  do { /* Break Code Block for error handling */\n\n    /* get information about option */\n    if ( cli_wand->command == (const OptionInfo *) NULL )\n      cli_wand->command = GetCommandOptionInfo(option);\n#if 0\n      (void) FormatLocaleFile(stderr, \"CLIOption \\\"%s\\\" matched \\\"%s\\\"\\n\",\n            option, cli_wand->command->mnemonic );\n#endif\n    option_type=(CommandOptionFlags) cli_wand->command->flags;\n\n    if ( option_type == UndefinedOptionFlag )\n      CLIWandExceptionReturn(OptionFatalError,\"UnrecognizedOption\",option);\n\n    assert( LocaleCompare(cli_wand->command->mnemonic,option) == 0 );\n\n    /* deprecated options */\n    if ( (option_type & DeprecateOptionFlag) != 0 )\n      CLIWandExceptionBreak(OptionError,\"DeprecatedOptionNoCode\",option);\n\n    /* options that this module does not handle */\n    if ((option_type & (SpecialOptionFlag|GenesisOptionFlag)) != 0 )\n      CLIWandExceptionBreak(OptionFatalError,\"InvalidUseOfOption\",option);\n\n    /* Get argument strings from VarArgs\n      How can you determine if enough arguments was supplied?\n      What happens if not enough arguments were supplied?\n    */\n    { size_t\n        count = (size_t) cli_wand->command->type;\n\n      va_list\n        operands;\n\n      va_start(operands,option);\n\n      arg1=arg2=NULL;\n      if ( count >= 1 )\n        arg1=(const char *) va_arg(operands, const char *);\n      if ( count >= 2 )\n        arg2=(const char *) va_arg(operands, const char *);\n\n      va_end(operands);\n#if 0\n      (void) FormatLocaleFile(stderr,\n        \"CLIOption: \\\"%s\\\"  Count: %ld  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            option,(long) count,option_type,arg1,arg2);\n#endif\n    }\n\n    /*\n      Call the appropriate option handler\n    */\n\n    /* FUTURE: this is temporary - get 'settings' to handle distribution of\n      settings to images attributes,proprieties,artifacts */\n    if ( cli_wand->wand.images != (Image *) NULL )\n      (void) SyncImagesSettings(cli_wand->wand.image_info,cli_wand->wand.images,\n        cli_wand->wand.exception);\n\n    if ( (option_type & SettingOptionFlags) != 0 ) {\n      CLISettingOptionInfo(cli_wand, option, arg1, arg2);\n      /*\n        FUTURE: Sync Specific Settings into Image Properities (not global)\n      */\n    }\n\n    /* Operators that do not need images - read, write, stack, clone */\n    if ((option_type & NoImageOperatorFlag) != 0)\n      CLINoImageOperator(cli_wand, option, arg1, arg2);\n\n    /* FUTURE: The not a setting part below is a temporary hack due to\n    * some options being both a Setting and a Simple operator.\n    * Specifically -monitor, -depth, and  -colorspace */\n    if ( cli_wand->wand.images == (Image *) NULL )\n      if ( ((option_type & (SimpleOperatorFlag|ListOperatorFlag)) != 0 ) &&\n          ((option_type & SettingOptionFlags) == 0 ))  /* temp hack */\n        CLIWandExceptionBreak(OptionError,\"NoImagesFound\",option);\n\n    /* Operators which loop of individual images, simply */\n    if ( (option_type & SimpleOperatorFlag) != 0 &&\n         cli_wand->wand.images != (Image *) NULL) /* temp hack */\n      {\n        ExceptionInfo *exception=AcquireExceptionInfo();\n        (void) CLISimpleOperatorImages(cli_wand, option, arg1, arg2,exception);\n        exception=DestroyExceptionInfo(exception);\n      }\n\n    /* Operators that work on the image list as a whole */\n    if ( (option_type & ListOperatorFlag) != 0 )\n      (void) CLIListOperatorImages(cli_wand, option, arg1, arg2);\n\nDisableMSCWarning(4127)\n  } while (0);  /* end Break code block */\nRestoreMSCWarning\n\n  cli_wand->command = (const OptionInfo *) NULL; /* prevent re-use later */\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%              M   M   OOO   GGGGG  RRRR   IIIII  FFFFF  Y   Y                %\n%              MM MM  O   O  G      R   R    I    F       Y Y                 %\n%              M M M  O   O  G GGG  RRRR     I    FFF      Y                  %\n%              M   M  O   O  G   G  R R      I    F        Y                  %\n%              M   M   OOO   GGGG   R  R   IIIII  F        Y                  %\n%                                                                             %\n%                                                                             %\n%                         MagickWand Module Methods                           %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                March 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Use the mogrify program to resize an image, blur, crop, despeckle, dither,\n%  draw on, flip, join, re-sample, and much more. This tool is similiar to\n%  convert except that the original image file is overwritten (unless you\n%  change the file suffix with the -format option) with any changes you\n%  request.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/mogrify-private.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_HAVE_UTIME_H)\n#include <utime.h>\n#endif\n\f\n/*\n  Constant declaration.\n*/\nstatic const char\n  MogrifyAlphaColor[] = \"#bdbdbd\",  /* gray */\n  MogrifyBackgroundColor[] = \"#ffffff\",  /* white */\n  MogrifyBorderColor[] = \"#dfdfdf\";  /* gray */\n\f\n/*\n  Define declarations.\n*/\n#define UndefinedCompressionQuality  0UL\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     M a g i c k C o m m a n d G e n e s i s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickCommandGenesis() applies image processing options to an image as\n%  prescribed by command line options.\n%\n%  It wiil look for special options like \"-debug\", \"-bench\", and\n%  \"-distribute-cache\" that needs to be applied even before the main\n%  processing begins, and may completely overrule normal command processing.\n%  Such 'Genesis' Options can only be given on the CLI, (not in a script)\n%  and are typically ignored (as they have been handled) if seen later.\n%\n%  The format of the MagickCommandGenesis method is:\n%\n%      MagickBooleanType MagickCommandGenesis(ImageInfo *image_info,\n%        MagickCommand command,int argc,char **argv,char **metadata,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o command: Choose from ConvertImageCommand, IdentifyImageCommand,\n%      MogrifyImageCommand, CompositeImageCommand, CompareImagesCommand,\n%      ConjureImageCommand, StreamImageCommand, ImportImageCommand,\n%      DisplayImageCommand, or AnimateImageCommand.\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o metadata: any metadata is returned here.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MagickCommandGenesis(ImageInfo *image_info,\n  MagickCommand command,int argc,char **argv,char **metadata,\n  ExceptionInfo *exception)\n{\n  char\n    client_name[MaxTextExtent],\n    *option;\n\n  double\n    duration,\n    serial;\n\n  MagickBooleanType\n    concurrent,\n    regard_warnings,\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    iterations,\n    number_threads;\n\n  ssize_t\n    n;\n\n  (void) setlocale(LC_ALL,\"\");\n  (void) setlocale(LC_NUMERIC,\"C\");\n  GetPathComponent(argv[0],TailPath,client_name);\n  (void) SetClientName(client_name);\n  concurrent=MagickFalse;\n  duration=(-1.0);\n  iterations=1;\n  status=MagickTrue;\n  regard_warnings=MagickFalse;\n  for (i=1; i < (ssize_t) (argc-1); i++)\n  {\n    option=argv[i];\n    if ((strlen(option) == 1) || ((*option != '-') && (*option != '+')))\n      continue;\n    if (LocaleCompare(\"-bench\",option) == 0)\n      iterations=StringToUnsignedLong(argv[++i]);\n    if (LocaleCompare(\"-concurrent\",option) == 0)\n      concurrent=MagickTrue;\n    if (LocaleCompare(\"-debug\",option) == 0)\n      (void) SetLogEventMask(argv[++i]);\n    if (LocaleCompare(\"-distribute-cache\",option) == 0)\n      {\n        DistributePixelCacheServer(StringToInteger(argv[++i]),exception);\n        exit(0);\n      }\n    if (LocaleCompare(\"-duration\",option) == 0)\n      duration=StringToDouble(argv[++i],(char **) NULL);\n    if (LocaleCompare(\"-regard-warnings\",option) == 0)\n      regard_warnings=MagickTrue;\n  }\n  if (iterations == 1)\n    {\n      char\n        *text;\n\n      text=(char *) NULL;\n      status=command(image_info,argc,argv,&text,exception);\n      if (exception->severity != UndefinedException)\n        {\n          if ((exception->severity > ErrorException) ||\n              (regard_warnings != MagickFalse))\n            status=MagickFalse;\n          CatchException(exception);\n        }\n      if (text != (char *) NULL)\n        {\n          if (metadata != (char **) NULL)\n            (void) ConcatenateString(&(*metadata),text);\n          text=DestroyString(text);\n        }\n      return(status);\n    }\n  number_threads=GetOpenMPMaximumThreads();\n  serial=0.0;\n  for (n=1; n <= (ssize_t) number_threads; n++)\n  {\n    double\n      e,\n      parallel,\n      user_time;\n\n    TimerInfo\n      *timer;\n\n    (void) SetMagickResourceLimit(ThreadResource,(MagickSizeType) n);\n    timer=AcquireTimerInfo();\n    if (concurrent == MagickFalse)\n      {\n        for (i=0; i < (ssize_t) iterations; i++)\n        {\n          char\n            *text;\n\n          text=(char *) NULL;\n          if (status == MagickFalse)\n            continue;\n          if (duration > 0)\n            {\n              if (GetElapsedTime(timer) > duration)\n                continue;\n              (void) ContinueTimer(timer);\n            }\n          status=command(image_info,argc,argv,&text,exception);\n          if (exception->severity != UndefinedException)\n            {\n              if ((exception->severity > ErrorException) ||\n                  (regard_warnings != MagickFalse))\n                status=MagickFalse;\n              CatchException(exception);\n            }\n          if (text != (char *) NULL)\n            {\n              if (metadata != (char **) NULL)\n                (void) ConcatenateString(&(*metadata),text);\n              text=DestroyString(text);\n            }\n          }\n      }\n    else\n      {\n        SetOpenMPNested(1);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        # pragma omp parallel for shared(status)\n#endif\n        for (i=0; i < (ssize_t) iterations; i++)\n        {\n          char\n            *text;\n\n          text=(char *) NULL;\n          if (status == MagickFalse)\n            continue;\n          if (duration > 0)\n            {\n              if (GetElapsedTime(timer) > duration)\n                continue;\n              (void) ContinueTimer(timer);\n            }\n          status=command(image_info,argc,argv,&text,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          # pragma omp critical (MagickCore_MagickCommandGenesis)\n#endif\n          {\n            if (exception->severity != UndefinedException)\n              {\n                if ((exception->severity > ErrorException) ||\n                    (regard_warnings != MagickFalse))\n                  status=MagickFalse;\n                CatchException(exception);\n              }\n            if (text != (char *) NULL)\n              {\n                if (metadata != (char **) NULL)\n                  (void) ConcatenateString(&(*metadata),text);\n                text=DestroyString(text);\n              }\n          }\n        }\n      }\n    user_time=GetUserTime(timer);\n    parallel=GetElapsedTime(timer);\n    e=1.0;\n    if (n == 1)\n      serial=parallel;\n    else\n      e=((1.0/(1.0/((serial/(serial+parallel))+(1.0-(serial/(serial+parallel)))/\n        (double) n)))-(1.0/(double) n))/(1.0-1.0/(double) n);\n    (void) FormatLocaleFile(stderr,\n      \"  Performance[%.20g]: %.20gi %0.3fips %0.6fe %0.6fu %lu:%02lu.%03lu\\n\",\n      (double) n,(double) iterations,(double) iterations/parallel,e,user_time,\n      (unsigned long) (parallel/60.0),(unsigned long) floor(fmod(parallel,\n      60.0)),(unsigned long) (1000.0*(parallel-floor(parallel))+0.5));\n    timer=DestroyTimerInfo(timer);\n  }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImage() applies simple single image processing options to a single\n%  image that may be part of a large list, but also handles any 'region'\n%  image handling.\n%\n%  The image in the list may be modified in three different ways...\n%\n%    * directly modified (EG: -negate, -gamma, -level, -annotate, -draw),\n%    * replaced by a new image (EG: -spread, -resize, -rotate, -morphology)\n%    * replace by a list of images (only the -separate option!)\n%\n%  In each case the result is returned into the list, and a pointer to the\n%  modified image (last image added if replaced by a list of images) is\n%  returned.\n%\n%  ASIDE: The -crop is present but restricted to non-tile single image crops\n%\n%  This means if all the images are being processed (such as by\n%  MogrifyImages(), next image to be processed will be as per the pointer\n%  (*image)->next.  Also the image list may grow as a result of some specific\n%  operations but as images are never merged or deleted, it will never shrink\n%  in length.  Typically the list will remain the same length.\n%\n%  WARNING: As the image pointed to may be replaced, the first image in the\n%  list may also change.  GetFirstImageInList() should be used by caller if\n%  they wish return the Image pointer to the first image in list.\n%\n%\n%  The format of the MogrifyImage method is:\n%\n%      MagickBooleanType MogrifyImage(ImageInfo *image_info,const int argc,\n%        const char **argv,Image **image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  /*\n    Read an image into a image cache (for repeated usage) if not already in\n    cache.  Then return the image that is in the cache.\n  */\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\nstatic inline MagickBooleanType IsPathWritable(const char *path)\n{\n  if (IsPathAccessible(path) == MagickFalse)\n    return(MagickFalse);\n  if (access_utf8(path,W_OK) != 0)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType MonitorProgress(const char *text,\n  const MagickOffsetType offset,const MagickSizeType extent,\n  void *wand_unused(client_data))\n{\n  char\n    message[MagickPathExtent],\n    tag[MagickPathExtent];\n\n  const char\n    *locale_message;\n\n  register char\n    *p;\n\n  magick_unreferenced(client_data);\n\n  if ((extent <= 1) || (offset < 0) || (offset >= (MagickOffsetType) extent))\n    return(MagickTrue);\n  if ((offset != (MagickOffsetType) (extent-1)) && ((offset % 50) != 0))\n    return(MagickTrue);\n  (void) CopyMagickString(tag,text,MagickPathExtent);\n  p=strrchr(tag,'/');\n  if (p != (char *) NULL)\n    *p='\\0';\n  (void) FormatLocaleString(message,MagickPathExtent,\"Monitor/%s\",tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == message)\n    locale_message=tag;\n  if (p == (char *) NULL)\n    (void) FormatLocaleFile(stderr,\"%s: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  else\n    (void) FormatLocaleFile(stderr,\"%s[%s]: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,p+1,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  if (offset == (MagickOffsetType) (extent-1))\n    (void) FormatLocaleFile(stderr,\"\\n\");\n  (void) fflush(stderr);\n  return(MagickTrue);\n}\n\nstatic Image *SparseColorOption(const Image *image,\n  const SparseColorMethod method,const char *arguments,\n  const MagickBooleanType color_from_image,ExceptionInfo *exception)\n{\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    *sparse_arguments;\n\n  Image\n    *sparse_image;\n\n  PixelInfo\n    color;\n\n  MagickBooleanType\n    error;\n\n  register size_t\n    x;\n\n  size_t\n    number_arguments,\n    number_colors;\n\n  /*\n    SparseColorOption() parses the complex -sparse-color argument into an an\n    array of floating point values then calls SparseColorImage().  Argument is\n    a complex mix of floating-point pixel coodinates, and color specifications\n    (or direct floating point numbers).  The number of floats needed to\n    represent a color varies depending on the current channel setting.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Limit channels according to image - and add up number of color channel.\n  */\n  number_colors=0;\n  if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    number_colors++;\n  if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->alpha_trait != UndefinedPixelTrait))\n    number_colors++;\n\n  /*\n    Read string, to determine number of arguments needed,\n  */\n  p=arguments;\n  x=0;\n  while( *p != '\\0' )\n  {\n    GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == ',' ) continue;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      if ( color_from_image ) {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color arg given, when colors are coming from image\");\n        return( (Image *) NULL);\n      }\n      x += number_colors;  /* color argument */\n    }\n    else {\n      x++;   /* floating point argument */\n    }\n  }\n  error=MagickTrue;\n  if ( color_from_image ) {\n    /* just the control points are being given */\n    error = ( x % 2 != 0 ) ? MagickTrue : MagickFalse;\n    number_arguments=(x/2)*(2+number_colors);\n  }\n  else {\n    /* control points and color values */\n    error = ( x % (2+number_colors) != 0 ) ? MagickTrue : MagickFalse;\n    number_arguments=x;\n  }\n  if ( error ) {\n    (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n               \"Invalid number of Arguments\");\n    return( (Image *) NULL);\n  }\n\n  /* Allocate and fill in the floating point arguments */\n  sparse_arguments=(double *) AcquireQuantumMemory(number_arguments,\n    sizeof(*sparse_arguments));\n  if (sparse_arguments == (double *) NULL) {\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"  MemoryAllocationFailed\\n\"\"%s\",\"SparseColorOption\");\n    return( (Image *) NULL);\n  }\n  (void) memset(sparse_arguments,0,number_arguments*\n    sizeof(*sparse_arguments));\n  p=arguments;\n  x=0;\n  while( *p != '\\0' && x < number_arguments ) {\n    /* X coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of X-coord\");\n      error = MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* Y coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of Y-coord\");\n      error = MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* color values for this control point */\n#if 0\n    if ( (color_from_image ) {\n      /* get color from image */\n      /* HOW??? */\n    }\n    else\n#endif\n    {\n      /* color name or function given in string argument */\n      token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n      if ( token[0] == '\\0' ) break;\n      if ( isalpha((int) token[0]) || token[0] == '#' ) {\n        /* Color string given */\n        (void) QueryColorCompliance(token,AllCompliance,&color,exception);\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          sparse_arguments[x++] = QuantumScale*color.red;\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          sparse_arguments[x++] = QuantumScale*color.green;\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          sparse_arguments[x++] = QuantumScale*color.blue;\n        if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->colorspace == CMYKColorspace))\n          sparse_arguments[x++] = QuantumScale*color.black;\n        if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->alpha_trait != UndefinedPixelTrait))\n          sparse_arguments[x++] = QuantumScale*color.alpha;\n      }\n      else {\n        /* Colors given as a set of floating point values - experimental */\n        /* NB: token contains the first floating point value to use! */\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->colorspace == CMYKColorspace))\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n        if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n            (image->alpha_trait != UndefinedPixelTrait))\n          {\n          while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n          if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n            break;\n          sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n          token[0] = ','; /* used this token - get another */\n        }\n      }\n    }\n  }\n  if ( number_arguments != x && !error ) {\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"  InvalidArgument\",\"'%s': %s\",\"sparse-color\",\"Argument Parsing Error\");\n    sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n    return( (Image *) NULL);\n  }\n  if ( error )\n    return( (Image *) NULL);\n\n  /* Call the Interpolation function with the parsed arguments */\n  sparse_image=SparseColorImage(image,method,number_arguments,sparse_arguments,\n    exception);\n  sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n  return( sparse_image );\n}\n\nWandExport MagickBooleanType MogrifyImage(ImageInfo *image_info,const int argc,\n  const char **argv,Image **image,ExceptionInfo *exception)\n{\n  CompositeOperator\n    compose;\n\n  const char\n    *format,\n    *option;\n\n  double\n    attenuate;\n\n  DrawInfo\n    *draw_info;\n\n  GeometryInfo\n    geometry_info;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  PixelInfo\n    fill;\n\n  MagickStatusType\n    flags;\n\n  PixelInterpolateMethod\n    interpolate_method;\n\n  QuantizeInfo\n    *quantize_info;\n\n  RectangleInfo\n    geometry,\n    region_geometry;\n\n  register ssize_t\n    i;\n\n  /*\n    Initialize method variables.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  if (argc < 0)\n    return(MagickTrue);\n  mogrify_info=CloneImageInfo(image_info);\n  draw_info=CloneDrawInfo(mogrify_info,(DrawInfo *) NULL);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  SetGeometryInfo(&geometry_info);\n  GetPixelInfo(*image,&fill);\n  fill=(*image)->background_color;\n  attenuate=1.0;\n  compose=(*image)->compose;\n  interpolate_method=UndefinedInterpolatePixel;\n  format=GetImageOption(mogrify_info,\"format\");\n  SetGeometry(*image,&region_geometry);\n  /*\n    Transmogrify the image.\n  */\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    Image\n      *mogrify_image;\n\n    ssize_t\n      count;\n\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=MagickMax(ParseCommandOption(MagickCommandOptions,MagickFalse,option),\n      0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    mogrify_image=(Image *) NULL;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n          {\n            /*\n              Adaptive blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=AdaptiveBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n          {\n            /*\n              Adaptive resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=AdaptiveResizeImage(*image,geometry.width,\n              geometry.height,exception);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n          {\n            /*\n              Adaptive sharpen image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=AdaptiveSharpenImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"affine\",option+1) == 0)\n          {\n            /*\n              Affine matrix.\n            */\n            if (*option == '+')\n              {\n                GetAffineMatrix(&draw_info->affine);\n                break;\n              }\n            (void) ParseAffineGeometry(argv[i+1],&draw_info->affine,exception);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",option+1) == 0)\n          {\n            AlphaChannelOption\n              alpha_type;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            alpha_type=(AlphaChannelOption) ParseCommandOption(\n              MagickAlphaChannelOptions,MagickFalse,argv[i+1]);\n            (void) SetImageAlphaChannel(*image,alpha_type,exception);\n            break;\n          }\n        if (LocaleCompare(\"annotate\",option+1) == 0)\n          {\n            char\n              *text,\n              geometry_str[MagickPathExtent];\n\n            /*\n              Annotate image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            SetGeometryInfo(&geometry_info);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            text=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (text == (char *) NULL)\n              break;\n            (void) CloneString(&draw_info->text,text);\n            text=DestroyString(text);\n            (void) FormatLocaleString(geometry_str,MagickPathExtent,\"%+f%+f\",\n              geometry_info.xi,geometry_info.psi);\n            (void) CloneString(&draw_info->geometry,geometry_str);\n            draw_info->affine.sx=cos(DegreesToRadians(\n              fmod(geometry_info.rho,360.0)));\n            draw_info->affine.rx=sin(DegreesToRadians(\n              fmod(geometry_info.rho,360.0)));\n            draw_info->affine.ry=(-sin(DegreesToRadians(\n              fmod(geometry_info.sigma,360.0))));\n            draw_info->affine.sy=cos(DegreesToRadians(\n              fmod(geometry_info.sigma,360.0)));\n            (void) AnnotateImage(*image,draw_info,exception);\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          {\n            draw_info->stroke_antialias=(*option == '-') ? MagickTrue :\n              MagickFalse;\n            draw_info->text_antialias=(*option == '-') ? MagickTrue :\n              MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"attenuate\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                attenuate=1.0;\n                break;\n              }\n            attenuate=StringToDouble(argv[i+1],(char **) NULL);\n            break;\n          }\n        if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n          {\n            /*\n              Auto Adjust Gamma of image based on its mean\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) AutoGammaImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"auto-level\",option+1) == 0)\n          {\n            /*\n              Perfectly Normalize (max/min stretch) the image\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) AutoLevelImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"auto-orient\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=AutoOrientImage(*image,(*image)->orientation,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n          {\n            AutoThresholdMethod\n              method;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(AutoThresholdMethod) ParseCommandOption(\n              MagickAutoThresholdOptions,MagickFalse,argv[i+1]);\n            (void) AutoThresholdImage(*image,method,exception);\n            break;\n          }\n        break;\n      }\n      case 'b':\n      {\n        if (LocaleCompare(\"black-threshold\",option+1) == 0)\n          {\n            /*\n              Black threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) BlackThresholdImage(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"blue-shift\",option+1) == 0)\n          {\n            /*\n              Blue shift image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            geometry_info.rho=1.5;\n            if (*option == '-')\n              flags=ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=BlueShiftImage(*image,geometry_info.rho,exception);\n            break;\n          }\n        if (LocaleCompare(\"blur\",option+1) == 0)\n          {\n            /*\n              Gaussian blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.0;\n            mogrify_image=BlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"border\",option+1) == 0)\n          {\n            /*\n              Surround image with a border of solid color.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=BorderImage(*image,&geometry,compose,exception);\n            break;\n          }\n        if (LocaleCompare(\"bordercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n                  &draw_info->border_color,exception);\n                break;\n              }\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &draw_info->border_color,exception);\n            break;\n          }\n        if (LocaleCompare(\"box\",option+1) == 0)\n          {\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &draw_info->undercolor,exception);\n            break;\n          }\n        if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n          {\n            double\n              brightness,\n              contrast;\n\n            /*\n              Brightness / contrast image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            brightness=geometry_info.rho;\n            contrast=0.0;\n            if ((flags & SigmaValue) != 0)\n              contrast=geometry_info.sigma;\n            (void) BrightnessContrastImage(*image,brightness,contrast,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"canny\",option+1) == 0)\n          {\n            /*\n              Detect edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.10;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=0.30;\n            if ((flags & PercentValue) != 0)\n              {\n                geometry_info.xi/=100.0;\n                geometry_info.psi/=100.0;\n              }\n            mogrify_image=CannyEdgeImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n            break;\n          }\n        if (LocaleCompare(\"cdl\",option+1) == 0)\n          {\n            char\n              *color_correction_collection;\n\n            /*\n              Color correct with a color decision list.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            color_correction_collection=FileToString(argv[i+1],~0UL,exception);\n            if (color_correction_collection == (char *) NULL)\n              break;\n            (void) ColorDecisionListImage(*image,color_correction_collection,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ChannelType\n              channel;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetPixelChannelMask(*image,DefaultChannels);\n                break;\n              }\n            channel=(ChannelType) ParseChannelOption(argv[i+1]);\n            (void) SetPixelChannelMask(*image,channel);\n            break;\n          }\n        if (LocaleCompare(\"charcoal\",option+1) == 0)\n          {\n            /*\n              Charcoal image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=1.0;\n            mogrify_image=CharcoalImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"chop\",option+1) == 0)\n          {\n            /*\n              Chop the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ChopImage(*image,&geometry,exception);\n            break;\n          }\n        if (LocaleCompare(\"clahe\",option+1) == 0)\n          {\n            /*\n              Contrast limited adaptive histogram equalization.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            (void) CLAHEImage(*image,geometry.width,geometry.height,\n              (size_t) geometry.x,geometry_info.psi,exception);\n            break;\n          }\n        if (LocaleCompare(\"clip\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            (void) ClipImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"clip-mask\",option+1) == 0)\n          {\n            Image\n              *clip_mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            clip_mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (clip_mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,WritePixelMask,clip_mask,exception);\n            clip_mask=DestroyImage(clip_mask);\n            break;\n          }\n        if (LocaleCompare(\"clip-path\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ClipImagePath(*image,argv[i+1],*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"colorize\",option+1) == 0)\n          {\n            /*\n              Colorize the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=ColorizeImage(*image,argv[i+1],&fill,exception);\n            break;\n          }\n        if (LocaleCompare(\"color-matrix\",option+1) == 0)\n          {\n            KernelInfo\n              *kernel;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            kernel=AcquireKernelInfo(argv[i+1],exception);\n            if (kernel == (KernelInfo *) NULL)\n              break;\n            /* FUTURE: check on size of the matrix */\n            mogrify_image=ColorMatrixImage(*image,kernel,exception);\n            kernel=DestroyKernelInfo(kernel);\n            break;\n          }\n        if (LocaleCompare(\"colors\",option+1) == 0)\n          {\n            /*\n              Reduce the number of colors in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            quantize_info->number_colors=StringToUnsignedLong(argv[i+1]);\n            if (quantize_info->number_colors == 0)\n              break;\n            if (((*image)->storage_class == DirectClass) ||\n                (*image)->colors > quantize_info->number_colors)\n              (void) QuantizeImage(quantize_info,*image,exception);\n            else\n              (void) CompressImageColormap(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ColorspaceType\n              colorspace;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) TransformImageColorspace(*image,sRGBColorspace,\n                  exception);\n                break;\n              }\n            colorspace=(ColorspaceType) ParseCommandOption(\n              MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            (void) TransformImageColorspace(*image,colorspace,exception);\n            break;\n          }\n        if (LocaleCompare(\"compose\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"connected-components\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=ConnectedComponentsImage(*image,(size_t)\n              StringToInteger(argv[i+1]),(CCObjectInfo **) NULL,exception);\n            break;\n          }\n        if (LocaleCompare(\"contrast\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ContrastImage(*image,(*option == '-') ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n          {\n            double\n              black_point,\n              white_point;\n\n            /*\n              Contrast stretch image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            black_point=geometry_info.rho;\n            white_point=(flags & SigmaValue) != 0 ? geometry_info.sigma :\n              black_point;\n            if ((flags & PercentValue) != 0)\n              {\n                black_point*=(double) (*image)->columns*(*image)->rows/100.0;\n                white_point*=(double) (*image)->columns*(*image)->rows/100.0;\n              }\n            white_point=(double) (*image)->columns*(*image)->rows-\n              white_point;\n            (void) ContrastStretchImage(*image,black_point,white_point,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"convolve\",option+1) == 0)\n          {\n            double\n              gamma;\n\n            KernelInfo\n              *kernel_info;\n\n            register ssize_t\n              j;\n\n            size_t\n              extent;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            kernel_info=AcquireKernelInfo(argv[i+1],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              break;\n            extent=kernel_info->width*kernel_info->height;\n            gamma=0.0;\n            for (j=0; j < (ssize_t) extent; j++)\n              gamma+=kernel_info->values[j];\n            gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma);\n            for (j=0; j < (ssize_t) extent; j++)\n              kernel_info->values[j]*=gamma;\n            mogrify_image=MorphologyImage(*image,CorrelateMorphology,1,\n              kernel_info,exception);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"crop\",option+1) == 0)\n          {\n            /*\n              Crop a image to a smaller size\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=CropImageToTiles(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"cycle\",option+1) == 0)\n          {\n            /*\n              Cycle an image colormap.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) CycleColormapImage(*image,(ssize_t) StringToLong(argv[i+1]),\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"decipher\",option+1) == 0)\n          {\n            StringInfo\n              *passkey;\n\n            /*\n              Decipher pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            passkey=FileToStringInfo(argv[i+1],~0UL,exception);\n            if (passkey != (StringInfo *) NULL)\n              {\n                (void) PasskeyDecipherImage(*image,passkey,exception);\n                passkey=DestroyStringInfo(passkey);\n              }\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            /*\n              Set image density.\n            */\n            (void) CloneString(&draw_info->density,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetImageDepth(*image,MAGICKCORE_QUANTUM_DEPTH,exception);\n                break;\n              }\n            (void) SetImageDepth(*image,StringToUnsignedLong(argv[i+1]),\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"deskew\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            /*\n              Straighten the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              threshold=40.0*QuantumRange/100.0;\n            else\n              threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n                1.0);\n            mogrify_image=DeskewImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"despeckle\",option+1) == 0)\n          {\n            /*\n              Reduce the speckles within an image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=DespeckleImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"display\",option+1) == 0)\n          {\n            (void) CloneString(&draw_info->server_name,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"distort\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            DistortMethod\n              method;\n\n            double\n              *arguments;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            /*\n              Distort image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(DistortMethod) ParseCommandOption(MagickDistortOptions,\n              MagickFalse,argv[i+1]);\n            if (method == ResizeDistortion)\n              {\n                 double\n                   resize_args[2];\n\n                 /*\n                   Special Case - Argument is actually a resize geometry!\n                   Convert that to an appropriate distortion argument array.\n                 */\n                 (void) ParseRegionGeometry(*image,argv[i+2],&geometry,\n                   exception);\n                 resize_args[0]=(double) geometry.width;\n                 resize_args[1]=(double) geometry.height;\n                 mogrify_image=DistortImage(*image,method,(size_t)2,\n                   resize_args,MagickTrue,exception);\n                 break;\n              }\n            args=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*image)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            mogrify_image=DistortImage(*image,method,number_arguments,arguments,\n              (*option == '+') ? MagickTrue : MagickFalse,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither_method=NoDitherMethod;\n                break;\n              }\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"draw\",option+1) == 0)\n          {\n            /*\n              Draw image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) CloneString(&draw_info->primitive,argv[i+1]);\n            (void) DrawImage(*image,draw_info,exception);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"edge\",option+1) == 0)\n          {\n            /*\n              Enhance edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=EdgeImage(*image,geometry_info.rho,exception);\n            break;\n          }\n        if (LocaleCompare(\"emboss\",option+1) == 0)\n          {\n            /*\n              Emboss image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=EmbossImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"encipher\",option+1) == 0)\n          {\n            StringInfo\n              *passkey;\n\n            /*\n              Encipher pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            passkey=FileToStringInfo(argv[i+1],~0UL,exception);\n            if (passkey != (StringInfo *) NULL)\n              {\n                (void) PasskeyEncipherImage(*image,passkey,exception);\n                passkey=DestroyStringInfo(passkey);\n              }\n            break;\n          }\n        if (LocaleCompare(\"encoding\",option+1) == 0)\n          {\n            (void) CloneString(&draw_info->encoding,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"enhance\",option+1) == 0)\n          {\n            /*\n              Enhance image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=EnhanceImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"equalize\",option+1) == 0)\n          {\n            /*\n              Equalize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) EqualizeImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"evaluate\",option+1) == 0)\n          {\n            double\n              constant;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            constant=StringToDoubleInterval(argv[i+2],(double) QuantumRange+\n              1.0);\n            (void) EvaluateImage(*image,op,constant,exception);\n            break;\n          }\n        if (LocaleCompare(\"extent\",option+1) == 0)\n          {\n            /*\n              Set the image extent.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            if (geometry.width == 0)\n              geometry.width=(*image)->columns;\n            if (geometry.height == 0)\n              geometry.height=(*image)->rows;\n            mogrify_image=ExtentImage(*image,&geometry,exception);\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"family\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (draw_info->family != (char *) NULL)\n                  draw_info->family=DestroyString(draw_info->family);\n                break;\n              }\n            (void) CloneString(&draw_info->family,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"features\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageArtifact(*image,\"identify:features\");\n                break;\n              }\n            (void) SetImageArtifact(*image,\"identify:features\",argv[i+1]);\n            (void) SetImageArtifact(*image,\"verbose\",\"true\");\n            break;\n          }\n        if (LocaleCompare(\"fill\",option+1) == 0)\n          {\n            ExceptionInfo\n              *sans;\n\n            PixelInfo\n              color;\n\n            GetPixelInfo(*image,&fill);\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(\"none\",AllCompliance,&fill,\n                  exception);\n                draw_info->fill=fill;\n                if (draw_info->fill_pattern != (Image *) NULL)\n                  draw_info->fill_pattern=DestroyImage(draw_info->fill_pattern);\n                break;\n              }\n            sans=AcquireExceptionInfo();\n            status=QueryColorCompliance(argv[i+1],AllCompliance,&color,sans);\n            sans=DestroyExceptionInfo(sans);\n            if (status == MagickFalse)\n              draw_info->fill_pattern=GetImageCache(mogrify_info,argv[i+1],\n                exception);\n            else\n              draw_info->fill=fill=color;\n            break;\n          }\n        if (LocaleCompare(\"flip\",option+1) == 0)\n          {\n            /*\n              Flip image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=FlipImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"floodfill\",option+1) == 0)\n          {\n            PixelInfo\n              target;\n\n            /*\n              Floodfill image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            (void) QueryColorCompliance(argv[i+2],AllCompliance,&target,\n              exception);\n            (void) FloodfillPaintImage(*image,draw_info,&target,geometry.x,\n              geometry.y,*option == '-' ? MagickFalse : MagickTrue,exception);\n            break;\n          }\n        if (LocaleCompare(\"flop\",option+1) == 0)\n          {\n            /*\n              Flop image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=FlopImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"font\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (draw_info->font != (char *) NULL)\n                  draw_info->font=DestroyString(draw_info->font);\n                break;\n              }\n            (void) CloneString(&draw_info->font,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            format=argv[i+1];\n            break;\n          }\n        if (LocaleCompare(\"frame\",option+1) == 0)\n          {\n            FrameInfo\n              frame_info;\n\n            /*\n              Surround image with an ornamental border.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            frame_info.width=geometry.width;\n            frame_info.height=geometry.height;\n            frame_info.outer_bevel=geometry.x;\n            frame_info.inner_bevel=geometry.y;\n            frame_info.x=(ssize_t) frame_info.width;\n            frame_info.y=(ssize_t) frame_info.height;\n            frame_info.width=(*image)->columns+2*frame_info.width;\n            frame_info.height=(*image)->rows+2*frame_info.height;\n            mogrify_image=FrameImage(*image,&frame_info,compose,exception);\n            break;\n          }\n        if (LocaleCompare(\"function\",option+1) == 0)\n          {\n            char\n              *arguments,\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            double\n              *parameters;\n\n            MagickFunction\n              function;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_parameters;\n\n            /*\n              Function Modify Image Values\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            function=(MagickFunction) ParseCommandOption(MagickFunctionOptions,\n              MagickFalse,argv[i+1]);\n            arguments=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (arguments == (char *) NULL)\n              break;\n            p=(char *) arguments;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n            }\n            number_parameters=(size_t) x;\n            parameters=(double *) AcquireQuantumMemory(number_parameters,\n              sizeof(*parameters));\n            if (parameters == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*image)->filename);\n            (void) memset(parameters,0,number_parameters*\n              sizeof(*parameters));\n            p=(char *) arguments;\n            for (x=0; (x < (ssize_t) number_parameters) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n              parameters[x]=StringToDouble(token,(char **) NULL);\n            }\n            arguments=DestroyString(arguments);\n            (void) FunctionImage(*image,function,number_parameters,parameters,\n              exception);\n            parameters=(double *) RelinquishMagickMemory(parameters);\n            break;\n          }\n        break;\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gamma\",option+1) == 0)\n          {\n            /*\n              Gamma image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              (*image)->gamma=StringToDouble(argv[i+1],(char **) NULL);\n            else\n              (void) GammaImage(*image,StringToDouble(argv[i+1],(char **) NULL),\n                exception);\n            break;\n          }\n        if ((LocaleCompare(\"gaussian-blur\",option+1) == 0) ||\n            (LocaleCompare(\"gaussian\",option+1) == 0))\n          {\n            /*\n              Gaussian blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=GaussianBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"geometry\",option+1) == 0)\n          {\n              /*\n                Record Image offset, Resize last image.\n              */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                if ((*image)->geometry != (char *) NULL)\n                  (*image)->geometry=DestroyString((*image)->geometry);\n                break;\n              }\n            flags=ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n              (void) CloneString(&(*image)->geometry,argv[i+1]);\n            else\n              mogrify_image=ResizeImage(*image,geometry.width,geometry.height,\n                (*image)->filter,exception);\n            break;\n          }\n        if (LocaleCompare(\"gravity\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                draw_info->gravity=UndefinedGravity;\n                break;\n              }\n            draw_info->gravity=(GravityType) ParseCommandOption(\n              MagickGravityOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"grayscale\",option+1) == 0)\n          {\n            PixelIntensityMethod\n              method;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(PixelIntensityMethod) ParseCommandOption(\n              MagickPixelIntensityOptions,MagickFalse,argv[i+1]);\n            (void) GrayscaleImage(*image,method,exception);\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"highlight-color\",option+1) == 0)\n          {\n            (void) SetImageArtifact(*image,\"compare:highlight-color\",argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"hough-lines\",option+1) == 0)\n          {\n            /*\n              Detect edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=40;\n            mogrify_image=HoughLineImage(*image,(size_t) geometry_info.rho,\n              (size_t) geometry_info.sigma,(size_t) geometry_info.xi,exception);\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"identify\",option+1) == 0)\n          {\n            char\n              *text;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (format == (char *) NULL)\n              {\n                (void) IdentifyImage(*image,stdout,mogrify_info->verbose,\n                  exception);\n                break;\n              }\n            text=InterpretImageProperties(mogrify_info,*image,format,\n              exception);\n            if (text == (char *) NULL)\n              break;\n            (void) fputs(text,stdout);\n            text=DestroyString(text);\n            break;\n          }\n        if (LocaleCompare(\"implode\",option+1) == 0)\n          {\n            /*\n              Implode image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=ImplodeImage(*image,geometry_info.rho,\n              interpolate_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"0\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->interline_spacing=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            interpolate_method=(PixelInterpolateMethod) ParseCommandOption(\n              MagickInterpolateOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"0\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->interword_spacing=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"interpolative-resize\",option+1) == 0)\n          {\n            /*\n              Interpolative resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=InterpolativeResizeImage(*image,geometry.width,\n              geometry.height,interpolate_method,exception);\n            break;\n          }\n        break;\n      }\n      case 'k':\n      {\n        if (LocaleCompare(\"kerning\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"0\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->kerning=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"kuwahara\",option+1) == 0)\n          {\n            /*\n              Edge preserving blur.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho-0.5;\n            mogrify_image=KuwaharaImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"lat\",option+1) == 0)\n          {\n            /*\n              Local adaptive threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & PercentValue) != 0)\n              geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n            mogrify_image=AdaptiveThresholdImage(*image,(size_t)\n              geometry_info.rho,(size_t) geometry_info.sigma,(double)\n              geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"level\",option+1) == 0)\n          {\n            double\n              black_point,\n              gamma,\n              white_point;\n\n            /*\n              Parse levels.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            black_point=geometry_info.rho;\n            white_point=(double) QuantumRange;\n            if ((flags & SigmaValue) != 0)\n              white_point=geometry_info.sigma;\n            gamma=1.0;\n            if ((flags & XiValue) != 0)\n              gamma=geometry_info.xi;\n            if ((flags & PercentValue) != 0)\n              {\n                black_point*=(double) (QuantumRange/100.0);\n                white_point*=(double) (QuantumRange/100.0);\n              }\n            if ((flags & SigmaValue) == 0)\n              white_point=(double) QuantumRange-black_point;\n            if ((*option == '+') || ((flags & AspectValue) != 0))\n              (void) LevelizeImage(*image,black_point,white_point,gamma,\n                exception);\n            else\n              (void) LevelImage(*image,black_point,white_point,gamma,\n                exception);\n            break;\n          }\n        if (LocaleCompare(\"level-colors\",option+1) == 0)\n          {\n            char\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            PixelInfo\n              black_point,\n              white_point;\n\n            p=(const char *) argv[i+1];\n            GetNextToken(p,&p,MagickPathExtent,token);  /* get black point color */\n            if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n              (void) QueryColorCompliance(token,AllCompliance,\n                &black_point,exception);\n            else\n              (void) QueryColorCompliance(\"#000000\",AllCompliance,\n                &black_point,exception);\n            if (isalpha((int) token[0]) || (token[0] == '#'))\n              GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == '\\0')\n              white_point=black_point; /* set everything to that color */\n            else\n              {\n                if ((isalpha((int) *token) == 0) && ((*token == '#') == 0))\n                  GetNextToken(p,&p,MagickPathExtent,token); /* Get white point color. */\n                if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n                  (void) QueryColorCompliance(token,AllCompliance,\n                    &white_point,exception);\n                else\n                  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,\n                    &white_point,exception);\n              }\n            (void) LevelImageColors(*image,&black_point,&white_point,\n              *option == '+' ? MagickTrue : MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"linear-stretch\",option+1) == 0)\n          {\n            double\n              black_point,\n              white_point;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            black_point=geometry_info.rho;\n            white_point=(double) (*image)->columns*(*image)->rows;\n            if ((flags & SigmaValue) != 0)\n              white_point=geometry_info.sigma;\n            if ((flags & PercentValue) != 0)\n              {\n                black_point*=(double) (*image)->columns*(*image)->rows/100.0;\n                white_point*=(double) (*image)->columns*(*image)->rows/100.0;\n              }\n            if ((flags & SigmaValue) == 0)\n              white_point=(double) (*image)->columns*(*image)->rows-\n                black_point;\n            (void) LinearStretchImage(*image,black_point,white_point,exception);\n            break;\n          }\n        if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n          {\n            /*\n              Liquid rescale image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            if ((flags & XValue) == 0)\n              geometry.x=1;\n            if ((flags & YValue) == 0)\n              geometry.y=0;\n            mogrify_image=LiquidRescaleImage(*image,geometry.width,\n              geometry.height,1.0*geometry.x,1.0*geometry.y,exception);\n            break;\n          }\n        if (LocaleCompare(\"local-contrast\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & RhoValue) == 0)\n              geometry_info.rho=10;\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=12.5;\n            mogrify_image=LocalContrastImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"lowlight-color\",option+1) == 0)\n          {\n            (void) SetImageArtifact(*image,\"compare:lowlight-color\",argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"magnify\",option+1) == 0)\n          {\n            /*\n              Double image size.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=MagnifyImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            Image\n              *remap_image;\n\n            /*\n              Transform image colors to match this set of colors.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              break;\n            remap_image=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (remap_image == (Image *) NULL)\n              break;\n            (void) RemapImage(quantize_info,*image,remap_image,exception);\n            remap_image=DestroyImage(remap_image);\n            break;\n          }\n        if (LocaleCompare(\"mask\",option+1) == 0)\n          {\n            Image\n              *mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,WritePixelMask,mask,exception);\n            mask=DestroyImage(mask);\n            break;\n          }\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          {\n            (void) SetImageAlphaChannel(*image,(*option == '-') ?\n              SetAlphaChannel : DeactivateAlphaChannel,exception);\n            break;\n          }\n        if (LocaleCompare(\"mean-shift\",option+1) == 0)\n          {\n            /*\n              Detect edges in the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.10*QuantumRange;\n            if ((flags & PercentValue) != 0)\n              geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n            mogrify_image=MeanShiftImage(*image,(size_t) geometry_info.rho,\n              (size_t) geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"median\",option+1) == 0)\n          {\n            /*\n              Median filter image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=StatisticImage(*image,MedianStatistic,(size_t)\n              geometry_info.rho,(size_t) geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"mode\",option+1) == 0)\n          {\n            /*\n              Mode image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=StatisticImage(*image,ModeStatistic,(size_t)\n              geometry_info.rho,(size_t) geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"modulate\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ModulateImage(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"moments\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageArtifact(*image,\"identify:moments\");\n                break;\n              }\n            (void) SetImageArtifact(*image,\"identify:moments\",argv[i+1]);\n            (void) SetImageArtifact(*image,\"verbose\",\"true\");\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageProgressMonitor(*image,\n                  (MagickProgressMonitor) NULL,(void *) NULL);\n                break;\n              }\n            (void) SetImageProgressMonitor(*image,MonitorProgress,\n              (void *) NULL);\n            break;\n          }\n        if (LocaleCompare(\"monochrome\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) SetImageType(*image,BilevelType,exception);\n            break;\n          }\n        if (LocaleCompare(\"morphology\",option+1) == 0)\n          {\n            char\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            KernelInfo\n              *kernel;\n\n            MorphologyMethod\n              method;\n\n            ssize_t\n              iterations;\n\n            /*\n              Morphological Image Operation\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            p=argv[i+1];\n            GetNextToken(p,&p,MagickPathExtent,token);\n            method=(MorphologyMethod) ParseCommandOption(\n              MagickMorphologyOptions,MagickFalse,token);\n            iterations=1L;\n            GetNextToken(p,&p,MagickPathExtent,token);\n            if ((*p == ':') || (*p == ','))\n              GetNextToken(p,&p,MagickPathExtent,token);\n            if ((*p != '\\0'))\n              iterations=(ssize_t) StringToLong(p);\n            kernel=AcquireKernelInfo(argv[i+2],exception);\n            if (kernel == (KernelInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"UnabletoParseKernel\",\"morphology\");\n                status=MagickFalse;\n                break;\n              }\n            mogrify_image=MorphologyImage(*image,method,iterations,kernel,\n              exception);\n            kernel=DestroyKernelInfo(kernel);\n            break;\n          }\n        if (LocaleCompare(\"motion-blur\",option+1) == 0)\n          {\n            /*\n              Motion blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=MotionBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        break;\n      }\n      case 'n':\n      {\n        if (LocaleCompare(\"negate\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) NegateImage(*image,*option == '+' ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"noise\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '-')\n              {\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                mogrify_image=StatisticImage(*image,NonpeakStatistic,(size_t)\n                  geometry_info.rho,(size_t) geometry_info.sigma,exception);\n              }\n            else\n              {\n                NoiseType\n                  noise;\n\n                noise=(NoiseType) ParseCommandOption(MagickNoiseOptions,\n                  MagickFalse,argv[i+1]);\n                mogrify_image=AddNoiseImage(*image,noise,attenuate,exception);\n              }\n            break;\n          }\n        if (LocaleCompare(\"normalize\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) NormalizeImage(*image,exception);\n            break;\n          }\n        break;\n      }\n      case 'o':\n      {\n        if (LocaleCompare(\"opaque\",option+1) == 0)\n          {\n            PixelInfo\n              target;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,&target,\n              exception);\n            (void) OpaquePaintImage(*image,&target,&fill,*option == '-' ?\n              MagickFalse : MagickTrue,exception);\n            break;\n          }\n        if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) OrderedDitherImage(*image,argv[i+1],exception);\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"paint\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=OilPaintImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"perceptible\",option+1) == 0)\n          {\n            /*\n              Perceptible image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) PerceptibleImage(*image,StringToDouble(argv[i+1],\n              (char **) NULL),exception);\n            break;\n          }\n        if (LocaleCompare(\"pointsize\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) ParseGeometry(\"12\",&geometry_info);\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            draw_info->pointsize=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"polaroid\",option+1) == 0)\n          {\n            const char\n              *caption;\n\n            double\n              angle;\n\n            RandomInfo\n              *random_info;\n\n            /*\n              Simulate a Polaroid picture.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            random_info=AcquireRandomInfo();\n            angle=22.5*(GetPseudoRandomValue(random_info)-0.5);\n            random_info=DestroyRandomInfo(random_info);\n            if (*option == '-')\n              {\n                SetGeometryInfo(&geometry_info);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                angle=geometry_info.rho;\n              }\n            caption=GetImageProperty(*image,\"caption\",exception);\n            mogrify_image=PolaroidImage(*image,draw_info,caption,angle,\n              interpolate_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"posterize\",option+1) == 0)\n          {\n            /*\n              Posterize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) PosterizeImage(*image,StringToUnsignedLong(argv[i+1]),\n              quantize_info->dither_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"preview\",option+1) == 0)\n          {\n            PreviewType\n              preview_type;\n\n            /*\n              Preview image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              preview_type=UndefinedPreview;\n            else\n              preview_type=(PreviewType) ParseCommandOption(\n                MagickPreviewOptions,MagickFalse,argv[i+1]);\n            mogrify_image=PreviewImage(*image,preview_type,exception);\n            break;\n          }\n        if (LocaleCompare(\"profile\",option+1) == 0)\n          {\n            const char\n              *name;\n\n            const StringInfo\n              *profile;\n\n            Image\n              *profile_image;\n\n            ImageInfo\n              *profile_info;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a profile from the image.\n                */\n                (void) ProfileImage(*image,argv[i+1],(const unsigned char *)\n                  NULL,0,exception);\n                break;\n              }\n            /*\n              Associate a profile with the image.\n            */\n            profile_info=CloneImageInfo(mogrify_info);\n            profile=GetImageProfile(*image,\"iptc\");\n            if (profile != (StringInfo *) NULL)\n              profile_info->profile=(void *) CloneStringInfo(profile);\n            profile_image=GetImageCache(profile_info,argv[i+1],exception);\n            profile_info=DestroyImageInfo(profile_info);\n            if (profile_image == (Image *) NULL)\n              {\n                StringInfo\n                  *file_data;\n\n                profile_info=CloneImageInfo(mogrify_info);\n                (void) CopyMagickString(profile_info->filename,argv[i+1],\n                  MagickPathExtent);\n                file_data=FileToStringInfo(profile_info->filename,~0UL,\n                  exception);\n                if (file_data != (StringInfo *) NULL)\n                  {\n                    (void) SetImageInfo(profile_info,0,exception);\n                    (void) ProfileImage(*image,profile_info->magick,\n                      GetStringInfoDatum(file_data),\n                      GetStringInfoLength(file_data),exception);\n                    file_data=DestroyStringInfo(file_data);\n                  }\n                profile_info=DestroyImageInfo(profile_info);\n                break;\n              }\n            ResetImageProfileIterator(profile_image);\n            name=GetNextImageProfile(profile_image);\n            while (name != (const char *) NULL)\n            {\n              profile=GetImageProfile(profile_image,name);\n              if (profile != (StringInfo *) NULL)\n                (void) ProfileImage(*image,name,GetStringInfoDatum(profile),\n                  (size_t) GetStringInfoLength(profile),exception);\n              name=GetNextImageProfile(profile_image);\n            }\n            profile_image=DestroyImage(profile_image);\n            break;\n          }\n        break;\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quantize\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->colorspace=UndefinedColorspace;\n                break;\n              }\n            quantize_info->colorspace=(ColorspaceType) ParseCommandOption(\n              MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n          {\n            /*\n              Rotational blur image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=RotationalBlurImage(*image,geometry_info.rho,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"raise\",option+1) == 0)\n          {\n            /*\n              Surround image with a raise of solid color.\n            */\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            (void) RaiseImage(*image,&geometry,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            break;\n          }\n        if (LocaleCompare(\"random-threshold\",option+1) == 0)\n          {\n            /*\n              Random threshold image.\n            */\n            double\n              min_threshold,\n              max_threshold;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            min_threshold=0.0;\n            max_threshold=(double) QuantumRange;\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            min_threshold=geometry_info.rho;\n            max_threshold=geometry_info.sigma;\n            if ((flags & SigmaValue) == 0)\n              max_threshold=min_threshold;\n            if (strchr(argv[i+1],'%') != (char *) NULL)\n              {\n                max_threshold*=(double) (0.01*QuantumRange);\n                min_threshold*=(double) (0.01*QuantumRange);\n              }\n            (void) RandomThresholdImage(*image,min_threshold,max_threshold,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"range-threshold\",option+1) == 0)\n          {\n            /*\n              Range threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=geometry_info.sigma;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=geometry_info.xi;\n            if (strchr(argv[i+1],'%') != (char *) NULL)\n              {\n                geometry_info.rho*=(double) (0.01*QuantumRange);\n                geometry_info.sigma*=(double) (0.01*QuantumRange);\n                geometry_info.xi*=(double) (0.01*QuantumRange);\n                geometry_info.psi*=(double) (0.01*QuantumRange);\n              }\n            (void) RangeThresholdImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n            break;\n          }\n        if (LocaleCompare(\"read-mask\",option+1) == 0)\n          {\n            Image\n              *mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,ReadPixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,ReadPixelMask,mask,exception);\n            mask=DestroyImage(mask);\n            break;\n          }\n        if (LocaleCompare(\"region\",option+1) == 0)\n          {\n            /*\n              Apply read mask as defined by a region geometry.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                (void) SetImageRegionMask(*image,WritePixelMask,\n                  (const RectangleInfo *) NULL,exception);\n                break;\n              }\n            (void) ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            (void) SetImageRegionMask(*image,WritePixelMask,&geometry,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"render\",option+1) == 0)\n          {\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            draw_info->render=(*option == '+') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"remap\",option+1) == 0)\n          {\n            Image\n              *remap_image;\n\n            /*\n              Transform image colors to match this set of colors.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              break;\n            remap_image=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (remap_image == (Image *) NULL)\n              break;\n            (void) RemapImage(quantize_info,*image,remap_image,exception);\n            remap_image=DestroyImage(remap_image);\n            break;\n          }\n        if (LocaleCompare(\"repage\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) ParseAbsoluteGeometry(\"0x0+0+0\",&(*image)->page);\n                break;\n              }\n            (void) ResetImagePage(*image,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"resample\",option+1) == 0)\n          {\n            /*\n              Resample image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=ResampleImage(*image,geometry_info.rho,\n              geometry_info.sigma,(*image)->filter,exception);\n            break;\n          }\n        if (LocaleCompare(\"resize\",option+1) == 0)\n          {\n            /*\n              Resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ResizeImage(*image,geometry.width,geometry.height,\n              (*image)->filter,exception);\n            break;\n          }\n        if (LocaleCompare(\"roll\",option+1) == 0)\n          {\n            /*\n              Roll image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            if ((flags & PercentValue) != 0)\n              {\n                geometry.x*=(double) (*image)->columns/100.0;\n                geometry.y*=(double) (*image)->rows/100.0;\n              }\n            mogrify_image=RollImage(*image,geometry.x,geometry.y,exception);\n            break;\n          }\n        if (LocaleCompare(\"rotate\",option+1) == 0)\n          {\n            char\n              *rotation;\n\n            /*\n              Check for conditional image rotation.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (strchr(argv[i+1],'>') != (char *) NULL)\n              if ((*image)->columns <= (*image)->rows)\n                break;\n            if (strchr(argv[i+1],'<') != (char *) NULL)\n              if ((*image)->columns >= (*image)->rows)\n                break;\n            /*\n              Rotate image.\n            */\n            rotation=ConstantString(argv[i+1]);\n            (void) SubstituteString(&rotation,\">\",\"\");\n            (void) SubstituteString(&rotation,\"<\",\"\");\n            (void) ParseGeometry(rotation,&geometry_info);\n            rotation=DestroyString(rotation);\n            mogrify_image=RotateImage(*image,geometry_info.rho,exception);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sample\",option+1) == 0)\n          {\n            /*\n              Sample image with pixel replication.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=SampleImage(*image,geometry.width,geometry.height,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"scale\",option+1) == 0)\n          {\n            /*\n              Resize image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ScaleImage(*image,geometry.width,geometry.height,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"selective-blur\",option+1) == 0)\n          {\n            /*\n              Selectively blur pixels within a contrast threshold.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & PercentValue) != 0)\n              geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n            mogrify_image=SelectiveBlurImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"separate\",option+1) == 0)\n          {\n            /*\n              Break channels into separate images.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=SeparateImages(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            /*\n              Sepia-tone image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n              1.0);\n            mogrify_image=SepiaToneImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"segment\",option+1) == 0)\n          {\n            /*\n              Segment image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            (void) SegmentImage(*image,(*image)->colorspace,\n              mogrify_info->verbose,geometry_info.rho,geometry_info.sigma,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            char\n              *value;\n\n            /*\n              Set image option.\n            */\n            if (*option == '+')\n              {\n                if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n                  (void) DeleteImageRegistry(argv[i+1]+9);\n                else\n                  if (LocaleNCompare(argv[i+1],\"option:\",7) == 0)\n                    {\n                      (void) DeleteImageOption(mogrify_info,argv[i+1]+7);\n                      (void) DeleteImageArtifact(*image,argv[i+1]+7);\n                    }\n                  else\n                    (void) DeleteImageProperty(*image,argv[i+1]);\n                break;\n              }\n            value=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (value == (char *) NULL)\n              break;\n            if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n              (void) SetImageRegistry(StringRegistryType,argv[i+1]+9,value,\n                exception);\n            else\n              if (LocaleNCompare(argv[i+1],\"option:\",7) == 0)\n                {\n                  (void) SetImageOption(image_info,argv[i+1]+7,value);\n                  (void) SetImageOption(mogrify_info,argv[i+1]+7,value);\n                  (void) SetImageArtifact(*image,argv[i+1]+7,value);\n                }\n              else\n                (void) SetImageProperty(*image,argv[i+1],value,exception);\n            value=DestroyString(value);\n            break;\n          }\n        if (LocaleCompare(\"shade\",option+1) == 0)\n          {\n            /*\n              Shade image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=ShadeImage(*image,(*option == '-') ? MagickTrue :\n              MagickFalse,geometry_info.rho,geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"shadow\",option+1) == 0)\n          {\n            /*\n              Shadow image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=4.0;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=4.0;\n            mogrify_image=ShadowImage(*image,geometry_info.rho,\n              geometry_info.sigma,(ssize_t) ceil(geometry_info.xi-0.5),\n              (ssize_t) ceil(geometry_info.psi-0.5),exception);\n            break;\n          }\n        if (LocaleCompare(\"sharpen\",option+1) == 0)\n          {\n            /*\n              Sharpen image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.0;\n            mogrify_image=SharpenImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"shave\",option+1) == 0)\n          {\n            /*\n              Shave the image edges.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParsePageGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ShaveImage(*image,&geometry,exception);\n            break;\n          }\n        if (LocaleCompare(\"shear\",option+1) == 0)\n          {\n            /*\n              Shear image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            mogrify_image=ShearImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n          {\n            /*\n              Sigmoidal non-linearity contrast control.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=(double) QuantumRange/2.0;\n            if ((flags & PercentValue) != 0)\n              geometry_info.sigma=(double) QuantumRange*geometry_info.sigma/\n                100.0;\n            (void) SigmoidalContrastImage(*image,(*option == '-') ?\n              MagickTrue : MagickFalse,geometry_info.rho,geometry_info.sigma,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"sketch\",option+1) == 0)\n          {\n            /*\n              Sketch image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=SketchImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,exception);\n            break;\n          }\n        if (LocaleCompare(\"solarize\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n              1.0);\n            (void) SolarizeImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"sparse-color\",option+1) == 0)\n          {\n            SparseColorMethod\n              method;\n\n            char\n              *arguments;\n\n            /*\n              Sparse Color Interpolated Gradient\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            method=(SparseColorMethod) ParseCommandOption(\n              MagickSparseColorOptions,MagickFalse,argv[i+1]);\n            arguments=InterpretImageProperties(mogrify_info,*image,argv[i+2],\n              exception);\n            if (arguments == (char *) NULL)\n              break;\n            mogrify_image=SparseColorOption(*image,method,arguments,\n              option[0] == '+' ? MagickTrue : MagickFalse,exception);\n            arguments=DestroyString(arguments);\n            break;\n          }\n        if (LocaleCompare(\"splice\",option+1) == 0)\n          {\n            /*\n              Splice a solid color into the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGravityGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=SpliceImage(*image,&geometry,exception);\n            break;\n          }\n        if (LocaleCompare(\"spread\",option+1) == 0)\n          {\n            /*\n              Spread an image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=SpreadImage(*image,interpolate_method,\n              geometry_info.rho,exception);\n            break;\n          }\n        if (LocaleCompare(\"statistic\",option+1) == 0)\n          {\n            StatisticType\n              type;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            type=(StatisticType) ParseCommandOption(MagickStatisticOptions,\n              MagickFalse,argv[i+1]);\n            (void) ParseGeometry(argv[i+2],&geometry_info);\n            mogrify_image=StatisticImage(*image,type,(size_t) geometry_info.rho,\n              (size_t) geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"stretch\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                draw_info->stretch=UndefinedStretch;\n                break;\n              }\n            draw_info->stretch=(StretchType) ParseCommandOption(\n              MagickStretchOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"strip\",option+1) == 0)\n          {\n            /*\n              Strip image of profiles and comments.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) StripImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",option+1) == 0)\n          {\n            ExceptionInfo\n              *sans;\n\n            PixelInfo\n              color;\n\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(\"none\",AllCompliance,\n                  &draw_info->stroke,exception);\n                if (draw_info->stroke_pattern != (Image *) NULL)\n                  draw_info->stroke_pattern=DestroyImage(\n                    draw_info->stroke_pattern);\n                break;\n              }\n            sans=AcquireExceptionInfo();\n            status=QueryColorCompliance(argv[i+1],AllCompliance,&color,sans);\n            sans=DestroyExceptionInfo(sans);\n            if (status == MagickFalse)\n              draw_info->stroke_pattern=GetImageCache(mogrify_info,argv[i+1],\n                exception);\n            else\n              draw_info->stroke=color;\n            break;\n          }\n        if (LocaleCompare(\"strokewidth\",option+1) == 0)\n          {\n            draw_info->stroke_width=StringToDouble(argv[i+1],(char **) NULL);\n            break;\n          }\n        if (LocaleCompare(\"style\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                draw_info->style=UndefinedStyle;\n                break;\n              }\n            draw_info->style=(StyleType) ParseCommandOption(MagickStyleOptions,\n              MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"swirl\",option+1) == 0)\n          {\n            /*\n              Swirl image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseGeometry(argv[i+1],&geometry_info);\n            mogrify_image=SwirlImage(*image,geometry_info.rho,\n              interpolate_method,exception);\n            break;\n          }\n        break;\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"threshold\",option+1) == 0)\n          {\n            double\n              threshold;\n\n            /*\n              Threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              threshold=(double) QuantumRange/2;\n            else\n              threshold=StringToDoubleInterval(argv[i+1],(double) QuantumRange+\n                1.0);\n            (void) BilevelImage(*image,threshold,exception);\n            break;\n          }\n        if (LocaleCompare(\"thumbnail\",option+1) == 0)\n          {\n            /*\n              Thumbnail image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) ParseRegionGeometry(*image,argv[i+1],&geometry,exception);\n            mogrify_image=ThumbnailImage(*image,geometry.width,geometry.height,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"tile\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (draw_info->fill_pattern != (Image *) NULL)\n                  draw_info->fill_pattern=DestroyImage(draw_info->fill_pattern);\n                break;\n              }\n            draw_info->fill_pattern=GetImageCache(mogrify_info,argv[i+1],\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"tint\",option+1) == 0)\n          {\n            /*\n              Tint the image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TintImage(*image,argv[i+1],&fill,exception);\n            break;\n          }\n        if (LocaleCompare(\"transform\",option+1) == 0)\n          {\n            /*\n              Affine transform image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=AffineTransformImage(*image,&draw_info->affine,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"transparent\",option+1) == 0)\n          {\n            PixelInfo\n              target;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,&target,\n              exception);\n            (void) TransparentPaintImage(*image,&target,(Quantum)\n              TransparentAlpha,*option == '-' ? MagickFalse : MagickTrue,\n              exception);\n            break;\n          }\n        if (LocaleCompare(\"transpose\",option+1) == 0)\n          {\n            /*\n              Transpose image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TransposeImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"transverse\",option+1) == 0)\n          {\n            /*\n              Transverse image scanlines.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TransverseImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"treedepth\",option+1) == 0)\n          {\n            quantize_info->tree_depth=StringToUnsignedLong(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"trim\",option+1) == 0)\n          {\n            /*\n              Trim image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=TrimImage(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"type\",option+1) == 0)\n          {\n            ImageType\n              type;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              type=UndefinedType;\n            else\n              type=(ImageType) ParseCommandOption(MagickTypeOptions,MagickFalse,\n                argv[i+1]);\n            (*image)->type=UndefinedType;\n            (void) SetImageType(*image,type,exception);\n            break;\n          }\n        break;\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"undercolor\",option+1) == 0)\n          {\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &draw_info->undercolor,exception);\n            break;\n          }\n        if (LocaleCompare(\"unique\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageArtifact(*image,\"identify:unique-colors\");\n                break;\n              }\n            (void) SetImageArtifact(*image,\"identify:unique-colors\",\"true\");\n            (void) SetImageArtifact(*image,\"verbose\",\"true\");\n            break;\n          }\n        if (LocaleCompare(\"unique-colors\",option+1) == 0)\n          {\n            /*\n              Unique image colors.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            mogrify_image=UniqueImageColors(*image,exception);\n            break;\n          }\n        if (LocaleCompare(\"unsharp\",option+1) == 0)\n          {\n            /*\n              Unsharp mask image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=1.0;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=0.05;\n            mogrify_image=UnsharpMaskImage(*image,geometry_info.rho,\n              geometry_info.sigma,geometry_info.xi,geometry_info.psi,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            (void) SetImageArtifact(*image,option+1,\n              *option == '+' ? \"false\" : \"true\");\n            break;\n          }\n        if (LocaleCompare(\"vignette\",option+1) == 0)\n          {\n            /*\n              Vignette image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            if ((flags & XiValue) == 0)\n              geometry_info.xi=0.1*(*image)->columns;\n            if ((flags & PsiValue) == 0)\n              geometry_info.psi=0.1*(*image)->rows;\n            if ((flags & PercentValue) != 0)\n              {\n                geometry_info.xi*=(double) (*image)->columns/100.0;\n                geometry_info.psi*=(double) (*image)->rows/100.0;\n              }\n            mogrify_image=VignetteImage(*image,geometry_info.rho,\n              geometry_info.sigma,(ssize_t) ceil(geometry_info.xi-0.5),\n              (ssize_t) ceil(geometry_info.psi-0.5),exception);\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageVirtualPixelMethod(*image,\n                  UndefinedVirtualPixelMethod,exception);\n                break;\n              }\n            (void) SetImageVirtualPixelMethod(*image,(VirtualPixelMethod)\n              ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i+1]),exception);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"wave\",option+1) == 0)\n          {\n            /*\n              Wave image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=1.0;\n            mogrify_image=WaveImage(*image,geometry_info.rho,\n              geometry_info.sigma,interpolate_method,exception);\n            break;\n          }\n        if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n          {\n            /*\n              Wavelet denoise image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            flags=ParseGeometry(argv[i+1],&geometry_info);\n            if ((flags & PercentValue) != 0)\n              {\n                geometry_info.rho=QuantumRange*geometry_info.rho/100.0;\n                geometry_info.sigma=QuantumRange*geometry_info.sigma/100.0;\n              }\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=0.0;\n            mogrify_image=WaveletDenoiseImage(*image,geometry_info.rho,\n              geometry_info.sigma,exception);\n            break;\n          }\n        if (LocaleCompare(\"weight\",option+1) == 0)\n          {\n            ssize_t\n              weight;\n\n            weight=ParseCommandOption(MagickWeightOptions,MagickFalse,\n              argv[i+1]);\n            if (weight == -1)\n              weight=(ssize_t) StringToUnsignedLong(argv[i+1]);\n            draw_info->weight=(size_t) weight;\n            break;\n          }\n        if (LocaleCompare(\"white-threshold\",option+1) == 0)\n          {\n            /*\n              White threshold image.\n            */\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            (void) WhiteThresholdImage(*image,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"write-mask\",option+1) == 0)\n          {\n            Image\n              *mask;\n\n            (void) SyncImageSettings(mogrify_info,*image,exception);\n            if (*option == '+')\n              {\n                /*\n                  Remove a mask.\n                */\n                (void) SetImageMask(*image,WritePixelMask,(Image *) NULL,\n                  exception);\n                break;\n              }\n            /*\n              Set the image mask.\n            */\n            mask=GetImageCache(mogrify_info,argv[i+1],exception);\n            if (mask == (Image *) NULL)\n              break;\n            (void) SetImageMask(*image,WritePixelMask,mask,exception);\n            mask=DestroyImage(mask);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    /*\n       Replace current image with any image that was generated\n    */\n    if (mogrify_image != (Image *) NULL)\n      ReplaceImageInListReturnLast(image,mogrify_image);\n    i+=count;\n  }\n  /*\n    Free resources.\n  */\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status=(MagickStatusType) (exception->severity < ErrorException ? 1 : 0);\n  return(status == 0 ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+    M o g r i f y I m a g e C o m m a n d                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImageCommand() transforms an image or a sequence of images. These\n%  transforms include image scaling, image rotation, color reduction, and\n%  others. The transmogrified image overwrites the original image.\n%\n%  The format of the MogrifyImageCommand method is:\n%\n%      MagickBooleanType MogrifyImageCommand(ImageInfo *image_info,int argc,\n%        const char **argv,char **metadata,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o metadata: any metadata is returned here.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType MogrifyUsage(void)\n{\n  static const char\n    channel_operators[] =\n      \"  -channel-fx expression\\n\"\n      \"                       exchange, extract, or transfer one or more image channels\\n\"\n      \"  -separate            separate an image channel into a grayscale image\",\n    miscellaneous[] =\n      \"  -debug events        display copious debugging information\\n\"\n      \"  -distribute-cache port\\n\"\n      \"                       distributed pixel cache spanning one or more servers\\n\"\n      \"  -help                print program options\\n\"\n      \"  -list type           print a list of supported option arguments\\n\"\n      \"  -log format          format of debugging information\\n\"\n      \"  -version             print version information\",\n    operators[] =\n      \"  -adaptive-blur geometry\\n\"\n      \"                       adaptively blur pixels; decrease effect near edges\\n\"\n      \"  -adaptive-resize geometry\\n\"\n      \"                       adaptively resize image using 'mesh' interpolation\\n\"\n      \"  -adaptive-sharpen geometry\\n\"\n      \"                       adaptively sharpen pixels; increase effect near edges\\n\"\n      \"  -alpha option        on, activate, off, deactivate, set, opaque, copy\\n\"\n      \"                       transparent, extract, background, or shape\\n\"\n      \"  -annotate geometry text\\n\"\n      \"                       annotate the image with text\\n\"\n      \"  -auto-gamma          automagically adjust gamma level of image\\n\"\n      \"  -auto-level          automagically adjust color levels of image\\n\"\n      \"  -auto-orient         automagically orient (rotate) image\\n\"\n      \"  -auto-threshold method\\n\"\n      \"                       automatically perform image thresholding\\n\"\n      \"  -bench iterations    measure performance\\n\"\n      \"  -black-threshold value\\n\"\n      \"                       force all pixels below the threshold into black\\n\"\n      \"  -blue-shift          simulate a scene at nighttime in the moonlight\\n\"\n      \"  -blur geometry       reduce image noise and reduce detail levels\\n\"\n      \"  -border geometry     surround image with a border of color\\n\"\n      \"  -bordercolor color   border color\\n\"\n      \"  -brightness-contrast geometry\\n\"\n      \"                       improve brightness / contrast of the image\\n\"\n      \"  -canny geometry      detect edges in the image\\n\"\n      \"  -cdl filename        color correct with a color decision list\\n\"\n      \"  -channel mask        set the image channel mask\\n\"\n      \"  -charcoal geometry   simulate a charcoal drawing\\n\"\n      \"  -chop geometry       remove pixels from the image interior\\n\"\n      \"  -clahe geometry      contrast limited adaptive histogram equalization\\n\"\n      \"  -clamp               keep pixel values in range (0-QuantumRange)\\n\"\n      \"  -clip                clip along the first path from the 8BIM profile\\n\"\n      \"  -clip-mask filename  associate a clip mask with the image\\n\"\n      \"  -clip-path id        clip along a named path from the 8BIM profile\\n\"\n      \"  -colorize value      colorize the image with the fill color\\n\"\n      \"  -color-matrix matrix apply color correction to the image\\n\"\n      \"  -connected-components connectivity\\n\"\n      \"                       connected-components uniquely labeled\\n\"\n      \"  -contrast            enhance or reduce the image contrast\\n\"\n      \"  -contrast-stretch geometry\\n\"\n      \"                       improve contrast by 'stretching' the intensity range\\n\"\n      \"  -convolve coefficients\\n\"\n      \"                       apply a convolution kernel to the image\\n\"\n      \"  -cycle amount        cycle the image colormap\\n\"\n      \"  -decipher filename   convert cipher pixels to plain pixels\\n\"\n      \"  -deskew threshold    straighten an image\\n\"\n      \"  -despeckle           reduce the speckles within an image\\n\"\n      \"  -distort method args\\n\"\n      \"                       distort images according to given method ad args\\n\"\n      \"  -draw string         annotate the image with a graphic primitive\\n\"\n      \"  -edge radius         apply a filter to detect edges in the image\\n\"\n      \"  -encipher filename   convert plain pixels to cipher pixels\\n\"\n      \"  -emboss radius       emboss an image\\n\"\n      \"  -enhance             apply a digital filter to enhance a noisy image\\n\"\n      \"  -equalize            perform histogram equalization to an image\\n\"\n      \"  -evaluate operator value\\n\"\n      \"                       evaluate an arithmetic, relational, or logical expression\\n\"\n      \"  -extent geometry     set the image size\\n\"\n      \"  -extract geometry    extract area from image\\n\"\n      \"  -fft                 implements the discrete Fourier transform (DFT)\\n\"\n      \"  -flip                flip image vertically\\n\"\n      \"  -floodfill geometry color\\n\"\n      \"                       floodfill the image with color\\n\"\n      \"  -flop                flop image horizontally\\n\"\n      \"  -frame geometry      surround image with an ornamental border\\n\"\n      \"  -function name parameters\\n\"\n      \"                       apply function over image values\\n\"\n      \"  -gamma value         level of gamma correction\\n\"\n      \"  -gaussian-blur geometry\\n\"\n      \"                       reduce image noise and reduce detail levels\\n\"\n      \"  -geometry geometry   preferred size or location of the image\\n\"\n      \"  -grayscale method    convert image to grayscale\\n\"\n      \"  -hough-lines geometry\\n\"\n      \"                       identify lines in the image\\n\"\n      \"  -identify            identify the format and characteristics of the image\\n\"\n      \"  -ift                 implements the inverse discrete Fourier transform (DFT)\\n\"\n      \"  -implode amount      implode image pixels about the center\\n\"\n      \"  -interpolative-resize geometry\\n\"\n      \"                       resize image using interpolation\\n\"\n      \"  -kuwahara geometry   edge preserving noise reduction filter\\n\"\n      \"  -lat geometry        local adaptive thresholding\\n\"\n      \"  -level value         adjust the level of image contrast\\n\"\n      \"  -level-colors color,color\\n\"\n      \"                       level image with the given colors\\n\"\n      \"  -linear-stretch geometry\\n\"\n      \"                       improve contrast by 'stretching with saturation'\\n\"\n      \"  -liquid-rescale geometry\\n\"\n      \"                       rescale image with seam-carving\\n\"\n      \"  -local-contrast geometry\\n\"\n      \"                       enhance local contrast\\n\"\n      \"  -magnify             double the size of the image with pixel art scaling\\n\"\n      \"  -mean-shift geometry delineate arbitrarily shaped clusters in the image\\n\"\n      \"  -median geometry     apply a median filter to the image\\n\"\n      \"  -mode geometry       make each pixel the 'predominant color' of the\\n\"\n      \"                       neighborhood\\n\"\n      \"  -modulate value      vary the brightness, saturation, and hue\\n\"\n      \"  -monochrome          transform image to black and white\\n\"\n      \"  -morphology method kernel\\n\"\n      \"                       apply a morphology method to the image\\n\"\n      \"  -motion-blur geometry\\n\"\n      \"                       simulate motion blur\\n\"\n      \"  -negate              replace every pixel with its complementary color \\n\"\n      \"  -noise geometry      add or reduce noise in an image\\n\"\n      \"  -normalize           transform image to span the full range of colors\\n\"\n      \"  -opaque color        change this color to the fill color\\n\"\n      \"  -ordered-dither NxN\\n\"\n      \"                       add a noise pattern to the image with specific\\n\"\n      \"                       amplitudes\\n\"\n      \"  -paint radius        simulate an oil painting\\n\"\n      \"  -perceptible epsilon\\n\"\n      \"                       pixel value less than |epsilon| become epsilon or\\n\"\n      \"                       -epsilon\\n\"\n      \"  -polaroid angle      simulate a Polaroid picture\\n\"\n      \"  -posterize levels    reduce the image to a limited number of color levels\\n\"\n      \"  -profile filename    add, delete, or apply an image profile\\n\"\n      \"  -quantize colorspace reduce colors in this colorspace\\n\"\n      \"  -raise value         lighten/darken image edges to create a 3-D effect\\n\"\n      \"  -random-threshold low,high\\n\"\n      \"                       random threshold the image\\n\"\n      \"  -range-threshold values\\n\"\n      \"                       perform either hard or soft thresholding within some range of values in an image\\n\"\n      \"  -region geometry     apply options to a portion of the image\\n\"\n      \"  -render              render vector graphics\\n\"\n      \"  -repage geometry     size and location of an image canvas\\n\"\n      \"  -resample geometry   change the resolution of an image\\n\"\n      \"  -resize geometry     resize the image\\n\"\n      \"  -roll geometry       roll an image vertically or horizontally\\n\"\n      \"  -rotate degrees      apply Paeth rotation to the image\\n\"\n      \"  -rotational-blur angle\\n\"\n      \"                       rotational blur the image\\n\"\n      \"  -sample geometry     scale image with pixel sampling\\n\"\n      \"  -scale geometry      scale the image\\n\"\n      \"  -segment values      segment an image\\n\"\n      \"  -selective-blur geometry\\n\"\n      \"                       selectively blur pixels within a contrast threshold\\n\"\n      \"  -sepia-tone threshold\\n\"\n      \"                       simulate a sepia-toned photo\\n\"\n      \"  -set property value  set an image property\\n\"\n      \"  -shade degrees       shade the image using a distant light source\\n\"\n      \"  -shadow geometry     simulate an image shadow\\n\"\n      \"  -sharpen geometry    sharpen the image\\n\"\n      \"  -shave geometry      shave pixels from the image edges\\n\"\n      \"  -shear geometry      slide one edge of the image along the X or Y axis\\n\"\n      \"  -sigmoidal-contrast geometry\\n\"\n      \"                       increase the contrast without saturating highlights or\\n\"\n      \"                       shadows\\n\"\n      \"  -sketch geometry     simulate a pencil sketch\\n\"\n      \"  -solarize threshold  negate all pixels above the threshold level\\n\"\n      \"  -sparse-color method args\\n\"\n      \"                       fill in a image based on a few color points\\n\"\n      \"  -splice geometry     splice the background color into the image\\n\"\n      \"  -spread radius       displace image pixels by a random amount\\n\"\n      \"  -statistic type radius\\n\"\n      \"                       replace each pixel with corresponding statistic from the neighborhood\\n\"\n      \"  -strip               strip image of all profiles and comments\\n\"\n      \"  -swirl degrees       swirl image pixels about the center\\n\"\n      \"  -threshold value     threshold the image\\n\"\n      \"  -thumbnail geometry  create a thumbnail of the image\\n\"\n      \"  -tile filename       tile image when filling a graphic primitive\\n\"\n      \"  -tint value          tint the image with the fill color\\n\"\n      \"  -transform           affine transform image\\n\"\n      \"  -transparent color   make this color transparent within the image\\n\"\n      \"  -transpose           flip image vertically and rotate 90 degrees\\n\"\n      \"  -transverse          flop image horizontally and rotate 270 degrees\\n\"\n      \"  -trim                trim image edges\\n\"\n      \"  -type type           image type\\n\"\n      \"  -unique-colors       discard all but one of any pixel color\\n\"\n      \"  -unsharp geometry    sharpen the image\\n\"\n      \"  -vignette geometry   soften the edges of the image in vignette style\\n\"\n      \"  -wave geometry       alter an image along a sine wave\\n\"\n      \"  -wavelet-denoise threshold\\n\"\n      \"                       removes noise from the image using a wavelet transform\\n\"\n      \"  -white-threshold value\\n\"\n      \"                       force all pixels above the threshold into white\",\n    sequence_operators[] =\n      \"  -affinity filename   transform image colors to match this set of colors\\n\"\n      \"  -append              append an image sequence\\n\"\n      \"  -clut                apply a color lookup table to the image\\n\"\n      \"  -coalesce            merge a sequence of images\\n\"\n      \"  -combine             combine a sequence of images\\n\"\n      \"  -compare             mathematically and visually annotate the difference between an image and its reconstruction\\n\"\n      \"  -complex operator    perform complex mathematics on an image sequence\\n\"\n      \"  -composite           composite image\\n\"\n      \"  -copy geometry offset\\n\"\n      \"                       copy pixels from one area of an image to another\\n\"\n      \"  -crop geometry       cut out a rectangular region of the image\\n\"\n      \"  -deconstruct         break down an image sequence into constituent parts\\n\"\n      \"  -evaluate-sequence operator\\n\"\n      \"                       evaluate an arithmetic, relational, or logical expression\\n\"\n      \"  -flatten             flatten a sequence of images\\n\"\n      \"  -fx expression       apply mathematical expression to an image channel(s)\\n\"\n      \"  -hald-clut           apply a Hald color lookup table to the image\\n\"\n      \"  -layers method       optimize, merge, or compare image layers\\n\"\n      \"  -morph value         morph an image sequence\\n\"\n      \"  -mosaic              create a mosaic from an image sequence\\n\"\n      \"  -poly terms          build a polynomial from the image sequence and the corresponding\\n\"\n      \"                       terms (coefficients and degree pairs).\\n\"\n      \"  -print string        interpret string and print to console\\n\"\n      \"  -process arguments   process the image with a custom image filter\\n\"\n      \"  -smush geometry      smush an image sequence together\\n\"\n      \"  -write filename      write images to this file\",\n    settings[] =\n      \"  -adjoin              join images into a single multi-image file\\n\"\n      \"  -affine matrix       affine transform matrix\\n\"\n      \"  -alpha option        activate, deactivate, reset, or set the alpha channel\\n\"\n      \"  -antialias           remove pixel-aliasing\\n\"\n      \"  -authenticate password\\n\"\n      \"                       decipher image with this password\\n\"\n      \"  -attenuate value     lessen (or intensify) when adding noise to an image\\n\"\n      \"  -background color    background color\\n\"\n      \"  -bias value          add bias when convolving an image\\n\"\n      \"  -black-point-compensation\\n\"\n      \"                       use black point compensation\\n\"\n      \"  -blue-primary point  chromaticity blue primary point\\n\"\n      \"  -bordercolor color   border color\\n\"\n      \"  -caption string      assign a caption to an image\\n\"\n      \"  -colors value        preferred number of colors in the image\\n\"\n      \"  -colorspace type     alternate image colorspace\\n\"\n      \"  -comment string      annotate image with comment\\n\"\n      \"  -compose operator    set image composite operator\\n\"\n      \"  -compress type       type of pixel compression when writing the image\\n\"\n      \"  -define format:option=value\\n\"\n      \"                       define one or more image format options\\n\"\n      \"  -delay value         display the next image after pausing\\n\"\n      \"  -density geometry    horizontal and vertical density of the image\\n\"\n      \"  -depth value         image depth\\n\"\n      \"  -direction type      render text right-to-left or left-to-right\\n\"\n      \"  -display server      get image or font from this X server\\n\"\n      \"  -dispose method      layer disposal method\\n\"\n      \"  -dither method       apply error diffusion to image\\n\"\n      \"  -encoding type       text encoding type\\n\"\n      \"  -endian type         endianness (MSB or LSB) of the image\\n\"\n      \"  -family name         render text with this font family\\n\"\n      \"  -features distance   analyze image features (e.g. contrast, correlation)\\n\"\n      \"  -fill color          color to use when filling a graphic primitive\\n\"\n      \"  -filter type         use this filter when resizing an image\\n\"\n      \"  -font name           render text with this font\\n\"\n      \"  -format \\\"string\\\"   output formatted image characteristics\\n\"\n      \"  -fuzz distance       colors within this distance are considered equal\\n\"\n      \"  -gravity type        horizontal and vertical text placement\\n\"\n      \"  -green-primary point chromaticity green primary point\\n\"\n      \"  -intensity method    method to generate an intensity value from a pixel\\n\"\n      \"  -intent type         type of rendering intent when managing the image color\\n\"\n      \"  -interlace type      type of image interlacing scheme\\n\"\n      \"  -interline-spacing value\\n\"\n      \"                       set the space between two text lines\\n\"\n      \"  -interpolate method  pixel color interpolation method\\n\"\n      \"  -interword-spacing value\\n\"\n      \"                       set the space between two words\\n\"\n      \"  -kerning value       set the space between two letters\\n\"\n      \"  -label string        assign a label to an image\\n\"\n      \"  -limit type value    pixel cache resource limit\\n\"\n      \"  -loop iterations     add Netscape loop extension to your GIF animation\\n\"\n      \"  -matte               store matte channel if the image has one\\n\"\n      \"  -mattecolor color    frame color\\n\"\n      \"  -monitor             monitor progress\\n\"\n      \"  -orient type         image orientation\\n\"\n      \"  -page geometry       size and location of an image canvas (setting)\\n\"\n      \"  -path path           write images to this path on disk\\n\"\n      \"  -ping                efficiently determine image attributes\\n\"\n      \"  -pointsize value     font point size\\n\"\n      \"  -precision value     maximum number of significant digits to print\\n\"\n      \"  -preview type        image preview type\\n\"\n      \"  -quality value       JPEG/MIFF/PNG compression level\\n\"\n      \"  -quiet               suppress all warning messages\\n\"\n      \"  -read-mask filename  associate a read mask with the image\\n\"\n      \"  -red-primary point   chromaticity red primary point\\n\"\n      \"  -regard-warnings     pay attention to warning messages\\n\"\n      \"  -remap filename      transform image colors to match this set of colors\\n\"\n      \"  -respect-parentheses settings remain in effect until parenthesis boundary\\n\"\n      \"  -sampling-factor geometry\\n\"\n      \"                       horizontal and vertical sampling factor\\n\"\n      \"  -scene value         image scene number\\n\"\n      \"  -seed value          seed a new sequence of pseudo-random numbers\\n\"\n      \"  -size geometry       width and height of image\\n\"\n      \"  -stretch type        render text with this font stretch\\n\"\n      \"  -stroke color        graphic primitive stroke color\\n\"\n      \"  -strokewidth value   graphic primitive stroke width\\n\"\n      \"  -style type          render text with this font style\\n\"\n      \"  -synchronize         synchronize image to storage device\\n\"\n      \"  -taint               declare the image as modified\\n\"\n      \"  -texture filename    name of texture to tile onto the image background\\n\"\n      \"  -tile-offset geometry\\n\"\n      \"                       tile offset\\n\"\n      \"  -treedepth value     color tree depth\\n\"\n      \"  -transparent-color color\\n\"\n      \"                       transparent color\\n\"\n      \"  -undercolor color    annotation bounding box color\\n\"\n      \"  -units type          the units of image resolution\\n\"\n      \"  -verbose             print detailed information about the image\\n\"\n      \"  -view                FlashPix viewing transforms\\n\"\n      \"  -virtual-pixel method\\n\"\n      \"                       virtual pixel access method\\n\"\n      \"  -weight type         render text with this font weight\\n\"\n      \"  -white-point point   chromaticity white point\\n\"\n      \"  -write-mask filename associate a write mask with the image\",\n    stack_operators[] =\n      \"  -delete indexes      delete the image from the image sequence\\n\"\n      \"  -duplicate count,indexes\\n\"\n      \"                       duplicate an image one or more times\\n\"\n      \"  -insert index        insert last image into the image sequence\\n\"\n      \"  -reverse             reverse image sequence\\n\"\n      \"  -swap indexes        swap two images in the image sequence\";\n\n  ListMagickVersion(stdout);\n  (void) printf(\"Usage: %s [options ...] file [ [options ...] file ...]\\n\",\n    GetClientName());\n  (void) printf(\"\\nImage Settings:\\n\");\n  (void) puts(settings);\n  (void) printf(\"\\nImage Operators:\\n\");\n  (void) puts(operators);\n  (void) printf(\"\\nImage Channel Operators:\\n\");\n  (void) puts(channel_operators);\n  (void) printf(\"\\nImage Sequence Operators:\\n\");\n  (void) puts(sequence_operators);\n  (void) printf(\"\\nImage Stack Operators:\\n\");\n  (void) puts(stack_operators);\n  (void) printf(\"\\nMiscellaneous Options:\\n\");\n  (void) puts(miscellaneous);\n  (void) printf(\n    \"\\nBy default, the image format of 'file' is determined by its magic\\n\");\n  (void) printf(\n    \"number.  To specify a particular image format, precede the filename\\n\");\n  (void) printf(\n    \"with an image format name and a colon (i.e. ps:image) or specify the\\n\");\n  (void) printf(\n    \"image type as the filename suffix (i.e. image.ps).  Specify 'file' as\\n\");\n  (void) printf(\"'-' for standard input or output.\\n\");\n  return(MagickFalse);\n}\n\nWandExport MagickBooleanType MogrifyImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **wand_unused(metadata),ExceptionInfo *exception)\n{\n#define DestroyMogrify() \\\n{ \\\n  if (format != (char *) NULL) \\\n    format=DestroyString(format); \\\n  if (path != (char *) NULL) \\\n    path=DestroyString(path); \\\n  DestroyImageStack(); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowMogrifyException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n    option); \\\n  DestroyMogrify(); \\\n  return(MagickFalse); \\\n}\n#define ThrowMogrifyInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",argument,option); \\\n  DestroyMogrify(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    *format,\n    *option,\n    *path;\n\n  Image\n    *image;\n\n  ImageStack\n    image_stack[MaxImageStackDepth+1];\n\n  MagickBooleanType\n    global_colormap;\n\n  MagickBooleanType\n    fire,\n    pend,\n    respect_parenthesis;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j,\n    k;\n\n  wand_unreferenced(metadata);\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc == 2)\n    {\n      option=argv[1];\n      if ((LocaleCompare(\"version\",option+1) == 0) ||\n          (LocaleCompare(\"-version\",option+1) == 0))\n        {\n          ListMagickVersion(stdout);\n          return(MagickTrue);\n        }\n    }\n  if (argc < 2)\n    return(MogrifyUsage());\n  format=(char *) NULL;\n  path=(char *) NULL;\n  global_colormap=MagickFalse;\n  k=0;\n  j=1;\n  NewImageStack();\n  option=(char *) NULL;\n  pend=MagickFalse;\n  respect_parenthesis=MagickFalse;\n  status=MagickTrue;\n  /*\n    Parse command line.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowMogrifyException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (LocaleCompare(option,\"(\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,pend);\n        if (k == MaxImageStackDepth)\n          ThrowMogrifyException(OptionError,\"ParenthesisNestedTooDeeply\",\n            option);\n        PushImageStack();\n        continue;\n      }\n    if (LocaleCompare(option,\")\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n        if (k == 0)\n          ThrowMogrifyException(OptionError,\"UnableToParseExpression\",option);\n        PopImageStack();\n        continue;\n      }\n    if (IsCommandOption(option) == MagickFalse)\n      {\n        char\n          backup_filename[MagickPathExtent],\n          *filename;\n\n        Image\n          *images;\n\n        struct stat\n          properties;\n\n        /*\n          Option is a file name: begin by reading image from specified file.\n        */\n        FireImageStack(MagickFalse,MagickFalse,pend);\n        filename=argv[i];\n        if ((LocaleCompare(filename,\"--\") == 0) && (i < (ssize_t) (argc-1)))\n          filename=argv[++i];\n        images=ReadImages(image_info,filename,exception);\n        status&=(images != (Image *) NULL) &&\n          (exception->severity < ErrorException);\n        if (images == (Image *) NULL)\n          continue;\n        properties=(*GetBlobProperties(images));\n        if (format != (char *) NULL)\n          (void) CopyMagickString(images->filename,images->magick_filename,\n            MagickPathExtent);\n        if (path != (char *) NULL)\n          {\n            GetPathComponent(option,TailPath,filename);\n            (void) FormatLocaleString(images->filename,MagickPathExtent,\n              \"%s%c%s\",path,*DirectorySeparator,filename);\n          }\n        if (format != (char *) NULL)\n          AppendImageFormat(format,images->filename);\n        AppendImageStack(images);\n        FinalizeImageSettings(image_info,image,MagickFalse);\n        if (global_colormap != MagickFalse)\n          {\n            QuantizeInfo\n              *quantize_info;\n\n            quantize_info=AcquireQuantizeInfo(image_info);\n            (void) RemapImages(quantize_info,images,(Image *) NULL,exception);\n            quantize_info=DestroyQuantizeInfo(quantize_info);\n          }\n        *backup_filename='\\0';\n        if ((LocaleCompare(image->filename,\"-\") != 0) &&\n            (IsPathWritable(image->filename) != MagickFalse))\n          {\n            /*\n              Rename image file as backup.\n            */\n            (void) CopyMagickString(backup_filename,image->filename,\n              MagickPathExtent);\n            for (j=0; j < 6; j++)\n            {\n              (void) ConcatenateMagickString(backup_filename,\"~\",\n                MagickPathExtent);\n              if (IsPathAccessible(backup_filename) == MagickFalse)\n                break;\n            }\n            if ((IsPathAccessible(backup_filename) != MagickFalse) ||\n                (rename_utf8(image->filename,backup_filename) != 0))\n              *backup_filename='\\0';\n          }\n        /*\n          Write transmogrified image to disk.\n        */\n        image_info->synchronize=MagickTrue;\n        status&=WriteImages(image_info,image,image->filename,exception);\n        if (status != MagickFalse)\n          {\n#if defined(MAGICKCORE_HAVE_UTIME)\n            {\n              MagickBooleanType\n                preserve_timestamp;\n\n              preserve_timestamp=IsStringTrue(GetImageOption(image_info,\n                \"preserve-timestamp\"));\n              if (preserve_timestamp != MagickFalse)\n                {\n                  struct utimbuf\n                    timestamp;\n\n                  timestamp.actime=properties.st_atime;\n                  timestamp.modtime=properties.st_mtime;\n                  (void) utime(image->filename,&timestamp);\n                }\n            }\n#endif\n            if (*backup_filename != '\\0')\n              (void) remove_utf8(backup_filename);\n          }\n        RemoveAllImageStack();\n        continue;\n      }\n    pend=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"affine\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,\n              argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\n                \"UnrecognizedAlphaChannelOption\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"annotate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"append\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"attenuate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"auto-level\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"auto-orient\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickAutoThresholdOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedThresholdMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'b':\n      {\n        if (LocaleCompare(\"background\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"bias\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"black-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"blue-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"blue-shift\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"border\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"bordercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"box\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"canny\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"caption\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            channel=ParseChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"channel-fx\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            channel=ParsePixelChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"cdl\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"charcoal\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"chop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"clahe\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"clamp\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"clip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"clip-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"colorize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"color-matrix\",option+1) == 0)\n          {\n            KernelInfo\n              *kernel_info;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            kernel_info=AcquireKernelInfo(argv[i],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"colors\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"compare\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"comment\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"compress\",option+1) == 0)\n          {\n            ssize_t\n              compress;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            compress=ParseCommandOption(MagickCompressOptions,MagickFalse,\n              argv[i]);\n            if (compress < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageCompression\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"connected-components\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"contrast\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"convolve\",option+1) == 0)\n          {\n            KernelInfo\n              *kernel_info;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            kernel_info=AcquireKernelInfo(argv[i],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"crop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"cycle\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"decipher\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                const char\n                  *define;\n\n                define=GetImageOption(image_info,argv[i]);\n                if (define == (const char *) NULL)\n                  ThrowMogrifyException(OptionError,\"NoSuchOption\",argv[i]);\n                break;\n              }\n            break;\n          }\n        if (LocaleCompare(\"delay\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"deskew\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"despeckle\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"dft\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"direction\",option+1) == 0)\n          {\n            ssize_t\n              direction;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,\n              argv[i]);\n            if (direction < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDirectionType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"display\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"dispose\",option+1) == 0)\n          {\n            ssize_t\n              dispose;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n              argv[i]);\n            if (dispose < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDisposeMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"distort\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickDistortOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDistortMethod\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickDitherOptions,MagickFalse,argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedDitherMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"draw\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"edge\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"emboss\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"encipher\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"encoding\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"endian\",option+1) == 0)\n          {\n            ssize_t\n              endian;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            endian=ParseCommandOption(MagickEndianOptions,MagickFalse,argv[i]);\n            if (endian < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEndianType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"enhance\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"equalize\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"evaluate\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickEvaluateOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEvaluateOperator\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickEvaluateOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedEvaluateOperator\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"extent\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"extract\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"family\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"features\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"fill\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"filter\",option+1) == 0)\n          {\n            ssize_t\n              filter;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            filter=ParseCommandOption(MagickFilterOptions,MagickFalse,argv[i]);\n            if (filter < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageFilter\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"flip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"flop\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"floodfill\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"font\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            (void) CopyMagickString(argv[i]+1,\"sans\",MagickPathExtent);\n            (void) CloneString(&format,(char *) NULL);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            (void) CloneString(&format,argv[i]);\n            (void) CopyMagickString(image_info->filename,format,\n              MagickPathExtent);\n            (void) ConcatenateMagickString(image_info->filename,\":\",\n              MagickPathExtent);\n            (void) SetImageInfo(image_info,0,exception);\n            if (*image_info->magick == '\\0')\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageFormat\",\n                format);\n            break;\n          }\n        if (LocaleCompare(\"frame\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"function\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickFunctionOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedFunction\",argv[i]);\n             i++;\n             if (i == (ssize_t) argc)\n               ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"fuzz\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gamma\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if ((LocaleCompare(\"gaussian-blur\",option+1) == 0) ||\n            (LocaleCompare(\"gaussian\",option+1) == 0))\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"geometry\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"gravity\",option+1) == 0)\n          {\n            ssize_t\n              gravity;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,\n              argv[i]);\n            if (gravity < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedGravityType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"grayscale\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedIntensityMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"green-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          break;\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          return(MogrifyUsage());\n        if (LocaleCompare(\"hough-lines\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"identify\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"idft\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"implode\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"intensity\",option+1) == 0)\n          {\n            ssize_t\n              intensity;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            intensity=ParseCommandOption(MagickPixelIntensityOptions,\n              MagickFalse,argv[i]);\n            if (intensity < 0)\n              ThrowMogrifyException(OptionError,\n                \"UnrecognizedPixelIntensityMethod\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"intent\",option+1) == 0)\n          {\n            ssize_t\n              intent;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            intent=ParseCommandOption(MagickIntentOptions,MagickFalse,argv[i]);\n            if (intent < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedIntentType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            ssize_t\n              interlace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            interlace=ParseCommandOption(MagickInterlaceOptions,MagickFalse,\n              argv[i]);\n            if (interlace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedInterlaceType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            ssize_t\n              interpolate;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n              argv[i]);\n            if (interpolate < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedInterpolateMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'k':\n      {\n        if (LocaleCompare(\"kerning\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"kuwahara\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"label\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"lat\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n          }\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickLayerOptions,MagickFalse,argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedLayerMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"level\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"level-colors\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            char\n              *p;\n\n            double\n              value;\n\n            ssize_t\n              resource;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            resource=ParseCommandOption(MagickResourceOptions,MagickFalse,\n              argv[i]);\n            if (resource < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedResourceType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            value=StringToDouble(argv[i],&p);\n            (void) value;\n            if ((p == argv[i]) && (LocaleCompare(\"unlimited\",argv[i]) != 0))\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i]);\n            if (list < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedListType\",argv[i]);\n            status=MogrifyImageInfo(image_info,(int) (i-j+1),(const char **)\n              argv+j,exception);\n            return(status == 0 ? MagickFalse : MagickTrue);\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if ((i == (ssize_t) argc) ||\n                (strchr(argv[i],'%') == (char *) NULL))\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"loop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"magnify\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            global_colormap=(*option == '+') ? MagickTrue : MagickFalse;\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"mattecolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"mean-shift\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"median\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"metric\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickMetricOptions,MagickTrue,argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedMetricType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"modulate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"mode\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"monochrome\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"morphology\",option+1) == 0)\n          {\n            char\n              token[MagickPathExtent];\n\n            KernelInfo\n              *kernel_info;\n\n            ssize_t\n              op;\n\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            GetNextToken(argv[i],(const char **) NULL,MagickPathExtent,token);\n            op=ParseCommandOption(MagickMorphologyOptions,MagickFalse,token);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedMorphologyMethod\",\n                token);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            kernel_info=AcquireKernelInfo(argv[i],exception);\n            if (kernel_info == (KernelInfo *) NULL)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            kernel_info=DestroyKernelInfo(kernel_info);\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"motion-blur\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'n':\n      {\n        if (LocaleCompare(\"negate\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"noise\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                ssize_t\n                  noise;\n\n                noise=ParseCommandOption(MagickNoiseOptions,MagickFalse,\n                  argv[i]);\n                if (noise < 0)\n                  ThrowMogrifyException(OptionError,\"UnrecognizedNoiseType\",\n                    argv[i]);\n                break;\n              }\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"noop\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"normalize\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'o':\n      {\n        if (LocaleCompare(\"opaque\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"orient\",option+1) == 0)\n          {\n            ssize_t\n              orientation;\n\n            orientation=UndefinedOrientation;\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            orientation=ParseCommandOption(MagickOrientationOptions,MagickFalse,\n              argv[i]);\n            if (orientation < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageOrientation\",\n                argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"page\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"paint\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"path\",option+1) == 0)\n          {\n            (void) CloneString(&path,(char *) NULL);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            (void) CloneString(&path,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"perceptible\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"pointsize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"polaroid\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"posterize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"precision\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"profile\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quality\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"quantize\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"raise\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"random-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"range-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"read-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"red-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n          }\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"region\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"remap\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"render\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"repage\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"resample\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"resize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleNCompare(\"respect-parentheses\",option+1,17) == 0)\n          {\n            respect_parenthesis=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"roll\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"rotate\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sample\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"scale\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"scene\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"segment\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"selective-blur\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"separate\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"shade\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"shadow\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sharpen\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"shave\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"shear\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sketch\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"solarize\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"sparse-color\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickSparseColorOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedSparseColorMethod\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"splice\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"spread\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"statistic\",option+1) == 0)\n          {\n            ssize_t\n              op;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            op=ParseCommandOption(MagickStatisticOptions,MagickFalse,argv[i]);\n            if (op < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedStatisticType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"stretch\",option+1) == 0)\n          {\n            ssize_t\n              stretch;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,\n              argv[i]);\n            if (stretch < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedStyleType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"strip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"stroke\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"strokewidth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"style\",option+1) == 0)\n          {\n            ssize_t\n              style;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            style=ParseCommandOption(MagickStyleOptions,MagickFalse,argv[i]);\n            if (style < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedStyleType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"swirl\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"synchronize\",option+1) == 0)\n          break;\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"taint\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"texture\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"tile\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"tile-offset\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"tint\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"transform\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"transpose\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"transverse\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"thumbnail\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"transparent\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"transparent-color\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"treedepth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"trim\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"type\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickTypeOptions,MagickFalse,argv[i]);\n            if (type < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedImageType\",\n                argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"undercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"unique-colors\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"units\",option+1) == 0)\n          {\n            ssize_t\n              units;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            units=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n              argv[i]);\n            if (units < 0)\n              ThrowMogrifyException(OptionError,\"UnrecognizedUnitsType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"unsharp\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            image_info->verbose=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            break;\n          }\n        if (LocaleCompare(\"vignette\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowMogrifyException(OptionError,\n                \"UnrecognizedVirtualPixelMethod\",argv[i]);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"wave\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"weight\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"white-point\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"white-threshold\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowMogrifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"write-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowMogrifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case '?':\n        break;\n      default:\n        ThrowMogrifyException(OptionError,\"UnrecognizedOption\",option)\n    }\n    fire=(GetCommandOptionFlags(MagickCommandOptions,MagickFalse,option) &\n      FireOptionFlag) == 0 ?  MagickFalse : MagickTrue;\n    if (fire != MagickFalse)\n      FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n  }\n  if (k != 0)\n    ThrowMogrifyException(OptionError,\"UnbalancedParenthesis\",argv[i]);\n  if (i != (ssize_t) argc)\n    ThrowMogrifyException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  DestroyMogrify();\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e I n f o                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImageInfo() applies image processing settings to the image as\n%  prescribed by command line options.\n%\n%  The format of the MogrifyImageInfo method is:\n%\n%      MagickBooleanType MogrifyImageInfo(ImageInfo *image_info,const int argc,\n%        const char **argv,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MogrifyImageInfo(ImageInfo *image_info,\n  const int argc,const char **argv,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  GeometryInfo\n    geometry_info;\n\n  ssize_t\n    count;\n\n  register ssize_t\n    i;\n\n  /*\n    Initialize method variables.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  if (argc < 0)\n    return(MagickTrue);\n  /*\n    Set the image settings.\n  */\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"adjoin\",option+1) == 0)\n          {\n            image_info->adjoin=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          {\n            image_info->antialias=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) DeleteImageOption(image_info,option+1);\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'b':\n      {\n        if (LocaleCompare(\"background\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                (void) QueryColorCompliance(MogrifyBackgroundColor,\n                  AllCompliance,&image_info->background_color,exception);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->background_color,exception);\n            break;\n          }\n        if (LocaleCompare(\"bias\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,\"convolve:bias\",\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,\"convolve:bias\",argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"false\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,\"true\");\n            break;\n          }\n        if (LocaleCompare(\"blue-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"bordercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n                  &image_info->border_color,exception);\n                break;\n              }\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->border_color,exception);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"box\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,\"undercolor\",\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,\"undercolor\",argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            MagickSizeType\n              limit;\n\n            limit=MagickResourceInfinity;\n            if (LocaleCompare(\"unlimited\",argv[i+1]) != 0)\n              limit=(MagickSizeType) SiPrefixToDoubleInterval(argv[i+1],\n                100.0);\n            (void) SetMagickResourceLimit(MemoryResource,limit);\n            (void) SetMagickResourceLimit(MapResource,2*limit);\n            break;\n          }\n        if (LocaleCompare(\"caption\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->colorspace=UndefinedColorspace;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->colorspace=(ColorspaceType) ParseCommandOption(\n              MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"comment\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"compose\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"compress\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->compression=UndefinedCompression;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->compression=(CompressionType) ParseCommandOption(\n              MagickCompressOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetLogEventMask(\"none\");\n            else\n              (void) SetLogEventMask(argv[i+1]);\n            image_info->debug=IsEventLogging();\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n                  (void) DeleteImageRegistry(argv[i+1]+9);\n                else\n                  (void) DeleteImageOption(image_info,argv[i+1]);\n                break;\n              }\n            if (LocaleNCompare(argv[i+1],\"registry:\",9) == 0)\n              {\n                (void) DefineImageRegistry(StringRegistryType,argv[i+1]+9,\n                  exception);\n                break;\n              }\n            (void) DefineImageOption(image_info,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"delay\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            /*\n              Set image density.\n            */\n            if (*option == '+')\n              {\n                if (image_info->density != (char *) NULL)\n                  image_info->density=DestroyString(image_info->density);\n                (void) SetImageOption(image_info,option+1,\"72\");\n                break;\n              }\n            (void) CloneString(&image_info->density,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->depth=MAGICKCORE_QUANTUM_DEPTH;\n                break;\n              }\n            image_info->depth=StringToUnsignedLong(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"direction\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"display\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->server_name != (char *) NULL)\n                  image_info->server_name=DestroyString(\n                    image_info->server_name);\n                break;\n              }\n            (void) CloneString(&image_info->server_name,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"dispose\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->dither=MagickFalse;\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            image_info->dither=MagickTrue;\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"encoding\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"endian\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->endian=UndefinedEndian;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->endian=(EndianType) ParseCommandOption(\n              MagickEndianOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"extract\",option+1) == 0)\n          {\n            /*\n              Set image extract geometry.\n            */\n            if (*option == '+')\n              {\n                if (image_info->extract != (char *) NULL)\n                  image_info->extract=DestroyString(image_info->extract);\n                break;\n              }\n            (void) CloneString(&image_info->extract,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"family\",option+1) == 0)\n          {\n            if (*option != '+')\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"fill\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"filter\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"font\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->font != (char *) NULL)\n                  image_info->font=DestroyString(image_info->font);\n                break;\n              }\n            (void) CloneString(&image_info->font,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            register const char\n              *q;\n\n            for (q=strchr(argv[i+1],'%'); q != (char *) NULL; q=strchr(q+1,'%'))\n              if (strchr(\"Agkrz@[#\",*(q+1)) != (char *) NULL)\n                image_info->ping=MagickFalse;\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"fuzz\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->fuzz=0.0;\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            image_info->fuzz=StringToDoubleInterval(argv[i+1],(double)\n              QuantumRange+1.0);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gravity\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"green-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"intensity\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"intent\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->interlace=UndefinedInterlace;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->interlace=(InterlaceType) ParseCommandOption(\n              MagickInterlaceOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'k':\n      {\n        if (LocaleCompare(\"kerning\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"label\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            MagickSizeType\n              limit;\n\n            ResourceType\n              type;\n\n            if (*option == '+')\n              break;\n            type=(ResourceType) ParseCommandOption(MagickResourceOptions,\n              MagickFalse,argv[i+1]);\n            limit=MagickResourceInfinity;\n            if (LocaleCompare(\"unlimited\",argv[i+2]) != 0)\n              limit=(MagickSizeType) SiPrefixToDoubleInterval(argv[i+2],100.0);\n            (void) SetMagickResourceLimit(type,limit);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            /*\n              Display configuration list.\n            */\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i+1]);\n            switch (list)\n            {\n              case MagickCoderOptions:\n              {\n                (void) ListCoderInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickColorOptions:\n              {\n                (void) ListColorInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickConfigureOptions:\n              {\n                (void) ListConfigureInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickDelegateOptions:\n              {\n                (void) ListDelegateInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickFontOptions:\n              {\n                (void) ListTypeInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickFormatOptions:\n              {\n                (void) ListMagickInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickLocaleOptions:\n              {\n                (void) ListLocaleInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickLogOptions:\n              {\n                (void) ListLogInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickMagicOptions:\n              {\n                (void) ListMagicInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickMimeOptions:\n              {\n                (void) ListMimeInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickModuleOptions:\n              {\n                (void) ListModuleInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickPolicyOptions:\n              {\n                (void) ListPolicyInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickResourceOptions:\n              {\n                (void) ListMagickResourceInfo((FILE *) NULL,exception);\n                break;\n              }\n              case MagickThresholdOptions:\n              {\n                (void) ListThresholdMaps((FILE *) NULL,exception);\n                break;\n              }\n              default:\n              {\n                (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n                  exception);\n                break;\n              }\n            }\n            break;\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            (void) SetLogFormat(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"loop\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"false\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,\"true\");\n            break;\n          }\n        if (LocaleCompare(\"mattecolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,argv[i+1]);\n                (void) QueryColorCompliance(MogrifyAlphaColor,AllCompliance,\n                  &image_info->matte_color,exception);\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->matte_color,exception);\n            break;\n          }\n        if (LocaleCompare(\"metric\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) DeleteImageOption(image_info,option+1);\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          {\n            (void) SetImageInfoProgressMonitor(image_info,MonitorProgress,\n              (void *) NULL);\n            break;\n          }\n        if (LocaleCompare(\"monochrome\",option+1) == 0)\n          {\n            image_info->monochrome=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        break;\n      }\n      case 'o':\n      {\n        if (LocaleCompare(\"orient\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->orientation=UndefinedOrientation;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->orientation=(OrientationType) ParseCommandOption(\n              MagickOrientationOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"page\",option+1) == 0)\n          {\n            char\n              *canonical_page,\n              page[MagickPathExtent];\n\n            const char\n              *image_option;\n\n            MagickStatusType\n              flags;\n\n            RectangleInfo\n              geometry;\n\n            if (*option == '+')\n              {\n                (void) DeleteImageOption(image_info,option+1);\n                (void) CloneString(&image_info->page,(char *) NULL);\n                break;\n              }\n            (void) memset(&geometry,0,sizeof(geometry));\n            image_option=GetImageOption(image_info,\"page\");\n            if (image_option != (const char *) NULL)\n              flags=ParseAbsoluteGeometry(image_option,&geometry);\n            canonical_page=GetPageGeometry(argv[i+1]);\n            flags=ParseAbsoluteGeometry(canonical_page,&geometry);\n            canonical_page=DestroyString(canonical_page);\n            (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu\",\n              (unsigned long) geometry.width,(unsigned long) geometry.height);\n            if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n              (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu%+ld%+ld\",\n                (unsigned long) geometry.width,(unsigned long) geometry.height,\n                (long) geometry.x,(long) geometry.y);\n            (void) SetImageOption(image_info,option+1,page);\n            (void) CloneString(&image_info->page,page);\n            break;\n          }\n        if (LocaleCompare(\"ping\",option+1) == 0)\n          {\n            image_info->ping=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"pointsize\",option+1) == 0)\n          {\n            if (*option == '+')\n              geometry_info.rho=0.0;\n            else\n              (void) ParseGeometry(argv[i+1],&geometry_info);\n            image_info->pointsize=geometry_info.rho;\n            break;\n          }\n        if (LocaleCompare(\"precision\",option+1) == 0)\n          {\n            (void) SetMagickPrecision(StringToInteger(argv[i+1]));\n            break;\n          }\n        break;\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quality\",option+1) == 0)\n          {\n            /*\n              Set image compression quality.\n            */\n            if (*option == '+')\n              {\n                image_info->quality=UndefinedCompressionQuality;\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            image_info->quality=StringToUnsignedLong(argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          {\n            static WarningHandler\n              warning_handler = (WarningHandler) NULL;\n\n            if (*option == '+')\n              {\n                /*\n                  Restore error or warning messages.\n                */\n                warning_handler=SetWarningHandler(warning_handler);\n                break;\n              }\n            /*\n              Suppress error or warning messages.\n            */\n            warning_handler=SetWarningHandler((WarningHandler) NULL);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"red-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"0.0\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            /*\n              Set image sampling factor.\n            */\n            if (*option == '+')\n              {\n                if (image_info->sampling_factor != (char *) NULL)\n                  image_info->sampling_factor=DestroyString(\n                    image_info->sampling_factor);\n                break;\n              }\n            (void) CloneString(&image_info->sampling_factor,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"scene\",option+1) == 0)\n          {\n            /*\n              Set image scene.\n            */\n            if (*option == '+')\n              {\n                image_info->scene=0;\n                (void) SetImageOption(image_info,option+1,\"0\");\n                break;\n              }\n            image_info->scene=StringToUnsignedLong(argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            unsigned long\n              seed;\n\n            if (*option == '+')\n              {\n                seed=(unsigned long) time((time_t *) NULL);\n                SetRandomSecretKey(seed);\n                break;\n              }\n            seed=StringToUnsignedLong(argv[i+1]);\n            SetRandomSecretKey(seed);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->size != (char *) NULL)\n                  image_info->size=DestroyString(image_info->size);\n                break;\n              }\n            (void) CloneString(&image_info->size,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"strokewidth\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"style\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"synchronize\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->synchronize=MagickFalse;\n                break;\n              }\n            image_info->synchronize=MagickTrue;\n            break;\n          }\n        break;\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"taint\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) SetImageOption(image_info,option+1,\"false\");\n                break;\n              }\n            (void) SetImageOption(image_info,option+1,\"true\");\n            break;\n          }\n        if (LocaleCompare(\"texture\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                if (image_info->texture != (char *) NULL)\n                  image_info->texture=DestroyString(image_info->texture);\n                break;\n              }\n            (void) CloneString(&image_info->texture,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"tile-offset\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"transparent-color\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                (void) QueryColorCompliance(\"none\",AllCompliance,\n                  &image_info->transparent_color,exception);\n                (void) SetImageOption(image_info,option+1,\"none\");\n                break;\n              }\n            (void) QueryColorCompliance(argv[i+1],AllCompliance,\n              &image_info->transparent_color,exception);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"type\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->type=UndefinedType;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->type=(ImageType) ParseCommandOption(MagickTypeOptions,\n              MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"undercolor\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) DeleteImageOption(image_info,option+1);\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"units\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->units=UndefinedResolution;\n                (void) SetImageOption(image_info,option+1,\"undefined\");\n                break;\n              }\n            image_info->units=(ResolutionType) ParseCommandOption(\n              MagickResolutionOptions,MagickFalse,argv[i+1]);\n            (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                image_info->verbose=MagickFalse;\n                break;\n              }\n            image_info->verbose=MagickTrue;\n            image_info->ping=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"undefined\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"weight\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"white-point\",option+1) == 0)\n          {\n            if (*option == '+')\n              (void) SetImageOption(image_info,option+1,\"0.0\");\n            else\n              (void) SetImageOption(image_info,option+1,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImageList() applies any command line options that might affect the\n%  entire image list (e.g. -append, -coalesce, etc.).\n%\n%  The format of the MogrifyImage method is:\n%\n%      MagickBooleanType MogrifyImageList(ImageInfo *image_info,const int argc,\n%        const char **argv,Image **images,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o images: pointer to pointer of the first image in image list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n  const int argc,const char **argv,Image **images,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  PixelInterpolateMethod\n   interpolate_method;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index;\n\n  /*\n    Apply options to the image list.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image **) NULL);\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  interpolate_method=UndefinedInterpolatePixel;\n  mogrify_info=CloneImageInfo(image_info);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    if (*images == (Image *) NULL)\n      break;\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"affinity\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"append\",option+1) == 0)\n          {\n            Image\n              *append_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            append_image=AppendImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            if (append_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=append_image;\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          {\n            Image\n              *average_image;\n\n            /*\n              Average an image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            average_image=EvaluateImages(*images,MeanEvaluateOperator,\n              exception);\n            if (average_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=average_image;\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"channel-fx\",option+1) == 0)\n          {\n            Image\n              *channel_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            channel_image=ChannelFxImage(*images,argv[i+1],exception);\n            if (channel_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=channel_image;\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          {\n            Image\n              *clut_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            clut_image=RemoveFirstImageFromList(images);\n            if (clut_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) ClutImage(image,clut_image,interpolate_method,exception);\n            clut_image=DestroyImage(clut_image);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          {\n            Image\n              *coalesce_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            coalesce_image=CoalesceImages(*images,exception);\n            if (coalesce_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=coalesce_image;\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            ColorspaceType\n              colorspace;\n\n            Image\n              *combine_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            colorspace=(*images)->colorspace;\n            if ((*images)->number_channels < GetImageListLength(*images))\n              colorspace=sRGBColorspace;\n            if (*option == '+')\n              colorspace=(ColorspaceType) ParseCommandOption(\n                MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            combine_image=CombineImages(*images,colorspace,exception);\n            if (combine_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=combine_image;\n            break;\n          }\n        if (LocaleCompare(\"compare\",option+1) == 0)\n          {\n            double\n              distortion;\n\n            Image\n              *difference_image,\n              *image,\n              *reconstruct_image;\n\n            MetricType\n              metric;\n\n            /*\n              Mathematically and visually annotate the difference between an\n              image and its reconstruction.\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            reconstruct_image=RemoveFirstImageFromList(images);\n            if (reconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            metric=UndefinedErrorMetric;\n            option=GetImageOption(mogrify_info,\"metric\");\n            if (option != (const char *) NULL)\n              metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n                MagickFalse,option);\n            difference_image=CompareImages(image,reconstruct_image,metric,\n              &distortion,exception);\n            if (difference_image == (Image *) NULL)\n              break;\n            reconstruct_image=DestroyImage(reconstruct_image);\n            image=DestroyImage(image);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=difference_image;\n            break;\n          }\n        if (LocaleCompare(\"complex\",option+1) == 0)\n          {\n            ComplexOperator\n              op;\n\n            Image\n              *complex_images;\n\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            op=(ComplexOperator) ParseCommandOption(MagickComplexOptions,\n              MagickFalse,argv[i+1]);\n            complex_images=ComplexImages(*images,op,exception);\n            if (complex_images == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=complex_images;\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          {\n            CompositeOperator\n              compose;\n\n            const char*\n              value;\n\n            MagickBooleanType\n              clip_to_self;\n\n            Image\n              *mask_image,\n              *new_images,\n              *source_image;\n\n            RectangleInfo\n              geometry;\n\n            /* Compose value from \"-compose\" option only */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            value=GetImageOption(mogrify_info,\"compose\");\n            if (value == (const char *) NULL)\n              compose=OverCompositeOp;  /* use Over not source_image->compose */\n            else\n              compose=(CompositeOperator) ParseCommandOption(\n                MagickComposeOptions,MagickFalse,value);\n\n            /* Get \"clip-to-self\" expert setting (false is normal) */\n            clip_to_self=GetCompositeClipToSelf(compose);\n            value=GetImageOption(mogrify_info,\"compose:clip-to-self\");\n            if (value != (const char *) NULL)\n              clip_to_self=IsStringTrue(value);\n            value=GetImageOption(mogrify_info,\"compose:outside-overlay\");\n            if (value != (const char *) NULL)\n              clip_to_self=IsStringFalse(value);  /* deprecated */\n\n            new_images=RemoveFirstImageFromList(images);\n            source_image=RemoveFirstImageFromList(images);\n            if (source_image == (Image *) NULL)\n              break; /* FUTURE - produce Exception, rather than silent fail */\n\n            /* FUTURE: this should not be here! - should be part of -geometry */\n            if (source_image->geometry != (char *) NULL)\n              {\n                RectangleInfo\n                  resize_geometry;\n\n                (void) ParseRegionGeometry(source_image,source_image->geometry,\n                  &resize_geometry,exception);\n                if ((source_image->columns != resize_geometry.width) ||\n                    (source_image->rows != resize_geometry.height))\n                  {\n                    Image\n                      *resize_image;\n\n                    resize_image=ResizeImage(source_image,resize_geometry.width,\n                      resize_geometry.height,source_image->filter,exception);\n                    if (resize_image != (Image *) NULL)\n                      {\n                        source_image=DestroyImage(source_image);\n                        source_image=resize_image;\n                      }\n                  }\n              }\n            SetGeometry(source_image,&geometry);\n            (void) ParseAbsoluteGeometry(source_image->geometry,&geometry);\n            GravityAdjustGeometry(new_images->columns,new_images->rows,\n              new_images->gravity,&geometry);\n            mask_image=RemoveFirstImageFromList(images);\n            if (mask_image == (Image *) NULL)\n              status&=CompositeImage(new_images,source_image,compose,\n                clip_to_self,geometry.x,geometry.y,exception);\n            else\n              {\n                if ((compose == DisplaceCompositeOp) ||\n                    (compose == DistortCompositeOp))\n                  {\n                    status&=CompositeImage(source_image,mask_image,\n                      CopyGreenCompositeOp,MagickTrue,0,0,exception);\n                    status&=CompositeImage(new_images,source_image,compose,\n                      clip_to_self,geometry.x,geometry.y,exception);\n                  }\n                else\n                  {\n                    Image\n                      *clone_image;\n\n                    clone_image=CloneImage(new_images,0,0,MagickTrue,exception);\n                    if (clone_image == (Image *) NULL)\n                      break;\n                    status&=CompositeImage(new_images,source_image,compose,\n                      clip_to_self,geometry.x,geometry.y,exception);\n                    status&=CompositeImage(new_images,mask_image,\n                      CopyAlphaCompositeOp,MagickTrue,0,0,exception);\n                    status&=CompositeImage(clone_image,new_images,\n                      OverCompositeOp,clip_to_self,0,0,exception);\n                    new_images=DestroyImageList(new_images);\n                    new_images=clone_image;\n                  }\n                mask_image=DestroyImage(mask_image);\n              }\n            source_image=DestroyImage(source_image);\n            *images=DestroyImageList(*images);\n            *images=new_images;\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            (void) ParsePageGeometry(*images,argv[i+2],&geometry,exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=(*images);\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,argv[i+1],&geometry,\n              exception);\n            status=CopyImagePixels(*images,source_image,&geometry,&offset,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          {\n            Image\n              *deconstruct_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            deconstruct_image=CompareImagesLayers(*images,CompareAnyLayer,\n              exception);\n            if (deconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=deconstruct_image;\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              DeleteImages(images,\"-1\",exception);\n            else\n              DeleteImages(images,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither_method=NoDitherMethod;\n                break;\n              }\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            Image\n              *duplicate_images;\n\n            if (*option == '+')\n              duplicate_images=DuplicateImages(*images,1,\"-1\",exception);\n            else\n              {\n                const char\n                  *p;\n\n                size_t\n                  number_duplicates;\n\n                number_duplicates=(size_t) StringToLong(argv[i+1]);\n                p=strchr(argv[i+1],',');\n                if (p == (const char *) NULL)\n                  duplicate_images=DuplicateImages(*images,number_duplicates,\n                    \"-1\",exception);\n                else\n                  duplicate_images=DuplicateImages(*images,number_duplicates,p,\n                    exception);\n              }\n            AppendImageToList(images, duplicate_images);\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            Image\n              *evaluate_image;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            evaluate_image=EvaluateImages(*images,op,exception);\n            if (evaluate_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=evaluate_image;\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"fft\",option+1) == 0)\n          {\n            Image\n              *fourier_image;\n\n            /*\n              Implements the discrete Fourier transform (DFT).\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            fourier_image=ForwardFourierTransformImage(*images,*option == '-' ?\n              MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          {\n            Image\n              *flatten_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            flatten_image=MergeImageLayers(*images,FlattenLayer,exception);\n            if (flatten_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=flatten_image;\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            Image\n              *fx_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            fx_image=FxImage(*images,argv[i+1],exception);\n            if (fx_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=fx_image;\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          {\n            Image\n              *hald_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            hald_image=RemoveFirstImageFromList(images);\n            if (hald_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) HaldClutImage(image,hald_image,exception);\n            hald_image=DestroyImage(hald_image);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"ift\",option+1) == 0)\n          {\n            Image\n              *fourier_image,\n              *magnitude_image,\n              *phase_image;\n\n            /*\n              Implements the inverse fourier discrete Fourier transform (DFT).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            magnitude_image=RemoveFirstImageFromList(images);\n            phase_image=RemoveFirstImageFromList(images);\n            if (phase_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            fourier_image=InverseFourierTransformImage(magnitude_image,\n              phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"insert\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q;\n\n            index=0;\n            if (*option != '+')\n              index=(ssize_t) StringToLong(argv[i+1]);\n            p=RemoveLastImageFromList(images);\n            if (p == (Image *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                status=MagickFalse;\n                break;\n              }\n            q=p;\n            if (index == 0)\n              PrependImageToList(images,q);\n            else\n              if (index == (ssize_t) GetImageListLength(*images))\n                AppendImageToList(images,q);\n              else\n                {\n                   q=GetImageFromList(*images,index-1);\n                   if (q == (Image *) NULL)\n                     {\n                       p=DestroyImage(p);\n                       (void) ThrowMagickException(exception,GetMagickModule(),\n                         OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                       status=MagickFalse;\n                       break;\n                     }\n                  InsertImageInList(&q,p);\n                }\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            interpolate_method=(PixelInterpolateMethod) ParseCommandOption(\n              MagickInterpolateOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            Image\n              *layers;\n\n            LayerMethod\n              method;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            layers=(Image *) NULL;\n            method=(LayerMethod) ParseCommandOption(MagickLayerOptions,\n              MagickFalse,argv[i+1]);\n            switch (method)\n            {\n              case CoalesceLayer:\n              {\n                layers=CoalesceImages(*images,exception);\n                break;\n              }\n              case CompareAnyLayer:\n              case CompareClearLayer:\n              case CompareOverlayLayer:\n              default:\n              {\n                layers=CompareImagesLayers(*images,method,exception);\n                break;\n              }\n              case MergeLayer:\n              case FlattenLayer:\n              case MosaicLayer:\n              case TrimBoundsLayer:\n              {\n                layers=MergeImageLayers(*images,method,exception);\n                break;\n              }\n              case DisposeLayer:\n              {\n                layers=DisposeImages(*images,exception);\n                break;\n              }\n              case OptimizeImageLayer:\n              {\n                layers=OptimizeImageLayers(*images,exception);\n                break;\n              }\n              case OptimizePlusLayer:\n              {\n                layers=OptimizePlusImageLayers(*images,exception);\n                break;\n              }\n              case OptimizeTransLayer:\n              {\n                OptimizeImageTransparency(*images,exception);\n                break;\n              }\n              case RemoveDupsLayer:\n              {\n                RemoveDuplicateLayers(images,exception);\n                break;\n              }\n              case RemoveZeroLayer:\n              {\n                RemoveZeroDelayLayers(images,exception);\n                break;\n              }\n              case OptimizeLayer:\n              {\n                /*\n                  General Purpose, GIF Animation Optimizer.\n                */\n                layers=CoalesceImages(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=OptimizeImageLayers(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=(Image *) NULL;\n                OptimizeImageTransparency(*images,exception);\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n              case CompositeLayer:\n              {\n                CompositeOperator\n                  compose;\n\n                Image\n                  *source;\n\n                RectangleInfo\n                  geometry;\n\n                /*\n                  Split image sequence at the first 'NULL:' image.\n                */\n                source=(*images);\n                while (source != (Image *) NULL)\n                {\n                  source=GetNextImageInList(source);\n                  if ((source != (Image *) NULL) &&\n                      (LocaleCompare(source->magick,\"NULL\") == 0))\n                    break;\n                }\n                if (source != (Image *) NULL)\n                  {\n                    if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                        (GetNextImageInList(source) == (Image *) NULL))\n                      source=(Image *) NULL;\n                    else\n                      {\n                        /*\n                          Separate the two lists, junk the null: image.\n                        */\n                        source=SplitImageList(source->previous);\n                        DeleteImageFromList(&source);\n                      }\n                  }\n                if (source == (Image *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                    status=MagickFalse;\n                    break;\n                  }\n                /*\n                  Adjust offset with gravity and virtual canvas.\n                */\n                SetGeometry(*images,&geometry);\n                (void) ParseAbsoluteGeometry((*images)->geometry,&geometry);\n                geometry.width=source->page.width != 0 ?\n                  source->page.width : source->columns;\n                geometry.height=source->page.height != 0 ?\n                 source->page.height : source->rows;\n                GravityAdjustGeometry((*images)->page.width != 0 ?\n                  (*images)->page.width : (*images)->columns,\n                  (*images)->page.height != 0 ? (*images)->page.height :\n                  (*images)->rows,(*images)->gravity,&geometry);\n                compose=OverCompositeOp;\n                option=GetImageOption(mogrify_info,\"compose\");\n                if (option != (const char *) NULL)\n                  compose=(CompositeOperator) ParseCommandOption(\n                    MagickComposeOptions,MagickFalse,option);\n                CompositeLayers(*images,compose,source,geometry.x,geometry.y,\n                  exception);\n                source=DestroyImageList(source);\n                break;\n              }\n            }\n            if (layers == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=layers;\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          {\n            Image\n              *maximum_image;\n\n            /*\n              Maximum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            maximum_image=EvaluateImages(*images,MaxEvaluateOperator,exception);\n            if (maximum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=maximum_image;\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          {\n            Image\n              *minimum_image;\n\n            /*\n              Minimum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            minimum_image=EvaluateImages(*images,MinEvaluateOperator,exception);\n            if (minimum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=minimum_image;\n            break;\n          }\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            Image\n              *morph_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            morph_image=MorphImages(*images,StringToUnsignedLong(argv[i+1]),\n              exception);\n            if (morph_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=morph_image;\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          {\n            Image\n              *mosaic_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            mosaic_image=MergeImageLayers(*images,MosaicLayer,exception);\n            if (mosaic_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=mosaic_image;\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            double\n              *arguments;\n\n            Image\n              *polynomial_image;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            /*\n              Polynomial image.\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            args=InterpretImageProperties(mogrify_info,*images,argv[i+1],\n              exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*images)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            polynomial_image=PolynomialImage(*images,number_arguments >> 1,\n              arguments,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            if (polynomial_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=polynomial_image;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            char\n              *string;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            string=InterpretImageProperties(mogrify_info,*images,argv[i+1],\n              exception);\n            if (string == (char *) NULL)\n              break;\n            (void) FormatLocaleFile(stdout,\"%s\",string);\n            string=DestroyString(string);\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            char\n              **arguments;\n\n            int\n              j,\n              number_arguments;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            arguments=StringToArgv(argv[i+1],&number_arguments);\n            if (arguments == (char **) NULL)\n              break;\n            if ((argc > 1) && (strchr(arguments[1],'=') != (char *) NULL))\n              {\n                char\n                  breaker,\n                  quote,\n                  *token;\n\n                const char\n                  *argument;\n\n                int\n                  next,\n                  token_status;\n\n                size_t\n                  length;\n\n                TokenInfo\n                  *token_info;\n\n                /*\n                  Support old style syntax, filter=\"-option arg\".\n                */\n                length=strlen(argv[i+1]);\n                token=(char *) NULL;\n                if (~length >= (MagickPathExtent-1))\n                  token=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n                    sizeof(*token));\n                if (token == (char *) NULL)\n                  break;\n                next=0;\n                argument=argv[i+1];\n                token_info=AcquireTokenInfo();\n                token_status=Tokenizer(token_info,0,token,length,argument,\"\",\n                  \"=\",\"\\\"\",'\\0',&breaker,&next,&quote);\n                token_info=DestroyTokenInfo(token_info);\n                if (token_status == 0)\n                  {\n                    const char\n                      *arg;\n\n                    arg=(&(argument[next]));\n                    (void) InvokeDynamicImageFilter(token,&(*images),1,&arg,\n                      exception);\n                  }\n                token=DestroyString(token);\n                break;\n              }\n            (void) SubstituteString(&arguments[1],\"-\",\"\");\n            (void) InvokeDynamicImageFilter(arguments[1],&(*images),\n              number_arguments-2,(const char **) arguments+2,exception);\n            for (j=0; j < number_arguments; j++)\n              arguments[j]=DestroyString(arguments[j]);\n            arguments=(char **) RelinquishMagickMemory(arguments);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          {\n            ReverseImageList(images);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            Image\n              *smush_image;\n\n            ssize_t\n              offset;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            offset=(ssize_t) StringToLong(argv[i+1]);\n            smush_image=SmushImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,offset,exception);\n            if (smush_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=smush_image;\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q,\n              *u,\n              *v;\n\n            ssize_t\n              swap_index;\n\n            index=(-1);\n            swap_index=(-2);\n            if (*option != '+')\n              {\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                swap_index=(-1);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                index=(ssize_t) geometry_info.rho;\n                if ((flags & SigmaValue) != 0)\n                  swap_index=(ssize_t) geometry_info.sigma;\n              }\n            p=GetImageFromList(*images,index);\n            q=GetImageFromList(*images,swap_index);\n            if ((p == (Image *) NULL) || (q == (Image *) NULL))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",(*images)->filename);\n                status=MagickFalse;\n                break;\n              }\n            if (p == q)\n              break;\n            u=CloneImage(p,0,0,MagickTrue,exception);\n            if (u == (Image *) NULL)\n              break;\n            v=CloneImage(q,0,0,MagickTrue,exception);\n            if (v == (Image *) NULL)\n              {\n                u=DestroyImage(u);\n                break;\n              }\n            ReplaceImageInList(&p,v);\n            ReplaceImageInList(&q,u);\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            char\n              key[MagickPathExtent];\n\n            Image\n              *write_images;\n\n            ImageInfo\n              *write_info;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",\n              argv[i+1]);\n            (void) DeleteImageRegistry(key);\n            write_images=(*images);\n            if (*option == '+')\n              write_images=CloneImageList(*images,exception);\n            write_info=CloneImageInfo(mogrify_info);\n            status&=WriteImages(write_info,write_images,argv[i+1],exception);\n            write_info=DestroyImageInfo(write_info);\n            if (*option == '+')\n              write_images=DestroyImageList(write_images);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status&=MogrifyImageInfo(image_info,argc,argv,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     M o g r i f y I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MogrifyImages() applies image processing options to a sequence of images as\n%  prescribed by command line options.\n%\n%  The format of the MogrifyImage method is:\n%\n%      MagickBooleanType MogrifyImages(ImageInfo *image_info,\n%        const MagickBooleanType post,const int argc,const char **argv,\n%        Image **images,Exceptioninfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o post: If true, post process image list operators otherwise pre-process.\n%\n%    o argc: Specifies a pointer to an integer describing the number of\n%      elements in the argument vector.\n%\n%    o argv: Specifies a pointer to a text array containing the command line\n%      arguments.\n%\n%    o images: pointer to a pointer of the first image in image list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nWandExport MagickBooleanType MogrifyImages(ImageInfo *image_info,\n  const MagickBooleanType post,const int argc,const char **argv,\n  Image **images,ExceptionInfo *exception)\n{\n#define MogrifyImageTag  \"Mogrify/Image\"\n\n  MagickStatusType\n    status;\n\n  MagickBooleanType\n    proceed;\n\n  size_t\n    n;\n\n  register ssize_t\n    i;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (images == (Image **) NULL)\n    return(MogrifyImage(image_info,argc,argv,images,exception));\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  (void) SetImageInfoProgressMonitor(image_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  status=MagickTrue;\n#if 0\n  (void) FormatLocaleFile(stderr, \"mogrify start %s %d (%s)\\n\",argv[0],argc,\n    post?\"post\":\"pre\");\n#endif\n  /*\n    Pre-process multi-image sequence operators\n  */\n  if (post == MagickFalse)\n    status&=MogrifyImageList(image_info,argc,argv,images,exception);\n  /*\n    For each image, process simple single image operators\n  */\n  i=0;\n  n=GetImageListLength(*images);\n  for ( ; ; )\n  {\n#if 0\n  (void) FormatLocaleFile(stderr,\"mogrify %ld of %ld\\n\",(long)\n    GetImageIndexInList(*images),(long)GetImageListLength(*images));\n#endif\n    status&=MogrifyImage(image_info,argc,argv,images,exception);\n    proceed=SetImageProgress(*images,MogrifyImageTag,(MagickOffsetType) i, n);\n    if (proceed == MagickFalse)\n      break;\n    if ( (*images)->next == (Image *) NULL )\n      break;\n    *images=(*images)->next;\n    i++;\n  }\n  assert( *images != (Image *) NULL );\n#if 0\n  (void) FormatLocaleFile(stderr,\"mogrify end %ld of %ld\\n\",(long)\n    GetImageIndexInList(*images),(long)GetImageListLength(*images));\n#endif\n  /*\n    Post-process, multi-image sequence operators\n  */\n  *images=GetFirstImageInList(*images);\n  if (post != MagickFalse)\n    status&=MogrifyImageList(image_info,argc,argv,images,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%          OOO   PPPP   EEEE  RRRR    AA   TTTTT  III   OOO   N   N           %\n%         O   O  P   P  E     R   R  A  A    T     I   O   O  NN  N           %\n%         O   O  PPPP   EEE   RRRR   AAAA    T     I   O   O  N N N           %\n%         O   O  P      E     R R    A  A    T     I   O   O  N  NN           %\n%          OOO   P      EEEE  R  RR  A  A    T    III   OOO   N   N           %\n%                                                                             %\n%                                                                             %\n%                         CLI Magick Option Methods                           %\n%                                                                             %\n%                              Dragon Computing                               %\n%                              Anthony Thyssen                                %\n%                               September 2011                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Apply the given options (settings, and simple, or sequence operations) to\n% the given image(s) according to the current \"image_info\", \"draw_info\", and\n% \"quantize_info\" settings, stored in a special CLI Image Wand.\n%\n% The final goal is to allow the execution in a strict one option at a time\n% manner that is needed for 'pipelining and file scripting' of options in\n% IMv7.\n%\n% Anthony Thyssen, September 2011\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/mogrify.h\"\n#include \"MagickWand/operation.h\"\n#include \"MagickWand/wand.h\"\n#include \"MagickWand/wandcli.h\"\n#include \"MagickWand/wandcli-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nstatic const char\n  MogrifyAlphaColor[] = \"#bdbdbd\",  /* slightly darker gray */\n  MogrifyBackgroundColor[] = \"#fff\",  /* white */\n  MogrifyBorderColor[] = \"#dfdfdf\";  /* sRGB gray */\n\f\n/*\n  Define declarations.\n*/\n#define USE_WAND_METHODS  1\n#define MAX_STACK_DEPTH  32\n#define UNDEFINED_COMPRESSION_QUALITY  0UL\n\n/* FUTURE: why is this default so specific? */\n#define DEFAULT_DISSIMILARITY_THRESHOLD \"0.31830988618379067154\"\n\n/* For Debugging Geometry Input */\n#define ReportGeometry(flags,info) \\\n  (void) FormatLocaleFile(stderr, \"Geometry = 0x%04X : %lg x %lg %+lg %+lg\\n\", \\\n       flags, info.rho, info.sigma, info.xi, info.psi )\n\f\n/*\n** Function to report on the progress of image operations\n*/\nstatic MagickBooleanType MonitorProgress(const char *text,\n  const MagickOffsetType offset,const MagickSizeType extent,\n  void *wand_unused(client_data))\n{\n  char\n    message[MagickPathExtent],\n    tag[MagickPathExtent];\n\n  const char\n    *locale_message;\n\n  register char\n    *p;\n\n  magick_unreferenced(client_data);\n\n  if ((extent <= 1) || (offset < 0) || (offset >= (MagickOffsetType) extent))\n    return(MagickTrue);\n  if ((offset != (MagickOffsetType) (extent-1)) && ((offset % 50) != 0))\n    return(MagickTrue);\n  (void) CopyMagickString(tag,text,MagickPathExtent);\n  p=strrchr(tag,'/');\n  if (p != (char *) NULL)\n    *p='\\0';\n  (void) FormatLocaleString(message,MagickPathExtent,\"Monitor/%s\",tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == message)\n    locale_message=tag;\n  if (p == (char *) NULL)\n    (void) FormatLocaleFile(stderr,\"%s: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  else\n    (void) FormatLocaleFile(stderr,\"%s[%s]: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,p+1,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  if (offset == (MagickOffsetType) (extent-1))\n    (void) FormatLocaleFile(stderr,\"\\n\");\n  (void) fflush(stderr);\n  return(MagickTrue);\n}\n\n/*\n** GetImageCache() will read an image into a image cache if not already\n** present then return the image that is in the cache under that filename.\n*/\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  if (path != (const char *) NULL)\n    (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\n/*\n  SparseColorOption() parse the complex -sparse-color argument into an\n  an array of floating point values than call SparseColorImage().\n  Argument is a complex mix of floating-point pixel coodinates, and color\n  specifications (or direct floating point numbers).  The number of floats\n  needed to represent a color varies depending on the current channel\n  setting.\n\n  This really should be in MagickCore, so that other API's can make use of it.\n*/\nstatic Image *SparseColorOption(const Image *image,\n  const SparseColorMethod method,const char *arguments,ExceptionInfo *exception)\n{\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    *sparse_arguments;\n\n  Image\n    *sparse_image;\n\n  PixelInfo\n    color;\n\n  MagickBooleanType\n    error;\n\n  register size_t\n    x;\n\n  size_t\n    number_arguments,\n    number_colors;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Limit channels according to image\n    add up number of values needed per color.\n  */\n  number_colors=0;\n  if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    number_colors++;\n  if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n      image->alpha_trait != UndefinedPixelTrait)\n    number_colors++;\n\n  /*\n    Read string, to determine number of arguments needed,\n  */\n  p=arguments;\n  x=0;\n  while( *p != '\\0' )\n  {\n    GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == ',' ) continue;\n    if ( isalpha((int) token[0]) || token[0] == '#' )\n      x += number_colors;  /* color argument found */\n    else\n      x++;   /* floating point argument */\n  }\n  /* control points and color values */\n  if ((x % (2+number_colors)) != 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\", \"sparse-color\",\n        \"Invalid number of Arguments\");\n      return( (Image *) NULL);\n    }\n  error=MagickFalse;\n  number_arguments=x;\n\n  /* Allocate and fill in the floating point arguments */\n  sparse_arguments=(double *) AcquireQuantumMemory(number_arguments,\n    sizeof(*sparse_arguments));\n  if (sparse_arguments == (double *) NULL) {\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"MemoryAllocationFailed\",\"%s\",\"SparseColorOption\");\n    return( (Image *) NULL);\n  }\n  (void) memset(sparse_arguments,0,number_arguments*\n    sizeof(*sparse_arguments));\n  p=arguments;\n  x=0;\n  while( *p != '\\0' && x < number_arguments ) {\n    /* X coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of X-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* Y coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of Y-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* color name or function given in string argument */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      /* Color string given */\n      (void) QueryColorCompliance(token,AllCompliance,&color,\n                exception);\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.red;\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.green;\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.blue;\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        sparse_arguments[x++] = QuantumScale*color.black;\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        sparse_arguments[x++] = QuantumScale*color.alpha;\n    }\n    else {\n      /* Colors given as a set of floating point values - experimental */\n      /* NB: token contains the first floating point value to use! */\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n    }\n  }\n  if (error != MagickFalse)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      return((Image *) NULL);\n    }\n  if (number_arguments != x)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\",\"sparse-color\",\"Argument Parsing Error\");\n      return((Image *) NULL);\n    }\n  /* Call the Sparse Color Interpolation function with the parsed arguments */\n  sparse_image=SparseColorImage(image,method,number_arguments,sparse_arguments,\n    exception);\n  sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n  return( sparse_image );\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C L I S e t t i n g O p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISettingOptionInfo() applies a single settings option into a CLI wand\n%  holding the image_info, draw_info, quantize_info structures that will be\n%  used when processing the images.\n%\n%  These options do no require images to be present in the CLI wand for them\n%  to be able to be set, in which case they will generally be applied to image\n%  that are read in later\n%\n%  Options handled by this function are listed in CommandOptions[] of\n%  \"option.c\" that is one of \"SettingOptionFlags\" option flags.\n%\n%  The format of the CLISettingOptionInfo method is:\n%\n%    void CLISettingOptionInfo(MagickCLI *cli_wand,\n%               const char *option, const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option: The option string to be set\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently only used by \"-limit\"\n%\n*/\nWandPrivate void CLISettingOptionInfo(MagickCLI *cli_wand,\n     const char *option,const char *arg1n, const char *arg2n)\n{\n  ssize_t\n    parse;     /* option argument parsing (string to value table lookup) */\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define IfSetOption       (*option=='-')\n#define ArgBoolean        IfSetOption ? MagickTrue : MagickFalse\n#define ArgBooleanNot     IfSetOption ? MagickFalse : MagickTrue\n#define ArgBooleanString  (IfSetOption?\"true\":\"false\")\n#define ArgOption(def)    (IfSetOption?arg1:(const char *)(def))\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Setting Option: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1n,arg2n);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n#if 1\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n#endif\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adjoin\",option+1) == 0)\n        {\n          _image_info->adjoin = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"affine\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-draw 'affine ...'\");\n          if (IfSetOption)\n            (void) ParseAffineGeometry(arg1,&_draw_info->affine,_exception);\n          else\n            GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"antialias\",option+1) == 0)\n        {\n          _image_info->antialias =\n            _draw_info->stroke_antialias =\n              _draw_info->text_antialias = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"attenuate\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"1.0\"));\n          break;\n        }\n      if (LocaleCompare(\"authenticate\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used directly for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: if _image_info->background_color is not set then\n             we should fall back to per-image background_color\n\n             At this time -background will 'wipe out' the per-image\n             background color!\n\n             Better error handling of QueryColorCompliance() needed.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyBackgroundColor),AllCompliance,\n             &_image_info->background_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"bias\",option+1) == 0)\n        {\n          /* FUTURE: bias OBSOLETED, replaced by Artifact \"convolve:bias\"\n             as it is actually rarely used except in direct convolve operations\n             Usage outside a direct convolve operation is actally non-sensible!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,\"convolve:bias\",ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"blue-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders including PNG\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"bordercolor\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             SyncImageSettings() used to set per-image attribute.\n             Better error checking of QueryColorCompliance().\n          */\n          if (IfSetOption)\n            {\n              (void) SetImageOption(_image_info,option+1,arg1);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_image_info->border_color,_exception);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_draw_info->border_color,_exception);\n              break;\n            }\n          (void) DeleteImageOption(_image_info,option+1);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_image_info->border_color,_exception);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_draw_info->border_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"box\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-undercolor\");\n          CLISettingOptionInfo(cli_wand,\"-undercolor\",arg1, arg2);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"cache\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          limit=MagickResourceInfinity;\n          if (LocaleCompare(\"unlimited\",arg1) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg1,100.0);\n          (void) SetMagickResourceLimit(MemoryResource,limit);\n          (void) SetMagickResourceLimit(MapResource,2*limit);\n          break;\n        }\n      if (LocaleCompare(\"caption\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* Setting used for new images via AquireImage()\n             But also used as a SimpleImageOperator\n             Undefined colorspace means don't modify images on\n             read or as a operation */\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n             ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          _image_info->colorspace=(ColorspaceType) parse;\n          break;\n        }\n      if (LocaleCompare(\"comment\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compose\",option+1) == 0)\n        {\n          /* FUTURE: _image_info should be used,\n             SyncImageSettings() used to set per-image attribute. - REMOVE\n\n             This setting should NOT be used to set image 'compose'\n             \"-layer\" operators shoud use _image_info if defined otherwise\n             they should use a per-image compose setting.\n          */\n          parse = ParseCommandOption(MagickComposeOptions,MagickFalse,\n                          ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedComposeOperator\",\n                                      option,arg1);\n          _image_info->compose=(CompositeOperator) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compress\",option+1) == 0)\n        {\n          /* FUTURE: What should be used?  _image_info  or ImageOption ???\n             The former is more efficent, but Crisy prefers the latter!\n             SyncImageSettings() used to set per-image attribute.\n\n             The coders appears to use _image_info, not Image_Option\n             however the image attribute (for save) is set from the\n             ImageOption!\n\n             Note that \"undefined\" is a different setting to \"none\".\n          */\n          parse = ParseCommandOption(MagickCompressOptions,MagickFalse,\n                     ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageCompression\",\n                                      option,arg1);\n          _image_info->compression=(CompressionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"debug\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"none\");\n          parse = ParseCommandOption(MagickLogEventOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEventType\",\n                                      option,arg1);\n          (void) SetLogEventMask(arg1);\n          _image_info->debug=IsEventLogging();   /* extract logging*/\n          cli_wand->wand.debug=IsEventLogging();\n          break;\n        }\n      if (LocaleCompare(\"define\",option+1) == 0)\n        {\n          if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n            {\n              if (IfSetOption)\n                (void) DefineImageRegistry(StringRegistryType,arg1+9,_exception);\n              else\n                (void) DeleteImageRegistry(arg1+9);\n              break;\n            }\n          /* DefineImageOption() equals SetImageOption() but with '=' */\n          if (IfSetOption)\n            (void) DefineImageOption(_image_info,arg1);\n          else if (DeleteImageOption(_image_info,arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"NoSuchOption\",option,arg1);\n          break;\n        }\n      if (LocaleCompare(\"delay\",option+1) == 0)\n        {\n          /* Only used for new images via AcquireImage()\n             FUTURE: Option should also be used for \"-morph\" (color morphing)\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"density\",option+1) == 0)\n        {\n          /* FUTURE: strings used in _image_info attr and _draw_info!\n             Basically as density can be in a XxY form!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) CloneString(&_image_info->density,ArgOption(NULL));\n          (void) CloneString(&_draw_info->density,_image_info->density);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* This is also a SimpleImageOperator! for 8->16 vaule trunc !!!!\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->depth=IfSetOption?StringToUnsignedLong(arg1)\n                                       :MAGICKCORE_QUANTUM_DEPTH;\n          break;\n        }\n      if (LocaleCompare(\"direction\",option+1) == 0)\n        {\n          /* Image Option is only used to set _draw_info */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDirectionOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDirectionType\",\n                                      option,arg1);\n          _draw_info->direction=(DirectionType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"display\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->server_name,ArgOption(NULL));\n          (void) CloneString(&_draw_info->server_name,_image_info->server_name);\n          break;\n        }\n      if (LocaleCompare(\"dispose\",option+1) == 0)\n        {\n          /* only used in setting new images */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDisposeOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDisposeMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"undefined\"));\n          break;\n        }\n      if (LocaleCompare(\"dissimilarity-threshold\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          arg1=ArgOption(DEFAULT_DISSIMILARITY_THRESHOLD);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"dither\",option+1) == 0)\n        {\n          /* _image_info attr (on/off), _quantize_info attr (on/off)\n             but also ImageInfo and _quantize_info method!\n             FUTURE: merge the duality of the dithering options\n          */\n          _image_info->dither = ArgBoolean;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"none\"));\n          _quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n             MagickDitherOptions,MagickFalse,ArgOption(\"none\"));\n          if (_quantize_info->dither_method == NoDitherMethod)\n            _image_info->dither = MagickFalse;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"encoding\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->encoding,ArgOption(\"undefined\"));\n          (void) SetImageOption(_image_info,option+1,_draw_info->encoding);\n          break;\n        }\n      if (LocaleCompare(\"endian\",option+1) == 0)\n        {\n          /* Both _image_info attr and ImageInfo */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickEndianOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEndianType\",\n                                      option,arg1);\n          /* FUTURE: check alloc/free of endian string!  - remove? */\n          _image_info->endian=(EndianType) (*arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"extract\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->extract,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"family\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->family,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"features\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:features\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"fill\",option+1) == 0)\n        {\n          /* Set \"fill\" OR \"fill-pattern\" in _draw_info\n             The original fill color is preserved if a fill-pattern is given.\n             That way it does not effect other operations that directly using\n             the fill color and, can be retored using \"+tile\".\n          */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->fill_pattern != (Image *) NULL)\n            _draw_info->fill_pattern=DestroyImage(_draw_info->fill_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->fill_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->fill=color;\n          break;\n        }\n      if (LocaleCompare(\"filter\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickFilterOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageFilter\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"font\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->font,ArgOption(NULL));\n          (void) CloneString(&_image_info->font,_draw_info->font);\n          break;\n        }\n      if (LocaleCompare(\"format\",option+1) == 0)\n        {\n          /* FUTURE: why the ping test, you could set ping after this! */\n          /*\n          register const char\n            *q;\n\n          for (q=strchr(arg1,'%'); q != (char *) NULL; q=strchr(q+1,'%'))\n            if (strchr(\"Agkrz@[#\",*(q+1)) != (char *) NULL)\n              _image_info->ping=MagickFalse;\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"fuzz\",option+1) == 0)\n        {\n          /* Option used to set image fuzz! unless blank canvas (from color)\n             Image attribute used for color compare operations\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: Can't find anything else using _image_info->fuzz directly!\n                     convert structure attribute to 'option' string\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->fuzz=StringToDoubleInterval(arg1,(double)\n                QuantumRange+1.0);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gravity\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"none\");\n          parse = ParseCommandOption(MagickGravityOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedGravityType\",\n                                      option,arg1);\n          _draw_info->gravity=(GravityType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"green-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             SyncImageSettings() used to set per-image attribute.\n             Used directly by many coders\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"highlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:highlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",option+1) == 0)\n        {\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n            arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityType\",\n              option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"intent\",option+1) == 0)\n        {\n          /* Only used by coders: MIFF, MPC, BMP, PNG\n             and for image profile call to AcquireTransformThreadSet()\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickIntentOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntentType\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interlace\",option+1) == 0)\n        {\n          /* _image_info is directly used by coders (so why an image setting?)\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterlaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterlaceType\",\n                                      option,arg1);\n          _image_info->interlace=(InterlaceType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interline_spacing=StringToDouble(ArgOption(\"0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"interpolate\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterpolateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterpolateMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interword_spacing=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kerning\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->kerning=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"label\",option+1) == 0)\n        {\n          /* only used for new images - not in SyncImageOptions() */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"limit\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          limit=MagickResourceInfinity;\n          parse= ParseCommandOption(MagickResourceOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedResourceType\",\n                option,arg1);\n          if (LocaleCompare(\"unlimited\",arg2) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg2,100.0);\n          (void) SetMagickResourceLimit((ResourceType)parse,limit);\n          break;\n        }\n      if (LocaleCompare(\"log\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if ((strchr(arg1,'%') == (char *) NULL))\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) SetLogFormat(arg1);\n          }\n          break;\n        }\n      if (LocaleCompare(\"lowlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:lowlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"loop\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"mattecolor\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyAlphaColor),\n            AllCompliance,&_image_info->matte_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          parse=ParseCommandOption(MagickMetricOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedMetricType\",\n                option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"moments\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:moments\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageInfoProgressMonitor(_image_info, IfSetOption?\n                MonitorProgress: (MagickProgressMonitor) NULL, (void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          /* Setting (used by some input coders!) -- why?\n             Warning: This is also Special '-type' SimpleOperator\n          */\n          _image_info->monochrome= ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"orient\",option+1) == 0)\n        {\n          /* Is not used when defining for new images.\n             This makes it more of a 'operation' than a setting\n             FUTURE: make set meta-data operator instead.\n             SyncImageSettings() used to set per-image attribute.\n          */\n          parse=ParseCommandOption(MagickOrientationOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageOrientation\",\n                                      option,arg1);\n          _image_info->orientation=(OrientationType)parse;\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",option+1) == 0)\n        {\n          /* Only used for new images and image generators.\n             SyncImageSettings() used to set per-image attribute. ?????\n             That last is WRONG!!!!\n             FUTURE: adjust named 'page' sizes according density\n          */\n          char\n            *canonical_page,\n            page[MagickPathExtent];\n\n          const char\n            *image_option;\n\n          MagickStatusType\n            flags;\n\n          RectangleInfo\n            geometry;\n\n          if (!IfSetOption)\n            {\n              (void) DeleteImageOption(_image_info,option+1);\n              (void) CloneString(&_image_info->page,(char *) NULL);\n              break;\n            }\n          (void) memset(&geometry,0,sizeof(geometry));\n          image_option=GetImageOption(_image_info,\"page\");\n          if (image_option != (const char *) NULL)\n            flags=ParseAbsoluteGeometry(image_option,&geometry);\n          canonical_page=GetPageGeometry(arg1);\n          flags=ParseAbsoluteGeometry(canonical_page,&geometry);\n          canonical_page=DestroyString(canonical_page);\n          (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu\",\n            (unsigned long) geometry.width,(unsigned long) geometry.height);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu%+ld%+ld\",\n              (unsigned long) geometry.width,(unsigned long) geometry.height,\n              (long) geometry.x,(long) geometry.y);\n          (void) SetImageOption(_image_info,option+1,page);\n          (void) CloneString(&_image_info->page,page);\n          break;\n        }\n      if (LocaleCompare(\"ping\",option+1) == 0)\n        {\n          _image_info->ping = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"pointsize\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            _image_info->pointsize =\n            _draw_info->pointsize =\n              StringToDouble(arg1,(char **) NULL);\n          }\n          else {\n            _image_info->pointsize=0.0; /* unset pointsize */\n            _draw_info->pointsize=12.0;\n          }\n          break;\n        }\n      if (LocaleCompare(\"precision\",option+1) == 0)\n        {\n          arg1=ArgOption(\"-1\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetMagickPrecision(StringToInteger(arg1));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'q':\n    {\n      if (LocaleCompare(\"quality\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->quality= IfSetOption ? StringToUnsignedLong(arg1)\n                                            : UNDEFINED_COMPRESSION_QUALITY;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"quantize\",option+1) == 0)\n        {\n          /* Just a set direct in _quantize_info */\n          arg1=ArgOption(\"undefined\");\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",\n                 option,arg1);\n          _quantize_info->colorspace=(ColorspaceType)parse;\n          break;\n        }\n      if (LocaleCompare(\"quiet\",option+1) == 0)\n        {\n          /* FUTURE: if two -quiet is performed you can not do +quiet!\n             This needs to be checked over thoughly.\n          */\n          static WarningHandler\n            warning_handler = (WarningHandler) NULL;\n\n          WarningHandler\n            tmp = SetWarningHandler((WarningHandler) NULL);\n\n          if ( tmp != (WarningHandler) NULL)\n            warning_handler = tmp; /* remember the old handler */\n          if (!IfSetOption)        /* set the old handler */\n            warning_handler=SetWarningHandler(warning_handler);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"red-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n        /* FUTURE: to be replaced by a 'fatal-level' type setting */\n        break;\n      if (LocaleCompare(\"render\",option+1) == 0)\n        {\n          /* _draw_info only setting */\n          _draw_info->render= ArgBooleanNot;\n          break;\n        }\n      if (LocaleCompare(\"respect-parenthesis\",option+1) == 0)\n        {\n          /* link image and setting stacks - option is itself saved on stack! */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n        {\n          /* FUTURE: should be converted to jpeg:sampling_factor */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CloneString(&_image_info->sampling_factor,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"scene\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set this as a per-image attribute.\n             What ??? Why ????\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _image_info->scene=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"seed\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          SetRandomSecretKey(\n               IfSetOption ? (unsigned long) StringToUnsignedLong(arg1)\n                           : (unsigned long) time((time_t *) NULL));\n          break;\n        }\n      if (LocaleCompare(\"size\",option+1) == 0)\n        {\n          /* FUTURE: string in _image_info -- convert to Option ???\n             Look at the special handling for \"size\" in SetImageOption()\n           */\n          (void) CloneString(&_image_info->size,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"stretch\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStretchOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStretchType\",\n                 option,arg1);\n          _draw_info->stretch=(StretchType) parse;\n          break;\n        }\n      if (LocaleCompare(\"stroke\",option+1) == 0)\n        {\n          /* set stroke color OR stroke-pattern\n             UPDATE: ensure stroke color is not destroyed is a pattern\n             is given. Just in case the color is also used for other purposes.\n           */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->stroke_pattern != (Image *) NULL)\n            _draw_info->stroke_pattern=DestroyImage(_draw_info->stroke_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->stroke_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->stroke=color;\n          break;\n        }\n      if (LocaleCompare(\"strokewidth\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->stroke_width=StringToDouble(ArgOption(\"1.0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"style\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStyleOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStyleType\",\n                 option,arg1);\n          _draw_info->style=(StyleType) parse;\n          break;\n        }\n#if 0\n      if (LocaleCompare(\"subimage-search\",option+1) == 0)\n        {\n        /* FUTURE: this is only used by CompareImages() which is used\n            only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n#endif\n      if (LocaleCompare(\"synchronize\",option+1) == 0)\n        {\n          /* FUTURE: syncronize to storage - but what does that mean? */\n          _image_info->synchronize = ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"taint\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"texture\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          /* FUTURE: move _image_info string to option splay-tree\n             Other than \"montage\" what uses \"texture\" ????\n          */\n          (void) CloneString(&_image_info->texture,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"tile\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          _draw_info->fill_pattern=IfSetOption\n                                 ?GetImageCache(_image_info,arg1,_exception)\n                                 :DestroyImage(_draw_info->fill_pattern);\n          break;\n        }\n      if (LocaleCompare(\"tile-offset\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. ??? */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"transparent-color\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             Note that +transparent-color, means fall-back to image\n             attribute so ImageOption is deleted, not set to a default.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n              &_image_info->transparent_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"treedepth\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _quantize_info->tree_depth=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          parse=ParseCommandOption(MagickTypeOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageType\",\n                 option,arg1);\n          _image_info->type=(ImageType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"undercolor\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n               &_draw_info->undercolor,_exception);\n          break;\n        }\n      if (LocaleCompare(\"units\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             Should this effect _draw_info X and Y resolution?\n             FUTURE: this probably should be part of the density setting\n          */\n          parse=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedUnitsType\",\n                 option,arg1);\n          _image_info->units=(ResolutionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: Remember all options become image artifacts\n             _image_info->verbose is only used by coders.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          _image_info->verbose= ArgBoolean;\n          _image_info->ping=MagickFalse; /* verbose can't be a ping */\n          break;\n        }\n      if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             This is VERY deep in the image caching structure.\n          */\n          parse=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedVirtualPixelMethod\",\n                 option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"weight\",option+1) == 0)\n        {\n          ssize_t\n            weight;\n\n          weight=ParseCommandOption(MagickWeightOptions,MagickFalse,arg1);\n          if (weight == -1)\n            weight=(ssize_t) StringToUnsignedLong(arg1);\n          _draw_info->weight=(size_t) weight;\n          break;\n        }\n      if (LocaleCompare(\"white-point\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if ((arg1 && arg1n) && (arg1 != arg1n ))\n    arg1=DestroyString((char *) arg1);\n  if ((arg2 && arg2n) && (arg2 != arg2n ))\n    arg2=DestroyString((char *) arg2);\n\n#undef _image_info\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfSetOption\n#undef ArgBoolean\n#undef ArgBooleanNot\n#undef ArgBooleanString\n#undef ArgOption\n\n  return;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I S i m p l e O p e r a t o r I m a g e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISimpleOperatorImages() applys one simple image operation given to all\n%  the images in the CLI wand, using any per-image or global settings that was\n%  previously saved in the CLI wand.\n%\n%  It is assumed that any such settings are up-to-date.\n%\n%  The format of the WandSimpleOperatorImages method is:\n%\n%    MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,const char *option,\n%      const char *arg1, const char *arg2,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings and images to be operated on\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%\n*/\n\n/*\n  CLISimpleOperatorImage() is an Internal subrountine to apply one simple\n  image operation to the current image pointed to by the CLI wand.\n\n  The image in the list may be modified in three different ways...\n    * directly modified (EG: -negate, -gamma, -level, -annotate, -draw),\n    * replaced by a new image (EG: -spread, -resize, -rotate, -morphology)\n    * one image replace by a list of images (-separate and -crop only!)\n\n  In each case the result replaces the single original image in the list, as\n  well as the pointer to the modified image (last image added if replaced by a\n  list of images) is returned.\n\n  As the image pointed to may be replaced, the first image in the list may\n  also change.  GetFirstImageInList() should be used by caller if they wish\n  return the Image pointer to the first image in list.\n*/\nstatic MagickBooleanType CLISimpleOperatorImage(MagickCLI *cli_wand,\n  const char *option, const char *arg1n, const char *arg2n,\n  ExceptionInfo *exception)\n{\n  Image *\n    new_image;\n\n  GeometryInfo\n    geometry_info;\n\n  RectangleInfo\n    geometry;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    parse;\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp        (*option=='-')\n#define IfPlusOp          (*option!='-')\n#define IsNormalOp        IfNormalOp ? MagickTrue : MagickFalse\n#define IsPlusOp          IfNormalOp ? MagickFalse : MagickTrue\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_image != (Image *) NULL);             /* an image must be present */\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",cli_wand->wand.name);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n#if 0\n  (void) FormatLocaleFile(stderr,\n    \"CLISimpleOperatorImage: \\\"%s\\\" \\\"%s\\\" \\\"%s\\\"\\n\",option,arg1,arg2);\n#endif\n\n  new_image = (Image *) NULL; /* the replacement image, if not null at end */\n  SetGeometryInfo(&geometry_info);\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=AdaptiveResizeImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveSharpenImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"alpha\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedAlphaChannelOption\",\n              option,arg1);\n          (void) SetImageAlphaChannel(_image,(AlphaChannelOption) parse,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"annotate\",option+1) == 0)\n        {\n          char\n            geometry[MagickPathExtent];\n\n          SetGeometryInfo(&geometry_info);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (flags == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          (void) CloneString(&_draw_info->text,arg2);\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"%+f%+f\",\n            geometry_info.xi,geometry_info.psi);\n          (void) CloneString(&_draw_info->geometry,geometry);\n          _draw_info->affine.sx=cos(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.rx=sin(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.ry=(-sin(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0))));\n          _draw_info->affine.sy=cos(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0)));\n          (void) AnnotateImage(_image,_draw_info,_exception);\n          GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n        {\n          (void) AutoGammaImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-level\",option+1) == 0)\n        {\n          (void) AutoLevelImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-orient\",option+1) == 0)\n        {\n          new_image=AutoOrientImage(_image,_image->orientation,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n        {\n          AutoThresholdMethod\n            method;\n\n          method=(AutoThresholdMethod) ParseCommandOption(\n            MagickAutoThresholdOptions,MagickFalse,arg1);\n          (void) AutoThresholdImage(_image,method,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"black-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) BlackThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blue-shift\",option+1) == 0)\n        {\n          geometry_info.rho=1.5;\n          if (IfNormalOp) {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          }\n          new_image=BlueShiftImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=BlurImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"border\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & (WidthValue | HeightValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          compose=OverCompositeOp;\n          value=GetImageOption(_image_info,\"compose\");\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          new_image=BorderImage(_image,&geometry,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n        {\n          double\n            brightness,\n            contrast;\n\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          brightness=geometry_info.rho;\n          contrast=0.0;\n          if ((flags & SigmaValue) != 0)\n            contrast=geometry_info.sigma;\n          (void) BrightnessContrastImage(_image,brightness,contrast,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"canny\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=10;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=30;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi/=100.0;\n              geometry_info.psi/=100.0;\n            }\n          new_image=CannyEdgeImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cdl\",option+1) == 0)\n        {\n          char\n            *color_correction_collection; /* Note: arguments do not have percent escapes expanded */\n\n          /*\n            Color correct with a color decision list.\n          */\n          color_correction_collection=FileToString(arg1,~0UL,_exception);\n          if (color_correction_collection == (char *) NULL)\n            break;\n          (void) ColorDecisionListImage(_image,color_correction_collection,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"channel\",option+1) == 0)\n        {\n          if (IfPlusOp)\n            {\n              (void) SetPixelChannelMask(_image,DefaultChannels);\n              break;\n            }\n          parse=ParseChannelOption(arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedChannelType\",option,\n              arg1);\n          (void) SetPixelChannelMask(_image,(ChannelType) parse);\n          break;\n        }\n      if (LocaleCompare(\"charcoal\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          new_image=CharcoalImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"chop\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=ChopImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clahe\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          (void) CLAHEImage(_image,geometry.width,geometry.height,\n            (size_t) geometry.x,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clamp\",option+1) == 0)\n        {\n          (void) ClampImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clip\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            (void) ClipImage(_image,_exception);\n          else /* \"+mask\" remove the write mask */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n              _exception);\n          break;\n        }\n      if (LocaleCompare(\"clip-mask\",option+1) == 0)\n        {\n          Image\n            *clip_mask;\n\n          if (IfPlusOp) {\n            /* use \"+clip-mask\" Remove the write mask for -clip-path */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,_exception);\n            break;\n          }\n          clip_mask=GetImageCache(_image_info,arg1,_exception);\n          if (clip_mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,clip_mask,_exception);\n          clip_mask=DestroyImage(clip_mask);\n          break;\n        }\n      if (LocaleCompare(\"clip-path\",option+1) == 0)\n        {\n          (void) ClipImagePath(_image,arg1,IsNormalOp,_exception);\n          /* Note: Use \"+clip-mask\" remove the write mask added */\n          break;\n        }\n      if (LocaleCompare(\"colorize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorizeImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"color-matrix\",option+1) == 0)\n        {\n          KernelInfo\n            *kernel;\n\n          kernel=AcquireKernelInfo(arg1,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorMatrixImage(_image,kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"colors\",option+1) == 0)\n        {\n          /* Reduce the number of colors in the image.\n             FUTURE: also provide 'plus version with image 'color counts'\n          */\n          _quantize_info->number_colors=StringToUnsignedLong(arg1);\n          if (_quantize_info->number_colors == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((_image->storage_class == DirectClass) ||\n              _image->colors > _quantize_info->number_colors)\n            (void) QuantizeImage(_quantize_info,_image,_exception);\n          else\n            (void) CompressImageColormap(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* WARNING: this is both a image_info setting (already done)\n                      and a operator to change image colorspace.\n\n             FUTURE: default colorspace should be sRGB!\n             Unless some type of 'linear colorspace' mode is set.\n\n             Note that +colorspace sets \"undefined\" or no effect on\n             new images, but forces images already in memory back to RGB!\n             That seems to be a little strange!\n          */\n          (void) TransformImageColorspace(_image,\n                    IfNormalOp ? _image_info->colorspace : sRGBColorspace,\n                    _exception);\n          break;\n        }\n      if (LocaleCompare(\"connected-components\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ConnectedComponentsImage(_image,(size_t)\n            StringToInteger(arg1),(CCObjectInfo **) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-level\":\"+level\");\n          (void) ContrastImage(_image,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(flags & SigmaValue) != 0 ? geometry_info.sigma :\n            black_point;\n          if ((flags & PercentValue) != 0) {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          white_point=(double) _image->columns*_image->rows-white_point;\n          (void) ContrastStretchImage(_image,black_point,white_point,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"convolve\",option+1) == 0)\n        {\n          double\n            gamma;\n\n          KernelInfo\n            *kernel_info;\n\n          register ssize_t\n            j;\n\n          kernel_info=AcquireKernelInfo(arg1,exception);\n          if (kernel_info == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          gamma=0.0;\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            gamma+=kernel_info->values[j];\n          gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma);\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            kernel_info->values[j]*=gamma;\n          new_image=MorphologyImage(_image,CorrelateMorphology,1,kernel_info,\n            _exception);\n          kernel_info=DestroyKernelInfo(kernel_info);\n          break;\n        }\n      if (LocaleCompare(\"crop\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=CropImageToTiles(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cycle\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CycleColormapImage(_image,(ssize_t) StringToLong(arg1),\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"decipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey == (StringInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n\n          (void) PasskeyDecipherImage(_image,passkey,_exception);\n          passkey=DestroyStringInfo(passkey);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* The _image_info->depth setting has already been set\n             We just need to apply it to all images in current sequence\n\n             WARNING: Depth from 8 to 16 causes 'quantum rounding to images!\n             That is it really is an operation, not a setting! Arrgghhh\n\n             FUTURE: this should not be an operator!!!\n          */\n          (void) SetImageDepth(_image,_image_info->depth,_exception);\n          break;\n        }\n      if (LocaleCompare(\"deskew\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          else\n            threshold=40.0*QuantumRange/100.0;\n          new_image=DeskewImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"despeckle\",option+1) == 0)\n        {\n          new_image=DespeckleImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"distort\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse = ParseCommandOption(MagickDistortOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n             CLIWandExceptArgBreak(OptionError,\"UnrecognizedDistortMethod\",\n                                      option,arg1);\n          if ((DistortMethod) parse == ResizeDistortion)\n            {\n               double\n                 resize_args[2];\n               /* Special Case - Argument is actually a resize geometry!\n               ** Convert that to an appropriate distortion argument array.\n               ** FUTURE: make a separate special resize operator\n                    Roll into a resize special operator */\n               if (IsGeometry(arg2) == MagickFalse)\n                 CLIWandExceptArgBreak(OptionError,\"InvalidGeometry\",\n                                           option,arg2);\n               (void) ParseRegionGeometry(_image,arg2,&geometry,_exception);\n               resize_args[0]=(double) geometry.width;\n               resize_args[1]=(double) geometry.height;\n               new_image=DistortImage(_image,(DistortMethod) parse,\n                    (size_t)2,resize_args,MagickTrue,_exception);\n               break;\n            }\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          new_image=DistortImage(_image,(DistortMethod) parse,(size_t)\n             count,args,IsPlusOp,_exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"draw\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->primitive,arg1);\n          (void) DrawImage(_image,_draw_info,_exception);\n          (void) CloneString(&_draw_info->primitive,(char *) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"edge\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=EdgeImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"emboss\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=EmbossImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"encipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey != (StringInfo *) NULL)\n            {\n              (void) PasskeyEncipherImage(_image,passkey,_exception);\n              passkey=DestroyStringInfo(passkey);\n            }\n          break;\n        }\n      if (LocaleCompare(\"enhance\",option+1) == 0)\n        {\n          new_image=EnhanceImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"equalize\",option+1) == 0)\n        {\n          (void) EqualizeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"evaluate\",option+1) == 0)\n        {\n          double\n            constant;\n\n          parse = ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n                 option,arg1);\n          if (IsGeometry(arg2) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          constant=StringToDoubleInterval(arg2,(double) QuantumRange+1.0);\n          (void) EvaluateImage(_image,(MagickEvaluateOperator)parse,constant,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"extent\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          if (geometry.width == 0)\n            geometry.width=_image->columns;\n          if (geometry.height == 0)\n            geometry.height=_image->rows;\n          new_image=ExtentImage(_image,&geometry,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"flip\",option+1) == 0)\n        {\n          new_image=FlipImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"flop\",option+1) == 0)\n        {\n          new_image=FlopImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"floodfill\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) QueryColorCompliance(arg2,AllCompliance,&target,_exception);\n          (void) FloodfillPaintImage(_image,_draw_info,&target,geometry.x,\n            geometry.y,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"frame\",option+1) == 0)\n        {\n          FrameInfo\n            frame_info;\n\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          value=GetImageOption(_image_info,\"compose\");\n            compose=OverCompositeOp;  /* use Over not _image->compose */\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          frame_info.width=geometry.width;\n          frame_info.height=geometry.height;\n          frame_info.outer_bevel=geometry.x;\n          frame_info.inner_bevel=geometry.y;\n          frame_info.x=(ssize_t) frame_info.width;\n          frame_info.y=(ssize_t) frame_info.height;\n          frame_info.width=_image->columns+2*frame_info.width;\n          frame_info.height=_image->rows+2*frame_info.height;\n          new_image=FrameImage(_image,&frame_info,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"function\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse=ParseCommandOption(MagickFunctionOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",\n                 option,arg1);\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          (void) FunctionImage(_image,(MagickFunction)parse,(size_t) count,args,\n               _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",option+1) == 0)\n        {\n          double\n            constant;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          constant=StringToDouble(arg1,(char **) NULL);\n#if 0\n          /* Using Gamma, via a cache */\n          if (IfPlusOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) GammaImage(_image,constant,_exception);\n#else\n          /* Using Evaluate POW, direct update of values - more accurite */\n          if (IfNormalOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) EvaluateImage(_image,PowEvaluateOperator,constant,_exception);\n          _image->gamma*=StringToDouble(arg1,(char **) NULL);\n#endif\n          /* Set gamma setting -- Old meaning of \"+gamma\"\n           * _image->gamma=StringToDouble(arg1,(char **) NULL);\n           */\n          break;\n        }\n      if (LocaleCompare(\"gaussian-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=GaussianBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"gaussian\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-gaussian-blur\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-gaussian-blur\",arg1,NULL,exception);\n        }\n      if (LocaleCompare(\"geometry\",option+1) == 0)\n        {\n          /*\n            Record Image offset for composition. (A Setting)\n            Resize last _image. (ListOperator)  -- DEPRECIATE\n            FUTURE: Why if no 'offset' does this resize ALL images?\n            Also why is the setting recorded in the IMAGE non-sense!\n          */\n          if (IfPlusOp)\n            { /* remove the previous composition geometry offset! */\n              if (_image->geometry != (char *) NULL)\n                _image->geometry=DestroyString(_image->geometry);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) CloneString(&_image->geometry,arg1);\n          else\n            new_image=ResizeImage(_image,geometry.width,geometry.height,\n              _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"grayscale\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickPixelIntensityOptions,\n            MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityMethod\",\n              option,arg1);\n          (void) GrayscaleImage(_image,(PixelIntensityMethod) parse,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hough-lines\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=40;\n          new_image=HoughLineImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,(size_t) geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"identify\",option+1) == 0)\n        {\n          const char\n            *format,\n            *text;\n\n          format=GetImageOption(_image_info,\"format\");\n          if (format == (char *) NULL)\n            {\n              (void) IdentifyImage(_image,stdout,_image_info->verbose,\n                _exception);\n              break;\n            }\n          text=InterpretImageProperties(_image_info,_image,format,_exception);\n          if (text == (char *) NULL)\n            CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n              option);\n          (void) fputs(text,stdout);\n          text=DestroyString((char *)text);\n          break;\n        }\n      if (LocaleCompare(\"implode\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ImplodeImage(_image,geometry_info.rho,_image->interpolate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"interpolative-resize\",option+1) == 0)\n        {\n          /* FUTURE: New to IMv7\n               Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=InterpolativeResizeImage(_image,geometry.width,\n               geometry.height,_image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kuwahara\",option+1) == 0)\n        {\n          /*\n            Edge preserving blur.\n          */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho-0.5;\n          new_image=KuwaharaImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"lat\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=AdaptiveThresholdImage(_image,(size_t) geometry_info.rho,\n               (size_t) geometry_info.sigma,(double) geometry_info.xi,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"level\",option+1) == 0)\n        {\n          double\n            black_point,\n            gamma,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) QuantumRange;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          gamma=1.0;\n          if ((flags & XiValue) != 0)\n            gamma=geometry_info.xi;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) (QuantumRange/100.0);\n              white_point*=(double) (QuantumRange/100.0);\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) QuantumRange-black_point;\n          if (IfPlusOp || ((flags & AspectValue) != 0))\n            (void) LevelizeImage(_image,black_point,white_point,gamma,_exception);\n          else\n            (void) LevelImage(_image,black_point,white_point,gamma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"level-colors\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          PixelInfo\n            black_point,\n            white_point;\n\n          p=(const char *) arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);  /* get black point color */\n          if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n            (void) QueryColorCompliance(token,AllCompliance,\n                      &black_point,_exception);\n          else\n            (void) QueryColorCompliance(\"#000000\",AllCompliance,\n                      &black_point,_exception);\n          if (isalpha((int) token[0]) || (token[0] == '#'))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == '\\0')\n            white_point=black_point; /* set everything to that color */\n          else\n            {\n              if ((isalpha((int) *token) == 0) && ((*token == '#') == 0))\n                GetNextToken(p,&p,MagickPathExtent,token); /* Get white point color. */\n              if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n                (void) QueryColorCompliance(token,AllCompliance,\n                           &white_point,_exception);\n              else\n                (void) QueryColorCompliance(\"#ffffff\",AllCompliance,\n                           &white_point,_exception);\n            }\n          (void) LevelImageColors(_image,&black_point,&white_point,\n                     IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"linear-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) _image->columns*_image->rows;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) _image->columns*_image->rows-\n              black_point;\n          (void) LinearStretchImage(_image,black_point,white_point,_exception);\n          break;\n        }\n      if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & XValue) == 0)\n            geometry.x=1;\n          if ((flags & YValue) == 0)\n            geometry.y=0;\n          new_image=LiquidRescaleImage(_image,geometry.width,\n            geometry.height,1.0*geometry.x,1.0*geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"local-contrast\",option+1) == 0)\n        {\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            geometry_info.rho=10;\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=12.5;\n          new_image=LocalContrastImage(_image,geometry_info.rho,\n            geometry_info.sigma,exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magnify\",option+1) == 0)\n        {\n          new_image=MagnifyImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-remap\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-remap\",NULL,NULL,exception);\n          break;\n        }\n      if (LocaleCompare(\"mask\",option+1) == 0)\n        {\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            {\n              /*\n                Remove a mask.\n              */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /*\n            Set the image mask.\n          */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"matte\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-alpha Set\":\"-alpha Off\");\n          (void) SetImageAlphaChannel(_image,IfNormalOp ? SetAlphaChannel :\n            DeactivateAlphaChannel, _exception);\n          break;\n        }\n      if (LocaleCompare(\"mean-shift\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.10*QuantumRange;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=MeanShiftImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"median\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-statistic Median\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Median\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"mode\",option+1) == 0)\n        {\n          /* FUTURE: note this is also a special \"montage\" option */\n          CLIWandWarnReplaced(\"-statistic Mode\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Mode\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"modulate\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ModulateImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageProgressMonitor(_image, IfNormalOp ? MonitorProgress :\n                (MagickProgressMonitor) NULL,(void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          (void) SetImageType(_image,BilevelType,_exception);\n          break;\n        }\n      if (LocaleCompare(\"morphology\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          KernelInfo\n            *kernel;\n\n          ssize_t\n            iterations;\n\n          p=arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          parse=ParseCommandOption(MagickMorphologyOptions,MagickFalse,token);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",option,\n              arg1);\n          iterations=1L;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p == ':') || (*p == ','))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p != '\\0'))\n            iterations=(ssize_t) StringToLong(p);\n          kernel=AcquireKernelInfo(arg2,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"UnabletoParseKernel\",option,arg2);\n          new_image=MorphologyImage(_image,(MorphologyMethod)parse,iterations,\n            kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"motion-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=MotionBlurImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'n':\n    {\n      if (LocaleCompare(\"negate\",option+1) == 0)\n        {\n          (void) NegateImage(_image, IsPlusOp, _exception);\n          break;\n        }\n      if (LocaleCompare(\"noise\",option+1) == 0)\n        {\n          double\n            attenuate;\n\n          const char*\n            value;\n\n          if (IfNormalOp)\n            {\n              CLIWandWarnReplaced(\"-statistic NonPeak\");\n              (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"NonPeak\",arg1,exception);\n              break;\n            }\n          parse=ParseCommandOption(MagickNoiseOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedNoiseType\",\n                option,arg1);\n          attenuate=1.0;\n          value=GetImageOption(_image_info,\"attenuate\");\n          if  (value != (const char *) NULL)\n            attenuate=StringToDouble(value,(char **) NULL);\n          new_image=AddNoiseImage(_image,(NoiseType)parse,attenuate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"normalize\",option+1) == 0)\n        {\n          (void) NormalizeImage(_image,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) OpaquePaintImage(_image,&target,&_draw_info->fill,IsPlusOp,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n        {\n          (void) OrderedDitherImage(_image,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"paint\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=OilPaintImage(_image,geometry_info.rho,geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"perceptible\",option+1) == 0)\n        {\n          (void) PerceptibleImage(_image,StringToDouble(arg1,(char **) NULL),\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"polaroid\",option+1) == 0)\n        {\n          const char\n            *caption;\n\n          double\n            angle;\n\n          if (IfPlusOp) {\n            RandomInfo\n              *random_info;\n\n            random_info=AcquireRandomInfo();\n            angle=22.5*(GetPseudoRandomValue(random_info)-0.5);\n            random_info=DestroyRandomInfo(random_info);\n          }\n          else {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            angle=geometry_info.rho;\n          }\n          caption=GetImageProperty(_image,\"caption\",_exception);\n          new_image=PolaroidImage(_image,_draw_info,caption,angle,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"posterize\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) PosterizeImage(_image,(size_t) geometry_info.rho,\n            _quantize_info->dither_method,_exception);\n          break;\n        }\n      if (LocaleCompare(\"preview\",option+1) == 0)\n        {\n          /* FUTURE: should be a 'Genesis' option?\n             Option however is also in WandSettingOptionInfo()\n             Why???\n          */\n          parse=ParseCommandOption(MagickPreviewOptions, MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedPreviewType\",\n                option,arg1);\n          new_image=PreviewImage(_image,(PreviewType)parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"profile\",option+1) == 0)\n        {\n          const char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          Image\n            *profile_image;\n\n          ImageInfo\n            *profile_info;\n\n          /* Note: arguments do not have percent escapes expanded */\n          if (IfPlusOp)\n            { /* Remove a profile from the _image.  */\n              (void) ProfileImage(_image,arg1,(const unsigned char *)\n                NULL,0,_exception);\n              break;\n            }\n          /* Associate a profile with the _image.  */\n          profile_info=CloneImageInfo(_image_info);\n          profile=GetImageProfile(_image,\"iptc\");\n          if (profile != (StringInfo *) NULL)\n            profile_info->profile=(void *) CloneStringInfo(profile);\n          profile_image=GetImageCache(profile_info,arg1,_exception);\n          profile_info=DestroyImageInfo(profile_info);\n          if (profile_image == (Image *) NULL)\n            {\n              StringInfo\n                *profile;\n\n              profile_info=CloneImageInfo(_image_info);\n              (void) CopyMagickString(profile_info->filename,arg1,\n                MagickPathExtent);\n              profile=FileToStringInfo(profile_info->filename,~0UL,_exception);\n              if (profile != (StringInfo *) NULL)\n                {\n                  (void) SetImageInfo(profile_info,0,_exception);\n                  (void) ProfileImage(_image,profile_info->magick,\n                    GetStringInfoDatum(profile),(size_t)\n                    GetStringInfoLength(profile),_exception);\n                  profile=DestroyStringInfo(profile);\n                }\n              profile_info=DestroyImageInfo(profile_info);\n              break;\n            }\n          ResetImageProfileIterator(profile_image);\n          name=GetNextImageProfile(profile_image);\n          while (name != (const char *) NULL)\n          {\n            profile=GetImageProfile(profile_image,name);\n            if (profile != (StringInfo *) NULL)\n              (void) ProfileImage(_image,name,GetStringInfoDatum(profile),\n                (size_t) GetStringInfoLength(profile),_exception);\n            name=GetNextImageProfile(profile_image);\n          }\n          profile_image=DestroyImage(profile_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"raise\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) RaiseImage(_image,&geometry,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"random-threshold\",option+1) == 0)\n        {\n          double\n            min_threshold,\n            max_threshold;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          min_threshold=0.0;\n          max_threshold=(double) QuantumRange;\n          flags=ParseGeometry(arg1,&geometry_info);\n          min_threshold=geometry_info.rho;\n          max_threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            max_threshold=min_threshold;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              max_threshold*=(double) (0.01*QuantumRange);\n              min_threshold*=(double) (0.01*QuantumRange);\n            }\n          (void) RandomThresholdImage(_image,min_threshold,max_threshold,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"range-threshold\",option+1) == 0)\n        {\n          /*\n            Range threshold image.\n          */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=geometry_info.sigma;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=geometry_info.xi;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              geometry_info.rho*=(double) (0.01*QuantumRange);\n              geometry_info.sigma*=(double) (0.01*QuantumRange);\n              geometry_info.xi*=(double) (0.01*QuantumRange);\n              geometry_info.psi*=(double) (0.01*QuantumRange);\n            }\n          (void) RangeThresholdImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n          break;\n        }\n      if (LocaleCompare(\"read-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,ReadPixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,ReadPixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"recolor\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-color-matrix\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-color-matrix\",arg1,NULL,\n            exception);\n        }\n      if (LocaleCompare(\"region\",option+1) == 0)\n        {\n          if (*option == '+')\n            {\n              (void) SetImageRegionMask(_image,WritePixelMask,\n                (const RectangleInfo *) NULL,_exception);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          (void) SetImageRegionMask(_image,WritePixelMask,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *remap_image;\n\n          remap_image=GetImageCache(_image_info,arg1,_exception);\n          if (remap_image == (Image *) NULL)\n            break;\n          (void) RemapImage(_quantize_info,_image,remap_image,_exception);\n          remap_image=DestroyImage(remap_image);\n          break;\n        }\n      if (LocaleCompare(\"repage\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                  arg1);\n              (void) ResetImagePage(_image,arg1);\n            }\n          else\n            (void) ParseAbsoluteGeometry(\"0x0+0+0\",&_image->page);\n          break;\n        }\n      if (LocaleCompare(\"resample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operation */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ResampleImage(_image,geometry_info.rho,\n            geometry_info.sigma,_image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"resize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ResizeImage(_image,geometry.width,geometry.height,\n            _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"roll\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry.x*=(double) _image->columns/100.0;\n              geometry.y*=(double) _image->rows/100.0;\n            }\n          new_image=RollImage(_image,geometry.x,geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotate\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & GreaterValue) != 0 && (_image->columns <= _image->rows))\n            break;\n          if ((flags & LessValue) != 0 && (_image->columns >= _image->rows))\n            break;\n          new_image=RotateImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=RotationalBlurImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=SampleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"scale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ScaleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"segment\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          (void) SegmentImage(_image,_image->colorspace,\n            _image_info->verbose,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"selective-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=SelectiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"separate\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          /* FUTURE - this may be replaced by a \"-channel\" method */\n          new_image=SeparateImages(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SepiaToneImage(_image,StringToDoubleInterval(arg1,\n                 (double) QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"shade\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (((flags & RhoValue) == 0) || ((flags & SigmaValue) == 0))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ShadeImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shadow\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=4.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=4.0;\n          new_image=ShadowImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.0;\n          new_image=SharpenImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"shave\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          new_image=ShaveImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shear\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ShearImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=(double) QuantumRange/2.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.sigma=(double) QuantumRange*geometry_info.sigma/\n              100.0;\n          (void) SigmoidalContrastImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sketch\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=SketchImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"solarize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SolarizeImage(_image,StringToDoubleInterval(arg1,(double)\n                 QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sparse-color\",option+1) == 0)\n        {\n          parse= ParseCommandOption(MagickSparseColorOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedSparseColorMethod\",\n                option,arg1);\n          new_image=SparseColorOption(_image,(SparseColorMethod)parse,arg2,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"splice\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=SpliceImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"spread\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          new_image=SpreadImage(_image,_image->interpolate,geometry_info.rho,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"statistic\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickStatisticOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStatisticType\",\n                 option,arg1);\n          flags=ParseGeometry(arg2,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=StatisticImage(_image,(StatisticType)parse,\n               (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"strip\",option+1) == 0)\n        {\n          (void) StripImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"swirl\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SwirlImage(_image,geometry_info.rho,\n            _image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"threshold\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          threshold=(double) QuantumRange/2;\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          (void) BilevelImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"thumbnail\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ThumbnailImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"tint\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=TintImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transform\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+distort AffineProjection\");\n          new_image=AffineTransformImage(_image,&_draw_info->affine,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transparent\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) TransparentPaintImage(_image,&target,(Quantum)\n            TransparentAlpha,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transpose\",option+1) == 0)\n        {\n          new_image=TransposeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transverse\",option+1) == 0)\n        {\n          new_image=TransverseImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"trim\",option+1) == 0)\n        {\n          new_image=TrimImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* Note that \"type\" setting should have already been defined */\n          (void) SetImageType(_image,_image_info->type,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcqireImage()???\n             Option is not documented, bt appears to be for \"identify\".\n             We may need a identify specific verbose!\n          */\n          if (IsPlusOp) {\n              (void) DeleteImageArtifact(_image,\"identify:unique-colors\");\n              break;\n            }\n          (void) SetImageArtifact(_image,\"identify:unique-colors\",\"true\");\n          (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"unique-colors\",option+1) == 0)\n        {\n          new_image=UniqueImageColors(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"unsharp\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.05;\n          new_image=UnsharpMaskImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcquireImage()???\n             three places!   ImageArtifact   ImageOption  _image_info->verbose\n             Some how new images also get this artifact!\n          */\n          (void) SetImageArtifact(_image,option+1,\n                           IfNormalOp ? \"true\" : \"false\" );\n          break;\n        }\n      if (LocaleCompare(\"vignette\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.1*_image->columns;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.1*_image->rows;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi*=(double) _image->columns/100.0;\n              geometry_info.psi*=(double) _image->rows/100.0;\n            }\n          new_image=VignetteImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"wave\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=WaveImage(_image,geometry_info.rho,geometry_info.sigma,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.rho=QuantumRange*geometry_info.rho/100.0;\n              geometry_info.sigma=QuantumRange*geometry_info.sigma/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=0.0;\n          new_image=WaveletDenoiseImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"white-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) WhiteThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"write-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* Replace current image with any image that was generated\n     and set image point to last image (so image->next is correct) */\n  if (new_image != (Image *) NULL)\n    ReplaceImageInListReturnLast(&_image,new_image);\n\n  return(MagickTrue);\n#undef _image_info\n#undef _draw_info\n#undef _quantize_info\n#undef _image\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n#undef IsPlusOp\n}\n\nWandPrivate MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1,const char *arg2,ExceptionInfo *exception)\n{\n#if !USE_WAND_METHODS\n  size_t\n    n,\n    i;\n#endif\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(cli_wand->wand.images != (Image *) NULL); /* images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Simple Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1,arg2);\n\n#if !USE_WAND_METHODS\n  /* FUTURE add appropriate tracing */\n  i=0;\n  n=GetImageListLength(cli_wand->wand.images);\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n  while (1) {\n    i++;\n    CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n    if ( cli_wand->wand.images->next == (Image *) NULL )\n      break;\n    cli_wand->wand.images=cli_wand->wand.images->next;\n  }\n  assert( i == n );\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n#else\n  MagickResetIterator(&cli_wand->wand);\n  while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n    (void) CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n  MagickResetIterator(&cli_wand->wand);\n#endif\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I L i s t O p e r a t o r I m a g e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIListOperatorImages() applies a single operation that is apply to the\n%  entire image list as a whole. The result is often a complete replacment\n%  of the image list with a completely new list, or with just a single image\n%  result.\n%\n%  The format of the MogrifyImage method is:\n%\n%    MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n%      const char *option,const char *arg1,const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently not used\n%\n*/\nWandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n  Image\n    *new_images;\n\n  MagickStatusType\n    status;\n\n  ssize_t\n    parse;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _draw_info      (cli_wand->draw_info)\n#define _quantize_info  (cli_wand->quantize_info)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n#define IsNormalOp      IfNormalOp ? MagickTrue : MagickFalse\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_images != (Image *) NULL);             /* _images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n       \"- List Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n       arg1n == (const char *) NULL ? \"null\" : arg1n,\n       arg2n == (const char *) NULL ? \"null\" : arg2n);\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  status=MagickTrue;\n  new_images=NewImageList();\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"append\",option+1) == 0)\n        {\n          new_images=AppendImages(_images,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"average\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-evaluate-sequence Mean\");\n          (void) CLIListOperatorImages(cli_wand,\"-evaluate-sequence\",\"Mean\",\n            NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channel-fx\",option+1) == 0)\n        {\n          new_images=ChannelFxImage(_images,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clut\",option+1) == 0)\n        {\n          Image\n            *clut_image;\n\n          /* FUTURE - make this a compose option, and thus can be used\n             with layers compose or even compose last image over all other\n             _images.\n          */\n          new_images=RemoveFirstImageFromList(&_images);\n          clut_image=RemoveLastImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (clut_image == (Image *) NULL)\n            break;\n          (void) ClutImage(new_images,clut_image,new_images->interpolate,\n            _exception);\n          clut_image=DestroyImage(clut_image);\n          break;\n        }\n      if (LocaleCompare(\"coalesce\",option+1) == 0)\n        {\n          new_images=CoalesceImages(_images,_exception);\n          break;\n        }\n      if (LocaleCompare(\"combine\",option+1) == 0)\n        {\n          parse=(ssize_t) _images->colorspace;\n          if (_images->number_channels < GetImageListLength(_images))\n            parse=sRGBColorspace;\n          if ( IfPlusOp )\n            parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          new_images=CombineImages(_images,(ColorspaceType) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"compare\",option+1) == 0)\n        {\n          double\n            distortion;\n\n          Image\n            *image,\n            *reconstruct_image;\n\n          MetricType\n            metric;\n\n          /*\n            Mathematically and visually annotate the difference between an\n            image and its reconstruction.\n          */\n          image=RemoveFirstImageFromList(&_images);\n          reconstruct_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (reconstruct_image == (Image *) NULL)\n            { \n              image=DestroyImage(image);\n              break;\n            }\n          metric=UndefinedErrorMetric;\n          option=GetImageOption(_image_info,\"metric\");\n          if (option != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,option);\n          new_images=CompareImages(image,reconstruct_image,metric,&distortion,\n            _exception);\n          (void) distortion;\n          reconstruct_image=DestroyImage(reconstruct_image);\n          image=DestroyImage(image);\n          break;\n        }\n      if (LocaleCompare(\"complex\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickComplexOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=ComplexImages(_images,(ComplexOperator) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"composite\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          MagickBooleanType\n            clip_to_self;\n\n          Image\n            *mask_image,\n            *source_image;\n\n          RectangleInfo\n            geometry;\n\n          /* Compose value from \"-compose\" option only */\n          value=GetImageOption(_image_info,\"compose\");\n          if (value == (const char *) NULL)\n            compose=OverCompositeOp;  /* use Over not source_image->compose */\n          else\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n\n          /* Get \"clip-to-self\" expert setting (false is normal) */\n          clip_to_self=GetCompositeClipToSelf(compose);\n          value=GetImageOption(_image_info,\"compose:clip-to-self\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringTrue(value);\n          value=GetImageOption(_image_info,\"compose:outside-overlay\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringFalse(value);  /* deprecated */\n\n          new_images=RemoveFirstImageFromList(&_images);\n          source_image=RemoveFirstImageFromList(&_images);\n          if (source_image == (Image *) NULL)\n            break; /* FUTURE - produce Exception, rather than silent fail */\n\n          /* FUTURE - this should not be here! - should be part of -geometry */\n          if (source_image->geometry != (char *) NULL)\n            {\n              RectangleInfo\n                resize_geometry;\n\n              (void) ParseRegionGeometry(source_image,source_image->geometry,\n                &resize_geometry,_exception);\n              if ((source_image->columns != resize_geometry.width) ||\n                  (source_image->rows != resize_geometry.height))\n                {\n                  Image\n                    *resize_image;\n\n                  resize_image=ResizeImage(source_image,resize_geometry.width,\n                    resize_geometry.height,source_image->filter,_exception);\n                  if (resize_image != (Image *) NULL)\n                    {\n                      source_image=DestroyImage(source_image);\n                      source_image=resize_image;\n                    }\n                }\n            }\n          SetGeometry(source_image,&geometry);\n          (void) ParseAbsoluteGeometry(source_image->geometry,&geometry);\n          GravityAdjustGeometry(new_images->columns,new_images->rows,\n            new_images->gravity, &geometry);\n          mask_image=RemoveFirstImageFromList(&_images);\n          if (mask_image == (Image *) NULL)\n            status&=CompositeImage(new_images,source_image,compose,clip_to_self,\n              geometry.x,geometry.y,_exception);\n          else\n            {\n              if ((compose == DisplaceCompositeOp) ||\n                  (compose == DistortCompositeOp))\n                {\n                  status&=CompositeImage(source_image,mask_image,\n                    CopyGreenCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                }\n              else\n                {\n                  Image\n                    *clone_image;\n\n                  clone_image=CloneImage(new_images,0,0,MagickTrue,_exception);\n                  if (clone_image == (Image *) NULL)\n                    break;\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                  status&=CompositeImage(new_images,mask_image,\n                    CopyAlphaCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(clone_image,new_images,OverCompositeOp,\n                    clip_to_self,0,0,_exception);\n                  new_images=DestroyImageList(new_images);\n                  new_images=clone_image;\n                }\n              mask_image=DestroyImage(mask_image);\n            }\n          source_image=DestroyImage(source_image);\n          break;\n        }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            if (IsGeometry(arg2) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) ParsePageGeometry(_images,arg2,&geometry,_exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=_images;\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,arg1,&geometry,_exception);\n            (void) CopyImagePixels(_images,source_image,&geometry,&offset,\n              _exception);\n            break;\n          }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"deconstruct\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-layer CompareAny\");\n          (void) CLIListOperatorImages(cli_wand,\"-layer\",\"CompareAny\",NULL);\n          break;\n        }\n      if (LocaleCompare(\"delete\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            DeleteImages(&_images,arg1,_exception);\n          else\n            DeleteImages(&_images,\"-1\",_exception);\n          break;\n        }\n      if (LocaleCompare(\"duplicate\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              const char\n                *p;\n\n              size_t\n                number_duplicates;\n\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                      arg1);\n              number_duplicates=(size_t) StringToLong(arg1);\n              p=strchr(arg1,',');\n              if (p == (const char *) NULL)\n                new_images=DuplicateImages(_images,number_duplicates,\"-1\",\n                  _exception);\n              else\n                new_images=DuplicateImages(_images,number_duplicates,p,\n                  _exception);\n            }\n          else\n            new_images=DuplicateImages(_images,1,\"-1\",_exception);\n          AppendImageToList(&_images, new_images);\n          new_images=(Image *) NULL;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=EvaluateImages(_images,(MagickEvaluateOperator) parse,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"fft\",option+1) == 0)\n        {\n          new_images=ForwardFourierTransformImage(_images,IsNormalOp,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"flatten\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers flatten instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      if (LocaleCompare(\"fx\",option+1) == 0)\n        {\n          new_images=FxImage(_images,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hald-clut\",option+1) == 0)\n        {\n          /* FUTURE - make this a compose option (and thus layers compose )\n             or perhaps compose last image over all other _images.\n          */\n          Image\n            *hald_image;\n\n          new_images=RemoveFirstImageFromList(&_images);\n          hald_image=RemoveLastImageFromList(&_images);\n          if (hald_image == (Image *) NULL)\n            break;\n          (void) HaldClutImage(new_images,hald_image,_exception);\n          hald_image=DestroyImage(hald_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"ift\",option+1) == 0)\n        {\n          Image\n            *magnitude_image,\n            *phase_image;\n\n           magnitude_image=RemoveFirstImageFromList(&_images);\n           phase_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n           if (phase_image == (Image *) NULL)\n             break;\n           new_images=InverseFourierTransformImage(magnitude_image,phase_image,\n             IsNormalOp,_exception);\n           magnitude_image=DestroyImage(magnitude_image);\n           phase_image=DestroyImage(phase_image);\n          break;\n        }\n      if (LocaleCompare(\"insert\",option+1) == 0)\n        {\n          Image\n            *insert_image,\n            *index_image;\n\n          ssize_t\n            index;\n\n          if (IfNormalOp && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=0;\n          insert_image=RemoveLastImageFromList(&_images);\n          if (IfNormalOp)\n            index=(ssize_t) StringToLong(arg1);\n          index_image=insert_image;\n          if (index == 0)\n            PrependImageToList(&_images,insert_image);\n          else if (index == (ssize_t) GetImageListLength(_images))\n            AppendImageToList(&_images,insert_image);\n          else\n            {\n               index_image=GetImageFromList(_images,index-1);\n               if (index_image == (Image *) NULL)\n                 {\n                   insert_image=DestroyImage(insert_image);\n                   CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n                 }\n              InsertImageInList(&index_image,insert_image);\n            }\n          _images=GetFirstImageInList(index_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"layers\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickLayerOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedLayerMethod\",\n                 option,arg1);\n          switch ((LayerMethod) parse)\n          {\n            case CoalesceLayer:\n            {\n              new_images=CoalesceImages(_images,_exception);\n              break;\n            }\n            case CompareAnyLayer:\n            case CompareClearLayer:\n            case CompareOverlayLayer:\n            default:\n            {\n              new_images=CompareImagesLayers(_images,(LayerMethod) parse,\n                   _exception);\n              break;\n            }\n            case MergeLayer:\n            case FlattenLayer:\n            case MosaicLayer:\n            case TrimBoundsLayer:\n            {\n              new_images=MergeImageLayers(_images,(LayerMethod) parse,\n                _exception);\n              break;\n            }\n            case DisposeLayer:\n            {\n              new_images=DisposeImages(_images,_exception);\n              break;\n            }\n            case OptimizeImageLayer:\n            {\n              new_images=OptimizeImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizePlusLayer:\n            {\n              new_images=OptimizePlusImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizeTransLayer:\n            {\n              OptimizeImageTransparency(_images,_exception);\n              break;\n            }\n            case RemoveDupsLayer:\n            {\n              RemoveDuplicateLayers(&_images,_exception);\n              break;\n            }\n            case RemoveZeroLayer:\n            {\n              RemoveZeroDelayLayers(&_images,_exception);\n              break;\n            }\n            case OptimizeLayer:\n            { /* General Purpose, GIF Animation Optimizer.  */\n              new_images=CoalesceImages(_images,_exception);\n              if (new_images == (Image *) NULL)\n                break;\n              _images=DestroyImageList(_images);\n              _images=OptimizeImageLayers(new_images,_exception);\n              if (_images == (Image *) NULL)\n                break;\n              new_images=DestroyImageList(new_images);\n              OptimizeImageTransparency(_images,_exception);\n              (void) RemapImages(_quantize_info,_images,(Image *) NULL,\n                _exception);\n              break;\n            }\n            case CompositeLayer:\n            {\n              Image\n                *source;\n\n              RectangleInfo\n                geometry;\n\n              CompositeOperator\n                compose;\n\n              const char*\n                value;\n\n              value=GetImageOption(_image_info,\"compose\");\n              compose=OverCompositeOp;  /* Default to Over */\n              if (value != (const char *) NULL)\n                compose=(CompositeOperator) ParseCommandOption(\n                      MagickComposeOptions,MagickFalse,value);\n\n              /* Split image sequence at the first 'NULL:' image. */\n              source=_images;\n              while (source != (Image *) NULL)\n              {\n                source=GetNextImageInList(source);\n                if ((source != (Image *) NULL) &&\n                    (LocaleCompare(source->magick,\"NULL\") == 0))\n                  break;\n              }\n              if (source != (Image *) NULL)\n                {\n                  if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                      (GetNextImageInList(source) == (Image *) NULL))\n                    source=(Image *) NULL;\n                  else\n                    { /* Separate the two lists, junk the null: image.  */\n                      source=SplitImageList(source->previous);\n                      DeleteImageFromList(&source);\n                    }\n                }\n              if (source == (Image *) NULL)\n                {\n                  (void) ThrowMagickException(_exception,GetMagickModule(),\n                    OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                  break;\n                }\n              /* Adjust offset with gravity and virtual canvas.  */\n              SetGeometry(_images,&geometry);\n              (void) ParseAbsoluteGeometry(_images->geometry,&geometry);\n              geometry.width=source->page.width != 0 ?\n                source->page.width : source->columns;\n              geometry.height=source->page.height != 0 ?\n               source->page.height : source->rows;\n              GravityAdjustGeometry(_images->page.width != 0 ?\n                _images->page.width : _images->columns,\n                _images->page.height != 0 ? _images->page.height :\n                _images->rows,_images->gravity,&geometry);\n\n              /* Compose the two image sequences together */\n              CompositeLayers(_images,compose,source,geometry.x,geometry.y,\n                _exception);\n              source=DestroyImageList(source);\n              break;\n            }\n          }\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+remap\");\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"morph\",option+1) == 0)\n        {\n          Image\n            *morph_image;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          morph_image=MorphImages(_images,StringToUnsignedLong(arg1),\n            _exception);\n          if (morph_image == (Image *) NULL)\n            break;\n          _images=DestroyImageList(_images);\n          _images=morph_image;\n          break;\n        }\n      if (LocaleCompare(\"mosaic\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers mosaic instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"poly\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg1,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg1);\n          new_images=PolynomialImage(_images,(size_t) (count >> 1),args,\n           _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"process\",option+1) == 0)\n        {\n          /* FUTURE: better parsing using ScriptToken() from string ??? */\n          char\n            **arguments;\n\n          int\n            j,\n            number_arguments;\n\n          arguments=StringToArgv(arg1,&number_arguments);\n          if (arguments == (char **) NULL)\n            break;\n          if (strchr(arguments[1],'=') != (char *) NULL)\n            {\n              char\n                breaker,\n                quote,\n                *token;\n\n              const char\n                *arguments;\n\n              int\n                next,\n                status;\n\n              size_t\n                length;\n\n              TokenInfo\n                *token_info;\n\n              /*\n                Support old style syntax, filter=\"-option arg1\".\n              */\n              assert(arg1 != (const char *) NULL);\n              length=strlen(arg1);\n              token=(char *) NULL;\n              if (~length >= (MagickPathExtent-1))\n                token=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n                  sizeof(*token));\n              if (token == (char *) NULL)\n                break;\n              next=0;\n              arguments=arg1;\n              token_info=AcquireTokenInfo();\n              status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",\n                \"\\\"\",'\\0',&breaker,&next,&quote);\n              token_info=DestroyTokenInfo(token_info);\n              if (status == 0)\n                {\n                  const char\n                    *argv;\n\n                  argv=(&(arguments[next]));\n                  (void) InvokeDynamicImageFilter(token,&_images,1,&argv,\n                    _exception);\n                }\n              token=DestroyString(token);\n              break;\n            }\n          (void) SubstituteString(&arguments[1],\"-\",\"\");\n          (void) InvokeDynamicImageFilter(arguments[1],&_images,\n            number_arguments-2,(const char **) arguments+2,_exception);\n          for (j=0; j < number_arguments; j++)\n            arguments[j]=DestroyString(arguments[j]);\n          arguments=(char **) RelinquishMagickMemory(arguments);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"reverse\",option+1) == 0)\n        {\n          ReverseImageList(&_images);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"smush\",option+1) == 0)\n        {\n          /* FUTURE: this option needs more work to make better */\n          ssize_t\n            offset;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          offset=(ssize_t) StringToLong(arg1);\n          new_images=SmushImages(_images,IsNormalOp,offset,_exception);\n          break;\n        }\n      if (LocaleCompare(\"subimage\",option+1) == 0)\n        {\n          Image\n            *base_image,\n            *compare_image;\n\n          const char\n            *value;\n\n          MetricType\n            metric;\n\n          double\n            similarity;\n\n          RectangleInfo\n            offset;\n\n          base_image=GetImageFromList(_images,0);\n          compare_image=GetImageFromList(_images,1);\n\n          /* Comparision Metric */\n          metric=UndefinedErrorMetric;\n          value=GetImageOption(_image_info,\"metric\");\n          if (value != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,value);\n\n          new_images=SimilarityImage(base_image,compare_image,metric,0.0,\n            &offset,&similarity,_exception);\n\n          if (new_images != (Image *) NULL)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%lf\",\n                similarity);\n              (void) SetImageProperty(new_images,\"subimage:similarity\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.x);\n              (void) SetImageProperty(new_images,\"subimage:x\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.y);\n              (void) SetImageProperty(new_images,\"subimage:y\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\n                \"%lux%lu%+ld%+ld\",(unsigned long) offset.width,(unsigned long)\n                offset.height,(long) offset.x,(long) offset.y);\n              (void) SetImageProperty(new_images,\"subimage:offset\",result,\n                _exception);\n            }\n          break;\n        }\n      if (LocaleCompare(\"swap\",option+1) == 0)\n        {\n        Image\n          *p,\n          *q,\n          *swap;\n\n        ssize_t\n          index,\n          swap_index;\n\n        index=(-1);\n        swap_index=(-2);\n        if (IfNormalOp) {\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          swap_index=(-1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=(ssize_t) geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            swap_index=(ssize_t) geometry_info.sigma;\n        }\n        p=GetImageFromList(_images,index);\n        q=GetImageFromList(_images,swap_index);\n        if ((p == (Image *) NULL) || (q == (Image *) NULL)) {\n          if (IfNormalOp)\n            CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1)\n          else\n            CLIWandExceptionBreak(OptionError,\"TwoOrMoreImagesRequired\",option);\n        }\n        if (p == q)\n          CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1);\n        swap=CloneImage(p,0,0,MagickTrue,_exception);\n        if (swap == (Image *) NULL)\n          CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n        ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,_exception));\n        ReplaceImageInList(&q,swap);\n        _images=GetFirstImageInList(q);\n        break;\n      }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* if new image list generated, replace existing image list */\n  if (new_images == (Image *) NULL)\n    return(status == 0 ? MagickFalse : MagickTrue);\n  _images=DestroyImageList(_images);\n  _images=GetFirstImageInList(new_images);\n  return(status == 0 ? MagickFalse : MagickTrue);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I N o I m a g e O p e r a t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLINoImageOperator() Applies operations that may not actually need images\n%  in an image list.\n%\n%  The classic operators of this type is \"-read\", which actually creates\n%  images even when no images are present.  Or image stack operators, which\n%  can be applied (push or pop) to an empty image list.\n%\n%  Note that these operators may involve other special 'option' prefix\n%  characters other  than '-' or '+', namely parenthesis and braces.\n%\n%  The format of the CLINoImageOption method is:\n%\n%      void CLINoImageOption(MagickCLI *cli_wand,const char *option,\n%           const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use. (sometimes not required)\n%\n%    o option: The special option (with any switch char) to process\n%\n%    o arg1 & arg2: Argument for option, if required\n%                   Currently arg2 is not used.\n%\n*/\nWandPrivate void CLINoImageOperator(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n      \"- NoImage Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n      arg1n != (char *) NULL ? arg1n : \"\",\n      arg2n != (char *) NULL ? arg2n : \"\");\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  do {  /* break to exit code */\n    /*\n      No-op options  (ignore these)\n    */\n    if (LocaleCompare(\"noop\",option+1) == 0)   /* zero argument */\n      break;\n    if (LocaleCompare(\"sans\",option+1) == 0)   /* one argument */\n      break;\n    if (LocaleCompare(\"sans0\",option+1) == 0)  /* zero argument */\n      break;\n    if (LocaleCompare(\"sans1\",option+1) == 0)  /* one argument */\n      break;\n    if (LocaleCompare(\"sans2\",option+1) == 0)  /* two arguments */\n      break;\n    /*\n      Image Reading\n    */\n    if ( ( LocaleCompare(\"read\",option+1) == 0 ) ||\n      ( LocaleCompare(\"--\",option) == 0 ) ) {\n      /* Do Glob filename Expansion for 'arg1' then read all images.\n      *\n      * Expansion handles '@', '~', '*', and '?' meta-characters while ignoring\n      * (but attaching to the filenames in the generated argument list) any\n      * [...] read modifiers that may be present.\n      *\n      * For example: It will expand '*.gif[20x20]' into a list such as\n      * 'abc.gif[20x20]',  'foobar.gif[20x20]',  'xyzzy.gif[20x20]'\n      *\n      * NOTE: In IMv6 this was done globally across all images. This\n      * meant you could include IM options in '@filename' lists, but you\n      * could not include comments.   Doing it only for image read makes\n      * it far more secure.\n      *\n      * Note: arguments do not have percent escapes expanded for security\n      * reasons.\n      */\n      int      argc;\n      char     **argv;\n      ssize_t  i;\n\n      argc = 1;\n      argv = (char **) &arg1;\n\n      /* Expand 'glob' expressions in the given filename.\n        Expansion handles any 'coder:' prefix, or read modifiers attached\n        to the filename, including them in the resulting expanded list.\n      */\n      if (ExpandFilenames(&argc,&argv) == MagickFalse)\n        CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n\n      /* loop over expanded filename list, and read then all in */\n      for (i=0; i < (ssize_t) argc; i++) {\n        Image *\n          new_images;\n        if (_image_info->ping != MagickFalse)\n          new_images=PingImages(_image_info,argv[i],_exception);\n        else\n          new_images=ReadImages(_image_info,argv[i],_exception);\n        AppendImageToList(&_images, new_images);\n        argv[i]=DestroyString(argv[i]);\n      }\n      argv=(char **) RelinquishMagickMemory(argv);\n      break;\n    }\n    /*\n      Image Writing\n      Note: Writing a empty image list is valid in specific cases\n    */\n    if (LocaleCompare(\"write\",option+1) == 0) {\n      /* Note: arguments do not have percent escapes expanded */\n      char\n        key[MagickPathExtent];\n\n      Image\n        *write_images;\n\n      ImageInfo\n        *write_info;\n\n      /* Need images, unless a \"null:\" output coder is used */\n      if ( _images == (Image *) NULL ) {\n        if ( LocaleCompare(arg1,\"null:\") == 0 )\n          break;\n        CLIWandExceptArgBreak(OptionError,\"NoImagesForWrite\",option,arg1);\n      }\n\n      (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",arg1);\n      (void) DeleteImageRegistry(key);\n      write_images=_images;\n      if (IfPlusOp)\n        write_images=CloneImageList(_images,_exception);\n      write_info=CloneImageInfo(_image_info);\n      (void) WriteImages(write_info,write_images,arg1,_exception);\n      write_info=DestroyImageInfo(write_info);\n      if (IfPlusOp)\n        write_images=DestroyImageList(write_images);\n      break;\n    }\n    /*\n      Parenthesis and Brace operations\n    */\n    if (LocaleCompare(\"(\",option) == 0) {\n      /* stack 'push' images */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_list_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"ParenthesisNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n      node->data = (void *)cli_wand->wand.images;\n      node->next = cli_wand->image_list_stack;\n      cli_wand->image_list_stack = node;\n      cli_wand->wand.images = NewImageList();\n\n      /* handle respect-parenthesis */\n      if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,\n                    \"respect-parenthesis\")) != MagickFalse)\n        option=\"{\"; /* fall-thru so as to push image settings too */\n      else\n        break;\n      /* fall thru to operation */\n    }\n    if (LocaleCompare(\"{\",option) == 0) {\n      /* stack 'push' of image_info settings */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_info_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"CurlyBracesNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n\n      node->data = (void *)cli_wand->wand.image_info;\n      node->next = cli_wand->image_info_stack;\n\n      cli_wand->image_info_stack = node;\n      cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);\n      if (cli_wand->wand.image_info == (ImageInfo *) NULL) {\n        CLIWandException(ResourceLimitFatalError,\"MemoryAllocationFailed\",\n            option);\n        cli_wand->wand.image_info = (ImageInfo *)node->data;\n        node = (Stack *)RelinquishMagickMemory(node);\n        break;\n      }\n\n      break;\n    }\n    if (LocaleCompare(\")\",option) == 0) {\n      /* pop images from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_list_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedParenthesis\",option);\n      cli_wand->image_list_stack = node->next;\n\n      AppendImageToList((Image **)&node->data,cli_wand->wand.images);\n      cli_wand->wand.images= (Image *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      /* handle respect-parenthesis - of the previous 'pushed' settings */\n      node = cli_wand->image_info_stack;\n      if ( node != (Stack *) NULL)\n        {\n          if (IsStringTrue(GetImageOption(\n                cli_wand->wand.image_info,\"respect-parenthesis\")) != MagickFalse)\n            option=\"}\"; /* fall-thru so as to pop image settings too */\n          else\n            break;\n        }\n      else\n        break;\n      /* fall thru to next if */\n    }\n    if (LocaleCompare(\"}\",option) == 0) {\n      /* pop image_info settings from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_info_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedCurlyBraces\",option);\n      cli_wand->image_info_stack = node->next;\n\n      (void) DestroyImageInfo(cli_wand->wand.image_info);\n      cli_wand->wand.image_info = (ImageInfo *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);\n      cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);\n      cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);\n\n      break;\n    }\n      if (LocaleCompare(\"print\",option+1) == 0)\n        {\n          (void) FormatLocaleFile(stdout,\"%s\",arg1);\n          break;\n        }\n    if (LocaleCompare(\"set\",option+1) == 0)\n      {\n        /* Settings are applied to each image in memory in turn (if any).\n           While a option: only need to be applied once globally.\n\n           NOTE: rguments have not been automatically percent expaneded\n        */\n\n        /* escape the 'key' once only, using first image. */\n        arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n        if (arg1 == (char *) NULL)\n          CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                option);\n\n        if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n          {\n            if (IfPlusOp)\n              {\n                (void) DeleteImageRegistry(arg1+9);\n                arg1=DestroyString((char *)arg1);\n                break;\n              }\n            arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n            if (arg2 == (char *) NULL) {\n              arg1=DestroyString((char *)arg1);\n              CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                    option);\n            }\n            (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        if (LocaleNCompare(arg1,\"option:\",7) == 0)\n          {\n            /* delete equivelent artifact from all images (if any) */\n            if (_images != (Image *) NULL)\n              {\n                MagickResetIterator(&cli_wand->wand);\n                while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n                  (void) DeleteImageArtifact(_images,arg1+7);\n                MagickResetIterator(&cli_wand->wand);\n              }\n            /* now set/delete the global option as needed */\n            /* FUTURE: make escapes in a global 'option:' delayed */\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            (void) SetImageOption(_image_info,arg1+7,arg2);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        /* Set Artifacts/Properties/Attributes all images (required) */\n        if ( _images == (Image *) NULL )\n          CLIWandExceptArgBreak(OptionWarning,\"NoImageForProperty\",option,arg1);\n\n        MagickResetIterator(&cli_wand->wand);\n        while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n          {\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            if (LocaleNCompare(arg1,\"artifact:\",9) == 0)\n              (void) SetImageArtifact(_images,arg1+9,arg2);\n            else if (LocaleNCompare(arg1,\"property:\",9) == 0)\n              (void) SetImageProperty(_images,arg1+9,arg2,_exception);\n            else\n              (void) SetImageProperty(_images,arg1,arg2,_exception);\n            arg2=DestroyString((char *)arg2);\n          }\n        MagickResetIterator(&cli_wand->wand);\n        arg1=DestroyString((char *)arg1);\n        break;\n     }\n    if (LocaleCompare(\"clone\",option+1) == 0) {\n        Image\n          *new_images;\n\n        if (*option == '+')\n          arg1=AcquireString(\"-1\");\n        if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)\n          CLIWandExceptionBreak(OptionError,\"InvalidArgument\",option);\n        if ( cli_wand->image_list_stack == (Stack *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images = (Image *)cli_wand->image_list_stack->data;\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images=CloneImages(new_images,arg1,_exception);\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"NoSuchImage\",option);\n        AppendImageToList(&_images,new_images);\n        break;\n      }\n    /*\n       Informational Operations.\n\n       Note that these do not require either a cli-wand or images!\n       Though currently a cli-wand much be provided regardless.\n    */\n    if (LocaleCompare(\"version\",option+1) == 0)\n      {\n        ListMagickVersion(stdout);\n        break;\n      }\n    if (LocaleCompare(\"list\",option+1) == 0) {\n      /*\n         FUTURE: This 'switch' should really be part of MagickCore\n      */\n      ssize_t\n        list;\n\n      list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);\n      if ( list < 0 ) {\n        CLIWandExceptionArg(OptionError,\"UnrecognizedListType\",option,arg1);\n        break;\n      }\n      switch (list)\n      {\n        case MagickCoderOptions:\n        {\n          (void) ListCoderInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickColorOptions:\n        {\n          (void) ListColorInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickConfigureOptions:\n        {\n          (void) ListConfigureInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickDelegateOptions:\n        {\n          (void) ListDelegateInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFontOptions:\n        {\n          (void) ListTypeInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFormatOptions:\n          (void) ListMagickInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLocaleOptions:\n          (void) ListLocaleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLogOptions:\n          (void) ListLogInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMagicOptions:\n          (void) ListMagicInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMimeOptions:\n          (void) ListMimeInfo((FILE *) NULL,_exception);\n          break;\n        case MagickModuleOptions:\n          (void) ListModuleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickPolicyOptions:\n          (void) ListPolicyInfo((FILE *) NULL,_exception);\n          break;\n        case MagickResourceOptions:\n          (void) ListMagickResourceInfo((FILE *) NULL,_exception);\n          break;\n        case MagickThresholdOptions:\n          (void) ListThresholdMaps((FILE *) NULL,_exception);\n          break;\n        default:\n          (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n            _exception);\n          break;\n      }\n      break;\n    }\n\n    CLIWandException(OptionError,\"UnrecognizedOption\",option);\n\nDisableMSCWarning(4127)\n  } while (0);  /* break to exit code. */\nRestoreMSCWarning\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I O p t i o n                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIOption() Processes the given option using the given CLI Magick Wand.\n%  The option arguments can be variable in number, though at this time no more\n%  that two is actually used by any option (this may change). Excess options\n%  are simply ignored.\n%\n%  If the cli_wand->command pointer is non-null, then it is assumed that the\n%  option has already been search for up from the CommandOptions[] table in\n%  \"MagickCore/options.c\" using  GetCommandOptionInfo().  If not set this\n%  routine will do the lookup instead. The pointer is reset afterward.\n%\n%  This action allows the caller to lookup and pre-handle any 'special'\n%  options, (such as implicit reads) before calling this general option\n%  handler to deal with 'standard' command line options.\n%\n%  The format of the CLIOption method is:\n%\n%       void CLIOption(MagickCLI *cli_wand,const char *option, ...)\n%\n%  A description of each parameter follows:\n%\n%     o cli_wand: the main CLI Wand to use.\n%\n%     o option: The special option (with any switch char) to process\n%\n%     o args: any required arguments for an option (variable number)\n%\n%  Example Usage...\n%\n%    CLIoption(cli_wand,\"-read\",\"rose:\");\n%    CLIoption(cli_wand,\"-virtual-pixel\",\"transparent\");\n%    CLIoption(cli_wand,\"-distort\",\"SRT:\",\"30\");\n%    CLIoption(cli_wand,\"-write\",\"rotated_rose.png\");\n%\n*/\nWandExport void CLIOption(MagickCLI *cli_wand,const char *option,...)\n{\n  const char    /* extracted option args from args */\n    *arg1,\n    *arg2;\n\n  CommandOptionFlags\n    option_type;\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  do { /* Break Code Block for error handling */\n\n    /* get information about option */\n    if ( cli_wand->command == (const OptionInfo *) NULL )\n      cli_wand->command = GetCommandOptionInfo(option);\n#if 0\n      (void) FormatLocaleFile(stderr, \"CLIOption \\\"%s\\\" matched \\\"%s\\\"\\n\",\n            option, cli_wand->command->mnemonic );\n#endif\n    option_type=(CommandOptionFlags) cli_wand->command->flags;\n\n    if ( option_type == UndefinedOptionFlag )\n      CLIWandExceptionReturn(OptionFatalError,\"UnrecognizedOption\",option);\n\n    assert( LocaleCompare(cli_wand->command->mnemonic,option) == 0 );\n\n    /* deprecated options */\n    if ( (option_type & DeprecateOptionFlag) != 0 )\n      CLIWandExceptionBreak(OptionError,\"DeprecatedOptionNoCode\",option);\n\n    /* options that this module does not handle */\n    if ((option_type & (SpecialOptionFlag|GenesisOptionFlag)) != 0 )\n      CLIWandExceptionBreak(OptionFatalError,\"InvalidUseOfOption\",option);\n\n    /* Get argument strings from VarArgs\n      How can you determine if enough arguments was supplied?\n      What happens if not enough arguments were supplied?\n    */\n    { size_t\n        count = (size_t) cli_wand->command->type;\n\n      va_list\n        operands;\n\n      va_start(operands,option);\n\n      arg1=arg2=NULL;\n      if ( count >= 1 )\n        arg1=(const char *) va_arg(operands, const char *);\n      if ( count >= 2 )\n        arg2=(const char *) va_arg(operands, const char *);\n\n      va_end(operands);\n#if 0\n      (void) FormatLocaleFile(stderr,\n        \"CLIOption: \\\"%s\\\"  Count: %ld  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            option,(long) count,option_type,arg1,arg2);\n#endif\n    }\n\n    /*\n      Call the appropriate option handler\n    */\n\n    /* FUTURE: this is temporary - get 'settings' to handle distribution of\n      settings to images attributes,proprieties,artifacts */\n    if ( cli_wand->wand.images != (Image *) NULL )\n      (void) SyncImagesSettings(cli_wand->wand.image_info,cli_wand->wand.images,\n        cli_wand->wand.exception);\n\n    if ( (option_type & SettingOptionFlags) != 0 ) {\n      CLISettingOptionInfo(cli_wand, option, arg1, arg2);\n      /*\n        FUTURE: Sync Specific Settings into Image Properities (not global)\n      */\n    }\n\n    /* Operators that do not need images - read, write, stack, clone */\n    if ((option_type & NoImageOperatorFlag) != 0)\n      CLINoImageOperator(cli_wand, option, arg1, arg2);\n\n    /* FUTURE: The not a setting part below is a temporary hack due to\n    * some options being both a Setting and a Simple operator.\n    * Specifically -monitor, -depth, and  -colorspace */\n    if ( cli_wand->wand.images == (Image *) NULL )\n      if ( ((option_type & (SimpleOperatorFlag|ListOperatorFlag)) != 0 ) &&\n          ((option_type & SettingOptionFlags) == 0 ))  /* temp hack */\n        CLIWandExceptionBreak(OptionError,\"NoImagesFound\",option);\n\n    /* Operators which loop of individual images, simply */\n    if ( (option_type & SimpleOperatorFlag) != 0 &&\n         cli_wand->wand.images != (Image *) NULL) /* temp hack */\n      {\n        ExceptionInfo *exception=AcquireExceptionInfo();\n        (void) CLISimpleOperatorImages(cli_wand, option, arg1, arg2,exception);\n        exception=DestroyExceptionInfo(exception);\n      }\n\n    /* Operators that work on the image list as a whole */\n    if ( (option_type & ListOperatorFlag) != 0 )\n      (void) CLIListOperatorImages(cli_wand, option, arg1, arg2);\n\nDisableMSCWarning(4127)\n  } while (0);  /* end Break code block */\nRestoreMSCWarning\n\n  cli_wand->command = (const OptionInfo *) NULL; /* prevent re-use later */\n}\n"], "buggy_code_start_loc": [7918, 4181], "buggy_code_end_loc": [8305, 4182], "fixing_code_start_loc": [7919, 4181], "fixing_code_end_loc": [8309, 4185], "type": "CWE-401", "message": "ImageMagick 7.0.8-50 Q16 has memory leaks at AcquireMagickMemory because of mishandling the NoSuchImage error in CLIListOperatorImages in MagickWand/operation.c.", "other": {"cve": {"id": "CVE-2019-13309", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.813", "lastModified": "2023-02-23T15:04:25.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has memory leaks at AcquireMagickMemory because of mishandling the NoSuchImage error in CLIListOperatorImages in MagickWand/operation.c."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 tiene fugas de memoria en AcquireMagickMemory debido a la mala gesti\u00f3n del error NoSuchImage en CLIListOperatorImages en MagickWand/operation.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/5f21230b657ccd65452dd3d94c5b5401ba691a2d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1616", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/5982632109cad48bc6dab867298fdea4dea57c51", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/5f21230b657ccd65452dd3d94c5b5401ba691a2d"}}