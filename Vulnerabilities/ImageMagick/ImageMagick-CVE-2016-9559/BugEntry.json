{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%            PPPP    RRRR    OOO   PPPP   EEEEE  RRRR   TTTTT  Y   Y          %\n%            P   P   R   R  O   O  P   P  E      R   R    T     Y Y           %\n%            PPPP    RRRR   O   O  PPPP   EEE    RRRR     T      Y            %\n%            P       R R    O   O  P      E      R R      T      Y            %\n%            P       R  R    OOO   P      EEEEE  R  R     T      Y            %\n%                                                                             %\n%                                                                             %\n%                         MagickCore Property Methods                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compare.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS2_LCMS2_H)\n#include <lcms2/lcms2.h>\n#elif defined(MAGICKCORE_HAVE_LCMS2_H)\n#include \"lcms2.h\"\n#elif defined(MAGICKCORE_HAVE_LCMS_LCMS_H)\n#include <lcms/lcms.h>\n#else\n#include \"lcms.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o p e r t i e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProperties() clones all the image properties to another image.\n%\n%  The format of the CloneImageProperties method is:\n%\n%      MagickBooleanType CloneImageProperties(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProperties(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      clone_image->filename);\n  (void) CopyMagickString(image->filename,clone_image->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,clone_image->magick_filename,\n    MagickPathExtent);\n  image->compression=clone_image->compression;\n  image->quality=clone_image->quality;\n  image->depth=clone_image->depth;\n  image->alpha_color=clone_image->alpha_color;\n  image->background_color=clone_image->background_color;\n  image->border_color=clone_image->border_color;\n  image->transparent_color=clone_image->transparent_color;\n  image->gamma=clone_image->gamma;\n  image->chromaticity=clone_image->chromaticity;\n  image->rendering_intent=clone_image->rendering_intent;\n  image->black_point_compensation=clone_image->black_point_compensation;\n  image->units=clone_image->units;\n  image->montage=(char *) NULL;\n  image->directory=(char *) NULL;\n  (void) CloneString(&image->geometry,clone_image->geometry);\n  image->offset=clone_image->offset;\n  image->resolution.x=clone_image->resolution.x;\n  image->resolution.y=clone_image->resolution.y;\n  image->page=clone_image->page;\n  image->tile_offset=clone_image->tile_offset;\n  image->extract_info=clone_image->extract_info;\n  image->filter=clone_image->filter;\n  image->fuzz=clone_image->fuzz;\n  image->intensity=clone_image->intensity;\n  image->interlace=clone_image->interlace;\n  image->interpolate=clone_image->interpolate;\n  image->endian=clone_image->endian;\n  image->gravity=clone_image->gravity;\n  image->compose=clone_image->compose;\n  image->orientation=clone_image->orientation;\n  image->scene=clone_image->scene;\n  image->dispose=clone_image->dispose;\n  image->delay=clone_image->delay;\n  image->ticks_per_second=clone_image->ticks_per_second;\n  image->iterations=clone_image->iterations;\n  image->total_colors=clone_image->total_colors;\n  image->taint=clone_image->taint;\n  image->progress_monitor=clone_image->progress_monitor;\n  image->client_data=clone_image->client_data;\n  image->start_loop=clone_image->start_loop;\n  image->error=clone_image->error;\n  image->signature=clone_image->signature;\n  if (clone_image->properties != (void *) NULL)\n    {\n      if (image->properties != (void *) NULL)\n        DestroyImageProperties(image);\n      image->properties=CloneSplayTree((SplayTreeInfo *)\n        clone_image->properties,(void *(*)(void *)) ConstantString,\n        (void *(*)(void *)) ConstantString);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e f i n e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageProperty() associates an assignment string of the form\n%  \"key=value\" with an artifact or options. It is equivelent to\n%  SetImageProperty()\n%\n%  The format of the DefineImageProperty method is:\n%\n%      MagickBooleanType DefineImageProperty(Image *image,const char *property,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DefineImageProperty(Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n\n  register char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(property != (const char *) NULL);\n  (void) CopyMagickString(key,property,MagickPathExtent-1);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageProperty(image,key,value,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProperty() deletes an image property.\n%\n%  The format of the DeleteImageProperty method is:\n%\n%      MagickBooleanType DeleteImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProperty(Image *image,\n  const char *property)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return(MagickFalse);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->properties,property));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o p e r t i e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProperties() destroys all properties and associated memory\n%  attached to the given image.\n%\n%  The format of the DestroyDefines method is:\n%\n%      void DestroyImageProperties(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t I m a g e P r o p e r t y                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatImageProperty() permits formatted property/value pairs to be saved as\n%  an image property.\n%\n%  The format of the FormatImageProperty method is:\n%\n%      MagickBooleanType FormatImageProperty(Image *image,const char *property,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o  image:  The image.\n%\n%   o  property:  The attribute property.\n%\n%   o  format:  A string describing the format to use to write the remaining\n%      arguments.\n%\n*/\nMagickExport MagickBooleanType FormatImageProperty(Image *image,\n  const char *property,const char *format,...)\n{\n  char\n    value[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(value,MagickPathExtent,format,operands);\n  (void) n;\n  va_end(operands);\n  exception=AcquireExceptionInfo();\n  status=SetImageProperty(image,property,value,exception);\n  exception=DestroyExceptionInfo(exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProperty() gets a value associated with an image property.\n%\n%  This includes,  profile prefixes, such as \"exif:\", \"iptc:\" and \"8bim:\"\n%  It does not handle non-prifile prefixes, such as \"fx:\", \"option:\", or\n%  \"artifact:\".\n%\n%  The returned string is stored as a properity of the same name for faster\n%  lookup later. It should NOT be freed by the caller.\n%\n%  The format of the GetImageProperty method is:\n%\n%      const char *GetImageProperty(const Image *image,const char *key,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char\n  *TracePSClippath(const unsigned char *,size_t),\n  *TraceSVGClippath(const unsigned char *,size_t,const size_t,\n    const size_t);\n\nstatic MagickBooleanType GetIPTCProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    *message;\n\n  const StringInfo\n    *profile;\n\n  long\n    count,\n    dataset,\n    record;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=sscanf(key,\"IPTC:%ld:%ld\",&dataset,&record);\n  if (count != 2)\n    return(MagickFalse);\n  attribute=(char *) NULL;\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)\n  {\n    length=1;\n    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)\n      continue;\n    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);\n    length|=GetStringInfoDatum(profile)[i+4];\n    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&\n        ((long) GetStringInfoDatum(profile)[i+2] == record))\n      {\n        message=(char *) NULL;\n        if (~length >= 1)\n          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));\n        if (message != (char *) NULL)\n          {\n            (void) CopyMagickString(message,(char *) GetStringInfoDatum(\n              profile)+i+5,length+1);\n            (void) ConcatenateString(&attribute,message);\n            (void) ConcatenateString(&attribute,\";\");\n            message=DestroyString(message);\n          }\n      }\n    i+=5;\n  }\n  if ((attribute == (char *) NULL) || (*attribute == ';'))\n    {\n      if (attribute != (char *) NULL)\n        attribute=DestroyString(attribute);\n      return(MagickFalse);\n    }\n  attribute[strlen(attribute)-1]='\\0';\n  (void) SetImageProperty((Image *) image,key,(const char *) attribute,\n    exception);\n  attribute=DestroyString(attribute);\n  return(MagickTrue);\n}\n\nstatic inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed int ReadPropertyMSBLong(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[4];\n\n  unsigned int\n    value;\n\n  if (*length < 4)\n    return(-1);\n  for (i=0; i < 4; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed short ReadPropertyMSBShort(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[2];\n\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return((unsigned short) ~0);\n  for (i=0; i < 2; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((count < 0) || ((size_t) count > length))\n      {\n        length=0; \n        continue;\n      }\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}\n\nstatic inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned int ReadPropertyUnsignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      return(value & 0xffffffff);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  return(value & 0xffffffff);\n}\n\nstatic inline signed short ReadPropertySignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned short ReadPropertyUnsignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      return(value & 0xffff);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  return(value & 0xffff);\n}\n\nstatic MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      *description;\n  } TagInfo;\n\n  static TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" },\n      {  0x8827, \"exif:ISOSpeedRatings\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },\n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:ExifImageWidth\" },\n      {  0xa003, \"exif:ExifImageLength\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x00000, (const char *) NULL }\n    };\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((offset < 0) || (size_t) offset >= length)\n            continue;\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MagickPathExtent],\n            *value;\n\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(unsigned char *) p1));\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n              break;\n            }\n            default:\n            case EXIF_FMT_STRING:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  register ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              register const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  register ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MagickPathExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MagickPathExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MagickPathExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MagickPathExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value,exception);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}\n\nstatic MagickBooleanType GetICCProperty(const Image *image,const char *property,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  magick_unreferenced(property);\n\n  profile=GetImageProfile(image,\"icc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"icm\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 128)\n    return(MagickFalse);  /* minimum ICC profile length */\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n  {\n    cmsHPROFILE\n      icc_profile;\n\n    icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n      (cmsUInt32Number) GetStringInfoLength(profile));\n    if (icc_profile != (cmsHPROFILE *) NULL)\n      {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n        const char\n          *name;\n\n        name=cmsTakeProductName(icc_profile);\n        if (name != (const char *) NULL)\n          (void) SetImageProperty((Image *) image,\"icc:name\",name,exception);\n#else\n        char\n          info[MagickPathExtent];\n\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:description\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:manufacturer\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\"US\",info,\n          MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:model\",info,exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:copyright\",info,exception);\n#endif\n        (void) cmsCloseProfile(icc_profile);\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n  {\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n              ConstantString(GetXMLTreeTag(node)),ConstantString(content));\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                ConstantString(GetXMLTreeTag(child)),ConstantString(content));\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n        }\n        description=GetNextXMLTreeTag(description);\n      }\n    }\n  xmp=DestroyXMLTree(xmp);\n  return(status);\n}\n\nstatic char *TracePSClippath(const unsigned char *blob,size_t length)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    knot_count,\n    selector,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,\"/ClipImage\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"{\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /c {curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /l {lineto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /m {moveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /v {currentpoint 6 2 roll curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /y {2 copy curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /z {closepath} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  newpath\\n\");\n  (void) ConcatenateString(&path,message);\n  /*\n    The clipping path format is defined in \"Adobe Photoshop File Formats\n    Specification\" version 6.0 downloadable from adobe.com.\n  */\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length > 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          size_t\n            xx,\n            yy;\n\n          yy=(size_t) ReadPropertyMSBLong(&blob,&length);\n          xx=(size_t) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x/4096/4096;\n          point[i].y=1.0-(double) y/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"  %g %g m\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l\\n\",point[1].x,point[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v\\n\",point[0].x,point[0].y,\n                  point[1].x,point[1].y);\n              else\n                if ((point[0].x == point[1].x) && (point[0].y == point[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y\\n\",last[2].x,last[2].y,\n                    point[1].x,point[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c\\n\",last[2].x,\n                    last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n            /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l z\\n\",first[1].x,first[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v z\\n\",first[0].x,first[0].y,\n                  first[1].x,first[1].y);\n              else\n                if ((first[0].x == first[1].x) && (first[0].y == first[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y z\\n\",last[2].x,last[2].y,\n                    first[1].x,first[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c z\\n\",last[2].x,\n                    last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Returns an empty PS path if the path has no knots.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"  eoclip\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"} bind def\");\n  (void) ConcatenateString(&path,message);\n  message=DestroyString(message);\n  return(path);\n}\n\nstatic char *TraceSVGClippath(const unsigned char *blob,size_t length,\n  const size_t columns,const size_t rows)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector,\n    x,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,(\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\\n\"\n    \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"\n    \" width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\"\n    \"<g>\\n\"\n    \"<path fill-rule=\\\"evenodd\\\" style=\\\"fill:#00000000;stroke:#00000000;\"\n    \"stroke-width:0;stroke-antialiasing:false\\\" d=\\\"\\n\"),(double) columns,\n    (double) rows);\n  (void) ConcatenateString(&path,message);\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          unsigned int\n            xx,\n            yy;\n\n          yy=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          xx=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x*columns/4096/4096;\n          point[i].y=(double) y*rows/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"M %g %g\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g\\n\",point[1].x,point[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g\\n\",last[2].x,\n                last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n           /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g Z\\n\",first[1].x,first[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g Z\\n\",last[2].x,\n                last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Return an empty SVG image if the path does not have knots.\n  */\n  (void) ConcatenateString(&path,\"\\\"/>\\n</g>\\n</svg>\\n\");\n  message=DestroyString(message);\n  return(path);\n}\n\nMagickExport const char *GetImageProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  register const char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  p=(const char *) NULL;\n  if (image->properties != (void *) NULL)\n    {\n      if (property == (const char *) NULL)\n        {\n          ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n          p=(const char *) GetNextValueInSplayTree((SplayTreeInfo *)\n            image->properties);\n          return(p);\n        }\n        p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n          image->properties,property);\n        if (p != (const char *) NULL)\n          return(p);\n    }\n  if ((property == (const char *) NULL) ||\n      (strchr(property,':') == (char *) NULL))\n    return(p);\n  switch (*property)\n  {\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) Get8BIMProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) GetEXIFProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleNCompare(\"icc:\",property,4) == 0) ||\n          (LocaleNCompare(\"icm:\",property,4) == 0))\n        {\n          (void) GetICCProperty(image,property,exception);\n          break;\n        }\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) GetIPTCProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) GetXMPProperty(image,property);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (image->properties != (void *) NULL)\n    {\n      p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n        image->properties,property);\n      return(p);\n    }\n  return((const char *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t M a g i c k P r o p e r t y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickProperty() gets attributes or calculated values that is associated\n%  with a fixed known property name, or single letter property. It may be\n%  called if no image is defined (IMv7), in which case only global image_info\n%  values are available:\n%\n%    \\n   newline\n%    \\r   carriage return\n%    <    less-than character.\n%    >    greater-than character.\n%    &    ampersand character.\n%    %%   a percent sign\n%    %b   file size of image read in\n%    %c   comment meta-data property\n%    %d   directory component of path\n%    %e   filename extension or suffix\n%    %f   filename (including suffix)\n%    %g   layer canvas page geometry   (equivalent to \"%Wx%H%X%Y\")\n%    %h   current image height in pixels\n%    %i   image filename (note: becomes output filename for \"info:\")\n%    %k   CALCULATED: number of unique colors\n%    %l   label meta-data property\n%    %m   image file format (file magic)\n%    %n   number of images in current image sequence\n%    %o   output filename  (used for delegates)\n%    %p   index of image in current image list\n%    %q   quantum depth (compile-time constant)\n%    %r   image class and colorspace\n%    %s   scene number (from input unless re-assigned)\n%    %t   filename without directory or extension (suffix)\n%    %u   unique temporary filename (used for delegates)\n%    %w   current width in pixels\n%    %x   x resolution (density)\n%    %y   y resolution (density)\n%    %z   image depth (as read in unless modified, image save depth)\n%    %A   image transparency channel enabled (true/false)\n%    %C   image compression type\n%    %D   image GIF dispose method\n%    %G   original image size (%wx%h; before any resizes)\n%    %H   page (canvas) height\n%    %M   Magick filename (original file exactly as given,  including read mods)\n%    %O   page (canvas) offset ( = %X%Y )\n%    %P   page (canvas) size ( = %Wx%H )\n%    %Q   image compression quality ( 0 = default )\n%    %S   ?? scenes ??\n%    %T   image time delay (in centi-seconds)\n%    %U   image resolution units\n%    %W   page (canvas) width\n%    %X   page (canvas) x offset (including sign)\n%    %Y   page (canvas) y offset (including sign)\n%    %Z   unique filename (used for delegates)\n%    %@   CALCULATED: trim bounding box (without actually trimming)\n%    %#   CALCULATED: 'signature' hash of image values\n%\n%  This routine only handles specifically known properties.  It does not\n%  handle special prefixed properties, profiles, or expressions. Nor does\n%  it return any free-form property strings.\n%\n%  The returned string is stored in a structure somewhere, and should not be\n%  directly freed.  If the string was generated (common) the string will be\n%  stored as as either as artifact or option 'get-property'.  These may be\n%  deleted (cleaned up) when no longer required, but neither artifact or\n%  option is guranteed to exist.\n%\n%  The format of the GetMagickProperty method is:\n%\n%      const char *GetMagickProperty(ImageInfo *image_info,Image *image,\n%        const char *property,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info (optional)\n%\n%    o image: the image (optional)\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const char *GetMagickPropertyLetter(ImageInfo *image_info,\n  Image *image,const char letter,ExceptionInfo *exception)\n{\n#define WarnNoImageReturn(format,arg) \\\n  if (image == (Image *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n  char\n    value[MagickPathExtent];  /* formatted string to store as an artifact */\n\n  const char\n    *string;     /* return a string already stored somewher */\n\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formatted string */\n  string=(char *) NULL;  /* constant string reference */\n  /*\n    Get properities that are directly defined by images.\n  */\n  switch (letter)\n  {\n    case 'b':  /* image size read in - in bytes */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatMagickSize(image->extent,MagickFalse,\"B\",MagickPathExtent,\n        value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n          MagickPathExtent,value);\n      break;\n    }\n    case 'c':  /* image comment property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"comment\",exception);\n      if ( string == (const char *) NULL )\n        string=\"\";\n      break;\n    }\n    case 'd':  /* Directory component of filename */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'e': /* Filename extension (suffix) of image file */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'f': /* Filename without directory component */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'g': /* Image geometry, canvas and offset  %Wx%H+%X+%Y */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n        image->page.height,(double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h': /* Image height (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i': /* Filename last used for an image (read or write) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->filename;\n      break;\n    }\n    case 'k': /* Number of unique colors  */\n    {\n      /*\n        FUTURE: ensure this does not generate the formatted comment!\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,exception));\n      break;\n    }\n    case 'l': /* Image label property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"label\",exception);\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm': /* Image format (file magick) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick;\n      break;\n    }\n    case 'n': /* Number of images in the list.  */\n    {\n      if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          GetImageListLength(image));\n      else\n        string=\"0\";    /* no images or scenes */\n      break;\n    }\n    case 'o': /* Output Filename - for delegate use only */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->filename;\n      break;\n    case 'p': /* Image index in current image list */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q': /* Quantum depth of image in memory */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r': /* Image storage class, colorspace, and alpha enabled.  */\n    {\n      ColorspaceType\n        colorspace;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      colorspace=image->colorspace;\n      if (SetImageGray(image,exception) != MagickFalse)\n        colorspace=GRAYColorspace;   /* FUTURE: this is IMv6 not IMv7 */\n      (void) FormatLocaleString(value,MagickPathExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?\n        \"Alpha\" : \"\");\n      break;\n    }\n    case 's': /* Image scene number */\n    {\n#if 0  /* this seems non-sensical -- simplifing */\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image_info->scene);\n      else if (image != (Image *) NULL)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image->scene);\n      else\n          string=\"0\";\n#else\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n         image->scene);\n#endif\n      break;\n    }\n    case 't': /* Base filename without directory or extention */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,BasePath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'u': /* Unique filename */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->unique;\n      break;\n    }\n    case 'w': /* Image width (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x': /* Image horizontal resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);\n      break;\n    }\n    case 'y': /* Image vertical resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);\n      break;\n    }\n    case 'z': /* Image depth as read in */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->depth);\n      break;\n    }\n    case 'A': /* Image alpha channel  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n        image->alpha_trait);\n      break;\n    }\n    case 'C': /* Image compression method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n        image->compression);\n      break;\n    }\n    case 'D': /* Image dispose method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t)\n        image->dispose);\n      break;\n    }\n    case 'G': /* Image size as geometry = \"%wx%h\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H': /* layer canvas height */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.height);\n      break;\n    }\n    case 'M': /* Magick filename - filename given incl. coder & read mods */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick_filename;\n      break;\n    }\n    case 'O': /* layer canvas offset with sign = \"+%X+%Y\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P': /* layer canvas page size = \"%Wx%H\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q': /* image compression quality */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S': /* Number of scenes in image list.  */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n#if 0 /* What is this number? -- it makes no sense - simplifing */\n      if (image_info->number_scenes == 0)\n         string=\"2147483647\";\n      else if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n                image_info->scene+image_info->number_scenes);\n      else\n        string=\"0\";\n#else\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image_info->number_scenes == 0 ? 2147483647 :\n         image_info->number_scenes));\n#endif\n      break;\n    }\n    case 'T': /* image time delay for animations */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U': /* Image resolution units. */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n        image->units);\n      break;\n    }\n    case 'W': /* layer canvas width */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X': /* layer canvas X offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y': /* layer canvas Y offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case '%': /* percent escaped */\n    {\n      string=\"%\";\n      break;\n    }\n    case '@': /* Trim bounding box, without actually Trimming! */\n    {\n      RectangleInfo\n        page;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      page=GetImageBoundingBox(image,exception);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) page.width,(double) page.height,\n        (double) page.x,(double)page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) SignatureImage(image,exception);\n      string=GetImageProperty(image,\"signature\",exception);\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n\nMagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image,exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual colorspace - no 'gray' stuff */\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)\n            image->compose);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n     break;\n    }\n    case 'p':\n    {\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n       break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result, that will get cleaned up, eventually.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n#undef WarnNoImageReturn\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o p e r t y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProperty() gets the next free-form string property name.\n%\n%  The format of the GetNextImageProperty method is:\n%\n%      char *GetNextImageProperty(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const char *GetNextImageProperty(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((const char *) NULL);\n  return((const char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->properties));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n t e r p r e t I m a g e P r o p e r t i e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageProperties() replaces any embedded formatting characters with\n%  the appropriate image property and returns the interpreted text.\n%\n%  This searches for and replaces\n%     \\n \\r \\%          replaced by newline, return, and percent resp.\n%     &lt; &gt; &amp;   replaced by '<', '>', '&' resp.\n%     %%                replaced by percent\n%\n%     %x %[x]       where 'x' is a single letter properity, case sensitive).\n%     %[type:name]  where 'type' a is special and known prefix.\n%     %[name]       where 'name' is a specifically known attribute, calculated\n%                   value, or a per-image property string name, or a per-image\n%                   'artifact' (as generated from a global option).\n%                   It may contain ':' as long as the prefix is not special.\n%\n%  Single letter % substitutions will only happen if the character before the\n%  percent is NOT a number. But braced substitutions will always be performed.\n%  This prevents the typical usage of percent in a interpreted geometry\n%  argument from being substituted when the percent is a geometry flag.\n%\n%  If 'glob-expresions' ('*' or '?' characters) is used for 'name' it may be\n%  used as a search pattern to print multiple lines of \"name=value\\n\" pairs of\n%  the associacted set of properties.\n%\n%  The returned string must be freed using DestoryString() by the caller.\n%\n%  The format of the InterpretImageProperties method is:\n%\n%      char *InterpretImageProperties(ImageInfo *image_info,\n%        Image *image,const char *embed_text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info. (required)\n%\n%    o image: the image. (optional)\n%\n%    o embed_text: the address of a character string containing the embedded\n%      formatting characters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport char *InterpretImageProperties(ImageInfo *image_info,Image *image,\n  const char *embed_text,ExceptionInfo *exception)\n{\n#define ExtendInterpretText(string_length) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=(string_length); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n   } \\\n} \\\nRestoreMSCWarning\n\n#define AppendKeyValue2Text(key,value)\\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen(key)+strlen(value)+2; \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n     } \\\n   q+=FormatLocaleString(q,extent,\"%s=%s\\n\",(key),(value)); \\\n} \\\nRestoreMSCWarning\n\n#define AppendString2Text(string) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen((string)); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n    } \\\n  (void) CopyMagickString(q,(string),extent); \\\n  q+=length; \\\n} \\\nRestoreMSCWarning\n\n  char\n    *interpret_text;\n\n  MagickBooleanType\n    number;\n\n  register char\n    *q;  /* current position in interpret_text */\n\n  register const char\n    *p;  /* position in embed_text string being expanded */\n\n  size_t\n    extent;  /* allocated length of interpret_text */\n\n  assert(image == NULL || image->signature == MagickCoreSignature);\n  assert(image_info == NULL || image_info->signature == MagickCoreSignature);\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-image\");\n  if (embed_text == (const char *) NULL)\n    return(ConstantString(\"\"));\n  p=embed_text;\n  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\\0'))\n    p++;\n  if (*p == '\\0')\n    return(ConstantString(\"\"));\n  if ((*p == '@') && (IsPathAccessible(p+1) != MagickFalse))\n    {\n      /*\n        Handle a '@' replace string from file.\n      */\n      if (IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,p) == MagickFalse)\n        {\n          errno=EPERM;\n          (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n            \"NotAuthorized\",\"`%s'\",p);\n          return(ConstantString(\"\"));\n        }\n      interpret_text=FileToString(p+1,~0UL,exception);\n      if (interpret_text != (char *) NULL)\n        return(interpret_text);\n    }\n  /*\n    Translate any embedded format characters.\n  */\n  interpret_text=AcquireString(embed_text); /* new string with extra space */\n  extent=MagickPathExtent;                     /* allocated space in string */\n  number=MagickFalse;                       /* is last char a number? */\n  for (q=interpret_text; *p!='\\0'; number=isdigit(*p) ? MagickTrue : MagickFalse,p++)\n  {\n    /*\n      Look for the various escapes, (and handle other specials)\n    */\n    *q='\\0';\n    ExtendInterpretText(MagickPathExtent);\n    switch (*p)\n    {\n      case '\\\\':\n      {\n        switch (*(p+1))\n        {\n          case '\\0':\n            continue;\n          case 'r':  /* convert to RETURN */\n          {\n            *q++='\\r';\n            p++;\n            continue;\n          }\n          case 'n':  /* convert to NEWLINE */\n          {\n            *q++='\\n';\n            p++;\n            continue;\n          }\n          case '\\n':  /* EOL removal UNIX,MacOSX */\n          {\n            p++;\n            continue;\n          }\n          case '\\r':  /* EOL removal DOS,Windows */\n          {\n            p++;\n            if (*p == '\\n') /* return-newline EOL */\n              p++;\n            continue;\n          }\n          default:\n          {\n            p++;\n            *q++=(*p);\n          }\n        }\n        continue;\n      }\n      case '&':\n      {\n        if (LocaleNCompare(\"&lt;\",p,4) == 0)\n          {\n            *q++='<';\n            p+=3;\n          }\n        else\n          if (LocaleNCompare(\"&gt;\",p,4) == 0)\n            {\n              *q++='>';\n              p+=3;\n            }\n          else\n            if (LocaleNCompare(\"&amp;\",p,5) == 0)\n              {\n                *q++='&';\n                p+=4;\n              }\n            else\n              *q++=(*p);\n        continue;\n      }\n      case '%':\n        break;  /* continue to next set of handlers */\n      default:\n      {\n        *q++=(*p);  /* any thing else is 'as normal' */\n        continue;\n      }\n    }\n    p++; /* advance beyond the percent */\n    /*\n      Doubled Percent - or percent at end of string.\n    */\n    if ((*p == '\\0') || (*p == '\\'') || (*p == '\"'))\n      p--;\n    if (*p == '%')\n      {\n        *q++='%';\n        continue;\n      }\n    /*\n      Single letter escapes %c.\n    */\n    if (*p != '[')\n      {\n        const char\n          *string;\n\n        if (number != MagickFalse)\n          {\n            /*\n              But only if not preceeded by a number!\n            */\n            *q++='%'; /* do NOT substitute the percent */\n            p--;      /* back up one */\n            continue;\n          }\n        string=GetMagickPropertyLetter(image_info,image,*p, exception);\n        if (string != (char *) NULL)\n          {\n            AppendString2Text(string);\n            if (image != (Image *) NULL)\n              (void) DeleteImageArtifact(image,\"get-property\");\n            if (image_info != (ImageInfo *) NULL)\n              (void) DeleteImageOption(image_info,\"get-property\");\n            continue;\n          }\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n          \"UnknownImageProperty\",\"\\\"%%%c\\\"\",*p);\n        continue;\n      }\n    {\n      char\n        pattern[2*MagickPathExtent];\n\n      const char\n        *key,\n        *string;\n\n      register ssize_t\n        len;\n\n      ssize_t\n        depth;\n\n      /*\n        Braced Percent Escape %[...].\n      */\n      p++;  /* advance p to just inside the opening brace */\n      depth=1;\n      if (*p == ']')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"UnknownImageProperty\",\"\\\"%%[]\\\"\");\n          break;\n        }\n      for (len=0; len<(MagickPathExtent-1L) && (*p != '\\0');)\n      {\n        if ((*p == '\\\\') && (*(p+1) != '\\0'))\n          {\n            /*\n              Skip escaped braces within braced pattern.\n            */\n            pattern[len++]=(*p++);\n            pattern[len++]=(*p++);\n            continue;\n          }\n        if (*p == '[')\n          depth++;\n        if (*p == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[len++]=(*p++);\n      }\n      pattern[len]='\\0';\n      if (depth != 0)\n        {\n          /*\n            Check for unmatched final ']' for \"%[...]\".\n          */\n          if (len >= 64)\n            {\n              pattern[61] = '.';  /* truncate string for error message */\n              pattern[62] = '.';\n              pattern[63] = '.';\n              pattern[64] = '\\0';\n            }\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"UnbalancedBraces\",\"\\\"%%[%s\\\"\",pattern);\n          interpret_text=DestroyString(interpret_text);\n          return((char *) NULL);\n        }\n      /*\n        Special Lookup Prefixes %[prefix:...].\n      */\n      if (LocaleNCompare(\"fx:\",pattern,3) == 0)\n        {\n          double\n            value;\n\n          FxInfo\n            *fx_info;\n\n          MagickBooleanType\n            status;\n\n          /*\n            FX - value calculator.\n          */\n          if (image == (Image *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          fx_info=AcquireFxInfo(image,pattern+3,exception);\n          status=FxEvaluateChannelExpression(fx_info,IntensityPixelChannel,0,0,\n            &value,exception);\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%.*g\",\n                GetMagickPrecision(),(double) value);\n              AppendString2Text(result);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"pixel:\",pattern,6) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          GetPixelInfo(image,&pixel);\n          fx_info=AcquireFxInfo(image,pattern+6,exception);\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                name[MagickPathExtent];\n\n              (void) QueryColorname(image,&pixel,SVGCompliance,name,\n                exception);\n              AppendString2Text(name);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"option:\",pattern,7) == 0)\n        {\n          /*\n            Option - direct global option lookup (with globbing).\n          */\n          if (image_info == (ImageInfo *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+7) != MagickFalse)\n            {\n              ResetImageOptionIterator(image_info);\n              while ((key=GetNextImageOption(image_info)) != (const char *) NULL)\n                if (GlobExpression(key,pattern+7,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageOption(image_info,key);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? key found but no string value! */\n                  }\n              continue;\n            }\n          string=GetImageOption(image_info,pattern+7);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"artifact:\",pattern,9) == 0)\n        {\n          /*\n            Artifact - direct image artifact lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImageArtifactIterator(image);\n              while ((key=GetNextImageArtifact(image)) != (const char *) NULL)\n              if (GlobExpression(key,pattern+9,MagickTrue) != MagickFalse)\n                {\n                  string=GetImageArtifact(image,key);\n                  if (string != (const char *) NULL)\n                    AppendKeyValue2Text(key,string);\n                  /* else - assertion failure? key found but no string value! */\n                }\n              continue;\n            }\n          string=GetImageArtifact(image,pattern+9);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"property:\",pattern,9) == 0)\n        {\n          /*\n            Property - direct image property lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImagePropertyIterator(image);\n              while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n                if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageProperty(image,key,exception);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? */\n                  }\n              continue;\n            }\n          string=GetImageProperty(image,pattern+9,exception);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (image != (Image *) NULL)\n        {\n          /*\n            Properties without special prefix.  This handles attributes,\n            properties, and profiles such as %[exif:...].  Note the profile\n            properties may also include a glob expansion pattern.\n          */\n          string=GetImageProperty(image,pattern,exception);\n          if (string != (const char *) NULL)\n            {\n              AppendString2Text(string);\n              if (image != (Image *) NULL)\n                (void)DeleteImageArtifact(image,\"get-property\");\n              if (image_info != (ImageInfo *) NULL)\n                (void)DeleteImageOption(image_info,\"get-property\");\n              continue;\n            }\n        }\n      if (IsGlob(pattern) != MagickFalse)\n        {\n          /*\n            Handle property 'glob' patterns such as:\n            %[*] %[user:array_??] %[filename:e*]>\n          */\n          if (image == (Image *) NULL)\n            continue; /* else no image to retrieve proprty - no list */\n          ResetImagePropertyIterator(image);\n          while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n            if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n              {\n                string=GetImageProperty(image,key,exception);\n                if (string != (const char *) NULL)\n                  AppendKeyValue2Text(key,string);\n                /* else - assertion failure? */\n              }\n          continue;\n        }\n      /*\n        Look for a known property or image attribute such as\n        %[basename] %[denisty] %[delay].  Also handles a braced single\n        letter: %[b] %[G] %[g].\n      */\n      string=GetMagickProperty(image_info,image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Look for a per-image artifact. This includes option lookup\n        (FUTURE: interpreted according to image).\n      */\n      if (image != (Image *) NULL)\n        {\n          string=GetImageArtifact(image,pattern);\n          if (string != (char *) NULL)\n            {\n              AppendString2Text(string);\n              continue;\n            }\n        }\n      else\n        if (image_info != (ImageInfo *) NULL)\n          {\n            /*\n              No image, so direct 'option' lookup (no delayed percent escapes).\n            */\n            string=GetImageOption(image_info,pattern);\n            if (string != (char *) NULL)\n              {\n                AppendString2Text(string);\n                continue;\n              }\n          }\nPropertyLookupFailure:\n      /*\n        Failed to find any match anywhere!\n      */\n      if (len >= 64)\n        {\n          pattern[61] = '.';  /* truncate string for error message */\n          pattern[62] = '.';\n          pattern[63] = '.';\n          pattern[64] = '\\0';\n        }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"UnknownImageProperty\",\"\\\"%%[%s]\\\"\",pattern);\n    }\n  }\n  *q='\\0';\n  return(interpret_text);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProperty() removes a property from the image and returns its\n%  value.\n%\n%  In this case the ConstantString() value returned should be freed by the\n%  caller when finished.\n%\n%  The format of the RemoveImageProperty method is:\n%\n%      char *RemoveImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport char *RemoveImageProperty(Image *image,const char *property)\n{\n  char\n    *value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return((char *) NULL);\n  value=(char *) RemoveNodeFromSplayTree((SplayTreeInfo *) image->properties,\n    property);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P r o p e r t y I t e r a t o r                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePropertyIterator() resets the image properties iterator.  Use it\n%  in conjunction with GetNextImageProperty() to iterate over all the values\n%  associated with an image property.\n%\n%  The format of the ResetImagePropertyIterator method is:\n%\n%      ResetImagePropertyIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImagePropertyIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProperty() saves the given string value either to specific known\n%  attribute or to a freeform property string.\n%\n%  Attempting to set a property that is normally calculated will produce\n%  an exception.\n%\n%  The format of the SetImageProperty method is:\n%\n%      MagickBooleanType SetImageProperty(Image *image,const char *property,\n%        const char *value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o values: the image property values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n    {\n      /*\n        Do not 'set' single letter properties - read only shorthand.\n       */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"SetReadOnlyProperty\",\"`%s'\",property);\n      return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ((LocaleCompare(\"magick\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0) ||\n          (LocaleCompare(\"mean\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ((LocaleCompare(\"size\",property) == 0) ||\n          (LocaleCompare(\"skewness\",property) == 0) ||\n          (LocaleCompare(\"scenes\",property) == 0) ||\n          (LocaleCompare(\"standard-deviation\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include \"tiffconf.h\"\n# endif\n# include \"tiff.h\"\n# include \"tiffio.h\"\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadSingleSampleMethod,\n  ReadRGBAMethod,\n  ReadCMYKAMethod,\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 0, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n#endif  /* MAGICKCORE_TIFF_DELEGATE */\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(long) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic void TIFFGetProfiles(TIFF *tiff,Image *image,MagickBooleanType ping,\n  ExceptionInfo *exception)\n{\n  uint32\n    length;\n\n  unsigned char\n    *profile;\n\n  length=0;\n  if (ping == MagickFalse)\n    {\n#if defined(TIFFTAG_ICCPROFILE)\n      if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n      if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n      if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          (void) ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n      if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n#endif\n      if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n          exception);\n    }\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n}\n\nstatic void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n\n  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:document\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n    (void) SetImageProperty(image,\"comment\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:make\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:model\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n    (void) SetImageProperty(image,\"label\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:software\",text,exception);\n  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\n    }\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MagickPathExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  sans=NULL;\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,&sans,&sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MagickPathExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,&sans,&sans) == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",shorty);\n          }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              &sans,&sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",(double)\n            floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value,exception);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,size_t bits_per_sample,\n  tsample_t sample,ssize_t row,tdata_t scanline)\n{\n  int32\n    status;\n\n  (void) bits_per_sample;\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    **value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /* only support 8 bit for now */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /* Search for Adobe APP14 JPEG Marker */\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value))\n    return(ReadRGBAMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadRGBAMethod);\n  method=ReadRGBAMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic void TIFFReadPhotoshopLayers(Image* image,const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *layer_info;\n\n  Image\n    *layers;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  layer_info=GetImageProfile(image,\"tiff:37724\");\n  if (layer_info == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) layer_info->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (layer_info->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (layer_info->length-8))\n    return;\n  layers=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachBlob(layers->blob,layer_info->datum,layer_info->length);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  info.version=1;\n  info.columns=layers->columns;\n  info.rows=layers->rows;\n  info.channels=(unsigned short) layers->number_channels;\n  /* Setting the mode to a value that won't change the colorspace */\n  info.mode=10;\n  ReadPSDLayers(layers,image_info,&info,MagickFalse,exception);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  do\n  {\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\nRestoreMSCWarning\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      SetImageColorspace(image,GRAYColorspace,exception);\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      SetImageColorspace(image,CMYKColorspace,exception);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      SetImageColorspace(image,LabColorspace,exception);\n    TIFFGetProfiles(tiff,image,image_info->ping,exception);\n    TIFFGetProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      TIFFGetEXIFProperties(tiff,image,exception);\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n      &samples_per_pixel);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                  exception);\n          }\n      }\n    method=ReadGenericMethod;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MagickPathExtent];\n\n        method=ReadStripMethod;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value,exception);\n      }\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))\n      method=ReadRGBAMethod;\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))\n      method=ReadCMYKAMethod;\n    if ((photometric != PHOTOMETRIC_RGB) &&\n        (photometric != PHOTOMETRIC_CIELAB) &&\n        (photometric != PHOTOMETRIC_SEPARATED))\n      method=ReadGenericMethod;\n    if (image->storage_class == PseudoClass)\n      method=ReadSingleSampleMethod;\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      method=ReadSingleSampleMethod;\n    if ((photometric != PHOTOMETRIC_SEPARATED) &&\n        (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (compress_tag == COMPRESSION_JBIG)\n      method=ReadStripMethod;\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      method=ReadTileMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (method)\n    {\n      case ReadSingleSampleMethod:\n      {\n        /*\n          Convert TIFF image to PseudoClass MIFF image.\n        */\n        quantum_type=IndexQuantum;\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class != PseudoClass)\n              {\n                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                  GrayAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n            else\n              {\n                quantum_type=IndexAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n          }\n        else\n          if (image->storage_class != PseudoClass)\n            {\n              quantum_type=GrayQuantum;\n              pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n            }\n        status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(\n          bits_per_sample)/log(2))));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadRGBAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadCMYKAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register Quantum\n              *magick_restrict q;\n\n            int\n              status;\n\n            status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)\n              pixels);\n            if (status == -1)\n              break;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (image->colorspace != CMYKColorspace)\n              switch (i)\n              {\n                case 0: quantum_type=RedQuantum; break;\n                case 1: quantum_type=GreenQuantum; break;\n                case 2: quantum_type=BlueQuantum; break;\n                case 3: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            else\n              switch (i)\n              {\n                case 0: quantum_type=CyanQuantum; break;\n                case 1: quantum_type=MagentaQuantum; break;\n                case 2: quantum_type=YellowQuantum; break;\n                case 3: quantum_type=BlackQuantum; break;\n                case 4: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadYCCKMethod:\n      {\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register uint32\n          *p;\n\n        /*\n          Convert stripped TIFF image to DirectClass MIFF image.\n        */\n        i=0;\n        p=(uint32 *) NULL;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          if (i == 0)\n            {\n              if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)\n                break;\n              i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)\n                image->rows-y);\n            }\n          i--;\n          p=((uint32 *) pixels)+image->columns*i;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetR(*p))),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetG(*p))),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetB(*p))),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                (TIFFGetA(*p))),q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register uint32\n          *p;\n\n        uint32\n          *tile_pixels,\n          columns,\n          rows;\n\n        /*\n          Convert tiled TIFF image to DirectClass MIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(CoderError,\"ImageIsNotTiled\");\n          }\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*\n          sizeof(*tile_pixels));\n        if (tile_pixels == (uint32 *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (y=0; y < (ssize_t) image->rows; y+=rows)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q,\n            *magick_restrict tile;\n\n          size_t\n            columns_remaining,\n            rows_remaining;\n\n          rows_remaining=image->rows-y;\n          if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n            rows_remaining=rows;\n          tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,\n            exception);\n          if (tile == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=columns)\n          {\n            size_t\n              column,\n              row;\n\n            if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)\n              break;\n            columns_remaining=image->columns-x;\n            if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n              columns_remaining=columns;\n            p=tile_pixels+(rows-rows_remaining)*columns;\n            q=tile+GetPixelChannels(image)*(image->columns*(rows_remaining-1)+\n              x);\n            for (row=rows_remaining; row > 0; row--)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetA(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              else\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              p+=columns-columns_remaining;\n              q-=GetPixelChannels(image)*(image->columns+columns_remaining);\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *pixel_info;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n          sizeof(uint32));\n        if (pixel_info == (MemoryInfo *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        p=pixels+number_pixels-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (status != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while (status != MagickFalse);\n  TIFFClose(tiff);\n  TIFFReadPhotoshopLayers(image,image_info,exception);\n  if (image_info->number_scenes != 0)\n    {\n      if (image_info->scene >= GetImageListLength(image))\n        {\n          /* Subimage was not found in the Photoshop layer */\n          image=DestroyImageList(image);\n          return((Image *)NULL);\n        }\n    }\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  images=GetFirstImageInList(images);\n  /*\n    Write pyramid-encoded TIFF image.\n  */\n  write_info=CloneImageInfo(image_info);\n  write_info->adjoin=MagickTrue;\n  (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n  (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n  status=WriteTIFFImage(write_info,images,exception);\n  images=DestroyImageList(images);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) ResetMagickMemory(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    {\n      uint32\n        rows_per_strip;\n\n      option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n      if (option != (const char *) NULL)\n        rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n      else\n        if (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&rows_per_strip) == 0)\n          rows_per_strip=0;  /* use default */\n      rows_per_strip=TIFFDefaultStripSize(tiff,rows_per_strip);\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      return(MagickTrue);\n    }\n  /*\n    Create tiled TIFF, ignore \"tiff:rows-per-strip\".\n  */\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) CopyMagickMemory(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property,exception);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n\n\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (image->colorspace == YCbCrColorspace)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n                }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT  X   X  TTTTT                              %\n%                              T     X X     T                                %\n%                              T      X      T                                %\n%                              T     X X     T                                %\n%                              T    X   X    T                                %\n%                                                                             %\n%                                                                             %\n%                      Render Text Onto A Canvas Image.                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTXTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T X T                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTXT() returns MagickTrue if the image format type, identified by the magick\n%  string, is TXT.\n%\n%  The format of the IsTXT method is:\n%\n%      MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n\n  char\n    colorspace[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  unsigned long\n    columns,\n    depth,\n    rows;\n\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T E X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTEXTImage() reads a text file and returns it as an image.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTEXTImage method is:\n%\n%      Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\n%        char *text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o text: the text storage buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTEXTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *p,\n    text[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image,\n    *texture;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    offset;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  /*\n    Set the page geometry.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  page.width=612;\n  page.height=792;\n  page.x=43;\n  page.y=43;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  /*\n    Initialize Image structure.\n  */\n  image->columns=(size_t) floor((((double) page.width*image->resolution.x)/\n    delta.x)+0.5);\n  image->rows=(size_t) floor((((double) page.height*image->resolution.y)/\n    delta.y)+0.5);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  image->page.x=0;\n  image->page.y=0;\n  texture=(Image *) NULL;\n  if (image_info->texture != (char *) NULL)\n    {\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) CopyMagickString(read_info->filename,image_info->texture,\n        MagickPathExtent);\n      texture=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n    }\n  /*\n    Annotate the text image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,image_info->filename);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=GetTypeMetrics(image,draw_info,&metrics,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\n  page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  (void) CopyMagickString(filename,image_info->filename,MagickPathExtent);\n  if (*draw_info->text != '\\0')\n    *draw_info->text='\\0';\n  p=text;\n  for (offset=2*page.y; p != (char *) NULL; )\n  {\n    /*\n      Annotate image with text.\n    */\n    (void) ConcatenateString(&draw_info->text,text);\n    (void) ConcatenateString(&draw_info->text,\"\\n\");\n    offset+=(ssize_t) (metrics.ascent-metrics.descent);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) offset,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    p=ReadBlobString(image,text);\n    if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\n      continue;\n    if (texture != (Image *) NULL)\n      {\n        MagickProgressMonitor\n          progress_monitor;\n\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) TextureImage(image,texture,exception);\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n      }\n    (void) AnnotateImage(image,draw_info,exception);\n    if (p == (char *) NULL)\n      break;\n    /*\n      Page is full-- allocate next image structure.\n    */\n    *draw_info->text='\\0';\n    offset=2*page.y;\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image->next->columns=image->columns;\n    image->next->rows=image->rows;\n    image=SyncNextImageInList(image);\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    (void) SetImageBackgroundColor(image,exception);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (texture != (Image *) NULL)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      progress_monitor=SetImageProgressMonitor(image,\n        (MagickProgressMonitor) NULL,image->client_data);\n      (void) TextureImage(image,texture,exception);\n      (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    }\n  (void) AnnotateImage(image,draw_info,exception);\n  if (texture != (Image *) NULL)\n    texture=DestroyImage(texture);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T X T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTXTImage() reads a text file and returns it as an image.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadTXTImage method is:\n%\n%      Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T X T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTXTImage() adds attributes for the TXT image format to the\n%  list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTXTImage method is:\n%\n%      size_t RegisterTXTImage(void)\n%\n*/\nModuleExport size_t RegisterTXTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TXT\",\"SPARSE-COLOR\",\"Sparse Color\");\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TEXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTEXTImage;\n  entry->format_type=ImplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTXTImage;\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->magick=(IsImageFormatHandler *) IsTXT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T X T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTXTImage() removes format registrations made by the\n%  TXT module from the list of supported format.\n%\n%  The format of the UnregisterTXTImage method is:\n%\n%      UnregisterTXTImage(void)\n%\n*/\nModuleExport void UnregisterTXTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SPARSE-COLOR\");\n  (void) UnregisterMagickInfo(\"TEXT\");\n  (void) UnregisterMagickInfo(\"TXT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTXTImage writes the pixel values as text numbers.\n%\n%  The format of the WriteTXTImage method is:\n%\n%      MagickBooleanType WriteTXTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    colorspace[MagickPathExtent],\n    tuple[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    ComplianceType\n      compliance;\n\n    const char\n      *value;\n\n    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(\n      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);\n    LocaleLower(colorspace);\n    image->depth=GetImageQuantumDepth(image,MagickTrue);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) ConcatenateMagickString(colorspace,\"a\",MagickPathExtent);\n    compliance=NoCompliance;\n    value=GetImageOption(image_info,\"txt:compliance\");\n    if (value != (char *) NULL)\n      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,\n        MagickFalse,value);\n    if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") != 0)\n      {\n        size_t\n          depth;\n\n        depth=compliance == SVGCompliance ? image->depth :\n          MAGICKCORE_QUANTUM_DEPTH;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\\n\",(double)\n          image->columns,(double) image->rows,(double) ((MagickOffsetType)\n          GetQuantumRange(depth)),colorspace);\n        (void) WriteBlobString(image,buffer);\n      }\n    GetPixelInfo(image,&pixel);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        GetPixelInfoPixel(image,p,&pixel);\n        if (pixel.colorspace == LabColorspace)\n          {\n            pixel.green-=(QuantumRange+1)/2.0;\n            pixel.blue-=(QuantumRange+1)/2.0;\n          }\n        if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") == 0)\n          {\n            /*\n              Sparse-color format.\n            */\n            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)\n              {\n                GetColorTuple(&pixel,MagickFalse,tuple);\n                (void) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%.20g,%.20g,\",(double) x,(double) y);\n                (void) WriteBlobString(image,buffer);\n                (void) WriteBlobString(image,tuple);\n                (void) WriteBlobString(image,\" \");\n              }\n            p+=GetPixelChannels(image);\n            continue;\n          }\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g,%.20g: \",\n          (double) x,(double) y);\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n        if (pixel.colorspace == GRAYColorspace)\n          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,\n            tuple);\n        else\n          {\n            ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,\n              tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);\n          }\n        if (pixel.colorspace == CMYKColorspace)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,\n              tuple);\n          }\n        if (pixel.alpha_trait != UndefinedPixelTrait)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,\n              tuple);\n          }\n        (void) ConcatenateMagickString(tuple,\")\",MagickPathExtent);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"  \");\n        GetColorTuple(&pixel,MagickTrue,tuple);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%s\",tuple);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"  \");\n        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"\\n\");\n        p+=GetPixelChannels(image);\n      }\n      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n        image->rows);\n      if (status == MagickFalse)\n        break;\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%            PPPP    RRRR    OOO   PPPP   EEEEE  RRRR   TTTTT  Y   Y          %\n%            P   P   R   R  O   O  P   P  E      R   R    T     Y Y           %\n%            PPPP    RRRR   O   O  PPPP   EEE    RRRR     T      Y            %\n%            P       R R    O   O  P      E      R R      T      Y            %\n%            P       R  R    OOO   P      EEEEE  R  R     T      Y            %\n%                                                                             %\n%                                                                             %\n%                         MagickCore Property Methods                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compare.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS2_LCMS2_H)\n#include <lcms2/lcms2.h>\n#elif defined(MAGICKCORE_HAVE_LCMS2_H)\n#include \"lcms2.h\"\n#elif defined(MAGICKCORE_HAVE_LCMS_LCMS_H)\n#include <lcms/lcms.h>\n#else\n#include \"lcms.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o p e r t i e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProperties() clones all the image properties to another image.\n%\n%  The format of the CloneImageProperties method is:\n%\n%      MagickBooleanType CloneImageProperties(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProperties(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      clone_image->filename);\n  (void) CopyMagickString(image->filename,clone_image->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,clone_image->magick_filename,\n    MagickPathExtent);\n  image->compression=clone_image->compression;\n  image->quality=clone_image->quality;\n  image->depth=clone_image->depth;\n  image->alpha_color=clone_image->alpha_color;\n  image->background_color=clone_image->background_color;\n  image->border_color=clone_image->border_color;\n  image->transparent_color=clone_image->transparent_color;\n  image->gamma=clone_image->gamma;\n  image->chromaticity=clone_image->chromaticity;\n  image->rendering_intent=clone_image->rendering_intent;\n  image->black_point_compensation=clone_image->black_point_compensation;\n  image->units=clone_image->units;\n  image->montage=(char *) NULL;\n  image->directory=(char *) NULL;\n  (void) CloneString(&image->geometry,clone_image->geometry);\n  image->offset=clone_image->offset;\n  image->resolution.x=clone_image->resolution.x;\n  image->resolution.y=clone_image->resolution.y;\n  image->page=clone_image->page;\n  image->tile_offset=clone_image->tile_offset;\n  image->extract_info=clone_image->extract_info;\n  image->filter=clone_image->filter;\n  image->fuzz=clone_image->fuzz;\n  image->intensity=clone_image->intensity;\n  image->interlace=clone_image->interlace;\n  image->interpolate=clone_image->interpolate;\n  image->endian=clone_image->endian;\n  image->gravity=clone_image->gravity;\n  image->compose=clone_image->compose;\n  image->orientation=clone_image->orientation;\n  image->scene=clone_image->scene;\n  image->dispose=clone_image->dispose;\n  image->delay=clone_image->delay;\n  image->ticks_per_second=clone_image->ticks_per_second;\n  image->iterations=clone_image->iterations;\n  image->total_colors=clone_image->total_colors;\n  image->taint=clone_image->taint;\n  image->progress_monitor=clone_image->progress_monitor;\n  image->client_data=clone_image->client_data;\n  image->start_loop=clone_image->start_loop;\n  image->error=clone_image->error;\n  image->signature=clone_image->signature;\n  if (clone_image->properties != (void *) NULL)\n    {\n      if (image->properties != (void *) NULL)\n        DestroyImageProperties(image);\n      image->properties=CloneSplayTree((SplayTreeInfo *)\n        clone_image->properties,(void *(*)(void *)) ConstantString,\n        (void *(*)(void *)) ConstantString);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e f i n e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageProperty() associates an assignment string of the form\n%  \"key=value\" with an artifact or options. It is equivelent to\n%  SetImageProperty().\n%\n%  The format of the DefineImageProperty method is:\n%\n%      MagickBooleanType DefineImageProperty(Image *image,const char *property,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DefineImageProperty(Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n\n  register char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(property != (const char *) NULL);\n  (void) CopyMagickString(key,property,MagickPathExtent-1);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageProperty(image,key,value,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProperty() deletes an image property.\n%\n%  The format of the DeleteImageProperty method is:\n%\n%      MagickBooleanType DeleteImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProperty(Image *image,\n  const char *property)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return(MagickFalse);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->properties,property));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o p e r t i e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProperties() destroys all properties and associated memory\n%  attached to the given image.\n%\n%  The format of the DestroyDefines method is:\n%\n%      void DestroyImageProperties(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t I m a g e P r o p e r t y                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatImageProperty() permits formatted property/value pairs to be saved as\n%  an image property.\n%\n%  The format of the FormatImageProperty method is:\n%\n%      MagickBooleanType FormatImageProperty(Image *image,const char *property,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o  image:  The image.\n%\n%   o  property:  The attribute property.\n%\n%   o  format:  A string describing the format to use to write the remaining\n%      arguments.\n%\n*/\nMagickExport MagickBooleanType FormatImageProperty(Image *image,\n  const char *property,const char *format,...)\n{\n  char\n    value[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(value,MagickPathExtent,format,operands);\n  (void) n;\n  va_end(operands);\n  exception=AcquireExceptionInfo();\n  status=SetImageProperty(image,property,value,exception);\n  exception=DestroyExceptionInfo(exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProperty() gets a value associated with an image property.\n%\n%  This includes,  profile prefixes, such as \"exif:\", \"iptc:\" and \"8bim:\"\n%  It does not handle non-prifile prefixes, such as \"fx:\", \"option:\", or\n%  \"artifact:\".\n%\n%  The returned string is stored as a properity of the same name for faster\n%  lookup later. It should NOT be freed by the caller.\n%\n%  The format of the GetImageProperty method is:\n%\n%      const char *GetImageProperty(const Image *image,const char *key,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char\n  *TracePSClippath(const unsigned char *,size_t),\n  *TraceSVGClippath(const unsigned char *,size_t,const size_t,\n    const size_t);\n\nstatic MagickBooleanType GetIPTCProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    *message;\n\n  const StringInfo\n    *profile;\n\n  long\n    count,\n    dataset,\n    record;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=sscanf(key,\"IPTC:%ld:%ld\",&dataset,&record);\n  if (count != 2)\n    return(MagickFalse);\n  attribute=(char *) NULL;\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)\n  {\n    length=1;\n    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)\n      continue;\n    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);\n    length|=GetStringInfoDatum(profile)[i+4];\n    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&\n        ((long) GetStringInfoDatum(profile)[i+2] == record))\n      {\n        message=(char *) NULL;\n        if (~length >= 1)\n          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));\n        if (message != (char *) NULL)\n          {\n            (void) CopyMagickString(message,(char *) GetStringInfoDatum(\n              profile)+i+5,length+1);\n            (void) ConcatenateString(&attribute,message);\n            (void) ConcatenateString(&attribute,\";\");\n            message=DestroyString(message);\n          }\n      }\n    i+=5;\n  }\n  if ((attribute == (char *) NULL) || (*attribute == ';'))\n    {\n      if (attribute != (char *) NULL)\n        attribute=DestroyString(attribute);\n      return(MagickFalse);\n    }\n  attribute[strlen(attribute)-1]='\\0';\n  (void) SetImageProperty((Image *) image,key,(const char *) attribute,\n    exception);\n  attribute=DestroyString(attribute);\n  return(MagickTrue);\n}\n\nstatic inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed int ReadPropertyMSBLong(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[4];\n\n  unsigned int\n    value;\n\n  if (*length < 4)\n    return(-1);\n  for (i=0; i < 4; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed short ReadPropertyMSBShort(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[2];\n\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return((unsigned short) ~0);\n  for (i=0; i < 2; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((count < 0) || ((size_t) count > length))\n      {\n        length=0; \n        continue;\n      }\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}\n\nstatic inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned int ReadPropertyUnsignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      return(value & 0xffffffff);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  return(value & 0xffffffff);\n}\n\nstatic inline signed short ReadPropertySignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned short ReadPropertyUnsignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      return(value & 0xffff);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  return(value & 0xffff);\n}\n\nstatic MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      *description;\n  } TagInfo;\n\n  static TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" },\n      {  0x8827, \"exif:ISOSpeedRatings\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },\n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:ExifImageWidth\" },\n      {  0xa003, \"exif:ExifImageLength\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x00000, (const char *) NULL }\n    };\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((offset < 0) || (size_t) offset >= length)\n            continue;\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MagickPathExtent],\n            *value;\n\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(unsigned char *) p1));\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n              break;\n            }\n            default:\n            case EXIF_FMT_STRING:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  register ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              register const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  register ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MagickPathExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MagickPathExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MagickPathExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MagickPathExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value,exception);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}\n\nstatic MagickBooleanType GetICCProperty(const Image *image,const char *property,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  magick_unreferenced(property);\n\n  profile=GetImageProfile(image,\"icc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"icm\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 128)\n    return(MagickFalse);  /* minimum ICC profile length */\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n  {\n    cmsHPROFILE\n      icc_profile;\n\n    icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n      (cmsUInt32Number) GetStringInfoLength(profile));\n    if (icc_profile != (cmsHPROFILE *) NULL)\n      {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n        const char\n          *name;\n\n        name=cmsTakeProductName(icc_profile);\n        if (name != (const char *) NULL)\n          (void) SetImageProperty((Image *) image,\"icc:name\",name,exception);\n#else\n        char\n          info[MagickPathExtent];\n\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:description\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:manufacturer\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\"US\",info,\n          MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:model\",info,exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:copyright\",info,exception);\n#endif\n        (void) cmsCloseProfile(icc_profile);\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n  {\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n              ConstantString(GetXMLTreeTag(node)),ConstantString(content));\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                ConstantString(GetXMLTreeTag(child)),ConstantString(content));\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n        }\n        description=GetNextXMLTreeTag(description);\n      }\n    }\n  xmp=DestroyXMLTree(xmp);\n  return(status);\n}\n\nstatic char *TracePSClippath(const unsigned char *blob,size_t length)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    knot_count,\n    selector,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,\"/ClipImage\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"{\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /c {curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /l {lineto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /m {moveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /v {currentpoint 6 2 roll curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /y {2 copy curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /z {closepath} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  newpath\\n\");\n  (void) ConcatenateString(&path,message);\n  /*\n    The clipping path format is defined in \"Adobe Photoshop File Formats\n    Specification\" version 6.0 downloadable from adobe.com.\n  */\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length > 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          size_t\n            xx,\n            yy;\n\n          yy=(size_t) ReadPropertyMSBLong(&blob,&length);\n          xx=(size_t) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x/4096/4096;\n          point[i].y=1.0-(double) y/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"  %g %g m\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l\\n\",point[1].x,point[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v\\n\",point[0].x,point[0].y,\n                  point[1].x,point[1].y);\n              else\n                if ((point[0].x == point[1].x) && (point[0].y == point[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y\\n\",last[2].x,last[2].y,\n                    point[1].x,point[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c\\n\",last[2].x,\n                    last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n            /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l z\\n\",first[1].x,first[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v z\\n\",first[0].x,first[0].y,\n                  first[1].x,first[1].y);\n              else\n                if ((first[0].x == first[1].x) && (first[0].y == first[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y z\\n\",last[2].x,last[2].y,\n                    first[1].x,first[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c z\\n\",last[2].x,\n                    last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Returns an empty PS path if the path has no knots.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"  eoclip\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"} bind def\");\n  (void) ConcatenateString(&path,message);\n  message=DestroyString(message);\n  return(path);\n}\n\nstatic char *TraceSVGClippath(const unsigned char *blob,size_t length,\n  const size_t columns,const size_t rows)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector,\n    x,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,(\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\\n\"\n    \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"\n    \" width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\"\n    \"<g>\\n\"\n    \"<path fill-rule=\\\"evenodd\\\" style=\\\"fill:#00000000;stroke:#00000000;\"\n    \"stroke-width:0;stroke-antialiasing:false\\\" d=\\\"\\n\"),(double) columns,\n    (double) rows);\n  (void) ConcatenateString(&path,message);\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          unsigned int\n            xx,\n            yy;\n\n          yy=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          xx=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x*columns/4096/4096;\n          point[i].y=(double) y*rows/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"M %g %g\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g\\n\",point[1].x,point[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g\\n\",last[2].x,\n                last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n           /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g Z\\n\",first[1].x,first[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g Z\\n\",last[2].x,\n                last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Return an empty SVG image if the path does not have knots.\n  */\n  (void) ConcatenateString(&path,\"\\\"/>\\n</g>\\n</svg>\\n\");\n  message=DestroyString(message);\n  return(path);\n}\n\nMagickExport const char *GetImageProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  register const char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  p=(const char *) NULL;\n  if (image->properties != (void *) NULL)\n    {\n      if (property == (const char *) NULL)\n        {\n          ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n          p=(const char *) GetNextValueInSplayTree((SplayTreeInfo *)\n            image->properties);\n          return(p);\n        }\n        p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n          image->properties,property);\n        if (p != (const char *) NULL)\n          return(p);\n    }\n  if ((property == (const char *) NULL) ||\n      (strchr(property,':') == (char *) NULL))\n    return(p);\n  switch (*property)\n  {\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) Get8BIMProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) GetEXIFProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleNCompare(\"icc:\",property,4) == 0) ||\n          (LocaleNCompare(\"icm:\",property,4) == 0))\n        {\n          (void) GetICCProperty(image,property,exception);\n          break;\n        }\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) GetIPTCProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) GetXMPProperty(image,property);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (image->properties != (void *) NULL)\n    {\n      p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n        image->properties,property);\n      return(p);\n    }\n  return((const char *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t M a g i c k P r o p e r t y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickProperty() gets attributes or calculated values that is associated\n%  with a fixed known property name, or single letter property. It may be\n%  called if no image is defined (IMv7), in which case only global image_info\n%  values are available:\n%\n%    \\n   newline\n%    \\r   carriage return\n%    <    less-than character.\n%    >    greater-than character.\n%    &    ampersand character.\n%    %%   a percent sign\n%    %b   file size of image read in\n%    %c   comment meta-data property\n%    %d   directory component of path\n%    %e   filename extension or suffix\n%    %f   filename (including suffix)\n%    %g   layer canvas page geometry   (equivalent to \"%Wx%H%X%Y\")\n%    %h   current image height in pixels\n%    %i   image filename (note: becomes output filename for \"info:\")\n%    %k   CALCULATED: number of unique colors\n%    %l   label meta-data property\n%    %m   image file format (file magic)\n%    %n   number of images in current image sequence\n%    %o   output filename  (used for delegates)\n%    %p   index of image in current image list\n%    %q   quantum depth (compile-time constant)\n%    %r   image class and colorspace\n%    %s   scene number (from input unless re-assigned)\n%    %t   filename without directory or extension (suffix)\n%    %u   unique temporary filename (used for delegates)\n%    %w   current width in pixels\n%    %x   x resolution (density)\n%    %y   y resolution (density)\n%    %z   image depth (as read in unless modified, image save depth)\n%    %A   image transparency channel enabled (true/false)\n%    %C   image compression type\n%    %D   image GIF dispose method\n%    %G   original image size (%wx%h; before any resizes)\n%    %H   page (canvas) height\n%    %M   Magick filename (original file exactly as given,  including read mods)\n%    %O   page (canvas) offset ( = %X%Y )\n%    %P   page (canvas) size ( = %Wx%H )\n%    %Q   image compression quality ( 0 = default )\n%    %S   ?? scenes ??\n%    %T   image time delay (in centi-seconds)\n%    %U   image resolution units\n%    %W   page (canvas) width\n%    %X   page (canvas) x offset (including sign)\n%    %Y   page (canvas) y offset (including sign)\n%    %Z   unique filename (used for delegates)\n%    %@   CALCULATED: trim bounding box (without actually trimming)\n%    %#   CALCULATED: 'signature' hash of image values\n%\n%  This routine only handles specifically known properties.  It does not\n%  handle special prefixed properties, profiles, or expressions. Nor does\n%  it return any free-form property strings.\n%\n%  The returned string is stored in a structure somewhere, and should not be\n%  directly freed.  If the string was generated (common) the string will be\n%  stored as as either as artifact or option 'get-property'.  These may be\n%  deleted (cleaned up) when no longer required, but neither artifact or\n%  option is guranteed to exist.\n%\n%  The format of the GetMagickProperty method is:\n%\n%      const char *GetMagickProperty(ImageInfo *image_info,Image *image,\n%        const char *property,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info (optional)\n%\n%    o image: the image (optional)\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const char *GetMagickPropertyLetter(ImageInfo *image_info,\n  Image *image,const char letter,ExceptionInfo *exception)\n{\n#define WarnNoImageReturn(format,arg) \\\n  if (image == (Image *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n  char\n    value[MagickPathExtent];  /* formatted string to store as an artifact */\n\n  const char\n    *string;     /* return a string already stored somewher */\n\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formatted string */\n  string=(char *) NULL;  /* constant string reference */\n  /*\n    Get properities that are directly defined by images.\n  */\n  switch (letter)\n  {\n    case 'b':  /* image size read in - in bytes */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatMagickSize(image->extent,MagickFalse,\"B\",MagickPathExtent,\n        value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n          MagickPathExtent,value);\n      break;\n    }\n    case 'c':  /* image comment property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"comment\",exception);\n      if ( string == (const char *) NULL )\n        string=\"\";\n      break;\n    }\n    case 'd':  /* Directory component of filename */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'e': /* Filename extension (suffix) of image file */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'f': /* Filename without directory component */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'g': /* Image geometry, canvas and offset  %Wx%H+%X+%Y */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n        image->page.height,(double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h': /* Image height (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i': /* Filename last used for an image (read or write) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->filename;\n      break;\n    }\n    case 'k': /* Number of unique colors  */\n    {\n      /*\n        FUTURE: ensure this does not generate the formatted comment!\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,exception));\n      break;\n    }\n    case 'l': /* Image label property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"label\",exception);\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm': /* Image format (file magick) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick;\n      break;\n    }\n    case 'n': /* Number of images in the list.  */\n    {\n      if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          GetImageListLength(image));\n      else\n        string=\"0\";    /* no images or scenes */\n      break;\n    }\n    case 'o': /* Output Filename - for delegate use only */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->filename;\n      break;\n    case 'p': /* Image index in current image list */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q': /* Quantum depth of image in memory */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r': /* Image storage class, colorspace, and alpha enabled.  */\n    {\n      ColorspaceType\n        colorspace;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      colorspace=image->colorspace;\n      if (SetImageGray(image,exception) != MagickFalse)\n        colorspace=GRAYColorspace;   /* FUTURE: this is IMv6 not IMv7 */\n      (void) FormatLocaleString(value,MagickPathExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?\n        \"Alpha\" : \"\");\n      break;\n    }\n    case 's': /* Image scene number */\n    {\n#if 0  /* this seems non-sensical -- simplifing */\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image_info->scene);\n      else if (image != (Image *) NULL)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image->scene);\n      else\n          string=\"0\";\n#else\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n         image->scene);\n#endif\n      break;\n    }\n    case 't': /* Base filename without directory or extention */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,BasePath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'u': /* Unique filename */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->unique;\n      break;\n    }\n    case 'w': /* Image width (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x': /* Image horizontal resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);\n      break;\n    }\n    case 'y': /* Image vertical resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);\n      break;\n    }\n    case 'z': /* Image depth as read in */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->depth);\n      break;\n    }\n    case 'A': /* Image alpha channel  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n        image->alpha_trait);\n      break;\n    }\n    case 'C': /* Image compression method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n        image->compression);\n      break;\n    }\n    case 'D': /* Image dispose method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t)\n        image->dispose);\n      break;\n    }\n    case 'G': /* Image size as geometry = \"%wx%h\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H': /* layer canvas height */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.height);\n      break;\n    }\n    case 'M': /* Magick filename - filename given incl. coder & read mods */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick_filename;\n      break;\n    }\n    case 'O': /* layer canvas offset with sign = \"+%X+%Y\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P': /* layer canvas page size = \"%Wx%H\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q': /* image compression quality */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S': /* Number of scenes in image list.  */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n#if 0 /* What is this number? -- it makes no sense - simplifing */\n      if (image_info->number_scenes == 0)\n         string=\"2147483647\";\n      else if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n                image_info->scene+image_info->number_scenes);\n      else\n        string=\"0\";\n#else\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image_info->number_scenes == 0 ? 2147483647 :\n         image_info->number_scenes));\n#endif\n      break;\n    }\n    case 'T': /* image time delay for animations */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U': /* Image resolution units. */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n        image->units);\n      break;\n    }\n    case 'W': /* layer canvas width */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X': /* layer canvas X offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y': /* layer canvas Y offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case '%': /* percent escaped */\n    {\n      string=\"%\";\n      break;\n    }\n    case '@': /* Trim bounding box, without actually Trimming! */\n    {\n      RectangleInfo\n        page;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      page=GetImageBoundingBox(image,exception);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) page.width,(double) page.height,\n        (double) page.x,(double)page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) SignatureImage(image,exception);\n      string=GetImageProperty(image,\"signature\",exception);\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n\nMagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image,exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual colorspace - no 'gray' stuff */\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)\n            image->compose);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n     break;\n    }\n    case 'p':\n    {\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n       break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result, that will get cleaned up, eventually.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n#undef WarnNoImageReturn\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o p e r t y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProperty() gets the next free-form string property name.\n%\n%  The format of the GetNextImageProperty method is:\n%\n%      char *GetNextImageProperty(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const char *GetNextImageProperty(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((const char *) NULL);\n  return((const char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->properties));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n t e r p r e t I m a g e P r o p e r t i e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageProperties() replaces any embedded formatting characters with\n%  the appropriate image property and returns the interpreted text.\n%\n%  This searches for and replaces\n%     \\n \\r \\%          replaced by newline, return, and percent resp.\n%     &lt; &gt; &amp;   replaced by '<', '>', '&' resp.\n%     %%                replaced by percent\n%\n%     %x %[x]       where 'x' is a single letter properity, case sensitive).\n%     %[type:name]  where 'type' a is special and known prefix.\n%     %[name]       where 'name' is a specifically known attribute, calculated\n%                   value, or a per-image property string name, or a per-image\n%                   'artifact' (as generated from a global option).\n%                   It may contain ':' as long as the prefix is not special.\n%\n%  Single letter % substitutions will only happen if the character before the\n%  percent is NOT a number. But braced substitutions will always be performed.\n%  This prevents the typical usage of percent in a interpreted geometry\n%  argument from being substituted when the percent is a geometry flag.\n%\n%  If 'glob-expresions' ('*' or '?' characters) is used for 'name' it may be\n%  used as a search pattern to print multiple lines of \"name=value\\n\" pairs of\n%  the associacted set of properties.\n%\n%  The returned string must be freed using DestoryString() by the caller.\n%\n%  The format of the InterpretImageProperties method is:\n%\n%      char *InterpretImageProperties(ImageInfo *image_info,\n%        Image *image,const char *embed_text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info. (required)\n%\n%    o image: the image. (optional)\n%\n%    o embed_text: the address of a character string containing the embedded\n%      formatting characters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport char *InterpretImageProperties(ImageInfo *image_info,Image *image,\n  const char *embed_text,ExceptionInfo *exception)\n{\n#define ExtendInterpretText(string_length) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=(string_length); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n   } \\\n} \\\nRestoreMSCWarning\n\n#define AppendKeyValue2Text(key,value)\\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen(key)+strlen(value)+2; \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n     } \\\n   q+=FormatLocaleString(q,extent,\"%s=%s\\n\",(key),(value)); \\\n} \\\nRestoreMSCWarning\n\n#define AppendString2Text(string) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen((string)); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n    } \\\n  (void) CopyMagickString(q,(string),extent); \\\n  q+=length; \\\n} \\\nRestoreMSCWarning\n\n  char\n    *interpret_text;\n\n  MagickBooleanType\n    number;\n\n  register char\n    *q;  /* current position in interpret_text */\n\n  register const char\n    *p;  /* position in embed_text string being expanded */\n\n  size_t\n    extent;  /* allocated length of interpret_text */\n\n  assert(image == NULL || image->signature == MagickCoreSignature);\n  assert(image_info == NULL || image_info->signature == MagickCoreSignature);\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-image\");\n  if (embed_text == (const char *) NULL)\n    return(ConstantString(\"\"));\n  p=embed_text;\n  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\\0'))\n    p++;\n  if (*p == '\\0')\n    return(ConstantString(\"\"));\n  if ((*p == '@') && (IsPathAccessible(p+1) != MagickFalse))\n    {\n      /*\n        Handle a '@' replace string from file.\n      */\n      if (IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,p) == MagickFalse)\n        {\n          errno=EPERM;\n          (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n            \"NotAuthorized\",\"`%s'\",p);\n          return(ConstantString(\"\"));\n        }\n      interpret_text=FileToString(p+1,~0UL,exception);\n      if (interpret_text != (char *) NULL)\n        return(interpret_text);\n    }\n  /*\n    Translate any embedded format characters.\n  */\n  interpret_text=AcquireString(embed_text); /* new string with extra space */\n  extent=MagickPathExtent;                     /* allocated space in string */\n  number=MagickFalse;                       /* is last char a number? */\n  for (q=interpret_text; *p!='\\0'; number=isdigit(*p) ? MagickTrue : MagickFalse,p++)\n  {\n    /*\n      Look for the various escapes, (and handle other specials)\n    */\n    *q='\\0';\n    ExtendInterpretText(MagickPathExtent);\n    switch (*p)\n    {\n      case '\\\\':\n      {\n        switch (*(p+1))\n        {\n          case '\\0':\n            continue;\n          case 'r':  /* convert to RETURN */\n          {\n            *q++='\\r';\n            p++;\n            continue;\n          }\n          case 'n':  /* convert to NEWLINE */\n          {\n            *q++='\\n';\n            p++;\n            continue;\n          }\n          case '\\n':  /* EOL removal UNIX,MacOSX */\n          {\n            p++;\n            continue;\n          }\n          case '\\r':  /* EOL removal DOS,Windows */\n          {\n            p++;\n            if (*p == '\\n') /* return-newline EOL */\n              p++;\n            continue;\n          }\n          default:\n          {\n            p++;\n            *q++=(*p);\n          }\n        }\n        continue;\n      }\n      case '&':\n      {\n        if (LocaleNCompare(\"&lt;\",p,4) == 0)\n          {\n            *q++='<';\n            p+=3;\n          }\n        else\n          if (LocaleNCompare(\"&gt;\",p,4) == 0)\n            {\n              *q++='>';\n              p+=3;\n            }\n          else\n            if (LocaleNCompare(\"&amp;\",p,5) == 0)\n              {\n                *q++='&';\n                p+=4;\n              }\n            else\n              *q++=(*p);\n        continue;\n      }\n      case '%':\n        break;  /* continue to next set of handlers */\n      default:\n      {\n        *q++=(*p);  /* any thing else is 'as normal' */\n        continue;\n      }\n    }\n    p++; /* advance beyond the percent */\n    /*\n      Doubled Percent - or percent at end of string.\n    */\n    if ((*p == '\\0') || (*p == '\\'') || (*p == '\"'))\n      p--;\n    if (*p == '%')\n      {\n        *q++='%';\n        continue;\n      }\n    /*\n      Single letter escapes %c.\n    */\n    if (*p != '[')\n      {\n        const char\n          *string;\n\n        if (number != MagickFalse)\n          {\n            /*\n              But only if not preceeded by a number!\n            */\n            *q++='%'; /* do NOT substitute the percent */\n            p--;      /* back up one */\n            continue;\n          }\n        string=GetMagickPropertyLetter(image_info,image,*p, exception);\n        if (string != (char *) NULL)\n          {\n            AppendString2Text(string);\n            if (image != (Image *) NULL)\n              (void) DeleteImageArtifact(image,\"get-property\");\n            if (image_info != (ImageInfo *) NULL)\n              (void) DeleteImageOption(image_info,\"get-property\");\n            continue;\n          }\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n          \"UnknownImageProperty\",\"\\\"%%%c\\\"\",*p);\n        continue;\n      }\n    {\n      char\n        pattern[2*MagickPathExtent];\n\n      const char\n        *key,\n        *string;\n\n      register ssize_t\n        len;\n\n      ssize_t\n        depth;\n\n      /*\n        Braced Percent Escape %[...].\n      */\n      p++;  /* advance p to just inside the opening brace */\n      depth=1;\n      if (*p == ']')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"UnknownImageProperty\",\"\\\"%%[]\\\"\");\n          break;\n        }\n      for (len=0; len<(MagickPathExtent-1L) && (*p != '\\0');)\n      {\n        if ((*p == '\\\\') && (*(p+1) != '\\0'))\n          {\n            /*\n              Skip escaped braces within braced pattern.\n            */\n            pattern[len++]=(*p++);\n            pattern[len++]=(*p++);\n            continue;\n          }\n        if (*p == '[')\n          depth++;\n        if (*p == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[len++]=(*p++);\n      }\n      pattern[len]='\\0';\n      if (depth != 0)\n        {\n          /*\n            Check for unmatched final ']' for \"%[...]\".\n          */\n          if (len >= 64)\n            {\n              pattern[61] = '.';  /* truncate string for error message */\n              pattern[62] = '.';\n              pattern[63] = '.';\n              pattern[64] = '\\0';\n            }\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"UnbalancedBraces\",\"\\\"%%[%s\\\"\",pattern);\n          interpret_text=DestroyString(interpret_text);\n          return((char *) NULL);\n        }\n      /*\n        Special Lookup Prefixes %[prefix:...].\n      */\n      if (LocaleNCompare(\"fx:\",pattern,3) == 0)\n        {\n          double\n            value;\n\n          FxInfo\n            *fx_info;\n\n          MagickBooleanType\n            status;\n\n          /*\n            FX - value calculator.\n          */\n          if (image == (Image *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          fx_info=AcquireFxInfo(image,pattern+3,exception);\n          status=FxEvaluateChannelExpression(fx_info,IntensityPixelChannel,0,0,\n            &value,exception);\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%.*g\",\n                GetMagickPrecision(),(double) value);\n              AppendString2Text(result);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"pixel:\",pattern,6) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          GetPixelInfo(image,&pixel);\n          fx_info=AcquireFxInfo(image,pattern+6,exception);\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                name[MagickPathExtent];\n\n              (void) QueryColorname(image,&pixel,SVGCompliance,name,\n                exception);\n              AppendString2Text(name);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"option:\",pattern,7) == 0)\n        {\n          /*\n            Option - direct global option lookup (with globbing).\n          */\n          if (image_info == (ImageInfo *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+7) != MagickFalse)\n            {\n              ResetImageOptionIterator(image_info);\n              while ((key=GetNextImageOption(image_info)) != (const char *) NULL)\n                if (GlobExpression(key,pattern+7,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageOption(image_info,key);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? key found but no string value! */\n                  }\n              continue;\n            }\n          string=GetImageOption(image_info,pattern+7);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"artifact:\",pattern,9) == 0)\n        {\n          /*\n            Artifact - direct image artifact lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImageArtifactIterator(image);\n              while ((key=GetNextImageArtifact(image)) != (const char *) NULL)\n              if (GlobExpression(key,pattern+9,MagickTrue) != MagickFalse)\n                {\n                  string=GetImageArtifact(image,key);\n                  if (string != (const char *) NULL)\n                    AppendKeyValue2Text(key,string);\n                  /* else - assertion failure? key found but no string value! */\n                }\n              continue;\n            }\n          string=GetImageArtifact(image,pattern+9);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"property:\",pattern,9) == 0)\n        {\n          /*\n            Property - direct image property lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImagePropertyIterator(image);\n              while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n                if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageProperty(image,key,exception);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? */\n                  }\n              continue;\n            }\n          string=GetImageProperty(image,pattern+9,exception);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (image != (Image *) NULL)\n        {\n          /*\n            Properties without special prefix.  This handles attributes,\n            properties, and profiles such as %[exif:...].  Note the profile\n            properties may also include a glob expansion pattern.\n          */\n          string=GetImageProperty(image,pattern,exception);\n          if (string != (const char *) NULL)\n            {\n              AppendString2Text(string);\n              if (image != (Image *) NULL)\n                (void)DeleteImageArtifact(image,\"get-property\");\n              if (image_info != (ImageInfo *) NULL)\n                (void)DeleteImageOption(image_info,\"get-property\");\n              continue;\n            }\n        }\n      if (IsGlob(pattern) != MagickFalse)\n        {\n          /*\n            Handle property 'glob' patterns such as:\n            %[*] %[user:array_??] %[filename:e*]>\n          */\n          if (image == (Image *) NULL)\n            continue; /* else no image to retrieve proprty - no list */\n          ResetImagePropertyIterator(image);\n          while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n            if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n              {\n                string=GetImageProperty(image,key,exception);\n                if (string != (const char *) NULL)\n                  AppendKeyValue2Text(key,string);\n                /* else - assertion failure? */\n              }\n          continue;\n        }\n      /*\n        Look for a known property or image attribute such as\n        %[basename] %[denisty] %[delay].  Also handles a braced single\n        letter: %[b] %[G] %[g].\n      */\n      string=GetMagickProperty(image_info,image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Look for a per-image artifact. This includes option lookup\n        (FUTURE: interpreted according to image).\n      */\n      if (image != (Image *) NULL)\n        {\n          string=GetImageArtifact(image,pattern);\n          if (string != (char *) NULL)\n            {\n              AppendString2Text(string);\n              continue;\n            }\n        }\n      else\n        if (image_info != (ImageInfo *) NULL)\n          {\n            /*\n              No image, so direct 'option' lookup (no delayed percent escapes).\n            */\n            string=GetImageOption(image_info,pattern);\n            if (string != (char *) NULL)\n              {\n                AppendString2Text(string);\n                continue;\n              }\n          }\nPropertyLookupFailure:\n      /*\n        Failed to find any match anywhere!\n      */\n      if (len >= 64)\n        {\n          pattern[61] = '.';  /* truncate string for error message */\n          pattern[62] = '.';\n          pattern[63] = '.';\n          pattern[64] = '\\0';\n        }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"UnknownImageProperty\",\"\\\"%%[%s]\\\"\",pattern);\n    }\n  }\n  *q='\\0';\n  return(interpret_text);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProperty() removes a property from the image and returns its\n%  value.\n%\n%  In this case the ConstantString() value returned should be freed by the\n%  caller when finished.\n%\n%  The format of the RemoveImageProperty method is:\n%\n%      char *RemoveImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport char *RemoveImageProperty(Image *image,const char *property)\n{\n  char\n    *value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return((char *) NULL);\n  value=(char *) RemoveNodeFromSplayTree((SplayTreeInfo *) image->properties,\n    property);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P r o p e r t y I t e r a t o r                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePropertyIterator() resets the image properties iterator.  Use it\n%  in conjunction with GetNextImageProperty() to iterate over all the values\n%  associated with an image property.\n%\n%  The format of the ResetImagePropertyIterator method is:\n%\n%      ResetImagePropertyIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImagePropertyIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProperty() saves the given string value either to specific known\n%  attribute or to a freeform property string.\n%\n%  Attempting to set a property that is normally calculated will produce\n%  an exception.\n%\n%  The format of the SetImageProperty method is:\n%\n%      MagickBooleanType SetImageProperty(Image *image,const char *property,\n%        const char *value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o values: the image property values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n    {\n      /*\n        Do not 'set' single letter properties - read only shorthand.\n      */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"SetReadOnlyProperty\",\"`%s'\",property);\n      return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ((LocaleCompare(\"magick\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0) ||\n          (LocaleCompare(\"mean\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ((LocaleCompare(\"size\",property) == 0) ||\n          (LocaleCompare(\"skewness\",property) == 0) ||\n          (LocaleCompare(\"scenes\",property) == 0) ||\n          (LocaleCompare(\"standard-deviation\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include \"tiffconf.h\"\n# endif\n# include \"tiff.h\"\n# include \"tiffio.h\"\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadSingleSampleMethod,\n  ReadRGBAMethod,\n  ReadCMYKAMethod,\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 0, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n#endif  /* MAGICKCORE_TIFF_DELEGATE */\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(long) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic void TIFFGetProfiles(TIFF *tiff,Image *image,MagickBooleanType ping,\n  ExceptionInfo *exception)\n{\n  uint32\n    length;\n\n  unsigned char\n    *profile;\n\n  length=0;\n  if (ping == MagickFalse)\n    {\n#if defined(TIFFTAG_ICCPROFILE)\n      if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n      if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n      if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          (void) ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n      if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n#endif\n      if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n          exception);\n    }\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n}\n\nstatic void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:document\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"comment\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:make\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:model\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"label\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:software\",text,exception);\n  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&\n      (tietz != (unsigned long *) NULL))\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\n    }\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MagickPathExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  sans=NULL;\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,&sans,&sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MagickPathExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,&sans,&sans) == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",shorty);\n          }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              &sans,&sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",(double)\n            floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value,exception);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,size_t bits_per_sample,\n  tsample_t sample,ssize_t row,tdata_t scanline)\n{\n  int32\n    status;\n\n  (void) bits_per_sample;\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    **value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /* only support 8 bit for now */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /* Search for Adobe APP14 JPEG Marker */\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value))\n    return(ReadRGBAMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadRGBAMethod);\n  method=ReadRGBAMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic void TIFFReadPhotoshopLayers(Image* image,const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *layer_info;\n\n  Image\n    *layers;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  layer_info=GetImageProfile(image,\"tiff:37724\");\n  if (layer_info == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) layer_info->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (layer_info->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (layer_info->length-8))\n    return;\n  layers=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachBlob(layers->blob,layer_info->datum,layer_info->length);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  info.version=1;\n  info.columns=layers->columns;\n  info.rows=layers->rows;\n  info.channels=(unsigned short) layers->number_channels;\n  /* Setting the mode to a value that won't change the colorspace */\n  info.mode=10;\n  ReadPSDLayers(layers,image_info,&info,MagickFalse,exception);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  do\n  {\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\nRestoreMSCWarning\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      SetImageColorspace(image,GRAYColorspace,exception);\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      SetImageColorspace(image,CMYKColorspace,exception);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      SetImageColorspace(image,LabColorspace,exception);\n    TIFFGetProfiles(tiff,image,image_info->ping,exception);\n    TIFFGetProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      TIFFGetEXIFProperties(tiff,image,exception);\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n      &samples_per_pixel);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                  exception);\n          }\n      }\n    method=ReadGenericMethod;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MagickPathExtent];\n\n        method=ReadStripMethod;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value,exception);\n      }\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))\n      method=ReadRGBAMethod;\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))\n      method=ReadCMYKAMethod;\n    if ((photometric != PHOTOMETRIC_RGB) &&\n        (photometric != PHOTOMETRIC_CIELAB) &&\n        (photometric != PHOTOMETRIC_SEPARATED))\n      method=ReadGenericMethod;\n    if (image->storage_class == PseudoClass)\n      method=ReadSingleSampleMethod;\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      method=ReadSingleSampleMethod;\n    if ((photometric != PHOTOMETRIC_SEPARATED) &&\n        (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (compress_tag == COMPRESSION_JBIG)\n      method=ReadStripMethod;\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      method=ReadTileMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (method)\n    {\n      case ReadSingleSampleMethod:\n      {\n        /*\n          Convert TIFF image to PseudoClass MIFF image.\n        */\n        quantum_type=IndexQuantum;\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class != PseudoClass)\n              {\n                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                  GrayAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n            else\n              {\n                quantum_type=IndexAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n          }\n        else\n          if (image->storage_class != PseudoClass)\n            {\n              quantum_type=GrayQuantum;\n              pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n            }\n        status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(\n          bits_per_sample)/log(2))));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadRGBAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadCMYKAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register Quantum\n              *magick_restrict q;\n\n            int\n              status;\n\n            status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)\n              pixels);\n            if (status == -1)\n              break;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (image->colorspace != CMYKColorspace)\n              switch (i)\n              {\n                case 0: quantum_type=RedQuantum; break;\n                case 1: quantum_type=GreenQuantum; break;\n                case 2: quantum_type=BlueQuantum; break;\n                case 3: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            else\n              switch (i)\n              {\n                case 0: quantum_type=CyanQuantum; break;\n                case 1: quantum_type=MagentaQuantum; break;\n                case 2: quantum_type=YellowQuantum; break;\n                case 3: quantum_type=BlackQuantum; break;\n                case 4: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadYCCKMethod:\n      {\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register uint32\n          *p;\n\n        /*\n          Convert stripped TIFF image to DirectClass MIFF image.\n        */\n        i=0;\n        p=(uint32 *) NULL;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          if (i == 0)\n            {\n              if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)\n                break;\n              i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)\n                image->rows-y);\n            }\n          i--;\n          p=((uint32 *) pixels)+image->columns*i;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetR(*p))),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetG(*p))),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetB(*p))),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                (TIFFGetA(*p))),q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register uint32\n          *p;\n\n        uint32\n          *tile_pixels,\n          columns,\n          rows;\n\n        /*\n          Convert tiled TIFF image to DirectClass MIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(CoderError,\"ImageIsNotTiled\");\n          }\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*\n          sizeof(*tile_pixels));\n        if (tile_pixels == (uint32 *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (y=0; y < (ssize_t) image->rows; y+=rows)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q,\n            *magick_restrict tile;\n\n          size_t\n            columns_remaining,\n            rows_remaining;\n\n          rows_remaining=image->rows-y;\n          if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n            rows_remaining=rows;\n          tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,\n            exception);\n          if (tile == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=columns)\n          {\n            size_t\n              column,\n              row;\n\n            if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)\n              break;\n            columns_remaining=image->columns-x;\n            if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n              columns_remaining=columns;\n            p=tile_pixels+(rows-rows_remaining)*columns;\n            q=tile+GetPixelChannels(image)*(image->columns*(rows_remaining-1)+\n              x);\n            for (row=rows_remaining; row > 0; row--)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetA(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              else\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              p+=columns-columns_remaining;\n              q-=GetPixelChannels(image)*(image->columns+columns_remaining);\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *pixel_info;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n          sizeof(uint32));\n        if (pixel_info == (MemoryInfo *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        p=pixels+number_pixels-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (status != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while (status != MagickFalse);\n  TIFFClose(tiff);\n  TIFFReadPhotoshopLayers(image,image_info,exception);\n  if (image_info->number_scenes != 0)\n    {\n      if (image_info->scene >= GetImageListLength(image))\n        {\n          /* Subimage was not found in the Photoshop layer */\n          image=DestroyImageList(image);\n          return((Image *)NULL);\n        }\n    }\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  images=GetFirstImageInList(images);\n  /*\n    Write pyramid-encoded TIFF image.\n  */\n  write_info=CloneImageInfo(image_info);\n  write_info->adjoin=MagickTrue;\n  (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n  (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n  status=WriteTIFFImage(write_info,images,exception);\n  images=DestroyImageList(images);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) ResetMagickMemory(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    {\n      uint32\n        rows_per_strip;\n\n      option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n      if (option != (const char *) NULL)\n        rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n      else\n        if (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&rows_per_strip) == 0)\n          rows_per_strip=0;  /* use default */\n      rows_per_strip=TIFFDefaultStripSize(tiff,rows_per_strip);\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      return(MagickTrue);\n    }\n  /*\n    Create tiled TIFF, ignore \"tiff:rows-per-strip\".\n  */\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) CopyMagickMemory(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property,exception);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n\n\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (image->colorspace == YCbCrColorspace)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n                }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT  X   X  TTTTT                              %\n%                              T     X X     T                                %\n%                              T      X      T                                %\n%                              T     X X     T                                %\n%                              T    X   X    T                                %\n%                                                                             %\n%                                                                             %\n%                      Render Text Onto A Canvas Image.                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTXTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T X T                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTXT() returns MagickTrue if the image format type, identified by the magick\n%  string, is TXT.\n%\n%  The format of the IsTXT method is:\n%\n%      MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n\n  char\n    colorspace[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  unsigned long\n    columns,\n    depth,\n    rows;\n\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T E X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTEXTImage() reads a text file and returns it as an image.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTEXTImage method is:\n%\n%      Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\n%        char *text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o text: the text storage buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTEXTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *p,\n    text[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image,\n    *texture;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    offset;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  /*\n    Set the page geometry.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  page.width=612;\n  page.height=792;\n  page.x=43;\n  page.y=43;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  /*\n    Initialize Image structure.\n  */\n  image->columns=(size_t) floor((((double) page.width*image->resolution.x)/\n    delta.x)+0.5);\n  image->rows=(size_t) floor((((double) page.height*image->resolution.y)/\n    delta.y)+0.5);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  image->page.x=0;\n  image->page.y=0;\n  texture=(Image *) NULL;\n  if (image_info->texture != (char *) NULL)\n    {\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) CopyMagickString(read_info->filename,image_info->texture,\n        MagickPathExtent);\n      texture=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n    }\n  /*\n    Annotate the text image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,image_info->filename);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=GetTypeMetrics(image,draw_info,&metrics,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\n  page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  (void) CopyMagickString(filename,image_info->filename,MagickPathExtent);\n  if (*draw_info->text != '\\0')\n    *draw_info->text='\\0';\n  p=text;\n  for (offset=2*page.y; p != (char *) NULL; )\n  {\n    /*\n      Annotate image with text.\n    */\n    (void) ConcatenateString(&draw_info->text,text);\n    (void) ConcatenateString(&draw_info->text,\"\\n\");\n    offset+=(ssize_t) (metrics.ascent-metrics.descent);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) offset,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    p=ReadBlobString(image,text);\n    if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\n      continue;\n    if (texture != (Image *) NULL)\n      {\n        MagickProgressMonitor\n          progress_monitor;\n\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) TextureImage(image,texture,exception);\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n      }\n    (void) AnnotateImage(image,draw_info,exception);\n    if (p == (char *) NULL)\n      break;\n    /*\n      Page is full-- allocate next image structure.\n    */\n    *draw_info->text='\\0';\n    offset=2*page.y;\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image->next->columns=image->columns;\n    image->next->rows=image->rows;\n    image=SyncNextImageInList(image);\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    (void) SetImageBackgroundColor(image,exception);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (texture != (Image *) NULL)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      progress_monitor=SetImageProgressMonitor(image,\n        (MagickProgressMonitor) NULL,image->client_data);\n      (void) TextureImage(image,texture,exception);\n      (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    }\n  (void) AnnotateImage(image,draw_info,exception);\n  if (texture != (Image *) NULL)\n    texture=DestroyImage(texture);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T X T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTXTImage() reads a text file and returns it as an image.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadTXTImage method is:\n%\n%      Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T X T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTXTImage() adds attributes for the TXT image format to the\n%  list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTXTImage method is:\n%\n%      size_t RegisterTXTImage(void)\n%\n*/\nModuleExport size_t RegisterTXTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TXT\",\"SPARSE-COLOR\",\"Sparse Color\");\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TEXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTEXTImage;\n  entry->format_type=ImplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTXTImage;\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->magick=(IsImageFormatHandler *) IsTXT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T X T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTXTImage() removes format registrations made by the\n%  TXT module from the list of supported format.\n%\n%  The format of the UnregisterTXTImage method is:\n%\n%      UnregisterTXTImage(void)\n%\n*/\nModuleExport void UnregisterTXTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SPARSE-COLOR\");\n  (void) UnregisterMagickInfo(\"TEXT\");\n  (void) UnregisterMagickInfo(\"TXT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTXTImage writes the pixel values as text numbers.\n%\n%  The format of the WriteTXTImage method is:\n%\n%      MagickBooleanType WriteTXTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    colorspace[MagickPathExtent],\n    tuple[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    ComplianceType\n      compliance;\n\n    const char\n      *value;\n\n    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(\n      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);\n    LocaleLower(colorspace);\n    image->depth=GetImageQuantumDepth(image,MagickTrue);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) ConcatenateMagickString(colorspace,\"a\",MagickPathExtent);\n    compliance=NoCompliance;\n    value=GetImageOption(image_info,\"txt:compliance\");\n    if (value != (char *) NULL)\n      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,\n        MagickFalse,value);\n    if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") != 0)\n      {\n        size_t\n          depth;\n\n        depth=compliance == SVGCompliance ? image->depth :\n          MAGICKCORE_QUANTUM_DEPTH;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\\n\",(double)\n          image->columns,(double) image->rows,(double) ((MagickOffsetType)\n          GetQuantumRange(depth)),colorspace);\n        (void) WriteBlobString(image,buffer);\n      }\n    GetPixelInfo(image,&pixel);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        GetPixelInfoPixel(image,p,&pixel);\n        if (pixel.colorspace == LabColorspace)\n          {\n            pixel.green-=(QuantumRange+1)/2.0;\n            pixel.blue-=(QuantumRange+1)/2.0;\n          }\n        if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") == 0)\n          {\n            /*\n              Sparse-color format.\n            */\n            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)\n              {\n                GetColorTuple(&pixel,MagickFalse,tuple);\n                (void) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%.20g,%.20g,\",(double) x,(double) y);\n                (void) WriteBlobString(image,buffer);\n                (void) WriteBlobString(image,tuple);\n                (void) WriteBlobString(image,\" \");\n              }\n            p+=GetPixelChannels(image);\n            continue;\n          }\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g,%.20g: \",\n          (double) x,(double) y);\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n        if (pixel.colorspace == GRAYColorspace)\n          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n        else\n          {\n            ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,\n              tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);\n          }\n        if (pixel.colorspace == CMYKColorspace)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,\n              tuple);\n          }\n        if (pixel.alpha_trait != UndefinedPixelTrait)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,\n              tuple);\n          }\n        (void) ConcatenateMagickString(tuple,\")\",MagickPathExtent);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"  \");\n        GetColorTuple(&pixel,MagickTrue,tuple);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%s\",tuple);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"  \");\n        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"\\n\");\n        p+=GetPixelChannels(image);\n      }\n      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n        image->rows);\n      if (status == MagickFalse)\n        break;\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "buggy_code_start_loc": [219, 640, 804], "buggy_code_end_loc": [3979, 705, 806], "fixing_code_start_loc": [219, 640, 804], "fixing_code_end_loc": [3979, 718, 805], "type": "CWE-476", "message": "coders/tiff.c in ImageMagick before 7.0.3.7 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted image.", "other": {"cve": {"id": "CVE-2016-9559", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-01T15:59:00.383", "lastModified": "2021-04-28T19:21:16.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "coders/tiff.c in ImageMagick before 7.0.3.7 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted image."}, {"lang": "es", "value": "coders/tiff.c en ImageMagick en versiones anteriores a 7.0.3.7 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda) a trav\u00e9s de una imagen manipulada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.6-5", "matchCriteriaId": "F30626A9-B511-4DA4-B48E-D2843785C187"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.3-7", "matchCriteriaId": "ACA6D542-44E0-4B8A-A71C-0FA03FEC80E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3726", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/19/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/23/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94489", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blogs.gentoo.org/ago/2016/11/19/imagemagick-null-pointer-must-never-be-null-tiff-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/298", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"}}