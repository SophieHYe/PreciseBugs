{"buggy_code": ["2020-11-30  7.0.10-45  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-45 GIT revision 17972:6c0cb7f72:20201130\n\n2020-11-30  7.0.10-45  Dirk Lemstra <dirk@lem.....org>\n  * added support for the farbfeld format (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2664).\n\n2020-11-29  7.0.10-45  <quetzlzacatenango@image...>\n  * specify the bilateral neighbor as width/height rather than radius/sigma.\n\n2020-11-28  7.0.10-44  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-44 GIT revision 17948:7e96e9fdd:20201128\n\n2020-11-26  7.0.10-44  Dirk Lemstra <dirk@lem.....org>\n  * correct reading of first row in TIFF decoder.\n\n2020-11-24  7.0.10-44  <quetzlzacatenango@image...>\n  * correct rotation parameter for SVG transform.\n\n2020-11-23  7.0.10-43  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-43 GIT revision 17885:be852878e:20201123\n\n2020-11-23  7.0.10-43  <quetzlzacatenango@image...>\n  * add padding to AcquirePolicyString().\n\n2020-11-22  7.0.10-42  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-42 GIT revision 17881:d228ef95e:20201122\n\n2020-11-21  7.0.10-42  <quetzlzacatenango@image...>\n  * revert memory patch to avert possible thread lock.\n  * add support for FilmLight FL32 image format.\n\n2020-11-20  7.0.10-40  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-40 GIT revision 17860:2594cd0a5:20201120 \n\n2020-11-19  7.0.10-40  <quetzlzacatenango@image...>\n  * remove Linux shell artifact from Windows delegate configuration file.\n  * fix shell injection vulnerability via the -authenticate option (reference\n    alex@cure...).\n\n2020-11-17  7.0.10-39  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-39 GIT revision 17837:ffb8da39c:20201117\n\n2020-11-07  7.0.10-39  <quetzlzacatenango@image...>\n  * support DPX 4:2:2 sampling.\n\n2020-11-14  7.0.10-38  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-38 GIT revision 17815:bf51a3f1f:20201114\n\n2020-11-07  7.0.10-38  <quetzlzacatenango@image...>\n  * add image settings support to -fx.\n  * better support for TIFF YCbCr photometric.\n  * verify TTF glyph format before dereferencing (reference\n    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26932).\n  * force single HEIC image per container.\n\n2020-11-07  7.0.10-37  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-37 GIT revision 17780:47a8392ef:20201107\n\n2020-11-07  7.0.10-37  <quetzlzacatenango@image...>\n  * correct soversioning.\n\n2020-11-07  7.0.10-36  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-36 GIT revision 17776:6bb35345c:20201107\n\n2020-11-02  7.0.10-36  <quetzlzacatenango@image...>\n  * check and report if profile is corrupt.\n  * do not add entropy based on mkstemp() unique filename.\n\n2020-10-31  7.0.10-35  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-35 GIT revision 17762:df5df8489:20201031\n\n2020-10-14  7.0.10-35  <quetzlzacatenango@image...>\n  * Prefer ffmpeg over avconv.\n  * Support median image statistic and median property.\n  * Add -extend option to {display,animate,import}.\n  * Support papersize property, e.g. [%papersize:A5].\n\n2020-10-07  7.0.10-34  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-34 GIT revision 17695:de3284341:20201008\n\n2020-10-05  7.0.10-34  <quetzlzacatenango@image...>\n  * Check for linux-compatible sendfile().\n\n2020-10-04  7.0.10-33  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-33 GIT revision 17683:c1bfec283:20201004\n\n2020-10-04  7.0.10-33  <quetzlzacatenango@image...>\n  * Miscellaneous clean-up.\n\n2020-10-02  7.0.10-32  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-32 GIT revision 17670:1686dd921:20201002 \n\n2020-09-27  7.0.10-32  <quetzlzacatenango@image...>\n  * enable WMF for module build.\n  * writing PDF requires a seekable stream.\n\n2020-09-27  7.0.10-31  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-31 GIT revision 17652:78ad905d9:20200926\n\n2020-09-20  7.0.10-31  <quetzlzacatenango@image...>\n  * Add support for APNG (specify explicitly, e.g. apng:animate.png).\n  * Add support for WEBM.\n\n2020-09-19  7.0.10-30  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-30 GIT revision 17641:ab95f7264:20200919\n\n2020-09-15  7.0.10-30 Dirk Lemstra <dirk@lem.....org>\n  * Fixed registry lookup of GhostScript that now writes the patch version to the\n    registry (reference https://github.com/ImageMagick/ImageMagick/issues/2571).\n\n2020-09-07  7.0.10-30  <quetzlzacatenango@image...>\n  * Add endian support to JSON coder.\n  * Regression: MapCache type cache allocation skipped (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/97).\n  * Some DCM images include a thumbnail (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2558).\n\n2020-09-05  7.0.10-29  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-29 GIT revision 17580:fc52fa0a9:20200905\n\n2020-09-05  7.0.10-29  <quetzlzacatenango@image...>\n  * Eliminate infinite loop for certain SVG styles (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/96).\n  * Add version element to JSON file format (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/91).\n\n2020-09-01  7.0.10-29 Dirk Lemstra <dirk@lem.....org>\n  * Enabled support for AVIF encoding on Windows.\n  * Clip path in 8bim profile is updated when the image is extended. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2414)\n\n2020-08-16  7.0.10-28  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-28 GIT revision 17533:41e79fc33:20200816\n\n2020-08-16  7.0.10-28  <quetzlzacatenango@image...>\n  * Distorted clip path after -extent (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2414).\n  * Paths in Photoshop EPS files are corrupted on conversion (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2413).\n\n2020-08-09  7.0.10-27  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-27 GIT revision 17525:ae6ace83c:20200809\n\n2020-08-08  7.0.10-27  <quetzlzacatenango@image...>\n  * fix regression when detecting the libz delegate library.\n\n2020-08-08  7.0.10-26  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-26 GIT revision 17520:9c2744359:20200808\n\n2020-08-02  7.0.10-26  <quetzlzacatenango@image...>\n  * Add animated webp blend method support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2351).\n  * Add support for OpenRaster (.ora) image format (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2342).\n  * Paths in Photoshop EPS files are no longer corrupted (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2380).\n\n2020-07-31  7.0.10-25  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-25 GIT revision 17497:0e12ff687:20200731\n\n2020-07-25  7.0.10-25  <quetzlzacatenango@image...>\n  * Remove UseCIEColor setting from PDF code as its use is not recommended.\n  * Update to the latest documentation.\n\n2020-07-18  7.0.10-24  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-24 GIT revision 17483:d11a2ec03:20200718\n\n2020-07-18  7.0.10-24 Dirk Lemstra <dirk@lem.....org>\n  * To preserve compression of input image with the tiff encoder use:\n    -define tiff:preserve-compression=true.\n\n2020-07-05  7.0.10-24  <quetzlzacatenango@image...>\n  * Add support for the -white-balance command-line option.\n  * Discover hidden files when globbing (e.g. *.jpg) (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2239).\n  * New inverse-log evaluate operator.\n\n2020-07-04  7.0.10-23  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-23 GIT revision 17437:894231bc3:20200704\n\n2020-06-28  7.0.10-23  <quetzlzacatenango@image...>\n  * Ensure that float is valid in ClampToQuantum() (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2219).\n  * New pseudo-image format, ashlar, e.g.\n    convert *.jpg -resize 320x320 ashlar:canvas.png).\n\n2020-06-27  7.0.10-22  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-22 GIT revision 17415:5318a3e0a:20200627\n\n2020-06-24  7.0.10-22  <quetzlzacatenango@image...>\n  * Fix wrapping of caption (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2178).\n  * Sanity check of affine matrix when drawing.\n\n2020-06-22  7.0.10-21  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-21 GIT revision 17395:af81c28c9:20200622\n\n2020-06-21  7.0.10-21  <quetzlzacatenango@image...>\n  * New image property, %N, only report the # of frames in an image sequence,\n    just once rather than on a per frame basis\n  * Problems converting CMYK to RGB regression (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/83)\n\n2020-06-21  7.0.10-21 Dirk Lemstra <dirk@lem.....org>\n  * Added support for 32 bit zip with prediction format to the PSD decoder\n    (reference https://github.com/ImageMagick/ImageMagick/issues/455).\n\n2020-06-20  7.0.10-20  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-20 GIT revision 17372:d91c43f3b:20200620\n\n2020-06-14  7.0.10-20  <quetzlzacatenango@image...>\n  * Fix out-of-bounds vulnerability when reading sixel images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2143).\n  * Fix incorrect parsing of font family list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2153).\n\n2020-06-12  7.0.10-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-19, GIT revision 17343:e552d22:20200612\n\n2020-06-09  7.0.10-19 Cristy  <quetzlzacatenango@image...>\n  * Improve checking for write failures (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2081).\n\n2020-06-08  7.0.10-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-18, GIT revision 17333:d071c2032:20200608\n\n2020-06-08  7.0.10-18 Cristy  <quetzlzacatenango@image...>\n  * Colorspace change will remove ICC profile (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/82).\n\n2020-06-07  7.0.10-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-17, GIT revision 17311:8b5350f:20200607\n\n2020-06-03  7.0.10-17 Cristy  <quetzlzacatenango@image...>\n  * Free up memory after a ICC profile is removed.\n\n2020-05-31  7.0.10-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-16, GIT revision 17294:5be1abe:20200531\n\n2020-05-30  7.0.10-16 Cristy  <quetzlzacatenango@image...>\n  * Fix PDF XREF directory for image sequences with and without ICC profiles.\n\n2020-05-29  7.0.10-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-15, GIT revision 17282:9294896:20200529\n\n2020-05-24  7.0.10-15 Cristy  <quetzlzacatenango@image...>\n  * Clipping was not returning expected results (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2061).\n  * Don't write a ICC profile to PDF if the image is gray (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2070).\n\n2020-05-22  7.0.10-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-14, GIT revision 17268:e9c804c93:20200522\n\n2020-05-22  7.0.10-14 Cristy  <quetzlzacatenango@image...>\n  * Errant warning when reading a profile file (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2030).\n   * Fix one off error on PDF object for images with ICC profile.\n\n2020-05-17  7.0.10-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-13, GIT revision 17257:e3b442c:20200517.\n\n2020-05-17  7.0.10-13 Cristy  <quetzlzacatenango@image...>\n  * Remove errant debugging statement in SVG coder.\n\n2020-05-15  7.0.10-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-12, GIT revision 17242:e14b3fb:20200515.\n\n2020-05-12  7.0.10-12 Cristy  <quetzlzacatenango@image...>\n  * Black artefacts during quantization (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2007#discussioncomment-13546).\n\n2020-05-08  7.0.10-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-11, GIT revision 17230:088df0e:20200508.\n\n2020-04-28  7.0.10-11 Cristy  <quetzlzacatenango@image...>\n  * Disable \"random\" OpenCL kernel.  Previously the work load was distributed\n    but each started with the same random seed.\n  * Finished implementation of -distort rigid-affine.\n  * Enable threaded PNG coder.\n\n2020-04-27  7.0.10-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-10, GIT revision 17205:9b0340e:20200427\n\n2020-04-27  7.0.10-10 Cristy  <quetzlzacatenango@image...>\n  * Correction to allocate a colormap of the maximum colors when color\n    reducing an image sequence.\n  * Write to stdout for mp4:-.\n\n2020-04-25  7.0.10-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-9, GIT revision 17190:13fdcd1:20200426.\n\n2020-04-25  7.0.10-9 Cristy  <quetzlzacatenango@image...>\n  * Allocate a colormap of the maximum colors when color reducing an image\n    sequence.\n  * Label was not centered properly (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1879).\n\n2020-04-24  7.0.10-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-8, GIT revision 17175:481b85f:20200424.\n\n2020-04-23  7.0.10-8 Cristy  <quetzlzacatenango@image...>\n  * Some configure --with-method-prefix methods were missing (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1912).\n\n2020-04-19  7.0.10-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-7, GIT revision 17170:c635e88:20200419.\n\n2020-04-07  7.0.10-7 Cristy  <quetzlzacatenango@image...>\n  * Fix erroneous \"insufficient image data\" exception (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1883).\n  * Fix an unconditional jump for the XPM coder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1895).\n  * Improve unrotate value returned by the minimum bounding box (thanks\n    to Fred Weinhaus).\n\n    https://github.com/ImageMagick/ImageMagick/discussions/1880).\n2020-04-06  7.0.10-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-6, GIT revision 17146:634bbfd:20200406.\n\n2020-04-05  7.0.10-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-5, GIT revision 17143:8be18423e:20200405.\n\n2020-04-05  7.0.10-5 Cristy  <quetzlzacatenango@image...>\n * Default inkscape delegate to version 0.92 (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/1880).\n  * Set monochrome image depth to 1 for Group4 compression.\n\n2020-04-05  7.0.10-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-4, GIT revision 17137:eeff0b6:20200405\n\n2020-03-28  7.0.10-4 Cristy  <quetzlzacatenango@image...>\n  * The X max attribute for certain fonts is zero (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37723).\n  * Multi-value of jp2:quality does not work (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1873).\n  * Return EPS & TIFF images from the EPT image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37781).\n\n2020-03-27  7.0.10-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-3, GIT revision 17108:5a4f5a9:20200327.\n\n2020-03-22  7.0.10-3 Cristy  <quetzlzacatenango@image...>\n  * The -charcoal option should ignore the alpha channel.\n  * Fix numerical instability issue when drawing lines\n  * Improve mono font rendering (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37723).\n\n2020-03-21  7.0.10-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-2, GIT revision 17088:ed6f37f:20200322.\n\n2020-03-16  7.0.10-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed another sizing issue with the label coder when pointsize is set.\n  * Respect explicit image filename modified (e.g. png24:im.png) (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1835).\n  * Add support for returning the minimum bounding box of an image with the\n    %[minimum-bounding-box] property.\n  * Stroked dash array render properly again.\n\n2020-03-15  7.0.10-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-1, GIT revision 17065:130e52e:20200315.\n\n2020-03-14  7.0.10-1 Cristy  <quetzlzacatenango@image...>\n  * Add support for returning the convex hull of an image with the\n    %[canvas-hull] property.\n\n2020-03-09  7.0.10-1 Dirk Lemstra <dirk@lem.....org>\n  * Added option to specify the preferred version when writing a PDF file with\n    -define pdf:version=version (e.g. 1.7).\n\n2020-03-07  7.0.10-1 Cristy  <quetzlzacatenango@image...>\n  * Do not throw exception on empty draw path (reference\n    https://github.com/ImageMagick/ImageMagick/issues/974).\n  * Fix possible buffer overflow in ComplexImages().\n  * SVG to MVG requires transforms to appear before clipping paths (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1860).\n\n2020-03-06  7.0.10-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-0, GIT revision 17026:fd430ac9a:20200307\n\n2020-03-01  7.0.10-0 Cristy  <quetzlzacatenango@image...>\n  * Label text no longer gets cut-off (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37621).\n  * Prevent heap overflow (reference\n     https://github.com/ImageMagick/ImageMagick/issues/1857).\n\n2020-02-29  7.0.9-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-27, GIT revision 17006:49d81b672:20200229\n\n2020-02-24  7.0.9-27 Cristy  <quetzlzacatenango@image...>\n  * Make sure we can grok this Fx expression: 1- -2.\n  * Do not advance when substituting a NULL string.\n  * Correct alpha for named colors in the Q32 non-HDRI build.\n  * Write Group4 compressed image as a single strip.\n\n2020-02-23  7.0.9-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-26, GIT revision 16972:49f1e4de2:20200223\n\n2020-02-22  7.0.9-26 Cristy  <quetzlzacatenango@image...>\n  * No percent sign in lab() color.\n  * Introducing the -color-threshold command-line option.\n  * Handle out of range HDRI values for -statistic option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37589).\n  * Fix improper casting when computing image signature (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37594).\n\n2020-02-21  7.0.9-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-25, GIT revision 16931:2a56db8:20200221\n\n2020-02-18  7.0.9-25 Cristy  <quetzlzacatenango@image...>\n  * Adapt to a change in command-line options in the SVG inkscape delegate.\n\n2020-02-17  7.0.9-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-24, GIT revision 16919:41efef9de:20200217\n\n2020-02-15  7.0.9-24 Cristy  <quetzlzacatenango@image...>\n  * Support connected-components:eccentricity-threshold,\n    connected-components:major-axis-threshold,\n    connected-components:minor-axis-threshold,\n    connected-components:angle-threshold.\n  * Set the alpha channel if the write mask is not enabled.\n  * Corrected ellipse orientation when computing image moments.\n\n2020-02-14  7.0.9-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-23, GIT revision 16884:acb56cd:20200214\n\n2020-02-08  7.0.9-23 Cristy  <quetzlzacatenango@image...>\n  * Report gray(127.5) as gray(50%).\n  * Support -define connected-components:perimeter-threshold=min-max\n\n2020-02-07  7.0.9-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-22, GIT revision 16855:8733f3e:20200207\n\n2020-02-03  7.0.9-22 Cristy  <quetzlzacatenango@image...>\n  * More work on connect components, e.g. keep-colors, remove-colors,\n    keep-topids.\n  * Initialize mutex before locking if its not already initialized.\n  * Support 24-bit TIFF images.\n\n2020-02-01  7.0.9-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-21, GIT revision 16823:290cb93:20200201.\n\n2020-01-27  7.0.9-21 Cristy  <quetzlzacatenango@image...>\n  * Support additional connected components defines.\n  * Refresh cache morphology when writing MPC images.\n\n2020-01-26  7.0.9-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-19, GIT revision 16789:bac6ecc:20200126\n\n2020-01-26  7.0.9-19 Cristy  <quetzlzacatenango@image...>\n  * Make PNG creation reproducible (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1270).\n  * Refactor uninitialize variable patch for -fx \"while(,)\" expression.\n\n2020-01-25  7.0.9-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-18, GIT revision 16780:08beae5:20200125\n\n2020-01-19  7.0.9-18 Cristy  <quetzlzacatenango@image...>\n  * Alpha draw primitive no longer returns a parser exception.\n  * Support 32-bit tiled TIFF images.\n  * New -connected-component options (reference\n    https://imagemagick.org/script/connected-components.php).\n\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37391).\n2020-01-18  7.0.9-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-17, GIT revision 16753:c300b3a:20200118\n\n2020-01-12  7.0.9-17 Cristy  <quetzlzacatenango@image...>\n  * Allow larger negative interline spacing (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37391).\n  * Conditional compile for huge xml pages for RSVG delegate library.\n  * Put \"width\" property in the PNG namespace (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1833).\n  * -combine -colorspace sRGB no longer returns grayscale output (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1835).\n  * Support Jzazbz colorspace (contributed by snibgo @\n    http://im.snibgo.com/jzazbz.htm).\n\n2020-01-12  7.0.9-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-16, GIT revision 16719:fefd765:20200112.\n\n2020-01-12  7.0.9-16 Cristy  <quetzlzacatenango@image...>\n  * Fixed three failing Magick.NET unit tests.\n\n2020-01-11  7.0.9-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-15, GIT revision 16709:0000f6d:20200111.\n\n2020-01-11  7.0.9-15 Dirk Lemstra <dirk@lem.....org>\n  * Also support svg:xml-parse-huge when using librsvg.\n\n2020-01-10  7.0.9-15 Cristy  <quetzlzacatenango@image...>\n  * Optimize -evaluate-sequence option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1824).\n  * Support Fx do() iterator.\n  * `magick -size 100x100 xc:black black.pnm` no longer creates a white image\n    (reference https://github.com/ImageMagick/ImageMagick/issues/1817).\n  * setjmp/longjmp in jpeg.c no longer trigger undefind behavior (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37379).\n  * Permit compositing in the CMYK colorspace (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37368).\n\n2020-01-04  7.0.9-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-14, GIT revision 16654:89ef7ea:20200104.\n\n2020-01-01  7.0.9-14 Cristy  <quetzlzacatenango@image...>\n  * Support extended Fx assignment operators (e.g. *=, /=, ++, --, etc.)\n  * Support Fx for() iterator.\n  * Optimize Fx performance.\n  * Ensure circle.rb renders the same for IMv6 and IMv7 (reference\n    https://github.com/rmagick/rmagick/issues/905).\n\n2019-12-30  7.0.9-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-13, GIT revision 16616:dbafe0b:20191230.\n\n2019-12-27  7.0.9-13 Cristy  <quetzlzacatenango@image...>\n  * xc:white no longer creates a black PNM image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1817).\n  * Sync pixel cache for -kmeans option.\n  * Thread -kmeans option.\n  * PSD: only set the alpha channel when type is not 0.\n  * Fix Lab to custom profile (CMYK or RGB) conversion bug (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37318).\n\n2019-12-26  7.0.9-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-12, GIT revision 16587:7d6a559:20191226.\n\n2019-12-26  7.0.9-12 Cristy  <quetzlzacatenango@image...>\n  * Fix Build failure with MinGW-w64 (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/67).\n  * Inject image profile properties immediately after the image is read.\n\n2019-12-23  7.0.9-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-11, GIT revision 16568:1d6c960:20191224.\n\n2019-12-18  7.0.9-11 Cristy  <quetzlzacatenango@image...>\n  * Replace pseudo-random number generator with a Xoshiro generator.\n  * The -layers optimize option requires a fully transparent previous image.\n\n2019-12-22  7.0.9-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-10, GIT revision 16548:281649843:20191222.\n\n2019-12-18  7.0.9-10 Cristy  <quetzlzacatenango@image...>\n  * Some clang releases do not support _aligned_alloc().\n  * Support -kmeans command-line option.\n\n2019-12-07  7.0.9-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-9, GIT revision 16513:8ec82f4:20191215.\n\n2019-12-07  7.0.9-9 Cristy  <quetzlzacatenango@image...>\n  * Build file clean-up (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1798).\n  * Improve semaphore handling @\n    https://github.com/ImageMagick/ImageMagick/pull/1798).\n  * Introduce HeapOverflowSanityCheckGetExtent() method (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1798).\n\n2019-12-01  7.0.9-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-8, GIT revision 16474:0bc0e95:20191207.\n\n2019-12-01  7.0.9-8 Cristy  <quetzlzacatenango@image...>\n  * -type bilevel behavior restored, it creates a black and white image.\n\n2019-11-30  7.0.9-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-7, GIT revision 16449:971ba06:20191130.\n\n2019-11-26  7.0.9-7 Cristy  <quetzlzacatenango@image...>\n  * Support Pocketmod image format, e.g.\n    convert -density 300 pages?.pdf pocketmod:organize.pdf\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Update documentation.\n\n2019-11-26  7.0.9-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-6, GIT revision 16407:1725ec3:20191126.\n\n2019-11-19  7.0.9-6 Cristy  <quetzlzacatenango@image...>\n  * Increase the maximum number of bezier coordinates (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1784).\n  * Santize \"'\" from SHOW and WIN delegates under Linux, '\"\\' for Windows\n    (thanks to Enzo Puig).\n  * Correct for TGA orientation (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34757).\n  * The result for -compose Copy -extent on a  MYK image is CMYK (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37118).\n  * Fix potential buffer overflow when reading a fax image (alert from\n    Justin).\n  * Support dng:use-camera-wb option.\n\n2019-11-17  7.0.9-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-5, GIT revision 16369:747618e:20191117.\n\n2019-11-16  7.0.9-5 Cristy  <quetzlzacatenango@image...>\n  * Ensure Ascii85 compression is thread safe.\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-11-13  7.0.9-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-4, GIT revision 16354:5f53562:20191114.\n\n2019-11-10  7.0.9-4 Cristy  <quetzlzacatenango@image...>\n  * Add exception parameter to CMS transform methods.\n  * Output exception there is an attempt to perform an operation not allowed by\n    the security policy\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-10-30  7.0.9-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-2, GIT revision 16325:6f84d89:20191030.\n\n2019-10-29  7.0.9-2 Cristy  <quetzlzacatenango@image...>\n  * JPEG and JPG are aliases in coder security policy.\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-10-27  7.0.9-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-1, GIT revision 16313:e068be3:20191027.\n\n2019-10-27  7.0.9-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-10-23  7.0.9-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-0, GIT revision 16297:8744fd9:20191024\n\n2019-10-06  7.0.9-0 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support trim:background-color define for -trim option.\n\n2019-10-05  7.0.8-68 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-68, GIT revision 16184:b75b0e5:20191005.\n\n2019-09-30  7.0.8-68 Cristy  <quetzlzacatenango@image...>\n  * Support animated WebP encoding/decoding (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1708).\n  * Text stroke cut off (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=36829).\n  * Adds support for lossless JPEG1 recompression (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36828).\n\n2019-09-29  7.0.8-67 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-67, GIT revision 16145:6f2feb9:20190929.\n\n2019-09-28  7.0.8-67 Cristy  <quetzlzacatenango@image...>\n  * line endings renedered as empty boxes (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1704).\n\n2019-09-21  7.0.8-66 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-66, GIT revision 16134:f6ce80a:20190921.\n\n2019-09-09  7.0.8-66 Cristy  <quetzlzacatenango@image...>\n  * Support compound statements in FX while() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1701).\n\n2019-09-15  7.0.8-65 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-65, GIT revision 16130:254db34:20190915.\n\n2019-09-09  7.0.8-65 Cristy  <quetzlzacatenango@image...>\n  * Eliminate fault when trace delegate is not available.\n  * Properly distinquish linear and non-linear gray colorspaces (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1680).\n\n2019-09-07  7.0.8-64 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-64, GIT revision 16108:2ad3cbc:20190907.\n\n2019-09-02  7.0.8-64 Cristy  <quetzlzacatenango@image...>\n  * Support XPM symbolic (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1684).\n  * DilateIntensity is channel independent (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36641).\n\n2019-08-31  7.0.8-63 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-63, GIT revision 16088:3b7a33d:20190831.\n\n2019-08-24  7.0.8-63 Cristy  <quetzlzacatenango@image...>\n  * Properly identify the DNG and AI image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36581).\n\n2019-08-23  7.0.8-62 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-62, GIT revision 16061:7525595:20190823.\n\n2019-08-23  7.0.8-62 Dirk Lemstra <dirk@lem.....org>\n  * Added option to limit the maximum point size with -define\n    caption:max-pointsize=pointsize.\n  * Corrected JP2 numresolution calculation (reference:\n    https://github.com/ImageMagick/ImageMagick/issues/1673)\n\n2019-08-19  7.0.8-62 Cristy  <quetzlzacatenango@image...>\n  * Conditionally compile call to AcquireCLocale() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1669).\n  * More robust support for converting bitmap to vector.\n\n2019-08-16  7.0.8-61 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-61, GIT revision 16033:0c5808c:20190816.\n\n2019-08-03  7.0.8-61 Cristy  <quetzlzacatenango@image...>\n  * Issue with -background and -swirl (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36512).\n\n2019-08-10  7.0.8-60 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-60, GIT revision 16020:52ff205:20190810.\n\n2019-08-07  7.0.8-60 Cristy  <quetzlzacatenango@image...>\n  * Enable reading EXR image file from stdin.\n\n2019-08-04  7.0.8-59 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-59, GIT revision 15986:c3de0e7:20190804.\n\n2019-08-01  7.0.8-59 Cristy  <quetzlzacatenango@image...>\n  * Module is a reserved keyword for C++ 20 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1650).\n\n2019-07-29  7.0.8-58 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-58, GIT revision 15962:cf00632:20190729.\n\n2019-07-27  7.0.8-58 Cristy  <quetzlzacatenango@image...>\n  * Improve GetNextToken() performance.\n\n2019-07-26  7.0.8-57 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-57, GIT revision 15948:8fba4a3:20190726.\n\n2019-07-22  7.0.8-57 Cristy  <quetzlzacatenango@image...>\n  * Heap-buffer-overflow in Postscript coder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1644).\n  * The -alpha shape option nondeteministic under OpenMP (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36396).\n  * Correction to the ModulusAdd and ModulusSubtract composite op (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36413).\n\n2019-07-20  7.0.8-56 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-56, GIT revision 15936:2ac4147:20190720.\n\n2019-07-20  7.0.8-56 Cristy  <quetzlzacatenango@image...>\n  * Unexpected -alpha shape results (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36396).\n  * Converting from PDF to PBM inverts the image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1643).\n\n2019-07-18  7.0.8-55 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-55, GIT revision 15930:ac09240:20190718.\n\n2019-07-18  7.0.8-55 Cristy  <quetzlzacatenango@image...>\n  * Heap-buffer overflow (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1641\n  * PerlMagick test suite passes again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1640) \n\n2019-07-16  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-54, GIT revision 15916:e868e22:20190716.\n\n2019-07-08  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n  * resolve division by zero  (reference\n     https://github.com/ImageMagick/ImageMagick/issues/1629).\n  * introducing MagickLevelImageColors() MagickWand method.\n  * Transient problem with text placement with gravity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1633).\n  * Support TIM2 image format (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1571).\n  * For -magnify option, specify an alternative scaling method with -define\n    magnify:method=method, choose from these methods: eagle2X, eagle3X,\n    eagle3XB, epb2X, fish2X, hq2X,  scale2X (default), scale3X, xbr2X.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-53, GIT revision 15828:f5d59c0:20190705.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n   * Fix -fx parsing issue (reference\n     https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36314).\n\n2019-07-05  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-52, GIT revision 15825:ea47310:20190705.\n\n2019-07-01  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Eliminate buffer overflow in TranslateEvent() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1621).\n\n2019-06-30  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-51, GIT revision 15812:51f11c4:20190630.\n\n2019-06-24  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Clone rather than copy X window name/icon.\n  * Optimize PDF reader.\n\n2019-06-23  7.0.8-50 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-50, GIT revision 15778:4a60519:20190623\n\n2019-06-14  7.0.8-50 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading all images from a HEIC image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1391).\n  * Heap-buffer-overflow in MagickCore/fourier.c (reference\n   https://github.com/ImageMagick/ImageMagick/issues/1588).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-06-08  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-49, GIT revision 15708:6d7e1db:20190608\n\n2019-06-03  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Add support for RGB565 image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36078).\n  * Use user defined allocator instead of `malloc` (reference\n    https://github.com/ImageMagick/ImageMagick6/pull/49/).\n  * Add static decorator to accelerator kernels (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1366).\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-48, GIT revision 15689:061a3bb82:20190601\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Fix transient convolution bug (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36119).\n\n2019-05-26  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-47, GIT revision 15681:5cffc6cbb:20190526\n\n2019-05-19  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Support 16 and 32 bit tiled float TIFF images.\n  * Convolve morphology alpha channel fix (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36086).\n  * Text improvements to the internal SVG renderer.\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-46, GIT revision 15655:84dd3301c:20190518\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * PerlMagick unit tests pass again.\n  * Builds under MacOS X and FreeBSD works again.\n  * Return HEIC images in the sRGB colorspace.\n\n2019-05-12  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-45, GIT revision 15634:784105bcb:20190512\n\n2019-05-06  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Fix image signatures to ensure they are Q-depth invariant (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35970).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-44, GIT revision 15600:41f47759a:20190503\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-43, GIT revision 15595:0062cef74:20190502\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-29  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-42, GIT revision 15570:71190ccd0:20190424\n\n2019-04-20  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-19  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-41, GIT revision 15540:c78993d13:20190420\n\n2019-04-13  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Honor SOURCE_DATE_EPOCH environment variable (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1496/).\n  * Standardize on UTC time for any image format timestamp.\n  * Add MagickAutoThresholdImage(), MagickCannyEdgeImage(),\n    MagickComplexImages(), MagickConnectedComponentsImage(),\n    MagickHoughLineImage(), MagickKuwaharaImage(), MagickLevelizeImageColors(),\n    MagickLevelImageColors(), MagickMeanShiftImage(), MagickPolynomialImage(),\n    MagickRangeThresholdImage(), MagickSetSeed(), MagickWaveletDenoiseImage()\n    methods to MagickWand API.\n\n2019-04-12  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-40, GIT revision 15510:7e503e231:20190412\n\n2019-04-10  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n\n2019-04-07  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-39, GIT revision 15489:6120f8bc1:20190406\n\n2019-04-06  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * The -layers option compared pixels inocorrectly as opacity rather than\n    alpha.\n  * The -preview raise option now returns expected results.\n  * Initialise ghostscript instances with NULL (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1538).\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-38, GIT revision 15483:23edcef04:20190406\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Modulo off by one patch for -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-37, GIT revision 15470:477216fd7:20190403\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Fixed -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-03-31  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-36, GIT revision 15464:3a928224d:20190331\n\n2019-03-27  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-24  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-35, GIT revision 15440:4a0a88e41:20190324\n\n2019-03-23  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * -draw image DstOver is now responsive to the composite operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35650).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-15  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-34, GIT revision 15413:860af935d:20190315\n\n2019-03-11  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Associate one lock with each resource.\n  * Report exception if opening TIFF did not work out.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-03-10  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-33, GIT revision 15401:c805e3205:20190310\n\n2019-03-06  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Fix SVG conversion infinite loop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35591).\n  * Initialize primitive drawing structure after resizing.\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-32, GIT revision 15386:58d9c4692:20190305\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Fix out-of-boundary LocaleLowerCase() @\n    https://github.com/ImageMagick/ImageMagick/issues/1495\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-31, GIT revision 15381:3122a669d:20190304\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * -trim is no longer sensitive to the image virtual canvas.\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-30, GIT revision 15376:16d2b4e6a:20190303\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Support define to remove additional background from an image during a\n    trim, e.g. -fuzz 5% -define trim:percent-background=0% -trim.\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-29, GIT revision 15368:5d8ed9f56:20190228\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-02-18  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-28, GIT revision 15345:09a7c67dd:20190218\n\n2019-02-12  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-27, GIT revision 15315:5d48cd312:20190209\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Mod patch to properly handle subimage ranges (e.g. image.gif[2-3]).\n\n2019-02-03  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-26, GIT revision 15294:726bd82a3:20190203\n\n2019-02-02  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-01-27  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-25, GIT revision 15279:7da783a5b:20190127\n\n2019-01-19  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Eliminate spurious font warning (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1458).\n  * Support HEIC EXIF & XMP profiles.\n\n2019-01-12  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-24, GIT revision 15233:db129ba64:20190112\n\n2019-01-08  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe option real clip limit (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=35292).\n  * ShadeImage() kernels can return negative pixels, clamp to range (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1319).\n  * Annotate with negative offsets no longer renders slanted text.\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-23, GIT revision 15199:ba07f7d07:20190101\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * CacheInfo destructor must be aligned in DestroyPixelStream().\n\n2018-12-30  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-22, GIT revision 15189:842164090:20181230\n\n2018-12-29  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Support negative rotations in a geometry (e.g. -10x-10+10+10).\n  * Return expected canvas offset after a crop with gravity.\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-21, GIT revision 15179:114be1716:20181227\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Check to ensure SeekBlob() offset can be represented in an off_t.\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-20, GIT revision 15170:8e8222e87:20181223\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Cube image format returns a HALD image.\n  * CLAHE tiles overlapped are now centered relative to the image.\n\n2018-12-19  7.0.8-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-19, GIT revision 15153:e74ed77f5:20181219\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-18, GIT revision 15146:b5eccd295:20181218\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Fixed Magick++ compile error on Mac OS X.\n\n2018-12-17  7.0.8-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-17, GIT revision 15142:32f2d195e:20181217\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe clip limit with percentages (e.g. -clahe 50x50%+128+3).\n\n2018-12-10  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-16, GIT revision 15109:9a9af88de:20181210.\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Check for modulo underflow.\n  * Change SVG default DPI to 96 from 90 to meet recommendation of SVG2 & CSS.\n\n2018-12-01  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-15, GIT revision 15059:2fb22e07b:20181201\n\n2018-11-21  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Added support for the -clahe option: contrast limited adaptive histogram\n    equalization.\n\n2018-11-13  7.0.8-15 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GIMP 2.10 files (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1381).\n\n2018-10-23  7.0.8-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-14, GIT revision 14943:1a0da3dd0:20181023\n\n2018-10-21  7.0.8-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-13, GIT revision 14936:d3ec5abe2:20181021.\n\n2018-10-04  7.0.8-13 Dirk Lemstra <dirk@lem.....org>\n  * Adding coder headers with magic.xml will no longer be supported.\n  * Adding coder aliases with coder.xml will no longer be supported.\n\n2018-09-16  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-12, GIT revision 14843:cb5cf1959:20180923\n\n2018-09-15  7.0.8-12 Dirk Lemstra <dirk@lem.....org>\n  * Added support for arithmetic coding to the jpeg encoder:\n    -define jpeg:arithmetic-coding=true.\n\n2018-09-08  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-08-28  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-11, GIT revision 14729:798fbdb5b:20180828\n\n2018-08-15  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Add support for \"module\" security policy.\n\n2018-08-13  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-10, GIT revision 14646:48fba3256:20180813\n\n2018-08-12  7.0.8-10 Dirk Lemstra <dirk@lem.....org>\n  * Added dcraw coder (dcraw:img.cr2) that can be used to force the use of the\n    dcraw delegate when libraw is the default raw delegate.\n  * Restored thread support for the HEIC coder.\n\n2018-08-08  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * ThumbnailImage function no longer reveals sensitive information (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1243).\n\n2018-08-06  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-9, GIT revision 14618:a3663c3dc:20180805.\n\n2018-07-24  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * XBM coder leaves the hex image data uninitialized if hex value of the\n    pixel is negative.\n  * More improvements to SVG text handling.\n  * New -range-threshold option that combines hard and soft thresholding.\n\n2018-07-23  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-8, GIT revision 14583:300fdbcfd:20180723.\n\n2018-07-20  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Non-HDRI ScaleLongToQuantum() private method no longer adds a half interval.\n  * Fixed memset() negative-size-param (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1217).\n\n2018-07-16  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-7, GIT revision 14561:f85c23180:20180716.\n\n2018-07-15  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-07-08  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-6, GIT revision 14541:db940ccd2:20180708.\n\n2018-07-06  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Improve SVG support for tspan element.\n  * Add support for -fx image.extent.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-5, GIT revision 14514:bba545bbb:20180704.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed a few potential memory leaks\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-07-02  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-4, GIT revision 14505:4613eed4a:20180702.\n\n2018-06-28  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Small tweaks to compile under Cygwin.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Support %B property, the image file size without any decorations.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-3, GIT revision 14489:c63c504e8:20180624.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Apply translate component of SVG transform rotate.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-2, GIT revision 14476:cda11d81d:20180618.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * More robust SVG text handling.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-1, GIT revision 14468:94cb08785:20180616.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Fixed an issue with stroke and label: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34142).\n  * PNG: set storage class to DirectClass if alpha enabled (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34121).\n\n2018-06-12  7.0.8-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-0, GIT revision 14459:d7c892d5a:20180612.\n\n2018-06-11  7.0.8-0  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-11  7.0.7-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-39, GIT revision 14445:cc962acde:20180611.\n\n2018-06-06  7.0.7-39  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-02  7.0.7-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-38, GIT revision 14409:01e395a73:20180602.\n\n2018-05-30  7.0.7-38  <quetzlzacatenango@image...>\n  * Heap buffer overflow fix (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1156).\n  * Boundary issues with -gamma option when HDRI is enabled (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1151).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-29  7.0.7-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-37, GIT revision 14393:61d7e8b17:20180529.\n\n2018-05-29  7.0.7-37  <quetzlzacatenango@image...>\n  * Properly initialize SVG color style.\n\n2018-05-28  7.0.7-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-36, GIT revision 14390:3a6bd703f:20180528.\n\n2018-05-28  7.0.7-36  <quetzlzacatenango@image...>\n  * A SVG rectangle with a width and height of 1 is a point.\n\n2018-05-21  7.0.7-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-35, GIT revision 14356:13507412c:20180521.\n\n2018-05-21  7.0.7-35  <quetzlzacatenango@image...>\n  * Fixed memory corruption for MVG paths.\n\n2018-05-20  7.0.7-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-34, GIT revision 14348:ac9ff6ba1:20180520.\n\n2018-05-20  7.0.7-34 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading eXIf chunks to the PNG coder.\n\n2018-05-19  7.0.7-34  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Improved clip / composite mask handling.\n\n2018-05-16  7.0.7-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-33, GIT revision 14326:58c2e4972:20180516.\n\n2018-05-03  7.0.7-33  <quetzlzacatenango@image...>\n  * Restore SetImageAlpha() behavior.\n  * Fix -clip and -mask options.\n\n2018-05-13  7.0.7-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-32, GIT revision 14307:f61f674e3:20180513.\n\n2018-05-03  7.0.7-31  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-01  7.0.7-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-30, GIT revision 14242:730f1d1d3:20180501.\n\n2018-05-01  7.0.7-30  <quetzlzacatenango@image...>\n  * Missing break when checking \"compliance\" element.\n\n2018-04-30  7.0.7-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-29, GIT revision 14225:41edbdcea:20180430.\n\n2018-03-26  7.0.7-29  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-24  7.0.7-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-28, GIT revision 23615:edd71782e:20180325.\n\n2018-03-21  7.0.7-28  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-18  7.0.7-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-27, GIT revision 23466:734b146df:20180318.\n\n2018-03-17  7.0.7-27  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-11  7.0.7-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-26, GIT revision 23344:7a03766ef:20180311.\n\n2018-03-10  7.0.7-26  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-25, GIT revision 23177:17a986472:20180304.\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-25  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-24, GIT revision 23079:7ccb76178:20180225.\n\n2018-02-19  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Do not refer to page in OptimizeLayerFrames (reference\n    https://github.com/ImageMagick/ImageMagick/pull/987).\n  * PerlMagick unit tests pass again.\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-18  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-23, GIT revision 22969:c6b3a22b0:20180218.\n\n2018-02-09  7.0.7-23 Dirk Lemstra <dirk@lem.....org>\n  * Add support for reading the HEIC image format to the Windows build.\n\n2018-01-23  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n  * Add list-length policy to limit the maximum image sequence length.\n\n2018-01-22  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-22, GIT revision 22391:e8be814f1:20180122.\n\n2018-01-06  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Support aspect ratio geometry, e.g. -crop 3:2.\n  * Add support for reading the HEIC image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/507).\n  * Fixed numerous memory leaks, credit to OSS Fuzz.\n\n2018-01-06  7.0.7-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-21, GIT revision 22168:a91afc45b:20180106.\n\n2018-01-06  7.0.7-21 Dirk Lemstra <dirk@lem.....org>\n  * Fix some enum values in the OpenCL code.\n\n2018-01-06  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-20, GIT revision 22161:33a04d3e5:20180105.\n\n2018-01-05  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-01-01  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-19, GIT revision 22133:977fe08bf:20180101.\n\n2017-12-29  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Check for webpmux library version 0.4.4 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/896).\n\n2017-12-26  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-18, GIT revision 22096:ad4bdeb40:20171228.\n\n2017-12-28  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading from pipe under Windows (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=33288).\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-17, GIT revision 22093:9caea323b:20171227.\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Fix heap use after free error (reference\n    https://github.com/ImageMagick/ImageMagick/issues/918).\n\n2017-12-24  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-16, GIT revision 22038:e55dc7626:20171225.\n\n2017-12-18  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading multi-layer XCF image file.\n  * Fix possible stack overflow in WEBP reader (reference\n    https://github.com/ImageMagick/ImageMagick/issues/907)\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-12-16  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-15, GIT revision 21924:30cb31746:20171216.\n\n2017-12-08  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Overall standard deviation is the average of each pixel channel (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Update to the latest ImageMagick documentation.\n\n2017-12-05  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-14, GIT revision 21855:dc73b2aba:20171205.\n\n2017-11-30  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Support Stereo composite operator.\n  * Fix build failure with --without-modules (reference\n    https://github.com/ImageMagick/ImageMagick/issues/890).\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-13, GIT revision 21823:72cb0fd0c:20171130.\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Fix build failure with libraw 0.14.8 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/888).\n\n2017-11-29  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-12, GIT revision 21814:5ef2c5a67:20171129.\n\n2017-11-12  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * The -tint option no longer munges the alpha channel (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=1&t=33070).\n  * Don't delete in-memory blob when reading an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/886).\n  * Support HDRI color profile management.\n\n2017-11-11  7.0.7-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-11, GIT revision 21635:0447c6b46:20171111.\n\n2017-11-05  7.0.7-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-10, GIT revision 21612:36e2aabfd:20171105.\n\n2017-11-03  7.0.7-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed a problem with resource bookkeeping in AcquireMatrixInfo().\n\n2017-10-30  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-9, GIT revision 21580:2682a311e:20171031.\n\n2017-10-20  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Encode JSON control characters (reference\n    https://github.com/ImageMagick/ImageMagick/issues/848).\n\n2017-10-27  7.0.7-9 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading mipmaps in dds images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/845).\n\n2017-10-15  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-8, GIT revision 21507:63ffc9878:20171015.\n\n2017-10-08  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Return expected results for a percent 0 -chop option argument (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32806).\n  * Tweaks to OpenMP support within ImageMagick.\n\n2017-10-07  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-7, GIT revision 21432:29003eeed:20171007.\n\n2017-10-06  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Correct handling of GIF transparency (reference\n    https://github.com/ImageMagick/ImageMagick/issues/831).\n\n2017-10-04  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-6, GIT revision 21426:0a1cb507b:20171004.\n\n2017-10-03  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Reset the magick_list_initialized boolean when needed (reference\n    https://github.com/ImageMagick/ImageMagick/pull/826).\n\n2017-10-01  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-5, GIT revision 21382:3846f9d97:20171001.\n\n2017-09-28  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support URW-base35 fonts.\n\n2017-09-26  7.0.7-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed \"ping_preserve_iCCP=MagickTrue;\" statement that was inadvertently\n    added to coders/png.c (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32771).\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-4, GIT revision 21265:bdbc14590:20170923.\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-17  7.0.7-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-3, GIT revision 21202:6e6907ac7:20170917.\n\n2017-09-17  7.0.7-3 ADLab of Venustech\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-15  7.0.7-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop potential leaks in the JNG decoder (reference:\n    https://github.com/ImageMagick/ImageMagick/issues/760).\n  * Maximum valid hour is 23, not 24, in the PNG tIME chunk, and maximum\n    valid minute is 59, not 60.\n\n2017-09-12  7.0.7-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-2, GIT revision 21089:4e46ad9dd:20170912.\n\n2017-09-11  7.0.7-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Use signed integer arithmetic to calculate timezone corrections (reference\n    https://github.com/ImageMagick/ImageMagick/issues/685).\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-1, GIT revision 21065:ab2194121:20170909.\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-09-05 7.0.7-1 Dirk Lemstra <dirk@lem.....org>\n  * Added -define tiff:write-layers=true to add support for writing layered\n    tiff files.\n\n2017-09-03  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-0, GIT revision 20996:2f8ac2203:20170903.\n\n2017-08-28  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't overwrite symbolic links when the shred policy is enabled.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-10, GIT revision 20920:9940c367a:20170827.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Support -metric ssim, structual similarity index.\n\n2017-08-26  7.0.6-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed thread safety issue inside the pango and librsvg decoder\n    (reference: https://github.com/dlemstra/Magick.NET/issues/91).\n\n2017-08-20  7.0.6-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-9, GIT revision 20860:3f307d8ad:20170820.\n\n2017-08-18  7.0.6-9 Glenn Randers-Pehrson <glennrp@image...>\n  * Fixed bug with writing tIME chunk when timezone has a negative offset\n    (reference: https://github.com/ImageMagick/ImageMagick/issues/685)\n\n2017-08-18  7.0.6-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-8, GIT revision 20838:e2eb79427:20170818.\n\n2017-08-14  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support CubicSpline resize filter.  Define the lobes with the\n    -define filter:lobes={2,3,4} (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=32506).\n  * Prevent assertion failure when creating PDF thumbnail (reference\n    https://github.com/ImageMagick/ImageMagick/issues/674).\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-7, GIT revision 20799:0db4d8a16:20170812.\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Improve EPS aliasing (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32497).\n\n2017-08-11  7.0.6-7 Dirk Lemstra <dirk@lem.....org>\n  * Added a new option called 'dds:fast-mipmaps' (reference\n    https://github.com/ImageMagick/ImageMagick/issues/558)\n  * The mipmaps of a dds image can now be created from a list of images with\n    -define dds:mipmaps=fromlist (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30236).\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-6, GIT revision 20775:061d0fa25:20170810.\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-08-10  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * tests/validate.c: Show the reason for failures in the test logs,\n    if available.\n\n2017-08-03  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Put UTC time in the PNG tIME chunk instead of local time (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32447).\n\n2017-08-02  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-5, GIT revision 20715:26b28d50a:20170802.\n\n2017-08-01  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-29  7.0.6-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Properly set image->colorspace in the PNG decoder (previously\n    it was setting image->gamma, but only setting image->colorspace\n    for grayscale and gray-alpha images.  Reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32418).\n  * Fix improper use of NULL in the JNG decoder (CVE-2017-11750, Reference\n    https://github.com/ImageMagick/ImageMagick/issues/632).\n  * Added \"-define png:ignore-crc\" option to PNG decoder. When you know\n    your image has no CRC or ADLER32 errors, this can speed up decoding.\n    It is also helpful in debugging bug reports from \"fuzzers\".\n\n2017-07-29  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Off by one error for gradient coder (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32416),\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n\n2017-07-28  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-4, GIT revision 20657:4e81160d6:20170728.\n\n2017-07-24  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * YUV coder no longer renders streaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues) including\n    https://github.com/ImageMagick/ImageMagick/issues/618 (CVE-2017-12676).\n  * coders/png.c: Initialized quantum_scanline and quantum_info\n    to prevent a bad free (reference\n    https://github.com/ImageMagick/ImageMagick/issues/621).\n\n2017-07-25  7.0.6-4 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed write_chunk_from_profile() from coders/png.c because it has\n    not worked at least since version 6.7.6.\n  * Removed many redundant checks before RelinquishMagickMemory(), which\n    is safe to call with a NULL argument.\n  * Added experimental PNG orNT chunk, to store image->orientation.\n  * Removed vpAg chunk write support (we are now writing caNv instead).\n\n2017-07-24  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-3, GIT revision 20598:cc9c43b44:20170724.\n\n2017-07-23  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-23  7.0.6-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Fix memory leaks when reading a malformed JNG image:\n    https://github.com/ImageMagick/ImageMagick/issues/600 (CVE-2017-13141),\n    https://github.com/ImageMagick/ImageMagick/issues/602 (CVE-2017-12565).\n\n2017-07-21  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-2, GIT revision 20549:62fcf3d96:20170721.\n\n2017-07-19  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * The -monochrome option no longer returns a blank canvas (reference\n    https://github.com/ImageMagick/ImageMagick/issues/594).\n  * coders/png.c: fixed memory leak of quantum_info (CVE-2017-11539, reference\n    https://github.com/ImageMagick/ImageMagick/issues/582\n  * coders/png.c: fixed NULL dereference when trying to write an empty MNG\n    (CVE-2017-11522, reference\n    https://github.com/ImageMagick/ImageMagick/issues/586).\n\n2017-07-15  7.0.6-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Added caNv, eXIf, and pHYs to the list of PNG chunks to be removed\n    by the \"-strip\" option.\n\n2017-07-15  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-1, GIT revision 20447:c2a315e10:20170715.\n\n2017-07-13  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Implemented PNG eXIf chunk support.\n\n2017-07-08  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Support new -auto-threshold option.  OTSU and Triangle methods are\n    currently supported.  Look for the Kapur method in the next release.\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't use variable float_t / double_t, bump SO (reference\n    https://github.com/ImageMagick/ImageMagick/issues/510).\n  * Support DNG images with libraw delegate library.\n\n2017-07-02  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Reject PNG file that is too small (under 60 bytes) to contain\n    a valid image.\n  * Reject JPEG file that is too small (under 107 bytes) to contain\n    a valid image.\n  * Reject JNG file that is too small (under 147 bytes) to contain\n    a valid image.\n\n2017-06-22  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop a memory leak in read_user_chunk_callback() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/517,\n    CVE 2017-11310).\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-0, GIT revision 20194:b0c0d00:20170611.\n\n2017-06-10  7.0.6-0 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Accept exIf chunks whose data segment\n    erroneously begins with \"Exif\\0\\0\".\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Introduce SetMagickSecurityPolicy() (MagickCore) and\n    MagickSetSecurityPolicy() (MagickWand) to set the ImageMagick security\n    policy (reference https://github.com/ImageMagick/ImageMagick/issues/407).\n\n2017-06-02  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-10, GIT revision 20155:38ebc02:20170602.\n\n2017-06-01  7.0.5-10 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed experimental PNG zxIF chunk support; the proposal is dead.\n\n2017-06-01  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Fix choppy bitmap font rendering (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32071).\n  * The +opaque option is not longer a noop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32081).\n  * Add support  for 'hex:' property.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-9, GIT revision 20113:8b67333:20170528.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Transient error validating the JPEG-2000 image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/501).\n  * Properly allocate DCM image colormap (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32063).\n\n2017-05-26  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-8, GIT revision 20099:870a016:20170526.\n\n2017-05-23  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Improper allocation of memory for IM instances without threads (reference\n    https://github.com/ImageMagick/ImageMagick/issues/497).\n  * Delete corrupt image from list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/500).\n\n2017-05-19  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20078:7ce2d38:20170519.\n\n2017-05-15  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Support various image operators for the compare utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=31938).\n\n 2017-05-12  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20039:9371904:20170512.\n\n2017-05-10  7.0.5-6 John Cupitt <jcupitt@gmail.com>\n  * Revise DICOM window and rescale handling (reference\n    https://github.com/ImageMagick/ImageMagick/pull/484)\n\n2017-05-06  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Restore the -alpha Shape option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31879).\n  * Fix transient PDF bug (reference\n    https://github.com/ImageMagick/ImageMagick/issues/463).\n  * The +opaque option now works on all channels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31862).\n  * Ensure backwards compatibility for the -combine option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31855).\n  * Check for EOF conditions for RLE image format.\n  * Reset histogram page geometry (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31920).\n\n2017-04-24  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-5, GIT revision 19915:12eec43:20170424.\n\n2017-03-26  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Minimize buffer copies to improve OpenCL performance.\n  * Morphology thinning is no longer a no-op (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31650).\n  * Patch two PCD writer problems, corrupt output and dark pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=3164).\n  * Support ICC based PDF's (reference\n    https://github.com/ImageMagick/ImageMagick/issues/417).\n  * Fix improper EPS clip path rendering (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31722).\n\n2017-03-24  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-4, GIT revision 19754:350fff3:20170324.\n\n2017-03-21  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Respect -loop option for animate -window (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31619).\n\n2017-03-17  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-3, GIT revision 19741:070c3fb:20170317.\n\n2017-03-14  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Support namespaces for the security policy.\n  * Support the -authenticate option for PDF (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31530).\n\n2017-03-11  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-2, GIT revision 19696:da91a7c:20170311.\n\n2017-03-06  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Respect throttle policy (reference\n    https://github.com/ImageMagick/ImageMagick/issues/393).\n  * Return proper minima / maxima (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n\n2017-03-03  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-1, GIT revision 19662:b7f455a:20170303.\n\n2017-02-21  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Fix Spurious memory allocation message (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31438).\n  * Identical images should return inf for PSNR (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31487).\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-0, GIT revision 19616:505fea9:20170220.\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Fix transient bug with -separate option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/385).\n\n2017-02-18  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-10, GIT revision 19608:fe757a2:20170218.\n\n2017-02-18  7.0.4-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed fd leak for webp coder (reference\n    https://github.com/ImageMagick/ImageMagick/pull/382)\n\n2017-02-15  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent random pixel data for corrupt JPEG image (bug report from\n    Hirokazu Moriguchi, Sony).\n  * Restore -mattecolor option.\n  * Support pixel-cache and shred security policies.\n  * Bump Magick++ SO.  Previously a global replace changed matteColor to\n    alphaColor.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-9, GIT revision 19580:d474b37:20170214.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Revert patch that did not set update trait on alpha channel.\n\n2017-02-13  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-8, GIT revision 19574:7642384:20170213.\n\n2017-02-09  7.0.4-8 Dirk Lemstra <dirk@lem.....org>\n  * Fixed memory leak when creating nested exceptions in Magick++ (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=23&p=142634)\n\n2017-02-09  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Unbreak build without JPEG support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/373).\n  * Document behavior change in the security policy (thanks to yoya @\n    https://blog.awm.jp/2017/02/09/imagemagick-en/).\n  * Return unbiased standard deviation for image statistics (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n  * Don't set update trait on alpha channel (private e-mail concerning\n    -levels-colors option).\n\n2017-02-04  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-7, GIT revision 19513:5783e57:20170204.\n\n2017-01-28  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Sanitize comments that include braces for the MIFF image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/368).\n\n2017-01-27  7.0.4-7 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Added support for a proposed new PNG chunk\n    (zxIf, read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.  Enable\n    exIf and zxIf with CPPFLAGS=\"-DexIf_SUPPORTED -DxzIf_SUPPORTED\".\n    If exIf is enabled, only the uncompressed exIF chunk will be\n    written and the hex-encoded zTXt chunk containing the raw Exif\n    profile won't be written.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-6, GIT revision 19442:4747de9:20170127.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Uninitialized data in MAT image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/362).\n  * Properly auto-fit caption (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Correction to composite Over operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31282).\n  * Respect gravity option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31284).\n\n2017-01-22  7.0.4-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Renamed read_vpag_chunk_callback() function to png_user_chunk_callback()\n    in coders/png.c\n  * Implemented a private PNG caNv (canvas) chunk for remembering the\n    original dimensions and offsets when an image is cropped.  Previously\n    we used the oFFs and vpAg chunks for this purpose, but this had potential\n    conflicts with other applications that also use the oFFs chunk.\n  * coders/png.c: Added support for a proposed new PNG chunk (exIf\n    read-write, eXIf read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.\n\n2017-01-22  7.0.4-6 Dirk Lemstra <dirk@lem.....org>\n  * Replaced CoderSeekableStreamFlag with CoderDecoderSeekableStreamFlag and\n    CoderEncoderSeekableStreamFlag.\n\n2017-01-21  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-5, GIT revision 19381:7ae396f:20170121.\n\n2017-01-18  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Don't set background for transparent tiled images (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31210).\n\n2017-01-14  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-4, GIT revision 19361:a12953c:20170114.\n\n2017-01-14  7.0.4-4 Dirk Lemstra <dirk@lem.....org>\n  * Added support for RGB555, RGB565, ARGB4444 and ARGB1555 to the\n    BMP encoder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/344).\n\n2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n  * Fix memory leak in the MPC format.\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006).\n  * Enable alpha channel if background color is non-opaque (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 Fahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2020 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include <tiffconf.h>\n# endif\n# include <tiff.h>\n# include <tiffio.h>\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n# if defined(COMPRESSION_ZSTD) && defined(MAGICKCORE_ZSTD_DELEGATE)\n#   include <zstd.h>\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\ntypedef struct _PhotoshopProfile\n{\n  StringInfo\n    *data;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    length,\n    extent,\n    quantum;\n} PhotoshopProfile;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 2, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n\nstatic MagickOffsetType TIFFTellCustomStream(void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  return(profile->offset);\n}\n\nstatic void InitPSDInfo(const Image *image,PSDInfo *info)\n{\n  (void) memset(info,0,sizeof(*info));\n  info->version=1;\n  info->columns=image->columns;\n  info->rows=image->rows;\n  info->mode=10; /* Set the mode to a value that won't change the colorspace */\n  info->channels=1U;\n  info->min_channels=1U;\n  info->has_merged_image=MagickFalse;\n  if (image->storage_class == PseudoClass)\n    info->mode=2; /* indexed mode */\n  else\n    {\n      info->channels=(unsigned short) image->number_channels;\n      info->min_channels=info->channels;\n      if (image->alpha_trait == BlendPixelTrait)\n        info->min_channels--;\n    }\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  if (length != 10)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(unsigned int) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(unsigned int) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  if (ferror(file) != 0)\n    {\n      (void) fclose(file);\n      ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n    }\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  message[MaxTextExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic MagickBooleanType TIFFGetProfiles(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  uint32\n    length = 0;\n\n  unsigned char\n    *profile = (unsigned char *) NULL;\n\n  status=MagickTrue;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC) && (TIFFLIB_VERSION >= 20191103)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      const TIFFField\n        *field;\n\n      field=TIFFFieldWithTag(tiff,TIFFTAG_RICHTIFFIPTC);\n      if (TIFFFieldDataType(field) == TIFF_LONG)\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n      else\n        status=ReadProfile(image,\"iptc\",profile,length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      StringInfo\n        *dng;\n\n      status=ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      dng=BlobToStringInfo(profile,length);\n      if (dng != (StringInfo *) NULL)\n        {\n          const char\n            *target = \"dc:format=\\\"image/dng\\\"\";\n\n          if (strstr((char *) GetStringInfoDatum(dng),target) != (char *) NULL)\n            (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n          dng=DestroyStringInfo(dng);\n        }\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n  return(status);\n}\n\nstatic MagickBooleanType TIFFGetProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  MagickBooleanType\n    status;\n\n  uint32\n    count,\n    type;\n\n  text=(char *) NULL;\n  status=MagickTrue;\n  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:artist\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:document\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"comment\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:make\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:model\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"label\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:software\",text,exception);\n  if ((TIFFGetField(tiff,33423,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if ((TIFFGetField(tiff,36867,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  return(status);\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MagickPathExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MagickPathExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,sans) == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",shorty);\n          }\n        else if (exif_info[i].variable_length == 2)\n        {\n          uint16\n            *shorty;\n\n          shorty=0;\n          if ((TIFFGetField(tiff,exif_info[i].tag,&shorty,sans) == 1) &&\n              (shorty != (uint16 *) NULL))\n            (void) FormatLocaleString(value,MagickPathExtent,\"%d\",*shorty);\n        }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",(double)\n            floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value,exception);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,const tsample_t sample,const ssize_t row,\n  tdata_t scanline)\n{\n  int32\n    status;\n\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  message[MaxTextExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    *value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /*\n    Only support 8 bit for now.\n  */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /*\n    Search for Adobe APP14 JPEG marker.\n  */\n  value=NULL;\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value) || (value == NULL))\n    return(ReadStripMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadStripMethod);\n  method=ReadStripMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  size_t\n    total;\n\n  MagickOffsetType\n    remaining;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForReading(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamReader(custom_stream,TIFFReadCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic void TIFFReadPhotoshopLayers(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *layers;\n\n  ImageInfo\n    *clone_info;\n\n  PhotoshopProfile\n    photoshop_profile;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  profile=GetImageProfile(image,\"tiff:37724\");\n  if (profile == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) profile->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (profile->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (profile->length-8))\n    return;\n  photoshop_profile.data=(StringInfo *) profile;\n  photoshop_profile.length=profile->length;\n  custom_stream=TIFFAcquireCustomStreamForReading(&photoshop_profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return;\n  layers=CloneImage(image,0,0,MagickTrue,exception);\n  if (layers == (Image *) NULL)\n    {\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      return;\n    }\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachCustomStream(layers->blob,custom_stream);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  InitPSDInfo(layers,&info);\n  clone_info=CloneImageInfo(image_info);\n  clone_info->number_scenes=0;\n  (void) ReadPSDLayers(layers,clone_info,&info,exception);\n  clone_info=DestroyImageInfo(clone_info);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    more_frames,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      TIFFGetEXIFProperties(tiff,image,exception);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace,exception);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                    exception);\n                }\n          }\n      }\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          buffer[MagickPathExtent];\n\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",buffer,exception);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (photometric == PHOTOMETRIC_LOGLUV)\n      method=ReadGenericMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    if (TIFFScanlineSize(tiff) <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((1.0*TIFFScanlineSize(tiff)) > (2.53*GetBlobSize(image)))\n      ThrowTIFFException(CorruptImageError,\"InsufficientImageDataInFile\");\n    number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)\n      image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/\n      log(2.0))),image->columns*rows_per_strip));\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=IndexQuantum;\n    pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        if (image->storage_class == PseudoClass)\n          quantum_type=IndexAlphaQuantum;\n        else\n          quantum_type=samples_per_pixel == 1 ? AlphaQuantum : GrayAlphaQuantum;\n      }\n    else\n      if (image->storage_class != PseudoClass)\n        quantum_type=GrayQuantum;\n    if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n      {\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (tiff_status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register Quantum\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=TIFFTileSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=columns*sizeof(uint64);\n#else\n        extent+=columns*sizeof(uint32);\n#endif\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            register ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                register Quantum\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo * ) NULL;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        number_pixels+=image->columns*sizeof(uint32);\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if (status != MagickFalse)\n    TIFFReadPhotoshopLayers(image_info,image,exception);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  /*\n    This also sets field_bit to 0 (FIELD_IGNORE).\n  */\n  (void) memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n#endif\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      DestroyBlob(pyramid_image);\n      pyramid_image->blob=ReferenceBlob(next->blob);\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  status=MagickFalse;\n  if (images != (Image *) NULL)\n    {\n      /*\n        Write pyramid-encoded TIFF image.\n      */\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n#define TIFFStripSizeDefault  1048576\n\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) memset(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    {\n      size_t\n        extent;\n\n      uint32\n        rows,\n        rows_per_strip;\n\n      extent=TIFFScanlineSize(tiff);\n      rows_per_strip=TIFFStripSizeDefault/(extent == 0 ? 1 : (uint32) extent);\n      rows_per_strip=16*(((rows_per_strip < 16 ? 16 : rows_per_strip)+1)/16);\n      TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&rows);\n      if (rows_per_strip > rows)\n        rows_per_strip=rows;\n      option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n      if (option != (const char *) NULL)\n        rows_per_strip=(uint32) strtoul(option,(char **) NULL,10);\n      rows_per_strip=TIFFDefaultStripSize(tiff,rows_per_strip);\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      return(MagickTrue);\n    }\n  /*\n    Create tiled TIFF, ignore \"tiff:rows-per-strip\".\n  */\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  if ((TIFFScanlineSize(tiff) <= 0) || (TIFFTileSize(tiff) <= 0))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) memcpy(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic ssize_t TIFFWriteCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  if ((profile->offset+(MagickOffsetType) count) >=\n        (MagickOffsetType) profile->extent)\n    {\n      profile->extent+=count+profile->quantum;\n      profile->quantum<<=1;\n      SetStringInfoLength(profile->data,profile->extent);\n    }\n  (void) memcpy(profile->data->datum+profile->offset,data,count);\n  profile->offset+=count;\n  return(count);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForWriting(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamWriter(custom_stream,TIFFWriteCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *base_image,\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  base_image=CloneImage(image,0,0,MagickFalse,exception);\n  if (base_image == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(base_image);\n  base_image->blob=blob;\n  next=base_image;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  AttachCustomStream(base_image->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  base_image->endian=endian;\n  WriteBlobString(base_image,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(base_image,0);\n  WriteBlobString(base_image,base_image->endian == LSBEndian ? \"MIB8ryaL\" :\n    \"8BIMLayr\");\n  status=WritePSDLayers(base_image,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  next=base_image;\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const MagickBooleanType adjoin,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property,exception);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    adjoin,\n    debug,\n    preserve_compression,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    imageListLength,\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric,\n    predictor;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;\n    }\n  mode=endian_type == LSBEndian ? \"wl\" : \"wb\";\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    mode=endian_type == LSBEndian ? \"wl8\" : \"wb8\";\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      return(MagickFalse);\n    }\n  (void) DeleteImageProfile(image,\"tiff:37724\");\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  adjoin=image_info->adjoin;\n  imageListLength=GetImageListLength(image);\n  option=GetImageOption(image_info,\"tiff:preserve-compression\");\n  preserve_compression=IsStringTrue(option);\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    (void) IsImageMonochrome(image);\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=image_info->compression;\n    if (preserve_compression != MagickFalse)\n      compression=image->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if (IsImageMonochrome(image) == MagickFalse)\n          {\n            if (IsImageGray(image) == MagickFalse)\n              (void) SetImageType(image,BilevelType,exception);\n            else\n              (void) SetImageDepth(image,1,exception);\n          }\n        image->depth=1;\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          {\n            quantum_info=DestroyQuantumInfo(quantum_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n#if defined(COMPRESSION_ZSTD)\n      case ZstdCompression:\n      {\n        compress_tag=COMPRESSION_ZSTD;\n        break;\n      }\n#endif\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n            MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              status=SetQuantumDepth(image,quantum_info,8);\n              if (status == MagickFalse)\n                ThrowWriterException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) ||\n        (compress_tag == COMPRESSION_CCITTFAX4))\n      {\n         if ((photometric != PHOTOMETRIC_MINISWHITE) &&\n             (photometric != PHOTOMETRIC_MINISBLACK))\n          {\n            compress_tag=COMPRESSION_NONE;\n            endian=FILLORDER_MSB2LSB;\n          }\n      }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel,sans);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    predictor=0;\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n                }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        break;\n      }\n#if defined(WEBP_SUPPORT) && defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_WEBP_LEVEL,image_info->quality);\n        if (image_info->quality >= 100)\n          (void) TIFFSetField(tiff,TIFFTAG_WEBP_LOSSLESS,1);\n        break;\n      }\n#endif\n#if defined(ZSTD_SUPPORT) && defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZSTD_LEVEL,22*image_info->quality/\n          100.0);\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    if (quantum_info->format == FloatingPointQuantumFormat)\n      predictor=PREDICTOR_FLOATINGPOINT;\n    option=GetImageOption(image_info,\"tiff:predictor\");\n    if (option != (const char * ) NULL)\n      predictor=(uint16) strtol(option,(char **) NULL,10);\n    if (predictor != 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,predictor);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    option=GetImageOption(image_info,\"tiff:write-layers\");\n    if (IsStringTrue(option) != MagickFalse)\n      {\n        (void) TIFFWritePhotoshopLayers(image,image_info,endian_type,exception);\n        adjoin=MagickFalse;\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (adjoin != MagickFalse) && (imageListLength > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            imageListLength);\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    else\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) imageListLength;\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,adjoin,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (compress_tag == COMPRESSION_CCITTFAX4)\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,(uint32) image->rows);\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          {\n            if (red != (uint16 *) NULL)\n              red=(uint16 *) RelinquishMagickMemory(red);\n            if (green != (uint16 *) NULL)\n              green=(uint16 *) RelinquishMagickMemory(green);\n            if (blue != (uint16 *) NULL)\n              blue=(uint16 *) RelinquishMagickMemory(blue);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) memset(red,0,65536*sizeof(*red));\n        (void) memset(green,0,65536*sizeof(*green));\n        (void) memset(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    if (TIFFWriteDirectory(tiff) == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(status);\n}\n#endif\n"], "fixing_code": ["2020-11-30  7.0.10-46  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-46 GIT revision 17...\n\n2020-11-30  7.0.10-45  <quetzlzacatenango@image...>\n  * possible TIFF related-heap buffer overflow (alert & POC by Hardik Shah).\n\n2020-11-30  7.0.10-45  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-45 GIT revision 17972:6c0cb7f72:20201130\n\n2020-11-30  7.0.10-45  Dirk Lemstra <dirk@lem.....org>\n  * added support for the farbfeld format (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2664).\n\n2020-11-29  7.0.10-45  <quetzlzacatenango@image...>\n  * specify the bilateral neighbor as width/height rather than radius/sigma.\n\n2020-11-28  7.0.10-44  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-44 GIT revision 17948:7e96e9fdd:20201128\n\n2020-11-26  7.0.10-44  Dirk Lemstra <dirk@lem.....org>\n  * correct reading of first row in TIFF decoder.\n\n2020-11-24  7.0.10-44  <quetzlzacatenango@image...>\n  * correct rotation parameter for SVG transform.\n\n2020-11-23  7.0.10-43  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-43 GIT revision 17885:be852878e:20201123\n\n2020-11-23  7.0.10-43  <quetzlzacatenango@image...>\n  * add padding to AcquirePolicyString().\n\n2020-11-22  7.0.10-42  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-42 GIT revision 17881:d228ef95e:20201122\n\n2020-11-21  7.0.10-42  <quetzlzacatenango@image...>\n  * revert memory patch to avert possible thread lock.\n  * add support for FilmLight FL32 image format.\n\n2020-11-20  7.0.10-40  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-40 GIT revision 17860:2594cd0a5:20201120 \n\n2020-11-19  7.0.10-40  <quetzlzacatenango@image...>\n  * remove Linux shell artifact from Windows delegate configuration file.\n  * fix shell injection vulnerability via the -authenticate option (reference\n    alex@cure...).\n\n2020-11-17  7.0.10-39  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-39 GIT revision 17837:ffb8da39c:20201117\n\n2020-11-07  7.0.10-39  <quetzlzacatenango@image...>\n  * support DPX 4:2:2 sampling.\n\n2020-11-14  7.0.10-38  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-38 GIT revision 17815:bf51a3f1f:20201114\n\n2020-11-07  7.0.10-38  <quetzlzacatenango@image...>\n  * add image settings support to -fx.\n  * better support for TIFF YCbCr photometric.\n  * verify TTF glyph format before dereferencing (reference\n    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26932).\n  * force single HEIC image per container.\n\n2020-11-07  7.0.10-37  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-37 GIT revision 17780:47a8392ef:20201107\n\n2020-11-07  7.0.10-37  <quetzlzacatenango@image...>\n  * correct soversioning.\n\n2020-11-07  7.0.10-36  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-36 GIT revision 17776:6bb35345c:20201107\n\n2020-11-02  7.0.10-36  <quetzlzacatenango@image...>\n  * check and report if profile is corrupt.\n  * do not add entropy based on mkstemp() unique filename.\n\n2020-10-31  7.0.10-35  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-35 GIT revision 17762:df5df8489:20201031\n\n2020-10-14  7.0.10-35  <quetzlzacatenango@image...>\n  * Prefer ffmpeg over avconv.\n  * Support median image statistic and median property.\n  * Add -extend option to {display,animate,import}.\n  * Support papersize property, e.g. [%papersize:A5].\n\n2020-10-07  7.0.10-34  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-34 GIT revision 17695:de3284341:20201008\n\n2020-10-05  7.0.10-34  <quetzlzacatenango@image...>\n  * Check for linux-compatible sendfile().\n\n2020-10-04  7.0.10-33  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-33 GIT revision 17683:c1bfec283:20201004\n\n2020-10-04  7.0.10-33  <quetzlzacatenango@image...>\n  * Miscellaneous clean-up.\n\n2020-10-02  7.0.10-32  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-32 GIT revision 17670:1686dd921:20201002 \n\n2020-09-27  7.0.10-32  <quetzlzacatenango@image...>\n  * enable WMF for module build.\n  * writing PDF requires a seekable stream.\n\n2020-09-27  7.0.10-31  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-31 GIT revision 17652:78ad905d9:20200926\n\n2020-09-20  7.0.10-31  <quetzlzacatenango@image...>\n  * Add support for APNG (specify explicitly, e.g. apng:animate.png).\n  * Add support for WEBM.\n\n2020-09-19  7.0.10-30  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-30 GIT revision 17641:ab95f7264:20200919\n\n2020-09-15  7.0.10-30 Dirk Lemstra <dirk@lem.....org>\n  * Fixed registry lookup of GhostScript that now writes the patch version to the\n    registry (reference https://github.com/ImageMagick/ImageMagick/issues/2571).\n\n2020-09-07  7.0.10-30  <quetzlzacatenango@image...>\n  * Add endian support to JSON coder.\n  * Regression: MapCache type cache allocation skipped (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/97).\n  * Some DCM images include a thumbnail (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2558).\n\n2020-09-05  7.0.10-29  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-29 GIT revision 17580:fc52fa0a9:20200905\n\n2020-09-05  7.0.10-29  <quetzlzacatenango@image...>\n  * Eliminate infinite loop for certain SVG styles (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/96).\n  * Add version element to JSON file format (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/91).\n\n2020-09-01  7.0.10-29 Dirk Lemstra <dirk@lem.....org>\n  * Enabled support for AVIF encoding on Windows.\n  * Clip path in 8bim profile is updated when the image is extended. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2414)\n\n2020-08-16  7.0.10-28  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-28 GIT revision 17533:41e79fc33:20200816\n\n2020-08-16  7.0.10-28  <quetzlzacatenango@image...>\n  * Distorted clip path after -extent (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2414).\n  * Paths in Photoshop EPS files are corrupted on conversion (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2413).\n\n2020-08-09  7.0.10-27  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-27 GIT revision 17525:ae6ace83c:20200809\n\n2020-08-08  7.0.10-27  <quetzlzacatenango@image...>\n  * fix regression when detecting the libz delegate library.\n\n2020-08-08  7.0.10-26  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-26 GIT revision 17520:9c2744359:20200808\n\n2020-08-02  7.0.10-26  <quetzlzacatenango@image...>\n  * Add animated webp blend method support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2351).\n  * Add support for OpenRaster (.ora) image format (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2342).\n  * Paths in Photoshop EPS files are no longer corrupted (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2380).\n\n2020-07-31  7.0.10-25  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-25 GIT revision 17497:0e12ff687:20200731\n\n2020-07-25  7.0.10-25  <quetzlzacatenango@image...>\n  * Remove UseCIEColor setting from PDF code as its use is not recommended.\n  * Update to the latest documentation.\n\n2020-07-18  7.0.10-24  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-24 GIT revision 17483:d11a2ec03:20200718\n\n2020-07-18  7.0.10-24 Dirk Lemstra <dirk@lem.....org>\n  * To preserve compression of input image with the tiff encoder use:\n    -define tiff:preserve-compression=true.\n\n2020-07-05  7.0.10-24  <quetzlzacatenango@image...>\n  * Add support for the -white-balance command-line option.\n  * Discover hidden files when globbing (e.g. *.jpg) (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2239).\n  * New inverse-log evaluate operator.\n\n2020-07-04  7.0.10-23  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-23 GIT revision 17437:894231bc3:20200704\n\n2020-06-28  7.0.10-23  <quetzlzacatenango@image...>\n  * Ensure that float is valid in ClampToQuantum() (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2219).\n  * New pseudo-image format, ashlar, e.g.\n    convert *.jpg -resize 320x320 ashlar:canvas.png).\n\n2020-06-27  7.0.10-22  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-22 GIT revision 17415:5318a3e0a:20200627\n\n2020-06-24  7.0.10-22  <quetzlzacatenango@image...>\n  * Fix wrapping of caption (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2178).\n  * Sanity check of affine matrix when drawing.\n\n2020-06-22  7.0.10-21  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-21 GIT revision 17395:af81c28c9:20200622\n\n2020-06-21  7.0.10-21  <quetzlzacatenango@image...>\n  * New image property, %N, only report the # of frames in an image sequence,\n    just once rather than on a per frame basis\n  * Problems converting CMYK to RGB regression (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/83)\n\n2020-06-21  7.0.10-21 Dirk Lemstra <dirk@lem.....org>\n  * Added support for 32 bit zip with prediction format to the PSD decoder\n    (reference https://github.com/ImageMagick/ImageMagick/issues/455).\n\n2020-06-20  7.0.10-20  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-20 GIT revision 17372:d91c43f3b:20200620\n\n2020-06-14  7.0.10-20  <quetzlzacatenango@image...>\n  * Fix out-of-bounds vulnerability when reading sixel images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2143).\n  * Fix incorrect parsing of font family list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2153).\n\n2020-06-12  7.0.10-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-19, GIT revision 17343:e552d22:20200612\n\n2020-06-09  7.0.10-19 Cristy  <quetzlzacatenango@image...>\n  * Improve checking for write failures (reference\n    https://github.com/ImageMagick/ImageMagick/pull/2081).\n\n2020-06-08  7.0.10-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-18, GIT revision 17333:d071c2032:20200608\n\n2020-06-08  7.0.10-18 Cristy  <quetzlzacatenango@image...>\n  * Colorspace change will remove ICC profile (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/82).\n\n2020-06-07  7.0.10-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-17, GIT revision 17311:8b5350f:20200607\n\n2020-06-03  7.0.10-17 Cristy  <quetzlzacatenango@image...>\n  * Free up memory after a ICC profile is removed.\n\n2020-05-31  7.0.10-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-16, GIT revision 17294:5be1abe:20200531\n\n2020-05-30  7.0.10-16 Cristy  <quetzlzacatenango@image...>\n  * Fix PDF XREF directory for image sequences with and without ICC profiles.\n\n2020-05-29  7.0.10-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-15, GIT revision 17282:9294896:20200529\n\n2020-05-24  7.0.10-15 Cristy  <quetzlzacatenango@image...>\n  * Clipping was not returning expected results (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2061).\n  * Don't write a ICC profile to PDF if the image is gray (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2070).\n\n2020-05-22  7.0.10-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-14, GIT revision 17268:e9c804c93:20200522\n\n2020-05-22  7.0.10-14 Cristy  <quetzlzacatenango@image...>\n  * Errant warning when reading a profile file (reference\n    https://github.com/ImageMagick/ImageMagick/issues/2030).\n   * Fix one off error on PDF object for images with ICC profile.\n\n2020-05-17  7.0.10-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-13, GIT revision 17257:e3b442c:20200517.\n\n2020-05-17  7.0.10-13 Cristy  <quetzlzacatenango@image...>\n  * Remove errant debugging statement in SVG coder.\n\n2020-05-15  7.0.10-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-12, GIT revision 17242:e14b3fb:20200515.\n\n2020-05-12  7.0.10-12 Cristy  <quetzlzacatenango@image...>\n  * Black artefacts during quantization (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/2007#discussioncomment-13546).\n\n2020-05-08  7.0.10-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-11, GIT revision 17230:088df0e:20200508.\n\n2020-04-28  7.0.10-11 Cristy  <quetzlzacatenango@image...>\n  * Disable \"random\" OpenCL kernel.  Previously the work load was distributed\n    but each started with the same random seed.\n  * Finished implementation of -distort rigid-affine.\n  * Enable threaded PNG coder.\n\n2020-04-27  7.0.10-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-10, GIT revision 17205:9b0340e:20200427\n\n2020-04-27  7.0.10-10 Cristy  <quetzlzacatenango@image...>\n  * Correction to allocate a colormap of the maximum colors when color\n    reducing an image sequence.\n  * Write to stdout for mp4:-.\n\n2020-04-25  7.0.10-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-9, GIT revision 17190:13fdcd1:20200426.\n\n2020-04-25  7.0.10-9 Cristy  <quetzlzacatenango@image...>\n  * Allocate a colormap of the maximum colors when color reducing an image\n    sequence.\n  * Label was not centered properly (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1879).\n\n2020-04-24  7.0.10-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-8, GIT revision 17175:481b85f:20200424.\n\n2020-04-23  7.0.10-8 Cristy  <quetzlzacatenango@image...>\n  * Some configure --with-method-prefix methods were missing (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1912).\n\n2020-04-19  7.0.10-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-7, GIT revision 17170:c635e88:20200419.\n\n2020-04-07  7.0.10-7 Cristy  <quetzlzacatenango@image...>\n  * Fix erroneous \"insufficient image data\" exception (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1883).\n  * Fix an unconditional jump for the XPM coder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1895).\n  * Improve unrotate value returned by the minimum bounding box (thanks\n    to Fred Weinhaus).\n\n    https://github.com/ImageMagick/ImageMagick/discussions/1880).\n2020-04-06  7.0.10-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-6, GIT revision 17146:634bbfd:20200406.\n\n2020-04-05  7.0.10-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-5, GIT revision 17143:8be18423e:20200405.\n\n2020-04-05  7.0.10-5 Cristy  <quetzlzacatenango@image...>\n * Default inkscape delegate to version 0.92 (reference\n    https://github.com/ImageMagick/ImageMagick/discussions/1880).\n  * Set monochrome image depth to 1 for Group4 compression.\n\n2020-04-05  7.0.10-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-4, GIT revision 17137:eeff0b6:20200405\n\n2020-03-28  7.0.10-4 Cristy  <quetzlzacatenango@image...>\n  * The X max attribute for certain fonts is zero (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37723).\n  * Multi-value of jp2:quality does not work (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1873).\n  * Return EPS & TIFF images from the EPT image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37781).\n\n2020-03-27  7.0.10-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-3, GIT revision 17108:5a4f5a9:20200327.\n\n2020-03-22  7.0.10-3 Cristy  <quetzlzacatenango@image...>\n  * The -charcoal option should ignore the alpha channel.\n  * Fix numerical instability issue when drawing lines\n  * Improve mono font rendering (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37723).\n\n2020-03-21  7.0.10-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-2, GIT revision 17088:ed6f37f:20200322.\n\n2020-03-16  7.0.10-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed another sizing issue with the label coder when pointsize is set.\n  * Respect explicit image filename modified (e.g. png24:im.png) (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1835).\n  * Add support for returning the minimum bounding box of an image with the\n    %[minimum-bounding-box] property.\n  * Stroked dash array render properly again.\n\n2020-03-15  7.0.10-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-1, GIT revision 17065:130e52e:20200315.\n\n2020-03-14  7.0.10-1 Cristy  <quetzlzacatenango@image...>\n  * Add support for returning the convex hull of an image with the\n    %[canvas-hull] property.\n\n2020-03-09  7.0.10-1 Dirk Lemstra <dirk@lem.....org>\n  * Added option to specify the preferred version when writing a PDF file with\n    -define pdf:version=version (e.g. 1.7).\n\n2020-03-07  7.0.10-1 Cristy  <quetzlzacatenango@image...>\n  * Do not throw exception on empty draw path (reference\n    https://github.com/ImageMagick/ImageMagick/issues/974).\n  * Fix possible buffer overflow in ComplexImages().\n  * SVG to MVG requires transforms to appear before clipping paths (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1860).\n\n2020-03-06  7.0.10-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.10-0, GIT revision 17026:fd430ac9a:20200307\n\n2020-03-01  7.0.10-0 Cristy  <quetzlzacatenango@image...>\n  * Label text no longer gets cut-off (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37621).\n  * Prevent heap overflow (reference\n     https://github.com/ImageMagick/ImageMagick/issues/1857).\n\n2020-02-29  7.0.9-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-27, GIT revision 17006:49d81b672:20200229\n\n2020-02-24  7.0.9-27 Cristy  <quetzlzacatenango@image...>\n  * Make sure we can grok this Fx expression: 1- -2.\n  * Do not advance when substituting a NULL string.\n  * Correct alpha for named colors in the Q32 non-HDRI build.\n  * Write Group4 compressed image as a single strip.\n\n2020-02-23  7.0.9-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-26, GIT revision 16972:49f1e4de2:20200223\n\n2020-02-22  7.0.9-26 Cristy  <quetzlzacatenango@image...>\n  * No percent sign in lab() color.\n  * Introducing the -color-threshold command-line option.\n  * Handle out of range HDRI values for -statistic option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37589).\n  * Fix improper casting when computing image signature (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37594).\n\n2020-02-21  7.0.9-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-25, GIT revision 16931:2a56db8:20200221\n\n2020-02-18  7.0.9-25 Cristy  <quetzlzacatenango@image...>\n  * Adapt to a change in command-line options in the SVG inkscape delegate.\n\n2020-02-17  7.0.9-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-24, GIT revision 16919:41efef9de:20200217\n\n2020-02-15  7.0.9-24 Cristy  <quetzlzacatenango@image...>\n  * Support connected-components:eccentricity-threshold,\n    connected-components:major-axis-threshold,\n    connected-components:minor-axis-threshold,\n    connected-components:angle-threshold.\n  * Set the alpha channel if the write mask is not enabled.\n  * Corrected ellipse orientation when computing image moments.\n\n2020-02-14  7.0.9-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-23, GIT revision 16884:acb56cd:20200214\n\n2020-02-08  7.0.9-23 Cristy  <quetzlzacatenango@image...>\n  * Report gray(127.5) as gray(50%).\n  * Support -define connected-components:perimeter-threshold=min-max\n\n2020-02-07  7.0.9-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-22, GIT revision 16855:8733f3e:20200207\n\n2020-02-03  7.0.9-22 Cristy  <quetzlzacatenango@image...>\n  * More work on connect components, e.g. keep-colors, remove-colors,\n    keep-topids.\n  * Initialize mutex before locking if its not already initialized.\n  * Support 24-bit TIFF images.\n\n2020-02-01  7.0.9-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-21, GIT revision 16823:290cb93:20200201.\n\n2020-01-27  7.0.9-21 Cristy  <quetzlzacatenango@image...>\n  * Support additional connected components defines.\n  * Refresh cache morphology when writing MPC images.\n\n2020-01-26  7.0.9-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-19, GIT revision 16789:bac6ecc:20200126\n\n2020-01-26  7.0.9-19 Cristy  <quetzlzacatenango@image...>\n  * Make PNG creation reproducible (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1270).\n  * Refactor uninitialize variable patch for -fx \"while(,)\" expression.\n\n2020-01-25  7.0.9-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-18, GIT revision 16780:08beae5:20200125\n\n2020-01-19  7.0.9-18 Cristy  <quetzlzacatenango@image...>\n  * Alpha draw primitive no longer returns a parser exception.\n  * Support 32-bit tiled TIFF images.\n  * New -connected-component options (reference\n    https://imagemagick.org/script/connected-components.php).\n\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37391).\n2020-01-18  7.0.9-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-17, GIT revision 16753:c300b3a:20200118\n\n2020-01-12  7.0.9-17 Cristy  <quetzlzacatenango@image...>\n  * Allow larger negative interline spacing (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=37391).\n  * Conditional compile for huge xml pages for RSVG delegate library.\n  * Put \"width\" property in the PNG namespace (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1833).\n  * -combine -colorspace sRGB no longer returns grayscale output (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1835).\n  * Support Jzazbz colorspace (contributed by snibgo @\n    http://im.snibgo.com/jzazbz.htm).\n\n2020-01-12  7.0.9-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-16, GIT revision 16719:fefd765:20200112.\n\n2020-01-12  7.0.9-16 Cristy  <quetzlzacatenango@image...>\n  * Fixed three failing Magick.NET unit tests.\n\n2020-01-11  7.0.9-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-15, GIT revision 16709:0000f6d:20200111.\n\n2020-01-11  7.0.9-15 Dirk Lemstra <dirk@lem.....org>\n  * Also support svg:xml-parse-huge when using librsvg.\n\n2020-01-10  7.0.9-15 Cristy  <quetzlzacatenango@image...>\n  * Optimize -evaluate-sequence option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1824).\n  * Support Fx do() iterator.\n  * `magick -size 100x100 xc:black black.pnm` no longer creates a white image\n    (reference https://github.com/ImageMagick/ImageMagick/issues/1817).\n  * setjmp/longjmp in jpeg.c no longer trigger undefind behavior (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37379).\n  * Permit compositing in the CMYK colorspace (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37368).\n\n2020-01-04  7.0.9-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-14, GIT revision 16654:89ef7ea:20200104.\n\n2020-01-01  7.0.9-14 Cristy  <quetzlzacatenango@image...>\n  * Support extended Fx assignment operators (e.g. *=, /=, ++, --, etc.)\n  * Support Fx for() iterator.\n  * Optimize Fx performance.\n  * Ensure circle.rb renders the same for IMv6 and IMv7 (reference\n    https://github.com/rmagick/rmagick/issues/905).\n\n2019-12-30  7.0.9-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-13, GIT revision 16616:dbafe0b:20191230.\n\n2019-12-27  7.0.9-13 Cristy  <quetzlzacatenango@image...>\n  * xc:white no longer creates a black PNM image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1817).\n  * Sync pixel cache for -kmeans option.\n  * Thread -kmeans option.\n  * PSD: only set the alpha channel when type is not 0.\n  * Fix Lab to custom profile (CMYK or RGB) conversion bug (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37318).\n\n2019-12-26  7.0.9-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-12, GIT revision 16587:7d6a559:20191226.\n\n2019-12-26  7.0.9-12 Cristy  <quetzlzacatenango@image...>\n  * Fix Build failure with MinGW-w64 (reference\n    https://github.com/ImageMagick/ImageMagick6/issues/67).\n  * Inject image profile properties immediately after the image is read.\n\n2019-12-23  7.0.9-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-11, GIT revision 16568:1d6c960:20191224.\n\n2019-12-18  7.0.9-11 Cristy  <quetzlzacatenango@image...>\n  * Replace pseudo-random number generator with a Xoshiro generator.\n  * The -layers optimize option requires a fully transparent previous image.\n\n2019-12-22  7.0.9-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-10, GIT revision 16548:281649843:20191222.\n\n2019-12-18  7.0.9-10 Cristy  <quetzlzacatenango@image...>\n  * Some clang releases do not support _aligned_alloc().\n  * Support -kmeans command-line option.\n\n2019-12-07  7.0.9-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-9, GIT revision 16513:8ec82f4:20191215.\n\n2019-12-07  7.0.9-9 Cristy  <quetzlzacatenango@image...>\n  * Build file clean-up (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1798).\n  * Improve semaphore handling @\n    https://github.com/ImageMagick/ImageMagick/pull/1798).\n  * Introduce HeapOverflowSanityCheckGetExtent() method (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1798).\n\n2019-12-01  7.0.9-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-8, GIT revision 16474:0bc0e95:20191207.\n\n2019-12-01  7.0.9-8 Cristy  <quetzlzacatenango@image...>\n  * -type bilevel behavior restored, it creates a black and white image.\n\n2019-11-30  7.0.9-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-7, GIT revision 16449:971ba06:20191130.\n\n2019-11-26  7.0.9-7 Cristy  <quetzlzacatenango@image...>\n  * Support Pocketmod image format, e.g.\n    convert -density 300 pages?.pdf pocketmod:organize.pdf\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Update documentation.\n\n2019-11-26  7.0.9-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-6, GIT revision 16407:1725ec3:20191126.\n\n2019-11-19  7.0.9-6 Cristy  <quetzlzacatenango@image...>\n  * Increase the maximum number of bezier coordinates (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1784).\n  * Santize \"'\" from SHOW and WIN delegates under Linux, '\"\\' for Windows\n    (thanks to Enzo Puig).\n  * Correct for TGA orientation (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34757).\n  * The result for -compose Copy -extent on a  MYK image is CMYK (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=37118).\n  * Fix potential buffer overflow when reading a fax image (alert from\n    Justin).\n  * Support dng:use-camera-wb option.\n\n2019-11-17  7.0.9-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-5, GIT revision 16369:747618e:20191117.\n\n2019-11-16  7.0.9-5 Cristy  <quetzlzacatenango@image...>\n  * Ensure Ascii85 compression is thread safe.\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-11-13  7.0.9-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-4, GIT revision 16354:5f53562:20191114.\n\n2019-11-10  7.0.9-4 Cristy  <quetzlzacatenango@image...>\n  * Add exception parameter to CMS transform methods.\n  * Output exception there is an attempt to perform an operation not allowed by\n    the security policy\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-10-30  7.0.9-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-2, GIT revision 16325:6f84d89:20191030.\n\n2019-10-29  7.0.9-2 Cristy  <quetzlzacatenango@image...>\n  * JPEG and JPG are aliases in coder security policy.\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-10-27  7.0.9-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-1, GIT revision 16313:e068be3:20191027.\n\n2019-10-27  7.0.9-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-10-23  7.0.9-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.9-0, GIT revision 16297:8744fd9:20191024\n\n2019-10-06  7.0.9-0 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous issues  posted to GitHub (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support trim:background-color define for -trim option.\n\n2019-10-05  7.0.8-68 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-68, GIT revision 16184:b75b0e5:20191005.\n\n2019-09-30  7.0.8-68 Cristy  <quetzlzacatenango@image...>\n  * Support animated WebP encoding/decoding (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1708).\n  * Text stroke cut off (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=36829).\n  * Adds support for lossless JPEG1 recompression (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36828).\n\n2019-09-29  7.0.8-67 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-67, GIT revision 16145:6f2feb9:20190929.\n\n2019-09-28  7.0.8-67 Cristy  <quetzlzacatenango@image...>\n  * line endings renedered as empty boxes (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1704).\n\n2019-09-21  7.0.8-66 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-66, GIT revision 16134:f6ce80a:20190921.\n\n2019-09-09  7.0.8-66 Cristy  <quetzlzacatenango@image...>\n  * Support compound statements in FX while() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1701).\n\n2019-09-15  7.0.8-65 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-65, GIT revision 16130:254db34:20190915.\n\n2019-09-09  7.0.8-65 Cristy  <quetzlzacatenango@image...>\n  * Eliminate fault when trace delegate is not available.\n  * Properly distinquish linear and non-linear gray colorspaces (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1680).\n\n2019-09-07  7.0.8-64 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-64, GIT revision 16108:2ad3cbc:20190907.\n\n2019-09-02  7.0.8-64 Cristy  <quetzlzacatenango@image...>\n  * Support XPM symbolic (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1684).\n  * DilateIntensity is channel independent (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36641).\n\n2019-08-31  7.0.8-63 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-63, GIT revision 16088:3b7a33d:20190831.\n\n2019-08-24  7.0.8-63 Cristy  <quetzlzacatenango@image...>\n  * Properly identify the DNG and AI image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36581).\n\n2019-08-23  7.0.8-62 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-62, GIT revision 16061:7525595:20190823.\n\n2019-08-23  7.0.8-62 Dirk Lemstra <dirk@lem.....org>\n  * Added option to limit the maximum point size with -define\n    caption:max-pointsize=pointsize.\n  * Corrected JP2 numresolution calculation (reference:\n    https://github.com/ImageMagick/ImageMagick/issues/1673)\n\n2019-08-19  7.0.8-62 Cristy  <quetzlzacatenango@image...>\n  * Conditionally compile call to AcquireCLocale() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1669).\n  * More robust support for converting bitmap to vector.\n\n2019-08-16  7.0.8-61 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-61, GIT revision 16033:0c5808c:20190816.\n\n2019-08-03  7.0.8-61 Cristy  <quetzlzacatenango@image...>\n  * Issue with -background and -swirl (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36512).\n\n2019-08-10  7.0.8-60 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-60, GIT revision 16020:52ff205:20190810.\n\n2019-08-07  7.0.8-60 Cristy  <quetzlzacatenango@image...>\n  * Enable reading EXR image file from stdin.\n\n2019-08-04  7.0.8-59 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-59, GIT revision 15986:c3de0e7:20190804.\n\n2019-08-01  7.0.8-59 Cristy  <quetzlzacatenango@image...>\n  * Module is a reserved keyword for C++ 20 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1650).\n\n2019-07-29  7.0.8-58 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-58, GIT revision 15962:cf00632:20190729.\n\n2019-07-27  7.0.8-58 Cristy  <quetzlzacatenango@image...>\n  * Improve GetNextToken() performance.\n\n2019-07-26  7.0.8-57 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-57, GIT revision 15948:8fba4a3:20190726.\n\n2019-07-22  7.0.8-57 Cristy  <quetzlzacatenango@image...>\n  * Heap-buffer-overflow in Postscript coder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1644).\n  * The -alpha shape option nondeteministic under OpenMP (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36396).\n  * Correction to the ModulusAdd and ModulusSubtract composite op (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36413).\n\n2019-07-20  7.0.8-56 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-56, GIT revision 15936:2ac4147:20190720.\n\n2019-07-20  7.0.8-56 Cristy  <quetzlzacatenango@image...>\n  * Unexpected -alpha shape results (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36396).\n  * Converting from PDF to PBM inverts the image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1643).\n\n2019-07-18  7.0.8-55 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-55, GIT revision 15930:ac09240:20190718.\n\n2019-07-18  7.0.8-55 Cristy  <quetzlzacatenango@image...>\n  * Heap-buffer overflow (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1641\n  * PerlMagick test suite passes again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1640) \n\n2019-07-16  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-54, GIT revision 15916:e868e22:20190716.\n\n2019-07-08  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n  * resolve division by zero  (reference\n     https://github.com/ImageMagick/ImageMagick/issues/1629).\n  * introducing MagickLevelImageColors() MagickWand method.\n  * Transient problem with text placement with gravity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1633).\n  * Support TIM2 image format (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1571).\n  * For -magnify option, specify an alternative scaling method with -define\n    magnify:method=method, choose from these methods: eagle2X, eagle3X,\n    eagle3XB, epb2X, fish2X, hq2X,  scale2X (default), scale3X, xbr2X.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-53, GIT revision 15828:f5d59c0:20190705.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n   * Fix -fx parsing issue (reference\n     https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36314).\n\n2019-07-05  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-52, GIT revision 15825:ea47310:20190705.\n\n2019-07-01  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Eliminate buffer overflow in TranslateEvent() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1621).\n\n2019-06-30  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-51, GIT revision 15812:51f11c4:20190630.\n\n2019-06-24  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Clone rather than copy X window name/icon.\n  * Optimize PDF reader.\n\n2019-06-23  7.0.8-50 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-50, GIT revision 15778:4a60519:20190623\n\n2019-06-14  7.0.8-50 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading all images from a HEIC image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1391).\n  * Heap-buffer-overflow in MagickCore/fourier.c (reference\n   https://github.com/ImageMagick/ImageMagick/issues/1588).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-06-08  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-49, GIT revision 15708:6d7e1db:20190608\n\n2019-06-03  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Add support for RGB565 image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36078).\n  * Use user defined allocator instead of `malloc` (reference\n    https://github.com/ImageMagick/ImageMagick6/pull/49/).\n  * Add static decorator to accelerator kernels (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1366).\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-48, GIT revision 15689:061a3bb82:20190601\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Fix transient convolution bug (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36119).\n\n2019-05-26  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-47, GIT revision 15681:5cffc6cbb:20190526\n\n2019-05-19  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Support 16 and 32 bit tiled float TIFF images.\n  * Convolve morphology alpha channel fix (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36086).\n  * Text improvements to the internal SVG renderer.\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-46, GIT revision 15655:84dd3301c:20190518\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * PerlMagick unit tests pass again.\n  * Builds under MacOS X and FreeBSD works again.\n  * Return HEIC images in the sRGB colorspace.\n\n2019-05-12  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-45, GIT revision 15634:784105bcb:20190512\n\n2019-05-06  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Fix image signatures to ensure they are Q-depth invariant (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35970).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-44, GIT revision 15600:41f47759a:20190503\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-43, GIT revision 15595:0062cef74:20190502\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-29  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-42, GIT revision 15570:71190ccd0:20190424\n\n2019-04-20  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-19  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-41, GIT revision 15540:c78993d13:20190420\n\n2019-04-13  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Honor SOURCE_DATE_EPOCH environment variable (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1496/).\n  * Standardize on UTC time for any image format timestamp.\n  * Add MagickAutoThresholdImage(), MagickCannyEdgeImage(),\n    MagickComplexImages(), MagickConnectedComponentsImage(),\n    MagickHoughLineImage(), MagickKuwaharaImage(), MagickLevelizeImageColors(),\n    MagickLevelImageColors(), MagickMeanShiftImage(), MagickPolynomialImage(),\n    MagickRangeThresholdImage(), MagickSetSeed(), MagickWaveletDenoiseImage()\n    methods to MagickWand API.\n\n2019-04-12  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-40, GIT revision 15510:7e503e231:20190412\n\n2019-04-10  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n\n2019-04-07  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-39, GIT revision 15489:6120f8bc1:20190406\n\n2019-04-06  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * The -layers option compared pixels inocorrectly as opacity rather than\n    alpha.\n  * The -preview raise option now returns expected results.\n  * Initialise ghostscript instances with NULL (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1538).\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-38, GIT revision 15483:23edcef04:20190406\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Modulo off by one patch for -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-37, GIT revision 15470:477216fd7:20190403\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Fixed -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-03-31  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-36, GIT revision 15464:3a928224d:20190331\n\n2019-03-27  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-24  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-35, GIT revision 15440:4a0a88e41:20190324\n\n2019-03-23  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * -draw image DstOver is now responsive to the composite operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35650).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-15  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-34, GIT revision 15413:860af935d:20190315\n\n2019-03-11  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Associate one lock with each resource.\n  * Report exception if opening TIFF did not work out.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-03-10  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-33, GIT revision 15401:c805e3205:20190310\n\n2019-03-06  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Fix SVG conversion infinite loop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35591).\n  * Initialize primitive drawing structure after resizing.\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-32, GIT revision 15386:58d9c4692:20190305\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Fix out-of-boundary LocaleLowerCase() @\n    https://github.com/ImageMagick/ImageMagick/issues/1495\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-31, GIT revision 15381:3122a669d:20190304\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * -trim is no longer sensitive to the image virtual canvas.\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-30, GIT revision 15376:16d2b4e6a:20190303\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Support define to remove additional background from an image during a\n    trim, e.g. -fuzz 5% -define trim:percent-background=0% -trim.\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-29, GIT revision 15368:5d8ed9f56:20190228\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-02-18  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-28, GIT revision 15345:09a7c67dd:20190218\n\n2019-02-12  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-27, GIT revision 15315:5d48cd312:20190209\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Mod patch to properly handle subimage ranges (e.g. image.gif[2-3]).\n\n2019-02-03  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-26, GIT revision 15294:726bd82a3:20190203\n\n2019-02-02  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-01-27  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-25, GIT revision 15279:7da783a5b:20190127\n\n2019-01-19  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Eliminate spurious font warning (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1458).\n  * Support HEIC EXIF & XMP profiles.\n\n2019-01-12  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-24, GIT revision 15233:db129ba64:20190112\n\n2019-01-08  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe option real clip limit (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=35292).\n  * ShadeImage() kernels can return negative pixels, clamp to range (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1319).\n  * Annotate with negative offsets no longer renders slanted text.\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-23, GIT revision 15199:ba07f7d07:20190101\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * CacheInfo destructor must be aligned in DestroyPixelStream().\n\n2018-12-30  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-22, GIT revision 15189:842164090:20181230\n\n2018-12-29  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Support negative rotations in a geometry (e.g. -10x-10+10+10).\n  * Return expected canvas offset after a crop with gravity.\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-21, GIT revision 15179:114be1716:20181227\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Check to ensure SeekBlob() offset can be represented in an off_t.\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-20, GIT revision 15170:8e8222e87:20181223\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Cube image format returns a HALD image.\n  * CLAHE tiles overlapped are now centered relative to the image.\n\n2018-12-19  7.0.8-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-19, GIT revision 15153:e74ed77f5:20181219\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-18, GIT revision 15146:b5eccd295:20181218\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Fixed Magick++ compile error on Mac OS X.\n\n2018-12-17  7.0.8-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-17, GIT revision 15142:32f2d195e:20181217\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe clip limit with percentages (e.g. -clahe 50x50%+128+3).\n\n2018-12-10  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-16, GIT revision 15109:9a9af88de:20181210.\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Check for modulo underflow.\n  * Change SVG default DPI to 96 from 90 to meet recommendation of SVG2 & CSS.\n\n2018-12-01  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-15, GIT revision 15059:2fb22e07b:20181201\n\n2018-11-21  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Added support for the -clahe option: contrast limited adaptive histogram\n    equalization.\n\n2018-11-13  7.0.8-15 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GIMP 2.10 files (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1381).\n\n2018-10-23  7.0.8-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-14, GIT revision 14943:1a0da3dd0:20181023\n\n2018-10-21  7.0.8-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-13, GIT revision 14936:d3ec5abe2:20181021.\n\n2018-10-04  7.0.8-13 Dirk Lemstra <dirk@lem.....org>\n  * Adding coder headers with magic.xml will no longer be supported.\n  * Adding coder aliases with coder.xml will no longer be supported.\n\n2018-09-16  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-12, GIT revision 14843:cb5cf1959:20180923\n\n2018-09-15  7.0.8-12 Dirk Lemstra <dirk@lem.....org>\n  * Added support for arithmetic coding to the jpeg encoder:\n    -define jpeg:arithmetic-coding=true.\n\n2018-09-08  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-08-28  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-11, GIT revision 14729:798fbdb5b:20180828\n\n2018-08-15  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Add support for \"module\" security policy.\n\n2018-08-13  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-10, GIT revision 14646:48fba3256:20180813\n\n2018-08-12  7.0.8-10 Dirk Lemstra <dirk@lem.....org>\n  * Added dcraw coder (dcraw:img.cr2) that can be used to force the use of the\n    dcraw delegate when libraw is the default raw delegate.\n  * Restored thread support for the HEIC coder.\n\n2018-08-08  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * ThumbnailImage function no longer reveals sensitive information (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1243).\n\n2018-08-06  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-9, GIT revision 14618:a3663c3dc:20180805.\n\n2018-07-24  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * XBM coder leaves the hex image data uninitialized if hex value of the\n    pixel is negative.\n  * More improvements to SVG text handling.\n  * New -range-threshold option that combines hard and soft thresholding.\n\n2018-07-23  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-8, GIT revision 14583:300fdbcfd:20180723.\n\n2018-07-20  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Non-HDRI ScaleLongToQuantum() private method no longer adds a half interval.\n  * Fixed memset() negative-size-param (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1217).\n\n2018-07-16  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-7, GIT revision 14561:f85c23180:20180716.\n\n2018-07-15  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-07-08  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-6, GIT revision 14541:db940ccd2:20180708.\n\n2018-07-06  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Improve SVG support for tspan element.\n  * Add support for -fx image.extent.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-5, GIT revision 14514:bba545bbb:20180704.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed a few potential memory leaks\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-07-02  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-4, GIT revision 14505:4613eed4a:20180702.\n\n2018-06-28  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Small tweaks to compile under Cygwin.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Support %B property, the image file size without any decorations.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-3, GIT revision 14489:c63c504e8:20180624.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Apply translate component of SVG transform rotate.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-2, GIT revision 14476:cda11d81d:20180618.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * More robust SVG text handling.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-1, GIT revision 14468:94cb08785:20180616.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Fixed an issue with stroke and label: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34142).\n  * PNG: set storage class to DirectClass if alpha enabled (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34121).\n\n2018-06-12  7.0.8-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-0, GIT revision 14459:d7c892d5a:20180612.\n\n2018-06-11  7.0.8-0  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-11  7.0.7-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-39, GIT revision 14445:cc962acde:20180611.\n\n2018-06-06  7.0.7-39  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-02  7.0.7-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-38, GIT revision 14409:01e395a73:20180602.\n\n2018-05-30  7.0.7-38  <quetzlzacatenango@image...>\n  * Heap buffer overflow fix (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1156).\n  * Boundary issues with -gamma option when HDRI is enabled (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1151).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-29  7.0.7-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-37, GIT revision 14393:61d7e8b17:20180529.\n\n2018-05-29  7.0.7-37  <quetzlzacatenango@image...>\n  * Properly initialize SVG color style.\n\n2018-05-28  7.0.7-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-36, GIT revision 14390:3a6bd703f:20180528.\n\n2018-05-28  7.0.7-36  <quetzlzacatenango@image...>\n  * A SVG rectangle with a width and height of 1 is a point.\n\n2018-05-21  7.0.7-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-35, GIT revision 14356:13507412c:20180521.\n\n2018-05-21  7.0.7-35  <quetzlzacatenango@image...>\n  * Fixed memory corruption for MVG paths.\n\n2018-05-20  7.0.7-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-34, GIT revision 14348:ac9ff6ba1:20180520.\n\n2018-05-20  7.0.7-34 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading eXIf chunks to the PNG coder.\n\n2018-05-19  7.0.7-34  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Improved clip / composite mask handling.\n\n2018-05-16  7.0.7-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-33, GIT revision 14326:58c2e4972:20180516.\n\n2018-05-03  7.0.7-33  <quetzlzacatenango@image...>\n  * Restore SetImageAlpha() behavior.\n  * Fix -clip and -mask options.\n\n2018-05-13  7.0.7-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-32, GIT revision 14307:f61f674e3:20180513.\n\n2018-05-03  7.0.7-31  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-01  7.0.7-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-30, GIT revision 14242:730f1d1d3:20180501.\n\n2018-05-01  7.0.7-30  <quetzlzacatenango@image...>\n  * Missing break when checking \"compliance\" element.\n\n2018-04-30  7.0.7-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-29, GIT revision 14225:41edbdcea:20180430.\n\n2018-03-26  7.0.7-29  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-24  7.0.7-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-28, GIT revision 23615:edd71782e:20180325.\n\n2018-03-21  7.0.7-28  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-18  7.0.7-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-27, GIT revision 23466:734b146df:20180318.\n\n2018-03-17  7.0.7-27  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-11  7.0.7-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-26, GIT revision 23344:7a03766ef:20180311.\n\n2018-03-10  7.0.7-26  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-25, GIT revision 23177:17a986472:20180304.\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-25  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-24, GIT revision 23079:7ccb76178:20180225.\n\n2018-02-19  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Do not refer to page in OptimizeLayerFrames (reference\n    https://github.com/ImageMagick/ImageMagick/pull/987).\n  * PerlMagick unit tests pass again.\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-18  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-23, GIT revision 22969:c6b3a22b0:20180218.\n\n2018-02-09  7.0.7-23 Dirk Lemstra <dirk@lem.....org>\n  * Add support for reading the HEIC image format to the Windows build.\n\n2018-01-23  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n  * Add list-length policy to limit the maximum image sequence length.\n\n2018-01-22  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-22, GIT revision 22391:e8be814f1:20180122.\n\n2018-01-06  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Support aspect ratio geometry, e.g. -crop 3:2.\n  * Add support for reading the HEIC image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/507).\n  * Fixed numerous memory leaks, credit to OSS Fuzz.\n\n2018-01-06  7.0.7-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-21, GIT revision 22168:a91afc45b:20180106.\n\n2018-01-06  7.0.7-21 Dirk Lemstra <dirk@lem.....org>\n  * Fix some enum values in the OpenCL code.\n\n2018-01-06  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-20, GIT revision 22161:33a04d3e5:20180105.\n\n2018-01-05  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-01-01  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-19, GIT revision 22133:977fe08bf:20180101.\n\n2017-12-29  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Check for webpmux library version 0.4.4 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/896).\n\n2017-12-26  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-18, GIT revision 22096:ad4bdeb40:20171228.\n\n2017-12-28  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading from pipe under Windows (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=33288).\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-17, GIT revision 22093:9caea323b:20171227.\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Fix heap use after free error (reference\n    https://github.com/ImageMagick/ImageMagick/issues/918).\n\n2017-12-24  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-16, GIT revision 22038:e55dc7626:20171225.\n\n2017-12-18  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading multi-layer XCF image file.\n  * Fix possible stack overflow in WEBP reader (reference\n    https://github.com/ImageMagick/ImageMagick/issues/907)\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-12-16  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-15, GIT revision 21924:30cb31746:20171216.\n\n2017-12-08  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Overall standard deviation is the average of each pixel channel (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Update to the latest ImageMagick documentation.\n\n2017-12-05  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-14, GIT revision 21855:dc73b2aba:20171205.\n\n2017-11-30  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Support Stereo composite operator.\n  * Fix build failure with --without-modules (reference\n    https://github.com/ImageMagick/ImageMagick/issues/890).\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-13, GIT revision 21823:72cb0fd0c:20171130.\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Fix build failure with libraw 0.14.8 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/888).\n\n2017-11-29  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-12, GIT revision 21814:5ef2c5a67:20171129.\n\n2017-11-12  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * The -tint option no longer munges the alpha channel (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=1&t=33070).\n  * Don't delete in-memory blob when reading an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/886).\n  * Support HDRI color profile management.\n\n2017-11-11  7.0.7-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-11, GIT revision 21635:0447c6b46:20171111.\n\n2017-11-05  7.0.7-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-10, GIT revision 21612:36e2aabfd:20171105.\n\n2017-11-03  7.0.7-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed a problem with resource bookkeeping in AcquireMatrixInfo().\n\n2017-10-30  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-9, GIT revision 21580:2682a311e:20171031.\n\n2017-10-20  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Encode JSON control characters (reference\n    https://github.com/ImageMagick/ImageMagick/issues/848).\n\n2017-10-27  7.0.7-9 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading mipmaps in dds images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/845).\n\n2017-10-15  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-8, GIT revision 21507:63ffc9878:20171015.\n\n2017-10-08  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Return expected results for a percent 0 -chop option argument (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32806).\n  * Tweaks to OpenMP support within ImageMagick.\n\n2017-10-07  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-7, GIT revision 21432:29003eeed:20171007.\n\n2017-10-06  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Correct handling of GIF transparency (reference\n    https://github.com/ImageMagick/ImageMagick/issues/831).\n\n2017-10-04  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-6, GIT revision 21426:0a1cb507b:20171004.\n\n2017-10-03  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Reset the magick_list_initialized boolean when needed (reference\n    https://github.com/ImageMagick/ImageMagick/pull/826).\n\n2017-10-01  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-5, GIT revision 21382:3846f9d97:20171001.\n\n2017-09-28  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support URW-base35 fonts.\n\n2017-09-26  7.0.7-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed \"ping_preserve_iCCP=MagickTrue;\" statement that was inadvertently\n    added to coders/png.c (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32771).\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-4, GIT revision 21265:bdbc14590:20170923.\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-17  7.0.7-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-3, GIT revision 21202:6e6907ac7:20170917.\n\n2017-09-17  7.0.7-3 ADLab of Venustech\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-15  7.0.7-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop potential leaks in the JNG decoder (reference:\n    https://github.com/ImageMagick/ImageMagick/issues/760).\n  * Maximum valid hour is 23, not 24, in the PNG tIME chunk, and maximum\n    valid minute is 59, not 60.\n\n2017-09-12  7.0.7-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-2, GIT revision 21089:4e46ad9dd:20170912.\n\n2017-09-11  7.0.7-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Use signed integer arithmetic to calculate timezone corrections (reference\n    https://github.com/ImageMagick/ImageMagick/issues/685).\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-1, GIT revision 21065:ab2194121:20170909.\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-09-05 7.0.7-1 Dirk Lemstra <dirk@lem.....org>\n  * Added -define tiff:write-layers=true to add support for writing layered\n    tiff files.\n\n2017-09-03  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-0, GIT revision 20996:2f8ac2203:20170903.\n\n2017-08-28  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't overwrite symbolic links when the shred policy is enabled.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-10, GIT revision 20920:9940c367a:20170827.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Support -metric ssim, structual similarity index.\n\n2017-08-26  7.0.6-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed thread safety issue inside the pango and librsvg decoder\n    (reference: https://github.com/dlemstra/Magick.NET/issues/91).\n\n2017-08-20  7.0.6-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-9, GIT revision 20860:3f307d8ad:20170820.\n\n2017-08-18  7.0.6-9 Glenn Randers-Pehrson <glennrp@image...>\n  * Fixed bug with writing tIME chunk when timezone has a negative offset\n    (reference: https://github.com/ImageMagick/ImageMagick/issues/685)\n\n2017-08-18  7.0.6-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-8, GIT revision 20838:e2eb79427:20170818.\n\n2017-08-14  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support CubicSpline resize filter.  Define the lobes with the\n    -define filter:lobes={2,3,4} (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=32506).\n  * Prevent assertion failure when creating PDF thumbnail (reference\n    https://github.com/ImageMagick/ImageMagick/issues/674).\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-7, GIT revision 20799:0db4d8a16:20170812.\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Improve EPS aliasing (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32497).\n\n2017-08-11  7.0.6-7 Dirk Lemstra <dirk@lem.....org>\n  * Added a new option called 'dds:fast-mipmaps' (reference\n    https://github.com/ImageMagick/ImageMagick/issues/558)\n  * The mipmaps of a dds image can now be created from a list of images with\n    -define dds:mipmaps=fromlist (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30236).\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-6, GIT revision 20775:061d0fa25:20170810.\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-08-10  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * tests/validate.c: Show the reason for failures in the test logs,\n    if available.\n\n2017-08-03  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Put UTC time in the PNG tIME chunk instead of local time (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32447).\n\n2017-08-02  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-5, GIT revision 20715:26b28d50a:20170802.\n\n2017-08-01  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-29  7.0.6-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Properly set image->colorspace in the PNG decoder (previously\n    it was setting image->gamma, but only setting image->colorspace\n    for grayscale and gray-alpha images.  Reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32418).\n  * Fix improper use of NULL in the JNG decoder (CVE-2017-11750, Reference\n    https://github.com/ImageMagick/ImageMagick/issues/632).\n  * Added \"-define png:ignore-crc\" option to PNG decoder. When you know\n    your image has no CRC or ADLER32 errors, this can speed up decoding.\n    It is also helpful in debugging bug reports from \"fuzzers\".\n\n2017-07-29  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Off by one error for gradient coder (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32416),\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n\n2017-07-28  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-4, GIT revision 20657:4e81160d6:20170728.\n\n2017-07-24  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * YUV coder no longer renders streaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues) including\n    https://github.com/ImageMagick/ImageMagick/issues/618 (CVE-2017-12676).\n  * coders/png.c: Initialized quantum_scanline and quantum_info\n    to prevent a bad free (reference\n    https://github.com/ImageMagick/ImageMagick/issues/621).\n\n2017-07-25  7.0.6-4 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed write_chunk_from_profile() from coders/png.c because it has\n    not worked at least since version 6.7.6.\n  * Removed many redundant checks before RelinquishMagickMemory(), which\n    is safe to call with a NULL argument.\n  * Added experimental PNG orNT chunk, to store image->orientation.\n  * Removed vpAg chunk write support (we are now writing caNv instead).\n\n2017-07-24  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-3, GIT revision 20598:cc9c43b44:20170724.\n\n2017-07-23  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-23  7.0.6-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Fix memory leaks when reading a malformed JNG image:\n    https://github.com/ImageMagick/ImageMagick/issues/600 (CVE-2017-13141),\n    https://github.com/ImageMagick/ImageMagick/issues/602 (CVE-2017-12565).\n\n2017-07-21  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-2, GIT revision 20549:62fcf3d96:20170721.\n\n2017-07-19  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * The -monochrome option no longer returns a blank canvas (reference\n    https://github.com/ImageMagick/ImageMagick/issues/594).\n  * coders/png.c: fixed memory leak of quantum_info (CVE-2017-11539, reference\n    https://github.com/ImageMagick/ImageMagick/issues/582\n  * coders/png.c: fixed NULL dereference when trying to write an empty MNG\n    (CVE-2017-11522, reference\n    https://github.com/ImageMagick/ImageMagick/issues/586).\n\n2017-07-15  7.0.6-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Added caNv, eXIf, and pHYs to the list of PNG chunks to be removed\n    by the \"-strip\" option.\n\n2017-07-15  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-1, GIT revision 20447:c2a315e10:20170715.\n\n2017-07-13  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Implemented PNG eXIf chunk support.\n\n2017-07-08  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Support new -auto-threshold option.  OTSU and Triangle methods are\n    currently supported.  Look for the Kapur method in the next release.\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't use variable float_t / double_t, bump SO (reference\n    https://github.com/ImageMagick/ImageMagick/issues/510).\n  * Support DNG images with libraw delegate library.\n\n2017-07-02  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Reject PNG file that is too small (under 60 bytes) to contain\n    a valid image.\n  * Reject JPEG file that is too small (under 107 bytes) to contain\n    a valid image.\n  * Reject JNG file that is too small (under 147 bytes) to contain\n    a valid image.\n\n2017-06-22  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop a memory leak in read_user_chunk_callback() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/517,\n    CVE 2017-11310).\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-0, GIT revision 20194:b0c0d00:20170611.\n\n2017-06-10  7.0.6-0 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Accept exIf chunks whose data segment\n    erroneously begins with \"Exif\\0\\0\".\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Introduce SetMagickSecurityPolicy() (MagickCore) and\n    MagickSetSecurityPolicy() (MagickWand) to set the ImageMagick security\n    policy (reference https://github.com/ImageMagick/ImageMagick/issues/407).\n\n2017-06-02  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-10, GIT revision 20155:38ebc02:20170602.\n\n2017-06-01  7.0.5-10 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed experimental PNG zxIF chunk support; the proposal is dead.\n\n2017-06-01  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Fix choppy bitmap font rendering (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32071).\n  * The +opaque option is not longer a noop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32081).\n  * Add support  for 'hex:' property.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-9, GIT revision 20113:8b67333:20170528.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Transient error validating the JPEG-2000 image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/501).\n  * Properly allocate DCM image colormap (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32063).\n\n2017-05-26  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-8, GIT revision 20099:870a016:20170526.\n\n2017-05-23  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Improper allocation of memory for IM instances without threads (reference\n    https://github.com/ImageMagick/ImageMagick/issues/497).\n  * Delete corrupt image from list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/500).\n\n2017-05-19  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20078:7ce2d38:20170519.\n\n2017-05-15  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Support various image operators for the compare utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=31938).\n\n 2017-05-12  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20039:9371904:20170512.\n\n2017-05-10  7.0.5-6 John Cupitt <jcupitt@gmail.com>\n  * Revise DICOM window and rescale handling (reference\n    https://github.com/ImageMagick/ImageMagick/pull/484)\n\n2017-05-06  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Restore the -alpha Shape option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31879).\n  * Fix transient PDF bug (reference\n    https://github.com/ImageMagick/ImageMagick/issues/463).\n  * The +opaque option now works on all channels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31862).\n  * Ensure backwards compatibility for the -combine option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31855).\n  * Check for EOF conditions for RLE image format.\n  * Reset histogram page geometry (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31920).\n\n2017-04-24  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-5, GIT revision 19915:12eec43:20170424.\n\n2017-03-26  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Minimize buffer copies to improve OpenCL performance.\n  * Morphology thinning is no longer a no-op (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31650).\n  * Patch two PCD writer problems, corrupt output and dark pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=3164).\n  * Support ICC based PDF's (reference\n    https://github.com/ImageMagick/ImageMagick/issues/417).\n  * Fix improper EPS clip path rendering (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31722).\n\n2017-03-24  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-4, GIT revision 19754:350fff3:20170324.\n\n2017-03-21  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Respect -loop option for animate -window (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31619).\n\n2017-03-17  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-3, GIT revision 19741:070c3fb:20170317.\n\n2017-03-14  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Support namespaces for the security policy.\n  * Support the -authenticate option for PDF (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31530).\n\n2017-03-11  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-2, GIT revision 19696:da91a7c:20170311.\n\n2017-03-06  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Respect throttle policy (reference\n    https://github.com/ImageMagick/ImageMagick/issues/393).\n  * Return proper minima / maxima (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n\n2017-03-03  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-1, GIT revision 19662:b7f455a:20170303.\n\n2017-02-21  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Fix Spurious memory allocation message (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31438).\n  * Identical images should return inf for PSNR (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31487).\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-0, GIT revision 19616:505fea9:20170220.\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Fix transient bug with -separate option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/385).\n\n2017-02-18  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-10, GIT revision 19608:fe757a2:20170218.\n\n2017-02-18  7.0.4-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed fd leak for webp coder (reference\n    https://github.com/ImageMagick/ImageMagick/pull/382)\n\n2017-02-15  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent random pixel data for corrupt JPEG image (bug report from\n    Hirokazu Moriguchi, Sony).\n  * Restore -mattecolor option.\n  * Support pixel-cache and shred security policies.\n  * Bump Magick++ SO.  Previously a global replace changed matteColor to\n    alphaColor.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-9, GIT revision 19580:d474b37:20170214.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Revert patch that did not set update trait on alpha channel.\n\n2017-02-13  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-8, GIT revision 19574:7642384:20170213.\n\n2017-02-09  7.0.4-8 Dirk Lemstra <dirk@lem.....org>\n  * Fixed memory leak when creating nested exceptions in Magick++ (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=23&p=142634)\n\n2017-02-09  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Unbreak build without JPEG support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/373).\n  * Document behavior change in the security policy (thanks to yoya @\n    https://blog.awm.jp/2017/02/09/imagemagick-en/).\n  * Return unbiased standard deviation for image statistics (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n  * Don't set update trait on alpha channel (private e-mail concerning\n    -levels-colors option).\n\n2017-02-04  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-7, GIT revision 19513:5783e57:20170204.\n\n2017-01-28  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Sanitize comments that include braces for the MIFF image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/368).\n\n2017-01-27  7.0.4-7 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Added support for a proposed new PNG chunk\n    (zxIf, read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.  Enable\n    exIf and zxIf with CPPFLAGS=\"-DexIf_SUPPORTED -DxzIf_SUPPORTED\".\n    If exIf is enabled, only the uncompressed exIF chunk will be\n    written and the hex-encoded zTXt chunk containing the raw Exif\n    profile won't be written.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-6, GIT revision 19442:4747de9:20170127.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Uninitialized data in MAT image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/362).\n  * Properly auto-fit caption (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Correction to composite Over operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31282).\n  * Respect gravity option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31284).\n\n2017-01-22  7.0.4-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Renamed read_vpag_chunk_callback() function to png_user_chunk_callback()\n    in coders/png.c\n  * Implemented a private PNG caNv (canvas) chunk for remembering the\n    original dimensions and offsets when an image is cropped.  Previously\n    we used the oFFs and vpAg chunks for this purpose, but this had potential\n    conflicts with other applications that also use the oFFs chunk.\n  * coders/png.c: Added support for a proposed new PNG chunk (exIf\n    read-write, eXIf read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.\n\n2017-01-22  7.0.4-6 Dirk Lemstra <dirk@lem.....org>\n  * Replaced CoderSeekableStreamFlag with CoderDecoderSeekableStreamFlag and\n    CoderEncoderSeekableStreamFlag.\n\n2017-01-21  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-5, GIT revision 19381:7ae396f:20170121.\n\n2017-01-18  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Don't set background for transparent tiled images (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31210).\n\n2017-01-14  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-4, GIT revision 19361:a12953c:20170114.\n\n2017-01-14  7.0.4-4 Dirk Lemstra <dirk@lem.....org>\n  * Added support for RGB555, RGB565, ARGB4444 and ARGB1555 to the\n    BMP encoder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/344).\n\n2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n  * Fix memory leak in the MPC format.\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006).\n  * Enable alpha channel if background color is non-opaque (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 Fahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2020 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include <tiffconf.h>\n# endif\n# include <tiff.h>\n# include <tiffio.h>\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n# if defined(COMPRESSION_ZSTD) && defined(MAGICKCORE_ZSTD_DELEGATE)\n#   include <zstd.h>\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\ntypedef struct _PhotoshopProfile\n{\n  StringInfo\n    *data;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    length,\n    extent,\n    quantum;\n} PhotoshopProfile;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 2, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n\nstatic MagickOffsetType TIFFTellCustomStream(void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  return(profile->offset);\n}\n\nstatic void InitPSDInfo(const Image *image,PSDInfo *info)\n{\n  (void) memset(info,0,sizeof(*info));\n  info->version=1;\n  info->columns=image->columns;\n  info->rows=image->rows;\n  info->mode=10; /* Set the mode to a value that won't change the colorspace */\n  info->channels=1U;\n  info->min_channels=1U;\n  info->has_merged_image=MagickFalse;\n  if (image->storage_class == PseudoClass)\n    info->mode=2; /* indexed mode */\n  else\n    {\n      info->channels=(unsigned short) image->number_channels;\n      info->min_channels=info->channels;\n      if (image->alpha_trait == BlendPixelTrait)\n        info->min_channels--;\n    }\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  if (length != 10)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(unsigned int) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(unsigned int) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(unsigned int) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  if (ferror(file) != 0)\n    {\n      (void) fclose(file);\n      ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n    }\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  message[MaxTextExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic MagickBooleanType TIFFGetProfiles(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  uint32\n    length = 0;\n\n  unsigned char\n    *profile = (unsigned char *) NULL;\n\n  status=MagickTrue;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC) && (TIFFLIB_VERSION >= 20191103)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      const TIFFField\n        *field;\n\n      field=TIFFFieldWithTag(tiff,TIFFTAG_RICHTIFFIPTC);\n      if (TIFFFieldDataType(field) == TIFF_LONG)\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n      else\n        status=ReadProfile(image,\"iptc\",profile,length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      StringInfo\n        *dng;\n\n      status=ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      dng=BlobToStringInfo(profile,length);\n      if (dng != (StringInfo *) NULL)\n        {\n          const char\n            *target = \"dc:format=\\\"image/dng\\\"\";\n\n          if (strstr((char *) GetStringInfoDatum(dng),target) != (char *) NULL)\n            (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n          dng=DestroyStringInfo(dng);\n        }\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n  return(status);\n}\n\nstatic MagickBooleanType TIFFGetProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  MagickBooleanType\n    status;\n\n  uint32\n    count,\n    type;\n\n  text=(char *) NULL;\n  status=MagickTrue;\n  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:artist\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:document\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"comment\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:make\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:model\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"label\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n      (text != (char *) NULL))\n    status=SetImageProperty(image,\"tiff:software\",text,exception);\n  if ((TIFFGetField(tiff,33423,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if ((TIFFGetField(tiff,36867,&count,&text) == 1) && (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      status=SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        status=SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  return(status);\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MagickPathExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MagickPathExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,sans) == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",shorty);\n          }\n        else if (exif_info[i].variable_length == 2)\n        {\n          uint16\n            *shorty;\n\n          shorty=0;\n          if ((TIFFGetField(tiff,exif_info[i].tag,&shorty,sans) == 1) &&\n              (shorty != (uint16 *) NULL))\n            (void) FormatLocaleString(value,MagickPathExtent,\"%d\",*shorty);\n        }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",(double)\n            floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value,exception);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,const tsample_t sample,const ssize_t row,\n  tdata_t scanline)\n{\n  int32\n    status;\n\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *,const char *,va_list)\n  magick_attribute((__format__ (__printf__,2,0)));\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  message[MaxTextExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    *value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /*\n    Only support 8 bit for now.\n  */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /*\n    Search for Adobe APP14 JPEG marker.\n  */\n  value=NULL;\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value) || (value == NULL))\n    return(ReadStripMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadStripMethod);\n  method=ReadStripMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  size_t\n    total;\n\n  MagickOffsetType\n    remaining;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForReading(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamReader(custom_stream,TIFFReadCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic void TIFFReadPhotoshopLayers(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *layers;\n\n  ImageInfo\n    *clone_info;\n\n  PhotoshopProfile\n    photoshop_profile;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  profile=GetImageProfile(image,\"tiff:37724\");\n  if (profile == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) profile->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (profile->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (profile->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (profile->length-8))\n    return;\n  photoshop_profile.data=(StringInfo *) profile;\n  photoshop_profile.length=profile->length;\n  custom_stream=TIFFAcquireCustomStreamForReading(&photoshop_profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return;\n  layers=CloneImage(image,0,0,MagickTrue,exception);\n  if (layers == (Image *) NULL)\n    {\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      return;\n    }\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachCustomStream(layers->blob,custom_stream);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  InitPSDInfo(layers,&info);\n  clone_info=CloneImageInfo(image_info);\n  clone_info->number_scenes=0;\n  (void) ReadPSDLayers(layers,clone_info,&info,exception);\n  clone_info=DestroyImageInfo(clone_info);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    more_frames,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      TIFFGetEXIFProperties(tiff,image,exception);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace,exception);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                    exception);\n                }\n          }\n      }\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          buffer[MagickPathExtent];\n\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",buffer,exception);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (photometric == PHOTOMETRIC_LOGLUV)\n      method=ReadGenericMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    if (TIFFScanlineSize(tiff) <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((1.0*TIFFScanlineSize(tiff)) > (2.53*GetBlobSize(image)))\n      ThrowTIFFException(CorruptImageError,\"InsufficientImageDataInFile\");\n    number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)\n      image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/\n      log(2.0))),image->columns*rows_per_strip));\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=IndexQuantum;\n    pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        if (image->storage_class == PseudoClass)\n          quantum_type=IndexAlphaQuantum;\n        else\n          quantum_type=samples_per_pixel == 1 ? AlphaQuantum : GrayAlphaQuantum;\n      }\n    else\n      if (image->storage_class != PseudoClass)\n        quantum_type=GrayQuantum;\n    if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n      {\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (tiff_status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          2*sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register Quantum\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=TIFFTileSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=columns*sizeof(uint64);\n#else\n        extent+=columns*sizeof(uint32);\n#endif\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            register ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                register Quantum\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo * ) NULL;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        number_pixels+=image->columns*sizeof(uint32);\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if (status != MagickFalse)\n    TIFFReadPhotoshopLayers(image_info,image,exception);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  /*\n    This also sets field_bit to 0 (FIELD_IGNORE).\n  */\n  (void) memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n#endif\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  if (IsImageMonochrome(image) == MagickFalse)\n    (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      DestroyBlob(pyramid_image);\n      pyramid_image->blob=ReferenceBlob(next->blob);\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  status=MagickFalse;\n  if (images != (Image *) NULL)\n    {\n      /*\n        Write pyramid-encoded TIFF image.\n      */\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n#define TIFFStripSizeDefault  1048576\n\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) memset(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    {\n      size_t\n        extent;\n\n      uint32\n        rows,\n        rows_per_strip;\n\n      extent=TIFFScanlineSize(tiff);\n      rows_per_strip=TIFFStripSizeDefault/(extent == 0 ? 1 : (uint32) extent);\n      rows_per_strip=16*(((rows_per_strip < 16 ? 16 : rows_per_strip)+1)/16);\n      TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&rows);\n      if (rows_per_strip > rows)\n        rows_per_strip=rows;\n      option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n      if (option != (const char *) NULL)\n        rows_per_strip=(uint32) strtoul(option,(char **) NULL,10);\n      rows_per_strip=TIFFDefaultStripSize(tiff,rows_per_strip);\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      return(MagickTrue);\n    }\n  /*\n    Create tiled TIFF, ignore \"tiff:rows-per-strip\".\n  */\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  if ((TIFFScanlineSize(tiff) <= 0) || (TIFFTileSize(tiff) <= 0))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) memcpy(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic ssize_t TIFFWriteCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  if ((profile->offset+(MagickOffsetType) count) >=\n        (MagickOffsetType) profile->extent)\n    {\n      profile->extent+=count+profile->quantum;\n      profile->quantum<<=1;\n      SetStringInfoLength(profile->data,profile->extent);\n    }\n  (void) memcpy(profile->data->datum+profile->offset,data,count);\n  profile->offset+=count;\n  return(count);\n}\n\nstatic CustomStreamInfo *TIFFAcquireCustomStreamForWriting(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamWriter(custom_stream,TIFFWriteCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}\n\nstatic MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *base_image,\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  base_image=CloneImage(image,0,0,MagickFalse,exception);\n  if (base_image == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(base_image);\n  base_image->blob=blob;\n  next=base_image;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  AttachCustomStream(base_image->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  base_image->endian=endian;\n  WriteBlobString(base_image,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(base_image,0);\n  WriteBlobString(base_image,base_image->endian == LSBEndian ? \"MIB8ryaL\" :\n    \"8BIMLayr\");\n  status=WritePSDLayers(base_image,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  next=base_image;\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const MagickBooleanType adjoin,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property,exception);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    adjoin,\n    debug,\n    preserve_compression,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    imageListLength,\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric,\n    predictor;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[2] = { NULL, NULL };\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;\n    }\n  mode=endian_type == LSBEndian ? \"wl\" : \"wb\";\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    mode=endian_type == LSBEndian ? \"wl8\" : \"wb8\";\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      return(MagickFalse);\n    }\n  (void) DeleteImageProfile(image,\"tiff:37724\");\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  adjoin=image_info->adjoin;\n  imageListLength=GetImageListLength(image);\n  option=GetImageOption(image_info,\"tiff:preserve-compression\");\n  preserve_compression=IsStringTrue(option);\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    (void) IsImageMonochrome(image);\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=image_info->compression;\n    if (preserve_compression != MagickFalse)\n      compression=image->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if (IsImageMonochrome(image) == MagickFalse)\n          {\n            if (IsImageGray(image) == MagickFalse)\n              (void) SetImageType(image,BilevelType,exception);\n            else\n              (void) SetImageDepth(image,1,exception);\n          }\n        image->depth=1;\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          {\n            quantum_info=DestroyQuantumInfo(quantum_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n#if defined(COMPRESSION_ZSTD)\n      case ZstdCompression:\n      {\n        compress_tag=COMPRESSION_ZSTD;\n        break;\n      }\n#endif\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n            MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              status=SetQuantumDepth(image,quantum_info,8);\n              if (status == MagickFalse)\n                ThrowWriterException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) ||\n        (compress_tag == COMPRESSION_CCITTFAX4))\n      {\n         if ((photometric != PHOTOMETRIC_MINISWHITE) &&\n             (photometric != PHOTOMETRIC_MINISBLACK))\n          {\n            compress_tag=COMPRESSION_NONE;\n            endian=FILLORDER_MSB2LSB;\n          }\n      }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel,sans);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    predictor=0;\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (IsYCbCrCompatibleColorspace(image->colorspace) != MagickFalse)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n                }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        break;\n      }\n#if defined(WEBP_SUPPORT) && defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_WEBP_LEVEL,image_info->quality);\n        if (image_info->quality >= 100)\n          (void) TIFFSetField(tiff,TIFFTAG_WEBP_LOSSLESS,1);\n        break;\n      }\n#endif\n#if defined(ZSTD_SUPPORT) && defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample,sans);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZSTD_LEVEL,22*image_info->quality/\n          100.0);\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    if (quantum_info->format == FloatingPointQuantumFormat)\n      predictor=PREDICTOR_FLOATINGPOINT;\n    option=GetImageOption(image_info,\"tiff:predictor\");\n    if (option != (const char * ) NULL)\n      predictor=(uint16) strtol(option,(char **) NULL,10);\n    if (predictor != 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,predictor);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    option=GetImageOption(image_info,\"tiff:write-layers\");\n    if (IsStringTrue(option) != MagickFalse)\n      {\n        (void) TIFFWritePhotoshopLayers(image,image_info,endian_type,exception);\n        adjoin=MagickFalse;\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (adjoin != MagickFalse) && (imageListLength > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            imageListLength);\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    else\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) imageListLength;\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,adjoin,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (compress_tag == COMPRESSION_CCITTFAX4)\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,(uint32) image->rows);\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          {\n            if (red != (uint16 *) NULL)\n              red=(uint16 *) RelinquishMagickMemory(red);\n            if (green != (uint16 *) NULL)\n              green=(uint16 *) RelinquishMagickMemory(green);\n            if (blue != (uint16 *) NULL)\n              blue=(uint16 *) RelinquishMagickMemory(blue);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) memset(red,0,65536*sizeof(*red));\n        (void) memset(green,0,65536*sizeof(*green));\n        (void) memset(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    if (TIFFWriteDirectory(tiff) == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(status);\n}\n#endif\n"], "buggy_code_start_loc": [0, 1984], "buggy_code_end_loc": [0, 1985], "fixing_code_start_loc": [1, 1984], "fixing_code_end_loc": [7, 1985], "type": "CWE-122", "message": "A heap based buffer overflow in coders/tiff.c may result in program crash and denial of service in ImageMagick before 7.0.10-45.", "other": {"cve": {"id": "CVE-2020-27829", "sourceIdentifier": "secalert@redhat.com", "published": "2021-03-26T17:15:11.953", "lastModified": "2021-03-29T20:25:46.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap based buffer overflow in coders/tiff.c may result in program crash and denial of service in ImageMagick before 7.0.10-45."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria en el archivo coders/tiff.c puede causar un bloqueo del programa y una denegaci\u00f3n de servicio en ImageMagick versiones anteriores a 7.0.10-45."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.10-45", "matchCriteriaId": "68A02AE0-2D9F-419C-BBC0-8C8ADB58C820"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1922525", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/6ee5059cd3ac8d82714a1ab1321399b88539abf0", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/6ee5059cd3ac8d82714a1ab1321399b88539abf0"}}