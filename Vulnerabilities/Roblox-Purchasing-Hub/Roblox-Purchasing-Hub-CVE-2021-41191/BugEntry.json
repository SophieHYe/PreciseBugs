{"buggy_code": ["\"\"\"\n    File: /lib/cogs/website.py\n    Info: This cog handles the website which talks to the API.\n\"\"\"\nfrom datetime import datetime\nfrom math import prod\nimport nextcord\nfrom nextcord.ext.commands import Cog, command\nfrom nextcord.ext.commands.core import Command\nfrom nextcord import Embed, Colour, colour\nfrom quart import Quart, request\nfrom ..utils.database import db\nfrom ..utils.api import *\nfrom ..utils.util import require_apikey\nfrom bson.json_util import ObjectId, dumps\nfrom ro_py import Client\nfrom bs4 import BeautifulSoup\nimport json\nimport string\nimport random\nimport requests\nimport re\n\napp = Quart(__name__)\n\n# Had to do this cause I cant pass in self in quart\nwith open(\"./BOT/lib/bot/config.json\") as config_file:\n    config = json.load(config_file)\nroblox = Client()\nverificationkeys = {}\n\n# Define Functions\n\n## This needs to be done with the MongoDB database to make sure the _id is a string and not ObjectId\nclass MyEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, ObjectId):\n            return str(obj)\n        return super(MyEncoder, self).default(obj)\n\n\napp.json_encoder = MyEncoder\n\n# Website Handling\n\n\n@app.route(\"/\", methods=[\"GET\"])\nasync def index():\n    return {\"message\": \"Ok\"}\n\n\n@app.route(\"/v1/status\", methods=[\"GET\"])\nasync def status():\n    result = db.command(\"serverStatus\")\n    if result:\n        return {\"message\": \"Ok\", \"info\": {\"api\": \"Ok\", \"database\": \"Ok\"}}\n    else:\n        return {\"message\": \"Ok\", \"info\": {\"api\": \"Ok\", \"database\": \"Error\"}}\n\n\n@app.route(\"/v1/products\", methods=[\"GET\"])\nasync def products():\n    dbresponse = getproducts()\n    results = {}\n    for i in dbresponse:\n        results[i[\"name\"]] = i\n    return results\n\n\n@app.route(\"/v1/create_product\", methods=[\"POST\"])\n@require_apikey\nasync def create_product():\n    info = await request.get_json()\n    try:\n        createproduct(info[\"name\"], info[\"description\"], info[\"price\"])\n        return {\n            \"info\": {\n                \"name\": info[\"name\"],\n                \"description\": info[\"description\"],\n                \"price\": info[\"price\"],\n            }\n        }\n    except:\n        return {\"errors\": [{\"message\": \"Unable to delete product\"}]}\n\n\n@app.route(\"/v1/update_product\", methods=[\"POST\"])\n@require_apikey\nasync def update_product():\n    info = await request.get_json()\n    try:\n        updateproduct(\n            info[\"oldname\"], info[\"newname\"], info[\"description\"], info[\"price\"]\n        )\n        return {\n            \"info\": {\n                \"name\": info[\"newname\"],\n                \"description\": info[\"description\"],\n                \"price\": info[\"price\"],\n            }\n        }\n    except:\n        return {\"errors\": [{\"message\": \"Unable to update product\"}]}\n\n\n@app.route(\"/v1/delete_product\", methods=[\"DELETE\"])\n@require_apikey\nasync def delete_product():\n    info = await request.get_json()\n    try:\n        deleteproduct(info[\"name\"])\n        return {\"message\": \"Deleted\"}\n    except:\n        return {\"errors\": [{\"message\": \"Unable to create product\"}]}\n\n\n@app.route(\n    \"/v1/user\", methods=[\"GET\", \"POST\"]\n)  # Had to define as POST as well due to Roblox\nasync def get_user():\n    try:\n        info = await request.get_json()\n        dbresponse = getuser(info[\"userid\"])\n        if dbresponse == None:\n            return {\"errors\": [{\"message\": \"Unable to get user\"}]}\n        return dumps(dbresponse)\n    except:\n        return {\"errors\": [{\"message\": \"Something went wrong when getting user\"}]}\n\n\n@app.route(\"/v1/verify_user\", methods=[\"POST\"])\n@require_apikey\nasync def verify_user():\n    info = await request.get_json()\n    user = getuser(info[\"userid\"])\n    if not user:\n        key = \"\".join(random.choices(string.ascii_uppercase + string.digits, k=5))\n        verificationkeys[key] = info[\"userid\"]\n        return {\"key\": key}\n    else:\n        return {\"errors\": [{\"message\": \"User is already verified\"}]}\n\n\n@app.route(\"/v1/give_product\", methods=[\"POST\"])\n@require_apikey\nasync def give_product():\n    info = await request.get_json()\n    try:\n        giveproduct(info[\"userid\"], info[\"productname\"])\n        userinfo = getuser(info[\"userid\"])\n        return dumps(userinfo)\n    except:\n        return {\"errors\": [{\"message\": \"Unable to give product\"}]}\n\n\n@app.route(\"/v1/revoke_product\", methods=[\"DELETE\"])\n@require_apikey\nasync def revoke_product():\n    info = await request.get_json()\n    try:\n        revokeproduct(info[\"userid\"], info[\"productname\"])\n        userinfo = getuser(info[\"userid\"])\n        return dumps(userinfo)\n    except:\n        return {\"errors\": [{\"message\": \"Unable to revoke product\"}]}\n\n\n@app.route(\"/v1/create_purchase\", methods=[\"POST\"])\n@require_apikey\nasync def create_purchase():\n    info = await request.get_json()\n    if info[\"gameid\"] and info[\"name\"] and info[\"price\"]:\n        data = {\n            \"universeId\": info[\"gameid\"],\n            \"name\": info[\"name\"],\n            \"priceInRobux\": info[\"price\"],\n            \"description\": info[\"name\"] + \" \" + str(info[\"price\"]),\n        }\n        cookies = {\".ROBLOSECURITY\": config[\"roblox\"][\"cookie\"]}\n        # Get the x-csrf-token, this won't actually log you out because there is no x-csrf-token yet.\n        # Basically just exploiting the api to give us a x-csrf-token to use.\n        r1 = requests.post(\n            \"https://auth.roblox.com/v2/logout\",\n            data=None,\n            cookies=cookies,\n        )\n        if r1.headers[\"x-csrf-token\"]:\n            headers = {\"x-csrf-token\": r1.headers[\"x-csrf-token\"]}\n            r = requests.post(\n                \"https://www.roblox.com/places/developerproducts/add\",\n                data=data,\n                cookies=cookies,\n                headers=headers,\n            )\n\n            if r.status_code == 200:\n                return {\n                    \"ProductId\": \"\".join(\n                        re.findall(\n                            r\"\\d\",\n                            str(\n                                BeautifulSoup(r.text, \"html.parser\").find(\n                                    id=\"DeveloperProductStatus\"\n                                )\n                            ),\n                        )\n                    )\n                }\n\n    return {\"errors\": [{\"message\": \"Unable to create developer product\"}]}\n\n\n# Bot Handling\n\n\nclass Website(Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    @command(\n        name=\"website\",\n        aliases=[\"web\", \"ws\", \"websitestatus\"],\n        brief=\"Displays if the website is online.\",\n        catagory=\"misc\",\n    )\n    async def website(self, ctx):\n        if ctx.message.author.id in self.bot.owner_ids:\n            await ctx.send(\"\ud83d\udfe2 Website Online\")\n\n    @command(name=\"verify\", brief=\"Verify's you as a user.\", catagory=\"user\")\n    async def verify(self, ctx, key):\n        if key in verificationkeys:\n            userid = verificationkeys[key]\n            try:\n                user = await roblox.get_user(userid)\n                username = user.name\n                verifyuser(userid, ctx.author.id, username)\n                verificationkeys.pop(key)\n                await ctx.send(\"Verified\", delete_after=5.0, reference=ctx.message)\n            except:\n                await ctx.send(\n                    \"I was unable to verify you\",\n                    delete_after=5.0,\n                    reference=ctx.message,\n                )\n        else:\n            await ctx.send(\n                \"The provided key was incorrect please check the key and try again.\",\n                delete_after=5.0,\n                reference=ctx.message,\n            )\n\n    @Cog.listener()\n    async def on_ready(self):\n        if not self.bot.ready:\n            self.bot.cogs_ready.ready_up(\"website\")\n            await self.bot.stdout.send(\"`/lib/cogs/website.py` ready\")\n            print(\" /lib/cogs/website.py ready\")\n\n\ndef setup(bot):\n    bot.loop.create_task(\n        app.run_task(\"0.0.0.0\")\n    )  # It is highly recomended that you change \"0.0.0.0\" to your server IP in a production env\n    bot.add_cog(Website(bot))\n"], "fixing_code": ["\"\"\"\n    File: /lib/cogs/website.py\n    Info: This cog handles the website which talks to the API.\n\"\"\"\nfrom datetime import datetime\nfrom math import prod\nimport nextcord\nfrom nextcord.ext.commands import Cog, command\nfrom nextcord.ext.commands.core import Command\nfrom nextcord import Embed, Colour, colour\nfrom quart import Quart, request\nfrom ..utils.database import db\nfrom ..utils.api import *\nfrom ..utils.util import require_apikey\nfrom bson.json_util import ObjectId, dumps\nfrom ro_py import Client\nfrom bs4 import BeautifulSoup\nimport json\nimport string\nimport random\nimport requests\nimport re\n\napp = Quart(__name__)\n\n# Had to do this cause I cant pass in self in quart\nwith open(\"./BOT/lib/bot/config.json\") as config_file:\n    config = json.load(config_file)\nroblox = Client()\nverificationkeys = {}\n\n# Define Functions\n\n## This needs to be done with the MongoDB database to make sure the _id is a string and not ObjectId\nclass MyEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, ObjectId):\n            return str(obj)\n        return super(MyEncoder, self).default(obj)\n\n\napp.json_encoder = MyEncoder\n\n# Website Handling\n\n\n@app.route(\"/\", methods=[\"GET\"])\nasync def index():\n    return {\"message\": \"Ok\"}\n\n\n@app.route(\"/v1/status\", methods=[\"GET\"])\nasync def status():\n    result = db.command(\"serverStatus\")\n    if result:\n        return {\"message\": \"Ok\", \"info\": {\"api\": \"Ok\", \"database\": \"Ok\"}}\n    else:\n        return {\"message\": \"Ok\", \"info\": {\"api\": \"Ok\", \"database\": \"Error\"}}\n\n\n@app.route(\"/v1/products\", methods=[\"GET\"])\n@require_apikey\nasync def products():\n    dbresponse = getproducts()\n    results = {}\n    for i in dbresponse:\n        results[i[\"name\"]] = i\n    return results\n\n\n@app.route(\"/v1/create_product\", methods=[\"POST\"])\n@require_apikey\nasync def create_product():\n    info = await request.get_json()\n    try:\n        createproduct(info[\"name\"], info[\"description\"], info[\"price\"])\n        return {\n            \"info\": {\n                \"name\": info[\"name\"],\n                \"description\": info[\"description\"],\n                \"price\": info[\"price\"],\n            }\n        }\n    except:\n        return {\"errors\": [{\"message\": \"Unable to delete product\"}]}\n\n\n@app.route(\"/v1/update_product\", methods=[\"POST\"])\n@require_apikey\nasync def update_product():\n    info = await request.get_json()\n    try:\n        updateproduct(\n            info[\"oldname\"], info[\"newname\"], info[\"description\"], info[\"price\"]\n        )\n        return {\n            \"info\": {\n                \"name\": info[\"newname\"],\n                \"description\": info[\"description\"],\n                \"price\": info[\"price\"],\n            }\n        }\n    except:\n        return {\"errors\": [{\"message\": \"Unable to update product\"}]}\n\n\n@app.route(\"/v1/delete_product\", methods=[\"DELETE\"])\n@require_apikey\nasync def delete_product():\n    info = await request.get_json()\n    try:\n        deleteproduct(info[\"name\"])\n        return {\"message\": \"Deleted\"}\n    except:\n        return {\"errors\": [{\"message\": \"Unable to create product\"}]}\n\n\n@app.route(\n    \"/v1/user\", methods=[\"GET\", \"POST\"]\n)  # Had to define as POST as well due to Roblox\nasync def get_user():\n    try:\n        info = await request.get_json()\n        dbresponse = getuser(info[\"userid\"])\n        if dbresponse == None:\n            return {\"errors\": [{\"message\": \"Unable to get user\"}]}\n        return dumps(dbresponse)\n    except:\n        return {\"errors\": [{\"message\": \"Something went wrong when getting user\"}]}\n\n\n@app.route(\"/v1/verify_user\", methods=[\"POST\"])\n@require_apikey\nasync def verify_user():\n    info = await request.get_json()\n    user = getuser(info[\"userid\"])\n    if not user:\n        key = \"\".join(random.choices(string.ascii_uppercase + string.digits, k=5))\n        verificationkeys[key] = info[\"userid\"]\n        return {\"key\": key}\n    else:\n        return {\"errors\": [{\"message\": \"User is already verified\"}]}\n\n\n@app.route(\"/v1/give_product\", methods=[\"POST\"])\n@require_apikey\nasync def give_product():\n    info = await request.get_json()\n    try:\n        giveproduct(info[\"userid\"], info[\"productname\"])\n        userinfo = getuser(info[\"userid\"])\n        return dumps(userinfo)\n    except:\n        return {\"errors\": [{\"message\": \"Unable to give product\"}]}\n\n\n@app.route(\"/v1/revoke_product\", methods=[\"DELETE\"])\n@require_apikey\nasync def revoke_product():\n    info = await request.get_json()\n    try:\n        revokeproduct(info[\"userid\"], info[\"productname\"])\n        userinfo = getuser(info[\"userid\"])\n        return dumps(userinfo)\n    except:\n        return {\"errors\": [{\"message\": \"Unable to revoke product\"}]}\n\n\n@app.route(\"/v1/create_purchase\", methods=[\"POST\"])\n@require_apikey\nasync def create_purchase():\n    info = await request.get_json()\n    if info[\"gameid\"] and info[\"name\"] and info[\"price\"]:\n        data = {\n            \"universeId\": info[\"gameid\"],\n            \"name\": info[\"name\"],\n            \"priceInRobux\": info[\"price\"],\n            \"description\": info[\"name\"] + \" \" + str(info[\"price\"]),\n        }\n        cookies = {\".ROBLOSECURITY\": config[\"roblox\"][\"cookie\"]}\n        # Get the x-csrf-token, this won't actually log you out because there is no x-csrf-token yet.\n        # Basically just exploiting the api to give us a x-csrf-token to use.\n        r1 = requests.post(\n            \"https://auth.roblox.com/v2/logout\",\n            data=None,\n            cookies=cookies,\n        )\n        if r1.headers[\"x-csrf-token\"]:\n            headers = {\"x-csrf-token\": r1.headers[\"x-csrf-token\"]}\n            r = requests.post(\n                \"https://www.roblox.com/places/developerproducts/add\",\n                data=data,\n                cookies=cookies,\n                headers=headers,\n            )\n\n            if r.status_code == 200:\n                return {\n                    \"ProductId\": \"\".join(\n                        re.findall(\n                            r\"\\d\",\n                            str(\n                                BeautifulSoup(r.text, \"html.parser\").find(\n                                    id=\"DeveloperProductStatus\"\n                                )\n                            ),\n                        )\n                    )\n                }\n\n    return {\"errors\": [{\"message\": \"Unable to create developer product\"}]}\n\n\n# Bot Handling\n\n\nclass Website(Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    @command(\n        name=\"website\",\n        aliases=[\"web\", \"ws\", \"websitestatus\"],\n        brief=\"Displays if the website is online.\",\n        catagory=\"misc\",\n    )\n    async def website(self, ctx):\n        if ctx.message.author.id in self.bot.owner_ids:\n            await ctx.send(\"\ud83d\udfe2 Website Online\")\n\n    @command(name=\"verify\", brief=\"Verify's you as a user.\", catagory=\"user\")\n    async def verify(self, ctx, key):\n        if key in verificationkeys:\n            userid = verificationkeys[key]\n            try:\n                user = await roblox.get_user(userid)\n                username = user.name\n                verifyuser(userid, ctx.author.id, username)\n                verificationkeys.pop(key)\n                await ctx.send(\"Verified\", delete_after=5.0, reference=ctx.message)\n            except:\n                await ctx.send(\n                    \"I was unable to verify you\",\n                    delete_after=5.0,\n                    reference=ctx.message,\n                )\n        else:\n            await ctx.send(\n                \"The provided key was incorrect please check the key and try again.\",\n                delete_after=5.0,\n                reference=ctx.message,\n            )\n\n    @Cog.listener()\n    async def on_ready(self):\n        if not self.bot.ready:\n            self.bot.cogs_ready.ready_up(\"website\")\n            await self.bot.stdout.send(\"`/lib/cogs/website.py` ready\")\n            print(\" /lib/cogs/website.py ready\")\n\n\ndef setup(bot):\n    bot.loop.create_task(\n        app.run_task(\"0.0.0.0\")\n    )  # It is highly recomended that you change \"0.0.0.0\" to your server IP in a production env\n    bot.add_cog(Website(bot))\n"], "buggy_code_start_loc": [61], "buggy_code_end_loc": [61], "fixing_code_start_loc": [62], "fixing_code_end_loc": [63], "type": "CWE-116", "message": "Roblox-Purchasing-Hub is an open source Roblox product purchasing hub. A security risk in versions 1.0.1 and prior allowed people who have someone's API URL to get product files without an API key. This issue is fixed in version 1.0.2. As a workaround, add `@require_apikey` in `BOT/lib/cogs/website.py` under the route for `/v1/products`.", "other": {"cve": {"id": "CVE-2021-41191", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-27T21:15:08.133", "lastModified": "2021-11-02T14:54:34.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Roblox-Purchasing-Hub is an open source Roblox product purchasing hub. A security risk in versions 1.0.1 and prior allowed people who have someone's API URL to get product files without an API key. This issue is fixed in version 1.0.2. As a workaround, add `@require_apikey` in `BOT/lib/cogs/website.py` under the route for `/v1/products`."}, {"lang": "es", "value": "Roblox-Purchasing-Hub es un centro de compras de productos de Roblox de c\u00f3digo abierto. Un riesgo de seguridad en las versiones 1.0.1 y anteriores, permit\u00eda a las personas que ten\u00edan la URL de la API de alguien conseguir archivos de productos sin una clave de la API. Este problema ha sido corregido en la versi\u00f3n 1.0.2. Como soluci\u00f3n, a\u00f1ada \"@require_apikey\" en \"BOT/lib/cogs/website.py\" bajo la ruta para \"/v1/products\""}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redon:roblox_purchasing_hub:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.2", "matchCriteriaId": "1937F4CD-073A-443C-BF4C-9C48D576C984"}]}]}], "references": [{"url": "https://github.com/Redon-Tech/Roblox-Purchasing-Hub/commit/58a22260eca40b1a0377daf61ccd8c4dc1440e03", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Redon-Tech/Roblox-Purchasing-Hub/releases/tag/V1.0.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Redon-Tech/Roblox-Purchasing-Hub/security/advisories/GHSA-76mx-6584-4v8q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Redon-Tech/Roblox-Purchasing-Hub/commit/58a22260eca40b1a0377daf61ccd8c4dc1440e03"}}