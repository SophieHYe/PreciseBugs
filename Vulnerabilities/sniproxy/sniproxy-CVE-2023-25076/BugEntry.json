{"buggy_code": ["2018-12-05  Dustin Lundquist <dustin@null-ptr.net>\n\t0.6.0 Release\n\n\t* PROXY v1 protocol support\n\t* SO_REUSEPORT support on Linux 3.9 and later\n\t* Listener ipv6_only directive to accept only IPv6 connections\n\t* TCP keepalive\n\n2017-04-26  Dustin Lundquist <dustin@null-ptr.net>\n\t0.5.0 Release\n\n\t* Transparent proxy support\n\t* Use accept4() on Linix\n\t* Run as group specified in config\n\n2015-04-07  Dustin Lundquist <dustin@null-ptr.net>\n\t0.4.0 release\n\n\t* Improve DNS resolver:\n\t  Support for AAAA records\n\t  Configuration options\n\t* Global access log\n\t* Man page for sniproxy.conf\n\t* Reject IP literals as hostnames for wildcard backends\n\n2014-09-26  Dustin Lundquist <dustin@null-ptr.net>\n\t0.3.6 release\n\n\t* Improve logging:\n\t  Fix negative connection duration in access log\n\t  Include log rotate script\n\t  Reopen log files on SIGHUP\n\t  Share file handle to same log file between listeners\n\t  Avoid unnecessary reconnection to syslog socket\n\t  Cache timestamp string for current second\n\t* Man page\n\t* Packaging improvements:\n\t  passes lintian and rpm-lint\n\n2014-08-13\tDustin Lundquist <dustin@null-ptr.net>\n\t0.3.5 release\n\n\t* Configuration reloading on SIGHUP\n\t* SSL 2.0 connection handling: do not treat as an error, use fallback\n\taddress if configured.\n\t* Fix buffer_coalesce error\n\t* Spawn privileged child to bind sockets to privileged ports on reload\n\t* Add -V flag to return sniproxy version\n\t* Use libev for timestamps to improve portability\n\t* Include several for BSD compatibility\n\t* Large file support (for log files)\n\n", "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.60])\nAC_INIT([sniproxy], [0.6.0])\nAC_CONFIG_SRCDIR([src/sniproxy.c])\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE([subdir-objects])\nAM_SILENT_RULES([yes])\nAC_GNU_SOURCE\n\n# Checks for programs.\nAC_PROG_CC_C99\n# Required by automake < 1.14\nAM_PROG_CC_C_O\n\n\n# Checks for libraries.\nPKG_CHECK_MODULES([LIBEV], [libev], HAVE_LIBEV=yes; AC_DEFINE(HAVE_LIBEV, 1),\n[AC_LIB_HAVE_LINKFLAGS(ev,, [#include <ev.h>], [ev_run(0,0);])\n if test x$ac_cv_libev = xyes; then\n  AC_SUBST([LIBEV_LIBS], [$LIBEV])\n else\n  AC_MSG_ERROR([[***\n*** libev4 was not found.\n***]])\n fi\n])\n\nPKG_CHECK_MODULES([LIBPCRE], [libpcre], HAVE_LIBPCRE=yes; AC_DEFINE(HAVE_LIBPCRE, 1),\n[AC_LIB_HAVE_LINKFLAGS(pcre,, [#include <pcre.h>], [pcre_exec(0,0,0,0,0,0,0,0);])\n if test x$ac_cv_libpcre = xyes; then\n  AC_SUBST([LIBPCRE_LIBS], [$LIBPCRE])\n else\n  AC_MSG_ERROR([[***\n*** libpcre was not found.\n***]])\n fi\n])\n\nAC_ARG_ENABLE([dns],\n  [AS_HELP_STRING([--disable-dns], [Disable DNS resolution])],\n  [dns=\"$withval\"], [dns=yes])\n\nAM_CONDITIONAL([DNS_ENABLED], [test \"x$dns\" = \"xyes\"])\n\nAS_IF([test \"x$dns\" = \"xyes\"],\n [PKG_CHECK_MODULES([LIBUDNS], [libudns], HAVE_LIBUDNS=yes; AC_DEFINE(HAVE_LIBUDNS, 1),\n  [AC_LIB_HAVE_LINKFLAGS(udns,, [#include <udns.h>], [dns_init(0, 0);])\n   AS_IF([test x$ac_cv_libudns = xyes], [AC_SUBST([LIBUDNS_LIBS], [$LIBUDNS])])\n  ])\n])\n\nAC_ARG_ENABLE([rfc3339-timestamps],\n  [AS_HELP_STRING([--enable-rfc3339-timestamps], [Enable RFC3339 timestamps])],\n  [rfc3339_timestamps=${enableval}], [rfc3339_timestamps=no])\n\nAS_IF([test \"x$rfc3339_timestamps\" = \"xyes\"],\n    [AC_DEFINE([RFC3339_TIMESTAMP], 1, [RFC3339 timestamps enabled])])\n\n# Checks for header files.\nAC_CHECK_HEADERS([arpa/inet.h fcntl.h inttypes.h netdb.h netinet/in.h stddef.h stdint.h stdlib.h string.h strings.h sys/socket.h sys/time.h syslog.h unistd.h],,\n    AC_MSG_ERROR([required header(s) not found]))\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_INLINE\nAC_TYPE_PID_T\nAC_TYPE_UID_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT8_T\n\n# Checks for library functions.\nAC_FUNC_FORK\nAC_FUNC_MALLOC\nAC_FUNC_REALLOC\nAC_FUNC_STRTOD\nAC_CHECK_FUNCS([atexit daemon memset socket strcasecmp strchr strdup strerror strncasecmp strrchr strspn strtoul],,\n    AC_MSG_ERROR([required functions(s) not found]))\n\nAC_CHECK_FUNCS([accept4])\n\n# Enable large file support (so we can log more than 2GB)\nAC_SYS_LARGEFILE\n\nAC_CONFIG_FILES([Makefile\n                 src/Makefile\n                 man/Makefile\n                 tests/Makefile])\n\nAC_OUTPUT\n", "sniproxy (0.6.0) unstable; urgency=medium\n\n  * PROXY v1 protocol support\n  * SO_REUSEPORT support on Linux 3.9 and later\n  * Listener ipv6_only directive to accept only IPv6 connections\n  * TCP keepalive\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 05 Dec 2018 20:12:24 -0800\n\nsniproxy (0.5.0) unstable; urgency=medium\n\n  * Transparent proxy support\n  * Use accept4() on Linix\n  * Run as group specified in config\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 26 Apr 2017 07:17:13 -0700\n\nsniproxy (0.4.0) unstable; urgency=medium\n\n  * Improve DNS resolver:\n    Support for AAAA records\n    Configuration options\n  * Global access log\n  * Man page for sniproxy.conf\n  * Reject IP literals as hostnames for wildcard backends\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 07 Apr 2015 09:14:41 -0700\n\nsniproxy (0.3.6) unstable; urgency=medium\n\n  * Improve logging:\n    Fix negative connection duration in access log\n    Include log rotate script\n    Reopen log files on SIGHUP\n    Share file handle to same log file between listeners\n    Avoid unnecessary reconnection to syslog socket\n    Cache timestamp string for current second\n  * Man page\n  * Packaging improvements:\n    passes lintian and rpm-lint\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Fri, 26 Sep 2014 19:52:38 -0700\n\nsniproxy (0.3.5) unstable; urgency=medium\n\n  * Configuration reloading on SIGHUP\n  * SSL 2.0 connection handling: do not treat as an error, use fallback\n    address if configured.\n  * Fix buffer_coalesce error\n  * Spawn privileged child to bind sockets to privileged ports on reload\n  * Add -V flag to return sniproxy version\n  * Use libev for timestamps to improve portability\n  * Include several for BSD compatibility\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 13 Aug 2014 18:25:53 -0700\n\nsniproxy (0.3.4) unstable; urgency=medium\n\n  * Add source address specification configuration option.\n  * Line buffer log files.\n  * Fix segfault when no hostname included in TLS extensions.\n  * Fix erroneously report of invalid TLS client handshake.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Sun, 18 May 2014 14:38:33 -0700\n\nsniproxy (0.3.3) unstable; urgency=medium\n\n  * Fix format argument segfault in buffer full warning.\n  * Add sniproxy-dbg package.\n  * File descriptor limit: raise limit and improve handling when limit is\n    reached.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 22 Apr 2014 17:35:59 -0700\n\nsniproxy (0.3.2-1) unstable; urgency=high\n\n  * Fix use after free when client closes connection before DNS response is\n    received.\n  * Fix two DNS query memory leaks.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Fri, 11 Apr 2014 16:32:06 -0700\n\nsniproxy (0.3.1-1) unstable; urgency=high\n\n  * Fix bug when client completely fills the buffer before the DNS query is\n    answered.\n  * Fix handling of invalid hostnames in client requests.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 09 Apr 2014 21:08:55 -0700\n\nsniproxy (0.3-1) unstable; urgency=medium\n\n  * Nonblocking connect and DNS resolution\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 08 Apr 2014 17:03:37 -0700\n\nsniproxy (0.2) unstable; urgency=low\n\n  * Moving pidfile\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Thu, 30 Jan 2014 13:51:02 -0800\n\nsniproxy (0.1-1) unstable; urgency=low\n\n  * Initial release\n\n -- Andreas Loibl <andreas@andreas-loibl.de>  Tue, 18 Jun 2013 17:55:43 +0200\n", "8\n", "Name: sniproxy\nVersion: 0.6.0\nRelease: 1%{?dist}\nSummary: Transparent TLS and HTTP layer 4 proxy with SNI support\n\nGroup: System Environment/Daemons\nLicense: BSD\nURL: https://github.com/dlundquist/sniproxy\nSource0: %{name}-%{version}.tar.gz\nBuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)\n\nBuildRequires: autoconf, automake, curl, libev-devel, pcre-devel, perl, gettext-devel, udns-devel\n\n%description\nProxies incoming HTTP and TLS connections based on the hostname contained in\nthe initial request of the TCP session. This enables HTTPS name-based virtual\nhosting to separate backend servers without installing the private key on the\nproxy machine.\n\n\n%prep\n%setup -q\n\n\n%build\n%configure CFLAGS=\"-I/usr/include/libev\"\nmake %{?_smp_mflags}\n\n\n%install\nrm -rf $RPM_BUILD_ROOT\nmake install DESTDIR=$RPM_BUILD_ROOT\n\n\n%clean\nrm -rf $RPM_BUILD_ROOT\n\n\n%files\n%defattr(-,root,root,-)\n%{_sbindir}/sniproxy\n%doc\n%{_mandir}/man8/sniproxy.8.gz\n%{_mandir}/man5/sniproxy.conf.5.gz\n\n\n\n%changelog\n* Wed Dec 5 2018 Dustin Lundquist <dustin@null-ptr.net> 0.6.0-1\n- PROXY v1 protocol support\n- SO_REUSEPORT support on Linux 3.9 and later\n- Listener ipv6_only directive to accept only IPv6 connections\n- TCP keepalive\n\n* Wed Apr 26 2017 Dustin Lundquist <dustin@null-ptr.net> 0.5.0-1\n- Transparent proxy support\n- Use accept4() on Linix\n- Run as group specified in config\n\n* Tue Apr 7 2015 Dustin Lundquist <dustin@null-ptr.net> 0.4.0-1\n- Improve DNS resolver:\n  Support for AAAA records\n  Configuration options\n- Global access log\n- Man page for sniproxy.conf\n- Reject IP literals as hostnames for wildcard backends\n\n* Fri Sep 26 2014 Dustin Lundquist <dustin@null-ptr.net> 0.3.6-1\n- Improve logging:\n  Fix negative connection duration in access log\n  Include log rotate script\n  Reopen log files on SIGHUP\n  Share file handle to same log file between listeners\n  Avoid unnecessary reconnection to syslog socket\n  Cache timestamp string for current second\n- Man page\n- Packaging improvements:\n  passes lintian and rpm-lint\n\n* Wed Aug 13 2014 Dustin Lundquist <dustin@null-ptr.net> 0.3.5-1\n- Configuration reloading on SIGHUP\n- SSL 2.0 connection handling: do not treat as an error, use fallback\n  address if configured.\n- Fix buffer_coalesce error\n- Spawn privileged child to bind sockets to privileged ports on reload\n- Add -V flag to return sniproxy version\n- Use libev for timestamps to improve portability\n- Include several for BSD compatibility\n- Large file support (for log files)\n", "#!/bin/sh\n\nVERSION=0.6.0\n\nSOURCE_DIR=$(dirname $0)\nGIT_DIR=${SOURCE_DIR}/.git\n\ncd ${SOURCE_DIR}\n\nif [ -d ${GIT_DIR} ]; then\n    GIT_VERSION=$(git describe --tags)\n    if [ \"x\" != \"x${GIT_VERSION}\" ]; then\n        if echo ${GIT_VERSION} | grep -q '-'; then\n            VER=$(echo ${GIT_VERSION} | cut -d- -f1)\n            REV=$(echo ${GIT_VERSION} | cut -d- -f2)\n            REF=$(echo ${GIT_VERSION} | cut -d- -f3)\n\n            VERSION=${VER}+git.${REV}.${REF}\n        else\n            # Release version (e.g. 0.3.5)\n            VERSION=${GIT_VERSION}\n            DEBIAN_VERSION=${VERSION}\n            SPEC_VERSION=${VERSION}\n        fi\n    fi\nfi\n\n# Update Autoconf with new version\nsed -i \"s/^\\(AC_INIT(\\[sniproxy\\], \\[\\)[^]]*\\(.\\+\\)$/\\1${VERSION}\\2/\" ${SOURCE_DIR}/configure.ac\n\n# Update redhat/sniproxy.spec with new version\nsed -i \"s/^Version:\\s\\+[^ ]\\+/Version: ${VERSION}/\" ${SOURCE_DIR}/redhat/sniproxy.spec\n\n# Update debian/changelog with new version\ndebchange --newversion ${VERSION} \"New git revision\"\n", "/*\n * Copyright (c) 2013, Dustin Lundquist <dustin@null-ptr.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h> /* tolower */\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h> /* inet_pton */\n#include <sys/un.h>\n#include <assert.h>\n#include \"address.h\"\n\n\nstruct Address {\n    enum {\n        HOSTNAME,\n        SOCKADDR,\n        WILDCARD,\n    } type;\n\n    size_t len;     /* length of data */\n    uint16_t port;  /* for hostname and wildcard */\n    char data[];\n};\n\n\nstatic const char valid_label_bytes[] =\n\"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n\n\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n\n\nstatic int valid_hostname(const char *);\n\n\nstruct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n\n        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}\n\nstruct Address *\nnew_address_sa(const struct sockaddr *sa, socklen_t sa_len) {\n    struct Address *addr = malloc(offsetof(struct Address, data) + sa_len);\n    if (addr != NULL) {\n        addr->type = SOCKADDR;\n        addr->len = sa_len;\n        memcpy(addr->data, sa, sa_len);\n        addr->port = address_port(addr);\n    }\n\n    return addr;\n}\n\nstruct Address *\ncopy_address(const struct Address *addr) {\n    size_t len = address_len(addr);\n    struct Address *new_addr = malloc(len);\n\n    if (new_addr != NULL)\n        memcpy(new_addr, addr, len);\n\n    return new_addr;\n}\n\nsize_t\naddress_len(const struct Address *addr) {\n    switch (addr->type) {\n        case HOSTNAME:\n            /* include trailing null byte */\n            return offsetof(struct Address, data) + addr->len + 1;\n        case SOCKADDR:\n            return offsetof(struct Address, data) + addr->len;\n        case WILDCARD:\n            return sizeof(struct Address);\n        default:\n            assert(0);\n            return 0;\n    }\n}\n\nint\naddress_compare(const struct Address *addr_1, const struct Address *addr_2) {\n    if (addr_1 == NULL && addr_2 == NULL)\n        return 0;\n    if (addr_1 == NULL && addr_2 != NULL)\n        return -1;\n    if (addr_1 != NULL && addr_2 == NULL)\n        return 1;\n\n    if (addr_1->type < addr_2->type)\n        return -1;\n    if (addr_1->type > addr_2->type)\n        return 1;\n\n    size_t addr1_len = addr_1->len;\n    size_t addr2_len = addr_2->len;\n    int result = memcmp(addr_1->data, addr_2->data, MIN(addr1_len, addr2_len));\n\n    if (result == 0) { /* they match, find a tie breaker */\n        if (addr1_len < addr2_len)\n            return -1;\n        if (addr1_len > addr2_len)\n            return 1;\n\n        if (addr_1->port < addr_2->port)\n            return -1;\n        if (addr_1->port > addr_2->port)\n            return 1;\n    }\n\n    return result;\n}\n\nint\naddress_is_hostname(const struct Address *addr) {\n    return addr != NULL && addr->type == HOSTNAME;\n}\n\nint\naddress_is_sockaddr(const struct Address *addr) {\n    return addr != NULL && addr->type == SOCKADDR;\n}\n\nint\naddress_is_wildcard(const struct Address *addr) {\n    return addr != NULL && addr->type == WILDCARD;\n}\n\nconst char *\naddress_hostname(const struct Address *addr) {\n    if (addr->type != HOSTNAME)\n        return NULL;\n\n    return addr->data;\n}\n\nconst struct sockaddr *\naddress_sa(const struct Address *addr) {\n    if (addr->type != SOCKADDR)\n        return NULL;\n\n    return (struct sockaddr *)addr->data;\n}\n\nsocklen_t\naddress_sa_len(const struct Address *addr) {\n    if (addr->type != SOCKADDR)\n        return 0;\n\n    return addr->len;\n}\n\nuint16_t\naddress_port(const struct Address *addr) {\n    switch (addr->type) {\n        case HOSTNAME:\n            return addr->port;\n        case SOCKADDR:\n            switch (address_sa(addr)->sa_family) {\n                case AF_INET:\n                    return ntohs(((struct sockaddr_in *)addr->data)\n                            ->sin_port);\n                case AF_INET6:\n                    return ntohs(((struct sockaddr_in6 *)addr->data)\n                            ->sin6_port);\n                case AF_UNIX:\n                case AF_UNSPEC:\n                    return 0;\n                default:\n                    assert(0);\n                    return 0;\n            }\n        case WILDCARD:\n            return addr->port;\n        default:\n            /* invalid Address type */\n            assert(0);\n            return 0;\n    }\n}\n\nvoid\naddress_set_port(struct Address *addr, uint16_t port) {\n    switch (addr->type) {\n        case SOCKADDR:\n            switch (address_sa(addr)->sa_family) {\n                case AF_INET:\n                    (((struct sockaddr_in *)addr->data) ->sin_port) =\n                        htons(port);\n                    break;\n                case AF_INET6:\n                    (((struct sockaddr_in6 *)addr->data) ->sin6_port) =\n                        htons(port);\n                    break;\n                case AF_UNIX:\n                case AF_UNSPEC:\n                    /* no op */\n                    break;\n                default:\n                    assert(0);\n            }\n            /* fall through */\n        case HOSTNAME:\n        case WILDCARD:\n            addr->port = port;\n            break;\n        default:\n            /* invalid Address type */\n            assert(0);\n    }\n}\n\nint\naddress_set_port_str(struct Address *addr, const char* str) {\n    int port = atoi(str);\n    if (port < 0 || port > 65535) {\n        return 0;\n    }\n    address_set_port(addr, (uint16_t)port);\n    return 1;\n}\n\nconst char *\ndisplay_address(const struct Address *addr, char *buffer, size_t buffer_len) {\n    if (addr == NULL || buffer == NULL)\n        return NULL;\n\n    switch (addr->type) {\n        case HOSTNAME:\n            if (addr->port != 0)\n                snprintf(buffer, buffer_len, \"%s:%\" PRIu16,\n                        addr->data,\n                        addr->port);\n            else\n                snprintf(buffer, buffer_len, \"%s\",\n                        addr->data);\n            return buffer;\n        case SOCKADDR:\n            return display_sockaddr(addr->data, buffer, buffer_len);\n        case WILDCARD:\n            if (addr->port != 0)\n                snprintf(buffer, buffer_len, \"*:%\" PRIu16,\n                        addr->port);\n            else\n                snprintf(buffer, buffer_len, \"*\");\n            return buffer;\n        default:\n            assert(0);\n            return NULL;\n    }\n}\n\nconst char *\ndisplay_sockaddr(const void *sa, char *buffer, size_t buffer_len) {\n    char ip[INET6_ADDRSTRLEN];\n    if (sa == NULL || buffer == NULL)\n        return NULL;\n\n    switch (((const struct sockaddr *)sa)->sa_family) {\n        case AF_INET:\n            inet_ntop(AF_INET,\n                      &((const struct sockaddr_in *)sa)->sin_addr,\n                      ip, sizeof(ip));\n\n            if (((struct sockaddr_in *)sa)->sin_port != 0)\n                snprintf(buffer, buffer_len, \"%s:%\" PRIu16, ip,\n                        ntohs(((struct sockaddr_in *)sa)->sin_port));\n            else\n                snprintf(buffer, buffer_len, \"%s\", ip);\n\n            break;\n        case AF_INET6:\n            inet_ntop(AF_INET6,\n                      &((const struct sockaddr_in6 *)sa)->sin6_addr,\n                      ip, sizeof(ip));\n\n            if (((struct sockaddr_in6 *)sa)->sin6_port != 0)\n                snprintf(buffer, buffer_len, \"[%s]:%\" PRIu16, ip,\n                         ntohs(((struct sockaddr_in6 *)sa)->sin6_port));\n            else\n                snprintf(buffer, buffer_len, \"[%s]\", ip);\n\n            break;\n        case AF_UNIX:\n            snprintf(buffer, buffer_len, \"unix:%s\",\n                     ((struct sockaddr_un *)sa)->sun_path);\n            break;\n        case AF_UNSPEC:\n            snprintf(buffer, buffer_len, \"NONE\");\n            break;\n        default:\n            /* unexpected AF */\n            assert(0);\n    }\n    return buffer;\n}\n\nint\nis_numeric(const char *s) {\n    char *p;\n\n    if (s == NULL || *s == '\\0')\n        return 0;\n\n    int n = strtod(s, &p);\n    (void)n; /* unused */\n\n    return *p == '\\0'; /* entire string was numeric */\n}\n\nstatic int\nvalid_hostname(const char *hostname) {\n    if (hostname == NULL)\n        return 0;\n\n    size_t hostname_len = strlen(hostname);\n    if (hostname_len < 1 || hostname_len > 255)\n        return 0;\n\n    if (hostname[0] == '.')\n        return 0;\n\n    const char *hostname_end = hostname + hostname_len;\n    for (const char *label = hostname; label < hostname_end;) {\n        size_t label_len = (size_t)(hostname_end - label);\n        char *next_dot = strchr(label, '.');\n        if (next_dot != NULL)\n            label_len = (size_t)(next_dot - label);\n        assert(label + label_len <= hostname_end);\n\n        if (label_len > 63 || label_len < 1)\n            return 0;\n\n        if (label[0] == '-' || label[label_len - 1] == '-')\n            return 0;\n\n        if (strspn(label, valid_label_bytes) < label_len)\n            return 0;\n\n        label += label_len + 1;\n    }\n\n    return 1;\n}\n", "AM_CPPFLAGS = -I$(top_srcdir)/src -g $(LIBEV_CFLAGS) $(LIBPCRE_CFLAGS) $(LIBUDNS_CFLAGS)\nAM_CFLAGS = -fno-strict-aliasing -Wall -Wextra -Wpedantic -Wwrite-strings\n\nTESTS = address_test \\\n        buffer_test \\\n        cfg_tokenizer_test \\\n        table_test \\\n        http_test \\\n        tls_test \\\n        binder_test\n\nTESTS += functional_test \\\n         bad_request_test \\\n         bind_source_test \\\n         connection_reset_test \\\n         fallback_test \\\n         fd_limit_test \\\n         ipv6_v6only_test \\\n         proxy_header_test \\\n         reload_test \\\n         reuseport_test \\\n         slow_client_test \\\n         transparent_proxy_test\nif DNS_ENABLED\n  TESTS += config_test \\\n           resolv_test \\\n           bad_dns_request_test\nendif\n\ncheck_PROGRAMS = http_test \\\n                 tls_test \\\n                 table_test \\\n                 binder_test \\\n                 buffer_test \\\n                 cfg_tokenizer_test \\\n                 address_test \\\n                 resolv_test \\\n                 config_test\n\nhttp_test_SOURCES = http_test.c \\\n                    ../src/http.c\n\ntls_test_SOURCES = tls_test.c \\\n                   ../src/tls.c \\\n                   ../src/logger.c\n\nbinder_test_SOURCES = binder_test.c \\\n                      ../src/binder.c \\\n                      ../src/logger.c\n\nbuffer_test_SOURCES = buffer_test.c \\\n                      ../src/buffer.c\n\nbuffer_test_LDADD = $(LIBEV_LIBS)\n\naddress_test_SOURCES = address_test.c \\\n                      ../src/address.c\n\ncfg_tokenizer_test_SOURCES = cfg_tokenizer_test.c \\\n                             ../src/cfg_tokenizer.c\n\nconfig_test_SOURCES = config_test.c \\\n                      ../src/binder.c \\\n                      ../src/config.c \\\n                      ../src/cfg_parser.c \\\n                      ../src/cfg_tokenizer.c \\\n                      ../src/address.c \\\n                      ../src/backend.c \\\n                      ../src/table.c \\\n                      ../src/listener.c \\\n                      ../src/connection.c \\\n                      ../src/buffer.c \\\n                      ../src/logger.c \\\n                      ../src/resolv.c \\\n                      ../src/resolv.h \\\n                      ../src/tls.c \\\n                      ../src/http.c\n\nconfig_test_LDADD = $(LIBEV_LIBS) $(LIBPCRE_LIBS) $(LIBUDNS_LIBS)\n\nresolv_test_SOURCES = resolv_test.c \\\n                      ../src/resolv.c \\\n                      ../src/address.c \\\n                      ../src/logger.c\n\nresolv_test_LDADD = $(LIBEV_LIBS) $(LIBUDNS_LIBS)\n\ntable_test_SOURCES = table_test.c \\\n                      ../src/backend.c \\\n                      ../src/table.c \\\n                      ../src/address.c \\\n                      ../src/logger.c\n\ntable_test_LDADD = $(LIBPCRE_LIBS)\n", "#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse File::Basename;\nuse lib dirname (__FILE__);\nuse TestUtils;\nuse TestHTTPD;\nuse File::Temp;\nuse IO::Socket::INET;\n\nmy $bad_requests = [\n    {\n        # Test bad name server\n        request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Invalid hostname\n        request => \"GET / HTTP/1.1\\r\\nHost: ...........\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Exceed buffer size\n        request => \"PUT / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 65536\\r\\n\\r\\n\" . 'x' x 65536,\n        client => \\&http_client,\n    },\n    {\n        # Exceed buffer size before host header\n        request => \"GET /\" . 'x' x 65536,\n        client => \\&http_client,\n    },\n    {\n        # Invalid hostname\n        request => \"GET / HTTP/1.1\\r\\nHost: \\0example.com\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Test client aborting connection before DNS response received\n        request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\",\n        client => \\&http_client_abort,\n    },\n];\n\nsub http_client($$) {\n    my $port = shift;\n    my $request = shift;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n                                       PeerPort => $port,\n                                       Proto => \"tcp\",\n                                       Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n\n    my $buffer;\n    $socket->recv($buffer, 4096);\n\n    $socket->close();\n\n    return undef;\n}\n\nsub http_client_abort($$) {\n    my $port = shift;\n    my $request = shift;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n                                       PeerPort => $port,\n                                       Proto => \"tcp\",\n                                       Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n    sleep(1);\n\n    $socket->close();\n\n    return undef;\n}\n\nsub proxy {\n    my $config = shift;\n\n    exec(@_, '../src/sniproxy', '-f', '-c', $config);\n}\n\n\nsub worker($$$) {\n    my ($port, $requests, $offset) = @_;\n\n    for (my $i = 0; $i < $requests; $i++) {\n        my $test = $bad_requests->[($i + $offset) % int(@$bad_requests)];\n        my $error = $test->{client}($port, $test->{request});\n\n        die($error) if defined $error;\n    }\n    # Success\n    exit 0;\n}\n\nsub make_wildcard_config($) {\n    my $proxy_port = shift;\n\n    my ($fh, $filename) = File::Temp::tempfile();\n\n    # Write out a test config file\n    print $fh <<END;\n# Minimal test configuration\n\nresolver {\n    # Use an RFC1166 documentation prefix IP address as the nameserver\n    # this should be not respond to DNS queries in any environment\n    nameserver 192.0.2.99\n}\n\nlisten 127.0.0.1 $proxy_port {\n    proto http\n}\n\ntable {\n    .* *:80\n}\nEND\n\n    close ($fh);\n\n    return $filename;\n}\n\nsub main {\n    my $proxy_port = $ENV{SNI_PROXY_PORT} || 8080;\n    my $workers = $ENV{WORKERS} || 3;\n    my $iterations = $ENV{ITERATIONS} || int(@$bad_requests);\n\n    my $config = make_wildcard_config($proxy_port);\n    my $proxy_pid = start_child('server', \\&proxy, $config, @ARGV);\n\n    # Wait for proxy to load and parse config\n    wait_for_port(port => $proxy_port);\n\n    for (my $i = 0; $i < $workers; $i++) {\n        start_child('worker', \\&worker, $proxy_port, $iterations, $i);\n    }\n\n    # Wait for all our children to finish\n    wait_for_type('worker');\n\n    # Give the proxy a second to flush buffers and close server connections\n    sleep 1;\n\n    # For troubleshooting connections stuck in CLOSE_WAIT state\n    #kill 10, $proxy_pid;\n    #system(\"netstat -ptn | grep $proxy_pid\\/sniproxy\");\n\n    # For troubleshooting 100% CPU usage\n    #system(\"top -n 1 -p $proxy_pid -b\");\n\n    # Orderly shutdown of the server\n    kill 15, $proxy_pid;\n    sleep 1;\n\n    # Delete our test configuration\n    unlink($config);\n\n    # Kill off any remaining children\n    reap_children();\n}\n\nmain();\n", "#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse File::Basename;\nuse lib dirname (__FILE__);\nuse TestUtils;\nuse TestHTTPD;\nuse File::Temp;\nuse IO::Socket::INET;\nuse Time::HiRes;\n\nsub proxy {\n    my $config = shift;\n\n    exec(@_, '../src/sniproxy', '-f', '-c', $config);\n}\n\nsub slow_client($$) {\n    my $port = shift;\n    my $requests = shift;\n    my $request = \"GET / HTTP/1.1\\r\\n\" .\n        \"UserAgent: slow_client/0.1\\r\\n\" .\n        \"Host: localhost:$port\\r\\n\" .\n        \"Accept: */*\\r\\n\" .\n        \"\\r\\n\";\n\n    local $SIG{ALRM} = sub { die \"alarm\\n\" };\n    alarm 10;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n            PeerPort => $port,\n            Proto => \"tcp\",\n            Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n    foreach (split(\"\\r\\n\", $request)) {\n        $socket->send(\"$_\\r\\n\");\n        sleep(1);\n    }\n\n    my $buffer;\n    $socket->recv($buffer, 4096);\n\n    $socket->close();\n\n    die(\"Unexpected response: $buffer\") unless ($buffer =~ /\\AHTTP\\/1\\.1 200 OK/);\n\n    exit(0);\n}\n\nsub main {\n    my $proxy_port = $ENV{SNI_PROXY_PORT} || 8080;\n    my $httpd_port = $ENV{TEST_HTTPD_PORT} || 8081;\n    my $workers = $ENV{WORKERS} || 3;\n    my $iterations = $ENV{ITERATIONS} || 3;\n    my $local_httpd = $ENV{LOCAL_HTTPD_PORT};\n\n    my $config = make_config($proxy_port, $local_httpd || $httpd_port);\n    my $proxy_pid = start_child('server', \\&proxy, $config, @ARGV);\n    my $httpd_pid = start_child('server', \\&TestHTTPD::httpd, port => $httpd_port) unless $local_httpd;\n\n    # Wait for proxy to load and parse config\n    wait_for_port(port => $httpd_port);\n    wait_for_port(port => $proxy_port);\n\n    for (my $i = 0; $i < $workers; $i++) {\n        start_child('worker', \\&slow_client, $proxy_port, $iterations);\n    }\n\n    # Wait for all our children to finish\n    wait_for_type('worker');\n\n    # Give the proxy a second to flush buffers and close server connections\n    sleep 1;\n\n    # For troubleshooting connections stuck in CLOSE_WAIT state\n    #kill 10, $proxy_pid;\n    #system(\"netstat -ptn | grep $proxy_pid\\/sniproxy\");\n\n    # For troubleshooting 100% CPU usage\n    #system(\"top -n 1 -p $proxy_pid -b\");\n\n    # Orderly shutdown of the server\n    kill 15, $proxy_pid;\n    kill 15, $httpd_pid unless $local_httpd;\n    sleep 1;\n\n    # Delete our test configuration\n    unlink($config);\n\n    # Kill off any remaining children\n    reap_children();\n}\n\nmain();\n"], "fixing_code": ["2023-03-16  Dustin Lundquist <dustin@null-ptr.net>\n\t0.6.1 Release\n\n\t* Fix buffer overflow in address module\n\t* Fix tests\n\n2018-12-05  Dustin Lundquist <dustin@null-ptr.net>\n\t0.6.0 Release\n\n\t* PROXY v1 protocol support\n\t* SO_REUSEPORT support on Linux 3.9 and later\n\t* Listener ipv6_only directive to accept only IPv6 connections\n\t* TCP keepalive\n\n2017-04-26  Dustin Lundquist <dustin@null-ptr.net>\n\t0.5.0 Release\n\n\t* Transparent proxy support\n\t* Use accept4() on Linix\n\t* Run as group specified in config\n\n2015-04-07  Dustin Lundquist <dustin@null-ptr.net>\n\t0.4.0 release\n\n\t* Improve DNS resolver:\n\t  Support for AAAA records\n\t  Configuration options\n\t* Global access log\n\t* Man page for sniproxy.conf\n\t* Reject IP literals as hostnames for wildcard backends\n\n2014-09-26  Dustin Lundquist <dustin@null-ptr.net>\n\t0.3.6 release\n\n\t* Improve logging:\n\t  Fix negative connection duration in access log\n\t  Include log rotate script\n\t  Reopen log files on SIGHUP\n\t  Share file handle to same log file between listeners\n\t  Avoid unnecessary reconnection to syslog socket\n\t  Cache timestamp string for current second\n\t* Man page\n\t* Packaging improvements:\n\t  passes lintian and rpm-lint\n\n2014-08-13\tDustin Lundquist <dustin@null-ptr.net>\n\t0.3.5 release\n\n\t* Configuration reloading on SIGHUP\n\t* SSL 2.0 connection handling: do not treat as an error, use fallback\n\taddress if configured.\n\t* Fix buffer_coalesce error\n\t* Spawn privileged child to bind sockets to privileged ports on reload\n\t* Add -V flag to return sniproxy version\n\t* Use libev for timestamps to improve portability\n\t* Include several for BSD compatibility\n\t* Large file support (for log files)\n\n", "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.60])\nAC_INIT([sniproxy], [0.6.1])\nAC_CONFIG_SRCDIR([src/sniproxy.c])\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE([subdir-objects])\nAM_SILENT_RULES([yes])\nAC_GNU_SOURCE\n\n# Checks for programs.\nAC_PROG_CC_C99\n# Required by automake < 1.14\nAM_PROG_CC_C_O\n\n\n# Checks for libraries.\nPKG_CHECK_MODULES([LIBEV], [libev], HAVE_LIBEV=yes; AC_DEFINE(HAVE_LIBEV, 1),\n[AC_LIB_HAVE_LINKFLAGS(ev,, [#include <ev.h>], [ev_run(0,0);])\n if test x$ac_cv_libev = xyes; then\n  AC_SUBST([LIBEV_LIBS], [$LIBEV])\n else\n  AC_MSG_ERROR([[***\n*** libev4 was not found.\n***]])\n fi\n])\n\nPKG_CHECK_MODULES([LIBPCRE], [libpcre], HAVE_LIBPCRE=yes; AC_DEFINE(HAVE_LIBPCRE, 1),\n[AC_LIB_HAVE_LINKFLAGS(pcre,, [#include <pcre.h>], [pcre_exec(0,0,0,0,0,0,0,0);])\n if test x$ac_cv_libpcre = xyes; then\n  AC_SUBST([LIBPCRE_LIBS], [$LIBPCRE])\n else\n  AC_MSG_ERROR([[***\n*** libpcre was not found.\n***]])\n fi\n])\n\nAC_ARG_ENABLE([dns],\n  [AS_HELP_STRING([--disable-dns], [Disable DNS resolution])],\n  [dns=\"$withval\"], [dns=yes])\n\nAM_CONDITIONAL([DNS_ENABLED], [test \"x$dns\" = \"xyes\"])\n\nAS_IF([test \"x$dns\" = \"xyes\"],\n [PKG_CHECK_MODULES([LIBUDNS], [libudns], HAVE_LIBUDNS=yes; AC_DEFINE(HAVE_LIBUDNS, 1),\n  [AC_LIB_HAVE_LINKFLAGS(udns,, [#include <udns.h>], [dns_init(0, 0);])\n   AS_IF([test x$ac_cv_libudns = xyes], [AC_SUBST([LIBUDNS_LIBS], [$LIBUDNS])])\n  ])\n])\n\nAC_ARG_ENABLE([rfc3339-timestamps],\n  [AS_HELP_STRING([--enable-rfc3339-timestamps], [Enable RFC3339 timestamps])],\n  [rfc3339_timestamps=${enableval}], [rfc3339_timestamps=no])\n\nAS_IF([test \"x$rfc3339_timestamps\" = \"xyes\"],\n    [AC_DEFINE([RFC3339_TIMESTAMP], 1, [RFC3339 timestamps enabled])])\n\n# Checks for header files.\nAC_CHECK_HEADERS([arpa/inet.h fcntl.h inttypes.h netdb.h netinet/in.h stddef.h stdint.h stdlib.h string.h strings.h sys/socket.h sys/time.h syslog.h unistd.h],,\n    AC_MSG_ERROR([required header(s) not found]))\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_INLINE\nAC_TYPE_PID_T\nAC_TYPE_UID_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT8_T\n\n# Checks for library functions.\nAC_FUNC_FORK\nAC_FUNC_MALLOC\nAC_FUNC_REALLOC\nAC_FUNC_STRTOD\nAC_CHECK_FUNCS([atexit daemon memset socket strcasecmp strchr strdup strerror strncasecmp strrchr strspn strtoul],,\n    AC_MSG_ERROR([required functions(s) not found]))\n\nAC_CHECK_FUNCS([accept4])\n\n# Enable large file support (so we can log more than 2GB)\nAC_SYS_LARGEFILE\n\nAC_CONFIG_FILES([Makefile\n                 src/Makefile\n                 man/Makefile\n                 tests/Makefile])\n\nAC_OUTPUT\n", "sniproxy (0.6.1) unstable; urgency=high\n\n  * Fix buffer overflow in address module\n  * Fix tests\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Thu, 16 Mar 2023 21:53:48 -0700\n\nsniproxy (0.6.0) unstable; urgency=medium\n\n  * PROXY v1 protocol support\n  * SO_REUSEPORT support on Linux 3.9 and later\n  * Listener ipv6_only directive to accept only IPv6 connections\n  * TCP keepalive\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 05 Dec 2018 20:12:24 -0800\n\nsniproxy (0.5.0) unstable; urgency=medium\n\n  * Transparent proxy support\n  * Use accept4() on Linux\n  * Run as group specified in config\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 26 Apr 2017 07:17:13 -0700\n\nsniproxy (0.4.0) unstable; urgency=medium\n\n  * Improve DNS resolver:\n    Support for AAAA records\n    Configuration options\n  * Global access log\n  * Man page for sniproxy.conf\n  * Reject IP literals as hostnames for wildcard backends\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 07 Apr 2015 09:14:41 -0700\n\nsniproxy (0.3.6) unstable; urgency=medium\n\n  * Improve logging:\n    Fix negative connection duration in access log\n    Include log rotate script\n    Reopen log files on SIGHUP\n    Share file handle to same log file between listeners\n    Avoid unnecessary reconnection to syslog socket\n    Cache timestamp string for current second\n  * Man page\n  * Packaging improvements:\n    passes lintian and rpm-lint\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Fri, 26 Sep 2014 19:52:38 -0700\n\nsniproxy (0.3.5) unstable; urgency=medium\n\n  * Configuration reloading on SIGHUP\n  * SSL 2.0 connection handling: do not treat as an error, use fallback\n    address if configured.\n  * Fix buffer_coalesce error\n  * Spawn privileged child to bind sockets to privileged ports on reload\n  * Add -V flag to return sniproxy version\n  * Use libev for timestamps to improve portability\n  * Include several for BSD compatibility\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 13 Aug 2014 18:25:53 -0700\n\nsniproxy (0.3.4) unstable; urgency=medium\n\n  * Add source address specification configuration option.\n  * Line buffer log files.\n  * Fix segfault when no hostname included in TLS extensions.\n  * Fix erroneously report of invalid TLS client handshake.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Sun, 18 May 2014 14:38:33 -0700\n\nsniproxy (0.3.3) unstable; urgency=medium\n\n  * Fix format argument segfault in buffer full warning.\n  * Add sniproxy-dbg package.\n  * File descriptor limit: raise limit and improve handling when limit is\n    reached.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 22 Apr 2014 17:35:59 -0700\n\nsniproxy (0.3.2-1) unstable; urgency=high\n\n  * Fix use after free when client closes connection before DNS response is\n    received.\n  * Fix two DNS query memory leaks.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Fri, 11 Apr 2014 16:32:06 -0700\n\nsniproxy (0.3.1-1) unstable; urgency=high\n\n  * Fix bug when client completely fills the buffer before the DNS query is\n    answered.\n  * Fix handling of invalid hostnames in client requests.\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 09 Apr 2014 21:08:55 -0700\n\nsniproxy (0.3-1) unstable; urgency=medium\n\n  * Nonblocking connect and DNS resolution\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 08 Apr 2014 17:03:37 -0700\n\nsniproxy (0.2) unstable; urgency=low\n\n  * Moving pidfile\n\n -- Dustin Lundquist <dustin@null-ptr.net>  Thu, 30 Jan 2014 13:51:02 -0800\n\nsniproxy (0.1-1) unstable; urgency=low\n\n  * Initial release\n\n -- Andreas Loibl <andreas@andreas-loibl.de>  Tue, 18 Jun 2013 17:55:43 +0200\n", "10\n", "Name: sniproxy\nVersion: 0.6.1\nRelease: 1%{?dist}\nSummary: Transparent TLS and HTTP layer 4 proxy with SNI support\n\nGroup: System Environment/Daemons\nLicense: BSD\nURL: https://github.com/dlundquist/sniproxy\nSource0: %{name}-%{version}.tar.gz\nBuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)\n\nBuildRequires: autoconf, automake, curl, libev-devel, pcre-devel, perl, gettext-devel, udns-devel\n\n%description\nProxies incoming HTTP and TLS connections based on the hostname contained in\nthe initial request of the TCP session. This enables HTTPS name-based virtual\nhosting to separate backend servers without installing the private key on the\nproxy machine.\n\n\n%prep\n%setup -q\n\n\n%build\n%configure CFLAGS=\"-I/usr/include/libev\"\nmake %{?_smp_mflags}\n\n\n%install\nrm -rf $RPM_BUILD_ROOT\nmake install DESTDIR=$RPM_BUILD_ROOT\n\n\n%clean\nrm -rf $RPM_BUILD_ROOT\n\n\n%files\n%defattr(-,root,root,-)\n%{_sbindir}/sniproxy\n%doc\n%{_mandir}/man8/sniproxy.8.gz\n%{_mandir}/man5/sniproxy.conf.5.gz\n\n\n\n%changelog\n* Thu Mar 16 2023 Dustin Lundquist <dustin@null-ptr.net 0.6.1-1\n- Fix buffer overflow in address module\n- Fix tests\n\n* Wed Dec 5 2018 Dustin Lundquist <dustin@null-ptr.net> 0.6.0-1\n- PROXY v1 protocol support\n- SO_REUSEPORT support on Linux 3.9 and later\n- Listener ipv6_only directive to accept only IPv6 connections\n- TCP keepalive\n\n* Wed Apr 26 2017 Dustin Lundquist <dustin@null-ptr.net> 0.5.0-1\n- Transparent proxy support\n- Use accept4() on Linix\n- Run as group specified in config\n\n* Tue Apr 7 2015 Dustin Lundquist <dustin@null-ptr.net> 0.4.0-1\n- Improve DNS resolver:\n  Support for AAAA records\n  Configuration options\n- Global access log\n- Man page for sniproxy.conf\n- Reject IP literals as hostnames for wildcard backends\n\n* Fri Sep 26 2014 Dustin Lundquist <dustin@null-ptr.net> 0.3.6-1\n- Improve logging:\n  Fix negative connection duration in access log\n  Include log rotate script\n  Reopen log files on SIGHUP\n  Share file handle to same log file between listeners\n  Avoid unnecessary reconnection to syslog socket\n  Cache timestamp string for current second\n- Man page\n- Packaging improvements:\n  passes lintian and rpm-lint\n\n* Wed Aug 13 2014 Dustin Lundquist <dustin@null-ptr.net> 0.3.5-1\n- Configuration reloading on SIGHUP\n- SSL 2.0 connection handling: do not treat as an error, use fallback\n  address if configured.\n- Fix buffer_coalesce error\n- Spawn privileged child to bind sockets to privileged ports on reload\n- Add -V flag to return sniproxy version\n- Use libev for timestamps to improve portability\n- Include several for BSD compatibility\n- Large file support (for log files)\n", "#!/bin/sh\n\nVERSION=0.6.1\n\nSOURCE_DIR=$(dirname $0)\nGIT_DIR=${SOURCE_DIR}/.git\n\ncd ${SOURCE_DIR}\n\nif [ -d ${GIT_DIR} ]; then\n    GIT_VERSION=$(git describe --tags)\n    if [ \"x\" != \"x${GIT_VERSION}\" ]; then\n        if echo ${GIT_VERSION} | grep -q '-'; then\n            VER=$(echo ${GIT_VERSION} | cut -d- -f1)\n            REV=$(echo ${GIT_VERSION} | cut -d- -f2)\n            REF=$(echo ${GIT_VERSION} | cut -d- -f3)\n\n            VERSION=${VER}+git.${REV}.${REF}\n        else\n            # Release version (e.g. 0.3.5)\n            VERSION=${GIT_VERSION}\n            DEBIAN_VERSION=${VERSION}\n            SPEC_VERSION=${VERSION}\n        fi\n    fi\nfi\n\n# Update Autoconf with new version\nsed -i \"s/^\\(AC_INIT(\\[sniproxy\\], \\[\\)[^]]*\\(.\\+\\)$/\\1${VERSION}\\2/\" ${SOURCE_DIR}/configure.ac\n\n# Update redhat/sniproxy.spec with new version\nsed -i \"s/^Version:\\s\\+[^ ]\\+/Version: ${VERSION}/\" ${SOURCE_DIR}/redhat/sniproxy.spec\n\n# Update debian/changelog with new version\ndebchange --newversion ${VERSION} \"New git revision\"\n", "/*\n * Copyright (c) 2013, Dustin Lundquist <dustin@null-ptr.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h> /* tolower */\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h> /* inet_pton */\n#include <sys/un.h>\n#include <assert.h>\n#include \"address.h\"\n\n\nstruct Address {\n    enum {\n        HOSTNAME,\n        SOCKADDR,\n        WILDCARD,\n    } type;\n\n    size_t len;     /* length of data */\n    uint16_t port;  /* for hostname and wildcard */\n    char data[];\n};\n\n\nstatic const char valid_label_bytes[] =\n\"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n\n\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n\n\nstatic int valid_hostname(const char *);\n\n\nstruct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n        if (len >= INET6_ADDRSTRLEN)\n            return NULL;\n\n        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}\n\nstruct Address *\nnew_address_sa(const struct sockaddr *sa, socklen_t sa_len) {\n    struct Address *addr = malloc(offsetof(struct Address, data) + sa_len);\n    if (addr != NULL) {\n        addr->type = SOCKADDR;\n        addr->len = sa_len;\n        memcpy(addr->data, sa, sa_len);\n        addr->port = address_port(addr);\n    }\n\n    return addr;\n}\n\nstruct Address *\ncopy_address(const struct Address *addr) {\n    size_t len = address_len(addr);\n    struct Address *new_addr = malloc(len);\n\n    if (new_addr != NULL)\n        memcpy(new_addr, addr, len);\n\n    return new_addr;\n}\n\nsize_t\naddress_len(const struct Address *addr) {\n    switch (addr->type) {\n        case HOSTNAME:\n            /* include trailing null byte */\n            return offsetof(struct Address, data) + addr->len + 1;\n        case SOCKADDR:\n            return offsetof(struct Address, data) + addr->len;\n        case WILDCARD:\n            return sizeof(struct Address);\n        default:\n            assert(0);\n            return 0;\n    }\n}\n\nint\naddress_compare(const struct Address *addr_1, const struct Address *addr_2) {\n    if (addr_1 == NULL && addr_2 == NULL)\n        return 0;\n    if (addr_1 == NULL && addr_2 != NULL)\n        return -1;\n    if (addr_1 != NULL && addr_2 == NULL)\n        return 1;\n\n    if (addr_1->type < addr_2->type)\n        return -1;\n    if (addr_1->type > addr_2->type)\n        return 1;\n\n    size_t addr1_len = addr_1->len;\n    size_t addr2_len = addr_2->len;\n    int result = memcmp(addr_1->data, addr_2->data, MIN(addr1_len, addr2_len));\n\n    if (result == 0) { /* they match, find a tie breaker */\n        if (addr1_len < addr2_len)\n            return -1;\n        if (addr1_len > addr2_len)\n            return 1;\n\n        if (addr_1->port < addr_2->port)\n            return -1;\n        if (addr_1->port > addr_2->port)\n            return 1;\n    }\n\n    return result;\n}\n\nint\naddress_is_hostname(const struct Address *addr) {\n    return addr != NULL && addr->type == HOSTNAME;\n}\n\nint\naddress_is_sockaddr(const struct Address *addr) {\n    return addr != NULL && addr->type == SOCKADDR;\n}\n\nint\naddress_is_wildcard(const struct Address *addr) {\n    return addr != NULL && addr->type == WILDCARD;\n}\n\nconst char *\naddress_hostname(const struct Address *addr) {\n    if (addr->type != HOSTNAME)\n        return NULL;\n\n    return addr->data;\n}\n\nconst struct sockaddr *\naddress_sa(const struct Address *addr) {\n    if (addr->type != SOCKADDR)\n        return NULL;\n\n    return (struct sockaddr *)addr->data;\n}\n\nsocklen_t\naddress_sa_len(const struct Address *addr) {\n    if (addr->type != SOCKADDR)\n        return 0;\n\n    return addr->len;\n}\n\nuint16_t\naddress_port(const struct Address *addr) {\n    switch (addr->type) {\n        case HOSTNAME:\n            return addr->port;\n        case SOCKADDR:\n            switch (address_sa(addr)->sa_family) {\n                case AF_INET:\n                    return ntohs(((struct sockaddr_in *)addr->data)\n                            ->sin_port);\n                case AF_INET6:\n                    return ntohs(((struct sockaddr_in6 *)addr->data)\n                            ->sin6_port);\n                case AF_UNIX:\n                case AF_UNSPEC:\n                    return 0;\n                default:\n                    assert(0);\n                    return 0;\n            }\n        case WILDCARD:\n            return addr->port;\n        default:\n            /* invalid Address type */\n            assert(0);\n            return 0;\n    }\n}\n\nvoid\naddress_set_port(struct Address *addr, uint16_t port) {\n    switch (addr->type) {\n        case SOCKADDR:\n            switch (address_sa(addr)->sa_family) {\n                case AF_INET:\n                    (((struct sockaddr_in *)addr->data) ->sin_port) =\n                        htons(port);\n                    break;\n                case AF_INET6:\n                    (((struct sockaddr_in6 *)addr->data) ->sin6_port) =\n                        htons(port);\n                    break;\n                case AF_UNIX:\n                case AF_UNSPEC:\n                    /* no op */\n                    break;\n                default:\n                    assert(0);\n            }\n            /* fall through */\n        case HOSTNAME:\n        case WILDCARD:\n            addr->port = port;\n            break;\n        default:\n            /* invalid Address type */\n            assert(0);\n    }\n}\n\nint\naddress_set_port_str(struct Address *addr, const char* str) {\n    int port = atoi(str);\n    if (port < 0 || port > 65535) {\n        return 0;\n    }\n    address_set_port(addr, (uint16_t)port);\n    return 1;\n}\n\nconst char *\ndisplay_address(const struct Address *addr, char *buffer, size_t buffer_len) {\n    if (addr == NULL || buffer == NULL)\n        return NULL;\n\n    switch (addr->type) {\n        case HOSTNAME:\n            if (addr->port != 0)\n                snprintf(buffer, buffer_len, \"%s:%\" PRIu16,\n                        addr->data,\n                        addr->port);\n            else\n                snprintf(buffer, buffer_len, \"%s\",\n                        addr->data);\n            return buffer;\n        case SOCKADDR:\n            return display_sockaddr(addr->data, buffer, buffer_len);\n        case WILDCARD:\n            if (addr->port != 0)\n                snprintf(buffer, buffer_len, \"*:%\" PRIu16,\n                        addr->port);\n            else\n                snprintf(buffer, buffer_len, \"*\");\n            return buffer;\n        default:\n            assert(0);\n            return NULL;\n    }\n}\n\nconst char *\ndisplay_sockaddr(const void *sa, char *buffer, size_t buffer_len) {\n    char ip[INET6_ADDRSTRLEN];\n    if (sa == NULL || buffer == NULL)\n        return NULL;\n\n    switch (((const struct sockaddr *)sa)->sa_family) {\n        case AF_INET:\n            inet_ntop(AF_INET,\n                      &((const struct sockaddr_in *)sa)->sin_addr,\n                      ip, sizeof(ip));\n\n            if (((struct sockaddr_in *)sa)->sin_port != 0)\n                snprintf(buffer, buffer_len, \"%s:%\" PRIu16, ip,\n                        ntohs(((struct sockaddr_in *)sa)->sin_port));\n            else\n                snprintf(buffer, buffer_len, \"%s\", ip);\n\n            break;\n        case AF_INET6:\n            inet_ntop(AF_INET6,\n                      &((const struct sockaddr_in6 *)sa)->sin6_addr,\n                      ip, sizeof(ip));\n\n            if (((struct sockaddr_in6 *)sa)->sin6_port != 0)\n                snprintf(buffer, buffer_len, \"[%s]:%\" PRIu16, ip,\n                         ntohs(((struct sockaddr_in6 *)sa)->sin6_port));\n            else\n                snprintf(buffer, buffer_len, \"[%s]\", ip);\n\n            break;\n        case AF_UNIX:\n            snprintf(buffer, buffer_len, \"unix:%s\",\n                     ((struct sockaddr_un *)sa)->sun_path);\n            break;\n        case AF_UNSPEC:\n            snprintf(buffer, buffer_len, \"NONE\");\n            break;\n        default:\n            /* unexpected AF */\n            assert(0);\n    }\n    return buffer;\n}\n\nint\nis_numeric(const char *s) {\n    char *p;\n\n    if (s == NULL || *s == '\\0')\n        return 0;\n\n    int n = strtod(s, &p);\n    (void)n; /* unused */\n\n    return *p == '\\0'; /* entire string was numeric */\n}\n\nstatic int\nvalid_hostname(const char *hostname) {\n    if (hostname == NULL)\n        return 0;\n\n    size_t hostname_len = strlen(hostname);\n    if (hostname_len < 1 || hostname_len > 255)\n        return 0;\n\n    if (hostname[0] == '.')\n        return 0;\n\n    const char *hostname_end = hostname + hostname_len;\n    for (const char *label = hostname; label < hostname_end;) {\n        size_t label_len = (size_t)(hostname_end - label);\n        char *next_dot = strchr(label, '.');\n        if (next_dot != NULL)\n            label_len = (size_t)(next_dot - label);\n        assert(label + label_len <= hostname_end);\n\n        if (label_len > 63 || label_len < 1)\n            return 0;\n\n        if (label[0] == '-' || label[label_len - 1] == '-')\n            return 0;\n\n        if (strspn(label, valid_label_bytes) < label_len)\n            return 0;\n\n        label += label_len + 1;\n    }\n\n    return 1;\n}\n", "AM_CPPFLAGS = -I$(top_srcdir)/src -g $(LIBEV_CFLAGS) $(LIBPCRE_CFLAGS) $(LIBUDNS_CFLAGS)\nAM_CFLAGS = -fno-strict-aliasing -Wall -Wextra -Wpedantic -Wwrite-strings\n\n.NOTPARALLEL:\n\nTESTS = address_test \\\n        buffer_test \\\n        cfg_tokenizer_test \\\n        table_test \\\n        http_test \\\n        tls_test \\\n        binder_test\n\nTESTS += functional_test \\\n         bad_request_test \\\n         bind_source_test \\\n         connection_reset_test \\\n         fallback_test \\\n         fd_limit_test \\\n         ipv6_v6only_test \\\n         proxy_header_test \\\n         reload_test \\\n         reuseport_test \\\n         slow_client_test \\\n         transparent_proxy_test\nif DNS_ENABLED\n  TESTS += config_test \\\n           resolv_test \\\n           bad_dns_request_test\nendif\n\ncheck_PROGRAMS = http_test \\\n                 tls_test \\\n                 table_test \\\n                 binder_test \\\n                 buffer_test \\\n                 cfg_tokenizer_test \\\n                 address_test \\\n                 resolv_test \\\n                 config_test\n\nhttp_test_SOURCES = http_test.c \\\n                    ../src/http.c\n\ntls_test_SOURCES = tls_test.c \\\n                   ../src/tls.c \\\n                   ../src/logger.c\n\nbinder_test_SOURCES = binder_test.c \\\n                      ../src/binder.c \\\n                      ../src/logger.c\n\nbuffer_test_SOURCES = buffer_test.c \\\n                      ../src/buffer.c\n\nbuffer_test_LDADD = $(LIBEV_LIBS)\n\naddress_test_SOURCES = address_test.c \\\n                      ../src/address.c\n\ncfg_tokenizer_test_SOURCES = cfg_tokenizer_test.c \\\n                             ../src/cfg_tokenizer.c\n\nconfig_test_SOURCES = config_test.c \\\n                      ../src/binder.c \\\n                      ../src/config.c \\\n                      ../src/cfg_parser.c \\\n                      ../src/cfg_tokenizer.c \\\n                      ../src/address.c \\\n                      ../src/backend.c \\\n                      ../src/table.c \\\n                      ../src/listener.c \\\n                      ../src/connection.c \\\n                      ../src/buffer.c \\\n                      ../src/logger.c \\\n                      ../src/resolv.c \\\n                      ../src/resolv.h \\\n                      ../src/tls.c \\\n                      ../src/http.c\n\nconfig_test_LDADD = $(LIBEV_LIBS) $(LIBPCRE_LIBS) $(LIBUDNS_LIBS)\n\nresolv_test_SOURCES = resolv_test.c \\\n                      ../src/resolv.c \\\n                      ../src/address.c \\\n                      ../src/logger.c\n\nresolv_test_LDADD = $(LIBEV_LIBS) $(LIBUDNS_LIBS)\n\ntable_test_SOURCES = table_test.c \\\n                      ../src/backend.c \\\n                      ../src/table.c \\\n                      ../src/address.c \\\n                      ../src/logger.c\n\ntable_test_LDADD = $(LIBPCRE_LIBS)\n", "#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse File::Basename;\nuse lib dirname (__FILE__);\nuse TestUtils;\nuse TestHTTPD;\nuse File::Temp;\nuse IO::Socket::INET;\n\nmy $bad_requests = [\n    {\n        # Test bad name server\n        request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Invalid hostname\n        request => \"GET / HTTP/1.1\\r\\nHost: ...........\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Exceed buffer size\n        request => \"PUT / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 65536\\r\\n\\r\\n\" . 'x' x 65536,\n        client => \\&http_client,\n    },\n    {\n        # Exceed buffer size before host header\n        request => \"GET /\" . 'x' x 65536,\n        client => \\&http_client,\n    },\n    {\n        # Invalid hostname\n        request => \"GET / HTTP/1.1\\r\\nHost: \\0example.com\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Exceed hostname buffer size\n        request => \"GET / HTTP/1.1\\r\\nHost: [\" . 'long.' x 60 . \"example.com]\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Test client aborting connection before DNS response received\n        request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\",\n        client => \\&http_client_abort,\n    },\n];\n\nsub http_client($$) {\n    my $port = shift;\n    my $request = shift;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n                                       PeerPort => $port,\n                                       Proto => \"tcp\",\n                                       Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n\n    my $buffer;\n    $socket->recv($buffer, 4096);\n\n    $socket->close();\n\n    return undef;\n}\n\nsub http_client_abort($$) {\n    my $port = shift;\n    my $request = shift;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n                                       PeerPort => $port,\n                                       Proto => \"tcp\",\n                                       Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n    sleep(1);\n\n    $socket->close();\n\n    return undef;\n}\n\nsub proxy {\n    my $config = shift;\n\n    exec(@_, '../src/sniproxy', '-f', '-c', $config);\n}\n\n\nsub worker($$$) {\n    my ($port, $requests, $offset) = @_;\n\n    for (my $i = 0; $i < $requests; $i++) {\n        my $test = $bad_requests->[($i + $offset) % int(@$bad_requests)];\n        my $error = $test->{client}($port, $test->{request});\n\n        die($error) if defined $error;\n    }\n    # Success\n    exit 0;\n}\n\nsub make_wildcard_config($) {\n    my $proxy_port = shift;\n\n    my ($fh, $filename) = File::Temp::tempfile();\n\n    # Write out a test config file\n    print $fh <<END;\n# Minimal test configuration\n\nresolver {\n    # Use an RFC1166 documentation prefix IP address as the nameserver\n    # this should be not respond to DNS queries in any environment\n    nameserver 192.0.2.99\n}\n\nlisten 127.0.0.1 $proxy_port {\n    proto http\n}\n\ntable {\n    .* *:80\n}\nEND\n\n    close ($fh);\n\n    return $filename;\n}\n\nsub main {\n    my $proxy_port = $ENV{SNI_PROXY_PORT} || 8080;\n    my $workers = $ENV{WORKERS} || 3;\n    my $iterations = $ENV{ITERATIONS} || int(@$bad_requests);\n\n    my $config = make_wildcard_config($proxy_port);\n    my $proxy_pid = start_child('server', \\&proxy, $config, @ARGV);\n\n    # Wait for proxy to load and parse config\n    wait_for_port(port => $proxy_port);\n\n    for (my $i = 0; $i < $workers; $i++) {\n        start_child('worker', \\&worker, $proxy_port, $iterations, $i);\n    }\n\n    # Wait for all our children to finish\n    wait_for_type('worker');\n\n    # Give the proxy a second to flush buffers and close server connections\n    sleep 1;\n\n    # For troubleshooting connections stuck in CLOSE_WAIT state\n    #kill 10, $proxy_pid;\n    #system(\"netstat -ptn | grep $proxy_pid\\/sniproxy\");\n\n    # For troubleshooting 100% CPU usage\n    #system(\"top -n 1 -p $proxy_pid -b\");\n\n    # Orderly shutdown of the server\n    kill 15, $proxy_pid;\n    sleep 1;\n\n    # Delete our test configuration\n    unlink($config);\n\n    # Kill off any remaining children\n    reap_children();\n}\n\nmain();\n", "#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse File::Basename;\nuse lib dirname (__FILE__);\nuse TestUtils;\nuse TestHTTPD;\nuse File::Temp;\nuse IO::Socket::INET;\nuse Time::HiRes;\n\nsub proxy {\n    my $config = shift;\n\n    exec(@_, '../src/sniproxy', '-f', '-c', $config);\n}\n\nsub slow_client($$) {\n    my $port = shift;\n    my $requests = shift;\n    my $request = \"GET / HTTP/1.1\\r\\n\" .\n        \"UserAgent: slow_client/0.1\\r\\n\" .\n        \"Host: localhost:$port\\r\\n\" .\n        \"Accept: */*\\r\\n\" .\n        \"\\r\\n\";\n\n    local $SIG{ALRM} = sub { die \"alarm\\n\" };\n    alarm 10;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n            PeerPort => $port,\n            Proto => \"tcp\",\n            Type => SOCK_STREAM,\n            Timeout => 5)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n    foreach (split(\"\\r\\n\", $request)) {\n        unless ($socket->connected()) {\n            print \"Disconnected\\n\";\n            exit(0);\n        }\n        $socket->send(\"$_\\r\\n\");\n        sleep(1);\n    }\n\n    my $buffer;\n    $socket->recv($buffer, 4096);\n\n    $socket->close();\n\n    die(\"Unexpected response: $buffer\") unless ($buffer =~ /\\AHTTP\\/1\\.1 200 OK/);\n\n    exit(0);\n}\n\nsub main {\n    my $proxy_port = $ENV{SNI_PROXY_PORT} || 8080;\n    my $httpd_port = $ENV{TEST_HTTPD_PORT} || 8081;\n    my $workers = $ENV{WORKERS} || 3;\n    my $iterations = $ENV{ITERATIONS} || 3;\n    my $local_httpd = $ENV{LOCAL_HTTPD_PORT};\n\n    my $config = make_config($proxy_port, $local_httpd || $httpd_port);\n    my $proxy_pid = start_child('server', \\&proxy, $config, @ARGV);\n    my $httpd_pid = start_child('server', \\&TestHTTPD::httpd, port => $httpd_port) unless $local_httpd;\n\n    # Wait for proxy to load and parse config\n    wait_for_port(port => $httpd_port);\n    wait_for_port(port => $proxy_port);\n\n    for (my $i = 0; $i < $workers; $i++) {\n        start_child('worker', \\&slow_client, $proxy_port, $iterations);\n    }\n\n    # Wait for all our children to finish\n    wait_for_type('worker');\n\n    # Give the proxy a second to flush buffers and close server connections\n    sleep 1;\n\n    # For troubleshooting connections stuck in CLOSE_WAIT state\n    #kill 10, $proxy_pid;\n    #system(\"netstat -ptn | grep $proxy_pid\\/sniproxy\");\n\n    # For troubleshooting 100% CPU usage\n    #system(\"top -n 1 -p $proxy_pid -b\");\n\n    # Orderly shutdown of the server\n    kill 15, $proxy_pid;\n    kill 15, $httpd_pid unless $local_httpd;\n    sleep 1;\n\n    # Delete our test configuration\n    unlink($config);\n\n    # Kill off any remaining children\n    reap_children();\n}\n\nmain();\n"], "buggy_code_start_loc": [0, 5, 0, 1, 2, 3, 150, 2, 35, 34], "buggy_code_end_loc": [0, 6, 14, 2, 48, 4, 150, 2, 35, 38], "fixing_code_start_loc": [1, 5, 1, 1, 2, 3, 151, 3, 36, 34], "fixing_code_end_loc": [7, 6, 21, 2, 53, 4, 153, 5, 41, 44], "type": "CWE-120", "message": "A buffer overflow vulnerability exists in the handling of wildcard backend hosts of SNIProxy 0.6.0-2 and the master branch (commit: 822bb80df9b7b345cc9eba55df74a07b498819ba). A specially crafted HTTP or TLS packet can lead to arbitrary code execution. An attacker could send a malicious packet to trigger this vulnerability.", "other": {"cve": {"id": "CVE-2023-25076", "sourceIdentifier": "talos-cna@cisco.com", "published": "2023-03-30T15:15:07.370", "lastModified": "2023-05-27T04:15:24.837", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A buffer overflow vulnerability exists in the handling of wildcard backend hosts of SNIProxy 0.6.0-2 and the master branch (commit: 822bb80df9b7b345cc9eba55df74a07b498819ba). A specially crafted HTTP or TLS packet can lead to arbitrary code execution. An attacker could send a malicious packet to trigger this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "talos-cna@cisco.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "talos-cna@cisco.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sniproxy_project:sniproxy:0.6.0-2:*:*:*:*:*:*:*", "matchCriteriaId": "1E18CB41-EF35-46B8-9D6C-E0BA78FFA8F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sniproxy_project:sniproxy:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "28C6109D-E621-41AC-87A6-F50E7ACB5510"}]}]}], "references": [{"url": "https://github.com/dlundquist/sniproxy/commit/f8d9a433fe22ab2fa15c00179048ab02ae23d583", "source": "talos-cna@cisco.com", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/04/msg00030.html", "source": "talos-cna@cisco.com"}, {"url": "https://talosintelligence.com/vulnerability_reports/TALOS-2023-1731", "source": "talos-cna@cisco.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5413", "source": "talos-cna@cisco.com"}]}, "github_commit_url": "https://github.com/dlundquist/sniproxy/commit/f8d9a433fe22ab2fa15c00179048ab02ae23d583"}}