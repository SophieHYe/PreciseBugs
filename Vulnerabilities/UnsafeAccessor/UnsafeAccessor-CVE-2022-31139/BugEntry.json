{"buggy_code": ["package io.github.karlatemp.unsafeaccessor;\n\nimport org.jetbrains.annotations.Contract;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.util.function.Consumer;\n\n/**\n * JVM Root Access.\n *\n * @since 1.1.0\n */\n@SuppressWarnings(\"DefaultAnnotationParam\")\npublic class Root {\n    @Contract(pure = false)\n    public static Unsafe getUnsafe() {\n        return Unsafe.getUnsafe();\n    }\n\n    /**\n     * Return the trusted lookup.\n     * <p>\n     * Use {@link #getTrusted(Class)}\n     *\n     * @return MethodHandles.Lookup.IMPL_LOOKUP\n     */\n    @Deprecated\n    @Contract(pure = true)\n    public static MethodHandles.Lookup getTrusted() {\n        SecurityCheck.LIMITER.preGetTrustedLookup(null);\n        return RootLookupHolder.ROOT;\n    }\n\n    @Contract(pure = true)\n    public static MethodHandles.Lookup getTrusted(Class<?> k) {\n        SecurityCheck.LIMITER.preGetTrustedLookup(k);\n        return RootLookupHolder.trustedIn(k);\n    }\n\n    @Contract(pure = false, value = \"null, _ -> fail\")\n    public static void setAccessible(AccessibleObject object, boolean isAccessible) {\n        OpenAccess.openAccess(object, isAccessible);\n    }\n\n    @Contract(pure = false, value = \"null -> fail\")\n    public static <T extends AccessibleObject> T openAccess(T object) {\n        setAccessible(object, true);\n        return object;\n    }\n\n    static class RootLookupHolder {\n        static final MethodHandles.Lookup ROOT;\n\n        static boolean isOpenJ9vm() {\n            if (ROOT.lookupClass() == MethodHandle.class) {\n                int modes = ROOT.lookupModes();\n                return modes == 0x40 // AdoptOpenJDK - jdk 11.0.9.11 openj9\n                        || modes == 0x80 // Eclipse OpenJ9 VM - 11.0.12.7-openj9\n                        ;\n            }\n            return false;\n        }\n\n        static final boolean isOpenj9;\n        static final long accessMode;\n\n        static {\n            try {\n                Unsafe unsafe = getUnsafe();\n                MethodHandles.Lookup lookup;\n                try {\n                    Field field = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n                    openAccess(field);\n                    lookup = (MethodHandles.Lookup) field.get(null);\n                } catch (Throwable any) {\n                    if (unsafe.isJava9()) {\n                        lookup = MethodHandles.lookup();\n                        unsafe.putReference(\n                                lookup,\n                                unsafe.objectFieldOffset(MethodHandles.Lookup.class, \"lookupClass\"),\n                                Object.class\n                        );\n                        unsafe.putInt(\n                                lookup,\n                                unsafe.objectFieldOffset(MethodHandles.Lookup.class, \"allowedModes\"),\n                                -1\n                        );\n                    } else {\n                        throw any;\n                    }\n                }\n                ROOT = lookup;\n            } catch (Exception e) {\n                throw new ExceptionInInitializerError(e);\n            }\n            isOpenj9 = isOpenJ9vm();\n            if (isOpenj9) {\n                accessMode = Unsafe.getUnsafe0().objectFieldOffset(MethodHandles.Lookup.class, \"accessMode\");\n            } else {\n                accessMode = -1;\n            }\n        }\n\n        static MethodHandles.Lookup trustedIn(Class<?> target) {\n            if (target == null) return ROOT;\n            if (isOpenj9) {\n                MethodHandles.Lookup lookup = ROOT.in(target);\n                Unsafe.getUnsafe0().putLong(lookup, accessMode, ROOT.lookupModes());\n                return lookup;\n            }\n            return ROOT;\n        }\n    }\n\n    static class OpenAccess {\n        private static final Unsafe usf = Unsafe.getUnsafe0();\n        private static final long overrideOffset;\n\n        static {\n            if (usf.isJava9()) {\n                overrideOffset = usf.objectFieldOffset(AccessibleObject.class, \"override\");\n            } else {\n                try {\n                    Field field = AccessibleObject.class.getDeclaredField(\"override\");\n                    overrideOffset = usf.objectFieldOffset(field);\n                } catch (Throwable throwable) {\n                    throw new ExceptionInInitializerError(throwable);\n                }\n            }\n        }\n\n        static void openAccess0(AccessibleObject object, boolean isAccessible) {\n            if (object == null) throw new NullPointerException(\"object\");\n            usf.putBoolean(object, overrideOffset, isAccessible);\n        }\n\n        static void openAccess(AccessibleObject object, boolean isAccessible) {\n            if (isAccessible) {\n                SecurityCheck.LIMITER.preOpenAccessible(object);\n            }\n            openAccess0(object, isAccessible);\n        }\n    }\n\n    static class Secret {\n        static ModuleAccess MACCESS;\n    }\n\n    /**\n     * Throw a new exception\n     *\n     * @since 1.2.0\n     */\n    @Contract(pure = false)\n    public static <T> T throw0(Throwable throwable) {\n        if (throwable == null) throw new NullPointerException();\n        getUnsafe().throwException(throwable);\n        throw new RuntimeException();\n    }\n\n    /**\n     * Allocate a new object, but not initialized.\n     *\n     * @see Unsafe#allocateInstance(Class)\n     * @since 1.2.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Contract(pure = false)\n    public static <T> T allocate(Class<T> klass) throws InstantiationException {\n        return (T) getUnsafe().allocateInstance(klass);\n    }\n\n    /**\n     * @since 1.5.0\n     */\n    @Contract(pure = true)\n    public static ModuleAccess getModuleAccess() {\n        getUnsafe();\n        return Secret.MACCESS;\n    }\n\n    static class ObjectInitializer {\n        static Consumer<Object> initializer;\n\n        static Consumer<Object> initializer() {\n            if (initializer != null) return initializer;\n            synchronized (ObjectInitializer.class) {\n                if (initializer != null) return initializer;\n                initializer = UsfAccessor.allocateObjectInitializer();\n            }\n            return initializer;\n        }\n    }\n\n    /**\n     * Do nothing\n     *\n     * @since 1.6.0\n     */\n    public static void initializeObject(Object instance) {\n        if (instance == null) return;\n        Unsafe.getUnsafe0().ensureClassInitialized(instance.getClass());\n        ObjectInitializer.initializer().accept(instance);\n    }\n}\n", "package io.github.karlatemp.unsafeaccessor;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.AccessibleObject;\n\n/**\n * Direct unsafe access\n * <p>\n * A bridge object to access unsafe.\n * <p>\n * Unlike other methods, using this bridge will not trigger any permission checks.\n * The permission check will only happen in {@link #getInstance()}\n *\n * @since 1.4.0\n */\npublic final class UnsafeAccess extends ProtectedObject {\n    static final UnsafeAccess INSTANCE = new UnsafeAccess();\n\n    public static UnsafeAccess getInstance() {\n        SecurityCheck.getInstance();\n        return INSTANCE;\n    }\n\n    public SecurityCheck getSecuritySettings() {\n        checkTrusted();\n        return SecurityCheck.INSTANCE;\n    }\n\n    public Unsafe getUnsafe() {\n        checkTrusted();\n        return Unsafe.getUnsafe0();\n    }\n\n    /**\n     * Use {@link #getTrustedIn(Class)}\n     *\n     * @return MethodHandles.Lookup.IMPL_LOOKUP\n     */\n    @Deprecated\n    public MethodHandles.Lookup getTrusted() {\n        checkTrusted();\n        return Root.RootLookupHolder.ROOT;\n    }\n\n    public MethodHandles.Lookup getTrustedIn(Class<?> target) {\n        checkTrusted();\n        return Root.RootLookupHolder.trustedIn(target);\n    }\n\n    public <T extends AccessibleObject> T openAccess(T object) {\n        checkTrusted();\n        Root.OpenAccess.openAccess0(object, true);\n        return object;\n    }\n\n    public <T extends AccessibleObject> T setAccessible(T object, boolean accessible) {\n        checkTrusted();\n        Root.OpenAccess.openAccess0(object, accessible);\n        return object;\n    }\n\n    /**\n     * @since 1.5.0\n     */\n    public ModuleAccess getModuleAccess() {\n        checkTrusted();\n        Unsafe.getUnsafe0();\n        return Root.Secret.MACCESS;\n    }\n}\n"], "fixing_code": ["package io.github.karlatemp.unsafeaccessor;\n\nimport org.jetbrains.annotations.Contract;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.util.function.Consumer;\n\n/**\n * JVM Root Access.\n *\n * @since 1.1.0\n */\n@SuppressWarnings(\"DefaultAnnotationParam\")\npublic class Root {\n    @Contract(pure = false)\n    public static Unsafe getUnsafe() {\n        return Unsafe.getUnsafe();\n    }\n\n    /**\n     * Return the trusted lookup.\n     * <p>\n     * Use {@link #getTrusted(Class)}\n     *\n     * @return MethodHandles.Lookup.IMPL_LOOKUP\n     */\n    @Deprecated\n    @Contract(pure = true)\n    public static MethodHandles.Lookup getTrusted() {\n        SecurityCheck.LIMITER.preGetTrustedLookup(null);\n        return RootLookupHolder.ROOT;\n    }\n\n    @Contract(pure = true)\n    public static MethodHandles.Lookup getTrusted(Class<?> k) {\n        SecurityCheck.LIMITER.preGetTrustedLookup(k);\n        return RootLookupHolder.trustedIn(k);\n    }\n\n    @Contract(pure = false, value = \"null, _ -> fail\")\n    public static void setAccessible(AccessibleObject object, boolean isAccessible) {\n        OpenAccess.openAccess(object, isAccessible);\n    }\n\n    @Contract(pure = false, value = \"null -> fail\")\n    public static <T extends AccessibleObject> T openAccess(T object) {\n        setAccessible(object, true);\n        return object;\n    }\n\n    static class RootLookupHolder {\n        static final MethodHandles.Lookup ROOT;\n\n        static boolean isOpenJ9vm() {\n            if (ROOT.lookupClass() == MethodHandle.class) {\n                int modes = ROOT.lookupModes();\n                return modes == 0x40 // AdoptOpenJDK - jdk 11.0.9.11 openj9\n                        || modes == 0x80 // Eclipse OpenJ9 VM - 11.0.12.7-openj9\n                        ;\n            }\n            return false;\n        }\n\n        static final boolean isOpenj9;\n        static final long accessMode;\n\n        static {\n            try {\n                Unsafe unsafe = getUnsafe();\n                MethodHandles.Lookup lookup;\n                try {\n                    Field field = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n                    openAccess(field);\n                    lookup = (MethodHandles.Lookup) field.get(null);\n                } catch (Throwable any) {\n                    if (unsafe.isJava9()) {\n                        lookup = MethodHandles.lookup();\n                        unsafe.putReference(\n                                lookup,\n                                unsafe.objectFieldOffset(MethodHandles.Lookup.class, \"lookupClass\"),\n                                Object.class\n                        );\n                        unsafe.putInt(\n                                lookup,\n                                unsafe.objectFieldOffset(MethodHandles.Lookup.class, \"allowedModes\"),\n                                -1\n                        );\n                    } else {\n                        throw any;\n                    }\n                }\n                ROOT = lookup;\n            } catch (Exception e) {\n                throw new ExceptionInInitializerError(e);\n            }\n            isOpenj9 = isOpenJ9vm();\n            if (isOpenj9) {\n                accessMode = Unsafe.getUnsafe0().objectFieldOffset(MethodHandles.Lookup.class, \"accessMode\");\n            } else {\n                accessMode = -1;\n            }\n        }\n\n        static MethodHandles.Lookup trustedIn(Class<?> target) {\n            if (target == null) return ROOT;\n            if (isOpenj9) {\n                MethodHandles.Lookup lookup = ROOT.in(target);\n                Unsafe.getUnsafe0().putLong(lookup, accessMode, ROOT.lookupModes());\n                return lookup;\n            }\n            return ROOT;\n        }\n    }\n\n    static class OpenAccess {\n        private static final Unsafe usf = Unsafe.getUnsafe0();\n        private static final long overrideOffset;\n\n        static {\n            if (usf.isJava9()) {\n                overrideOffset = usf.objectFieldOffset(AccessibleObject.class, \"override\");\n            } else {\n                try {\n                    Field field = AccessibleObject.class.getDeclaredField(\"override\");\n                    overrideOffset = usf.objectFieldOffset(field);\n                } catch (Throwable throwable) {\n                    throw new ExceptionInInitializerError(throwable);\n                }\n            }\n        }\n\n        static void openAccess0(AccessibleObject object, boolean isAccessible) {\n            if (object == null) throw new NullPointerException(\"object\");\n            usf.putBoolean(object, overrideOffset, isAccessible);\n        }\n\n        static void openAccess(AccessibleObject object, boolean isAccessible) {\n            if (isAccessible) {\n                SecurityCheck.LIMITER.preOpenAccessible(object);\n            }\n            openAccess0(object, isAccessible);\n        }\n    }\n\n    static class Secret {\n        static ModuleAccess MACCESS;\n    }\n\n    /**\n     * Throw a new exception\n     *\n     * @since 1.2.0\n     */\n    @Contract(pure = false)\n    public static <T> T throw0(Throwable throwable) {\n        if (throwable == null) throw new NullPointerException();\n        Unsafe.getUnsafe0().throwException(throwable);\n        throw new RuntimeException(throwable);\n    }\n\n    /**\n     * Allocate a new object, but not initialized.\n     *\n     * @see Unsafe#allocateInstance(Class)\n     * @since 1.2.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Contract(pure = false)\n    public static <T> T allocate(Class<T> klass) throws InstantiationException {\n        return (T) getUnsafe().allocateInstance(klass);\n    }\n\n    /**\n     * @since 1.5.0\n     */\n    @Contract(pure = true)\n    public static ModuleAccess getModuleAccess() {\n        getUnsafe();\n        return Secret.MACCESS;\n    }\n\n    static class ObjectInitializer {\n        static Consumer<Object> initializer;\n\n        static Consumer<Object> initializer() {\n            if (initializer != null) return initializer;\n            synchronized (ObjectInitializer.class) {\n                if (initializer != null) return initializer;\n                initializer = UsfAccessor.allocateObjectInitializer();\n            }\n            return initializer;\n        }\n    }\n\n    /**\n     * Do nothing\n     *\n     * @since 1.6.0\n     */\n    public static void initializeObject(Object instance) {\n        if (instance == null) return;\n        Unsafe.getUnsafe0().ensureClassInitialized(instance.getClass());\n        ObjectInitializer.initializer().accept(instance);\n    }\n}\n", "package io.github.karlatemp.unsafeaccessor;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.AccessibleObject;\n\n/**\n * Direct unsafe access\n * <p>\n * A bridge object to access unsafe.\n * <p>\n * Unlike other methods, using this bridge will not trigger any permission checks.\n * The permission check will only happen in {@link #getInstance()}\n *\n * @since 1.4.0\n */\npublic final class UnsafeAccess extends ProtectedObject {\n    static final UnsafeAccess INSTANCE = new UnsafeAccess();\n\n    public static UnsafeAccess getInstance() {\n        SecurityCheck.AccessLimiter accessLimiter = SecurityCheck.getInstance().getLimiter();\n        if (accessLimiter != null) accessLimiter.preGetUnsafeAccess();\n        return INSTANCE;\n    }\n\n    public SecurityCheck getSecuritySettings() {\n        checkTrusted();\n        return SecurityCheck.INSTANCE;\n    }\n\n    public Unsafe getUnsafe() {\n        checkTrusted();\n        return Unsafe.getUnsafe0();\n    }\n\n    /**\n     * Use {@link #getTrustedIn(Class)}\n     *\n     * @return MethodHandles.Lookup.IMPL_LOOKUP\n     */\n    @Deprecated\n    public MethodHandles.Lookup getTrusted() {\n        checkTrusted();\n        return Root.RootLookupHolder.ROOT;\n    }\n\n    public MethodHandles.Lookup getTrustedIn(Class<?> target) {\n        checkTrusted();\n        return Root.RootLookupHolder.trustedIn(target);\n    }\n\n    public <T extends AccessibleObject> T openAccess(T object) {\n        checkTrusted();\n        Root.OpenAccess.openAccess0(object, true);\n        return object;\n    }\n\n    public <T extends AccessibleObject> T setAccessible(T object, boolean accessible) {\n        checkTrusted();\n        Root.OpenAccess.openAccess0(object, accessible);\n        return object;\n    }\n\n    /**\n     * @since 1.5.0\n     */\n    public ModuleAccess getModuleAccess() {\n        checkTrusted();\n        Unsafe.getUnsafe0();\n        return Root.Secret.MACCESS;\n    }\n}\n"], "buggy_code_start_loc": [160, 20], "buggy_code_end_loc": [162, 21], "fixing_code_start_loc": [160, 20], "fixing_code_end_loc": [162, 22], "type": "CWE-200", "message": "UnsafeAccessor (UA) is a bridge to access jdk.internal.misc.Unsafe & sun.misc.Unsafe. Normally, if UA is loaded as a named module, the internal data of UA is protected by JVM and others can only access UA via UA's standard API. The main application can set up `SecurityCheck.AccessLimiter` for UA to limit access to UA. Starting with version 1.4.0 and prior to version 1.7.0, when `SecurityCheck.AccessLimiter` is set up, untrusted code can access UA without limitation, even when UA is loaded as a named module. This issue does not affect those for whom `SecurityCheck.AccessLimiter` is not set up. Version 1.7.0 contains a patch.", "other": {"cve": {"id": "CVE-2022-31139", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-11T19:15:07.890", "lastModified": "2022-07-18T16:01:33.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "UnsafeAccessor (UA) is a bridge to access jdk.internal.misc.Unsafe & sun.misc.Unsafe. Normally, if UA is loaded as a named module, the internal data of UA is protected by JVM and others can only access UA via UA's standard API. The main application can set up `SecurityCheck.AccessLimiter` for UA to limit access to UA. Starting with version 1.4.0 and prior to version 1.7.0, when `SecurityCheck.AccessLimiter` is set up, untrusted code can access UA without limitation, even when UA is loaded as a named module. This issue does not affect those for whom `SecurityCheck.AccessLimiter` is not set up. Version 1.7.0 contains a patch."}, {"lang": "es", "value": "UnsafeAccessor (UA) es un puente para acceder a jdk.internal.misc.Unsafe y sun.misc.Unsafe. Normalmente, si UA es cargado como un m\u00f3dulo con nombre, los datos internos de UA est\u00e1n protegidos por la JVM y otros s\u00f3lo pueden acceder a UA por medio de la API est\u00e1ndar de UA. La aplicaci\u00f3n principal puede configurar \"SecurityCheck.AccessLimiter\" para UA para limitar el acceso a UA. A partir de la versi\u00f3n 1.4.0 y versiones anteriores a 1.7.0, cuando es configurado \"SecurityCheck.AccessLimiter\", el c\u00f3digo que no es confiable puede acceder a la UA sin limitaciones, incluso cuando la UA es cargado como un m\u00f3dulo con nombre. Este problema no afecta a aquellos para los que no ha sido configurado \"SecurityCheck.AccessLimiter\". La versi\u00f3n 1.7.0 contiene un parche"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unsafe_accessor_project:unsafe_accessor:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.4.0", "versionEndExcluding": "1.7.0", "matchCriteriaId": "74CE5507-3A9F-46CB-B306-9A2234819608"}]}]}], "references": [{"url": "https://github.com/Karlatemp/UnsafeAccessor/commit/4ef83000184e8f13239a1ea2847ee401d81585fd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Karlatemp/UnsafeAccessor/releases/tag/1.7.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Karlatemp/UnsafeAccessor/security/advisories/GHSA-cr6p-23cf-w9g9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Karlatemp/UnsafeAccessor/commit/4ef83000184e8f13239a1ea2847ee401d81585fd"}}