{"buggy_code": ["/*\n * Ut Video decoder\n * Copyright (c) 2011 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Ut Video decoder\n */\n\n#include <inttypes.h>\n#include <stdlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"bswapdsp.h\"\n#include \"bytestream.h\"\n#include \"get_bits.h\"\n#include \"thread.h\"\n#include \"utvideo.h\"\n\nstatic int build_huff(const uint8_t *src, VLC *vlc, int *fsym)\n{\n    int i;\n    HuffEntry he[256];\n    int last;\n    uint32_t codes[256];\n    uint8_t bits[256];\n    uint8_t syms[256];\n    uint32_t code;\n\n    *fsym = -1;\n    for (i = 0; i < 256; i++) {\n        he[i].sym = i;\n        he[i].len = *src++;\n    }\n    qsort(he, 256, sizeof(*he), ff_ut_huff_cmp_len);\n\n    if (!he[0].len) {\n        *fsym = he[0].sym;\n        return 0;\n    }\n\n    last = 255;\n    while (he[last].len == 255 && last)\n        last--;\n\n    if (he[last].len > 32)\n        return -1;\n\n    code = 1;\n    for (i = last; i >= 0; i--) {\n        codes[i] = code >> (32 - he[i].len);\n        bits[i]  = he[i].len;\n        syms[i]  = he[i].sym;\n        code += 0x80000000u >> (he[i].len - 1);\n    }\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,\n                              bits,  sizeof(*bits),  sizeof(*bits),\n                              codes, sizeof(*codes), sizeof(*codes),\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n}\n\nstatic int decode_plane(UtvideoContext *c, int plane_no,\n                        uint8_t *dst, int step, int stride,\n                        int width, int height,\n                        const uint8_t *src, int use_pred)\n{\n    int i, j, slice, pix;\n    int sstart, send;\n    VLC vlc;\n    GetBitContext gb;\n    int prev, fsym;\n    const int cmask = ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n    if (build_huff(src, &vlc, &fsym)) {\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n        send = 0;\n        for (slice = 0; slice < c->slices; slice++) {\n            uint8_t *dest;\n\n            sstart = send;\n            send   = (height * (slice + 1) / c->slices) & cmask;\n            dest   = dst + sstart * stride;\n\n            prev = 0x80;\n            for (j = sstart; j < send; j++) {\n                for (i = 0; i < width * step; i += step) {\n                    pix = fsym;\n                    if (use_pred) {\n                        prev += pix;\n                        pix   = prev;\n                    }\n                    dest[i] = pix;\n                }\n                dest += stride;\n            }\n        }\n        return 0;\n    }\n\n    src      += 256;\n\n    send = 0;\n    for (slice = 0; slice < c->slices; slice++) {\n        uint8_t *dest;\n        int slice_data_start, slice_data_end, slice_size;\n\n        sstart = send;\n        send   = (height * (slice + 1) / c->slices) & cmask;\n        dest   = dst + sstart * stride;\n\n        // slice offset and size validation was done earlier\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n        slice_data_end   = AV_RL32(src + slice * 4);\n        slice_size       = slice_data_end - slice_data_start;\n\n        if (!slice_size) {\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n                   \"yet a slice has a length of zero.\\n\");\n            goto fail;\n        }\n\n        memcpy(c->slice_bits, src + slice_data_start + c->slices * 4,\n               slice_size);\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n                          (uint32_t *) c->slice_bits,\n                          (slice_data_end - slice_data_start + 3) >> 2);\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n        prev = 0x80;\n        for (j = sstart; j < send; j++) {\n            for (i = 0; i < width * step; i += step) {\n                if (get_bits_left(&gb) <= 0) {\n                    av_log(c->avctx, AV_LOG_ERROR,\n                           \"Slice decoding ran out of bits\\n\");\n                    goto fail;\n                }\n                pix = get_vlc2(&gb, vlc.table, vlc.bits, 3);\n                if (pix < 0) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n                    goto fail;\n                }\n                if (use_pred) {\n                    prev += pix;\n                    pix   = prev;\n                }\n                dest[i] = pix;\n            }\n            dest += stride;\n        }\n        if (get_bits_left(&gb) > 32)\n            av_log(c->avctx, AV_LOG_WARNING,\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n    }\n\n    ff_free_vlc(&vlc);\n\n    return 0;\nfail:\n    ff_free_vlc(&vlc);\n    return AVERROR_INVALIDDATA;\n}\n\nstatic void restore_rgb_planes(uint8_t *src, int step, int stride, int width,\n                               int height)\n{\n    int i, j;\n    uint8_t r, g, b;\n\n    for (j = 0; j < height; j++) {\n        for (i = 0; i < width * step; i += step) {\n            r = src[i];\n            g = src[i + 1];\n            b = src[i + 2];\n            src[i]     = r + g - 0x80;\n            src[i + 2] = b + g - 0x80;\n        }\n        src += stride;\n    }\n}\n\nstatic void restore_median(uint8_t *src, int step, int stride,\n                           int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask = ~rmode;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start  = ((slice * height) / slices) & cmask;\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                       slice_start;\n\n        if (!slice_height)\n            continue;\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            bsrc += stride;\n        }\n    }\n}\n\n/* UtVideo interlaced mode treats every two lines as a single one,\n * so restoring function should take care of possible padding between\n * two parts of the same \"line\".\n */\nstatic void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n        if (!slice_height)\n            continue;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    UtvideoContext *c = avctx->priv_data;\n    int i, j;\n    const uint8_t *plane_start[5];\n    int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;\n    int ret;\n    GetByteContext gb;\n    ThreadFrame frame = { .f = data };\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    /* parse plane structure to get frame flags and validate slice offsets */\n    bytestream2_init(&gb, buf, buf_size);\n    for (i = 0; i < c->planes; i++) {\n        plane_start[i] = gb.buffer;\n        if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {\n            av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        bytestream2_skipu(&gb, 256);\n        slice_start = 0;\n        slice_end   = 0;\n        for (j = 0; j < c->slices; j++) {\n            slice_end   = bytestream2_get_le32u(&gb);\n            slice_size  = slice_end - slice_start;\n            if (slice_end < 0 || slice_size < 0 ||\n                bytestream2_get_bytes_left(&gb) < slice_end) {\n                av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            slice_start = slice_end;\n            max_slice_size = FFMAX(max_slice_size, slice_size);\n        }\n        plane_size = slice_end;\n        bytestream2_skipu(&gb, plane_size);\n    }\n    plane_start[c->planes] = gb.buffer;\n    if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {\n        av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->frame_info = bytestream2_get_le32u(&gb);\n    av_log(avctx, AV_LOG_DEBUG, \"frame information flags %\"PRIX32\"\\n\",\n           c->frame_info);\n\n    c->frame_pred = (c->frame_info >> 8) & 3;\n\n    if (c->frame_pred == PRED_GRADIENT) {\n        avpriv_request_sample(avctx, \"Frame with gradient prediction\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_fast_malloc(&c->slice_bits, &c->slice_bits_size,\n                   max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!c->slice_bits) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    switch (c->avctx->pix_fmt) {\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n        for (i = 0; i < c->planes; i++) {\n            ret = decode_plane(c, i, frame.f->data[0] + ff_ut_rgb_order[i],\n                               c->planes, frame.f->linesize[0], avctx->width,\n                               avctx->height, plane_start[i],\n                               c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[0] + ff_ut_rgb_order[i],\n                                   c->planes, frame.f->linesize[0], avctx->width,\n                                   avctx->height, c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[0] + ff_ut_rgb_order[i],\n                                      c->planes, frame.f->linesize[0],\n                                      avctx->width, avctx->height, c->slices,\n                                      0);\n                }\n            }\n        }\n        restore_rgb_planes(frame.f->data[0], c->planes, frame.f->linesize[0],\n                           avctx->width, avctx->height);\n        break;\n    case AV_PIX_FMT_YUV420P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height >> !!i,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height >> !!i,\n                                   c->slices, !i);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width  >> !!i,\n                                      avctx->height >> !!i,\n                                      c->slices, !i);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV422P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height,\n                                   c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width >> !!i, avctx->height,\n                                      c->slices, 0);\n                }\n            }\n        }\n        break;\n    }\n\n    frame.f->key_frame = 1;\n    frame.f->pict_type = AV_PICTURE_TYPE_I;\n    frame.f->interlaced_frame = !!c->interlaced;\n\n    *got_frame = 1;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n\n    c->avctx = avctx;\n\n    ff_bswapdsp_init(&c->bdsp);\n\n    if (avctx->extradata_size < 16) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Insufficient extradata size %d, should be at least 16\\n\",\n               avctx->extradata_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n           avctx->extradata[3], avctx->extradata[2],\n           avctx->extradata[1], avctx->extradata[0]);\n    av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",\n           AV_RB32(avctx->extradata + 4));\n    c->frame_info_size = AV_RL32(avctx->extradata + 8);\n    c->flags           = AV_RL32(avctx->extradata + 12);\n\n    if (c->frame_info_size != 4)\n        avpriv_request_sample(avctx, \"Frame info not 4 bytes\");\n    av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);\n    c->slices      = (c->flags >> 24) + 1;\n    c->compression = c->flags & 1;\n    c->interlaced  = c->flags & 0x800;\n\n    c->slice_bits_size = 0;\n\n    switch (avctx->codec_tag) {\n    case MKTAG('U', 'L', 'R', 'G'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case MKTAG('U', 'L', 'R', 'A'):\n        c->planes      = 4;\n        avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        break;\n    case MKTAG('U', 'L', 'Y', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'Y', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'H', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    case MKTAG('U', 'L', 'H', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unknown Ut Video FOURCC provided (%08X)\\n\",\n               avctx->codec_tag);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n\n    av_freep(&c->slice_bits);\n\n    return 0;\n}\n\nAVCodec ff_utvideo_decoder = {\n    .name           = \"utvideo\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Ut Video\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_UTVIDEO,\n    .priv_data_size = sizeof(UtvideoContext),\n    .init           = decode_init,\n    .close          = decode_end,\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,\n};\n"], "fixing_code": ["/*\n * Ut Video decoder\n * Copyright (c) 2011 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Ut Video decoder\n */\n\n#include <inttypes.h>\n#include <stdlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"avcodec.h\"\n#include \"bswapdsp.h\"\n#include \"bytestream.h\"\n#include \"get_bits.h\"\n#include \"thread.h\"\n#include \"utvideo.h\"\n\nstatic int build_huff(const uint8_t *src, VLC *vlc, int *fsym)\n{\n    int i;\n    HuffEntry he[256];\n    int last;\n    uint32_t codes[256];\n    uint8_t bits[256];\n    uint8_t syms[256];\n    uint32_t code;\n\n    *fsym = -1;\n    for (i = 0; i < 256; i++) {\n        he[i].sym = i;\n        he[i].len = *src++;\n    }\n    qsort(he, 256, sizeof(*he), ff_ut_huff_cmp_len);\n\n    if (!he[0].len) {\n        *fsym = he[0].sym;\n        return 0;\n    }\n\n    last = 255;\n    while (he[last].len == 255 && last)\n        last--;\n\n    if (he[last].len > 32)\n        return -1;\n\n    code = 1;\n    for (i = last; i >= 0; i--) {\n        codes[i] = code >> (32 - he[i].len);\n        bits[i]  = he[i].len;\n        syms[i]  = he[i].sym;\n        code += 0x80000000u >> (he[i].len - 1);\n    }\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,\n                              bits,  sizeof(*bits),  sizeof(*bits),\n                              codes, sizeof(*codes), sizeof(*codes),\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n}\n\nstatic int decode_plane(UtvideoContext *c, int plane_no,\n                        uint8_t *dst, int step, int stride,\n                        int width, int height,\n                        const uint8_t *src, int use_pred)\n{\n    int i, j, slice, pix;\n    int sstart, send;\n    VLC vlc;\n    GetBitContext gb;\n    int prev, fsym;\n    const int cmask = ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n    if (build_huff(src, &vlc, &fsym)) {\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n        send = 0;\n        for (slice = 0; slice < c->slices; slice++) {\n            uint8_t *dest;\n\n            sstart = send;\n            send   = (height * (slice + 1) / c->slices) & cmask;\n            dest   = dst + sstart * stride;\n\n            prev = 0x80;\n            for (j = sstart; j < send; j++) {\n                for (i = 0; i < width * step; i += step) {\n                    pix = fsym;\n                    if (use_pred) {\n                        prev += pix;\n                        pix   = prev;\n                    }\n                    dest[i] = pix;\n                }\n                dest += stride;\n            }\n        }\n        return 0;\n    }\n\n    src      += 256;\n\n    send = 0;\n    for (slice = 0; slice < c->slices; slice++) {\n        uint8_t *dest;\n        int slice_data_start, slice_data_end, slice_size;\n\n        sstart = send;\n        send   = (height * (slice + 1) / c->slices) & cmask;\n        dest   = dst + sstart * stride;\n\n        // slice offset and size validation was done earlier\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n        slice_data_end   = AV_RL32(src + slice * 4);\n        slice_size       = slice_data_end - slice_data_start;\n\n        if (!slice_size) {\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n                   \"yet a slice has a length of zero.\\n\");\n            goto fail;\n        }\n\n        memcpy(c->slice_bits, src + slice_data_start + c->slices * 4,\n               slice_size);\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n                          (uint32_t *) c->slice_bits,\n                          (slice_data_end - slice_data_start + 3) >> 2);\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n        prev = 0x80;\n        for (j = sstart; j < send; j++) {\n            for (i = 0; i < width * step; i += step) {\n                if (get_bits_left(&gb) <= 0) {\n                    av_log(c->avctx, AV_LOG_ERROR,\n                           \"Slice decoding ran out of bits\\n\");\n                    goto fail;\n                }\n                pix = get_vlc2(&gb, vlc.table, vlc.bits, 3);\n                if (pix < 0) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n                    goto fail;\n                }\n                if (use_pred) {\n                    prev += pix;\n                    pix   = prev;\n                }\n                dest[i] = pix;\n            }\n            dest += stride;\n        }\n        if (get_bits_left(&gb) > 32)\n            av_log(c->avctx, AV_LOG_WARNING,\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n    }\n\n    ff_free_vlc(&vlc);\n\n    return 0;\nfail:\n    ff_free_vlc(&vlc);\n    return AVERROR_INVALIDDATA;\n}\n\nstatic void restore_rgb_planes(uint8_t *src, int step, int stride, int width,\n                               int height)\n{\n    int i, j;\n    uint8_t r, g, b;\n\n    for (j = 0; j < height; j++) {\n        for (i = 0; i < width * step; i += step) {\n            r = src[i];\n            g = src[i + 1];\n            b = src[i + 2];\n            src[i]     = r + g - 0x80;\n            src[i + 2] = b + g - 0x80;\n        }\n        src += stride;\n    }\n}\n\nstatic void restore_median(uint8_t *src, int step, int stride,\n                           int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask = ~rmode;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start  = ((slice * height) / slices) & cmask;\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                       slice_start;\n\n        if (!slice_height)\n            continue;\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            bsrc += stride;\n        }\n    }\n}\n\n/* UtVideo interlaced mode treats every two lines as a single one,\n * so restoring function should take care of possible padding between\n * two parts of the same \"line\".\n */\nstatic void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n        if (!slice_height)\n            continue;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    UtvideoContext *c = avctx->priv_data;\n    int i, j;\n    const uint8_t *plane_start[5];\n    int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;\n    int ret;\n    GetByteContext gb;\n    ThreadFrame frame = { .f = data };\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    /* parse plane structure to get frame flags and validate slice offsets */\n    bytestream2_init(&gb, buf, buf_size);\n    for (i = 0; i < c->planes; i++) {\n        plane_start[i] = gb.buffer;\n        if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {\n            av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        bytestream2_skipu(&gb, 256);\n        slice_start = 0;\n        slice_end   = 0;\n        for (j = 0; j < c->slices; j++) {\n            slice_end   = bytestream2_get_le32u(&gb);\n            slice_size  = slice_end - slice_start;\n            if (slice_end < 0 || slice_size < 0 ||\n                bytestream2_get_bytes_left(&gb) < slice_end) {\n                av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            slice_start = slice_end;\n            max_slice_size = FFMAX(max_slice_size, slice_size);\n        }\n        plane_size = slice_end;\n        bytestream2_skipu(&gb, plane_size);\n    }\n    plane_start[c->planes] = gb.buffer;\n    if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {\n        av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->frame_info = bytestream2_get_le32u(&gb);\n    av_log(avctx, AV_LOG_DEBUG, \"frame information flags %\"PRIX32\"\\n\",\n           c->frame_info);\n\n    c->frame_pred = (c->frame_info >> 8) & 3;\n\n    if (c->frame_pred == PRED_GRADIENT) {\n        avpriv_request_sample(avctx, \"Frame with gradient prediction\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_fast_malloc(&c->slice_bits, &c->slice_bits_size,\n                   max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!c->slice_bits) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    switch (c->avctx->pix_fmt) {\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n        for (i = 0; i < c->planes; i++) {\n            ret = decode_plane(c, i, frame.f->data[0] + ff_ut_rgb_order[i],\n                               c->planes, frame.f->linesize[0], avctx->width,\n                               avctx->height, plane_start[i],\n                               c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[0] + ff_ut_rgb_order[i],\n                                   c->planes, frame.f->linesize[0], avctx->width,\n                                   avctx->height, c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[0] + ff_ut_rgb_order[i],\n                                      c->planes, frame.f->linesize[0],\n                                      avctx->width, avctx->height, c->slices,\n                                      0);\n                }\n            }\n        }\n        restore_rgb_planes(frame.f->data[0], c->planes, frame.f->linesize[0],\n                           avctx->width, avctx->height);\n        break;\n    case AV_PIX_FMT_YUV420P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height >> !!i,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height >> !!i,\n                                   c->slices, !i);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width  >> !!i,\n                                      avctx->height >> !!i,\n                                      c->slices, !i);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV422P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height,\n                                   c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width >> !!i, avctx->height,\n                                      c->slices, 0);\n                }\n            }\n        }\n        break;\n    }\n\n    frame.f->key_frame = 1;\n    frame.f->pict_type = AV_PICTURE_TYPE_I;\n    frame.f->interlaced_frame = !!c->interlaced;\n\n    *got_frame = 1;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n    int h_shift, v_shift;\n\n    c->avctx = avctx;\n\n    ff_bswapdsp_init(&c->bdsp);\n\n    if (avctx->extradata_size < 16) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Insufficient extradata size %d, should be at least 16\\n\",\n               avctx->extradata_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n           avctx->extradata[3], avctx->extradata[2],\n           avctx->extradata[1], avctx->extradata[0]);\n    av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",\n           AV_RB32(avctx->extradata + 4));\n    c->frame_info_size = AV_RL32(avctx->extradata + 8);\n    c->flags           = AV_RL32(avctx->extradata + 12);\n\n    if (c->frame_info_size != 4)\n        avpriv_request_sample(avctx, \"Frame info not 4 bytes\");\n    av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);\n    c->slices      = (c->flags >> 24) + 1;\n    c->compression = c->flags & 1;\n    c->interlaced  = c->flags & 0x800;\n\n    c->slice_bits_size = 0;\n\n    switch (avctx->codec_tag) {\n    case MKTAG('U', 'L', 'R', 'G'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case MKTAG('U', 'L', 'R', 'A'):\n        c->planes      = 4;\n        avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        break;\n    case MKTAG('U', 'L', 'Y', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'Y', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT470BG;\n        break;\n    case MKTAG('U', 'L', 'H', '0'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    case MKTAG('U', 'L', 'H', '2'):\n        c->planes      = 3;\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        avctx->colorspace = AVCOL_SPC_BT709;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unknown Ut Video FOURCC provided (%08X)\\n\",\n               avctx->codec_tag);\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &h_shift, &v_shift);\n    if ((avctx->width  & ((1<<h_shift)-1)) ||\n        (avctx->height & ((1<<v_shift)-1))) {\n        avpriv_request_sample(avctx, \"Odd dimensions\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    UtvideoContext * const c = avctx->priv_data;\n\n    av_freep(&c->slice_bits);\n\n    return 0;\n}\n\nAVCodec ff_utvideo_decoder = {\n    .name           = \"utvideo\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Ut Video\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_UTVIDEO,\n    .priv_data_size = sizeof(UtvideoContext),\n    .init           = decode_init,\n    .close          = decode_end,\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,\n};\n"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [538], "fixing_code_start_loc": [31], "fixing_code_end_loc": [548], "type": "CWE-125", "message": "The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data.", "other": {"cve": {"id": "CVE-2018-7557", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-28T07:29:00.463", "lastModified": "2022-10-07T02:10:31.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data."}, {"lang": "es", "value": "La funci\u00f3n decode_init en libavcodec/utvideodec.c en FFmpeg versi\u00f3n 2.8 hasta la versi\u00f3n 3.4.2 permite a atacantes remotos causar una denegaci\u00f3n de servicio (lectura fuera de array) utilizando un archivo AVI manipulado con dimensiones manipuladas en datos de submuestreo de crominancia"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8", "versionEndIncluding": "3.4.2", "matchCriteriaId": "7FE9FE81-AA1D-4869-996A-EEDC052D6374"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/7414d0bda7763f9bd69c26c068e482ab297c1c96", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/e724bd1dd9efea3abb8586d6644ec07694afceae", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-65", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4249", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e724bd1dd9efea3abb8586d6644ec07694afceae"}}