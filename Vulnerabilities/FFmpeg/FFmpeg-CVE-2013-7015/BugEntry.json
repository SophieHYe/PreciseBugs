{"buggy_code": ["/*\n * Flash Screen Video decoder\n * Copyright (C) 2004 Alex Beregszaszi\n * Copyright (C) 2006 Benjamin Larsson\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Flash Screen Video decoder\n * @author Alex Beregszaszi\n * @author Benjamin Larsson\n * @author Daniel Verkamp\n * @author Konstantin Shishkov\n *\n * A description of the bitstream format for Flash Screen Video version 1/2\n * is part of the SWF File Format Specification (version 10), which can be\n * downloaded from http://www.adobe.com/devnet/swf.html.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <zlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n\ntypedef struct BlockInfo {\n    uint8_t *pos;\n    int      size;\n} BlockInfo;\n\ntypedef struct FlashSVContext {\n    AVCodecContext *avctx;\n    AVFrame         frame;\n    int             image_width, image_height;\n    int             block_width, block_height;\n    uint8_t        *tmpblock;\n    int             block_size;\n    z_stream        zstream;\n    int             ver;\n    const uint32_t *pal;\n    int             is_keyframe;\n    uint8_t        *keyframedata;\n    uint8_t        *keyframe;\n    BlockInfo      *blocks;\n    uint8_t        *deflate_block;\n    int             deflate_block_size;\n    int             color_depth;\n    int             zlibprime_curr, zlibprime_prev;\n    int             diff_start, diff_height;\n} FlashSVContext;\n\n\nstatic int decode_hybrid(const uint8_t *sptr, uint8_t *dptr, int dx, int dy,\n                         int h, int w, int stride, const uint32_t *pal)\n{\n    int x, y;\n    const uint8_t *orig_src = sptr;\n\n    for (y = dx+h; y > dx; y--) {\n        uint8_t *dst = dptr + (y * stride) + dy * 3;\n        for (x = 0; x < w; x++) {\n            if (*sptr & 0x80) {\n                /* 15-bit color */\n                unsigned c = AV_RB16(sptr) & ~0x8000;\n                unsigned b =  c        & 0x1F;\n                unsigned g = (c >>  5) & 0x1F;\n                unsigned r =  c >> 10;\n                /* 000aaabb -> aaabbaaa  */\n                *dst++ = (b << 3) | (b >> 2);\n                *dst++ = (g << 3) | (g >> 2);\n                *dst++ = (r << 3) | (r >> 2);\n                sptr += 2;\n            } else {\n                /* palette index */\n                uint32_t c = pal[*sptr++];\n                bytestream_put_le24(&dst, c);\n            }\n        }\n    }\n    return sptr - orig_src;\n}\n\nstatic av_cold int flashsv_decode_init(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n    int zret; // Zlib return code\n\n    s->avctx          = avctx;\n    s->zstream.zalloc = Z_NULL;\n    s->zstream.zfree  = Z_NULL;\n    s->zstream.opaque = Z_NULL;\n    zret = inflateInit(&s->zstream);\n    if (zret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret);\n        return 1;\n    }\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    avcodec_get_frame_defaults(&s->frame);\n\n    return 0;\n}\n\n\nstatic int flashsv2_prime(FlashSVContext *s, uint8_t *src, int size)\n{\n    z_stream zs;\n    int zret; // Zlib return code\n\n    if (!src)\n        return AVERROR_INVALIDDATA;\n\n    zs.zalloc = NULL;\n    zs.zfree  = NULL;\n    zs.opaque = NULL;\n\n    s->zstream.next_in   = src;\n    s->zstream.avail_in  = size;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    inflate(&s->zstream, Z_SYNC_FLUSH);\n\n    if (deflateInit(&zs, 0) != Z_OK)\n        return -1;\n    zs.next_in   = s->tmpblock;\n    zs.avail_in  = s->block_size * 3 - s->zstream.avail_out;\n    zs.next_out  = s->deflate_block;\n    zs.avail_out = s->deflate_block_size;\n    deflate(&zs, Z_SYNC_FLUSH);\n    deflateEnd(&zs);\n\n    if ((zret = inflateReset(&s->zstream)) != Z_OK) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", zret);\n        return AVERROR_UNKNOWN;\n    }\n\n    s->zstream.next_in   = s->deflate_block;\n    s->zstream.avail_in  = s->deflate_block_size - zs.avail_out;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    inflate(&s->zstream, Z_SYNC_FLUSH);\n\n    return 0;\n}\n\nstatic int flashsv_decode_block(AVCodecContext *avctx, AVPacket *avpkt,\n                                GetBitContext *gb, int block_size,\n                                int width, int height, int x_pos, int y_pos,\n                                int blk_idx)\n{\n    struct FlashSVContext *s = avctx->priv_data;\n    uint8_t *line = s->tmpblock;\n    int k;\n    int ret = inflateReset(&s->zstream);\n    if (ret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", ret);\n        return AVERROR_UNKNOWN;\n    }\n    if (s->zlibprime_curr || s->zlibprime_prev) {\n        ret = flashsv2_prime(s,\n                             s->blocks[blk_idx].pos,\n                             s->blocks[blk_idx].size);\n        if (ret < 0)\n            return ret;\n    }\n    s->zstream.next_in   = avpkt->data + get_bits_count(gb) / 8;\n    s->zstream.avail_in  = block_size;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    ret = inflate(&s->zstream, Z_FINISH);\n    if (ret == Z_DATA_ERROR) {\n        av_log(avctx, AV_LOG_ERROR, \"Zlib resync occurred\\n\");\n        inflateSync(&s->zstream);\n        ret = inflate(&s->zstream, Z_FINISH);\n    }\n\n    if (ret != Z_OK && ret != Z_STREAM_END) {\n        //return -1;\n    }\n\n    if (s->is_keyframe) {\n        s->blocks[blk_idx].pos      = s->keyframedata + (get_bits_count(gb) / 8);\n        s->blocks[blk_idx].size     = block_size;\n    }\n    if (!s->color_depth) {\n        /* Flash Screen Video stores the image upside down, so copy\n         * lines to destination in reverse order. */\n        for (k = 1; k <= s->diff_height; k++) {\n            memcpy(s->frame.data[0] + x_pos * 3 +\n                   (s->image_height - y_pos - s->diff_start - k) * s->frame.linesize[0],\n                   line, width * 3);\n            /* advance source pointer to next line */\n            line += width * 3;\n        }\n    } else {\n        /* hybrid 15-bit/palette mode */\n        decode_hybrid(s->tmpblock, s->frame.data[0],\n                      s->image_height - (y_pos + 1 + s->diff_start + s->diff_height),\n                      x_pos, s->diff_height, width,\n                      s->frame.linesize[0], s->pal);\n    }\n    skip_bits_long(gb, 8 * block_size); /* skip the consumed bits */\n    return 0;\n}\n\nstatic int calc_deflate_block_size(int tmpblock_size)\n{\n    z_stream zstream;\n    int size;\n\n    zstream.zalloc = Z_NULL;\n    zstream.zfree  = Z_NULL;\n    zstream.opaque = Z_NULL;\n    if (deflateInit(&zstream, 0) != Z_OK)\n        return -1;\n    size = deflateBound(&zstream, tmpblock_size);\n    deflateEnd(&zstream);\n\n    return size;\n}\n\nstatic int flashsv_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame, AVPacket *avpkt)\n{\n    int buf_size       = avpkt->size;\n    FlashSVContext *s  = avctx->priv_data;\n    int h_blocks, v_blocks, h_part, v_part, i, j, ret;\n    GetBitContext gb;\n    int last_blockwidth = s->block_width;\n    int last_blockheight= s->block_height;\n\n    /* no supplementary picture */\n    if (buf_size == 0)\n        return 0;\n    if (buf_size < 4)\n        return -1;\n\n    init_get_bits(&gb, avpkt->data, buf_size * 8);\n\n    /* start to parse the bitstream */\n    s->block_width  = 16 * (get_bits(&gb,  4) + 1);\n    s->image_width  =       get_bits(&gb, 12);\n    s->block_height = 16 * (get_bits(&gb,  4) + 1);\n    s->image_height =       get_bits(&gb, 12);\n\n    if (   last_blockwidth != s->block_width\n        || last_blockheight!= s->block_height)\n        av_freep(&s->blocks);\n\n    if (s->ver == 2) {\n        skip_bits(&gb, 6);\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"iframe\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"Custom palette\");\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n\n    /* calculate number of blocks and size of border (partial) blocks */\n    h_blocks = s->image_width  / s->block_width;\n    h_part   = s->image_width  % s->block_width;\n    v_blocks = s->image_height / s->block_height;\n    v_part   = s->image_height % s->block_height;\n\n    /* the block size could change between frames, make sure the buffer\n     * is large enough, if not, get a larger one */\n    if (s->block_size < s->block_width * s->block_height) {\n        int tmpblock_size = 3 * s->block_width * s->block_height;\n\n        s->tmpblock = av_realloc(s->tmpblock, tmpblock_size);\n        if (!s->tmpblock) {\n            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");\n            return AVERROR(ENOMEM);\n        }\n        if (s->ver == 2) {\n            s->deflate_block_size = calc_deflate_block_size(tmpblock_size);\n            if (s->deflate_block_size <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't determine deflate buffer size.\\n\");\n                return -1;\n            }\n            s->deflate_block = av_realloc(s->deflate_block, s->deflate_block_size);\n            if (!s->deflate_block) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't allocate deflate buffer.\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n    }\n    s->block_size = s->block_width * s->block_height;\n\n    /* initialize the image size once */\n    if (avctx->width == 0 && avctx->height == 0) {\n        avcodec_set_dimensions(avctx, s->image_width, s->image_height);\n    }\n\n    /* check for changes of image width and image height */\n    if (avctx->width != s->image_width || avctx->height != s->image_height) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame width or height differs from first frame!\\n\");\n        av_log(avctx, AV_LOG_ERROR, \"fh = %d, fv %d  vs  ch = %d, cv = %d\\n\",\n               avctx->height, avctx->width, s->image_height, s->image_width);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* we care for keyframes only in Screen Video v2 */\n    s->is_keyframe = (avpkt->flags & AV_PKT_FLAG_KEY) && (s->ver == 2);\n    if (s->is_keyframe) {\n        s->keyframedata = av_realloc(s->keyframedata, avpkt->size);\n        memcpy(s->keyframedata, avpkt->data, avpkt->size);\n    }\n    if(s->ver == 2 && !s->blocks)\n        s->blocks = av_mallocz((v_blocks + !!v_part) * (h_blocks + !!h_part)\n                                * sizeof(s->blocks[0]));\n\n    av_dlog(avctx, \"image: %dx%d block: %dx%d num: %dx%d part: %dx%d\\n\",\n            s->image_width, s->image_height, s->block_width, s->block_height,\n            h_blocks, v_blocks, h_part, v_part);\n\n    if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)\n        return ret;\n\n    /* loop over all block columns */\n    for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {\n\n        int y_pos  = j * s->block_height; // vertical position in frame\n        int cur_blk_height = (j < v_blocks) ? s->block_height : v_part;\n\n        /* loop over all block rows */\n        for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {\n            int x_pos = i * s->block_width; // horizontal position in frame\n            int cur_blk_width = (i < h_blocks) ? s->block_width : h_part;\n            int has_diff = 0;\n\n            /* get the size of the compressed zlib chunk */\n            int size = get_bits(&gb, 16);\n\n            s->color_depth    = 0;\n            s->zlibprime_curr = 0;\n            s->zlibprime_prev = 0;\n            s->diff_start     = 0;\n            s->diff_height    = cur_blk_height;\n\n            if (8 * size > get_bits_left(&gb)) {\n                av_frame_unref(&s->frame);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ver == 2 && size) {\n                skip_bits(&gb, 3);\n                s->color_depth    = get_bits(&gb, 2);\n                has_diff          = get_bits1(&gb);\n                s->zlibprime_curr = get_bits1(&gb);\n                s->zlibprime_prev = get_bits1(&gb);\n\n                if (s->color_depth != 0 && s->color_depth != 2) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"%dx%d invalid color depth %d\\n\", i, j, s->color_depth);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                if (has_diff) {\n                    if (!s->keyframe) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"inter frame without keyframe\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    s->diff_start  = get_bits(&gb, 8);\n                    s->diff_height = get_bits(&gb, 8);\n                    av_log(avctx, AV_LOG_DEBUG,\n                           \"%dx%d diff start %d height %d\\n\",\n                           i, j, s->diff_start, s->diff_height);\n                    size -= 2;\n                }\n\n                if (s->zlibprime_prev)\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_prev\\n\", i, j);\n\n                if (s->zlibprime_curr) {\n                    int col = get_bits(&gb, 8);\n                    int row = get_bits(&gb, 8);\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_curr %dx%d\\n\", i, j, col, row);\n                    size -= 2;\n                    avpriv_request_sample(avctx, \"zlibprime_curr\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                if (!s->blocks && (s->zlibprime_curr || s->zlibprime_prev)) {\n                    av_log(avctx, AV_LOG_ERROR, \"no data available for zlib \"\n                           \"priming\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                size--; // account for flags byte\n            }\n\n            if (has_diff) {\n                int k;\n                int off = (s->image_height - y_pos - 1) * s->frame.linesize[0];\n\n                for (k = 0; k < cur_blk_height; k++)\n                    memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,\n                           s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,\n                           cur_blk_width * 3);\n            }\n\n            /* skip unchanged blocks, which have size 0 */\n            if (size) {\n                if (flashsv_decode_block(avctx, avpkt, &gb, size,\n                                         cur_blk_width, cur_blk_height,\n                                         x_pos, y_pos,\n                                         i + j * (h_blocks + !!h_part)))\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"error in decompression of block %dx%d\\n\", i, j);\n            }\n        }\n    }\n    if (s->is_keyframe && s->ver == 2) {\n        if (!s->keyframe) {\n            s->keyframe = av_malloc(s->frame.linesize[0] * avctx->height);\n            if (!s->keyframe) {\n                av_log(avctx, AV_LOG_ERROR, \"Cannot allocate image data\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n        memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);\n    }\n\n    if ((ret = av_frame_ref(data, &s->frame)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    if ((get_bits_count(&gb) / 8) != buf_size)\n        av_log(avctx, AV_LOG_ERROR, \"buffer not fully consumed (%d != %d)\\n\",\n               buf_size, (get_bits_count(&gb) / 8));\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}\n\n\nstatic av_cold int flashsv_decode_end(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n    inflateEnd(&s->zstream);\n    /* release the frame if needed */\n    av_frame_unref(&s->frame);\n\n    /* free the tmpblock */\n    av_free(s->tmpblock);\n\n    return 0;\n}\n\n\n#if CONFIG_FLASHSV_DECODER\nAVCodec ff_flashsv_decoder = {\n    .name           = \"flashsv\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_FLASHSV,\n    .priv_data_size = sizeof(FlashSVContext),\n    .init           = flashsv_decode_init,\n    .close          = flashsv_decode_end,\n    .decode         = flashsv_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Flash Screen Video v1\"),\n};\n#endif /* CONFIG_FLASHSV_DECODER */\n\n#if CONFIG_FLASHSV2_DECODER\nstatic const uint32_t ff_flashsv2_default_palette[128] = {\n    0x000000, 0x333333, 0x666666, 0x999999, 0xCCCCCC, 0xFFFFFF,\n    0x330000, 0x660000, 0x990000, 0xCC0000, 0xFF0000, 0x003300,\n    0x006600, 0x009900, 0x00CC00, 0x00FF00, 0x000033, 0x000066,\n    0x000099, 0x0000CC, 0x0000FF, 0x333300, 0x666600, 0x999900,\n    0xCCCC00, 0xFFFF00, 0x003333, 0x006666, 0x009999, 0x00CCCC,\n    0x00FFFF, 0x330033, 0x660066, 0x990099, 0xCC00CC, 0xFF00FF,\n    0xFFFF33, 0xFFFF66, 0xFFFF99, 0xFFFFCC, 0xFF33FF, 0xFF66FF,\n    0xFF99FF, 0xFFCCFF, 0x33FFFF, 0x66FFFF, 0x99FFFF, 0xCCFFFF,\n    0xCCCC33, 0xCCCC66, 0xCCCC99, 0xCCCCFF, 0xCC33CC, 0xCC66CC,\n    0xCC99CC, 0xCCFFCC, 0x33CCCC, 0x66CCCC, 0x99CCCC, 0xFFCCCC,\n    0x999933, 0x999966, 0x9999CC, 0x9999FF, 0x993399, 0x996699,\n    0x99CC99, 0x99FF99, 0x339999, 0x669999, 0xCC9999, 0xFF9999,\n    0x666633, 0x666699, 0x6666CC, 0x6666FF, 0x663366, 0x669966,\n    0x66CC66, 0x66FF66, 0x336666, 0x996666, 0xCC6666, 0xFF6666,\n    0x333366, 0x333399, 0x3333CC, 0x3333FF, 0x336633, 0x339933,\n    0x33CC33, 0x33FF33, 0x663333, 0x993333, 0xCC3333, 0xFF3333,\n    0x003366, 0x336600, 0x660033, 0x006633, 0x330066, 0x663300,\n    0x336699, 0x669933, 0x993366, 0x339966, 0x663399, 0x996633,\n    0x6699CC, 0x99CC66, 0xCC6699, 0x66CC99, 0x9966CC, 0xCC9966,\n    0x99CCFF, 0xCCFF99, 0xFF99CC, 0x99FFCC, 0xCC99FF, 0xFFCC99,\n    0x111111, 0x222222, 0x444444, 0x555555, 0xAAAAAA, 0xBBBBBB,\n    0xDDDDDD, 0xEEEEEE\n};\n\nstatic av_cold int flashsv2_decode_init(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n    flashsv_decode_init(avctx);\n    s->pal = ff_flashsv2_default_palette;\n    s->ver = 2;\n\n    return 0;\n}\n\nstatic av_cold int flashsv2_decode_end(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n\n    av_freep(&s->keyframedata);\n    av_freep(&s->blocks);\n    av_freep(&s->keyframe);\n    av_freep(&s->deflate_block);\n    flashsv_decode_end(avctx);\n\n    return 0;\n}\n\nAVCodec ff_flashsv2_decoder = {\n    .name           = \"flashsv2\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_FLASHSV2,\n    .priv_data_size = sizeof(FlashSVContext),\n    .init           = flashsv2_decode_init,\n    .close          = flashsv2_decode_end,\n    .decode         = flashsv_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Flash Screen Video v2\"),\n};\n#endif /* CONFIG_FLASHSV2_DECODER */\n"], "fixing_code": ["/*\n * Flash Screen Video decoder\n * Copyright (C) 2004 Alex Beregszaszi\n * Copyright (C) 2006 Benjamin Larsson\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Flash Screen Video decoder\n * @author Alex Beregszaszi\n * @author Benjamin Larsson\n * @author Daniel Verkamp\n * @author Konstantin Shishkov\n *\n * A description of the bitstream format for Flash Screen Video version 1/2\n * is part of the SWF File Format Specification (version 10), which can be\n * downloaded from http://www.adobe.com/devnet/swf.html.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <zlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n\ntypedef struct BlockInfo {\n    uint8_t *pos;\n    int      size;\n} BlockInfo;\n\ntypedef struct FlashSVContext {\n    AVCodecContext *avctx;\n    AVFrame         frame;\n    int             image_width, image_height;\n    int             block_width, block_height;\n    uint8_t        *tmpblock;\n    int             block_size;\n    z_stream        zstream;\n    int             ver;\n    const uint32_t *pal;\n    int             is_keyframe;\n    uint8_t        *keyframedata;\n    uint8_t        *keyframe;\n    BlockInfo      *blocks;\n    uint8_t        *deflate_block;\n    int             deflate_block_size;\n    int             color_depth;\n    int             zlibprime_curr, zlibprime_prev;\n    int             diff_start, diff_height;\n} FlashSVContext;\n\n\nstatic int decode_hybrid(const uint8_t *sptr, uint8_t *dptr, int dx, int dy,\n                         int h, int w, int stride, const uint32_t *pal)\n{\n    int x, y;\n    const uint8_t *orig_src = sptr;\n\n    for (y = dx+h; y > dx; y--) {\n        uint8_t *dst = dptr + (y * stride) + dy * 3;\n        for (x = 0; x < w; x++) {\n            if (*sptr & 0x80) {\n                /* 15-bit color */\n                unsigned c = AV_RB16(sptr) & ~0x8000;\n                unsigned b =  c        & 0x1F;\n                unsigned g = (c >>  5) & 0x1F;\n                unsigned r =  c >> 10;\n                /* 000aaabb -> aaabbaaa  */\n                *dst++ = (b << 3) | (b >> 2);\n                *dst++ = (g << 3) | (g >> 2);\n                *dst++ = (r << 3) | (r >> 2);\n                sptr += 2;\n            } else {\n                /* palette index */\n                uint32_t c = pal[*sptr++];\n                bytestream_put_le24(&dst, c);\n            }\n        }\n    }\n    return sptr - orig_src;\n}\n\nstatic av_cold int flashsv_decode_init(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n    int zret; // Zlib return code\n\n    s->avctx          = avctx;\n    s->zstream.zalloc = Z_NULL;\n    s->zstream.zfree  = Z_NULL;\n    s->zstream.opaque = Z_NULL;\n    zret = inflateInit(&s->zstream);\n    if (zret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret);\n        return 1;\n    }\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    avcodec_get_frame_defaults(&s->frame);\n\n    return 0;\n}\n\n\nstatic int flashsv2_prime(FlashSVContext *s, uint8_t *src, int size)\n{\n    z_stream zs;\n    int zret; // Zlib return code\n\n    if (!src)\n        return AVERROR_INVALIDDATA;\n\n    zs.zalloc = NULL;\n    zs.zfree  = NULL;\n    zs.opaque = NULL;\n\n    s->zstream.next_in   = src;\n    s->zstream.avail_in  = size;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    inflate(&s->zstream, Z_SYNC_FLUSH);\n\n    if (deflateInit(&zs, 0) != Z_OK)\n        return -1;\n    zs.next_in   = s->tmpblock;\n    zs.avail_in  = s->block_size * 3 - s->zstream.avail_out;\n    zs.next_out  = s->deflate_block;\n    zs.avail_out = s->deflate_block_size;\n    deflate(&zs, Z_SYNC_FLUSH);\n    deflateEnd(&zs);\n\n    if ((zret = inflateReset(&s->zstream)) != Z_OK) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", zret);\n        return AVERROR_UNKNOWN;\n    }\n\n    s->zstream.next_in   = s->deflate_block;\n    s->zstream.avail_in  = s->deflate_block_size - zs.avail_out;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    inflate(&s->zstream, Z_SYNC_FLUSH);\n\n    return 0;\n}\n\nstatic int flashsv_decode_block(AVCodecContext *avctx, AVPacket *avpkt,\n                                GetBitContext *gb, int block_size,\n                                int width, int height, int x_pos, int y_pos,\n                                int blk_idx)\n{\n    struct FlashSVContext *s = avctx->priv_data;\n    uint8_t *line = s->tmpblock;\n    int k;\n    int ret = inflateReset(&s->zstream);\n    if (ret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", ret);\n        return AVERROR_UNKNOWN;\n    }\n    if (s->zlibprime_curr || s->zlibprime_prev) {\n        ret = flashsv2_prime(s,\n                             s->blocks[blk_idx].pos,\n                             s->blocks[blk_idx].size);\n        if (ret < 0)\n            return ret;\n    }\n    s->zstream.next_in   = avpkt->data + get_bits_count(gb) / 8;\n    s->zstream.avail_in  = block_size;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    ret = inflate(&s->zstream, Z_FINISH);\n    if (ret == Z_DATA_ERROR) {\n        av_log(avctx, AV_LOG_ERROR, \"Zlib resync occurred\\n\");\n        inflateSync(&s->zstream);\n        ret = inflate(&s->zstream, Z_FINISH);\n    }\n\n    if (ret != Z_OK && ret != Z_STREAM_END) {\n        //return -1;\n    }\n\n    if (s->is_keyframe) {\n        s->blocks[blk_idx].pos      = s->keyframedata + (get_bits_count(gb) / 8);\n        s->blocks[blk_idx].size     = block_size;\n    }\n    if (!s->color_depth) {\n        /* Flash Screen Video stores the image upside down, so copy\n         * lines to destination in reverse order. */\n        for (k = 1; k <= s->diff_height; k++) {\n            memcpy(s->frame.data[0] + x_pos * 3 +\n                   (s->image_height - y_pos - s->diff_start - k) * s->frame.linesize[0],\n                   line, width * 3);\n            /* advance source pointer to next line */\n            line += width * 3;\n        }\n    } else {\n        /* hybrid 15-bit/palette mode */\n        decode_hybrid(s->tmpblock, s->frame.data[0],\n                      s->image_height - (y_pos + 1 + s->diff_start + s->diff_height),\n                      x_pos, s->diff_height, width,\n                      s->frame.linesize[0], s->pal);\n    }\n    skip_bits_long(gb, 8 * block_size); /* skip the consumed bits */\n    return 0;\n}\n\nstatic int calc_deflate_block_size(int tmpblock_size)\n{\n    z_stream zstream;\n    int size;\n\n    zstream.zalloc = Z_NULL;\n    zstream.zfree  = Z_NULL;\n    zstream.opaque = Z_NULL;\n    if (deflateInit(&zstream, 0) != Z_OK)\n        return -1;\n    size = deflateBound(&zstream, tmpblock_size);\n    deflateEnd(&zstream);\n\n    return size;\n}\n\nstatic int flashsv_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame, AVPacket *avpkt)\n{\n    int buf_size       = avpkt->size;\n    FlashSVContext *s  = avctx->priv_data;\n    int h_blocks, v_blocks, h_part, v_part, i, j, ret;\n    GetBitContext gb;\n    int last_blockwidth = s->block_width;\n    int last_blockheight= s->block_height;\n\n    /* no supplementary picture */\n    if (buf_size == 0)\n        return 0;\n    if (buf_size < 4)\n        return -1;\n\n    init_get_bits(&gb, avpkt->data, buf_size * 8);\n\n    /* start to parse the bitstream */\n    s->block_width  = 16 * (get_bits(&gb,  4) + 1);\n    s->image_width  =       get_bits(&gb, 12);\n    s->block_height = 16 * (get_bits(&gb,  4) + 1);\n    s->image_height =       get_bits(&gb, 12);\n\n    if (   last_blockwidth != s->block_width\n        || last_blockheight!= s->block_height)\n        av_freep(&s->blocks);\n\n    if (s->ver == 2) {\n        skip_bits(&gb, 6);\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"iframe\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"Custom palette\");\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n\n    /* calculate number of blocks and size of border (partial) blocks */\n    h_blocks = s->image_width  / s->block_width;\n    h_part   = s->image_width  % s->block_width;\n    v_blocks = s->image_height / s->block_height;\n    v_part   = s->image_height % s->block_height;\n\n    /* the block size could change between frames, make sure the buffer\n     * is large enough, if not, get a larger one */\n    if (s->block_size < s->block_width * s->block_height) {\n        int tmpblock_size = 3 * s->block_width * s->block_height;\n\n        s->tmpblock = av_realloc(s->tmpblock, tmpblock_size);\n        if (!s->tmpblock) {\n            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");\n            return AVERROR(ENOMEM);\n        }\n        if (s->ver == 2) {\n            s->deflate_block_size = calc_deflate_block_size(tmpblock_size);\n            if (s->deflate_block_size <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't determine deflate buffer size.\\n\");\n                return -1;\n            }\n            s->deflate_block = av_realloc(s->deflate_block, s->deflate_block_size);\n            if (!s->deflate_block) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't allocate deflate buffer.\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n    }\n    s->block_size = s->block_width * s->block_height;\n\n    /* initialize the image size once */\n    if (avctx->width == 0 && avctx->height == 0) {\n        avcodec_set_dimensions(avctx, s->image_width, s->image_height);\n    }\n\n    /* check for changes of image width and image height */\n    if (avctx->width != s->image_width || avctx->height != s->image_height) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame width or height differs from first frame!\\n\");\n        av_log(avctx, AV_LOG_ERROR, \"fh = %d, fv %d  vs  ch = %d, cv = %d\\n\",\n               avctx->height, avctx->width, s->image_height, s->image_width);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* we care for keyframes only in Screen Video v2 */\n    s->is_keyframe = (avpkt->flags & AV_PKT_FLAG_KEY) && (s->ver == 2);\n    if (s->is_keyframe) {\n        s->keyframedata = av_realloc(s->keyframedata, avpkt->size);\n        memcpy(s->keyframedata, avpkt->data, avpkt->size);\n    }\n    if(s->ver == 2 && !s->blocks)\n        s->blocks = av_mallocz((v_blocks + !!v_part) * (h_blocks + !!h_part)\n                                * sizeof(s->blocks[0]));\n\n    av_dlog(avctx, \"image: %dx%d block: %dx%d num: %dx%d part: %dx%d\\n\",\n            s->image_width, s->image_height, s->block_width, s->block_height,\n            h_blocks, v_blocks, h_part, v_part);\n\n    if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)\n        return ret;\n\n    /* loop over all block columns */\n    for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {\n\n        int y_pos  = j * s->block_height; // vertical position in frame\n        int cur_blk_height = (j < v_blocks) ? s->block_height : v_part;\n\n        /* loop over all block rows */\n        for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {\n            int x_pos = i * s->block_width; // horizontal position in frame\n            int cur_blk_width = (i < h_blocks) ? s->block_width : h_part;\n            int has_diff = 0;\n\n            /* get the size of the compressed zlib chunk */\n            int size = get_bits(&gb, 16);\n\n            s->color_depth    = 0;\n            s->zlibprime_curr = 0;\n            s->zlibprime_prev = 0;\n            s->diff_start     = 0;\n            s->diff_height    = cur_blk_height;\n\n            if (8 * size > get_bits_left(&gb)) {\n                av_frame_unref(&s->frame);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ver == 2 && size) {\n                skip_bits(&gb, 3);\n                s->color_depth    = get_bits(&gb, 2);\n                has_diff          = get_bits1(&gb);\n                s->zlibprime_curr = get_bits1(&gb);\n                s->zlibprime_prev = get_bits1(&gb);\n\n                if (s->color_depth != 0 && s->color_depth != 2) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"%dx%d invalid color depth %d\\n\", i, j, s->color_depth);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                if (has_diff) {\n                    if (!s->keyframe) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"inter frame without keyframe\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    s->diff_start  = get_bits(&gb, 8);\n                    s->diff_height = get_bits(&gb, 8);\n                    if (s->diff_start + s->diff_height > cur_blk_height) {\n                        av_log(avctx, AV_LOG_ERROR, \"Block parameters invalid\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    av_log(avctx, AV_LOG_DEBUG,\n                           \"%dx%d diff start %d height %d\\n\",\n                           i, j, s->diff_start, s->diff_height);\n                    size -= 2;\n                }\n\n                if (s->zlibprime_prev)\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_prev\\n\", i, j);\n\n                if (s->zlibprime_curr) {\n                    int col = get_bits(&gb, 8);\n                    int row = get_bits(&gb, 8);\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_curr %dx%d\\n\", i, j, col, row);\n                    size -= 2;\n                    avpriv_request_sample(avctx, \"zlibprime_curr\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                if (!s->blocks && (s->zlibprime_curr || s->zlibprime_prev)) {\n                    av_log(avctx, AV_LOG_ERROR, \"no data available for zlib \"\n                           \"priming\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                size--; // account for flags byte\n            }\n\n            if (has_diff) {\n                int k;\n                int off = (s->image_height - y_pos - 1) * s->frame.linesize[0];\n\n                for (k = 0; k < cur_blk_height; k++)\n                    memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,\n                           s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,\n                           cur_blk_width * 3);\n            }\n\n            /* skip unchanged blocks, which have size 0 */\n            if (size) {\n                if (flashsv_decode_block(avctx, avpkt, &gb, size,\n                                         cur_blk_width, cur_blk_height,\n                                         x_pos, y_pos,\n                                         i + j * (h_blocks + !!h_part)))\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"error in decompression of block %dx%d\\n\", i, j);\n            }\n        }\n    }\n    if (s->is_keyframe && s->ver == 2) {\n        if (!s->keyframe) {\n            s->keyframe = av_malloc(s->frame.linesize[0] * avctx->height);\n            if (!s->keyframe) {\n                av_log(avctx, AV_LOG_ERROR, \"Cannot allocate image data\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n        memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);\n    }\n\n    if ((ret = av_frame_ref(data, &s->frame)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    if ((get_bits_count(&gb) / 8) != buf_size)\n        av_log(avctx, AV_LOG_ERROR, \"buffer not fully consumed (%d != %d)\\n\",\n               buf_size, (get_bits_count(&gb) / 8));\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}\n\n\nstatic av_cold int flashsv_decode_end(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n    inflateEnd(&s->zstream);\n    /* release the frame if needed */\n    av_frame_unref(&s->frame);\n\n    /* free the tmpblock */\n    av_free(s->tmpblock);\n\n    return 0;\n}\n\n\n#if CONFIG_FLASHSV_DECODER\nAVCodec ff_flashsv_decoder = {\n    .name           = \"flashsv\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_FLASHSV,\n    .priv_data_size = sizeof(FlashSVContext),\n    .init           = flashsv_decode_init,\n    .close          = flashsv_decode_end,\n    .decode         = flashsv_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Flash Screen Video v1\"),\n};\n#endif /* CONFIG_FLASHSV_DECODER */\n\n#if CONFIG_FLASHSV2_DECODER\nstatic const uint32_t ff_flashsv2_default_palette[128] = {\n    0x000000, 0x333333, 0x666666, 0x999999, 0xCCCCCC, 0xFFFFFF,\n    0x330000, 0x660000, 0x990000, 0xCC0000, 0xFF0000, 0x003300,\n    0x006600, 0x009900, 0x00CC00, 0x00FF00, 0x000033, 0x000066,\n    0x000099, 0x0000CC, 0x0000FF, 0x333300, 0x666600, 0x999900,\n    0xCCCC00, 0xFFFF00, 0x003333, 0x006666, 0x009999, 0x00CCCC,\n    0x00FFFF, 0x330033, 0x660066, 0x990099, 0xCC00CC, 0xFF00FF,\n    0xFFFF33, 0xFFFF66, 0xFFFF99, 0xFFFFCC, 0xFF33FF, 0xFF66FF,\n    0xFF99FF, 0xFFCCFF, 0x33FFFF, 0x66FFFF, 0x99FFFF, 0xCCFFFF,\n    0xCCCC33, 0xCCCC66, 0xCCCC99, 0xCCCCFF, 0xCC33CC, 0xCC66CC,\n    0xCC99CC, 0xCCFFCC, 0x33CCCC, 0x66CCCC, 0x99CCCC, 0xFFCCCC,\n    0x999933, 0x999966, 0x9999CC, 0x9999FF, 0x993399, 0x996699,\n    0x99CC99, 0x99FF99, 0x339999, 0x669999, 0xCC9999, 0xFF9999,\n    0x666633, 0x666699, 0x6666CC, 0x6666FF, 0x663366, 0x669966,\n    0x66CC66, 0x66FF66, 0x336666, 0x996666, 0xCC6666, 0xFF6666,\n    0x333366, 0x333399, 0x3333CC, 0x3333FF, 0x336633, 0x339933,\n    0x33CC33, 0x33FF33, 0x663333, 0x993333, 0xCC3333, 0xFF3333,\n    0x003366, 0x336600, 0x660033, 0x006633, 0x330066, 0x663300,\n    0x336699, 0x669933, 0x993366, 0x339966, 0x663399, 0x996633,\n    0x6699CC, 0x99CC66, 0xCC6699, 0x66CC99, 0x9966CC, 0xCC9966,\n    0x99CCFF, 0xCCFF99, 0xFF99CC, 0x99FFCC, 0xCC99FF, 0xFFCC99,\n    0x111111, 0x222222, 0x444444, 0x555555, 0xAAAAAA, 0xBBBBBB,\n    0xDDDDDD, 0xEEEEEE\n};\n\nstatic av_cold int flashsv2_decode_init(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n    flashsv_decode_init(avctx);\n    s->pal = ff_flashsv2_default_palette;\n    s->ver = 2;\n\n    return 0;\n}\n\nstatic av_cold int flashsv2_decode_end(AVCodecContext *avctx)\n{\n    FlashSVContext *s = avctx->priv_data;\n\n    av_freep(&s->keyframedata);\n    av_freep(&s->blocks);\n    av_freep(&s->keyframe);\n    av_freep(&s->deflate_block);\n    flashsv_decode_end(avctx);\n\n    return 0;\n}\n\nAVCodec ff_flashsv2_decoder = {\n    .name           = \"flashsv2\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_FLASHSV2,\n    .priv_data_size = sizeof(FlashSVContext),\n    .init           = flashsv2_decode_init,\n    .close          = flashsv2_decode_end,\n    .decode         = flashsv_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Flash Screen Video v2\"),\n};\n#endif /* CONFIG_FLASHSV2_DECODER */\n"], "buggy_code_start_loc": [389], "buggy_code_end_loc": [389], "fixing_code_start_loc": [390], "fixing_code_end_loc": [394], "type": "CWE-20", "message": "The flashsv_decode_frame function in libavcodec/flashsv.c in FFmpeg before 2.1 does not properly validate a certain height value, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Flash Screen Video data.", "other": {"cve": {"id": "CVE-2013-7015", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:49.097", "lastModified": "2016-12-03T03:00:40.470", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The flashsv_decode_frame function in libavcodec/flashsv.c in FFmpeg before 2.1 does not properly validate a certain height value, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Flash Screen Video data."}, {"lang": "es", "value": "La funci\u00f3n  flashsv_decode_frame en libavcodec/flashsv.c en FFmpeg anterior a v2.1 no valida correctamente ciertos valores de altura, lo que permite a atacantes remotods provocar una denegaci\u00f3n de servicio (acceso a array fuera de rango) o posiblemente tener otro impacto no especificado a trav\u00e9s de informaci\u00f3n de Flash Screen Video."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2014/dsa-2855", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/880c73cd76109697447fbfbaa8e5ee5683309446", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}, {"url": "https://trac.ffmpeg.org/ticket/2844", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/880c73cd76109697447fbfbaa8e5ee5683309446"}}