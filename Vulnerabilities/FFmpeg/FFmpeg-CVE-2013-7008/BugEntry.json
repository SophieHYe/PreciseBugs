{"buggy_code": ["/*\n * H.26L/H.264/AVC/JVT/14496-10/... decoder\n * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * H.264 / AVC / MPEG4 part10 codec.\n * @author Michael Niedermayer <michaelni@gmx.at>\n */\n\n#define UNCHECKED_BITSTREAM_READER 1\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/opt.h\"\n#include \"internal.h\"\n#include \"cabac.h\"\n#include \"cabac_functions.h\"\n#include \"dsputil.h\"\n#include \"error_resilience.h\"\n#include \"avcodec.h\"\n#include \"mpegvideo.h\"\n#include \"h264.h\"\n#include \"h264data.h\"\n#include \"h264chroma.h\"\n#include \"h264_mvpred.h\"\n#include \"golomb.h\"\n#include \"mathops.h\"\n#include \"rectangle.h\"\n#include \"svq3.h\"\n#include \"thread.h\"\n#include \"vdpau_internal.h\"\n\n#include <assert.h>\n\nstatic void flush_change(H264Context *h);\n\nconst uint16_t ff_h264_mb_sizes[4] = { 256, 384, 512, 768 };\n\nstatic const uint8_t rem6[QP_MAX_NUM + 1] = {\n    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,\n    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,\n    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,\n    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,\n    0, 1, 2, 3,\n};\n\nstatic const uint8_t div6[QP_MAX_NUM + 1] = {\n    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,\n    3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,\n    7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,\n   10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13,\n   14,14,14,14,\n};\n\nstatic const uint8_t field_scan[16+1] = {\n    0 + 0 * 4, 0 + 1 * 4, 1 + 0 * 4, 0 + 2 * 4,\n    0 + 3 * 4, 1 + 1 * 4, 1 + 2 * 4, 1 + 3 * 4,\n    2 + 0 * 4, 2 + 1 * 4, 2 + 2 * 4, 2 + 3 * 4,\n    3 + 0 * 4, 3 + 1 * 4, 3 + 2 * 4, 3 + 3 * 4,\n};\n\nstatic const uint8_t field_scan8x8[64+1] = {\n    0 + 0 * 8, 0 + 1 * 8, 0 + 2 * 8, 1 + 0 * 8,\n    1 + 1 * 8, 0 + 3 * 8, 0 + 4 * 8, 1 + 2 * 8,\n    2 + 0 * 8, 1 + 3 * 8, 0 + 5 * 8, 0 + 6 * 8,\n    0 + 7 * 8, 1 + 4 * 8, 2 + 1 * 8, 3 + 0 * 8,\n    2 + 2 * 8, 1 + 5 * 8, 1 + 6 * 8, 1 + 7 * 8,\n    2 + 3 * 8, 3 + 1 * 8, 4 + 0 * 8, 3 + 2 * 8,\n    2 + 4 * 8, 2 + 5 * 8, 2 + 6 * 8, 2 + 7 * 8,\n    3 + 3 * 8, 4 + 1 * 8, 5 + 0 * 8, 4 + 2 * 8,\n    3 + 4 * 8, 3 + 5 * 8, 3 + 6 * 8, 3 + 7 * 8,\n    4 + 3 * 8, 5 + 1 * 8, 6 + 0 * 8, 5 + 2 * 8,\n    4 + 4 * 8, 4 + 5 * 8, 4 + 6 * 8, 4 + 7 * 8,\n    5 + 3 * 8, 6 + 1 * 8, 6 + 2 * 8, 5 + 4 * 8,\n    5 + 5 * 8, 5 + 6 * 8, 5 + 7 * 8, 6 + 3 * 8,\n    7 + 0 * 8, 7 + 1 * 8, 6 + 4 * 8, 6 + 5 * 8,\n    6 + 6 * 8, 6 + 7 * 8, 7 + 2 * 8, 7 + 3 * 8,\n    7 + 4 * 8, 7 + 5 * 8, 7 + 6 * 8, 7 + 7 * 8,\n};\n\nstatic const uint8_t field_scan8x8_cavlc[64+1] = {\n    0 + 0 * 8, 1 + 1 * 8, 2 + 0 * 8, 0 + 7 * 8,\n    2 + 2 * 8, 2 + 3 * 8, 2 + 4 * 8, 3 + 3 * 8,\n    3 + 4 * 8, 4 + 3 * 8, 4 + 4 * 8, 5 + 3 * 8,\n    5 + 5 * 8, 7 + 0 * 8, 6 + 6 * 8, 7 + 4 * 8,\n    0 + 1 * 8, 0 + 3 * 8, 1 + 3 * 8, 1 + 4 * 8,\n    1 + 5 * 8, 3 + 1 * 8, 2 + 5 * 8, 4 + 1 * 8,\n    3 + 5 * 8, 5 + 1 * 8, 4 + 5 * 8, 6 + 1 * 8,\n    5 + 6 * 8, 7 + 1 * 8, 6 + 7 * 8, 7 + 5 * 8,\n    0 + 2 * 8, 0 + 4 * 8, 0 + 5 * 8, 2 + 1 * 8,\n    1 + 6 * 8, 4 + 0 * 8, 2 + 6 * 8, 5 + 0 * 8,\n    3 + 6 * 8, 6 + 0 * 8, 4 + 6 * 8, 6 + 2 * 8,\n    5 + 7 * 8, 6 + 4 * 8, 7 + 2 * 8, 7 + 6 * 8,\n    1 + 0 * 8, 1 + 2 * 8, 0 + 6 * 8, 3 + 0 * 8,\n    1 + 7 * 8, 3 + 2 * 8, 2 + 7 * 8, 4 + 2 * 8,\n    3 + 7 * 8, 5 + 2 * 8, 4 + 7 * 8, 5 + 4 * 8,\n    6 + 3 * 8, 6 + 5 * 8, 7 + 3 * 8, 7 + 7 * 8,\n};\n\n// zigzag_scan8x8_cavlc[i] = zigzag_scan8x8[(i/4) + 16*(i%4)]\nstatic const uint8_t zigzag_scan8x8_cavlc[64+1] = {\n    0 + 0 * 8, 1 + 1 * 8, 1 + 2 * 8, 2 + 2 * 8,\n    4 + 1 * 8, 0 + 5 * 8, 3 + 3 * 8, 7 + 0 * 8,\n    3 + 4 * 8, 1 + 7 * 8, 5 + 3 * 8, 6 + 3 * 8,\n    2 + 7 * 8, 6 + 4 * 8, 5 + 6 * 8, 7 + 5 * 8,\n    1 + 0 * 8, 2 + 0 * 8, 0 + 3 * 8, 3 + 1 * 8,\n    3 + 2 * 8, 0 + 6 * 8, 4 + 2 * 8, 6 + 1 * 8,\n    2 + 5 * 8, 2 + 6 * 8, 6 + 2 * 8, 5 + 4 * 8,\n    3 + 7 * 8, 7 + 3 * 8, 4 + 7 * 8, 7 + 6 * 8,\n    0 + 1 * 8, 3 + 0 * 8, 0 + 4 * 8, 4 + 0 * 8,\n    2 + 3 * 8, 1 + 5 * 8, 5 + 1 * 8, 5 + 2 * 8,\n    1 + 6 * 8, 3 + 5 * 8, 7 + 1 * 8, 4 + 5 * 8,\n    4 + 6 * 8, 7 + 4 * 8, 5 + 7 * 8, 6 + 7 * 8,\n    0 + 2 * 8, 2 + 1 * 8, 1 + 3 * 8, 5 + 0 * 8,\n    1 + 4 * 8, 2 + 4 * 8, 6 + 0 * 8, 4 + 3 * 8,\n    0 + 7 * 8, 4 + 4 * 8, 7 + 2 * 8, 3 + 6 * 8,\n    5 + 5 * 8, 6 + 5 * 8, 6 + 6 * 8, 7 + 7 * 8,\n};\n\nstatic const uint8_t dequant4_coeff_init[6][3] = {\n    { 10, 13, 16 },\n    { 11, 14, 18 },\n    { 13, 16, 20 },\n    { 14, 18, 23 },\n    { 16, 20, 25 },\n    { 18, 23, 29 },\n};\n\nstatic const uint8_t dequant8_coeff_init_scan[16] = {\n    0, 3, 4, 3, 3, 1, 5, 1, 4, 5, 2, 5, 3, 1, 5, 1\n};\n\nstatic const uint8_t dequant8_coeff_init[6][6] = {\n    { 20, 18, 32, 19, 25, 24 },\n    { 22, 19, 35, 21, 28, 26 },\n    { 26, 23, 42, 24, 33, 31 },\n    { 28, 25, 45, 26, 35, 33 },\n    { 32, 28, 51, 30, 40, 38 },\n    { 36, 32, 58, 34, 46, 43 },\n};\n\nstatic const enum AVPixelFormat h264_hwaccel_pixfmt_list_420[] = {\n#if CONFIG_H264_DXVA2_HWACCEL\n    AV_PIX_FMT_DXVA2_VLD,\n#endif\n#if CONFIG_H264_VAAPI_HWACCEL\n    AV_PIX_FMT_VAAPI_VLD,\n#endif\n#if CONFIG_H264_VDA_HWACCEL\n    AV_PIX_FMT_VDA_VLD,\n#endif\n#if CONFIG_H264_VDPAU_HWACCEL\n    AV_PIX_FMT_VDPAU,\n#endif\n    AV_PIX_FMT_YUV420P,\n    AV_PIX_FMT_NONE\n};\n\nstatic const enum AVPixelFormat h264_hwaccel_pixfmt_list_jpeg_420[] = {\n#if CONFIG_H264_DXVA2_HWACCEL\n    AV_PIX_FMT_DXVA2_VLD,\n#endif\n#if CONFIG_H264_VAAPI_HWACCEL\n    AV_PIX_FMT_VAAPI_VLD,\n#endif\n#if CONFIG_H264_VDA_HWACCEL\n    AV_PIX_FMT_VDA_VLD,\n#endif\n#if CONFIG_H264_VDPAU_HWACCEL\n    AV_PIX_FMT_VDPAU,\n#endif\n    AV_PIX_FMT_YUVJ420P,\n    AV_PIX_FMT_NONE\n};\n\nint avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    return h ? h->sps.num_reorder_frames : 0;\n}\n\nstatic void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,\n                              int (*mv)[2][4][2],\n                              int mb_x, int mb_y, int mb_intra, int mb_skipped)\n{\n    H264Context *h = opaque;\n\n    h->mb_x  = mb_x;\n    h->mb_y  = mb_y;\n    h->mb_xy = mb_x + mb_y * h->mb_stride;\n    memset(h->non_zero_count_cache, 0, sizeof(h->non_zero_count_cache));\n    av_assert1(ref >= 0);\n    /* FIXME: It is possible albeit uncommon that slice references\n     * differ between slices. We take the easy approach and ignore\n     * it for now. If this turns out to have any relevance in\n     * practice then correct remapping should be added. */\n    if (ref >= h->ref_count[0])\n        ref = 0;\n    if (!h->ref_list[0][ref].f.data[0]) {\n        av_log(h->avctx, AV_LOG_DEBUG, \"Reference not available for error concealing\\n\");\n        ref = 0;\n    }\n    if ((h->ref_list[0][ref].reference&3) != 3) {\n        av_log(h->avctx, AV_LOG_DEBUG, \"Reference invalid\\n\");\n        return;\n    }\n    fill_rectangle(&h->cur_pic.ref_index[0][4 * h->mb_xy],\n                   2, 2, 2, ref, 1);\n    fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1);\n    fill_rectangle(h->mv_cache[0][scan8[0]], 4, 4, 8,\n                   pack16to32((*mv)[0][0][0], (*mv)[0][0][1]), 4);\n    h->mb_mbaff =\n    h->mb_field_decoding_flag = 0;\n    ff_h264_hl_decode_mb(h);\n}\n\nvoid ff_h264_draw_horiz_band(H264Context *h, int y, int height)\n{\n    AVCodecContext *avctx = h->avctx;\n    Picture *cur  = &h->cur_pic;\n    Picture *last = h->ref_list[0][0].f.data[0] ? &h->ref_list[0][0] : NULL;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    int vshift = desc->log2_chroma_h;\n    const int field_pic = h->picture_structure != PICT_FRAME;\n    if (field_pic) {\n        height <<= 1;\n        y      <<= 1;\n    }\n\n    height = FFMIN(height, avctx->height - y);\n\n    if (field_pic && h->first_field && !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD))\n        return;\n\n    if (avctx->draw_horiz_band) {\n        AVFrame *src;\n        int offset[AV_NUM_DATA_POINTERS];\n        int i;\n\n        if (cur->f.pict_type == AV_PICTURE_TYPE_B || h->low_delay ||\n            (avctx->slice_flags & SLICE_FLAG_CODED_ORDER))\n            src = &cur->f;\n        else if (last)\n            src = &last->f;\n        else\n            return;\n\n        offset[0] = y * src->linesize[0];\n        offset[1] =\n        offset[2] = (y >> vshift) * src->linesize[1];\n        for (i = 3; i < AV_NUM_DATA_POINTERS; i++)\n            offset[i] = 0;\n\n        emms_c();\n\n        avctx->draw_horiz_band(avctx, src, offset,\n                               y, h->picture_structure, height);\n    }\n}\n\nstatic void unref_picture(H264Context *h, Picture *pic)\n{\n    int off = offsetof(Picture, tf) + sizeof(pic->tf);\n    int i;\n\n    if (!pic->f.data[0])\n        return;\n\n    ff_thread_release_buffer(h->avctx, &pic->tf);\n    av_buffer_unref(&pic->hwaccel_priv_buf);\n\n    av_buffer_unref(&pic->qscale_table_buf);\n    av_buffer_unref(&pic->mb_type_buf);\n    for (i = 0; i < 2; i++) {\n        av_buffer_unref(&pic->motion_val_buf[i]);\n        av_buffer_unref(&pic->ref_index_buf[i]);\n    }\n\n    memset((uint8_t*)pic + off, 0, sizeof(*pic) - off);\n}\n\nstatic void release_unused_pictures(H264Context *h, int remove_current)\n{\n    int i;\n\n    /* release non reference frames */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&\n            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {\n            unref_picture(h, &h->DPB[i]);\n        }\n    }\n}\n\nstatic int ref_picture(H264Context *h, Picture *dst, Picture *src)\n{\n    int ret, i;\n\n    av_assert0(!dst->f.buf[0]);\n    av_assert0(src->f.buf[0]);\n\n    src->tf.f = &src->f;\n    dst->tf.f = &dst->f;\n    ret = ff_thread_ref_frame(&dst->tf, &src->tf);\n    if (ret < 0)\n        goto fail;\n\n    dst->qscale_table_buf = av_buffer_ref(src->qscale_table_buf);\n    dst->mb_type_buf      = av_buffer_ref(src->mb_type_buf);\n    if (!dst->qscale_table_buf || !dst->mb_type_buf)\n        goto fail;\n    dst->qscale_table = src->qscale_table;\n    dst->mb_type      = src->mb_type;\n\n    for (i = 0; i < 2; i++) {\n        dst->motion_val_buf[i] = av_buffer_ref(src->motion_val_buf[i]);\n        dst->ref_index_buf[i]  = av_buffer_ref(src->ref_index_buf[i]);\n        if (!dst->motion_val_buf[i] || !dst->ref_index_buf[i])\n            goto fail;\n        dst->motion_val[i] = src->motion_val[i];\n        dst->ref_index[i]  = src->ref_index[i];\n    }\n\n    if (src->hwaccel_picture_private) {\n        dst->hwaccel_priv_buf = av_buffer_ref(src->hwaccel_priv_buf);\n        if (!dst->hwaccel_priv_buf)\n            goto fail;\n        dst->hwaccel_picture_private = dst->hwaccel_priv_buf->data;\n    }\n\n    for (i = 0; i < 2; i++)\n        dst->field_poc[i] = src->field_poc[i];\n\n    memcpy(dst->ref_poc,   src->ref_poc,   sizeof(src->ref_poc));\n    memcpy(dst->ref_count, src->ref_count, sizeof(src->ref_count));\n\n    dst->poc           = src->poc;\n    dst->frame_num     = src->frame_num;\n    dst->mmco_reset    = src->mmco_reset;\n    dst->pic_id        = src->pic_id;\n    dst->long_ref      = src->long_ref;\n    dst->mbaff         = src->mbaff;\n    dst->field_picture = src->field_picture;\n    dst->needs_realloc = src->needs_realloc;\n    dst->reference     = src->reference;\n    dst->sync          = src->sync;\n    dst->crop          = src->crop;\n    dst->crop_left     = src->crop_left;\n    dst->crop_top      = src->crop_top;\n\n    return 0;\nfail:\n    unref_picture(h, dst);\n    return ret;\n}\n\nstatic int alloc_scratch_buffers(H264Context *h, int linesize)\n{\n    int alloc_size = FFALIGN(FFABS(linesize) + 32, 32);\n\n    if (h->bipred_scratchpad)\n        return 0;\n\n    h->bipred_scratchpad = av_malloc(16 * 6 * alloc_size);\n    // edge emu needs blocksize + filter length - 1\n    // (= 21x21 for  h264)\n    h->edge_emu_buffer = av_mallocz(alloc_size * 2 * 21);\n    h->me.scratchpad   = av_mallocz(alloc_size * 2 * 16 * 2);\n\n    if (!h->bipred_scratchpad || !h->edge_emu_buffer || !h->me.scratchpad) {\n        av_freep(&h->bipred_scratchpad);\n        av_freep(&h->edge_emu_buffer);\n        av_freep(&h->me.scratchpad);\n        return AVERROR(ENOMEM);\n    }\n\n    h->me.temp = h->me.scratchpad;\n\n    return 0;\n}\n\nstatic int init_table_pools(H264Context *h)\n{\n    const int big_mb_num    = h->mb_stride * (h->mb_height + 1) + 1;\n    const int mb_array_size = h->mb_stride * h->mb_height;\n    const int b4_stride     = h->mb_width * 4 + 1;\n    const int b4_array_size = b4_stride * h->mb_height * 4;\n\n    h->qscale_table_pool = av_buffer_pool_init(big_mb_num + h->mb_stride,\n                                               av_buffer_allocz);\n    h->mb_type_pool      = av_buffer_pool_init((big_mb_num + h->mb_stride) *\n                                               sizeof(uint32_t), av_buffer_allocz);\n    h->motion_val_pool = av_buffer_pool_init(2 * (b4_array_size + 4) *\n                                             sizeof(int16_t), av_buffer_allocz);\n    h->ref_index_pool  = av_buffer_pool_init(4 * mb_array_size, av_buffer_allocz);\n\n    if (!h->qscale_table_pool || !h->mb_type_pool || !h->motion_val_pool ||\n        !h->ref_index_pool) {\n        av_buffer_pool_uninit(&h->qscale_table_pool);\n        av_buffer_pool_uninit(&h->mb_type_pool);\n        av_buffer_pool_uninit(&h->motion_val_pool);\n        av_buffer_pool_uninit(&h->ref_index_pool);\n        return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n\nstatic int alloc_picture(H264Context *h, Picture *pic)\n{\n    int i, ret = 0;\n\n    av_assert0(!pic->f.data[0]);\n\n    pic->tf.f = &pic->f;\n    ret = ff_thread_get_buffer(h->avctx, &pic->tf, pic->reference ?\n                                                   AV_GET_BUFFER_FLAG_REF : 0);\n    if (ret < 0)\n        goto fail;\n\n    h->linesize   = pic->f.linesize[0];\n    h->uvlinesize = pic->f.linesize[1];\n    pic->crop     = h->sps.crop;\n    pic->crop_top = h->sps.crop_top;\n    pic->crop_left= h->sps.crop_left;\n\n    if (h->avctx->hwaccel) {\n        const AVHWAccel *hwaccel = h->avctx->hwaccel;\n        av_assert0(!pic->hwaccel_picture_private);\n        if (hwaccel->priv_data_size) {\n            pic->hwaccel_priv_buf = av_buffer_allocz(hwaccel->priv_data_size);\n            if (!pic->hwaccel_priv_buf)\n                return AVERROR(ENOMEM);\n            pic->hwaccel_picture_private = pic->hwaccel_priv_buf->data;\n        }\n    }\n\n    if (!h->qscale_table_pool) {\n        ret = init_table_pools(h);\n        if (ret < 0)\n            goto fail;\n    }\n\n    pic->qscale_table_buf = av_buffer_pool_get(h->qscale_table_pool);\n    pic->mb_type_buf      = av_buffer_pool_get(h->mb_type_pool);\n    if (!pic->qscale_table_buf || !pic->mb_type_buf)\n        goto fail;\n\n    pic->mb_type      = (uint32_t*)pic->mb_type_buf->data + 2 * h->mb_stride + 1;\n    pic->qscale_table = pic->qscale_table_buf->data + 2 * h->mb_stride + 1;\n\n    for (i = 0; i < 2; i++) {\n        pic->motion_val_buf[i] = av_buffer_pool_get(h->motion_val_pool);\n        pic->ref_index_buf[i]  = av_buffer_pool_get(h->ref_index_pool);\n        if (!pic->motion_val_buf[i] || !pic->ref_index_buf[i])\n            goto fail;\n\n        pic->motion_val[i] = (int16_t (*)[2])pic->motion_val_buf[i]->data + 4;\n        pic->ref_index[i]  = pic->ref_index_buf[i]->data;\n    }\n\n    return 0;\nfail:\n    unref_picture(h, pic);\n    return (ret < 0) ? ret : AVERROR(ENOMEM);\n}\n\nstatic inline int pic_is_unused(H264Context *h, Picture *pic)\n{\n    if (pic->f.data[0] == NULL)\n        return 1;\n    if (pic->needs_realloc && !(pic->reference & DELAYED_PIC_REF))\n        return 1;\n    return 0;\n}\n\nstatic int find_unused_picture(H264Context *h)\n{\n    int i;\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (pic_is_unused(h, &h->DPB[i]))\n            break;\n    }\n    if (i == MAX_PICTURE_COUNT)\n        return AVERROR_INVALIDDATA;\n\n    if (h->DPB[i].needs_realloc) {\n        h->DPB[i].needs_realloc = 0;\n        unref_picture(h, &h->DPB[i]);\n    }\n\n    return i;\n}\n\n/**\n * Check if the top & left blocks are available if needed and\n * change the dc mode so it only uses the available blocks.\n */\nint ff_h264_check_intra4x4_pred_mode(H264Context *h)\n{\n    static const int8_t top[12] = {\n        -1, 0, LEFT_DC_PRED, -1, -1, -1, -1, -1, 0\n    };\n    static const int8_t left[12] = {\n        0, -1, TOP_DC_PRED, 0, -1, -1, -1, 0, -1, DC_128_PRED\n    };\n    int i;\n\n    if (!(h->top_samples_available & 0x8000)) {\n        for (i = 0; i < 4; i++) {\n            int status = top[h->intra4x4_pred_mode_cache[scan8[0] + i]];\n            if (status < 0) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"top block unavailable for requested intra4x4 mode %d at %d %d\\n\",\n                       status, h->mb_x, h->mb_y);\n                return AVERROR_INVALIDDATA;\n            } else if (status) {\n                h->intra4x4_pred_mode_cache[scan8[0] + i] = status;\n            }\n        }\n    }\n\n    if ((h->left_samples_available & 0x8888) != 0x8888) {\n        static const int mask[4] = { 0x8000, 0x2000, 0x80, 0x20 };\n        for (i = 0; i < 4; i++)\n            if (!(h->left_samples_available & mask[i])) {\n                int status = left[h->intra4x4_pred_mode_cache[scan8[0] + 8 * i]];\n                if (status < 0) {\n                    av_log(h->avctx, AV_LOG_ERROR,\n                           \"left block unavailable for requested intra4x4 mode %d at %d %d\\n\",\n                           status, h->mb_x, h->mb_y);\n                    return AVERROR_INVALIDDATA;\n                } else if (status) {\n                    h->intra4x4_pred_mode_cache[scan8[0] + 8 * i] = status;\n                }\n            }\n    }\n\n    return 0;\n} // FIXME cleanup like ff_h264_check_intra_pred_mode\n\n/**\n * Check if the top & left blocks are available if needed and\n * change the dc mode so it only uses the available blocks.\n */\nint ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n{\n    static const int8_t top[4]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n    static const int8_t left[5] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n    if (mode > 3U) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"out of range intra chroma pred mode at %d %d\\n\",\n               h->mb_x, h->mb_y);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!(h->top_samples_available & 0x8000)) {\n        mode = top[mode];\n        if (mode < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n                   h->mb_x, h->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n        mode = left[mode];\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n                   (!(h->left_samples_available & 0x8000)) +\n                   2 * (mode == DC_128_PRED8x8);\n        }\n        if (mode < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n                   h->mb_x, h->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return mode;\n}\n\nconst uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src,\n                                  int *dst_length, int *consumed, int length)\n{\n    int i, si, di;\n    uint8_t *dst;\n    int bufidx;\n\n    // src[0]&0x80; // forbidden bit\n    h->nal_ref_idc   = src[0] >> 5;\n    h->nal_unit_type = src[0] & 0x1F;\n\n    src++;\n    length--;\n\n#define STARTCODE_TEST                                                  \\\n    if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {         \\\n        if (src[i + 2] != 3) {                                          \\\n            /* startcode, so we must be past the end */                 \\\n            length = i;                                                 \\\n        }                                                               \\\n        break;                                                          \\\n    }\n\n#if HAVE_FAST_UNALIGNED\n#define FIND_FIRST_ZERO                                                 \\\n    if (i > 0 && !src[i])                                               \\\n        i--;                                                            \\\n    while (src[i])                                                      \\\n        i++\n\n#if HAVE_FAST_64BIT\n    for (i = 0; i + 1 < length; i += 9) {\n        if (!((~AV_RN64A(src + i) &\n               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &\n              0x8000800080008080ULL))\n            continue;\n        FIND_FIRST_ZERO;\n        STARTCODE_TEST;\n        i -= 7;\n    }\n#else\n    for (i = 0; i + 1 < length; i += 5) {\n        if (!((~AV_RN32A(src + i) &\n               (AV_RN32A(src + i) - 0x01000101U)) &\n              0x80008080U))\n            continue;\n        FIND_FIRST_ZERO;\n        STARTCODE_TEST;\n        i -= 3;\n    }\n#endif\n#else\n    for (i = 0; i + 1 < length; i += 2) {\n        if (src[i])\n            continue;\n        if (i > 0 && src[i - 1] == 0)\n            i--;\n        STARTCODE_TEST;\n    }\n#endif\n\n    // use second escape buffer for inter data\n    bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0;\n\n    si = h->rbsp_buffer_size[bufidx];\n    av_fast_padded_malloc(&h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+MAX_MBPAIR_SIZE);\n    dst = h->rbsp_buffer[bufidx];\n\n    if (dst == NULL)\n        return NULL;\n\n    if(i>=length-1){ //no escaped 0\n        *dst_length= length;\n        *consumed= length+1; //+1 for the header\n        if(h->avctx->flags2 & CODEC_FLAG2_FAST){\n            return src;\n        }else{\n            memcpy(dst, src, length);\n            return dst;\n        }\n    }\n\n    memcpy(dst, src, i);\n    si = di = i;\n    while (si + 2 < length) {\n        // remove escapes (very rare 1:2^22)\n        if (src[si + 2] > 3) {\n            dst[di++] = src[si++];\n            dst[di++] = src[si++];\n        } else if (src[si] == 0 && src[si + 1] == 0) {\n            if (src[si + 2] == 3) { // escape\n                dst[di++]  = 0;\n                dst[di++]  = 0;\n                si        += 3;\n                continue;\n            } else // next start code\n                goto nsc;\n        }\n\n        dst[di++] = src[si++];\n    }\n    while (si < length)\n        dst[di++] = src[si++];\n\nnsc:\n    memset(dst + di, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n    *dst_length = di;\n    *consumed   = si + 1; // +1 for the header\n    /* FIXME store exact number of bits in the getbitcontext\n     * (it is needed for decoding) */\n    return dst;\n}\n\n/**\n * Identify the exact end of the bitstream\n * @return the length of the trailing, or 0 if damaged\n */\nstatic int decode_rbsp_trailing(H264Context *h, const uint8_t *src)\n{\n    int v = *src;\n    int r;\n\n    tprintf(h->avctx, \"rbsp trailing %X\\n\", v);\n\n    for (r = 1; r < 9; r++) {\n        if (v & 1)\n            return r;\n        v >>= 1;\n    }\n    return 0;\n}\n\nstatic inline int get_lowest_part_list_y(H264Context *h, Picture *pic, int n,\n                                         int height, int y_offset, int list)\n{\n    int raw_my             = h->mv_cache[list][scan8[n]][1];\n    int filter_height_down = (raw_my & 3) ? 3 : 0;\n    int full_my            = (raw_my >> 2) + y_offset;\n    int bottom             = full_my + filter_height_down + height;\n\n    av_assert2(height >= 0);\n\n    return FFMAX(0, bottom);\n}\n\nstatic inline void get_lowest_part_y(H264Context *h, int refs[2][48], int n,\n                                     int height, int y_offset, int list0,\n                                     int list1, int *nrefs)\n{\n    int my;\n\n    y_offset += 16 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0) {\n        int ref_n    = h->ref_cache[0][scan8[n]];\n        Picture *ref = &h->ref_list[0][ref_n];\n\n        // Error resilience puts the current picture in the ref list.\n        // Don't try to wait on these as it will cause a deadlock.\n        // Fields can wait on each other, though.\n        if (ref->tf.progress->data != h->cur_pic.tf.progress->data ||\n            (ref->reference & 3) != h->picture_structure) {\n            my = get_lowest_part_list_y(h, ref, n, height, y_offset, 0);\n            if (refs[0][ref_n] < 0)\n                nrefs[0] += 1;\n            refs[0][ref_n] = FFMAX(refs[0][ref_n], my);\n        }\n    }\n\n    if (list1) {\n        int ref_n    = h->ref_cache[1][scan8[n]];\n        Picture *ref = &h->ref_list[1][ref_n];\n\n        if (ref->tf.progress->data != h->cur_pic.tf.progress->data ||\n            (ref->reference & 3) != h->picture_structure) {\n            my = get_lowest_part_list_y(h, ref, n, height, y_offset, 1);\n            if (refs[1][ref_n] < 0)\n                nrefs[1] += 1;\n            refs[1][ref_n] = FFMAX(refs[1][ref_n], my);\n        }\n    }\n}\n\n/**\n * Wait until all reference frames are available for MC operations.\n *\n * @param h the H264 context\n */\nstatic void await_references(H264Context *h)\n{\n    const int mb_xy   = h->mb_xy;\n    const int mb_type = h->cur_pic.mb_type[mb_xy];\n    int refs[2][48];\n    int nrefs[2] = { 0 };\n    int ref, list;\n\n    memset(refs, -1, sizeof(refs));\n\n    if (IS_16X16(mb_type)) {\n        get_lowest_part_y(h, refs, 0, 16, 0,\n                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\n    } else if (IS_16X8(mb_type)) {\n        get_lowest_part_y(h, refs, 0, 8, 0,\n                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\n        get_lowest_part_y(h, refs, 8, 8, 8,\n                          IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);\n    } else if (IS_8X16(mb_type)) {\n        get_lowest_part_y(h, refs, 0, 16, 0,\n                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\n        get_lowest_part_y(h, refs, 4, 16, 0,\n                          IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);\n    } else {\n        int i;\n\n        av_assert2(IS_8X8(mb_type));\n\n        for (i = 0; i < 4; i++) {\n            const int sub_mb_type = h->sub_mb_type[i];\n            const int n           = 4 * i;\n            int y_offset          = (i & 2) << 2;\n\n            if (IS_SUB_8X8(sub_mb_type)) {\n                get_lowest_part_y(h, refs, n, 8, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n            } else if (IS_SUB_8X4(sub_mb_type)) {\n                get_lowest_part_y(h, refs, n, 4, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n                get_lowest_part_y(h, refs, n + 2, 4, y_offset + 4,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n            } else if (IS_SUB_4X8(sub_mb_type)) {\n                get_lowest_part_y(h, refs, n, 8, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n                get_lowest_part_y(h, refs, n + 1, 8, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n            } else {\n                int j;\n                av_assert2(IS_SUB_4X4(sub_mb_type));\n                for (j = 0; j < 4; j++) {\n                    int sub_y_offset = y_offset + 2 * (j & 2);\n                    get_lowest_part_y(h, refs, n + j, 4, sub_y_offset,\n                                      IS_DIR(sub_mb_type, 0, 0),\n                                      IS_DIR(sub_mb_type, 0, 1),\n                                      nrefs);\n                }\n            }\n        }\n    }\n\n    for (list = h->list_count - 1; list >= 0; list--)\n        for (ref = 0; ref < 48 && nrefs[list]; ref++) {\n            int row = refs[list][ref];\n            if (row >= 0) {\n                Picture *ref_pic      = &h->ref_list[list][ref];\n                int ref_field         = ref_pic->reference - 1;\n                int ref_field_picture = ref_pic->field_picture;\n                int pic_height        = 16 * h->mb_height >> ref_field_picture;\n\n                row <<= MB_MBAFF(h);\n                nrefs[list]--;\n\n                if (!FIELD_PICTURE(h) && ref_field_picture) { // frame referencing two fields\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN((row >> 1) - !(row & 1),\n                                                   pic_height - 1),\n                                             1);\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN((row >> 1), pic_height - 1),\n                                             0);\n                } else if (FIELD_PICTURE(h) && !ref_field_picture) { // field referencing one field of a frame\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN(row * 2 + ref_field,\n                                                   pic_height - 1),\n                                             0);\n                } else if (FIELD_PICTURE(h)) {\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN(row, pic_height - 1),\n                                             ref_field);\n                } else {\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN(row, pic_height - 1),\n                                             0);\n                }\n            }\n        }\n}\n\nstatic av_always_inline void mc_dir_part(H264Context *h, Picture *pic,\n                                         int n, int square, int height,\n                                         int delta, int list,\n                                         uint8_t *dest_y, uint8_t *dest_cb,\n                                         uint8_t *dest_cr,\n                                         int src_x_offset, int src_y_offset,\n                                         qpel_mc_func *qpix_op,\n                                         h264_chroma_mc_func chroma_op,\n                                         int pixel_shift, int chroma_idc)\n{\n    const int mx      = h->mv_cache[list][scan8[n]][0] + src_x_offset * 8;\n    int my            = h->mv_cache[list][scan8[n]][1] + src_y_offset * 8;\n    const int luma_xy = (mx & 3) + ((my & 3) << 2);\n    ptrdiff_t offset  = ((mx >> 2) << pixel_shift) + (my >> 2) * h->mb_linesize;\n    uint8_t *src_y    = pic->f.data[0] + offset;\n    uint8_t *src_cb, *src_cr;\n    int extra_width  = 0;\n    int extra_height = 0;\n    int emu = 0;\n    const int full_mx    = mx >> 2;\n    const int full_my    = my >> 2;\n    const int pic_width  = 16 * h->mb_width;\n    const int pic_height = 16 * h->mb_height >> MB_FIELD(h);\n    int ysh;\n\n    if (mx & 7)\n        extra_width -= 3;\n    if (my & 7)\n        extra_height -= 3;\n\n    if (full_mx                <          0 - extra_width  ||\n        full_my                <          0 - extra_height ||\n        full_mx + 16 /*FIXME*/ > pic_width  + extra_width  ||\n        full_my + 16 /*FIXME*/ > pic_height + extra_height) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_linesize,\n                                 src_y - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                 h->mb_linesize,\n                                 16 + 5, 16 + 5 /*FIXME*/, full_mx - 2,\n                                 full_my - 2, pic_width, pic_height);\n        src_y = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        emu   = 1;\n    }\n\n    qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); // FIXME try variable height perhaps?\n    if (!square)\n        qpix_op[luma_xy](dest_y + delta, src_y + delta, h->mb_linesize);\n\n    if (CONFIG_GRAY && h->flags & CODEC_FLAG_GRAY)\n        return;\n\n    if (chroma_idc == 3 /* yuv444 */) {\n        src_cb = pic->f.data[1] + offset;\n        if (emu) {\n            h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_linesize,\n                                     src_cb - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                     h->mb_linesize,\n                                     16 + 5, 16 + 5 /*FIXME*/,\n                                     full_mx - 2, full_my - 2,\n                                     pic_width, pic_height);\n            src_cb = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        }\n        qpix_op[luma_xy](dest_cb, src_cb, h->mb_linesize); // FIXME try variable height perhaps?\n        if (!square)\n            qpix_op[luma_xy](dest_cb + delta, src_cb + delta, h->mb_linesize);\n\n        src_cr = pic->f.data[2] + offset;\n        if (emu) {\n            h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_linesize,\n                                     src_cr - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                     h->mb_linesize,\n                                     16 + 5, 16 + 5 /*FIXME*/,\n                                     full_mx - 2, full_my - 2,\n                                     pic_width, pic_height);\n            src_cr = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        }\n        qpix_op[luma_xy](dest_cr, src_cr, h->mb_linesize); // FIXME try variable height perhaps?\n        if (!square)\n            qpix_op[luma_xy](dest_cr + delta, src_cr + delta, h->mb_linesize);\n        return;\n    }\n\n    ysh = 3 - (chroma_idc == 2 /* yuv422 */);\n    if (chroma_idc == 1 /* yuv420 */ && MB_FIELD(h)) {\n        // chroma offset when predicting from a field of opposite parity\n        my  += 2 * ((h->mb_y & 1) - (pic->reference - 1));\n        emu |= (my >> 3) < 0 || (my >> 3) + 8 >= (pic_height >> 1);\n    }\n\n    src_cb = pic->f.data[1] + ((mx >> 3) << pixel_shift) +\n             (my >> ysh) * h->mb_uvlinesize;\n    src_cr = pic->f.data[2] + ((mx >> 3) << pixel_shift) +\n             (my >> ysh) * h->mb_uvlinesize;\n\n    if (emu) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_uvlinesize, src_cb, h->mb_uvlinesize,\n                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),\n                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));\n        src_cb = h->edge_emu_buffer;\n    }\n    chroma_op(dest_cb, src_cb, h->mb_uvlinesize,\n              height >> (chroma_idc == 1 /* yuv420 */),\n              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);\n\n    if (emu) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_uvlinesize, src_cr, h->mb_uvlinesize,\n                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),\n                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));\n        src_cr = h->edge_emu_buffer;\n    }\n    chroma_op(dest_cr, src_cr, h->mb_uvlinesize, height >> (chroma_idc == 1 /* yuv420 */),\n              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);\n}\n\nstatic av_always_inline void mc_part_std(H264Context *h, int n, int square,\n                                         int height, int delta,\n                                         uint8_t *dest_y, uint8_t *dest_cb,\n                                         uint8_t *dest_cr,\n                                         int x_offset, int y_offset,\n                                         qpel_mc_func *qpix_put,\n                                         h264_chroma_mc_func chroma_put,\n                                         qpel_mc_func *qpix_avg,\n                                         h264_chroma_mc_func chroma_avg,\n                                         int list0, int list1,\n                                         int pixel_shift, int chroma_idc)\n{\n    qpel_mc_func *qpix_op         = qpix_put;\n    h264_chroma_mc_func chroma_op = chroma_put;\n\n    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    if (chroma_idc == 3 /* yuv444 */) {\n        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    } else if (chroma_idc == 2 /* yuv422 */) {\n        dest_cb += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n        dest_cr += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n    } else { /* yuv420 */\n        dest_cb += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n        dest_cr += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n    }\n    x_offset += 8 * h->mb_x;\n    y_offset += 8 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0) {\n        Picture *ref = &h->ref_list[0][h->ref_cache[0][scan8[n]]];\n        mc_dir_part(h, ref, n, square, height, delta, 0,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_op, chroma_op, pixel_shift, chroma_idc);\n\n        qpix_op   = qpix_avg;\n        chroma_op = chroma_avg;\n    }\n\n    if (list1) {\n        Picture *ref = &h->ref_list[1][h->ref_cache[1][scan8[n]]];\n        mc_dir_part(h, ref, n, square, height, delta, 1,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_op, chroma_op, pixel_shift, chroma_idc);\n    }\n}\n\nstatic av_always_inline void mc_part_weighted(H264Context *h, int n, int square,\n                                              int height, int delta,\n                                              uint8_t *dest_y, uint8_t *dest_cb,\n                                              uint8_t *dest_cr,\n                                              int x_offset, int y_offset,\n                                              qpel_mc_func *qpix_put,\n                                              h264_chroma_mc_func chroma_put,\n                                              h264_weight_func luma_weight_op,\n                                              h264_weight_func chroma_weight_op,\n                                              h264_biweight_func luma_weight_avg,\n                                              h264_biweight_func chroma_weight_avg,\n                                              int list0, int list1,\n                                              int pixel_shift, int chroma_idc)\n{\n    int chroma_height;\n\n    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    if (chroma_idc == 3 /* yuv444 */) {\n        chroma_height     = height;\n        chroma_weight_avg = luma_weight_avg;\n        chroma_weight_op  = luma_weight_op;\n        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    } else if (chroma_idc == 2 /* yuv422 */) {\n        chroma_height = height;\n        dest_cb      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n        dest_cr      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n    } else { /* yuv420 */\n        chroma_height = height >> 1;\n        dest_cb      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n        dest_cr      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n    }\n    x_offset += 8 * h->mb_x;\n    y_offset += 8 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0 && list1) {\n        /* don't optimize for luma-only case, since B-frames usually\n         * use implicit weights => chroma too. */\n        uint8_t *tmp_cb = h->bipred_scratchpad;\n        uint8_t *tmp_cr = h->bipred_scratchpad + (16 << pixel_shift);\n        uint8_t *tmp_y  = h->bipred_scratchpad + 16 * h->mb_uvlinesize;\n        int refn0       = h->ref_cache[0][scan8[n]];\n        int refn1       = h->ref_cache[1][scan8[n]];\n\n        mc_dir_part(h, &h->ref_list[0][refn0], n, square, height, delta, 0,\n                    dest_y, dest_cb, dest_cr,\n                    x_offset, y_offset, qpix_put, chroma_put,\n                    pixel_shift, chroma_idc);\n        mc_dir_part(h, &h->ref_list[1][refn1], n, square, height, delta, 1,\n                    tmp_y, tmp_cb, tmp_cr,\n                    x_offset, y_offset, qpix_put, chroma_put,\n                    pixel_shift, chroma_idc);\n\n        if (h->use_weight == 2) {\n            int weight0 = h->implicit_weight[refn0][refn1][h->mb_y & 1];\n            int weight1 = 64 - weight0;\n            luma_weight_avg(dest_y, tmp_y, h->mb_linesize,\n                            height, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize,\n                              chroma_height, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize,\n                              chroma_height, 5, weight0, weight1, 0);\n        } else {\n            luma_weight_avg(dest_y, tmp_y, h->mb_linesize, height,\n                            h->luma_log2_weight_denom,\n                            h->luma_weight[refn0][0][0],\n                            h->luma_weight[refn1][1][0],\n                            h->luma_weight[refn0][0][1] +\n                            h->luma_weight[refn1][1][1]);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, chroma_height,\n                              h->chroma_log2_weight_denom,\n                              h->chroma_weight[refn0][0][0][0],\n                              h->chroma_weight[refn1][1][0][0],\n                              h->chroma_weight[refn0][0][0][1] +\n                              h->chroma_weight[refn1][1][0][1]);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, chroma_height,\n                              h->chroma_log2_weight_denom,\n                              h->chroma_weight[refn0][0][1][0],\n                              h->chroma_weight[refn1][1][1][0],\n                              h->chroma_weight[refn0][0][1][1] +\n                              h->chroma_weight[refn1][1][1][1]);\n        }\n    } else {\n        int list     = list1 ? 1 : 0;\n        int refn     = h->ref_cache[list][scan8[n]];\n        Picture *ref = &h->ref_list[list][refn];\n        mc_dir_part(h, ref, n, square, height, delta, list,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_put, chroma_put, pixel_shift, chroma_idc);\n\n        luma_weight_op(dest_y, h->mb_linesize, height,\n                       h->luma_log2_weight_denom,\n                       h->luma_weight[refn][list][0],\n                       h->luma_weight[refn][list][1]);\n        if (h->use_weight_chroma) {\n            chroma_weight_op(dest_cb, h->mb_uvlinesize, chroma_height,\n                             h->chroma_log2_weight_denom,\n                             h->chroma_weight[refn][list][0][0],\n                             h->chroma_weight[refn][list][0][1]);\n            chroma_weight_op(dest_cr, h->mb_uvlinesize, chroma_height,\n                             h->chroma_log2_weight_denom,\n                             h->chroma_weight[refn][list][1][0],\n                             h->chroma_weight[refn][list][1][1]);\n        }\n    }\n}\n\nstatic av_always_inline void prefetch_motion(H264Context *h, int list,\n                                             int pixel_shift, int chroma_idc)\n{\n    /* fetch pixels for estimated mv 4 macroblocks ahead\n     * optimized for 64byte cache lines */\n    const int refn = h->ref_cache[list][scan8[0]];\n    if (refn >= 0) {\n        const int mx  = (h->mv_cache[list][scan8[0]][0] >> 2) + 16 * h->mb_x + 8;\n        const int my  = (h->mv_cache[list][scan8[0]][1] >> 2) + 16 * h->mb_y;\n        uint8_t **src = h->ref_list[list][refn].f.data;\n        int off       = (mx << pixel_shift) +\n                        (my + (h->mb_x & 3) * 4) * h->mb_linesize +\n                        (64 << pixel_shift);\n        h->vdsp.prefetch(src[0] + off, h->linesize, 4);\n        if (chroma_idc == 3 /* yuv444 */) {\n            h->vdsp.prefetch(src[1] + off, h->linesize, 4);\n            h->vdsp.prefetch(src[2] + off, h->linesize, 4);\n        } else {\n            off= (((mx>>1)+64)<<pixel_shift) + ((my>>1) + (h->mb_x&7))*h->uvlinesize;\n            h->vdsp.prefetch(src[1] + off, src[2] - src[1], 2);\n        }\n    }\n}\n\nstatic void free_tables(H264Context *h, int free_rbsp)\n{\n    int i;\n    H264Context *hx;\n\n    av_freep(&h->intra4x4_pred_mode);\n    av_freep(&h->chroma_pred_mode_table);\n    av_freep(&h->cbp_table);\n    av_freep(&h->mvd_table[0]);\n    av_freep(&h->mvd_table[1]);\n    av_freep(&h->direct_table);\n    av_freep(&h->non_zero_count);\n    av_freep(&h->slice_table_base);\n    h->slice_table = NULL;\n    av_freep(&h->list_counts);\n\n    av_freep(&h->mb2b_xy);\n    av_freep(&h->mb2br_xy);\n\n    for (i = 0; i < 3; i++)\n        av_freep(&h->visualization_buffer[i]);\n\n    av_buffer_pool_uninit(&h->qscale_table_pool);\n    av_buffer_pool_uninit(&h->mb_type_pool);\n    av_buffer_pool_uninit(&h->motion_val_pool);\n    av_buffer_pool_uninit(&h->ref_index_pool);\n\n    if (free_rbsp && h->DPB) {\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            unref_picture(h, &h->DPB[i]);\n        av_freep(&h->DPB);\n    } else if (h->DPB) {\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            h->DPB[i].needs_realloc = 1;\n    }\n\n    h->cur_pic_ptr = NULL;\n\n    for (i = 0; i < MAX_THREADS; i++) {\n        hx = h->thread_context[i];\n        if (!hx)\n            continue;\n        av_freep(&hx->top_borders[1]);\n        av_freep(&hx->top_borders[0]);\n        av_freep(&hx->bipred_scratchpad);\n        av_freep(&hx->edge_emu_buffer);\n        av_freep(&hx->dc_val_base);\n        av_freep(&hx->me.scratchpad);\n        av_freep(&hx->er.mb_index2xy);\n        av_freep(&hx->er.error_status_table);\n        av_freep(&hx->er.er_temp_buffer);\n        av_freep(&hx->er.mbintra_table);\n        av_freep(&hx->er.mbskip_table);\n\n        if (free_rbsp) {\n            av_freep(&hx->rbsp_buffer[1]);\n            av_freep(&hx->rbsp_buffer[0]);\n            hx->rbsp_buffer_size[0] = 0;\n            hx->rbsp_buffer_size[1] = 0;\n        }\n        if (i)\n            av_freep(&h->thread_context[i]);\n    }\n}\n\nstatic void init_dequant8_coeff_table(H264Context *h)\n{\n    int i, j, q, x;\n    const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);\n\n    for (i = 0; i < 6; i++) {\n        h->dequant8_coeff[i] = h->dequant8_buffer[i];\n        for (j = 0; j < i; j++)\n            if (!memcmp(h->pps.scaling_matrix8[j], h->pps.scaling_matrix8[i],\n                        64 * sizeof(uint8_t))) {\n                h->dequant8_coeff[i] = h->dequant8_buffer[j];\n                break;\n            }\n        if (j < i)\n            continue;\n\n        for (q = 0; q < max_qp + 1; q++) {\n            int shift = div6[q];\n            int idx   = rem6[q];\n            for (x = 0; x < 64; x++)\n                h->dequant8_coeff[i][q][(x >> 3) | ((x & 7) << 3)] =\n                    ((uint32_t)dequant8_coeff_init[idx][dequant8_coeff_init_scan[((x >> 1) & 12) | (x & 3)]] *\n                     h->pps.scaling_matrix8[i][x]) << shift;\n        }\n    }\n}\n\nstatic void init_dequant4_coeff_table(H264Context *h)\n{\n    int i, j, q, x;\n    const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);\n    for (i = 0; i < 6; i++) {\n        h->dequant4_coeff[i] = h->dequant4_buffer[i];\n        for (j = 0; j < i; j++)\n            if (!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i],\n                        16 * sizeof(uint8_t))) {\n                h->dequant4_coeff[i] = h->dequant4_buffer[j];\n                break;\n            }\n        if (j < i)\n            continue;\n\n        for (q = 0; q < max_qp + 1; q++) {\n            int shift = div6[q] + 2;\n            int idx   = rem6[q];\n            for (x = 0; x < 16; x++)\n                h->dequant4_coeff[i][q][(x >> 2) | ((x << 2) & 0xF)] =\n                    ((uint32_t)dequant4_coeff_init[idx][(x & 1) + ((x >> 2) & 1)] *\n                     h->pps.scaling_matrix4[i][x]) << shift;\n        }\n    }\n}\n\nstatic void init_dequant_tables(H264Context *h)\n{\n    int i, x;\n    init_dequant4_coeff_table(h);\n    if (h->pps.transform_8x8_mode)\n        init_dequant8_coeff_table(h);\n    if (h->sps.transform_bypass) {\n        for (i = 0; i < 6; i++)\n            for (x = 0; x < 16; x++)\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n        if (h->pps.transform_8x8_mode)\n            for (i = 0; i < 6; i++)\n                for (x = 0; x < 64; x++)\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n    }\n}\n\nint ff_h264_alloc_tables(H264Context *h)\n{\n    const int big_mb_num = h->mb_stride * (h->mb_height + 1);\n    const int row_mb_num = 2*h->mb_stride*FFMAX(h->avctx->thread_count, 1);\n    int x, y, i;\n\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->intra4x4_pred_mode,\n                      row_mb_num * 8 * sizeof(uint8_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->non_zero_count,\n                      big_mb_num * 48 * sizeof(uint8_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->slice_table_base,\n                      (big_mb_num + h->mb_stride) * sizeof(*h->slice_table_base), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->cbp_table,\n                      big_mb_num * sizeof(uint16_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->chroma_pred_mode_table,\n                      big_mb_num * sizeof(uint8_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mvd_table[0],\n                      16 * row_mb_num * sizeof(uint8_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mvd_table[1],\n                      16 * row_mb_num * sizeof(uint8_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->direct_table,\n                      4 * big_mb_num * sizeof(uint8_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->list_counts,\n                      big_mb_num * sizeof(uint8_t), fail)\n\n    memset(h->slice_table_base, -1,\n           (big_mb_num + h->mb_stride) * sizeof(*h->slice_table_base));\n    h->slice_table = h->slice_table_base + h->mb_stride * 2 + 1;\n\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mb2b_xy,\n                      big_mb_num * sizeof(uint32_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mb2br_xy,\n                      big_mb_num * sizeof(uint32_t), fail);\n    for (y = 0; y < h->mb_height; y++)\n        for (x = 0; x < h->mb_width; x++) {\n            const int mb_xy = x + y * h->mb_stride;\n            const int b_xy  = 4 * x + 4 * y * h->b_stride;\n\n            h->mb2b_xy[mb_xy]  = b_xy;\n            h->mb2br_xy[mb_xy] = 8 * (FMO ? mb_xy : (mb_xy % (2 * h->mb_stride)));\n        }\n\n    if (!h->dequant4_coeff[0])\n        init_dequant_tables(h);\n\n    if (!h->DPB) {\n        h->DPB = av_mallocz_array(MAX_PICTURE_COUNT, sizeof(*h->DPB));\n        if (!h->DPB)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            avcodec_get_frame_defaults(&h->DPB[i].f);\n        avcodec_get_frame_defaults(&h->cur_pic.f);\n    }\n\n    return 0;\n\nfail:\n    free_tables(h, 1);\n    return AVERROR(ENOMEM);\n}\n\n/**\n * Mimic alloc_tables(), but for every context thread.\n */\nstatic void clone_tables(H264Context *dst, H264Context *src, int i)\n{\n    dst->intra4x4_pred_mode     = src->intra4x4_pred_mode + i * 8 * 2 * src->mb_stride;\n    dst->non_zero_count         = src->non_zero_count;\n    dst->slice_table            = src->slice_table;\n    dst->cbp_table              = src->cbp_table;\n    dst->mb2b_xy                = src->mb2b_xy;\n    dst->mb2br_xy               = src->mb2br_xy;\n    dst->chroma_pred_mode_table = src->chroma_pred_mode_table;\n    dst->mvd_table[0]           = src->mvd_table[0] + i * 8 * 2 * src->mb_stride;\n    dst->mvd_table[1]           = src->mvd_table[1] + i * 8 * 2 * src->mb_stride;\n    dst->direct_table           = src->direct_table;\n    dst->list_counts            = src->list_counts;\n    dst->DPB                    = src->DPB;\n    dst->cur_pic_ptr            = src->cur_pic_ptr;\n    dst->cur_pic                = src->cur_pic;\n    dst->bipred_scratchpad      = NULL;\n    dst->edge_emu_buffer        = NULL;\n    dst->me.scratchpad          = NULL;\n    ff_h264_pred_init(&dst->hpc, src->avctx->codec_id, src->sps.bit_depth_luma,\n                      src->sps.chroma_format_idc);\n}\n\n/**\n * Init context\n * Allocate buffers which are not shared amongst multiple threads.\n */\nstatic int context_init(H264Context *h)\n{\n    ERContext *er = &h->er;\n    int mb_array_size = h->mb_height * h->mb_stride;\n    int y_size  = (2 * h->mb_width + 1) * (2 * h->mb_height + 1);\n    int c_size  = h->mb_stride * (h->mb_height + 1);\n    int yc_size = y_size + 2   * c_size;\n    int x, y, i;\n\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->top_borders[0],\n                      h->mb_width * 16 * 3 * sizeof(uint8_t) * 2, fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->top_borders[1],\n                      h->mb_width * 16 * 3 * sizeof(uint8_t) * 2, fail)\n\n    h->ref_cache[0][scan8[5]  + 1] =\n    h->ref_cache[0][scan8[7]  + 1] =\n    h->ref_cache[0][scan8[13] + 1] =\n    h->ref_cache[1][scan8[5]  + 1] =\n    h->ref_cache[1][scan8[7]  + 1] =\n    h->ref_cache[1][scan8[13] + 1] = PART_NOT_AVAILABLE;\n\n    if (CONFIG_ERROR_RESILIENCE) {\n        /* init ER */\n        er->avctx          = h->avctx;\n        er->dsp            = &h->dsp;\n        er->decode_mb      = h264_er_decode_mb;\n        er->opaque         = h;\n        er->quarter_sample = 1;\n\n        er->mb_num      = h->mb_num;\n        er->mb_width    = h->mb_width;\n        er->mb_height   = h->mb_height;\n        er->mb_stride   = h->mb_stride;\n        er->b8_stride   = h->mb_width * 2 + 1;\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, er->mb_index2xy, (h->mb_num + 1) * sizeof(int),\n                          fail); // error ressilience code looks cleaner with this\n        for (y = 0; y < h->mb_height; y++)\n            for (x = 0; x < h->mb_width; x++)\n                er->mb_index2xy[x + y * h->mb_width] = x + y * h->mb_stride;\n\n        er->mb_index2xy[h->mb_height * h->mb_width] = (h->mb_height - 1) *\n                                                      h->mb_stride + h->mb_width;\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, er->error_status_table,\n                          mb_array_size * sizeof(uint8_t), fail);\n\n        FF_ALLOC_OR_GOTO(h->avctx, er->mbintra_table, mb_array_size, fail);\n        memset(er->mbintra_table, 1, mb_array_size);\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, er->mbskip_table, mb_array_size + 2, fail);\n\n        FF_ALLOC_OR_GOTO(h->avctx, er->er_temp_buffer, h->mb_height * h->mb_stride,\n                         fail);\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, h->dc_val_base, yc_size * sizeof(int16_t), fail);\n        er->dc_val[0] = h->dc_val_base + h->mb_width * 2 + 2;\n        er->dc_val[1] = h->dc_val_base + y_size + h->mb_stride + 1;\n        er->dc_val[2] = er->dc_val[1] + c_size;\n        for (i = 0; i < yc_size; i++)\n            h->dc_val_base[i] = 1024;\n    }\n\n    return 0;\n\nfail:\n    return AVERROR(ENOMEM); // free_tables will clean up for us\n}\n\nstatic int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size,\n                            int parse_extradata);\n\nint ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)\n{\n    AVCodecContext *avctx = h->avctx;\n    int ret;\n\n    if (!buf || size <= 0)\n        return -1;\n\n    if (buf[0] == 1) {\n        int i, cnt, nalsize;\n        const unsigned char *p = buf;\n\n        h->is_avc = 1;\n\n        if (size < 7) {\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n         * so put a fake nal_length_size = 2 while parsing them */\n        h->nal_length_size = 2;\n        // Decode sps from avcC\n        cnt = *(p + 5) & 0x1f; // Number of sps\n        p  += 6;\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding sps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        // Decode pps from avcC\n        cnt = *(p++); // Number of pps\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding pps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        // Now store right nal length size, that will be used to parse all other nals\n        h->nal_length_size = (buf[4] & 0x03) + 1;\n    } else {\n        h->is_avc = 0;\n        ret = decode_nal_units(h, buf, size, 1);\n        if (ret < 0)\n            return ret;\n    }\n    return size;\n}\n\nav_cold int ff_h264_decode_init(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    int i;\n    int ret;\n\n    h->avctx = avctx;\n\n    h->bit_depth_luma    = 8;\n    h->chroma_format_idc = 1;\n\n    h->avctx->bits_per_raw_sample = 8;\n    h->cur_chroma_format_idc = 1;\n\n    ff_h264dsp_init(&h->h264dsp, 8, 1);\n    av_assert0(h->sps.bit_depth_chroma == 0);\n    ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma);\n    ff_h264qpel_init(&h->h264qpel, 8);\n    ff_h264_pred_init(&h->hpc, h->avctx->codec_id, 8, 1);\n\n    h->dequant_coeff_pps = -1;\n    h->current_sps_id = -1;\n\n    /* needed so that IDCT permutation is known early */\n    if (CONFIG_ERROR_RESILIENCE)\n        ff_dsputil_init(&h->dsp, h->avctx);\n    ff_videodsp_init(&h->vdsp, 8);\n\n    memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n    memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));\n\n    h->picture_structure   = PICT_FRAME;\n    h->slice_context_count = 1;\n    h->workaround_bugs     = avctx->workaround_bugs;\n    h->flags               = avctx->flags;\n\n    /* set defaults */\n    // s->decode_mb = ff_h263_decode_mb;\n    if (!avctx->has_b_frames)\n        h->low_delay = 1;\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n\n    ff_h264_decode_init_vlc();\n\n    ff_init_cabac_states();\n\n    h->pixel_shift        = 0;\n    h->sps.bit_depth_luma = avctx->bits_per_raw_sample = 8;\n\n    h->thread_context[0] = h;\n    h->outputed_poc      = h->next_outputed_poc = INT_MIN;\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n        h->last_pocs[i] = INT_MIN;\n    h->prev_poc_msb = 1 << 16;\n    h->prev_frame_num = -1;\n    h->x264_build   = -1;\n    h->sei_fpa.frame_packing_arrangement_cancel_flag = -1;\n    ff_h264_reset_sei(h);\n    if (avctx->codec_id == AV_CODEC_ID_H264) {\n        if (avctx->ticks_per_frame == 1) {\n            if(h->avctx->time_base.den < INT_MAX/2) {\n                h->avctx->time_base.den *= 2;\n            } else\n                h->avctx->time_base.num /= 2;\n        }\n        avctx->ticks_per_frame = 2;\n    }\n\n    if (avctx->extradata_size > 0 && avctx->extradata) {\n        ret = ff_h264_decode_extradata(h, avctx->extradata, avctx->extradata_size);\n        if (ret < 0) {\n            ff_h264_free_context(h);\n            return ret;\n        }\n    }\n\n    if (h->sps.bitstream_restriction_flag &&\n        h->avctx->has_b_frames < h->sps.num_reorder_frames) {\n        h->avctx->has_b_frames = h->sps.num_reorder_frames;\n        h->low_delay           = 0;\n    }\n\n    avctx->internal->allocate_progress = 1;\n\n    flush_change(h);\n\n    return 0;\n}\n\n#define IN_RANGE(a, b, size) (((a) >= (b)) && ((a) < ((b) + (size))))\n#undef REBASE_PICTURE\n#define REBASE_PICTURE(pic, new_ctx, old_ctx)             \\\n    ((pic && pic >= old_ctx->DPB &&                       \\\n      pic < old_ctx->DPB + MAX_PICTURE_COUNT) ?           \\\n     &new_ctx->DPB[pic - old_ctx->DPB] : NULL)\n\nstatic void copy_picture_range(Picture **to, Picture **from, int count,\n                               H264Context *new_base,\n                               H264Context *old_base)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        assert((IN_RANGE(from[i], old_base, sizeof(*old_base)) ||\n                IN_RANGE(from[i], old_base->DPB,\n                         sizeof(Picture) * MAX_PICTURE_COUNT) ||\n                !from[i]));\n        to[i] = REBASE_PICTURE(from[i], new_base, old_base);\n    }\n}\n\nstatic void copy_parameter_set(void **to, void **from, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        if (to[i] && !from[i])\n            av_freep(&to[i]);\n        else if (from[i] && !to[i])\n            to[i] = av_malloc(size);\n\n        if (from[i])\n            memcpy(to[i], from[i], size);\n    }\n}\n\nstatic int decode_init_thread_copy(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n\n    if (!avctx->internal->is_copy)\n        return 0;\n    memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n    memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n\n    h->rbsp_buffer[0] = NULL;\n    h->rbsp_buffer[1] = NULL;\n    h->rbsp_buffer_size[0] = 0;\n    h->rbsp_buffer_size[1] = 0;\n    h->context_initialized = 0;\n\n    return 0;\n}\n\n#define copy_fields(to, from, start_field, end_field)                   \\\n    memcpy(&to->start_field, &from->start_field,                        \\\n           (char *)&to->end_field - (char *)&to->start_field)\n\nstatic int h264_slice_header_init(H264Context *, int);\n\nstatic int h264_set_parameter_from_sps(H264Context *h);\n\nstatic int decode_update_thread_context(AVCodecContext *dst,\n                                        const AVCodecContext *src)\n{\n    H264Context *h = dst->priv_data, *h1 = src->priv_data;\n    int inited = h->context_initialized, err = 0;\n    int context_reinitialized = 0;\n    int i, ret;\n\n    if (dst == src)\n        return 0;\n\n    if (inited &&\n        (h->width                 != h1->width                 ||\n         h->height                != h1->height                ||\n         h->mb_width              != h1->mb_width              ||\n         h->mb_height             != h1->mb_height             ||\n         h->sps.bit_depth_luma    != h1->sps.bit_depth_luma    ||\n         h->sps.chroma_format_idc != h1->sps.chroma_format_idc ||\n         h->sps.colorspace        != h1->sps.colorspace)) {\n\n        /* set bits_per_raw_sample to the previous value. the check for changed\n         * bit depth in h264_set_parameter_from_sps() uses it and sets it to\n         * the current value */\n        h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;\n\n        av_freep(&h->bipred_scratchpad);\n\n        h->width     = h1->width;\n        h->height    = h1->height;\n        h->mb_height = h1->mb_height;\n        h->mb_width  = h1->mb_width;\n        h->mb_num    = h1->mb_num;\n        h->mb_stride = h1->mb_stride;\n        h->b_stride  = h1->b_stride;\n        // SPS/PPS\n        copy_parameter_set((void **)h->sps_buffers, (void **)h1->sps_buffers,\n                        MAX_SPS_COUNT, sizeof(SPS));\n        h->sps = h1->sps;\n        copy_parameter_set((void **)h->pps_buffers, (void **)h1->pps_buffers,\n                        MAX_PPS_COUNT, sizeof(PPS));\n        h->pps = h1->pps;\n\n        if ((err = h264_slice_header_init(h, 1)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"h264_slice_header_init() failed\");\n            return err;\n        }\n        context_reinitialized = 1;\n\n#if 0\n        h264_set_parameter_from_sps(h);\n        //Note we set context_reinitialized which will cause h264_set_parameter_from_sps to be reexecuted\n        h->cur_chroma_format_idc = h1->cur_chroma_format_idc;\n#endif\n    }\n    /* update linesize on resize for h264. The h264 decoder doesn't\n     * necessarily call ff_MPV_frame_start in the new thread */\n    h->linesize   = h1->linesize;\n    h->uvlinesize = h1->uvlinesize;\n\n    /* copy block_offset since frame_start may not be called */\n    memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));\n\n    if (!inited) {\n        for (i = 0; i < MAX_SPS_COUNT; i++)\n            av_freep(h->sps_buffers + i);\n\n        for (i = 0; i < MAX_PPS_COUNT; i++)\n            av_freep(h->pps_buffers + i);\n\n        av_freep(&h->rbsp_buffer[0]);\n        av_freep(&h->rbsp_buffer[1]);\n        memcpy(h, h1, offsetof(H264Context, intra_pcm_ptr));\n        memcpy(&h->cabac, &h1->cabac,\n               sizeof(H264Context) - offsetof(H264Context, cabac));\n        av_assert0((void*)&h->cabac == &h->mb_padding + 1);\n\n        memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n        memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n\n        memset(&h->er, 0, sizeof(h->er));\n        memset(&h->me, 0, sizeof(h->me));\n        memset(&h->mb, 0, sizeof(h->mb));\n        memset(&h->mb_luma_dc, 0, sizeof(h->mb_luma_dc));\n        memset(&h->mb_padding, 0, sizeof(h->mb_padding));\n\n        h->avctx             = dst;\n        h->DPB               = NULL;\n        h->qscale_table_pool = NULL;\n        h->mb_type_pool      = NULL;\n        h->ref_index_pool    = NULL;\n        h->motion_val_pool   = NULL;\n        for (i = 0; i < 2; i++) {\n            h->rbsp_buffer[i] = NULL;\n            h->rbsp_buffer_size[i] = 0;\n        }\n\n        if (h1->context_initialized) {\n        h->context_initialized = 0;\n\n        memset(&h->cur_pic, 0, sizeof(h->cur_pic));\n        avcodec_get_frame_defaults(&h->cur_pic.f);\n        h->cur_pic.tf.f = &h->cur_pic.f;\n\n        ret = ff_h264_alloc_tables(h);\n        if (ret < 0) {\n            av_log(dst, AV_LOG_ERROR, \"Could not allocate memory for h264\\n\");\n            return ret;\n        }\n        ret = context_init(h);\n        if (ret < 0) {\n            av_log(dst, AV_LOG_ERROR, \"context_init() failed.\\n\");\n            return ret;\n        }\n        }\n\n        h->bipred_scratchpad = NULL;\n        h->edge_emu_buffer   = NULL;\n\n        h->thread_context[0] = h;\n        h->context_initialized = h1->context_initialized;\n    }\n\n    h->avctx->coded_height  = h1->avctx->coded_height;\n    h->avctx->coded_width   = h1->avctx->coded_width;\n    h->avctx->width         = h1->avctx->width;\n    h->avctx->height        = h1->avctx->height;\n    h->coded_picture_number = h1->coded_picture_number;\n    h->first_field          = h1->first_field;\n    h->picture_structure    = h1->picture_structure;\n    h->qscale               = h1->qscale;\n    h->droppable            = h1->droppable;\n    h->data_partitioning    = h1->data_partitioning;\n    h->low_delay            = h1->low_delay;\n\n    for (i = 0; h->DPB && i < MAX_PICTURE_COUNT; i++) {\n        unref_picture(h, &h->DPB[i]);\n        if (h1->DPB[i].f.data[0] &&\n            (ret = ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)\n            return ret;\n    }\n\n    h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);\n    unref_picture(h, &h->cur_pic);\n    if (h1->cur_pic.f.buf[0] && (ret = ref_picture(h, &h->cur_pic, &h1->cur_pic)) < 0)\n        return ret;\n\n    h->workaround_bugs = h1->workaround_bugs;\n    h->low_delay       = h1->low_delay;\n    h->droppable       = h1->droppable;\n\n    // extradata/NAL handling\n    h->is_avc = h1->is_avc;\n\n    // SPS/PPS\n    copy_parameter_set((void **)h->sps_buffers, (void **)h1->sps_buffers,\n                       MAX_SPS_COUNT, sizeof(SPS));\n    h->sps = h1->sps;\n    copy_parameter_set((void **)h->pps_buffers, (void **)h1->pps_buffers,\n                       MAX_PPS_COUNT, sizeof(PPS));\n    h->pps = h1->pps;\n\n    // Dequantization matrices\n    // FIXME these are big - can they be only copied when PPS changes?\n    copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n\n    for (i = 0; i < 6; i++)\n        h->dequant4_coeff[i] = h->dequant4_buffer[0] +\n                               (h1->dequant4_coeff[i] - h1->dequant4_buffer[0]);\n\n    for (i = 0; i < 6; i++)\n        h->dequant8_coeff[i] = h->dequant8_buffer[0] +\n                               (h1->dequant8_coeff[i] - h1->dequant8_buffer[0]);\n\n    h->dequant_coeff_pps = h1->dequant_coeff_pps;\n\n    // POC timing\n    copy_fields(h, h1, poc_lsb, redundant_pic_count);\n\n    // reference lists\n    copy_fields(h, h1, short_ref, cabac_init_idc);\n\n    copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);\n    copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);\n    copy_picture_range(h->delayed_pic, h1->delayed_pic,\n                       MAX_DELAYED_PIC_COUNT + 2, h, h1);\n\n    h->sync            = h1->sync;\n\n    if (context_reinitialized)\n        h264_set_parameter_from_sps(h);\n\n    if (!h->cur_pic_ptr)\n        return 0;\n\n    if (!h->droppable) {\n        err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n        h->prev_poc_msb = h->poc_msb;\n        h->prev_poc_lsb = h->poc_lsb;\n    }\n    h->prev_frame_num_offset = h->frame_num_offset;\n    h->prev_frame_num        = h->frame_num;\n    h->outputed_poc          = h->next_outputed_poc;\n\n    return err;\n}\n\nstatic int h264_frame_start(H264Context *h)\n{\n    Picture *pic;\n    int i, ret;\n    const int pixel_shift = h->pixel_shift;\n    int c[4] = {\n        1<<(h->sps.bit_depth_luma-1),\n        1<<(h->sps.bit_depth_chroma-1),\n        1<<(h->sps.bit_depth_chroma-1),\n        -1\n    };\n\n    if (!ff_thread_can_start_frame(h->avctx)) {\n        av_log(h->avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n        return -1;\n    }\n\n    release_unused_pictures(h, 1);\n    h->cur_pic_ptr = NULL;\n\n    i = find_unused_picture(h);\n    if (i < 0) {\n        av_log(h->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n        return i;\n    }\n    pic = &h->DPB[i];\n\n    pic->reference              = h->droppable ? 0 : h->picture_structure;\n    pic->f.coded_picture_number = h->coded_picture_number++;\n    pic->field_picture          = h->picture_structure != PICT_FRAME;\n\n    /*\n     * Zero key_frame here; IDR markings per slice in frame or fields are ORed\n     * in later.\n     * See decode_nal_units().\n     */\n    pic->f.key_frame = 0;\n    pic->sync        = 0;\n    pic->mmco_reset  = 0;\n\n    if ((ret = alloc_picture(h, pic)) < 0)\n        return ret;\n    if(!h->sync && !h->avctx->hwaccel &&\n       !(h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU))\n        avpriv_color_frame(&pic->f, c);\n\n    h->cur_pic_ptr = pic;\n    unref_picture(h, &h->cur_pic);\n    if ((ret = ref_picture(h, &h->cur_pic, h->cur_pic_ptr)) < 0)\n        return ret;\n\n    if (CONFIG_ERROR_RESILIENCE) {\n        ff_er_frame_start(&h->er);\n        h->er.last_pic =\n        h->er.next_pic = NULL;\n    }\n\n    assert(h->linesize && h->uvlinesize);\n\n    for (i = 0; i < 16; i++) {\n        h->block_offset[i]           = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->linesize * ((scan8[i] - scan8[0]) >> 3);\n        h->block_offset[48 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->linesize * ((scan8[i] - scan8[0]) >> 3);\n    }\n    for (i = 0; i < 16; i++) {\n        h->block_offset[16 + i]      =\n        h->block_offset[32 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);\n        h->block_offset[48 + 16 + i] =\n        h->block_offset[48 + 32 + i] = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);\n    }\n\n    // s->decode = (h->flags & CODEC_FLAG_PSNR) || !s->encoding ||\n    //             h->cur_pic.reference /* || h->contains_intra */ || 1;\n\n    /* We mark the current picture as non-reference after allocating it, so\n     * that if we break out due to an error it can be released automatically\n     * in the next ff_MPV_frame_start().\n     */\n    h->cur_pic_ptr->reference = 0;\n\n    h->cur_pic_ptr->field_poc[0] = h->cur_pic_ptr->field_poc[1] = INT_MAX;\n\n    h->next_output_pic = NULL;\n\n    assert(h->cur_pic_ptr->long_ref == 0);\n\n    return 0;\n}\n\n/**\n * Run setup operations that must be run after slice header decoding.\n * This includes finding the next displayed frame.\n *\n * @param h h264 master context\n * @param setup_finished enough NALs have been read that we can call\n * ff_thread_finish_setup()\n */\nstatic void decode_postinit(H264Context *h, int setup_finished)\n{\n    Picture *out = h->cur_pic_ptr;\n    Picture *cur = h->cur_pic_ptr;\n    int i, pics, out_of_order, out_idx;\n\n    h->cur_pic_ptr->f.pict_type = h->pict_type;\n\n    if (h->next_output_pic)\n        return;\n\n    if (cur->field_poc[0] == INT_MAX || cur->field_poc[1] == INT_MAX) {\n        /* FIXME: if we have two PAFF fields in one packet, we can't start\n         * the next thread here. If we have one field per packet, we can.\n         * The check in decode_nal_units() is not good enough to find this\n         * yet, so we assume the worst for now. */\n        // if (setup_finished)\n        //    ff_thread_finish_setup(h->avctx);\n        return;\n    }\n\n    cur->f.interlaced_frame = 0;\n    cur->f.repeat_pict      = 0;\n\n    /* Signal interlacing information externally. */\n    /* Prioritize picture timing SEI information over used\n     * decoding process if it exists. */\n\n    if (h->sps.pic_struct_present_flag) {\n        switch (h->sei_pic_struct) {\n        case SEI_PIC_STRUCT_FRAME:\n            break;\n        case SEI_PIC_STRUCT_TOP_FIELD:\n        case SEI_PIC_STRUCT_BOTTOM_FIELD:\n            cur->f.interlaced_frame = 1;\n            break;\n        case SEI_PIC_STRUCT_TOP_BOTTOM:\n        case SEI_PIC_STRUCT_BOTTOM_TOP:\n            if (FIELD_OR_MBAFF_PICTURE(h))\n                cur->f.interlaced_frame = 1;\n            else\n                // try to flag soft telecine progressive\n                cur->f.interlaced_frame = h->prev_interlaced_frame;\n            break;\n        case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n        case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n            /* Signal the possibility of telecined film externally\n             * (pic_struct 5,6). From these hints, let the applications\n             * decide if they apply deinterlacing. */\n            cur->f.repeat_pict = 1;\n            break;\n        case SEI_PIC_STRUCT_FRAME_DOUBLING:\n            cur->f.repeat_pict = 2;\n            break;\n        case SEI_PIC_STRUCT_FRAME_TRIPLING:\n            cur->f.repeat_pict = 4;\n            break;\n        }\n\n        if ((h->sei_ct_type & 3) &&\n            h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)\n            cur->f.interlaced_frame = (h->sei_ct_type & (1 << 1)) != 0;\n    } else {\n        /* Derive interlacing flag from used decoding process. */\n        cur->f.interlaced_frame = FIELD_OR_MBAFF_PICTURE(h);\n    }\n    h->prev_interlaced_frame = cur->f.interlaced_frame;\n\n    if (cur->field_poc[0] != cur->field_poc[1]) {\n        /* Derive top_field_first from field pocs. */\n        cur->f.top_field_first = cur->field_poc[0] < cur->field_poc[1];\n    } else {\n        if (cur->f.interlaced_frame || h->sps.pic_struct_present_flag) {\n            /* Use picture timing SEI information. Even if it is a\n             * information of a past frame, better than nothing. */\n            if (h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM ||\n                h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)\n                cur->f.top_field_first = 1;\n            else\n                cur->f.top_field_first = 0;\n        } else {\n            /* Most likely progressive */\n            cur->f.top_field_first = 0;\n        }\n    }\n\n    cur->mmco_reset = h->mmco_reset;\n    h->mmco_reset = 0;\n    // FIXME do something with unavailable reference frames\n\n    /* Sort B-frames into display order */\n\n    if (h->sps.bitstream_restriction_flag &&\n        h->avctx->has_b_frames < h->sps.num_reorder_frames) {\n        h->avctx->has_b_frames = h->sps.num_reorder_frames;\n        h->low_delay           = 0;\n    }\n\n    if (h->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT &&\n        !h->sps.bitstream_restriction_flag) {\n        h->avctx->has_b_frames = MAX_DELAYED_PIC_COUNT - 1;\n        h->low_delay           = 0;\n    }\n\n    for (i = 0; 1; i++) {\n        if(i == MAX_DELAYED_PIC_COUNT || cur->poc < h->last_pocs[i]){\n            if(i)\n                h->last_pocs[i-1] = cur->poc;\n            break;\n        } else if(i) {\n            h->last_pocs[i-1]= h->last_pocs[i];\n        }\n    }\n    out_of_order = MAX_DELAYED_PIC_COUNT - i;\n    if(   cur->f.pict_type == AV_PICTURE_TYPE_B\n       || (h->last_pocs[MAX_DELAYED_PIC_COUNT-2] > INT_MIN && h->last_pocs[MAX_DELAYED_PIC_COUNT-1] - h->last_pocs[MAX_DELAYED_PIC_COUNT-2] > 2))\n        out_of_order = FFMAX(out_of_order, 1);\n    if (out_of_order == MAX_DELAYED_PIC_COUNT) {\n        av_log(h->avctx, AV_LOG_VERBOSE, \"Invalid POC %d<%d\\n\", cur->poc, h->last_pocs[0]);\n        for (i = 1; i < MAX_DELAYED_PIC_COUNT; i++)\n            h->last_pocs[i] = INT_MIN;\n        h->last_pocs[0] = cur->poc;\n        cur->mmco_reset = 1;\n    } else if(h->avctx->has_b_frames < out_of_order && !h->sps.bitstream_restriction_flag){\n        av_log(h->avctx, AV_LOG_VERBOSE, \"Increasing reorder buffer to %d\\n\", out_of_order);\n        h->avctx->has_b_frames = out_of_order;\n        h->low_delay = 0;\n    }\n\n    pics = 0;\n    while (h->delayed_pic[pics])\n        pics++;\n\n    av_assert0(pics <= MAX_DELAYED_PIC_COUNT);\n\n    h->delayed_pic[pics++] = cur;\n    if (cur->reference == 0)\n        cur->reference = DELAYED_PIC_REF;\n\n    out = h->delayed_pic[0];\n    out_idx = 0;\n    for (i = 1; h->delayed_pic[i] &&\n                !h->delayed_pic[i]->f.key_frame &&\n                !h->delayed_pic[i]->mmco_reset;\n         i++)\n        if (h->delayed_pic[i]->poc < out->poc) {\n            out     = h->delayed_pic[i];\n            out_idx = i;\n        }\n    if (h->avctx->has_b_frames == 0 &&\n        (h->delayed_pic[0]->f.key_frame || h->delayed_pic[0]->mmco_reset))\n        h->next_outputed_poc = INT_MIN;\n    out_of_order = out->poc < h->next_outputed_poc;\n\n    if (out_of_order || pics > h->avctx->has_b_frames) {\n        out->reference &= ~DELAYED_PIC_REF;\n        // for frame threading, the owner must be the second field's thread or\n        // else the first thread can release the picture and reuse it unsafely\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n    }\n    if (!out_of_order && pics > h->avctx->has_b_frames) {\n        h->next_output_pic = out;\n        if (out_idx == 0 && h->delayed_pic[0] && (h->delayed_pic[0]->f.key_frame || h->delayed_pic[0]->mmco_reset)) {\n            h->next_outputed_poc = INT_MIN;\n        } else\n            h->next_outputed_poc = out->poc;\n    } else {\n        av_log(h->avctx, AV_LOG_DEBUG, \"no picture %s\\n\", out_of_order ? \"ooo\" : \"\");\n    }\n\n    if (h->next_output_pic && h->next_output_pic->sync) {\n        h->sync |= 2;\n    }\n\n    if (setup_finished && !h->avctx->hwaccel)\n        ff_thread_finish_setup(h->avctx);\n}\n\nstatic av_always_inline void backup_mb_border(H264Context *h, uint8_t *src_y,\n                                              uint8_t *src_cb, uint8_t *src_cr,\n                                              int linesize, int uvlinesize,\n                                              int simple)\n{\n    uint8_t *top_border;\n    int top_idx = 1;\n    const int pixel_shift = h->pixel_shift;\n    int chroma444 = CHROMA444(h);\n    int chroma422 = CHROMA422(h);\n\n    src_y  -= linesize;\n    src_cb -= uvlinesize;\n    src_cr -= uvlinesize;\n\n    if (!simple && FRAME_MBAFF(h)) {\n        if (h->mb_y & 1) {\n            if (!MB_MBAFF(h)) {\n                top_border = h->top_borders[0][h->mb_x];\n                AV_COPY128(top_border, src_y + 15 * linesize);\n                if (pixel_shift)\n                    AV_COPY128(top_border + 16, src_y + 15 * linesize + 16);\n                if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n                    if (chroma444) {\n                        if (pixel_shift) {\n                            AV_COPY128(top_border + 32, src_cb + 15 * uvlinesize);\n                            AV_COPY128(top_border + 48, src_cb + 15 * uvlinesize + 16);\n                            AV_COPY128(top_border + 64, src_cr + 15 * uvlinesize);\n                            AV_COPY128(top_border + 80, src_cr + 15 * uvlinesize + 16);\n                        } else {\n                            AV_COPY128(top_border + 16, src_cb + 15 * uvlinesize);\n                            AV_COPY128(top_border + 32, src_cr + 15 * uvlinesize);\n                        }\n                    } else if (chroma422) {\n                        if (pixel_shift) {\n                            AV_COPY128(top_border + 32, src_cb + 15 * uvlinesize);\n                            AV_COPY128(top_border + 48, src_cr + 15 * uvlinesize);\n                        } else {\n                            AV_COPY64(top_border + 16, src_cb + 15 * uvlinesize);\n                            AV_COPY64(top_border + 24, src_cr + 15 * uvlinesize);\n                        }\n                    } else {\n                        if (pixel_shift) {\n                            AV_COPY128(top_border + 32, src_cb + 7 * uvlinesize);\n                            AV_COPY128(top_border + 48, src_cr + 7 * uvlinesize);\n                        } else {\n                            AV_COPY64(top_border + 16, src_cb + 7 * uvlinesize);\n                            AV_COPY64(top_border + 24, src_cr + 7 * uvlinesize);\n                        }\n                    }\n                }\n            }\n        } else if (MB_MBAFF(h)) {\n            top_idx = 0;\n        } else\n            return;\n    }\n\n    top_border = h->top_borders[top_idx][h->mb_x];\n    /* There are two lines saved, the line above the top macroblock\n     * of a pair, and the line above the bottom macroblock. */\n    AV_COPY128(top_border, src_y + 16 * linesize);\n    if (pixel_shift)\n        AV_COPY128(top_border + 16, src_y + 16 * linesize + 16);\n\n    if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n        if (chroma444) {\n            if (pixel_shift) {\n                AV_COPY128(top_border + 32, src_cb + 16 * linesize);\n                AV_COPY128(top_border + 48, src_cb + 16 * linesize + 16);\n                AV_COPY128(top_border + 64, src_cr + 16 * linesize);\n                AV_COPY128(top_border + 80, src_cr + 16 * linesize + 16);\n            } else {\n                AV_COPY128(top_border + 16, src_cb + 16 * linesize);\n                AV_COPY128(top_border + 32, src_cr + 16 * linesize);\n            }\n        } else if (chroma422) {\n            if (pixel_shift) {\n                AV_COPY128(top_border + 32, src_cb + 16 * uvlinesize);\n                AV_COPY128(top_border + 48, src_cr + 16 * uvlinesize);\n            } else {\n                AV_COPY64(top_border + 16, src_cb + 16 * uvlinesize);\n                AV_COPY64(top_border + 24, src_cr + 16 * uvlinesize);\n            }\n        } else {\n            if (pixel_shift) {\n                AV_COPY128(top_border + 32, src_cb + 8 * uvlinesize);\n                AV_COPY128(top_border + 48, src_cr + 8 * uvlinesize);\n            } else {\n                AV_COPY64(top_border + 16, src_cb + 8 * uvlinesize);\n                AV_COPY64(top_border + 24, src_cr + 8 * uvlinesize);\n            }\n        }\n    }\n}\n\nstatic av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,\n                                            uint8_t *src_cb, uint8_t *src_cr,\n                                            int linesize, int uvlinesize,\n                                            int xchg, int chroma444,\n                                            int simple, int pixel_shift)\n{\n    int deblock_topleft;\n    int deblock_top;\n    int top_idx = 1;\n    uint8_t *top_border_m1;\n    uint8_t *top_border;\n\n    if (!simple && FRAME_MBAFF(h)) {\n        if (h->mb_y & 1) {\n            if (!MB_MBAFF(h))\n                return;\n        } else {\n            top_idx = MB_MBAFF(h) ? 0 : 1;\n        }\n    }\n\n    if (h->deblocking_filter == 2) {\n        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;\n        deblock_top     = h->top_type;\n    } else {\n        deblock_topleft = (h->mb_x > 0);\n        deblock_top     = (h->mb_y > !!MB_FIELD(h));\n    }\n\n    src_y  -= linesize   + 1 + pixel_shift;\n    src_cb -= uvlinesize + 1 + pixel_shift;\n    src_cr -= uvlinesize + 1 + pixel_shift;\n\n    top_border_m1 = h->top_borders[top_idx][h->mb_x - 1];\n    top_border    = h->top_borders[top_idx][h->mb_x];\n\n#define XCHG(a, b, xchg)                        \\\n    if (pixel_shift) {                          \\\n        if (xchg) {                             \\\n            AV_SWAP64(b + 0, a + 0);            \\\n            AV_SWAP64(b + 8, a + 8);            \\\n        } else {                                \\\n            AV_COPY128(b, a);                   \\\n        }                                       \\\n    } else if (xchg)                            \\\n        AV_SWAP64(b, a);                        \\\n    else                                        \\\n        AV_COPY64(b, a);\n\n    if (deblock_top) {\n        if (deblock_topleft) {\n            XCHG(top_border_m1 + (8 << pixel_shift),\n                 src_y - (7 << pixel_shift), 1);\n        }\n        XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg);\n        XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1);\n        if (h->mb_x + 1 < h->mb_width) {\n            XCHG(h->top_borders[top_idx][h->mb_x + 1],\n                 src_y + (17 << pixel_shift), 1);\n        }\n        if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n            if (chroma444) {\n                if (deblock_topleft) {\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n                    XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n                }\n                XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg);\n                XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);\n                XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);\n                XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);\n                if (h->mb_x + 1 < h->mb_width) {\n                    XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);\n                    XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);\n                }\n            } else {\n                if (deblock_topleft) {\n                    XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n                }\n                XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);\n                XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);\n            }\n        }\n    }\n}\n\nstatic av_always_inline int dctcoef_get(int16_t *mb, int high_bit_depth,\n                                        int index)\n{\n    if (high_bit_depth) {\n        return AV_RN32A(((int32_t *)mb) + index);\n    } else\n        return AV_RN16A(mb + index);\n}\n\nstatic av_always_inline void dctcoef_set(int16_t *mb, int high_bit_depth,\n                                         int index, int value)\n{\n    if (high_bit_depth) {\n        AV_WN32A(((int32_t *)mb) + index, value);\n    } else\n        AV_WN16A(mb + index, value);\n}\n\nstatic av_always_inline void hl_decode_mb_predict_luma(H264Context *h,\n                                                       int mb_type, int is_h264,\n                                                       int simple,\n                                                       int transform_bypass,\n                                                       int pixel_shift,\n                                                       int *block_offset,\n                                                       int linesize,\n                                                       uint8_t *dest_y, int p)\n{\n    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);\n    void (*idct_dc_add)(uint8_t *dst, int16_t *block, int stride);\n    int i;\n    int qscale = p == 0 ? h->qscale : h->chroma_qp[p - 1];\n    block_offset += 16 * p;\n    if (IS_INTRA4x4(mb_type)) {\n        if (IS_8x8DCT(mb_type)) {\n            if (transform_bypass) {\n                idct_dc_add =\n                idct_add    = h->h264dsp.h264_add_pixels8_clear;\n            } else {\n                idct_dc_add = h->h264dsp.h264_idct8_dc_add;\n                idct_add    = h->h264dsp.h264_idct8_add;\n            }\n            for (i = 0; i < 16; i += 4) {\n                uint8_t *const ptr = dest_y + block_offset[i];\n                const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];\n                if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {\n                    h->hpc.pred8x8l_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                } else {\n                    const int nnz = h->non_zero_count_cache[scan8[i + p * 16]];\n                    h->hpc.pred8x8l[dir](ptr, (h->topleft_samples_available << i) & 0x8000,\n                                         (h->topright_samples_available << i) & 0x4000, linesize);\n                    if (nnz) {\n                        if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))\n                            idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                        else\n                            idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                    }\n                }\n            }\n        } else {\n            if (transform_bypass) {\n                idct_dc_add  =\n                idct_add     = h->h264dsp.h264_add_pixels4_clear;\n            } else {\n                idct_dc_add = h->h264dsp.h264_idct_dc_add;\n                idct_add    = h->h264dsp.h264_idct_add;\n            }\n            for (i = 0; i < 16; i++) {\n                uint8_t *const ptr = dest_y + block_offset[i];\n                const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];\n\n                if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {\n                    h->hpc.pred4x4_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                } else {\n                    uint8_t *topright;\n                    int nnz, tr;\n                    uint64_t tr_high;\n                    if (dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED) {\n                        const int topright_avail = (h->topright_samples_available << i) & 0x8000;\n                        av_assert2(h->mb_y || linesize <= block_offset[i]);\n                        if (!topright_avail) {\n                            if (pixel_shift) {\n                                tr_high  = ((uint16_t *)ptr)[3 - linesize / 2] * 0x0001000100010001ULL;\n                                topright = (uint8_t *)&tr_high;\n                            } else {\n                                tr       = ptr[3 - linesize] * 0x01010101u;\n                                topright = (uint8_t *)&tr;\n                            }\n                        } else\n                            topright = ptr + (4 << pixel_shift) - linesize;\n                    } else\n                        topright = NULL;\n\n                    h->hpc.pred4x4[dir](ptr, topright, linesize);\n                    nnz = h->non_zero_count_cache[scan8[i + p * 16]];\n                    if (nnz) {\n                        if (is_h264) {\n                            if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))\n                                idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                            else\n                                idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                        } else if (CONFIG_SVQ3_DECODER)\n                            ff_svq3_add_idct_c(ptr, h->mb + i * 16 + p * 256, linesize, qscale, 0);\n                    }\n                }\n            }\n        }\n    } else {\n        h->hpc.pred16x16[h->intra16x16_pred_mode](dest_y, linesize);\n        if (is_h264) {\n            if (h->non_zero_count_cache[scan8[LUMA_DC_BLOCK_INDEX + p]]) {\n                if (!transform_bypass)\n                    h->h264dsp.h264_luma_dc_dequant_idct(h->mb + (p * 256 << pixel_shift),\n                                                         h->mb_luma_dc[p],\n                                                         h->dequant4_coeff[p][qscale][0]);\n                else {\n                    static const uint8_t dc_mapping[16] = {\n                         0 * 16,  1 * 16,  4 * 16,  5 * 16,\n                         2 * 16,  3 * 16,  6 * 16,  7 * 16,\n                         8 * 16,  9 * 16, 12 * 16, 13 * 16,\n                        10 * 16, 11 * 16, 14 * 16, 15 * 16\n                    };\n                    for (i = 0; i < 16; i++)\n                        dctcoef_set(h->mb + (p * 256 << pixel_shift),\n                                    pixel_shift, dc_mapping[i],\n                                    dctcoef_get(h->mb_luma_dc[p],\n                                                pixel_shift, i));\n                }\n            }\n        } else if (CONFIG_SVQ3_DECODER)\n            ff_svq3_luma_dc_dequant_idct_c(h->mb + p * 256,\n                                           h->mb_luma_dc[p], qscale);\n    }\n}\n\nstatic av_always_inline void hl_decode_mb_idct_luma(H264Context *h, int mb_type,\n                                                    int is_h264, int simple,\n                                                    int transform_bypass,\n                                                    int pixel_shift,\n                                                    int *block_offset,\n                                                    int linesize,\n                                                    uint8_t *dest_y, int p)\n{\n    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);\n    int i;\n    block_offset += 16 * p;\n    if (!IS_INTRA4x4(mb_type)) {\n        if (is_h264) {\n            if (IS_INTRA16x16(mb_type)) {\n                if (transform_bypass) {\n                    if (h->sps.profile_idc == 244 &&\n                        (h->intra16x16_pred_mode == VERT_PRED8x8 ||\n                         h->intra16x16_pred_mode == HOR_PRED8x8)) {\n                        h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset,\n                                                                      h->mb + (p * 256 << pixel_shift),\n                                                                      linesize);\n                    } else {\n                        for (i = 0; i < 16; i++)\n                            if (h->non_zero_count_cache[scan8[i + p * 16]] ||\n                                dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))\n                                h->h264dsp.h264_add_pixels4_clear(dest_y + block_offset[i],\n                                                                  h->mb + (i * 16 + p * 256 << pixel_shift),\n                                                                  linesize);\n                    }\n                } else {\n                    h->h264dsp.h264_idct_add16intra(dest_y, block_offset,\n                                                    h->mb + (p * 256 << pixel_shift),\n                                                    linesize,\n                                                    h->non_zero_count_cache + p * 5 * 8);\n                }\n            } else if (h->cbp & 15) {\n                if (transform_bypass) {\n                    const int di = IS_8x8DCT(mb_type) ? 4 : 1;\n                    idct_add = IS_8x8DCT(mb_type) ? h->h264dsp.h264_add_pixels8_clear\n                                                  : h->h264dsp.h264_add_pixels4_clear;\n                    for (i = 0; i < 16; i += di)\n                        if (h->non_zero_count_cache[scan8[i + p * 16]])\n                            idct_add(dest_y + block_offset[i],\n                                     h->mb + (i * 16 + p * 256 << pixel_shift),\n                                     linesize);\n                } else {\n                    if (IS_8x8DCT(mb_type))\n                        h->h264dsp.h264_idct8_add4(dest_y, block_offset,\n                                                   h->mb + (p * 256 << pixel_shift),\n                                                   linesize,\n                                                   h->non_zero_count_cache + p * 5 * 8);\n                    else\n                        h->h264dsp.h264_idct_add16(dest_y, block_offset,\n                                                   h->mb + (p * 256 << pixel_shift),\n                                                   linesize,\n                                                   h->non_zero_count_cache + p * 5 * 8);\n                }\n            }\n        } else if (CONFIG_SVQ3_DECODER) {\n            for (i = 0; i < 16; i++)\n                if (h->non_zero_count_cache[scan8[i + p * 16]] || h->mb[i * 16 + p * 256]) {\n                    // FIXME benchmark weird rule, & below\n                    uint8_t *const ptr = dest_y + block_offset[i];\n                    ff_svq3_add_idct_c(ptr, h->mb + i * 16 + p * 256, linesize,\n                                       h->qscale, IS_INTRA(mb_type) ? 1 : 0);\n                }\n        }\n    }\n}\n\n#define BITS   8\n#define SIMPLE 1\n#include \"h264_mb_template.c\"\n\n#undef  BITS\n#define BITS   16\n#include \"h264_mb_template.c\"\n\n#undef  SIMPLE\n#define SIMPLE 0\n#include \"h264_mb_template.c\"\n\nvoid ff_h264_hl_decode_mb(H264Context *h)\n{\n    const int mb_xy   = h->mb_xy;\n    const int mb_type = h->cur_pic.mb_type[mb_xy];\n    int is_complex    = CONFIG_SMALL || h->is_complex ||\n                        IS_INTRA_PCM(mb_type) || h->qscale == 0;\n\n    if (CHROMA444(h)) {\n        if (is_complex || h->pixel_shift)\n            hl_decode_mb_444_complex(h);\n        else\n            hl_decode_mb_444_simple_8(h);\n    } else if (is_complex) {\n        hl_decode_mb_complex(h);\n    } else if (h->pixel_shift) {\n        hl_decode_mb_simple_16(h);\n    } else\n        hl_decode_mb_simple_8(h);\n}\n\nint ff_pred_weight_table(H264Context *h)\n{\n    int list, i;\n    int luma_def, chroma_def;\n\n    h->use_weight             = 0;\n    h->use_weight_chroma      = 0;\n    h->luma_log2_weight_denom = get_ue_golomb(&h->gb);\n    if (h->sps.chroma_format_idc)\n        h->chroma_log2_weight_denom = get_ue_golomb(&h->gb);\n    luma_def   = 1 << h->luma_log2_weight_denom;\n    chroma_def = 1 << h->chroma_log2_weight_denom;\n\n    for (list = 0; list < 2; list++) {\n        h->luma_weight_flag[list]   = 0;\n        h->chroma_weight_flag[list] = 0;\n        for (i = 0; i < h->ref_count[list]; i++) {\n            int luma_weight_flag, chroma_weight_flag;\n\n            luma_weight_flag = get_bits1(&h->gb);\n            if (luma_weight_flag) {\n                h->luma_weight[i][list][0] = get_se_golomb(&h->gb);\n                h->luma_weight[i][list][1] = get_se_golomb(&h->gb);\n                if (h->luma_weight[i][list][0] != luma_def ||\n                    h->luma_weight[i][list][1] != 0) {\n                    h->use_weight             = 1;\n                    h->luma_weight_flag[list] = 1;\n                }\n            } else {\n                h->luma_weight[i][list][0] = luma_def;\n                h->luma_weight[i][list][1] = 0;\n            }\n\n            if (h->sps.chroma_format_idc) {\n                chroma_weight_flag = get_bits1(&h->gb);\n                if (chroma_weight_flag) {\n                    int j;\n                    for (j = 0; j < 2; j++) {\n                        h->chroma_weight[i][list][j][0] = get_se_golomb(&h->gb);\n                        h->chroma_weight[i][list][j][1] = get_se_golomb(&h->gb);\n                        if (h->chroma_weight[i][list][j][0] != chroma_def ||\n                            h->chroma_weight[i][list][j][1] != 0) {\n                            h->use_weight_chroma        = 1;\n                            h->chroma_weight_flag[list] = 1;\n                        }\n                    }\n                } else {\n                    int j;\n                    for (j = 0; j < 2; j++) {\n                        h->chroma_weight[i][list][j][0] = chroma_def;\n                        h->chroma_weight[i][list][j][1] = 0;\n                    }\n                }\n            }\n        }\n        if (h->slice_type_nos != AV_PICTURE_TYPE_B)\n            break;\n    }\n    h->use_weight = h->use_weight || h->use_weight_chroma;\n    return 0;\n}\n\n/**\n * Initialize implicit_weight table.\n * @param field  0/1 initialize the weight for interlaced MBAFF\n *                -1 initializes the rest\n */\nstatic void implicit_weight_table(H264Context *h, int field)\n{\n    int ref0, ref1, i, cur_poc, ref_start, ref_count0, ref_count1;\n\n    for (i = 0; i < 2; i++) {\n        h->luma_weight_flag[i]   = 0;\n        h->chroma_weight_flag[i] = 0;\n    }\n\n    if (field < 0) {\n        if (h->picture_structure == PICT_FRAME) {\n            cur_poc = h->cur_pic_ptr->poc;\n        } else {\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure - 1];\n        }\n        if (h->ref_count[0] == 1 && h->ref_count[1] == 1 && !FRAME_MBAFF(h) &&\n            h->ref_list[0][0].poc + h->ref_list[1][0].poc == 2 * cur_poc) {\n            h->use_weight        = 0;\n            h->use_weight_chroma = 0;\n            return;\n        }\n        ref_start  = 0;\n        ref_count0 = h->ref_count[0];\n        ref_count1 = h->ref_count[1];\n    } else {\n        cur_poc    = h->cur_pic_ptr->field_poc[field];\n        ref_start  = 16;\n        ref_count0 = 16 + 2 * h->ref_count[0];\n        ref_count1 = 16 + 2 * h->ref_count[1];\n    }\n\n    h->use_weight               = 2;\n    h->use_weight_chroma        = 2;\n    h->luma_log2_weight_denom   = 5;\n    h->chroma_log2_weight_denom = 5;\n\n    for (ref0 = ref_start; ref0 < ref_count0; ref0++) {\n        int poc0 = h->ref_list[0][ref0].poc;\n        for (ref1 = ref_start; ref1 < ref_count1; ref1++) {\n            int w = 32;\n            if (!h->ref_list[0][ref0].long_ref && !h->ref_list[1][ref1].long_ref) {\n                int poc1 = h->ref_list[1][ref1].poc;\n                int td   = av_clip(poc1 - poc0, -128, 127);\n                if (td) {\n                    int tb = av_clip(cur_poc - poc0, -128, 127);\n                    int tx = (16384 + (FFABS(td) >> 1)) / td;\n                    int dist_scale_factor = (tb * tx + 32) >> 8;\n                    if (dist_scale_factor >= -64 && dist_scale_factor <= 128)\n                        w = 64 - dist_scale_factor;\n                }\n            }\n            if (field < 0) {\n                h->implicit_weight[ref0][ref1][0] =\n                h->implicit_weight[ref0][ref1][1] = w;\n            } else {\n                h->implicit_weight[ref0][ref1][field] = w;\n            }\n        }\n    }\n}\n\n/**\n * instantaneous decoder refresh.\n */\nstatic void idr(H264Context *h)\n{\n    int i;\n    ff_h264_remove_all_refs(h);\n    h->prev_frame_num        = 0;\n    h->prev_frame_num_offset = 0;\n    h->prev_poc_msb          = 1<<16;\n    h->prev_poc_lsb          = 0;\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n        h->last_pocs[i] = INT_MIN;\n}\n\n/* forget old pics after a seek */\nstatic void flush_change(H264Context *h)\n{\n    int i, j;\n\n    h->outputed_poc          = h->next_outputed_poc = INT_MIN;\n    h->prev_interlaced_frame = 1;\n    idr(h);\n\n    h->prev_frame_num = -1;\n    if (h->cur_pic_ptr) {\n        h->cur_pic_ptr->reference = 0;\n        for (j=i=0; h->delayed_pic[i]; i++)\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n                h->delayed_pic[j++] = h->delayed_pic[i];\n        h->delayed_pic[j] = NULL;\n    }\n    h->first_field = 0;\n    memset(h->ref_list[0], 0, sizeof(h->ref_list[0]));\n    memset(h->ref_list[1], 0, sizeof(h->ref_list[1]));\n    memset(h->default_ref_list[0], 0, sizeof(h->default_ref_list[0]));\n    memset(h->default_ref_list[1], 0, sizeof(h->default_ref_list[1]));\n    ff_h264_reset_sei(h);\n    h->recovery_frame= -1;\n    h->sync= 0;\n    h->list_count = 0;\n    h->current_slice = 0;\n}\n\n/* forget old pics after a seek */\nstatic void flush_dpb(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    int i;\n\n    for (i = 0; i <= MAX_DELAYED_PIC_COUNT; i++) {\n        if (h->delayed_pic[i])\n            h->delayed_pic[i]->reference = 0;\n        h->delayed_pic[i] = NULL;\n    }\n\n    flush_change(h);\n\n    if (h->DPB)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            unref_picture(h, &h->DPB[i]);\n    h->cur_pic_ptr = NULL;\n    unref_picture(h, &h->cur_pic);\n\n    h->mb_x = h->mb_y = 0;\n\n    h->parse_context.state             = -1;\n    h->parse_context.frame_start_found = 0;\n    h->parse_context.overread          = 0;\n    h->parse_context.overread_index    = 0;\n    h->parse_context.index             = 0;\n    h->parse_context.last_index        = 0;\n}\n\nint ff_init_poc(H264Context *h, int pic_field_poc[2], int *pic_poc)\n{\n    const int max_frame_num = 1 << h->sps.log2_max_frame_num;\n    int field_poc[2];\n\n    h->frame_num_offset = h->prev_frame_num_offset;\n    if (h->frame_num < h->prev_frame_num)\n        h->frame_num_offset += max_frame_num;\n\n    if (h->sps.poc_type == 0) {\n        const int max_poc_lsb = 1 << h->sps.log2_max_poc_lsb;\n\n        if (h->poc_lsb < h->prev_poc_lsb &&\n            h->prev_poc_lsb - h->poc_lsb >= max_poc_lsb / 2)\n            h->poc_msb = h->prev_poc_msb + max_poc_lsb;\n        else if (h->poc_lsb > h->prev_poc_lsb &&\n                 h->prev_poc_lsb - h->poc_lsb < -max_poc_lsb / 2)\n            h->poc_msb = h->prev_poc_msb - max_poc_lsb;\n        else\n            h->poc_msb = h->prev_poc_msb;\n        field_poc[0] =\n        field_poc[1] = h->poc_msb + h->poc_lsb;\n        if (h->picture_structure == PICT_FRAME)\n            field_poc[1] += h->delta_poc_bottom;\n    } else if (h->sps.poc_type == 1) {\n        int abs_frame_num, expected_delta_per_poc_cycle, expectedpoc;\n        int i;\n\n        if (h->sps.poc_cycle_length != 0)\n            abs_frame_num = h->frame_num_offset + h->frame_num;\n        else\n            abs_frame_num = 0;\n\n        if (h->nal_ref_idc == 0 && abs_frame_num > 0)\n            abs_frame_num--;\n\n        expected_delta_per_poc_cycle = 0;\n        for (i = 0; i < h->sps.poc_cycle_length; i++)\n            // FIXME integrate during sps parse\n            expected_delta_per_poc_cycle += h->sps.offset_for_ref_frame[i];\n\n        if (abs_frame_num > 0) {\n            int poc_cycle_cnt          = (abs_frame_num - 1) / h->sps.poc_cycle_length;\n            int frame_num_in_poc_cycle = (abs_frame_num - 1) % h->sps.poc_cycle_length;\n\n            expectedpoc = poc_cycle_cnt * expected_delta_per_poc_cycle;\n            for (i = 0; i <= frame_num_in_poc_cycle; i++)\n                expectedpoc = expectedpoc + h->sps.offset_for_ref_frame[i];\n        } else\n            expectedpoc = 0;\n\n        if (h->nal_ref_idc == 0)\n            expectedpoc = expectedpoc + h->sps.offset_for_non_ref_pic;\n\n        field_poc[0] = expectedpoc + h->delta_poc[0];\n        field_poc[1] = field_poc[0] + h->sps.offset_for_top_to_bottom_field;\n\n        if (h->picture_structure == PICT_FRAME)\n            field_poc[1] += h->delta_poc[1];\n    } else {\n        int poc = 2 * (h->frame_num_offset + h->frame_num);\n\n        if (!h->nal_ref_idc)\n            poc--;\n\n        field_poc[0] = poc;\n        field_poc[1] = poc;\n    }\n\n    if (h->picture_structure != PICT_BOTTOM_FIELD)\n        pic_field_poc[0] = field_poc[0];\n    if (h->picture_structure != PICT_TOP_FIELD)\n        pic_field_poc[1] = field_poc[1];\n    *pic_poc = FFMIN(pic_field_poc[0], pic_field_poc[1]);\n\n    return 0;\n}\n\n/**\n * initialize scan tables\n */\nstatic void init_scan_tables(H264Context *h)\n{\n    int i;\n    for (i = 0; i < 16; i++) {\n#define T(x) (x >> 2) | ((x << 2) & 0xF)\n        h->zigzag_scan[i] = T(zigzag_scan[i]);\n        h->field_scan[i]  = T(field_scan[i]);\n#undef T\n    }\n    for (i = 0; i < 64; i++) {\n#define T(x) (x >> 3) | ((x & 7) << 3)\n        h->zigzag_scan8x8[i]       = T(ff_zigzag_direct[i]);\n        h->zigzag_scan8x8_cavlc[i] = T(zigzag_scan8x8_cavlc[i]);\n        h->field_scan8x8[i]        = T(field_scan8x8[i]);\n        h->field_scan8x8_cavlc[i]  = T(field_scan8x8_cavlc[i]);\n#undef T\n    }\n    if (h->sps.transform_bypass) { // FIXME same ugly\n        memcpy(h->zigzag_scan_q0          , zigzag_scan             , sizeof(h->zigzag_scan_q0         ));\n        memcpy(h->zigzag_scan8x8_q0       , ff_zigzag_direct        , sizeof(h->zigzag_scan8x8_q0      ));\n        memcpy(h->zigzag_scan8x8_cavlc_q0 , zigzag_scan8x8_cavlc    , sizeof(h->zigzag_scan8x8_cavlc_q0));\n        memcpy(h->field_scan_q0           , field_scan              , sizeof(h->field_scan_q0          ));\n        memcpy(h->field_scan8x8_q0        , field_scan8x8           , sizeof(h->field_scan8x8_q0       ));\n        memcpy(h->field_scan8x8_cavlc_q0  , field_scan8x8_cavlc     , sizeof(h->field_scan8x8_cavlc_q0 ));\n    } else {\n        memcpy(h->zigzag_scan_q0          , h->zigzag_scan          , sizeof(h->zigzag_scan_q0         ));\n        memcpy(h->zigzag_scan8x8_q0       , h->zigzag_scan8x8       , sizeof(h->zigzag_scan8x8_q0      ));\n        memcpy(h->zigzag_scan8x8_cavlc_q0 , h->zigzag_scan8x8_cavlc , sizeof(h->zigzag_scan8x8_cavlc_q0));\n        memcpy(h->field_scan_q0           , h->field_scan           , sizeof(h->field_scan_q0          ));\n        memcpy(h->field_scan8x8_q0        , h->field_scan8x8        , sizeof(h->field_scan8x8_q0       ));\n        memcpy(h->field_scan8x8_cavlc_q0  , h->field_scan8x8_cavlc  , sizeof(h->field_scan8x8_cavlc_q0 ));\n    }\n}\n\nstatic int field_end(H264Context *h, int in_setup)\n{\n    AVCodecContext *const avctx = h->avctx;\n    int err = 0;\n    h->mb_y = 0;\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_set_reference_frames(h);\n\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (!h->droppable) {\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            h->prev_poc_msb = h->poc_msb;\n            h->prev_poc_lsb = h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n        h->outputed_poc          = h->next_outputed_poc;\n    }\n\n    if (avctx->hwaccel) {\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n\n    /*\n     * FIXME: Error handling code does not seem to support interlaced\n     * when slices span multiple rows\n     * The ff_er_add_slice calls don't work right for bottom\n     * fields; they cause massive erroneous error concealing\n     * Error marking covers both fields (top and bottom).\n     * This causes a mismatched s->error_count\n     * and a bad error table. Further, the error count goes to\n     * INT_MAX when called for bottom field, because mb_y is\n     * past end by one (callers fault) and resync_mb_y != 0\n     * causes problems for the first MB line, too.\n     */\n    if (CONFIG_ERROR_RESILIENCE &&\n        !FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\n        h->er.cur_pic  = h->cur_pic_ptr;\n        ff_er_frame_end(&h->er);\n    }\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n\n    h->current_slice = 0;\n\n    return err;\n}\n\n/**\n * Replicate H264 \"master\" context to thread contexts.\n */\nstatic int clone_slice(H264Context *dst, H264Context *src)\n{\n    memcpy(dst->block_offset, src->block_offset, sizeof(dst->block_offset));\n    dst->cur_pic_ptr = src->cur_pic_ptr;\n    dst->cur_pic     = src->cur_pic;\n    dst->linesize    = src->linesize;\n    dst->uvlinesize  = src->uvlinesize;\n    dst->first_field = src->first_field;\n\n    dst->prev_poc_msb          = src->prev_poc_msb;\n    dst->prev_poc_lsb          = src->prev_poc_lsb;\n    dst->prev_frame_num_offset = src->prev_frame_num_offset;\n    dst->prev_frame_num        = src->prev_frame_num;\n    dst->short_ref_count       = src->short_ref_count;\n\n    memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));\n    memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));\n    memcpy(dst->default_ref_list, src->default_ref_list, sizeof(dst->default_ref_list));\n\n    memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));\n    memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));\n\n    return 0;\n}\n\n/**\n * Compute profile from profile_idc and constraint_set?_flags.\n *\n * @param sps SPS\n *\n * @return profile as defined by FF_PROFILE_H264_*\n */\nint ff_h264_get_profile(SPS *sps)\n{\n    int profile = sps->profile_idc;\n\n    switch (sps->profile_idc) {\n    case FF_PROFILE_H264_BASELINE:\n        // constraint_set1_flag set to 1\n        profile |= (sps->constraint_set_flags & 1 << 1) ? FF_PROFILE_H264_CONSTRAINED : 0;\n        break;\n    case FF_PROFILE_H264_HIGH_10:\n    case FF_PROFILE_H264_HIGH_422:\n    case FF_PROFILE_H264_HIGH_444_PREDICTIVE:\n        // constraint_set3_flag set to 1\n        profile |= (sps->constraint_set_flags & 1 << 3) ? FF_PROFILE_H264_INTRA : 0;\n        break;\n    }\n\n    return profile;\n}\n\nstatic int h264_set_parameter_from_sps(H264Context *h)\n{\n    if (h->flags & CODEC_FLAG_LOW_DELAY ||\n        (h->sps.bitstream_restriction_flag &&\n         !h->sps.num_reorder_frames)) {\n        if (h->avctx->has_b_frames > 1 || h->delayed_pic[0])\n            av_log(h->avctx, AV_LOG_WARNING, \"Delayed frames seen. \"\n                   \"Reenabling low delay requires a codec flush.\\n\");\n        else\n            h->low_delay = 1;\n    }\n\n    if (h->avctx->has_b_frames < 2)\n        h->avctx->has_b_frames = !h->low_delay;\n\n    if (h->sps.bit_depth_luma != h->sps.bit_depth_chroma) {\n        avpriv_request_sample(h->avctx,\n                              \"Different chroma and luma bit depth\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||\n        h->cur_chroma_format_idc      != h->sps.chroma_format_idc) {\n        if (h->avctx->codec &&\n            h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU &&\n            (h->sps.bit_depth_luma != 8 || h->sps.chroma_format_idc > 1)) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"VDPAU decoding does not support video colorspace.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 14 &&\n            h->sps.bit_depth_luma != 11 && h->sps.bit_depth_luma != 13) {\n            h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;\n            h->cur_chroma_format_idc      = h->sps.chroma_format_idc;\n            h->pixel_shift                = h->sps.bit_depth_luma > 8;\n\n            ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,\n                            h->sps.chroma_format_idc);\n            ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma);\n            ff_h264qpel_init(&h->h264qpel, h->sps.bit_depth_luma);\n            ff_h264_pred_init(&h->hpc, h->avctx->codec_id, h->sps.bit_depth_luma,\n                              h->sps.chroma_format_idc);\n\n            if (CONFIG_ERROR_RESILIENCE)\n                ff_dsputil_init(&h->dsp, h->avctx);\n            ff_videodsp_init(&h->vdsp, h->sps.bit_depth_luma);\n        } else {\n            av_log(h->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\",\n                   h->sps.bit_depth_luma);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    return 0;\n}\n\nstatic enum AVPixelFormat get_pixel_format(H264Context *h, int force_callback)\n{\n    switch (h->sps.bit_depth_luma) {\n    case 9:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP9;\n            } else\n                return AV_PIX_FMT_YUV444P9;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P9;\n        else\n            return AV_PIX_FMT_YUV420P9;\n        break;\n    case 10:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP10;\n            } else\n                return AV_PIX_FMT_YUV444P10;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P10;\n        else\n            return AV_PIX_FMT_YUV420P10;\n        break;\n    case 12:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP12;\n            } else\n                return AV_PIX_FMT_YUV444P12;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P12;\n        else\n            return AV_PIX_FMT_YUV420P12;\n        break;\n    case 14:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP14;\n            } else\n                return AV_PIX_FMT_YUV444P14;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P14;\n        else\n            return AV_PIX_FMT_YUV420P14;\n        break;\n    case 8:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                av_log(h->avctx, AV_LOG_DEBUG, \"Detected GBR colorspace.\\n\");\n                return AV_PIX_FMT_GBR24P;\n            } else if (h->avctx->colorspace == AVCOL_SPC_YCGCO) {\n                av_log(h->avctx, AV_LOG_WARNING, \"Detected unsupported YCgCo colorspace.\\n\");\n            }\n            return h->avctx->color_range == AVCOL_RANGE_JPEG ? AV_PIX_FMT_YUVJ444P\n                                                                : AV_PIX_FMT_YUV444P;\n        } else if (CHROMA422(h)) {\n            return h->avctx->color_range == AVCOL_RANGE_JPEG ? AV_PIX_FMT_YUVJ422P\n                                                             : AV_PIX_FMT_YUV422P;\n        } else {\n            int i;\n            const enum AVPixelFormat * fmt = h->avctx->codec->pix_fmts ?\n                                        h->avctx->codec->pix_fmts :\n                                        h->avctx->color_range == AVCOL_RANGE_JPEG ?\n                                        h264_hwaccel_pixfmt_list_jpeg_420 :\n                                        h264_hwaccel_pixfmt_list_420;\n\n            for (i=0; fmt[i] != AV_PIX_FMT_NONE; i++)\n                if (fmt[i] == h->avctx->pix_fmt && !force_callback)\n                    return fmt[i];\n            return ff_thread_get_format(h->avctx, fmt);\n        }\n        break;\n    default:\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"Unsupported bit depth: %d\\n\", h->sps.bit_depth_luma);\n        return AVERROR_INVALIDDATA;\n    }\n}\n\n/* export coded and cropped frame dimensions to AVCodecContext */\nstatic int init_dimensions(H264Context *h)\n{\n    int width  = h->width  - (h->sps.crop_right + h->sps.crop_left);\n    int height = h->height - (h->sps.crop_top   + h->sps.crop_bottom);\n    av_assert0(h->sps.crop_right + h->sps.crop_left < (unsigned)h->width);\n    av_assert0(h->sps.crop_top + h->sps.crop_bottom < (unsigned)h->height);\n\n    /* handle container cropping */\n    if (!h->sps.crop &&\n        FFALIGN(h->avctx->width,  16) == h->width &&\n        FFALIGN(h->avctx->height, 16) == h->height) {\n        width  = h->avctx->width;\n        height = h->avctx->height;\n    }\n\n    if (width <= 0 || height <= 0) {\n        av_log(h->avctx, AV_LOG_ERROR, \"Invalid cropped dimensions: %dx%d.\\n\",\n               width, height);\n        if (h->avctx->err_recognition & AV_EF_EXPLODE)\n            return AVERROR_INVALIDDATA;\n\n        av_log(h->avctx, AV_LOG_WARNING, \"Ignoring cropping information.\\n\");\n        h->sps.crop_bottom = h->sps.crop_top = h->sps.crop_right = h->sps.crop_left = 0;\n        h->sps.crop        = 0;\n\n        width  = h->width;\n        height = h->height;\n    }\n\n    h->avctx->coded_width  = h->width;\n    h->avctx->coded_height = h->height;\n    h->avctx->width        = width;\n    h->avctx->height       = height;\n\n    return 0;\n}\n\nstatic int h264_slice_header_init(H264Context *h, int reinit)\n{\n    int nb_slices = (HAVE_THREADS &&\n                     h->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                    h->avctx->thread_count : 1;\n    int i, ret;\n\n    h->avctx->sample_aspect_ratio = h->sps.sar;\n    av_assert0(h->avctx->sample_aspect_ratio.den);\n    av_pix_fmt_get_chroma_sub_sample(h->avctx->pix_fmt,\n                                     &h->chroma_x_shift, &h->chroma_y_shift);\n\n    if (h->sps.timing_info_present_flag) {\n        int64_t den = h->sps.time_scale;\n        if (h->x264_build < 44U)\n            den *= 2;\n        av_reduce(&h->avctx->time_base.num, &h->avctx->time_base.den,\n                  h->sps.num_units_in_tick, den, 1 << 30);\n    }\n\n    h->avctx->hwaccel = ff_find_hwaccel(h->avctx->codec->id, h->avctx->pix_fmt);\n\n    if (reinit)\n        free_tables(h, 0);\n    h->first_field           = 0;\n    h->prev_interlaced_frame = 1;\n\n    init_scan_tables(h);\n    ret = ff_h264_alloc_tables(h);\n    if (ret < 0) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"Could not allocate memory for h264\\n\");\n        return ret;\n    }\n\n    if (nb_slices > MAX_THREADS || (nb_slices > h->mb_height && h->mb_height)) {\n        int max_slices;\n        if (h->mb_height)\n            max_slices = FFMIN(MAX_THREADS, h->mb_height);\n        else\n            max_slices = MAX_THREADS;\n        av_log(h->avctx, AV_LOG_WARNING, \"too many threads/slices (%d),\"\n               \" reducing to %d\\n\", nb_slices, max_slices);\n        nb_slices = max_slices;\n    }\n    h->slice_context_count = nb_slices;\n\n    if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_SLICE)) {\n        ret = context_init(h);\n        if (ret < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");\n            return ret;\n        }\n    } else {\n        for (i = 1; i < h->slice_context_count; i++) {\n            H264Context *c;\n            c                    = h->thread_context[i] = av_mallocz(sizeof(H264Context));\n            c->avctx             = h->avctx;\n            if (CONFIG_ERROR_RESILIENCE) {\n                c->dsp               = h->dsp;\n            }\n            c->vdsp              = h->vdsp;\n            c->h264dsp           = h->h264dsp;\n            c->h264qpel          = h->h264qpel;\n            c->h264chroma        = h->h264chroma;\n            c->sps               = h->sps;\n            c->pps               = h->pps;\n            c->pixel_shift       = h->pixel_shift;\n            c->cur_chroma_format_idc = h->cur_chroma_format_idc;\n            c->width             = h->width;\n            c->height            = h->height;\n            c->linesize          = h->linesize;\n            c->uvlinesize        = h->uvlinesize;\n            c->chroma_x_shift = h->chroma_x_shift;\n            c->chroma_y_shift = h->chroma_y_shift;\n            c->qscale            = h->qscale;\n            c->droppable         = h->droppable;\n            c->data_partitioning = h->data_partitioning;\n            c->low_delay         = h->low_delay;\n            c->mb_width          = h->mb_width;\n            c->mb_height         = h->mb_height;\n            c->mb_stride         = h->mb_stride;\n            c->mb_num            = h->mb_num;\n            c->flags             = h->flags;\n            c->workaround_bugs   = h->workaround_bugs;\n            c->pict_type         = h->pict_type;\n\n            init_scan_tables(c);\n            clone_tables(c, h, i);\n            c->context_initialized = 1;\n        }\n\n        for (i = 0; i < h->slice_context_count; i++)\n            if ((ret = context_init(h->thread_context[i])) < 0) {\n                av_log(h->avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");\n                return ret;\n            }\n    }\n\n    h->context_initialized = 1;\n\n    return 0;\n}\n\nint ff_set_ref_count(H264Context *h)\n{\n    int num_ref_idx_active_override_flag;\n\n    // set defaults, might be overridden a few lines later\n    h->ref_count[0] = h->pps.ref_count[0];\n    h->ref_count[1] = h->pps.ref_count[1];\n\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I) {\n        unsigned max[2];\n        max[0] = max[1] = h->picture_structure == PICT_FRAME ? 15 : 31;\n\n        if (h->slice_type_nos == AV_PICTURE_TYPE_B)\n            h->direct_spatial_mv_pred = get_bits1(&h->gb);\n        num_ref_idx_active_override_flag = get_bits1(&h->gb);\n\n        if (num_ref_idx_active_override_flag) {\n            h->ref_count[0] = get_ue_golomb(&h->gb) + 1;\n            if (h->slice_type_nos == AV_PICTURE_TYPE_B) {\n                h->ref_count[1] = get_ue_golomb(&h->gb) + 1;\n            } else\n                // full range is spec-ok in this case, even for frames\n                h->ref_count[1] = 1;\n        }\n\n        if (h->ref_count[0]-1 > max[0] || h->ref_count[1]-1 > max[1]){\n            av_log(h->avctx, AV_LOG_ERROR, \"reference overflow %u > %u or %u > %u\\n\", h->ref_count[0]-1, max[0], h->ref_count[1]-1, max[1]);\n            h->ref_count[0] = h->ref_count[1] = 0;\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (h->slice_type_nos == AV_PICTURE_TYPE_B)\n            h->list_count = 2;\n        else\n            h->list_count = 1;\n    } else {\n        h->list_count   = 0;\n        h->ref_count[0] = h->ref_count[1] = 0;\n    }\n\n    return 0;\n}\n\n/**\n * Decode a slice header.\n * This will also call ff_MPV_common_init() and frame_start() as needed.\n *\n * @param h h264context\n * @param h0 h264 master context (differs from 'h' when doing sliced based\n *           parallel decoding)\n *\n * @return 0 if okay, <0 if an error occurred, 1 if decoding must not be multithreaded\n */\nstatic int decode_slice_header(H264Context *h, H264Context *h0)\n{\n    unsigned int first_mb_in_slice;\n    unsigned int pps_id;\n    int ret;\n    unsigned int slice_type, tmp, i, j;\n    int last_pic_structure, last_pic_droppable;\n    int must_reinit;\n    int needs_reinit = 0;\n    int field_pic_flag, bottom_field_flag;\n\n    h->me.qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;\n    h->me.qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;\n\n    first_mb_in_slice = get_ue_golomb_long(&h->gb);\n\n    if (first_mb_in_slice == 0) { // FIXME better field boundary detection\n        if (h0->current_slice && FIELD_PICTURE(h)) {\n            field_end(h, 1);\n        }\n\n        h0->current_slice = 0;\n        if (!h0->first_field) {\n            if (h->cur_pic_ptr && !h->droppable) {\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n            }\n            h->cur_pic_ptr = NULL;\n        }\n    }\n\n    slice_type = get_ue_golomb_31(&h->gb);\n    if (slice_type > 9) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"slice type too large (%d) at %d %d\\n\",\n               slice_type, h->mb_x, h->mb_y);\n        return AVERROR_INVALIDDATA;\n    }\n    if (slice_type > 4) {\n        slice_type -= 5;\n        h->slice_type_fixed = 1;\n    } else\n        h->slice_type_fixed = 0;\n\n    slice_type = golomb_to_pict_type[slice_type];\n    h->slice_type     = slice_type;\n    h->slice_type_nos = slice_type & 3;\n\n    // to make a few old functions happy, it's wrong though\n    h->pict_type = h->slice_type;\n\n    pps_id = get_ue_golomb(&h->gb);\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %d out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!h0->pps_buffers[pps_id]) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"non-existing PPS %u referenced\\n\",\n               pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    h->pps = *h0->pps_buffers[pps_id];\n\n    if (!h0->sps_buffers[h->pps.sps_id]) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"non-existing SPS %u referenced\\n\",\n               h->pps.sps_id);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (h->pps.sps_id != h->current_sps_id ||\n        h0->sps_buffers[h->pps.sps_id]->new) {\n        h0->sps_buffers[h->pps.sps_id]->new = 0;\n\n        h->current_sps_id = h->pps.sps_id;\n        h->sps            = *h0->sps_buffers[h->pps.sps_id];\n\n        if (h->mb_width  != h->sps.mb_width ||\n            h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||\n            h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||\n            h->cur_chroma_format_idc != h->sps.chroma_format_idc\n        )\n            needs_reinit = 1;\n\n        if (h->bit_depth_luma    != h->sps.bit_depth_luma ||\n            h->chroma_format_idc != h->sps.chroma_format_idc) {\n            h->bit_depth_luma    = h->sps.bit_depth_luma;\n            h->chroma_format_idc = h->sps.chroma_format_idc;\n            needs_reinit         = 1;\n        }\n        if ((ret = h264_set_parameter_from_sps(h)) < 0)\n            return ret;\n    }\n\n    h->avctx->profile = ff_h264_get_profile(&h->sps);\n    h->avctx->level   = h->sps.level_idc;\n    h->avctx->refs    = h->sps.ref_frame_count;\n\n    must_reinit = (h->context_initialized &&\n                    (   16*h->sps.mb_width != h->avctx->coded_width\n                     || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height\n                     || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma\n                     || h->cur_chroma_format_idc != h->sps.chroma_format_idc\n                     || av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)\n                     || h->mb_width  != h->sps.mb_width\n                     || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)\n                    ));\n    if (h0->avctx->pix_fmt != get_pixel_format(h0, 0))\n        must_reinit = 1;\n\n    h->mb_width  = h->sps.mb_width;\n    h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);\n    h->mb_num    = h->mb_width * h->mb_height;\n    h->mb_stride = h->mb_width + 1;\n\n    h->b_stride = h->mb_width * 4;\n\n    h->chroma_y_shift = h->sps.chroma_format_idc <= 1; // 400 uses yuv420p\n\n    h->width  = 16 * h->mb_width;\n    h->height = 16 * h->mb_height;\n\n    ret = init_dimensions(h);\n    if (ret < 0)\n        return ret;\n\n    if (h->sps.video_signal_type_present_flag) {\n        h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG\n                                                    : AVCOL_RANGE_MPEG;\n        if (h->sps.colour_description_present_flag) {\n            if (h->avctx->colorspace != h->sps.colorspace)\n                needs_reinit = 1;\n            h->avctx->color_primaries = h->sps.color_primaries;\n            h->avctx->color_trc       = h->sps.color_trc;\n            h->avctx->colorspace      = h->sps.colorspace;\n        }\n    }\n\n    if (h->context_initialized &&\n        (h->width  != h->avctx->coded_width   ||\n         h->height != h->avctx->coded_height  ||\n         must_reinit ||\n         needs_reinit)) {\n        if (h != h0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"changing width/height on \"\n                   \"slice %d\\n\", h0->current_slice + 1);\n            return AVERROR_INVALIDDATA;\n        }\n\n        flush_change(h);\n\n        if ((ret = get_pixel_format(h, 1)) < 0)\n            return ret;\n        h->avctx->pix_fmt = ret;\n\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n               \"pix_fmt: %s\\n\", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));\n\n        if ((ret = h264_slice_header_init(h, 1)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"h264_slice_header_init() failed\\n\");\n            return ret;\n        }\n    }\n    if (!h->context_initialized) {\n        if (h != h0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        if ((ret = get_pixel_format(h, 1)) < 0)\n            return ret;\n        h->avctx->pix_fmt = ret;\n\n        if ((ret = h264_slice_header_init(h, 0)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"h264_slice_header_init() failed\\n\");\n            return ret;\n        }\n    }\n\n    if (h == h0 && h->dequant_coeff_pps != pps_id) {\n        h->dequant_coeff_pps = pps_id;\n        init_dequant_tables(h);\n    }\n\n    h->frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);\n\n    h->mb_mbaff        = 0;\n    h->mb_aff_frame    = 0;\n    last_pic_structure = h0->picture_structure;\n    last_pic_droppable = h0->droppable;\n    h->droppable       = h->nal_ref_idc == 0;\n    if (h->sps.frame_mbs_only_flag) {\n        h->picture_structure = PICT_FRAME;\n    } else {\n        if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {\n            av_log(h->avctx, AV_LOG_ERROR, \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");\n            return -1;\n        }\n        field_pic_flag = get_bits1(&h->gb);\n        if (field_pic_flag) {\n            bottom_field_flag = get_bits1(&h->gb);\n            h->picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n        } else {\n            h->picture_structure = PICT_FRAME;\n            h->mb_aff_frame      = h->sps.mb_aff;\n        }\n    }\n    h->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n\n    if (h0->current_slice != 0) {\n        if (last_pic_structure != h->picture_structure ||\n            last_pic_droppable != h->droppable) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n                   last_pic_structure, h->picture_structure);\n            h->picture_structure = last_pic_structure;\n            h->droppable         = last_pic_droppable;\n            return AVERROR_INVALIDDATA;\n        } else if (!h0->cur_pic_ptr) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"unset cur_pic_ptr on %d. slice\\n\",\n                   h0->current_slice + 1);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        /* Shorten frame num gaps so we don't have to allocate reference\n         * frames just to throw them away */\n        if (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0) {\n            int unwrap_prev_frame_num = h->prev_frame_num;\n            int max_frame_num         = 1 << h->sps.log2_max_frame_num;\n\n            if (unwrap_prev_frame_num > h->frame_num)\n                unwrap_prev_frame_num -= max_frame_num;\n\n            if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {\n                unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;\n                if (unwrap_prev_frame_num < 0)\n                    unwrap_prev_frame_num += max_frame_num;\n\n                h->prev_frame_num = unwrap_prev_frame_num;\n            }\n        }\n\n        /* See if we have a decoded first field looking for a pair...\n         * Here, we're using that to see if we should mark previously\n         * decode frames as \"finished\".\n         * We have to do that before the \"dummy\" in-between frame allocation,\n         * since that can modify h->cur_pic_ptr. */\n        if (h0->first_field) {\n            assert(h0->cur_pic_ptr);\n            assert(h0->cur_pic_ptr->f.data[0]);\n            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n            /* Mark old field/frame as completed */\n            if (!last_pic_droppable && h0->cur_pic_ptr->tf.owner == h0->avctx) {\n                ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                          last_pic_structure == PICT_BOTTOM_FIELD);\n            }\n\n            /* figure out if we have a complementary field pair */\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n                /* Previous field is unmatched. Don't display it, but let it\n                 * remain for reference if marked as such. */\n                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                              last_pic_structure == PICT_TOP_FIELD);\n                }\n            } else {\n                if (h0->cur_pic_ptr->frame_num != h->frame_num) {\n                    /* This and previous field were reference, but had\n                     * different frame_nums. Consider this field first in\n                     * pair. Throw away previous field except for reference\n                     * purposes. */\n                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n                        ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                                  last_pic_structure == PICT_TOP_FIELD);\n                    }\n                } else {\n                    /* Second field in complementary pair */\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n                           h->picture_structure == PICT_TOP_FIELD))) {\n                        av_log(h->avctx, AV_LOG_ERROR,\n                               \"Invalid field mode combination %d/%d\\n\",\n                               last_pic_structure, h->picture_structure);\n                        h->picture_structure = last_pic_structure;\n                        h->droppable         = last_pic_droppable;\n                        return AVERROR_INVALIDDATA;\n                    } else if (last_pic_droppable != h->droppable) {\n                        avpriv_request_sample(h->avctx,\n                                              \"Found reference and non-reference fields in the same frame, which\");\n                        h->picture_structure = last_pic_structure;\n                        h->droppable         = last_pic_droppable;\n                        return AVERROR_PATCHWELCOME;\n                    }\n                }\n            }\n        }\n\n        while (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0 && !h0->first_field &&\n               h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {\n            Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n                   h->frame_num, h->prev_frame_num);\n            if (!h->sps.gaps_in_frame_num_allowed_flag)\n                for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)\n                    h->last_pocs[i] = INT_MIN;\n            ret = h264_frame_start(h);\n            if (ret < 0)\n                return ret;\n            h->prev_frame_num++;\n            h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;\n            h->cur_pic_ptr->frame_num = h->prev_frame_num;\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            /* Error concealment: If a ref is missing, copy the previous ref\n             * in its place.\n             * FIXME: Avoiding a memcpy would be nice, but ref handling makes\n             * many assumptions about there being no actual duplicates.\n             * FIXME: This does not copy padding for out-of-frame motion\n             * vectors.  Given we are concealing a lost frame, this probably\n             * is not noticeable by comparison, but it should be fixed. */\n            if (h->short_ref_count) {\n                if (prev) {\n                    av_image_copy(h->short_ref[0]->f.data,\n                                  h->short_ref[0]->f.linesize,\n                                  (const uint8_t **)prev->f.data,\n                                  prev->f.linesize,\n                                  h->avctx->pix_fmt,\n                                  h->mb_width  * 16,\n                                  h->mb_height * 16);\n                    h->short_ref[0]->poc = prev->poc + 2;\n                }\n                h->short_ref[0]->frame_num = h->prev_frame_num;\n            }\n        }\n\n        /* See if we have a decoded first field looking for a pair...\n         * We're using that to see whether to continue decoding in that\n         * frame, or to allocate a new one. */\n        if (h0->first_field) {\n            assert(h0->cur_pic_ptr);\n            assert(h0->cur_pic_ptr->f.data[0]);\n            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n            /* figure out if we have a complementary field pair */\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n                /* Previous field is unmatched. Don't display it, but let it\n                 * remain for reference if marked as such. */\n                h0->cur_pic_ptr = NULL;\n                h0->first_field = FIELD_PICTURE(h);\n            } else {\n                if (h0->cur_pic_ptr->frame_num != h->frame_num) {\n                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                              h0->picture_structure==PICT_BOTTOM_FIELD);\n                    /* This and the previous field had different frame_nums.\n                     * Consider this field first in pair. Throw away previous\n                     * one except for reference purposes. */\n                    h0->first_field = 1;\n                    h0->cur_pic_ptr = NULL;\n                } else {\n                    /* Second field in complementary pair */\n                    h0->first_field = 0;\n                }\n            }\n        } else {\n            /* Frame or first field in a potentially complementary pair */\n            h0->first_field = FIELD_PICTURE(h);\n        }\n\n        if (!FIELD_PICTURE(h) || h0->first_field) {\n            if (h264_frame_start(h) < 0) {\n                h0->first_field = 0;\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            release_unused_pictures(h, 0);\n        }\n        /* Some macroblocks can be accessed before they're available in case\n        * of lost slices, MBAFF or threading. */\n        if (FIELD_PICTURE(h)) {\n            for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)\n                memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));\n        } else {\n            memset(h->slice_table, -1,\n                (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n        }\n        h0->last_slice_type = -1;\n    }\n    if (h != h0 && (ret = clone_slice(h, h0)) < 0)\n        return ret;\n\n    /* can't be in alloc_tables because linesize isn't known there.\n     * FIXME: redo bipred weight to not require extra buffer? */\n    for (i = 0; i < h->slice_context_count; i++)\n        if (h->thread_context[i]) {\n            ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);\n            if (ret < 0)\n                return ret;\n        }\n\n    h->cur_pic_ptr->frame_num = h->frame_num; // FIXME frame_num cleanup\n\n    av_assert1(h->mb_num == h->mb_width * h->mb_height);\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n        first_mb_in_slice >= h->mb_num) {\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;\n    h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<\n                               FIELD_OR_MBAFF_PICTURE(h);\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n        h->resync_mb_y = h->mb_y = h->mb_y + 1;\n    av_assert1(h->mb_y < h->mb_height);\n\n    if (h->picture_structure == PICT_FRAME) {\n        h->curr_pic_num = h->frame_num;\n        h->max_pic_num  = 1 << h->sps.log2_max_frame_num;\n    } else {\n        h->curr_pic_num = 2 * h->frame_num + 1;\n        h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);\n    }\n\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n        get_ue_golomb(&h->gb); /* idr_pic_id */\n\n    if (h->sps.poc_type == 0) {\n        h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);\n\n        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)\n            h->delta_poc_bottom = get_se_golomb(&h->gb);\n    }\n\n    if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {\n        h->delta_poc[0] = get_se_golomb(&h->gb);\n\n        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)\n            h->delta_poc[1] = get_se_golomb(&h->gb);\n    }\n\n    ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);\n\n    if (h->pps.redundant_pic_cnt_present)\n        h->redundant_pic_count = get_ue_golomb(&h->gb);\n\n    ret = ff_set_ref_count(h);\n    if (ret < 0)\n        return ret;\n\n    if (slice_type != AV_PICTURE_TYPE_I &&\n        (h0->current_slice == 0 ||\n         slice_type != h0->last_slice_type ||\n         memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {\n\n        ff_h264_fill_default_ref_list(h);\n    }\n\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I) {\n       ret = ff_h264_decode_ref_pic_list_reordering(h);\n       if (ret < 0) {\n           h->ref_count[1] = h->ref_count[0] = 0;\n           return ret;\n       }\n    }\n\n    if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||\n        (h->pps.weighted_bipred_idc == 1 &&\n         h->slice_type_nos == AV_PICTURE_TYPE_B))\n        ff_pred_weight_table(h);\n    else if (h->pps.weighted_bipred_idc == 2 &&\n             h->slice_type_nos == AV_PICTURE_TYPE_B) {\n        implicit_weight_table(h, -1);\n    } else {\n        h->use_weight = 0;\n        for (i = 0; i < 2; i++) {\n            h->luma_weight_flag[i]   = 0;\n            h->chroma_weight_flag[i] = 0;\n        }\n    }\n\n    // If frame-mt is enabled, only update mmco tables for the first slice\n    // in a field. Subsequent slices can temporarily clobber h->mmco_index\n    // or h->mmco, which will cause ref list mix-ups and decoding errors\n    // further down the line. This may break decoding if the first slice is\n    // corrupt, thus we only do this if frame-mt is enabled.\n    if (h->nal_ref_idc) {\n        ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n                                             h0->current_slice == 0);\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n            return AVERROR_INVALIDDATA;\n    }\n\n    if (FRAME_MBAFF(h)) {\n        ff_h264_fill_mbaff_ref_list(h);\n\n        if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {\n            implicit_weight_table(h, 0);\n            implicit_weight_table(h, 1);\n        }\n    }\n\n    if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)\n        ff_h264_direct_dist_scale_factor(h);\n    ff_h264_direct_ref_list_init(h);\n\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {\n        tmp = get_ue_golomb_31(&h->gb);\n        if (tmp > 2) {\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc overflow\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        h->cabac_init_idc = tmp;\n    }\n\n    h->last_qscale_diff = 0;\n    tmp = h->pps.init_qp + get_se_golomb(&h->gb);\n    if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n        return AVERROR_INVALIDDATA;\n    }\n    h->qscale       = tmp;\n    h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);\n    h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);\n    // FIXME qscale / qp ... stuff\n    if (h->slice_type == AV_PICTURE_TYPE_SP)\n        get_bits1(&h->gb); /* sp_for_switch_flag */\n    if (h->slice_type == AV_PICTURE_TYPE_SP ||\n        h->slice_type == AV_PICTURE_TYPE_SI)\n        get_se_golomb(&h->gb); /* slice_qs_delta */\n\n    h->deblocking_filter     = 1;\n    h->slice_alpha_c0_offset = 52;\n    h->slice_beta_offset     = 52;\n    if (h->pps.deblocking_filter_parameters_present) {\n        tmp = get_ue_golomb_31(&h->gb);\n        if (tmp > 2) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n            return AVERROR_INVALIDDATA;\n        }\n        h->deblocking_filter = tmp;\n        if (h->deblocking_filter < 2)\n            h->deblocking_filter ^= 1;  // 1<->0\n\n        if (h->deblocking_filter) {\n            h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;\n            h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;\n            if (h->slice_alpha_c0_offset > 104U ||\n                h->slice_beta_offset     > 104U) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"deblocking filter parameters %d %d out of range\\n\",\n                       h->slice_alpha_c0_offset, h->slice_beta_offset);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n\n    if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&\n         h->slice_type_nos != AV_PICTURE_TYPE_I) ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&\n         h->slice_type_nos == AV_PICTURE_TYPE_B) ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&\n         h->nal_ref_idc == 0))\n        h->deblocking_filter = 0;\n\n    if (h->deblocking_filter == 1 && h0->max_contexts > 1) {\n        if (h->avctx->flags2 & CODEC_FLAG2_FAST) {\n            /* Cheat slightly for speed:\n             * Do not bother to deblock across slices. */\n            h->deblocking_filter = 2;\n        } else {\n            h0->max_contexts = 1;\n            if (!h0->single_decode_warning) {\n                av_log(h->avctx, AV_LOG_INFO,\n                       \"Cannot parallelize deblocking type 1, decoding such frames in sequential order\\n\");\n                h0->single_decode_warning = 1;\n            }\n            if (h != h0) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"Deblocking switched inside frame.\\n\");\n                return 1;\n            }\n        }\n    }\n    h->qp_thresh = 15 + 52 -\n                   FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -\n                   FFMAX3(0,\n                          h->pps.chroma_qp_index_offset[0],\n                          h->pps.chroma_qp_index_offset[1]) +\n                   6 * (h->sps.bit_depth_luma - 8);\n\n    h0->last_slice_type = slice_type;\n    memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));\n    h->slice_num        = ++h0->current_slice;\n\n    if (h->slice_num)\n        h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;\n    if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y\n        && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y\n        && h->slice_num >= MAX_SLICES) {\n        //in case of ASO this check needs to be updated depending on how we decide to assign slice numbers in this case\n        av_log(h->avctx, AV_LOG_WARNING, \"Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\\n\", h->slice_num, MAX_SLICES);\n    }\n\n    for (j = 0; j < 2; j++) {\n        int id_list[16];\n        int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];\n        for (i = 0; i < 16; i++) {\n            id_list[i] = 60;\n            if (j < h->list_count && i < h->ref_count[j] &&\n                h->ref_list[j][i].f.buf[0]) {\n                int k;\n                AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;\n                for (k = 0; k < h->short_ref_count; k++)\n                    if (h->short_ref[k]->f.buf[0]->buffer == buf) {\n                        id_list[i] = k;\n                        break;\n                    }\n                for (k = 0; k < h->long_ref_count; k++)\n                    if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {\n                        id_list[i] = h->short_ref_count + k;\n                        break;\n                    }\n            }\n        }\n\n        ref2frm[0] =\n        ref2frm[1] = -1;\n        for (i = 0; i < 16; i++)\n            ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);\n        ref2frm[18 + 0] =\n        ref2frm[18 + 1] = -1;\n        for (i = 16; i < 48; i++)\n            ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +\n                             (h->ref_list[j][i].reference & 3);\n    }\n\n    if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];\n    if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];\n    h->er.ref_count = h->ref_count[0];\n\n    if (h->avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(h->avctx, AV_LOG_DEBUG,\n               \"slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\\n\",\n               h->slice_num,\n               (h->picture_structure == PICT_FRAME ? \"F\" : h->picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\"),\n               first_mb_in_slice,\n               av_get_picture_type_char(h->slice_type),\n               h->slice_type_fixed ? \" fix\" : \"\",\n               h->nal_unit_type == NAL_IDR_SLICE ? \" IDR\" : \"\",\n               pps_id, h->frame_num,\n               h->cur_pic_ptr->field_poc[0],\n               h->cur_pic_ptr->field_poc[1],\n               h->ref_count[0], h->ref_count[1],\n               h->qscale,\n               h->deblocking_filter,\n               h->slice_alpha_c0_offset / 2 - 26, h->slice_beta_offset / 2 - 26,\n               h->use_weight,\n               h->use_weight == 1 && h->use_weight_chroma ? \"c\" : \"\",\n               h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\") : \"\");\n    }\n\n    return 0;\n}\n\nint ff_h264_get_slice_type(const H264Context *h)\n{\n    switch (h->slice_type) {\n    case AV_PICTURE_TYPE_P:\n        return 0;\n    case AV_PICTURE_TYPE_B:\n        return 1;\n    case AV_PICTURE_TYPE_I:\n        return 2;\n    case AV_PICTURE_TYPE_SP:\n        return 3;\n    case AV_PICTURE_TYPE_SI:\n        return 4;\n    default:\n        return AVERROR_INVALIDDATA;\n    }\n}\n\nstatic av_always_inline void fill_filter_caches_inter(H264Context *h,\n                                                      int mb_type, int top_xy,\n                                                      int left_xy[LEFT_MBS],\n                                                      int top_type,\n                                                      int left_type[LEFT_MBS],\n                                                      int mb_xy, int list)\n{\n    int b_stride = h->b_stride;\n    int16_t(*mv_dst)[2] = &h->mv_cache[list][scan8[0]];\n    int8_t *ref_cache = &h->ref_cache[list][scan8[0]];\n    if (IS_INTER(mb_type) || IS_DIRECT(mb_type)) {\n        if (USES_LIST(top_type, list)) {\n            const int b_xy  = h->mb2b_xy[top_xy] + 3 * b_stride;\n            const int b8_xy = 4 * top_xy + 2;\n            int (*ref2frm)[64] = (void*)(h->ref2frm[h->slice_table[top_xy] & (MAX_SLICES - 1)][0] + (MB_MBAFF(h) ? 20 : 2));\n            AV_COPY128(mv_dst - 1 * 8, h->cur_pic.motion_val[list][b_xy + 0]);\n            ref_cache[0 - 1 * 8] =\n            ref_cache[1 - 1 * 8] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 0]];\n            ref_cache[2 - 1 * 8] =\n            ref_cache[3 - 1 * 8] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 1]];\n        } else {\n            AV_ZERO128(mv_dst - 1 * 8);\n            AV_WN32A(&ref_cache[0 - 1 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        }\n\n        if (!IS_INTERLACED(mb_type ^ left_type[LTOP])) {\n            if (USES_LIST(left_type[LTOP], list)) {\n                const int b_xy  = h->mb2b_xy[left_xy[LTOP]] + 3;\n                const int b8_xy = 4 * left_xy[LTOP] + 1;\n                int (*ref2frm)[64] =(void*)( h->ref2frm[h->slice_table[left_xy[LTOP]] & (MAX_SLICES - 1)][0] + (MB_MBAFF(h) ? 20 : 2));\n                AV_COPY32(mv_dst - 1 +  0, h->cur_pic.motion_val[list][b_xy + b_stride * 0]);\n                AV_COPY32(mv_dst - 1 +  8, h->cur_pic.motion_val[list][b_xy + b_stride * 1]);\n                AV_COPY32(mv_dst - 1 + 16, h->cur_pic.motion_val[list][b_xy + b_stride * 2]);\n                AV_COPY32(mv_dst - 1 + 24, h->cur_pic.motion_val[list][b_xy + b_stride * 3]);\n                ref_cache[-1 +  0] =\n                ref_cache[-1 +  8] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 2 * 0]];\n                ref_cache[-1 + 16] =\n                ref_cache[-1 + 24] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 2 * 1]];\n            } else {\n                AV_ZERO32(mv_dst - 1 +  0);\n                AV_ZERO32(mv_dst - 1 +  8);\n                AV_ZERO32(mv_dst - 1 + 16);\n                AV_ZERO32(mv_dst - 1 + 24);\n                ref_cache[-1 +  0] =\n                ref_cache[-1 +  8] =\n                ref_cache[-1 + 16] =\n                ref_cache[-1 + 24] = LIST_NOT_USED;\n            }\n        }\n    }\n\n    if (!USES_LIST(mb_type, list)) {\n        fill_rectangle(mv_dst, 4, 4, 8, pack16to32(0, 0), 4);\n        AV_WN32A(&ref_cache[0 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        AV_WN32A(&ref_cache[1 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        AV_WN32A(&ref_cache[2 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        AV_WN32A(&ref_cache[3 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        return;\n    }\n\n    {\n        int8_t *ref = &h->cur_pic.ref_index[list][4 * mb_xy];\n        int (*ref2frm)[64] = (void*)(h->ref2frm[h->slice_num & (MAX_SLICES - 1)][0] + (MB_MBAFF(h) ? 20 : 2));\n        uint32_t ref01 = (pack16to32(ref2frm[list][ref[0]], ref2frm[list][ref[1]]) & 0x00FF00FF) * 0x0101;\n        uint32_t ref23 = (pack16to32(ref2frm[list][ref[2]], ref2frm[list][ref[3]]) & 0x00FF00FF) * 0x0101;\n        AV_WN32A(&ref_cache[0 * 8], ref01);\n        AV_WN32A(&ref_cache[1 * 8], ref01);\n        AV_WN32A(&ref_cache[2 * 8], ref23);\n        AV_WN32A(&ref_cache[3 * 8], ref23);\n    }\n\n    {\n        int16_t(*mv_src)[2] = &h->cur_pic.motion_val[list][4 * h->mb_x + 4 * h->mb_y * b_stride];\n        AV_COPY128(mv_dst + 8 * 0, mv_src + 0 * b_stride);\n        AV_COPY128(mv_dst + 8 * 1, mv_src + 1 * b_stride);\n        AV_COPY128(mv_dst + 8 * 2, mv_src + 2 * b_stride);\n        AV_COPY128(mv_dst + 8 * 3, mv_src + 3 * b_stride);\n    }\n}\n\n/**\n *\n * @return non zero if the loop filter can be skipped\n */\nstatic int fill_filter_caches(H264Context *h, int mb_type)\n{\n    const int mb_xy = h->mb_xy;\n    int top_xy, left_xy[LEFT_MBS];\n    int top_type, left_type[LEFT_MBS];\n    uint8_t *nnz;\n    uint8_t *nnz_cache;\n\n    top_xy = mb_xy - (h->mb_stride << MB_FIELD(h));\n\n    /* Wow, what a mess, why didn't they simplify the interlacing & intra\n     * stuff, I can't imagine that these complex rules are worth it. */\n\n    left_xy[LBOT] = left_xy[LTOP] = mb_xy - 1;\n    if (FRAME_MBAFF(h)) {\n        const int left_mb_field_flag = IS_INTERLACED(h->cur_pic.mb_type[mb_xy - 1]);\n        const int curr_mb_field_flag = IS_INTERLACED(mb_type);\n        if (h->mb_y & 1) {\n            if (left_mb_field_flag != curr_mb_field_flag)\n                left_xy[LTOP] -= h->mb_stride;\n        } else {\n            if (curr_mb_field_flag)\n                top_xy += h->mb_stride &\n                          (((h->cur_pic.mb_type[top_xy] >> 7) & 1) - 1);\n            if (left_mb_field_flag != curr_mb_field_flag)\n                left_xy[LBOT] += h->mb_stride;\n        }\n    }\n\n    h->top_mb_xy        = top_xy;\n    h->left_mb_xy[LTOP] = left_xy[LTOP];\n    h->left_mb_xy[LBOT] = left_xy[LBOT];\n    {\n        /* For sufficiently low qp, filtering wouldn't do anything.\n         * This is a conservative estimate: could also check beta_offset\n         * and more accurate chroma_qp. */\n        int qp_thresh = h->qp_thresh; // FIXME strictly we should store qp_thresh for each mb of a slice\n        int qp        = h->cur_pic.qscale_table[mb_xy];\n        if (qp <= qp_thresh &&\n            (left_xy[LTOP] < 0 ||\n             ((qp + h->cur_pic.qscale_table[left_xy[LTOP]] + 1) >> 1) <= qp_thresh) &&\n            (top_xy < 0 ||\n             ((qp + h->cur_pic.qscale_table[top_xy] + 1) >> 1) <= qp_thresh)) {\n            if (!FRAME_MBAFF(h))\n                return 1;\n            if ((left_xy[LTOP] < 0 ||\n                 ((qp + h->cur_pic.qscale_table[left_xy[LBOT]] + 1) >> 1) <= qp_thresh) &&\n                (top_xy < h->mb_stride ||\n                 ((qp + h->cur_pic.qscale_table[top_xy - h->mb_stride] + 1) >> 1) <= qp_thresh))\n                return 1;\n        }\n    }\n\n    top_type        = h->cur_pic.mb_type[top_xy];\n    left_type[LTOP] = h->cur_pic.mb_type[left_xy[LTOP]];\n    left_type[LBOT] = h->cur_pic.mb_type[left_xy[LBOT]];\n    if (h->deblocking_filter == 2) {\n        if (h->slice_table[top_xy] != h->slice_num)\n            top_type = 0;\n        if (h->slice_table[left_xy[LBOT]] != h->slice_num)\n            left_type[LTOP] = left_type[LBOT] = 0;\n    } else {\n        if (h->slice_table[top_xy] == 0xFFFF)\n            top_type = 0;\n        if (h->slice_table[left_xy[LBOT]] == 0xFFFF)\n            left_type[LTOP] = left_type[LBOT] = 0;\n    }\n    h->top_type        = top_type;\n    h->left_type[LTOP] = left_type[LTOP];\n    h->left_type[LBOT] = left_type[LBOT];\n\n    if (IS_INTRA(mb_type))\n        return 0;\n\n    fill_filter_caches_inter(h, mb_type, top_xy, left_xy,\n                             top_type, left_type, mb_xy, 0);\n    if (h->list_count == 2)\n        fill_filter_caches_inter(h, mb_type, top_xy, left_xy,\n                                 top_type, left_type, mb_xy, 1);\n\n    nnz       = h->non_zero_count[mb_xy];\n    nnz_cache = h->non_zero_count_cache;\n    AV_COPY32(&nnz_cache[4 + 8 * 1], &nnz[0]);\n    AV_COPY32(&nnz_cache[4 + 8 * 2], &nnz[4]);\n    AV_COPY32(&nnz_cache[4 + 8 * 3], &nnz[8]);\n    AV_COPY32(&nnz_cache[4 + 8 * 4], &nnz[12]);\n    h->cbp = h->cbp_table[mb_xy];\n\n    if (top_type) {\n        nnz = h->non_zero_count[top_xy];\n        AV_COPY32(&nnz_cache[4 + 8 * 0], &nnz[3 * 4]);\n    }\n\n    if (left_type[LTOP]) {\n        nnz = h->non_zero_count[left_xy[LTOP]];\n        nnz_cache[3 + 8 * 1] = nnz[3 + 0 * 4];\n        nnz_cache[3 + 8 * 2] = nnz[3 + 1 * 4];\n        nnz_cache[3 + 8 * 3] = nnz[3 + 2 * 4];\n        nnz_cache[3 + 8 * 4] = nnz[3 + 3 * 4];\n    }\n\n    /* CAVLC 8x8dct requires NNZ values for residual decoding that differ\n     * from what the loop filter needs */\n    if (!CABAC(h) && h->pps.transform_8x8_mode) {\n        if (IS_8x8DCT(top_type)) {\n            nnz_cache[4 + 8 * 0] =\n            nnz_cache[5 + 8 * 0] = (h->cbp_table[top_xy] & 0x4000) >> 12;\n            nnz_cache[6 + 8 * 0] =\n            nnz_cache[7 + 8 * 0] = (h->cbp_table[top_xy] & 0x8000) >> 12;\n        }\n        if (IS_8x8DCT(left_type[LTOP])) {\n            nnz_cache[3 + 8 * 1] =\n            nnz_cache[3 + 8 * 2] = (h->cbp_table[left_xy[LTOP]] & 0x2000) >> 12; // FIXME check MBAFF\n        }\n        if (IS_8x8DCT(left_type[LBOT])) {\n            nnz_cache[3 + 8 * 3] =\n            nnz_cache[3 + 8 * 4] = (h->cbp_table[left_xy[LBOT]] & 0x8000) >> 12; // FIXME check MBAFF\n        }\n\n        if (IS_8x8DCT(mb_type)) {\n            nnz_cache[scan8[0]] =\n            nnz_cache[scan8[1]] =\n            nnz_cache[scan8[2]] =\n            nnz_cache[scan8[3]] = (h->cbp & 0x1000) >> 12;\n\n            nnz_cache[scan8[0 + 4]] =\n            nnz_cache[scan8[1 + 4]] =\n            nnz_cache[scan8[2 + 4]] =\n            nnz_cache[scan8[3 + 4]] = (h->cbp & 0x2000) >> 12;\n\n            nnz_cache[scan8[0 + 8]] =\n            nnz_cache[scan8[1 + 8]] =\n            nnz_cache[scan8[2 + 8]] =\n            nnz_cache[scan8[3 + 8]] = (h->cbp & 0x4000) >> 12;\n\n            nnz_cache[scan8[0 + 12]] =\n            nnz_cache[scan8[1 + 12]] =\n            nnz_cache[scan8[2 + 12]] =\n            nnz_cache[scan8[3 + 12]] = (h->cbp & 0x8000) >> 12;\n        }\n    }\n\n    return 0;\n}\n\nstatic void loop_filter(H264Context *h, int start_x, int end_x)\n{\n    uint8_t *dest_y, *dest_cb, *dest_cr;\n    int linesize, uvlinesize, mb_x, mb_y;\n    const int end_mb_y       = h->mb_y + FRAME_MBAFF(h);\n    const int old_slice_type = h->slice_type;\n    const int pixel_shift    = h->pixel_shift;\n    const int block_h        = 16 >> h->chroma_y_shift;\n\n    if (h->deblocking_filter) {\n        for (mb_x = start_x; mb_x < end_x; mb_x++)\n            for (mb_y = end_mb_y - FRAME_MBAFF(h); mb_y <= end_mb_y; mb_y++) {\n                int mb_xy, mb_type;\n                mb_xy         = h->mb_xy = mb_x + mb_y * h->mb_stride;\n                h->slice_num  = h->slice_table[mb_xy];\n                mb_type       = h->cur_pic.mb_type[mb_xy];\n                h->list_count = h->list_counts[mb_xy];\n\n                if (FRAME_MBAFF(h))\n                    h->mb_mbaff               =\n                    h->mb_field_decoding_flag = !!IS_INTERLACED(mb_type);\n\n                h->mb_x = mb_x;\n                h->mb_y = mb_y;\n                dest_y  = h->cur_pic.f.data[0] +\n                          ((mb_x << pixel_shift) + mb_y * h->linesize) * 16;\n                dest_cb = h->cur_pic.f.data[1] +\n                          (mb_x << pixel_shift) * (8 << CHROMA444(h)) +\n                          mb_y * h->uvlinesize * block_h;\n                dest_cr = h->cur_pic.f.data[2] +\n                          (mb_x << pixel_shift) * (8 << CHROMA444(h)) +\n                          mb_y * h->uvlinesize * block_h;\n                // FIXME simplify above\n\n                if (MB_FIELD(h)) {\n                    linesize   = h->mb_linesize   = h->linesize   * 2;\n                    uvlinesize = h->mb_uvlinesize = h->uvlinesize * 2;\n                    if (mb_y & 1) { // FIXME move out of this function?\n                        dest_y  -= h->linesize   * 15;\n                        dest_cb -= h->uvlinesize * (block_h - 1);\n                        dest_cr -= h->uvlinesize * (block_h - 1);\n                    }\n                } else {\n                    linesize   = h->mb_linesize   = h->linesize;\n                    uvlinesize = h->mb_uvlinesize = h->uvlinesize;\n                }\n                backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize,\n                                 uvlinesize, 0);\n                if (fill_filter_caches(h, mb_type))\n                    continue;\n                h->chroma_qp[0] = get_chroma_qp(h, 0, h->cur_pic.qscale_table[mb_xy]);\n                h->chroma_qp[1] = get_chroma_qp(h, 1, h->cur_pic.qscale_table[mb_xy]);\n\n                if (FRAME_MBAFF(h)) {\n                    ff_h264_filter_mb(h, mb_x, mb_y, dest_y, dest_cb, dest_cr,\n                                      linesize, uvlinesize);\n                } else {\n                    ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb,\n                                           dest_cr, linesize, uvlinesize);\n                }\n            }\n    }\n    h->slice_type   = old_slice_type;\n    h->mb_x         = end_x;\n    h->mb_y         = end_mb_y - FRAME_MBAFF(h);\n    h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);\n    h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);\n}\n\nstatic void predict_field_decoding_flag(H264Context *h)\n{\n    const int mb_xy = h->mb_x + h->mb_y * h->mb_stride;\n    int mb_type     = (h->slice_table[mb_xy - 1] == h->slice_num) ?\n                      h->cur_pic.mb_type[mb_xy - 1] :\n                      (h->slice_table[mb_xy - h->mb_stride] == h->slice_num) ?\n                      h->cur_pic.mb_type[mb_xy - h->mb_stride] : 0;\n    h->mb_mbaff     = h->mb_field_decoding_flag = IS_INTERLACED(mb_type) ? 1 : 0;\n}\n\n/**\n * Draw edges and report progress for the last MB row.\n */\nstatic void decode_finish_row(H264Context *h)\n{\n    int top            = 16 * (h->mb_y      >> FIELD_PICTURE(h));\n    int pic_height     = 16 *  h->mb_height >> FIELD_PICTURE(h);\n    int height         =  16      << FRAME_MBAFF(h);\n    int deblock_border = (16 + 4) << FRAME_MBAFF(h);\n\n    if (h->deblocking_filter) {\n        if ((top + height) >= pic_height)\n            height += deblock_border;\n        top -= deblock_border;\n    }\n\n    if (top >= pic_height || (top + height) < 0)\n        return;\n\n    height = FFMIN(height, pic_height - top);\n    if (top < 0) {\n        height = top + height;\n        top    = 0;\n    }\n\n    ff_h264_draw_horiz_band(h, top, height);\n\n    if (h->droppable || h->er.error_occurred)\n        return;\n\n    ff_thread_report_progress(&h->cur_pic_ptr->tf, top + height - 1,\n                              h->picture_structure == PICT_BOTTOM_FIELD);\n}\n\nstatic void er_add_slice(H264Context *h, int startx, int starty,\n                         int endx, int endy, int status)\n{\n    if (CONFIG_ERROR_RESILIENCE) {\n        ERContext *er = &h->er;\n\n        ff_er_add_slice(er, startx, starty, endx, endy, status);\n    }\n}\n\nstatic int decode_slice(struct AVCodecContext *avctx, void *arg)\n{\n    H264Context *h = *(void **)arg;\n    int lf_x_start = h->mb_x;\n\n    h->mb_skip_run = -1;\n\n    av_assert0(h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * h->linesize * ((scan8[15] - scan8[0]) >> 3));\n\n    h->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n                    avctx->codec_id != AV_CODEC_ID_H264 ||\n                    (CONFIG_GRAY && (h->flags & CODEC_FLAG_GRAY));\n\n    if (!(h->avctx->active_thread_type & FF_THREAD_SLICE) && h->picture_structure == PICT_FRAME && h->er.error_status_table) {\n        const int start_i  = av_clip(h->resync_mb_x + h->resync_mb_y * h->mb_width, 0, h->mb_num - 1);\n        if (start_i) {\n            int prev_status = h->er.error_status_table[h->er.mb_index2xy[start_i - 1]];\n            prev_status &= ~ VP_START;\n            if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END))\n                h->er.error_occurred = 1;\n        }\n    }\n\n    if (h->pps.cabac) {\n        /* realign */\n        align_get_bits(&h->gb);\n\n        /* init cabac */\n        ff_init_cabac_decoder(&h->cabac,\n                              h->gb.buffer + get_bits_count(&h->gb) / 8,\n                              (get_bits_left(&h->gb) + 7) / 8);\n\n        ff_h264_init_cabac_states(h);\n\n        for (;;) {\n            // START_TIMER\n            int ret = ff_h264_decode_mb_cabac(h);\n            int eos;\n            // STOP_TIMER(\"decode_mb_cabac\")\n\n            if (ret >= 0)\n                ff_h264_hl_decode_mb(h);\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n                h->mb_y++;\n\n                ret = ff_h264_decode_mb_cabac(h);\n\n                if (ret >= 0)\n                    ff_h264_hl_decode_mb(h);\n                h->mb_y--;\n            }\n            eos = get_cabac_terminate(&h->cabac);\n\n            if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n                h->cabac.bytestream > h->cabac.bytestream_end + 2) {\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n                             h->mb_y, ER_MB_END);\n                if (h->mb_x >= lf_x_start)\n                    loop_filter(h, lf_x_start, h->mb_x + 1);\n                return 0;\n            }\n            if (h->cabac.bytestream > h->cabac.bytestream_end + 2 )\n                av_log(h->avctx, AV_LOG_DEBUG, \"bytestream overread %td\\n\", h->cabac.bytestream_end - h->cabac.bytestream);\n            if (ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 4) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"error while decoding MB %d %d, bytestream (%td)\\n\",\n                       h->mb_x, h->mb_y,\n                       h->cabac.bytestream_end - h->cabac.bytestream);\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n                             h->mb_y, ER_MB_ERROR);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (++h->mb_x >= h->mb_width) {\n                loop_filter(h, lf_x_start, h->mb_x);\n                h->mb_x = lf_x_start = 0;\n                decode_finish_row(h);\n                ++h->mb_y;\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n                    ++h->mb_y;\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n                        predict_field_decoding_flag(h);\n                }\n            }\n\n            if (eos || h->mb_y >= h->mb_height) {\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n                             h->mb_y, ER_MB_END);\n                if (h->mb_x > lf_x_start)\n                    loop_filter(h, lf_x_start, h->mb_x);\n                return 0;\n            }\n        }\n    } else {\n        for (;;) {\n            int ret = ff_h264_decode_mb_cavlc(h);\n\n            if (ret >= 0)\n                ff_h264_hl_decode_mb(h);\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n                h->mb_y++;\n                ret = ff_h264_decode_mb_cavlc(h);\n\n                if (ret >= 0)\n                    ff_h264_hl_decode_mb(h);\n                h->mb_y--;\n            }\n\n            if (ret < 0) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"error while decoding MB %d %d\\n\", h->mb_x, h->mb_y);\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n                             h->mb_y, ER_MB_ERROR);\n                return ret;\n            }\n\n            if (++h->mb_x >= h->mb_width) {\n                loop_filter(h, lf_x_start, h->mb_x);\n                h->mb_x = lf_x_start = 0;\n                decode_finish_row(h);\n                ++h->mb_y;\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n                    ++h->mb_y;\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n                        predict_field_decoding_flag(h);\n                }\n                if (h->mb_y >= h->mb_height) {\n                    tprintf(h->avctx, \"slice end %d %d\\n\",\n                            get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                    if (   get_bits_left(&h->gb) == 0\n                        || get_bits_left(&h->gb) > 0 && !(h->avctx->err_recognition & AV_EF_AGGRESSIVE)) {\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n                                     h->mb_x - 1, h->mb_y,\n                                     ER_MB_END);\n\n                        return 0;\n                    } else {\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n                                     h->mb_x, h->mb_y,\n                                     ER_MB_END);\n\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if (get_bits_left(&h->gb) <= 0 && h->mb_skip_run <= 0) {\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                if (get_bits_left(&h->gb) == 0) {\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n                                 h->mb_x - 1, h->mb_y,\n                                 ER_MB_END);\n                    if (h->mb_x > lf_x_start)\n                        loop_filter(h, lf_x_start, h->mb_x);\n\n                    return 0;\n                } else {\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n                                 h->mb_y, ER_MB_ERROR);\n\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n}\n\n/**\n * Call decode_slice() for each context.\n *\n * @param h h264 master context\n * @param context_count number of contexts to execute\n */\nstatic int execute_decode_slices(H264Context *h, int context_count)\n{\n    AVCodecContext *const avctx = h->avctx;\n    H264Context *hx;\n    int i;\n\n    if (h->avctx->hwaccel ||\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        return 0;\n    if (context_count == 1) {\n        return decode_slice(avctx, &h);\n    } else {\n        av_assert0(context_count > 0);\n        for (i = 1; i < context_count; i++) {\n            hx                 = h->thread_context[i];\n            if (CONFIG_ERROR_RESILIENCE) {\n                hx->er.error_count = 0;\n            }\n            hx->x264_build     = h->x264_build;\n        }\n\n        avctx->execute(avctx, decode_slice, h->thread_context,\n                       NULL, context_count, sizeof(void *));\n\n        /* pull back stuff from slices to master context */\n        hx                   = h->thread_context[context_count - 1];\n        h->mb_x              = hx->mb_x;\n        h->mb_y              = hx->mb_y;\n        h->droppable         = hx->droppable;\n        h->picture_structure = hx->picture_structure;\n        if (CONFIG_ERROR_RESILIENCE) {\n            for (i = 1; i < context_count; i++)\n                h->er.error_count += h->thread_context[i]->er.error_count;\n        }\n    }\n\n    return 0;\n}\n\nstatic const uint8_t start_code[] = { 0x00, 0x00, 0x01 };\n\nstatic int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size,\n                            int parse_extradata)\n{\n    AVCodecContext *const avctx = h->avctx;\n    H264Context *hx; ///< thread context\n    int buf_index;\n    int context_count;\n    int next_avc;\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n    int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts\n    int nal_index;\n    int idr_cleared=0;\n    int first_slice = 0;\n    int ret = 0;\n\n    h->nal_unit_type= 0;\n\n    if(!h->slice_context_count)\n         h->slice_context_count= 1;\n    h->max_contexts = h->slice_context_count;\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS)) {\n        h->current_slice = 0;\n        if (!h->first_field)\n            h->cur_pic_ptr = NULL;\n        ff_h264_reset_sei(h);\n    }\n\n    if (h->nal_length_size == 4) {\n        if (buf_size > 8 && AV_RB32(buf) == 1 && AV_RB32(buf+5) > (unsigned)buf_size) {\n            h->is_avc = 0;\n        }else if(buf_size > 3 && AV_RB32(buf) > 1 && AV_RB32(buf) <= (unsigned)buf_size)\n            h->is_avc = 1;\n    }\n\n    for (; pass <= 1; pass++) {\n        buf_index     = 0;\n        context_count = 0;\n        next_avc      = h->is_avc ? 0 : buf_size;\n        nal_index     = 0;\n        for (;;) {\n            int consumed;\n            int dst_length;\n            int bit_length;\n            const uint8_t *ptr;\n            int i, nalsize = 0;\n            int err;\n\n            if (buf_index >= next_avc) {\n                if (buf_index >= buf_size - h->nal_length_size)\n                    break;\n                nalsize = 0;\n                for (i = 0; i < h->nal_length_size; i++)\n                    nalsize = (nalsize << 8) | buf[buf_index++];\n                if (nalsize <= 0 || nalsize > buf_size - buf_index) {\n                    av_log(h->avctx, AV_LOG_ERROR,\n                           \"AVC: nal size %d\\n\", nalsize);\n                    break;\n                }\n                next_avc = buf_index + nalsize;\n            } else {\n                // start code prefix search\n                for (; buf_index + 3 < next_avc; buf_index++)\n                    // This should always succeed in the first iteration.\n                    if (buf[buf_index]     == 0 &&\n                        buf[buf_index + 1] == 0 &&\n                        buf[buf_index + 2] == 1)\n                        break;\n\n                if (buf_index + 3 >= buf_size) {\n                    buf_index = buf_size;\n                    break;\n                }\n\n                buf_index += 3;\n                if (buf_index >= next_avc)\n                    continue;\n            }\n\n            hx = h->thread_context[context_count];\n\n            ptr = ff_h264_decode_nal(hx, buf + buf_index, &dst_length,\n                                     &consumed, next_avc - buf_index);\n            if (ptr == NULL || dst_length < 0) {\n                ret = -1;\n                goto end;\n            }\n            i = buf_index + consumed;\n            if ((h->workaround_bugs & FF_BUG_AUTODETECT) && i + 3 < next_avc &&\n                buf[i]     == 0x00 && buf[i + 1] == 0x00 &&\n                buf[i + 2] == 0x01 && buf[i + 3] == 0xE0)\n                h->workaround_bugs |= FF_BUG_TRUNCATED;\n\n            if (!(h->workaround_bugs & FF_BUG_TRUNCATED))\n                while(dst_length > 0 && ptr[dst_length - 1] == 0)\n                    dst_length--;\n            bit_length = !dst_length ? 0\n                                     : (8 * dst_length -\n                                        decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n            if (h->avctx->debug & FF_DEBUG_STARTCODE)\n                av_log(h->avctx, AV_LOG_DEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);\n\n            if (h->is_avc && (nalsize != consumed) && nalsize)\n                av_log(h->avctx, AV_LOG_DEBUG,\n                       \"AVC: Consumed only %d bytes instead of %d\\n\",\n                       consumed, nalsize);\n\n            buf_index += consumed;\n            nal_index++;\n\n            if (pass == 0) {\n                /* packets can sometimes contain multiple PPS/SPS,\n                 * e.g. two PAFF field pictures in one packet, or a demuxer\n                 * which splits NALs strangely if so, when frame threading we\n                 * can't start the next thread until we've read all of them */\n                switch (hx->nal_unit_type) {\n                case NAL_SPS:\n                case NAL_PPS:\n                    nals_needed = nal_index;\n                    break;\n                case NAL_DPA:\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                    init_get_bits(&hx->gb, ptr, bit_length);\n                    if (!get_ue_golomb(&hx->gb) || !first_slice)\n                        nals_needed = nal_index;\n                    if (!first_slice)\n                        first_slice = hx->nal_unit_type;\n                }\n                continue;\n            }\n\n            if (!first_slice)\n                switch (hx->nal_unit_type) {\n                case NAL_DPA:\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                    first_slice = hx->nal_unit_type;\n                }\n\n            if (avctx->skip_frame >= AVDISCARD_NONREF &&\n                h->nal_ref_idc == 0 &&\n                h->nal_unit_type != NAL_SEI)\n                continue;\n\nagain:\n            /* Ignore per frame NAL unit type during extradata\n             * parsing. Decoding slices is not possible in codec init\n             * with frame-mt */\n            if (parse_extradata) {\n                switch (hx->nal_unit_type) {\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                case NAL_DPA:\n                case NAL_DPB:\n                case NAL_DPC:\n                    av_log(h->avctx, AV_LOG_WARNING,\n                           \"Ignoring NAL %d in global header/extradata\\n\",\n                           hx->nal_unit_type);\n                    // fall through to next case\n                case NAL_AUXILIARY_SLICE:\n                    hx->nal_unit_type = NAL_FF_IGNORE;\n                }\n            }\n\n            err = 0;\n\n            switch (hx->nal_unit_type) {\n            case NAL_IDR_SLICE:\n                if (first_slice != NAL_IDR_SLICE) {\n                    av_log(h->avctx, AV_LOG_ERROR,\n                           \"Invalid mix of idr and non-idr slices\\n\");\n                    ret = -1;\n                    goto end;\n                }\n                if(!idr_cleared)\n                    idr(h); // FIXME ensure we don't lose some frames if there is reordering\n                idr_cleared = 1;\n            case NAL_SLICE:\n                init_get_bits(&hx->gb, ptr, bit_length);\n                hx->intra_gb_ptr      =\n                hx->inter_gb_ptr      = &hx->gb;\n                hx->data_partitioning = 0;\n\n                if ((err = decode_slice_header(hx, h)))\n                    break;\n\n                if (h->sei_recovery_frame_cnt >= 0 && (h->frame_num != h->sei_recovery_frame_cnt || hx->slice_type_nos != AV_PICTURE_TYPE_I))\n                    h->valid_recovery_point = 1;\n\n                if (   h->sei_recovery_frame_cnt >= 0\n                    && (   h->recovery_frame<0\n                        || ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt)) {\n                    h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %\n                                        (1 << h->sps.log2_max_frame_num);\n\n                    if (!h->valid_recovery_point)\n                        h->recovery_frame = h->frame_num;\n                }\n\n                h->cur_pic_ptr->f.key_frame |=\n                        (hx->nal_unit_type == NAL_IDR_SLICE);\n\n                if (h->recovery_frame == h->frame_num) {\n                    h->cur_pic_ptr->sync |= 1;\n                    h->recovery_frame = -1;\n                }\n\n                h->sync |= !!h->cur_pic_ptr->f.key_frame;\n                h->sync |= 3*!!(avctx->flags2 & CODEC_FLAG2_SHOW_ALL);\n                h->cur_pic_ptr->sync |= h->sync;\n\n                if (h->current_slice == 1) {\n                    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS))\n                        decode_postinit(h, nal_index >= nals_needed);\n\n                    if (h->avctx->hwaccel &&\n                        (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0)\n                        return ret;\n                    if (CONFIG_H264_VDPAU_DECODER &&\n                        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n                        ff_vdpau_h264_picture_start(h);\n                }\n\n                if (hx->redundant_pic_count == 0 &&\n                    (avctx->skip_frame < AVDISCARD_NONREF ||\n                     hx->nal_ref_idc) &&\n                    (avctx->skip_frame < AVDISCARD_BIDIR  ||\n                     hx->slice_type_nos != AV_PICTURE_TYPE_B) &&\n                    (avctx->skip_frame < AVDISCARD_NONKEY ||\n                     hx->slice_type_nos == AV_PICTURE_TYPE_I) &&\n                    avctx->skip_frame < AVDISCARD_ALL) {\n                    if (avctx->hwaccel) {\n                        ret = avctx->hwaccel->decode_slice(avctx,\n                                                           &buf[buf_index - consumed],\n                                                           consumed);\n                        if (ret < 0)\n                            return ret;\n                    } else if (CONFIG_H264_VDPAU_DECODER &&\n                               h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) {\n                        ff_vdpau_add_data_chunk(h->cur_pic_ptr->f.data[0],\n                                                start_code,\n                                                sizeof(start_code));\n                        ff_vdpau_add_data_chunk(h->cur_pic_ptr->f.data[0],\n                                                &buf[buf_index - consumed],\n                                                consumed);\n                    } else\n                        context_count++;\n                }\n                break;\n            case NAL_DPA:\n                init_get_bits(&hx->gb, ptr, bit_length);\n                hx->intra_gb_ptr =\n                hx->inter_gb_ptr = NULL;\n\n                if ((err = decode_slice_header(hx, h)) < 0)\n                    break;\n\n                hx->data_partitioning = 1;\n                break;\n            case NAL_DPB:\n                init_get_bits(&hx->intra_gb, ptr, bit_length);\n                hx->intra_gb_ptr = &hx->intra_gb;\n                break;\n            case NAL_DPC:\n                init_get_bits(&hx->inter_gb, ptr, bit_length);\n                hx->inter_gb_ptr = &hx->inter_gb;\n\n                av_log(h->avctx, AV_LOG_ERROR, \"Partitioned H.264 support is incomplete\\n\");\n                break;\n\n                if (hx->redundant_pic_count == 0 &&\n                    hx->intra_gb_ptr &&\n                    hx->data_partitioning &&\n                    h->cur_pic_ptr && h->context_initialized &&\n                    (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) &&\n                    (avctx->skip_frame < AVDISCARD_BIDIR  ||\n                     hx->slice_type_nos != AV_PICTURE_TYPE_B) &&\n                    (avctx->skip_frame < AVDISCARD_NONKEY ||\n                     hx->slice_type_nos == AV_PICTURE_TYPE_I) &&\n                    avctx->skip_frame < AVDISCARD_ALL)\n                    context_count++;\n                break;\n            case NAL_SEI:\n                init_get_bits(&h->gb, ptr, bit_length);\n                ff_h264_decode_sei(h);\n                break;\n            case NAL_SPS:\n                init_get_bits(&h->gb, ptr, bit_length);\n                if (ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? nalsize : 1)) {\n                    av_log(h->avctx, AV_LOG_DEBUG,\n                           \"SPS decoding failure, trying again with the complete NAL\\n\");\n                    if (h->is_avc)\n                        av_assert0(next_avc - buf_index + consumed == nalsize);\n                    if ((next_avc - buf_index + consumed - 1) >= INT_MAX/8)\n                        break;\n                    init_get_bits(&h->gb, &buf[buf_index + 1 - consumed],\n                                  8*(next_avc - buf_index + consumed - 1));\n                    ff_h264_decode_seq_parameter_set(h);\n                }\n\n                break;\n            case NAL_PPS:\n                init_get_bits(&h->gb, ptr, bit_length);\n                ff_h264_decode_picture_parameter_set(h, bit_length);\n                break;\n            case NAL_AUD:\n            case NAL_END_SEQUENCE:\n            case NAL_END_STREAM:\n            case NAL_FILLER_DATA:\n            case NAL_SPS_EXT:\n            case NAL_AUXILIARY_SLICE:\n                break;\n            case NAL_FF_IGNORE:\n                break;\n            default:\n                av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\",\n                       hx->nal_unit_type, bit_length);\n            }\n\n            if (context_count == h->max_contexts) {\n                execute_decode_slices(h, context_count);\n                context_count = 0;\n            }\n\n            if (err < 0)\n                av_log(h->avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n            else if (err == 1) {\n                /* Slice could not be decoded in parallel mode, copy down\n                 * NAL unit stuff to context 0 and restart. Note that\n                 * rbsp_buffer is not transferred, but since we no longer\n                 * run in parallel mode this should not be an issue. */\n                h->nal_unit_type = hx->nal_unit_type;\n                h->nal_ref_idc   = hx->nal_ref_idc;\n                hx               = h;\n                goto again;\n            }\n        }\n    }\n    if (context_count)\n        execute_decode_slices(h, context_count);\n\nend:\n    /* clean up */\n    if (h->cur_pic_ptr && !h->droppable) {\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    }\n\n    return (ret < 0) ? ret : buf_index;\n}\n\n/**\n * Return the number of bytes consumed for building the current frame.\n */\nstatic int get_consumed_bytes(int pos, int buf_size)\n{\n    if (pos == 0)\n        pos = 1;          // avoid infinite loops (i doubt that is needed but ...)\n    if (pos + 10 > buf_size)\n        pos = buf_size;                   // oops ;)\n\n    return pos;\n}\n\nstatic int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)\n{\n    AVFrame *src = &srcp->f;\n    int i;\n    int ret = av_frame_ref(dst, src);\n    if (ret < 0)\n        return ret;\n\n    av_dict_set(&dst->metadata, \"stereo_mode\", ff_h264_sei_stereo_mode(h), 0);\n\n    if (!srcp->crop)\n        return 0;\n\n    for (i = 0; i < 3; i++) {\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +\n                      (srcp->crop_top  >> vshift) * dst->linesize[i];\n        dst->data[i] += off;\n    }\n    return 0;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    H264Context *h     = avctx->priv_data;\n    AVFrame *pict      = data;\n    int buf_index      = 0;\n    Picture *out;\n    int i, out_idx;\n    int ret;\n\n    h->flags = avctx->flags;\n\n    /* end of stream, output what is still in the buffers */\n    if (buf_size == 0) {\n out:\n\n        h->cur_pic_ptr = NULL;\n        h->first_field = 0;\n\n        // FIXME factorize this with the output code below\n        out     = h->delayed_pic[0];\n        out_idx = 0;\n        for (i = 1;\n             h->delayed_pic[i] &&\n             !h->delayed_pic[i]->f.key_frame &&\n             !h->delayed_pic[i]->mmco_reset;\n             i++)\n            if (h->delayed_pic[i]->poc < out->poc) {\n                out     = h->delayed_pic[i];\n                out_idx = i;\n            }\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n        if (out) {\n            out->reference &= ~DELAYED_PIC_REF;\n            ret = output_frame(h, pict, out);\n            if (ret < 0)\n                return ret;\n            *got_frame = 1;\n        }\n\n        return buf_index;\n    }\n    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n        int cnt= buf[5]&0x1f;\n        const uint8_t *p= buf+6;\n        while(cnt--){\n            int nalsize= AV_RB16(p) + 2;\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)\n                goto not_extra;\n            p += nalsize;\n        }\n        cnt = *(p++);\n        if(!cnt)\n            goto not_extra;\n        while(cnt--){\n            int nalsize= AV_RB16(p) + 2;\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)\n                goto not_extra;\n            p += nalsize;\n        }\n\n        return ff_h264_decode_extradata(h, buf, buf_size);\n    }\nnot_extra:\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n    if (buf_index < 0)\n        return AVERROR_INVALIDDATA;\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n        av_assert0(buf_index <= buf_size);\n        goto out;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n            return buf_size;\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n            decode_postinit(h, 1);\n\n        field_end(h, 0);\n\n        /* Wait for second field. */\n        *got_frame = 0;\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n            ret = output_frame(h, pict, h->next_output_pic);\n            if (ret < 0)\n                return ret;\n            *got_frame = 1;\n            if (CONFIG_MPEGVIDEO) {\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n                                    &h->low_delay,\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n            }\n        }\n    }\n\n    assert(pict->data[0] || !*got_frame);\n\n    return get_consumed_bytes(buf_index, buf_size);\n}\n\nav_cold void ff_h264_free_context(H264Context *h)\n{\n    int i;\n\n    free_tables(h, 1); // FIXME cleanup init stuff perhaps\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n        av_freep(h->sps_buffers + i);\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n        av_freep(h->pps_buffers + i);\n}\n\nstatic av_cold int h264_decode_end(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n\n    ff_h264_remove_all_refs(h);\n    ff_h264_free_context(h);\n\n    unref_picture(h, &h->cur_pic);\n\n    return 0;\n}\n\nstatic const AVProfile profiles[] = {\n    { FF_PROFILE_H264_BASELINE,             \"Baseline\"              },\n    { FF_PROFILE_H264_CONSTRAINED_BASELINE, \"Constrained Baseline\"  },\n    { FF_PROFILE_H264_MAIN,                 \"Main\"                  },\n    { FF_PROFILE_H264_EXTENDED,             \"Extended\"              },\n    { FF_PROFILE_H264_HIGH,                 \"High\"                  },\n    { FF_PROFILE_H264_HIGH_10,              \"High 10\"               },\n    { FF_PROFILE_H264_HIGH_10_INTRA,        \"High 10 Intra\"         },\n    { FF_PROFILE_H264_HIGH_422,             \"High 4:2:2\"            },\n    { FF_PROFILE_H264_HIGH_422_INTRA,       \"High 4:2:2 Intra\"      },\n    { FF_PROFILE_H264_HIGH_444,             \"High 4:4:4\"            },\n    { FF_PROFILE_H264_HIGH_444_PREDICTIVE,  \"High 4:4:4 Predictive\" },\n    { FF_PROFILE_H264_HIGH_444_INTRA,       \"High 4:4:4 Intra\"      },\n    { FF_PROFILE_H264_CAVLC_444,            \"CAVLC 4:4:4\"           },\n    { FF_PROFILE_UNKNOWN },\n};\n\nstatic const AVOption h264_options[] = {\n    {\"is_avc\", \"is avc\", offsetof(H264Context, is_avc), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},\n    {\"nal_length_size\", \"nal_length_size\", offsetof(H264Context, nal_length_size), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 4, 0},\n    {NULL}\n};\n\nstatic const AVClass h264_class = {\n    .class_name = \"H264 Decoder\",\n    .item_name  = av_default_item_name,\n    .option     = h264_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nstatic const AVClass h264_vdpau_class = {\n    .class_name = \"H264 VDPAU Decoder\",\n    .item_name  = av_default_item_name,\n    .option     = h264_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_h264_decoder = {\n    .name                  = \"h264\",\n    .long_name             = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\"),\n    .type                  = AVMEDIA_TYPE_VIDEO,\n    .id                    = AV_CODEC_ID_H264,\n    .priv_data_size        = sizeof(H264Context),\n    .init                  = ff_h264_decode_init,\n    .close                 = h264_decode_end,\n    .decode                = decode_frame,\n    .capabilities          = /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 |\n                             CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS |\n                             CODEC_CAP_FRAME_THREADS,\n    .flush                 = flush_dpb,\n    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(decode_update_thread_context),\n    .profiles              = NULL_IF_CONFIG_SMALL(profiles),\n    .priv_class            = &h264_class,\n};\n\n#if CONFIG_H264_VDPAU_DECODER\nAVCodec ff_h264_vdpau_decoder = {\n    .name           = \"h264_vdpau\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (VDPAU acceleration)\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_H264,\n    .priv_data_size = sizeof(H264Context),\n    .init           = ff_h264_decode_init,\n    .close          = h264_decode_end,\n    .decode         = decode_frame,\n    .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,\n    .flush          = flush_dpb,\n    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_VDPAU_H264,\n                                                     AV_PIX_FMT_NONE},\n    .profiles       = NULL_IF_CONFIG_SMALL(profiles),\n    .priv_class     = &h264_vdpau_class,\n};\n#endif\n"], "fixing_code": ["/*\n * H.26L/H.264/AVC/JVT/14496-10/... decoder\n * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * H.264 / AVC / MPEG4 part10 codec.\n * @author Michael Niedermayer <michaelni@gmx.at>\n */\n\n#define UNCHECKED_BITSTREAM_READER 1\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/opt.h\"\n#include \"internal.h\"\n#include \"cabac.h\"\n#include \"cabac_functions.h\"\n#include \"dsputil.h\"\n#include \"error_resilience.h\"\n#include \"avcodec.h\"\n#include \"mpegvideo.h\"\n#include \"h264.h\"\n#include \"h264data.h\"\n#include \"h264chroma.h\"\n#include \"h264_mvpred.h\"\n#include \"golomb.h\"\n#include \"mathops.h\"\n#include \"rectangle.h\"\n#include \"svq3.h\"\n#include \"thread.h\"\n#include \"vdpau_internal.h\"\n\n#include <assert.h>\n\nstatic void flush_change(H264Context *h);\n\nconst uint16_t ff_h264_mb_sizes[4] = { 256, 384, 512, 768 };\n\nstatic const uint8_t rem6[QP_MAX_NUM + 1] = {\n    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,\n    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,\n    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,\n    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,\n    0, 1, 2, 3,\n};\n\nstatic const uint8_t div6[QP_MAX_NUM + 1] = {\n    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,\n    3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,\n    7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,\n   10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13,\n   14,14,14,14,\n};\n\nstatic const uint8_t field_scan[16+1] = {\n    0 + 0 * 4, 0 + 1 * 4, 1 + 0 * 4, 0 + 2 * 4,\n    0 + 3 * 4, 1 + 1 * 4, 1 + 2 * 4, 1 + 3 * 4,\n    2 + 0 * 4, 2 + 1 * 4, 2 + 2 * 4, 2 + 3 * 4,\n    3 + 0 * 4, 3 + 1 * 4, 3 + 2 * 4, 3 + 3 * 4,\n};\n\nstatic const uint8_t field_scan8x8[64+1] = {\n    0 + 0 * 8, 0 + 1 * 8, 0 + 2 * 8, 1 + 0 * 8,\n    1 + 1 * 8, 0 + 3 * 8, 0 + 4 * 8, 1 + 2 * 8,\n    2 + 0 * 8, 1 + 3 * 8, 0 + 5 * 8, 0 + 6 * 8,\n    0 + 7 * 8, 1 + 4 * 8, 2 + 1 * 8, 3 + 0 * 8,\n    2 + 2 * 8, 1 + 5 * 8, 1 + 6 * 8, 1 + 7 * 8,\n    2 + 3 * 8, 3 + 1 * 8, 4 + 0 * 8, 3 + 2 * 8,\n    2 + 4 * 8, 2 + 5 * 8, 2 + 6 * 8, 2 + 7 * 8,\n    3 + 3 * 8, 4 + 1 * 8, 5 + 0 * 8, 4 + 2 * 8,\n    3 + 4 * 8, 3 + 5 * 8, 3 + 6 * 8, 3 + 7 * 8,\n    4 + 3 * 8, 5 + 1 * 8, 6 + 0 * 8, 5 + 2 * 8,\n    4 + 4 * 8, 4 + 5 * 8, 4 + 6 * 8, 4 + 7 * 8,\n    5 + 3 * 8, 6 + 1 * 8, 6 + 2 * 8, 5 + 4 * 8,\n    5 + 5 * 8, 5 + 6 * 8, 5 + 7 * 8, 6 + 3 * 8,\n    7 + 0 * 8, 7 + 1 * 8, 6 + 4 * 8, 6 + 5 * 8,\n    6 + 6 * 8, 6 + 7 * 8, 7 + 2 * 8, 7 + 3 * 8,\n    7 + 4 * 8, 7 + 5 * 8, 7 + 6 * 8, 7 + 7 * 8,\n};\n\nstatic const uint8_t field_scan8x8_cavlc[64+1] = {\n    0 + 0 * 8, 1 + 1 * 8, 2 + 0 * 8, 0 + 7 * 8,\n    2 + 2 * 8, 2 + 3 * 8, 2 + 4 * 8, 3 + 3 * 8,\n    3 + 4 * 8, 4 + 3 * 8, 4 + 4 * 8, 5 + 3 * 8,\n    5 + 5 * 8, 7 + 0 * 8, 6 + 6 * 8, 7 + 4 * 8,\n    0 + 1 * 8, 0 + 3 * 8, 1 + 3 * 8, 1 + 4 * 8,\n    1 + 5 * 8, 3 + 1 * 8, 2 + 5 * 8, 4 + 1 * 8,\n    3 + 5 * 8, 5 + 1 * 8, 4 + 5 * 8, 6 + 1 * 8,\n    5 + 6 * 8, 7 + 1 * 8, 6 + 7 * 8, 7 + 5 * 8,\n    0 + 2 * 8, 0 + 4 * 8, 0 + 5 * 8, 2 + 1 * 8,\n    1 + 6 * 8, 4 + 0 * 8, 2 + 6 * 8, 5 + 0 * 8,\n    3 + 6 * 8, 6 + 0 * 8, 4 + 6 * 8, 6 + 2 * 8,\n    5 + 7 * 8, 6 + 4 * 8, 7 + 2 * 8, 7 + 6 * 8,\n    1 + 0 * 8, 1 + 2 * 8, 0 + 6 * 8, 3 + 0 * 8,\n    1 + 7 * 8, 3 + 2 * 8, 2 + 7 * 8, 4 + 2 * 8,\n    3 + 7 * 8, 5 + 2 * 8, 4 + 7 * 8, 5 + 4 * 8,\n    6 + 3 * 8, 6 + 5 * 8, 7 + 3 * 8, 7 + 7 * 8,\n};\n\n// zigzag_scan8x8_cavlc[i] = zigzag_scan8x8[(i/4) + 16*(i%4)]\nstatic const uint8_t zigzag_scan8x8_cavlc[64+1] = {\n    0 + 0 * 8, 1 + 1 * 8, 1 + 2 * 8, 2 + 2 * 8,\n    4 + 1 * 8, 0 + 5 * 8, 3 + 3 * 8, 7 + 0 * 8,\n    3 + 4 * 8, 1 + 7 * 8, 5 + 3 * 8, 6 + 3 * 8,\n    2 + 7 * 8, 6 + 4 * 8, 5 + 6 * 8, 7 + 5 * 8,\n    1 + 0 * 8, 2 + 0 * 8, 0 + 3 * 8, 3 + 1 * 8,\n    3 + 2 * 8, 0 + 6 * 8, 4 + 2 * 8, 6 + 1 * 8,\n    2 + 5 * 8, 2 + 6 * 8, 6 + 2 * 8, 5 + 4 * 8,\n    3 + 7 * 8, 7 + 3 * 8, 4 + 7 * 8, 7 + 6 * 8,\n    0 + 1 * 8, 3 + 0 * 8, 0 + 4 * 8, 4 + 0 * 8,\n    2 + 3 * 8, 1 + 5 * 8, 5 + 1 * 8, 5 + 2 * 8,\n    1 + 6 * 8, 3 + 5 * 8, 7 + 1 * 8, 4 + 5 * 8,\n    4 + 6 * 8, 7 + 4 * 8, 5 + 7 * 8, 6 + 7 * 8,\n    0 + 2 * 8, 2 + 1 * 8, 1 + 3 * 8, 5 + 0 * 8,\n    1 + 4 * 8, 2 + 4 * 8, 6 + 0 * 8, 4 + 3 * 8,\n    0 + 7 * 8, 4 + 4 * 8, 7 + 2 * 8, 3 + 6 * 8,\n    5 + 5 * 8, 6 + 5 * 8, 6 + 6 * 8, 7 + 7 * 8,\n};\n\nstatic const uint8_t dequant4_coeff_init[6][3] = {\n    { 10, 13, 16 },\n    { 11, 14, 18 },\n    { 13, 16, 20 },\n    { 14, 18, 23 },\n    { 16, 20, 25 },\n    { 18, 23, 29 },\n};\n\nstatic const uint8_t dequant8_coeff_init_scan[16] = {\n    0, 3, 4, 3, 3, 1, 5, 1, 4, 5, 2, 5, 3, 1, 5, 1\n};\n\nstatic const uint8_t dequant8_coeff_init[6][6] = {\n    { 20, 18, 32, 19, 25, 24 },\n    { 22, 19, 35, 21, 28, 26 },\n    { 26, 23, 42, 24, 33, 31 },\n    { 28, 25, 45, 26, 35, 33 },\n    { 32, 28, 51, 30, 40, 38 },\n    { 36, 32, 58, 34, 46, 43 },\n};\n\nstatic const enum AVPixelFormat h264_hwaccel_pixfmt_list_420[] = {\n#if CONFIG_H264_DXVA2_HWACCEL\n    AV_PIX_FMT_DXVA2_VLD,\n#endif\n#if CONFIG_H264_VAAPI_HWACCEL\n    AV_PIX_FMT_VAAPI_VLD,\n#endif\n#if CONFIG_H264_VDA_HWACCEL\n    AV_PIX_FMT_VDA_VLD,\n#endif\n#if CONFIG_H264_VDPAU_HWACCEL\n    AV_PIX_FMT_VDPAU,\n#endif\n    AV_PIX_FMT_YUV420P,\n    AV_PIX_FMT_NONE\n};\n\nstatic const enum AVPixelFormat h264_hwaccel_pixfmt_list_jpeg_420[] = {\n#if CONFIG_H264_DXVA2_HWACCEL\n    AV_PIX_FMT_DXVA2_VLD,\n#endif\n#if CONFIG_H264_VAAPI_HWACCEL\n    AV_PIX_FMT_VAAPI_VLD,\n#endif\n#if CONFIG_H264_VDA_HWACCEL\n    AV_PIX_FMT_VDA_VLD,\n#endif\n#if CONFIG_H264_VDPAU_HWACCEL\n    AV_PIX_FMT_VDPAU,\n#endif\n    AV_PIX_FMT_YUVJ420P,\n    AV_PIX_FMT_NONE\n};\n\nint avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    return h ? h->sps.num_reorder_frames : 0;\n}\n\nstatic void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,\n                              int (*mv)[2][4][2],\n                              int mb_x, int mb_y, int mb_intra, int mb_skipped)\n{\n    H264Context *h = opaque;\n\n    h->mb_x  = mb_x;\n    h->mb_y  = mb_y;\n    h->mb_xy = mb_x + mb_y * h->mb_stride;\n    memset(h->non_zero_count_cache, 0, sizeof(h->non_zero_count_cache));\n    av_assert1(ref >= 0);\n    /* FIXME: It is possible albeit uncommon that slice references\n     * differ between slices. We take the easy approach and ignore\n     * it for now. If this turns out to have any relevance in\n     * practice then correct remapping should be added. */\n    if (ref >= h->ref_count[0])\n        ref = 0;\n    if (!h->ref_list[0][ref].f.data[0]) {\n        av_log(h->avctx, AV_LOG_DEBUG, \"Reference not available for error concealing\\n\");\n        ref = 0;\n    }\n    if ((h->ref_list[0][ref].reference&3) != 3) {\n        av_log(h->avctx, AV_LOG_DEBUG, \"Reference invalid\\n\");\n        return;\n    }\n    fill_rectangle(&h->cur_pic.ref_index[0][4 * h->mb_xy],\n                   2, 2, 2, ref, 1);\n    fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1);\n    fill_rectangle(h->mv_cache[0][scan8[0]], 4, 4, 8,\n                   pack16to32((*mv)[0][0][0], (*mv)[0][0][1]), 4);\n    h->mb_mbaff =\n    h->mb_field_decoding_flag = 0;\n    ff_h264_hl_decode_mb(h);\n}\n\nvoid ff_h264_draw_horiz_band(H264Context *h, int y, int height)\n{\n    AVCodecContext *avctx = h->avctx;\n    Picture *cur  = &h->cur_pic;\n    Picture *last = h->ref_list[0][0].f.data[0] ? &h->ref_list[0][0] : NULL;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    int vshift = desc->log2_chroma_h;\n    const int field_pic = h->picture_structure != PICT_FRAME;\n    if (field_pic) {\n        height <<= 1;\n        y      <<= 1;\n    }\n\n    height = FFMIN(height, avctx->height - y);\n\n    if (field_pic && h->first_field && !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD))\n        return;\n\n    if (avctx->draw_horiz_band) {\n        AVFrame *src;\n        int offset[AV_NUM_DATA_POINTERS];\n        int i;\n\n        if (cur->f.pict_type == AV_PICTURE_TYPE_B || h->low_delay ||\n            (avctx->slice_flags & SLICE_FLAG_CODED_ORDER))\n            src = &cur->f;\n        else if (last)\n            src = &last->f;\n        else\n            return;\n\n        offset[0] = y * src->linesize[0];\n        offset[1] =\n        offset[2] = (y >> vshift) * src->linesize[1];\n        for (i = 3; i < AV_NUM_DATA_POINTERS; i++)\n            offset[i] = 0;\n\n        emms_c();\n\n        avctx->draw_horiz_band(avctx, src, offset,\n                               y, h->picture_structure, height);\n    }\n}\n\nstatic void unref_picture(H264Context *h, Picture *pic)\n{\n    int off = offsetof(Picture, tf) + sizeof(pic->tf);\n    int i;\n\n    if (!pic->f.data[0])\n        return;\n\n    ff_thread_release_buffer(h->avctx, &pic->tf);\n    av_buffer_unref(&pic->hwaccel_priv_buf);\n\n    av_buffer_unref(&pic->qscale_table_buf);\n    av_buffer_unref(&pic->mb_type_buf);\n    for (i = 0; i < 2; i++) {\n        av_buffer_unref(&pic->motion_val_buf[i]);\n        av_buffer_unref(&pic->ref_index_buf[i]);\n    }\n\n    memset((uint8_t*)pic + off, 0, sizeof(*pic) - off);\n}\n\nstatic void release_unused_pictures(H264Context *h, int remove_current)\n{\n    int i;\n\n    /* release non reference frames */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&\n            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {\n            unref_picture(h, &h->DPB[i]);\n        }\n    }\n}\n\nstatic int ref_picture(H264Context *h, Picture *dst, Picture *src)\n{\n    int ret, i;\n\n    av_assert0(!dst->f.buf[0]);\n    av_assert0(src->f.buf[0]);\n\n    src->tf.f = &src->f;\n    dst->tf.f = &dst->f;\n    ret = ff_thread_ref_frame(&dst->tf, &src->tf);\n    if (ret < 0)\n        goto fail;\n\n    dst->qscale_table_buf = av_buffer_ref(src->qscale_table_buf);\n    dst->mb_type_buf      = av_buffer_ref(src->mb_type_buf);\n    if (!dst->qscale_table_buf || !dst->mb_type_buf)\n        goto fail;\n    dst->qscale_table = src->qscale_table;\n    dst->mb_type      = src->mb_type;\n\n    for (i = 0; i < 2; i++) {\n        dst->motion_val_buf[i] = av_buffer_ref(src->motion_val_buf[i]);\n        dst->ref_index_buf[i]  = av_buffer_ref(src->ref_index_buf[i]);\n        if (!dst->motion_val_buf[i] || !dst->ref_index_buf[i])\n            goto fail;\n        dst->motion_val[i] = src->motion_val[i];\n        dst->ref_index[i]  = src->ref_index[i];\n    }\n\n    if (src->hwaccel_picture_private) {\n        dst->hwaccel_priv_buf = av_buffer_ref(src->hwaccel_priv_buf);\n        if (!dst->hwaccel_priv_buf)\n            goto fail;\n        dst->hwaccel_picture_private = dst->hwaccel_priv_buf->data;\n    }\n\n    for (i = 0; i < 2; i++)\n        dst->field_poc[i] = src->field_poc[i];\n\n    memcpy(dst->ref_poc,   src->ref_poc,   sizeof(src->ref_poc));\n    memcpy(dst->ref_count, src->ref_count, sizeof(src->ref_count));\n\n    dst->poc           = src->poc;\n    dst->frame_num     = src->frame_num;\n    dst->mmco_reset    = src->mmco_reset;\n    dst->pic_id        = src->pic_id;\n    dst->long_ref      = src->long_ref;\n    dst->mbaff         = src->mbaff;\n    dst->field_picture = src->field_picture;\n    dst->needs_realloc = src->needs_realloc;\n    dst->reference     = src->reference;\n    dst->sync          = src->sync;\n    dst->crop          = src->crop;\n    dst->crop_left     = src->crop_left;\n    dst->crop_top      = src->crop_top;\n\n    return 0;\nfail:\n    unref_picture(h, dst);\n    return ret;\n}\n\nstatic int alloc_scratch_buffers(H264Context *h, int linesize)\n{\n    int alloc_size = FFALIGN(FFABS(linesize) + 32, 32);\n\n    if (h->bipred_scratchpad)\n        return 0;\n\n    h->bipred_scratchpad = av_malloc(16 * 6 * alloc_size);\n    // edge emu needs blocksize + filter length - 1\n    // (= 21x21 for  h264)\n    h->edge_emu_buffer = av_mallocz(alloc_size * 2 * 21);\n    h->me.scratchpad   = av_mallocz(alloc_size * 2 * 16 * 2);\n\n    if (!h->bipred_scratchpad || !h->edge_emu_buffer || !h->me.scratchpad) {\n        av_freep(&h->bipred_scratchpad);\n        av_freep(&h->edge_emu_buffer);\n        av_freep(&h->me.scratchpad);\n        return AVERROR(ENOMEM);\n    }\n\n    h->me.temp = h->me.scratchpad;\n\n    return 0;\n}\n\nstatic int init_table_pools(H264Context *h)\n{\n    const int big_mb_num    = h->mb_stride * (h->mb_height + 1) + 1;\n    const int mb_array_size = h->mb_stride * h->mb_height;\n    const int b4_stride     = h->mb_width * 4 + 1;\n    const int b4_array_size = b4_stride * h->mb_height * 4;\n\n    h->qscale_table_pool = av_buffer_pool_init(big_mb_num + h->mb_stride,\n                                               av_buffer_allocz);\n    h->mb_type_pool      = av_buffer_pool_init((big_mb_num + h->mb_stride) *\n                                               sizeof(uint32_t), av_buffer_allocz);\n    h->motion_val_pool = av_buffer_pool_init(2 * (b4_array_size + 4) *\n                                             sizeof(int16_t), av_buffer_allocz);\n    h->ref_index_pool  = av_buffer_pool_init(4 * mb_array_size, av_buffer_allocz);\n\n    if (!h->qscale_table_pool || !h->mb_type_pool || !h->motion_val_pool ||\n        !h->ref_index_pool) {\n        av_buffer_pool_uninit(&h->qscale_table_pool);\n        av_buffer_pool_uninit(&h->mb_type_pool);\n        av_buffer_pool_uninit(&h->motion_val_pool);\n        av_buffer_pool_uninit(&h->ref_index_pool);\n        return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n\nstatic int alloc_picture(H264Context *h, Picture *pic)\n{\n    int i, ret = 0;\n\n    av_assert0(!pic->f.data[0]);\n\n    pic->tf.f = &pic->f;\n    ret = ff_thread_get_buffer(h->avctx, &pic->tf, pic->reference ?\n                                                   AV_GET_BUFFER_FLAG_REF : 0);\n    if (ret < 0)\n        goto fail;\n\n    h->linesize   = pic->f.linesize[0];\n    h->uvlinesize = pic->f.linesize[1];\n    pic->crop     = h->sps.crop;\n    pic->crop_top = h->sps.crop_top;\n    pic->crop_left= h->sps.crop_left;\n\n    if (h->avctx->hwaccel) {\n        const AVHWAccel *hwaccel = h->avctx->hwaccel;\n        av_assert0(!pic->hwaccel_picture_private);\n        if (hwaccel->priv_data_size) {\n            pic->hwaccel_priv_buf = av_buffer_allocz(hwaccel->priv_data_size);\n            if (!pic->hwaccel_priv_buf)\n                return AVERROR(ENOMEM);\n            pic->hwaccel_picture_private = pic->hwaccel_priv_buf->data;\n        }\n    }\n\n    if (!h->qscale_table_pool) {\n        ret = init_table_pools(h);\n        if (ret < 0)\n            goto fail;\n    }\n\n    pic->qscale_table_buf = av_buffer_pool_get(h->qscale_table_pool);\n    pic->mb_type_buf      = av_buffer_pool_get(h->mb_type_pool);\n    if (!pic->qscale_table_buf || !pic->mb_type_buf)\n        goto fail;\n\n    pic->mb_type      = (uint32_t*)pic->mb_type_buf->data + 2 * h->mb_stride + 1;\n    pic->qscale_table = pic->qscale_table_buf->data + 2 * h->mb_stride + 1;\n\n    for (i = 0; i < 2; i++) {\n        pic->motion_val_buf[i] = av_buffer_pool_get(h->motion_val_pool);\n        pic->ref_index_buf[i]  = av_buffer_pool_get(h->ref_index_pool);\n        if (!pic->motion_val_buf[i] || !pic->ref_index_buf[i])\n            goto fail;\n\n        pic->motion_val[i] = (int16_t (*)[2])pic->motion_val_buf[i]->data + 4;\n        pic->ref_index[i]  = pic->ref_index_buf[i]->data;\n    }\n\n    return 0;\nfail:\n    unref_picture(h, pic);\n    return (ret < 0) ? ret : AVERROR(ENOMEM);\n}\n\nstatic inline int pic_is_unused(H264Context *h, Picture *pic)\n{\n    if (pic->f.data[0] == NULL)\n        return 1;\n    if (pic->needs_realloc && !(pic->reference & DELAYED_PIC_REF))\n        return 1;\n    return 0;\n}\n\nstatic int find_unused_picture(H264Context *h)\n{\n    int i;\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (pic_is_unused(h, &h->DPB[i]))\n            break;\n    }\n    if (i == MAX_PICTURE_COUNT)\n        return AVERROR_INVALIDDATA;\n\n    if (h->DPB[i].needs_realloc) {\n        h->DPB[i].needs_realloc = 0;\n        unref_picture(h, &h->DPB[i]);\n    }\n\n    return i;\n}\n\n/**\n * Check if the top & left blocks are available if needed and\n * change the dc mode so it only uses the available blocks.\n */\nint ff_h264_check_intra4x4_pred_mode(H264Context *h)\n{\n    static const int8_t top[12] = {\n        -1, 0, LEFT_DC_PRED, -1, -1, -1, -1, -1, 0\n    };\n    static const int8_t left[12] = {\n        0, -1, TOP_DC_PRED, 0, -1, -1, -1, 0, -1, DC_128_PRED\n    };\n    int i;\n\n    if (!(h->top_samples_available & 0x8000)) {\n        for (i = 0; i < 4; i++) {\n            int status = top[h->intra4x4_pred_mode_cache[scan8[0] + i]];\n            if (status < 0) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"top block unavailable for requested intra4x4 mode %d at %d %d\\n\",\n                       status, h->mb_x, h->mb_y);\n                return AVERROR_INVALIDDATA;\n            } else if (status) {\n                h->intra4x4_pred_mode_cache[scan8[0] + i] = status;\n            }\n        }\n    }\n\n    if ((h->left_samples_available & 0x8888) != 0x8888) {\n        static const int mask[4] = { 0x8000, 0x2000, 0x80, 0x20 };\n        for (i = 0; i < 4; i++)\n            if (!(h->left_samples_available & mask[i])) {\n                int status = left[h->intra4x4_pred_mode_cache[scan8[0] + 8 * i]];\n                if (status < 0) {\n                    av_log(h->avctx, AV_LOG_ERROR,\n                           \"left block unavailable for requested intra4x4 mode %d at %d %d\\n\",\n                           status, h->mb_x, h->mb_y);\n                    return AVERROR_INVALIDDATA;\n                } else if (status) {\n                    h->intra4x4_pred_mode_cache[scan8[0] + 8 * i] = status;\n                }\n            }\n    }\n\n    return 0;\n} // FIXME cleanup like ff_h264_check_intra_pred_mode\n\n/**\n * Check if the top & left blocks are available if needed and\n * change the dc mode so it only uses the available blocks.\n */\nint ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n{\n    static const int8_t top[4]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n    static const int8_t left[5] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n    if (mode > 3U) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"out of range intra chroma pred mode at %d %d\\n\",\n               h->mb_x, h->mb_y);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!(h->top_samples_available & 0x8000)) {\n        mode = top[mode];\n        if (mode < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n                   h->mb_x, h->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n        mode = left[mode];\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n                   (!(h->left_samples_available & 0x8000)) +\n                   2 * (mode == DC_128_PRED8x8);\n        }\n        if (mode < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n                   h->mb_x, h->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return mode;\n}\n\nconst uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src,\n                                  int *dst_length, int *consumed, int length)\n{\n    int i, si, di;\n    uint8_t *dst;\n    int bufidx;\n\n    // src[0]&0x80; // forbidden bit\n    h->nal_ref_idc   = src[0] >> 5;\n    h->nal_unit_type = src[0] & 0x1F;\n\n    src++;\n    length--;\n\n#define STARTCODE_TEST                                                  \\\n    if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {         \\\n        if (src[i + 2] != 3) {                                          \\\n            /* startcode, so we must be past the end */                 \\\n            length = i;                                                 \\\n        }                                                               \\\n        break;                                                          \\\n    }\n\n#if HAVE_FAST_UNALIGNED\n#define FIND_FIRST_ZERO                                                 \\\n    if (i > 0 && !src[i])                                               \\\n        i--;                                                            \\\n    while (src[i])                                                      \\\n        i++\n\n#if HAVE_FAST_64BIT\n    for (i = 0; i + 1 < length; i += 9) {\n        if (!((~AV_RN64A(src + i) &\n               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &\n              0x8000800080008080ULL))\n            continue;\n        FIND_FIRST_ZERO;\n        STARTCODE_TEST;\n        i -= 7;\n    }\n#else\n    for (i = 0; i + 1 < length; i += 5) {\n        if (!((~AV_RN32A(src + i) &\n               (AV_RN32A(src + i) - 0x01000101U)) &\n              0x80008080U))\n            continue;\n        FIND_FIRST_ZERO;\n        STARTCODE_TEST;\n        i -= 3;\n    }\n#endif\n#else\n    for (i = 0; i + 1 < length; i += 2) {\n        if (src[i])\n            continue;\n        if (i > 0 && src[i - 1] == 0)\n            i--;\n        STARTCODE_TEST;\n    }\n#endif\n\n    // use second escape buffer for inter data\n    bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0;\n\n    si = h->rbsp_buffer_size[bufidx];\n    av_fast_padded_malloc(&h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+MAX_MBPAIR_SIZE);\n    dst = h->rbsp_buffer[bufidx];\n\n    if (dst == NULL)\n        return NULL;\n\n    if(i>=length-1){ //no escaped 0\n        *dst_length= length;\n        *consumed= length+1; //+1 for the header\n        if(h->avctx->flags2 & CODEC_FLAG2_FAST){\n            return src;\n        }else{\n            memcpy(dst, src, length);\n            return dst;\n        }\n    }\n\n    memcpy(dst, src, i);\n    si = di = i;\n    while (si + 2 < length) {\n        // remove escapes (very rare 1:2^22)\n        if (src[si + 2] > 3) {\n            dst[di++] = src[si++];\n            dst[di++] = src[si++];\n        } else if (src[si] == 0 && src[si + 1] == 0) {\n            if (src[si + 2] == 3) { // escape\n                dst[di++]  = 0;\n                dst[di++]  = 0;\n                si        += 3;\n                continue;\n            } else // next start code\n                goto nsc;\n        }\n\n        dst[di++] = src[si++];\n    }\n    while (si < length)\n        dst[di++] = src[si++];\n\nnsc:\n    memset(dst + di, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n    *dst_length = di;\n    *consumed   = si + 1; // +1 for the header\n    /* FIXME store exact number of bits in the getbitcontext\n     * (it is needed for decoding) */\n    return dst;\n}\n\n/**\n * Identify the exact end of the bitstream\n * @return the length of the trailing, or 0 if damaged\n */\nstatic int decode_rbsp_trailing(H264Context *h, const uint8_t *src)\n{\n    int v = *src;\n    int r;\n\n    tprintf(h->avctx, \"rbsp trailing %X\\n\", v);\n\n    for (r = 1; r < 9; r++) {\n        if (v & 1)\n            return r;\n        v >>= 1;\n    }\n    return 0;\n}\n\nstatic inline int get_lowest_part_list_y(H264Context *h, Picture *pic, int n,\n                                         int height, int y_offset, int list)\n{\n    int raw_my             = h->mv_cache[list][scan8[n]][1];\n    int filter_height_down = (raw_my & 3) ? 3 : 0;\n    int full_my            = (raw_my >> 2) + y_offset;\n    int bottom             = full_my + filter_height_down + height;\n\n    av_assert2(height >= 0);\n\n    return FFMAX(0, bottom);\n}\n\nstatic inline void get_lowest_part_y(H264Context *h, int refs[2][48], int n,\n                                     int height, int y_offset, int list0,\n                                     int list1, int *nrefs)\n{\n    int my;\n\n    y_offset += 16 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0) {\n        int ref_n    = h->ref_cache[0][scan8[n]];\n        Picture *ref = &h->ref_list[0][ref_n];\n\n        // Error resilience puts the current picture in the ref list.\n        // Don't try to wait on these as it will cause a deadlock.\n        // Fields can wait on each other, though.\n        if (ref->tf.progress->data != h->cur_pic.tf.progress->data ||\n            (ref->reference & 3) != h->picture_structure) {\n            my = get_lowest_part_list_y(h, ref, n, height, y_offset, 0);\n            if (refs[0][ref_n] < 0)\n                nrefs[0] += 1;\n            refs[0][ref_n] = FFMAX(refs[0][ref_n], my);\n        }\n    }\n\n    if (list1) {\n        int ref_n    = h->ref_cache[1][scan8[n]];\n        Picture *ref = &h->ref_list[1][ref_n];\n\n        if (ref->tf.progress->data != h->cur_pic.tf.progress->data ||\n            (ref->reference & 3) != h->picture_structure) {\n            my = get_lowest_part_list_y(h, ref, n, height, y_offset, 1);\n            if (refs[1][ref_n] < 0)\n                nrefs[1] += 1;\n            refs[1][ref_n] = FFMAX(refs[1][ref_n], my);\n        }\n    }\n}\n\n/**\n * Wait until all reference frames are available for MC operations.\n *\n * @param h the H264 context\n */\nstatic void await_references(H264Context *h)\n{\n    const int mb_xy   = h->mb_xy;\n    const int mb_type = h->cur_pic.mb_type[mb_xy];\n    int refs[2][48];\n    int nrefs[2] = { 0 };\n    int ref, list;\n\n    memset(refs, -1, sizeof(refs));\n\n    if (IS_16X16(mb_type)) {\n        get_lowest_part_y(h, refs, 0, 16, 0,\n                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\n    } else if (IS_16X8(mb_type)) {\n        get_lowest_part_y(h, refs, 0, 8, 0,\n                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\n        get_lowest_part_y(h, refs, 8, 8, 8,\n                          IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);\n    } else if (IS_8X16(mb_type)) {\n        get_lowest_part_y(h, refs, 0, 16, 0,\n                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);\n        get_lowest_part_y(h, refs, 4, 16, 0,\n                          IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);\n    } else {\n        int i;\n\n        av_assert2(IS_8X8(mb_type));\n\n        for (i = 0; i < 4; i++) {\n            const int sub_mb_type = h->sub_mb_type[i];\n            const int n           = 4 * i;\n            int y_offset          = (i & 2) << 2;\n\n            if (IS_SUB_8X8(sub_mb_type)) {\n                get_lowest_part_y(h, refs, n, 8, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n            } else if (IS_SUB_8X4(sub_mb_type)) {\n                get_lowest_part_y(h, refs, n, 4, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n                get_lowest_part_y(h, refs, n + 2, 4, y_offset + 4,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n            } else if (IS_SUB_4X8(sub_mb_type)) {\n                get_lowest_part_y(h, refs, n, 8, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n                get_lowest_part_y(h, refs, n + 1, 8, y_offset,\n                                  IS_DIR(sub_mb_type, 0, 0),\n                                  IS_DIR(sub_mb_type, 0, 1),\n                                  nrefs);\n            } else {\n                int j;\n                av_assert2(IS_SUB_4X4(sub_mb_type));\n                for (j = 0; j < 4; j++) {\n                    int sub_y_offset = y_offset + 2 * (j & 2);\n                    get_lowest_part_y(h, refs, n + j, 4, sub_y_offset,\n                                      IS_DIR(sub_mb_type, 0, 0),\n                                      IS_DIR(sub_mb_type, 0, 1),\n                                      nrefs);\n                }\n            }\n        }\n    }\n\n    for (list = h->list_count - 1; list >= 0; list--)\n        for (ref = 0; ref < 48 && nrefs[list]; ref++) {\n            int row = refs[list][ref];\n            if (row >= 0) {\n                Picture *ref_pic      = &h->ref_list[list][ref];\n                int ref_field         = ref_pic->reference - 1;\n                int ref_field_picture = ref_pic->field_picture;\n                int pic_height        = 16 * h->mb_height >> ref_field_picture;\n\n                row <<= MB_MBAFF(h);\n                nrefs[list]--;\n\n                if (!FIELD_PICTURE(h) && ref_field_picture) { // frame referencing two fields\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN((row >> 1) - !(row & 1),\n                                                   pic_height - 1),\n                                             1);\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN((row >> 1), pic_height - 1),\n                                             0);\n                } else if (FIELD_PICTURE(h) && !ref_field_picture) { // field referencing one field of a frame\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN(row * 2 + ref_field,\n                                                   pic_height - 1),\n                                             0);\n                } else if (FIELD_PICTURE(h)) {\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN(row, pic_height - 1),\n                                             ref_field);\n                } else {\n                    ff_thread_await_progress(&ref_pic->tf,\n                                             FFMIN(row, pic_height - 1),\n                                             0);\n                }\n            }\n        }\n}\n\nstatic av_always_inline void mc_dir_part(H264Context *h, Picture *pic,\n                                         int n, int square, int height,\n                                         int delta, int list,\n                                         uint8_t *dest_y, uint8_t *dest_cb,\n                                         uint8_t *dest_cr,\n                                         int src_x_offset, int src_y_offset,\n                                         qpel_mc_func *qpix_op,\n                                         h264_chroma_mc_func chroma_op,\n                                         int pixel_shift, int chroma_idc)\n{\n    const int mx      = h->mv_cache[list][scan8[n]][0] + src_x_offset * 8;\n    int my            = h->mv_cache[list][scan8[n]][1] + src_y_offset * 8;\n    const int luma_xy = (mx & 3) + ((my & 3) << 2);\n    ptrdiff_t offset  = ((mx >> 2) << pixel_shift) + (my >> 2) * h->mb_linesize;\n    uint8_t *src_y    = pic->f.data[0] + offset;\n    uint8_t *src_cb, *src_cr;\n    int extra_width  = 0;\n    int extra_height = 0;\n    int emu = 0;\n    const int full_mx    = mx >> 2;\n    const int full_my    = my >> 2;\n    const int pic_width  = 16 * h->mb_width;\n    const int pic_height = 16 * h->mb_height >> MB_FIELD(h);\n    int ysh;\n\n    if (mx & 7)\n        extra_width -= 3;\n    if (my & 7)\n        extra_height -= 3;\n\n    if (full_mx                <          0 - extra_width  ||\n        full_my                <          0 - extra_height ||\n        full_mx + 16 /*FIXME*/ > pic_width  + extra_width  ||\n        full_my + 16 /*FIXME*/ > pic_height + extra_height) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_linesize,\n                                 src_y - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                 h->mb_linesize,\n                                 16 + 5, 16 + 5 /*FIXME*/, full_mx - 2,\n                                 full_my - 2, pic_width, pic_height);\n        src_y = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        emu   = 1;\n    }\n\n    qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); // FIXME try variable height perhaps?\n    if (!square)\n        qpix_op[luma_xy](dest_y + delta, src_y + delta, h->mb_linesize);\n\n    if (CONFIG_GRAY && h->flags & CODEC_FLAG_GRAY)\n        return;\n\n    if (chroma_idc == 3 /* yuv444 */) {\n        src_cb = pic->f.data[1] + offset;\n        if (emu) {\n            h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_linesize,\n                                     src_cb - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                     h->mb_linesize,\n                                     16 + 5, 16 + 5 /*FIXME*/,\n                                     full_mx - 2, full_my - 2,\n                                     pic_width, pic_height);\n            src_cb = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        }\n        qpix_op[luma_xy](dest_cb, src_cb, h->mb_linesize); // FIXME try variable height perhaps?\n        if (!square)\n            qpix_op[luma_xy](dest_cb + delta, src_cb + delta, h->mb_linesize);\n\n        src_cr = pic->f.data[2] + offset;\n        if (emu) {\n            h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_linesize,\n                                     src_cr - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                     h->mb_linesize,\n                                     16 + 5, 16 + 5 /*FIXME*/,\n                                     full_mx - 2, full_my - 2,\n                                     pic_width, pic_height);\n            src_cr = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        }\n        qpix_op[luma_xy](dest_cr, src_cr, h->mb_linesize); // FIXME try variable height perhaps?\n        if (!square)\n            qpix_op[luma_xy](dest_cr + delta, src_cr + delta, h->mb_linesize);\n        return;\n    }\n\n    ysh = 3 - (chroma_idc == 2 /* yuv422 */);\n    if (chroma_idc == 1 /* yuv420 */ && MB_FIELD(h)) {\n        // chroma offset when predicting from a field of opposite parity\n        my  += 2 * ((h->mb_y & 1) - (pic->reference - 1));\n        emu |= (my >> 3) < 0 || (my >> 3) + 8 >= (pic_height >> 1);\n    }\n\n    src_cb = pic->f.data[1] + ((mx >> 3) << pixel_shift) +\n             (my >> ysh) * h->mb_uvlinesize;\n    src_cr = pic->f.data[2] + ((mx >> 3) << pixel_shift) +\n             (my >> ysh) * h->mb_uvlinesize;\n\n    if (emu) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_uvlinesize, src_cb, h->mb_uvlinesize,\n                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),\n                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));\n        src_cb = h->edge_emu_buffer;\n    }\n    chroma_op(dest_cb, src_cb, h->mb_uvlinesize,\n              height >> (chroma_idc == 1 /* yuv420 */),\n              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);\n\n    if (emu) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, h->mb_uvlinesize, src_cr, h->mb_uvlinesize,\n                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),\n                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));\n        src_cr = h->edge_emu_buffer;\n    }\n    chroma_op(dest_cr, src_cr, h->mb_uvlinesize, height >> (chroma_idc == 1 /* yuv420 */),\n              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);\n}\n\nstatic av_always_inline void mc_part_std(H264Context *h, int n, int square,\n                                         int height, int delta,\n                                         uint8_t *dest_y, uint8_t *dest_cb,\n                                         uint8_t *dest_cr,\n                                         int x_offset, int y_offset,\n                                         qpel_mc_func *qpix_put,\n                                         h264_chroma_mc_func chroma_put,\n                                         qpel_mc_func *qpix_avg,\n                                         h264_chroma_mc_func chroma_avg,\n                                         int list0, int list1,\n                                         int pixel_shift, int chroma_idc)\n{\n    qpel_mc_func *qpix_op         = qpix_put;\n    h264_chroma_mc_func chroma_op = chroma_put;\n\n    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    if (chroma_idc == 3 /* yuv444 */) {\n        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    } else if (chroma_idc == 2 /* yuv422 */) {\n        dest_cb += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n        dest_cr += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n    } else { /* yuv420 */\n        dest_cb += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n        dest_cr += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n    }\n    x_offset += 8 * h->mb_x;\n    y_offset += 8 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0) {\n        Picture *ref = &h->ref_list[0][h->ref_cache[0][scan8[n]]];\n        mc_dir_part(h, ref, n, square, height, delta, 0,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_op, chroma_op, pixel_shift, chroma_idc);\n\n        qpix_op   = qpix_avg;\n        chroma_op = chroma_avg;\n    }\n\n    if (list1) {\n        Picture *ref = &h->ref_list[1][h->ref_cache[1][scan8[n]]];\n        mc_dir_part(h, ref, n, square, height, delta, 1,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_op, chroma_op, pixel_shift, chroma_idc);\n    }\n}\n\nstatic av_always_inline void mc_part_weighted(H264Context *h, int n, int square,\n                                              int height, int delta,\n                                              uint8_t *dest_y, uint8_t *dest_cb,\n                                              uint8_t *dest_cr,\n                                              int x_offset, int y_offset,\n                                              qpel_mc_func *qpix_put,\n                                              h264_chroma_mc_func chroma_put,\n                                              h264_weight_func luma_weight_op,\n                                              h264_weight_func chroma_weight_op,\n                                              h264_biweight_func luma_weight_avg,\n                                              h264_biweight_func chroma_weight_avg,\n                                              int list0, int list1,\n                                              int pixel_shift, int chroma_idc)\n{\n    int chroma_height;\n\n    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    if (chroma_idc == 3 /* yuv444 */) {\n        chroma_height     = height;\n        chroma_weight_avg = luma_weight_avg;\n        chroma_weight_op  = luma_weight_op;\n        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    } else if (chroma_idc == 2 /* yuv422 */) {\n        chroma_height = height;\n        dest_cb      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n        dest_cr      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n    } else { /* yuv420 */\n        chroma_height = height >> 1;\n        dest_cb      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n        dest_cr      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n    }\n    x_offset += 8 * h->mb_x;\n    y_offset += 8 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0 && list1) {\n        /* don't optimize for luma-only case, since B-frames usually\n         * use implicit weights => chroma too. */\n        uint8_t *tmp_cb = h->bipred_scratchpad;\n        uint8_t *tmp_cr = h->bipred_scratchpad + (16 << pixel_shift);\n        uint8_t *tmp_y  = h->bipred_scratchpad + 16 * h->mb_uvlinesize;\n        int refn0       = h->ref_cache[0][scan8[n]];\n        int refn1       = h->ref_cache[1][scan8[n]];\n\n        mc_dir_part(h, &h->ref_list[0][refn0], n, square, height, delta, 0,\n                    dest_y, dest_cb, dest_cr,\n                    x_offset, y_offset, qpix_put, chroma_put,\n                    pixel_shift, chroma_idc);\n        mc_dir_part(h, &h->ref_list[1][refn1], n, square, height, delta, 1,\n                    tmp_y, tmp_cb, tmp_cr,\n                    x_offset, y_offset, qpix_put, chroma_put,\n                    pixel_shift, chroma_idc);\n\n        if (h->use_weight == 2) {\n            int weight0 = h->implicit_weight[refn0][refn1][h->mb_y & 1];\n            int weight1 = 64 - weight0;\n            luma_weight_avg(dest_y, tmp_y, h->mb_linesize,\n                            height, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize,\n                              chroma_height, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize,\n                              chroma_height, 5, weight0, weight1, 0);\n        } else {\n            luma_weight_avg(dest_y, tmp_y, h->mb_linesize, height,\n                            h->luma_log2_weight_denom,\n                            h->luma_weight[refn0][0][0],\n                            h->luma_weight[refn1][1][0],\n                            h->luma_weight[refn0][0][1] +\n                            h->luma_weight[refn1][1][1]);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, chroma_height,\n                              h->chroma_log2_weight_denom,\n                              h->chroma_weight[refn0][0][0][0],\n                              h->chroma_weight[refn1][1][0][0],\n                              h->chroma_weight[refn0][0][0][1] +\n                              h->chroma_weight[refn1][1][0][1]);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, chroma_height,\n                              h->chroma_log2_weight_denom,\n                              h->chroma_weight[refn0][0][1][0],\n                              h->chroma_weight[refn1][1][1][0],\n                              h->chroma_weight[refn0][0][1][1] +\n                              h->chroma_weight[refn1][1][1][1]);\n        }\n    } else {\n        int list     = list1 ? 1 : 0;\n        int refn     = h->ref_cache[list][scan8[n]];\n        Picture *ref = &h->ref_list[list][refn];\n        mc_dir_part(h, ref, n, square, height, delta, list,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_put, chroma_put, pixel_shift, chroma_idc);\n\n        luma_weight_op(dest_y, h->mb_linesize, height,\n                       h->luma_log2_weight_denom,\n                       h->luma_weight[refn][list][0],\n                       h->luma_weight[refn][list][1]);\n        if (h->use_weight_chroma) {\n            chroma_weight_op(dest_cb, h->mb_uvlinesize, chroma_height,\n                             h->chroma_log2_weight_denom,\n                             h->chroma_weight[refn][list][0][0],\n                             h->chroma_weight[refn][list][0][1]);\n            chroma_weight_op(dest_cr, h->mb_uvlinesize, chroma_height,\n                             h->chroma_log2_weight_denom,\n                             h->chroma_weight[refn][list][1][0],\n                             h->chroma_weight[refn][list][1][1]);\n        }\n    }\n}\n\nstatic av_always_inline void prefetch_motion(H264Context *h, int list,\n                                             int pixel_shift, int chroma_idc)\n{\n    /* fetch pixels for estimated mv 4 macroblocks ahead\n     * optimized for 64byte cache lines */\n    const int refn = h->ref_cache[list][scan8[0]];\n    if (refn >= 0) {\n        const int mx  = (h->mv_cache[list][scan8[0]][0] >> 2) + 16 * h->mb_x + 8;\n        const int my  = (h->mv_cache[list][scan8[0]][1] >> 2) + 16 * h->mb_y;\n        uint8_t **src = h->ref_list[list][refn].f.data;\n        int off       = (mx << pixel_shift) +\n                        (my + (h->mb_x & 3) * 4) * h->mb_linesize +\n                        (64 << pixel_shift);\n        h->vdsp.prefetch(src[0] + off, h->linesize, 4);\n        if (chroma_idc == 3 /* yuv444 */) {\n            h->vdsp.prefetch(src[1] + off, h->linesize, 4);\n            h->vdsp.prefetch(src[2] + off, h->linesize, 4);\n        } else {\n            off= (((mx>>1)+64)<<pixel_shift) + ((my>>1) + (h->mb_x&7))*h->uvlinesize;\n            h->vdsp.prefetch(src[1] + off, src[2] - src[1], 2);\n        }\n    }\n}\n\nstatic void free_tables(H264Context *h, int free_rbsp)\n{\n    int i;\n    H264Context *hx;\n\n    av_freep(&h->intra4x4_pred_mode);\n    av_freep(&h->chroma_pred_mode_table);\n    av_freep(&h->cbp_table);\n    av_freep(&h->mvd_table[0]);\n    av_freep(&h->mvd_table[1]);\n    av_freep(&h->direct_table);\n    av_freep(&h->non_zero_count);\n    av_freep(&h->slice_table_base);\n    h->slice_table = NULL;\n    av_freep(&h->list_counts);\n\n    av_freep(&h->mb2b_xy);\n    av_freep(&h->mb2br_xy);\n\n    for (i = 0; i < 3; i++)\n        av_freep(&h->visualization_buffer[i]);\n\n    av_buffer_pool_uninit(&h->qscale_table_pool);\n    av_buffer_pool_uninit(&h->mb_type_pool);\n    av_buffer_pool_uninit(&h->motion_val_pool);\n    av_buffer_pool_uninit(&h->ref_index_pool);\n\n    if (free_rbsp && h->DPB) {\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            unref_picture(h, &h->DPB[i]);\n        av_freep(&h->DPB);\n    } else if (h->DPB) {\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            h->DPB[i].needs_realloc = 1;\n    }\n\n    h->cur_pic_ptr = NULL;\n\n    for (i = 0; i < MAX_THREADS; i++) {\n        hx = h->thread_context[i];\n        if (!hx)\n            continue;\n        av_freep(&hx->top_borders[1]);\n        av_freep(&hx->top_borders[0]);\n        av_freep(&hx->bipred_scratchpad);\n        av_freep(&hx->edge_emu_buffer);\n        av_freep(&hx->dc_val_base);\n        av_freep(&hx->me.scratchpad);\n        av_freep(&hx->er.mb_index2xy);\n        av_freep(&hx->er.error_status_table);\n        av_freep(&hx->er.er_temp_buffer);\n        av_freep(&hx->er.mbintra_table);\n        av_freep(&hx->er.mbskip_table);\n\n        if (free_rbsp) {\n            av_freep(&hx->rbsp_buffer[1]);\n            av_freep(&hx->rbsp_buffer[0]);\n            hx->rbsp_buffer_size[0] = 0;\n            hx->rbsp_buffer_size[1] = 0;\n        }\n        if (i)\n            av_freep(&h->thread_context[i]);\n    }\n}\n\nstatic void init_dequant8_coeff_table(H264Context *h)\n{\n    int i, j, q, x;\n    const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);\n\n    for (i = 0; i < 6; i++) {\n        h->dequant8_coeff[i] = h->dequant8_buffer[i];\n        for (j = 0; j < i; j++)\n            if (!memcmp(h->pps.scaling_matrix8[j], h->pps.scaling_matrix8[i],\n                        64 * sizeof(uint8_t))) {\n                h->dequant8_coeff[i] = h->dequant8_buffer[j];\n                break;\n            }\n        if (j < i)\n            continue;\n\n        for (q = 0; q < max_qp + 1; q++) {\n            int shift = div6[q];\n            int idx   = rem6[q];\n            for (x = 0; x < 64; x++)\n                h->dequant8_coeff[i][q][(x >> 3) | ((x & 7) << 3)] =\n                    ((uint32_t)dequant8_coeff_init[idx][dequant8_coeff_init_scan[((x >> 1) & 12) | (x & 3)]] *\n                     h->pps.scaling_matrix8[i][x]) << shift;\n        }\n    }\n}\n\nstatic void init_dequant4_coeff_table(H264Context *h)\n{\n    int i, j, q, x;\n    const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);\n    for (i = 0; i < 6; i++) {\n        h->dequant4_coeff[i] = h->dequant4_buffer[i];\n        for (j = 0; j < i; j++)\n            if (!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i],\n                        16 * sizeof(uint8_t))) {\n                h->dequant4_coeff[i] = h->dequant4_buffer[j];\n                break;\n            }\n        if (j < i)\n            continue;\n\n        for (q = 0; q < max_qp + 1; q++) {\n            int shift = div6[q] + 2;\n            int idx   = rem6[q];\n            for (x = 0; x < 16; x++)\n                h->dequant4_coeff[i][q][(x >> 2) | ((x << 2) & 0xF)] =\n                    ((uint32_t)dequant4_coeff_init[idx][(x & 1) + ((x >> 2) & 1)] *\n                     h->pps.scaling_matrix4[i][x]) << shift;\n        }\n    }\n}\n\nstatic void init_dequant_tables(H264Context *h)\n{\n    int i, x;\n    init_dequant4_coeff_table(h);\n    if (h->pps.transform_8x8_mode)\n        init_dequant8_coeff_table(h);\n    if (h->sps.transform_bypass) {\n        for (i = 0; i < 6; i++)\n            for (x = 0; x < 16; x++)\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n        if (h->pps.transform_8x8_mode)\n            for (i = 0; i < 6; i++)\n                for (x = 0; x < 64; x++)\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n    }\n}\n\nint ff_h264_alloc_tables(H264Context *h)\n{\n    const int big_mb_num = h->mb_stride * (h->mb_height + 1);\n    const int row_mb_num = 2*h->mb_stride*FFMAX(h->avctx->thread_count, 1);\n    int x, y, i;\n\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->intra4x4_pred_mode,\n                      row_mb_num * 8 * sizeof(uint8_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->non_zero_count,\n                      big_mb_num * 48 * sizeof(uint8_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->slice_table_base,\n                      (big_mb_num + h->mb_stride) * sizeof(*h->slice_table_base), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->cbp_table,\n                      big_mb_num * sizeof(uint16_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->chroma_pred_mode_table,\n                      big_mb_num * sizeof(uint8_t), fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mvd_table[0],\n                      16 * row_mb_num * sizeof(uint8_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mvd_table[1],\n                      16 * row_mb_num * sizeof(uint8_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->direct_table,\n                      4 * big_mb_num * sizeof(uint8_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->list_counts,\n                      big_mb_num * sizeof(uint8_t), fail)\n\n    memset(h->slice_table_base, -1,\n           (big_mb_num + h->mb_stride) * sizeof(*h->slice_table_base));\n    h->slice_table = h->slice_table_base + h->mb_stride * 2 + 1;\n\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mb2b_xy,\n                      big_mb_num * sizeof(uint32_t), fail);\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->mb2br_xy,\n                      big_mb_num * sizeof(uint32_t), fail);\n    for (y = 0; y < h->mb_height; y++)\n        for (x = 0; x < h->mb_width; x++) {\n            const int mb_xy = x + y * h->mb_stride;\n            const int b_xy  = 4 * x + 4 * y * h->b_stride;\n\n            h->mb2b_xy[mb_xy]  = b_xy;\n            h->mb2br_xy[mb_xy] = 8 * (FMO ? mb_xy : (mb_xy % (2 * h->mb_stride)));\n        }\n\n    if (!h->dequant4_coeff[0])\n        init_dequant_tables(h);\n\n    if (!h->DPB) {\n        h->DPB = av_mallocz_array(MAX_PICTURE_COUNT, sizeof(*h->DPB));\n        if (!h->DPB)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            avcodec_get_frame_defaults(&h->DPB[i].f);\n        avcodec_get_frame_defaults(&h->cur_pic.f);\n    }\n\n    return 0;\n\nfail:\n    free_tables(h, 1);\n    return AVERROR(ENOMEM);\n}\n\n/**\n * Mimic alloc_tables(), but for every context thread.\n */\nstatic void clone_tables(H264Context *dst, H264Context *src, int i)\n{\n    dst->intra4x4_pred_mode     = src->intra4x4_pred_mode + i * 8 * 2 * src->mb_stride;\n    dst->non_zero_count         = src->non_zero_count;\n    dst->slice_table            = src->slice_table;\n    dst->cbp_table              = src->cbp_table;\n    dst->mb2b_xy                = src->mb2b_xy;\n    dst->mb2br_xy               = src->mb2br_xy;\n    dst->chroma_pred_mode_table = src->chroma_pred_mode_table;\n    dst->mvd_table[0]           = src->mvd_table[0] + i * 8 * 2 * src->mb_stride;\n    dst->mvd_table[1]           = src->mvd_table[1] + i * 8 * 2 * src->mb_stride;\n    dst->direct_table           = src->direct_table;\n    dst->list_counts            = src->list_counts;\n    dst->DPB                    = src->DPB;\n    dst->cur_pic_ptr            = src->cur_pic_ptr;\n    dst->cur_pic                = src->cur_pic;\n    dst->bipred_scratchpad      = NULL;\n    dst->edge_emu_buffer        = NULL;\n    dst->me.scratchpad          = NULL;\n    ff_h264_pred_init(&dst->hpc, src->avctx->codec_id, src->sps.bit_depth_luma,\n                      src->sps.chroma_format_idc);\n}\n\n/**\n * Init context\n * Allocate buffers which are not shared amongst multiple threads.\n */\nstatic int context_init(H264Context *h)\n{\n    ERContext *er = &h->er;\n    int mb_array_size = h->mb_height * h->mb_stride;\n    int y_size  = (2 * h->mb_width + 1) * (2 * h->mb_height + 1);\n    int c_size  = h->mb_stride * (h->mb_height + 1);\n    int yc_size = y_size + 2   * c_size;\n    int x, y, i;\n\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->top_borders[0],\n                      h->mb_width * 16 * 3 * sizeof(uint8_t) * 2, fail)\n    FF_ALLOCZ_OR_GOTO(h->avctx, h->top_borders[1],\n                      h->mb_width * 16 * 3 * sizeof(uint8_t) * 2, fail)\n\n    h->ref_cache[0][scan8[5]  + 1] =\n    h->ref_cache[0][scan8[7]  + 1] =\n    h->ref_cache[0][scan8[13] + 1] =\n    h->ref_cache[1][scan8[5]  + 1] =\n    h->ref_cache[1][scan8[7]  + 1] =\n    h->ref_cache[1][scan8[13] + 1] = PART_NOT_AVAILABLE;\n\n    if (CONFIG_ERROR_RESILIENCE) {\n        /* init ER */\n        er->avctx          = h->avctx;\n        er->dsp            = &h->dsp;\n        er->decode_mb      = h264_er_decode_mb;\n        er->opaque         = h;\n        er->quarter_sample = 1;\n\n        er->mb_num      = h->mb_num;\n        er->mb_width    = h->mb_width;\n        er->mb_height   = h->mb_height;\n        er->mb_stride   = h->mb_stride;\n        er->b8_stride   = h->mb_width * 2 + 1;\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, er->mb_index2xy, (h->mb_num + 1) * sizeof(int),\n                          fail); // error ressilience code looks cleaner with this\n        for (y = 0; y < h->mb_height; y++)\n            for (x = 0; x < h->mb_width; x++)\n                er->mb_index2xy[x + y * h->mb_width] = x + y * h->mb_stride;\n\n        er->mb_index2xy[h->mb_height * h->mb_width] = (h->mb_height - 1) *\n                                                      h->mb_stride + h->mb_width;\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, er->error_status_table,\n                          mb_array_size * sizeof(uint8_t), fail);\n\n        FF_ALLOC_OR_GOTO(h->avctx, er->mbintra_table, mb_array_size, fail);\n        memset(er->mbintra_table, 1, mb_array_size);\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, er->mbskip_table, mb_array_size + 2, fail);\n\n        FF_ALLOC_OR_GOTO(h->avctx, er->er_temp_buffer, h->mb_height * h->mb_stride,\n                         fail);\n\n        FF_ALLOCZ_OR_GOTO(h->avctx, h->dc_val_base, yc_size * sizeof(int16_t), fail);\n        er->dc_val[0] = h->dc_val_base + h->mb_width * 2 + 2;\n        er->dc_val[1] = h->dc_val_base + y_size + h->mb_stride + 1;\n        er->dc_val[2] = er->dc_val[1] + c_size;\n        for (i = 0; i < yc_size; i++)\n            h->dc_val_base[i] = 1024;\n    }\n\n    return 0;\n\nfail:\n    return AVERROR(ENOMEM); // free_tables will clean up for us\n}\n\nstatic int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size,\n                            int parse_extradata);\n\nint ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)\n{\n    AVCodecContext *avctx = h->avctx;\n    int ret;\n\n    if (!buf || size <= 0)\n        return -1;\n\n    if (buf[0] == 1) {\n        int i, cnt, nalsize;\n        const unsigned char *p = buf;\n\n        h->is_avc = 1;\n\n        if (size < 7) {\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n         * so put a fake nal_length_size = 2 while parsing them */\n        h->nal_length_size = 2;\n        // Decode sps from avcC\n        cnt = *(p + 5) & 0x1f; // Number of sps\n        p  += 6;\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding sps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        // Decode pps from avcC\n        cnt = *(p++); // Number of pps\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding pps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        // Now store right nal length size, that will be used to parse all other nals\n        h->nal_length_size = (buf[4] & 0x03) + 1;\n    } else {\n        h->is_avc = 0;\n        ret = decode_nal_units(h, buf, size, 1);\n        if (ret < 0)\n            return ret;\n    }\n    return size;\n}\n\nav_cold int ff_h264_decode_init(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    int i;\n    int ret;\n\n    h->avctx = avctx;\n\n    h->bit_depth_luma    = 8;\n    h->chroma_format_idc = 1;\n\n    h->avctx->bits_per_raw_sample = 8;\n    h->cur_chroma_format_idc = 1;\n\n    ff_h264dsp_init(&h->h264dsp, 8, 1);\n    av_assert0(h->sps.bit_depth_chroma == 0);\n    ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma);\n    ff_h264qpel_init(&h->h264qpel, 8);\n    ff_h264_pred_init(&h->hpc, h->avctx->codec_id, 8, 1);\n\n    h->dequant_coeff_pps = -1;\n    h->current_sps_id = -1;\n\n    /* needed so that IDCT permutation is known early */\n    if (CONFIG_ERROR_RESILIENCE)\n        ff_dsputil_init(&h->dsp, h->avctx);\n    ff_videodsp_init(&h->vdsp, 8);\n\n    memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n    memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));\n\n    h->picture_structure   = PICT_FRAME;\n    h->slice_context_count = 1;\n    h->workaround_bugs     = avctx->workaround_bugs;\n    h->flags               = avctx->flags;\n\n    /* set defaults */\n    // s->decode_mb = ff_h263_decode_mb;\n    if (!avctx->has_b_frames)\n        h->low_delay = 1;\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n\n    ff_h264_decode_init_vlc();\n\n    ff_init_cabac_states();\n\n    h->pixel_shift        = 0;\n    h->sps.bit_depth_luma = avctx->bits_per_raw_sample = 8;\n\n    h->thread_context[0] = h;\n    h->outputed_poc      = h->next_outputed_poc = INT_MIN;\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n        h->last_pocs[i] = INT_MIN;\n    h->prev_poc_msb = 1 << 16;\n    h->prev_frame_num = -1;\n    h->x264_build   = -1;\n    h->sei_fpa.frame_packing_arrangement_cancel_flag = -1;\n    ff_h264_reset_sei(h);\n    if (avctx->codec_id == AV_CODEC_ID_H264) {\n        if (avctx->ticks_per_frame == 1) {\n            if(h->avctx->time_base.den < INT_MAX/2) {\n                h->avctx->time_base.den *= 2;\n            } else\n                h->avctx->time_base.num /= 2;\n        }\n        avctx->ticks_per_frame = 2;\n    }\n\n    if (avctx->extradata_size > 0 && avctx->extradata) {\n        ret = ff_h264_decode_extradata(h, avctx->extradata, avctx->extradata_size);\n        if (ret < 0) {\n            ff_h264_free_context(h);\n            return ret;\n        }\n    }\n\n    if (h->sps.bitstream_restriction_flag &&\n        h->avctx->has_b_frames < h->sps.num_reorder_frames) {\n        h->avctx->has_b_frames = h->sps.num_reorder_frames;\n        h->low_delay           = 0;\n    }\n\n    avctx->internal->allocate_progress = 1;\n\n    flush_change(h);\n\n    return 0;\n}\n\n#define IN_RANGE(a, b, size) (((a) >= (b)) && ((a) < ((b) + (size))))\n#undef REBASE_PICTURE\n#define REBASE_PICTURE(pic, new_ctx, old_ctx)             \\\n    ((pic && pic >= old_ctx->DPB &&                       \\\n      pic < old_ctx->DPB + MAX_PICTURE_COUNT) ?           \\\n     &new_ctx->DPB[pic - old_ctx->DPB] : NULL)\n\nstatic void copy_picture_range(Picture **to, Picture **from, int count,\n                               H264Context *new_base,\n                               H264Context *old_base)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        assert((IN_RANGE(from[i], old_base, sizeof(*old_base)) ||\n                IN_RANGE(from[i], old_base->DPB,\n                         sizeof(Picture) * MAX_PICTURE_COUNT) ||\n                !from[i]));\n        to[i] = REBASE_PICTURE(from[i], new_base, old_base);\n    }\n}\n\nstatic void copy_parameter_set(void **to, void **from, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        if (to[i] && !from[i])\n            av_freep(&to[i]);\n        else if (from[i] && !to[i])\n            to[i] = av_malloc(size);\n\n        if (from[i])\n            memcpy(to[i], from[i], size);\n    }\n}\n\nstatic int decode_init_thread_copy(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n\n    if (!avctx->internal->is_copy)\n        return 0;\n    memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n    memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n\n    h->rbsp_buffer[0] = NULL;\n    h->rbsp_buffer[1] = NULL;\n    h->rbsp_buffer_size[0] = 0;\n    h->rbsp_buffer_size[1] = 0;\n    h->context_initialized = 0;\n\n    return 0;\n}\n\n#define copy_fields(to, from, start_field, end_field)                   \\\n    memcpy(&to->start_field, &from->start_field,                        \\\n           (char *)&to->end_field - (char *)&to->start_field)\n\nstatic int h264_slice_header_init(H264Context *, int);\n\nstatic int h264_set_parameter_from_sps(H264Context *h);\n\nstatic int decode_update_thread_context(AVCodecContext *dst,\n                                        const AVCodecContext *src)\n{\n    H264Context *h = dst->priv_data, *h1 = src->priv_data;\n    int inited = h->context_initialized, err = 0;\n    int context_reinitialized = 0;\n    int i, ret;\n\n    if (dst == src)\n        return 0;\n\n    if (inited &&\n        (h->width                 != h1->width                 ||\n         h->height                != h1->height                ||\n         h->mb_width              != h1->mb_width              ||\n         h->mb_height             != h1->mb_height             ||\n         h->sps.bit_depth_luma    != h1->sps.bit_depth_luma    ||\n         h->sps.chroma_format_idc != h1->sps.chroma_format_idc ||\n         h->sps.colorspace        != h1->sps.colorspace)) {\n\n        /* set bits_per_raw_sample to the previous value. the check for changed\n         * bit depth in h264_set_parameter_from_sps() uses it and sets it to\n         * the current value */\n        h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;\n\n        av_freep(&h->bipred_scratchpad);\n\n        h->width     = h1->width;\n        h->height    = h1->height;\n        h->mb_height = h1->mb_height;\n        h->mb_width  = h1->mb_width;\n        h->mb_num    = h1->mb_num;\n        h->mb_stride = h1->mb_stride;\n        h->b_stride  = h1->b_stride;\n        // SPS/PPS\n        copy_parameter_set((void **)h->sps_buffers, (void **)h1->sps_buffers,\n                        MAX_SPS_COUNT, sizeof(SPS));\n        h->sps = h1->sps;\n        copy_parameter_set((void **)h->pps_buffers, (void **)h1->pps_buffers,\n                        MAX_PPS_COUNT, sizeof(PPS));\n        h->pps = h1->pps;\n\n        if ((err = h264_slice_header_init(h, 1)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"h264_slice_header_init() failed\");\n            return err;\n        }\n        context_reinitialized = 1;\n\n#if 0\n        h264_set_parameter_from_sps(h);\n        //Note we set context_reinitialized which will cause h264_set_parameter_from_sps to be reexecuted\n        h->cur_chroma_format_idc = h1->cur_chroma_format_idc;\n#endif\n    }\n    /* update linesize on resize for h264. The h264 decoder doesn't\n     * necessarily call ff_MPV_frame_start in the new thread */\n    h->linesize   = h1->linesize;\n    h->uvlinesize = h1->uvlinesize;\n\n    /* copy block_offset since frame_start may not be called */\n    memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));\n\n    if (!inited) {\n        for (i = 0; i < MAX_SPS_COUNT; i++)\n            av_freep(h->sps_buffers + i);\n\n        for (i = 0; i < MAX_PPS_COUNT; i++)\n            av_freep(h->pps_buffers + i);\n\n        av_freep(&h->rbsp_buffer[0]);\n        av_freep(&h->rbsp_buffer[1]);\n        memcpy(h, h1, offsetof(H264Context, intra_pcm_ptr));\n        memcpy(&h->cabac, &h1->cabac,\n               sizeof(H264Context) - offsetof(H264Context, cabac));\n        av_assert0((void*)&h->cabac == &h->mb_padding + 1);\n\n        memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n        memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n\n        memset(&h->er, 0, sizeof(h->er));\n        memset(&h->me, 0, sizeof(h->me));\n        memset(&h->mb, 0, sizeof(h->mb));\n        memset(&h->mb_luma_dc, 0, sizeof(h->mb_luma_dc));\n        memset(&h->mb_padding, 0, sizeof(h->mb_padding));\n\n        h->avctx             = dst;\n        h->DPB               = NULL;\n        h->qscale_table_pool = NULL;\n        h->mb_type_pool      = NULL;\n        h->ref_index_pool    = NULL;\n        h->motion_val_pool   = NULL;\n        for (i = 0; i < 2; i++) {\n            h->rbsp_buffer[i] = NULL;\n            h->rbsp_buffer_size[i] = 0;\n        }\n\n        if (h1->context_initialized) {\n        h->context_initialized = 0;\n\n        memset(&h->cur_pic, 0, sizeof(h->cur_pic));\n        avcodec_get_frame_defaults(&h->cur_pic.f);\n        h->cur_pic.tf.f = &h->cur_pic.f;\n\n        ret = ff_h264_alloc_tables(h);\n        if (ret < 0) {\n            av_log(dst, AV_LOG_ERROR, \"Could not allocate memory for h264\\n\");\n            return ret;\n        }\n        ret = context_init(h);\n        if (ret < 0) {\n            av_log(dst, AV_LOG_ERROR, \"context_init() failed.\\n\");\n            return ret;\n        }\n        }\n\n        h->bipred_scratchpad = NULL;\n        h->edge_emu_buffer   = NULL;\n\n        h->thread_context[0] = h;\n        h->context_initialized = h1->context_initialized;\n    }\n\n    h->avctx->coded_height  = h1->avctx->coded_height;\n    h->avctx->coded_width   = h1->avctx->coded_width;\n    h->avctx->width         = h1->avctx->width;\n    h->avctx->height        = h1->avctx->height;\n    h->coded_picture_number = h1->coded_picture_number;\n    h->first_field          = h1->first_field;\n    h->picture_structure    = h1->picture_structure;\n    h->qscale               = h1->qscale;\n    h->droppable            = h1->droppable;\n    h->data_partitioning    = h1->data_partitioning;\n    h->low_delay            = h1->low_delay;\n\n    for (i = 0; h->DPB && i < MAX_PICTURE_COUNT; i++) {\n        unref_picture(h, &h->DPB[i]);\n        if (h1->DPB[i].f.data[0] &&\n            (ret = ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)\n            return ret;\n    }\n\n    h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);\n    unref_picture(h, &h->cur_pic);\n    if (h1->cur_pic.f.buf[0] && (ret = ref_picture(h, &h->cur_pic, &h1->cur_pic)) < 0)\n        return ret;\n\n    h->workaround_bugs = h1->workaround_bugs;\n    h->low_delay       = h1->low_delay;\n    h->droppable       = h1->droppable;\n\n    // extradata/NAL handling\n    h->is_avc = h1->is_avc;\n\n    // SPS/PPS\n    copy_parameter_set((void **)h->sps_buffers, (void **)h1->sps_buffers,\n                       MAX_SPS_COUNT, sizeof(SPS));\n    h->sps = h1->sps;\n    copy_parameter_set((void **)h->pps_buffers, (void **)h1->pps_buffers,\n                       MAX_PPS_COUNT, sizeof(PPS));\n    h->pps = h1->pps;\n\n    // Dequantization matrices\n    // FIXME these are big - can they be only copied when PPS changes?\n    copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n\n    for (i = 0; i < 6; i++)\n        h->dequant4_coeff[i] = h->dequant4_buffer[0] +\n                               (h1->dequant4_coeff[i] - h1->dequant4_buffer[0]);\n\n    for (i = 0; i < 6; i++)\n        h->dequant8_coeff[i] = h->dequant8_buffer[0] +\n                               (h1->dequant8_coeff[i] - h1->dequant8_buffer[0]);\n\n    h->dequant_coeff_pps = h1->dequant_coeff_pps;\n\n    // POC timing\n    copy_fields(h, h1, poc_lsb, redundant_pic_count);\n\n    // reference lists\n    copy_fields(h, h1, short_ref, cabac_init_idc);\n\n    copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);\n    copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);\n    copy_picture_range(h->delayed_pic, h1->delayed_pic,\n                       MAX_DELAYED_PIC_COUNT + 2, h, h1);\n\n    h->sync            = h1->sync;\n\n    if (context_reinitialized)\n        h264_set_parameter_from_sps(h);\n\n    if (!h->cur_pic_ptr)\n        return 0;\n\n    if (!h->droppable) {\n        err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n        h->prev_poc_msb = h->poc_msb;\n        h->prev_poc_lsb = h->poc_lsb;\n    }\n    h->prev_frame_num_offset = h->frame_num_offset;\n    h->prev_frame_num        = h->frame_num;\n    h->outputed_poc          = h->next_outputed_poc;\n\n    return err;\n}\n\nstatic int h264_frame_start(H264Context *h)\n{\n    Picture *pic;\n    int i, ret;\n    const int pixel_shift = h->pixel_shift;\n    int c[4] = {\n        1<<(h->sps.bit_depth_luma-1),\n        1<<(h->sps.bit_depth_chroma-1),\n        1<<(h->sps.bit_depth_chroma-1),\n        -1\n    };\n\n    if (!ff_thread_can_start_frame(h->avctx)) {\n        av_log(h->avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n        return -1;\n    }\n\n    release_unused_pictures(h, 1);\n    h->cur_pic_ptr = NULL;\n\n    i = find_unused_picture(h);\n    if (i < 0) {\n        av_log(h->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n        return i;\n    }\n    pic = &h->DPB[i];\n\n    pic->reference              = h->droppable ? 0 : h->picture_structure;\n    pic->f.coded_picture_number = h->coded_picture_number++;\n    pic->field_picture          = h->picture_structure != PICT_FRAME;\n\n    /*\n     * Zero key_frame here; IDR markings per slice in frame or fields are ORed\n     * in later.\n     * See decode_nal_units().\n     */\n    pic->f.key_frame = 0;\n    pic->sync        = 0;\n    pic->mmco_reset  = 0;\n\n    if ((ret = alloc_picture(h, pic)) < 0)\n        return ret;\n    if(!h->sync && !h->avctx->hwaccel &&\n       !(h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU))\n        avpriv_color_frame(&pic->f, c);\n\n    h->cur_pic_ptr = pic;\n    unref_picture(h, &h->cur_pic);\n    if ((ret = ref_picture(h, &h->cur_pic, h->cur_pic_ptr)) < 0)\n        return ret;\n\n    if (CONFIG_ERROR_RESILIENCE) {\n        ff_er_frame_start(&h->er);\n        h->er.last_pic =\n        h->er.next_pic = NULL;\n    }\n\n    assert(h->linesize && h->uvlinesize);\n\n    for (i = 0; i < 16; i++) {\n        h->block_offset[i]           = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->linesize * ((scan8[i] - scan8[0]) >> 3);\n        h->block_offset[48 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->linesize * ((scan8[i] - scan8[0]) >> 3);\n    }\n    for (i = 0; i < 16; i++) {\n        h->block_offset[16 + i]      =\n        h->block_offset[32 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);\n        h->block_offset[48 + 16 + i] =\n        h->block_offset[48 + 32 + i] = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);\n    }\n\n    // s->decode = (h->flags & CODEC_FLAG_PSNR) || !s->encoding ||\n    //             h->cur_pic.reference /* || h->contains_intra */ || 1;\n\n    /* We mark the current picture as non-reference after allocating it, so\n     * that if we break out due to an error it can be released automatically\n     * in the next ff_MPV_frame_start().\n     */\n    h->cur_pic_ptr->reference = 0;\n\n    h->cur_pic_ptr->field_poc[0] = h->cur_pic_ptr->field_poc[1] = INT_MAX;\n\n    h->next_output_pic = NULL;\n\n    assert(h->cur_pic_ptr->long_ref == 0);\n\n    return 0;\n}\n\n/**\n * Run setup operations that must be run after slice header decoding.\n * This includes finding the next displayed frame.\n *\n * @param h h264 master context\n * @param setup_finished enough NALs have been read that we can call\n * ff_thread_finish_setup()\n */\nstatic void decode_postinit(H264Context *h, int setup_finished)\n{\n    Picture *out = h->cur_pic_ptr;\n    Picture *cur = h->cur_pic_ptr;\n    int i, pics, out_of_order, out_idx;\n\n    h->cur_pic_ptr->f.pict_type = h->pict_type;\n\n    if (h->next_output_pic)\n        return;\n\n    if (cur->field_poc[0] == INT_MAX || cur->field_poc[1] == INT_MAX) {\n        /* FIXME: if we have two PAFF fields in one packet, we can't start\n         * the next thread here. If we have one field per packet, we can.\n         * The check in decode_nal_units() is not good enough to find this\n         * yet, so we assume the worst for now. */\n        // if (setup_finished)\n        //    ff_thread_finish_setup(h->avctx);\n        return;\n    }\n\n    cur->f.interlaced_frame = 0;\n    cur->f.repeat_pict      = 0;\n\n    /* Signal interlacing information externally. */\n    /* Prioritize picture timing SEI information over used\n     * decoding process if it exists. */\n\n    if (h->sps.pic_struct_present_flag) {\n        switch (h->sei_pic_struct) {\n        case SEI_PIC_STRUCT_FRAME:\n            break;\n        case SEI_PIC_STRUCT_TOP_FIELD:\n        case SEI_PIC_STRUCT_BOTTOM_FIELD:\n            cur->f.interlaced_frame = 1;\n            break;\n        case SEI_PIC_STRUCT_TOP_BOTTOM:\n        case SEI_PIC_STRUCT_BOTTOM_TOP:\n            if (FIELD_OR_MBAFF_PICTURE(h))\n                cur->f.interlaced_frame = 1;\n            else\n                // try to flag soft telecine progressive\n                cur->f.interlaced_frame = h->prev_interlaced_frame;\n            break;\n        case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n        case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n            /* Signal the possibility of telecined film externally\n             * (pic_struct 5,6). From these hints, let the applications\n             * decide if they apply deinterlacing. */\n            cur->f.repeat_pict = 1;\n            break;\n        case SEI_PIC_STRUCT_FRAME_DOUBLING:\n            cur->f.repeat_pict = 2;\n            break;\n        case SEI_PIC_STRUCT_FRAME_TRIPLING:\n            cur->f.repeat_pict = 4;\n            break;\n        }\n\n        if ((h->sei_ct_type & 3) &&\n            h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)\n            cur->f.interlaced_frame = (h->sei_ct_type & (1 << 1)) != 0;\n    } else {\n        /* Derive interlacing flag from used decoding process. */\n        cur->f.interlaced_frame = FIELD_OR_MBAFF_PICTURE(h);\n    }\n    h->prev_interlaced_frame = cur->f.interlaced_frame;\n\n    if (cur->field_poc[0] != cur->field_poc[1]) {\n        /* Derive top_field_first from field pocs. */\n        cur->f.top_field_first = cur->field_poc[0] < cur->field_poc[1];\n    } else {\n        if (cur->f.interlaced_frame || h->sps.pic_struct_present_flag) {\n            /* Use picture timing SEI information. Even if it is a\n             * information of a past frame, better than nothing. */\n            if (h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM ||\n                h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)\n                cur->f.top_field_first = 1;\n            else\n                cur->f.top_field_first = 0;\n        } else {\n            /* Most likely progressive */\n            cur->f.top_field_first = 0;\n        }\n    }\n\n    cur->mmco_reset = h->mmco_reset;\n    h->mmco_reset = 0;\n    // FIXME do something with unavailable reference frames\n\n    /* Sort B-frames into display order */\n\n    if (h->sps.bitstream_restriction_flag &&\n        h->avctx->has_b_frames < h->sps.num_reorder_frames) {\n        h->avctx->has_b_frames = h->sps.num_reorder_frames;\n        h->low_delay           = 0;\n    }\n\n    if (h->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT &&\n        !h->sps.bitstream_restriction_flag) {\n        h->avctx->has_b_frames = MAX_DELAYED_PIC_COUNT - 1;\n        h->low_delay           = 0;\n    }\n\n    for (i = 0; 1; i++) {\n        if(i == MAX_DELAYED_PIC_COUNT || cur->poc < h->last_pocs[i]){\n            if(i)\n                h->last_pocs[i-1] = cur->poc;\n            break;\n        } else if(i) {\n            h->last_pocs[i-1]= h->last_pocs[i];\n        }\n    }\n    out_of_order = MAX_DELAYED_PIC_COUNT - i;\n    if(   cur->f.pict_type == AV_PICTURE_TYPE_B\n       || (h->last_pocs[MAX_DELAYED_PIC_COUNT-2] > INT_MIN && h->last_pocs[MAX_DELAYED_PIC_COUNT-1] - h->last_pocs[MAX_DELAYED_PIC_COUNT-2] > 2))\n        out_of_order = FFMAX(out_of_order, 1);\n    if (out_of_order == MAX_DELAYED_PIC_COUNT) {\n        av_log(h->avctx, AV_LOG_VERBOSE, \"Invalid POC %d<%d\\n\", cur->poc, h->last_pocs[0]);\n        for (i = 1; i < MAX_DELAYED_PIC_COUNT; i++)\n            h->last_pocs[i] = INT_MIN;\n        h->last_pocs[0] = cur->poc;\n        cur->mmco_reset = 1;\n    } else if(h->avctx->has_b_frames < out_of_order && !h->sps.bitstream_restriction_flag){\n        av_log(h->avctx, AV_LOG_VERBOSE, \"Increasing reorder buffer to %d\\n\", out_of_order);\n        h->avctx->has_b_frames = out_of_order;\n        h->low_delay = 0;\n    }\n\n    pics = 0;\n    while (h->delayed_pic[pics])\n        pics++;\n\n    av_assert0(pics <= MAX_DELAYED_PIC_COUNT);\n\n    h->delayed_pic[pics++] = cur;\n    if (cur->reference == 0)\n        cur->reference = DELAYED_PIC_REF;\n\n    out = h->delayed_pic[0];\n    out_idx = 0;\n    for (i = 1; h->delayed_pic[i] &&\n                !h->delayed_pic[i]->f.key_frame &&\n                !h->delayed_pic[i]->mmco_reset;\n         i++)\n        if (h->delayed_pic[i]->poc < out->poc) {\n            out     = h->delayed_pic[i];\n            out_idx = i;\n        }\n    if (h->avctx->has_b_frames == 0 &&\n        (h->delayed_pic[0]->f.key_frame || h->delayed_pic[0]->mmco_reset))\n        h->next_outputed_poc = INT_MIN;\n    out_of_order = out->poc < h->next_outputed_poc;\n\n    if (out_of_order || pics > h->avctx->has_b_frames) {\n        out->reference &= ~DELAYED_PIC_REF;\n        // for frame threading, the owner must be the second field's thread or\n        // else the first thread can release the picture and reuse it unsafely\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n    }\n    if (!out_of_order && pics > h->avctx->has_b_frames) {\n        h->next_output_pic = out;\n        if (out_idx == 0 && h->delayed_pic[0] && (h->delayed_pic[0]->f.key_frame || h->delayed_pic[0]->mmco_reset)) {\n            h->next_outputed_poc = INT_MIN;\n        } else\n            h->next_outputed_poc = out->poc;\n    } else {\n        av_log(h->avctx, AV_LOG_DEBUG, \"no picture %s\\n\", out_of_order ? \"ooo\" : \"\");\n    }\n\n    if (h->next_output_pic && h->next_output_pic->sync) {\n        h->sync |= 2;\n    }\n\n    if (setup_finished && !h->avctx->hwaccel)\n        ff_thread_finish_setup(h->avctx);\n}\n\nstatic av_always_inline void backup_mb_border(H264Context *h, uint8_t *src_y,\n                                              uint8_t *src_cb, uint8_t *src_cr,\n                                              int linesize, int uvlinesize,\n                                              int simple)\n{\n    uint8_t *top_border;\n    int top_idx = 1;\n    const int pixel_shift = h->pixel_shift;\n    int chroma444 = CHROMA444(h);\n    int chroma422 = CHROMA422(h);\n\n    src_y  -= linesize;\n    src_cb -= uvlinesize;\n    src_cr -= uvlinesize;\n\n    if (!simple && FRAME_MBAFF(h)) {\n        if (h->mb_y & 1) {\n            if (!MB_MBAFF(h)) {\n                top_border = h->top_borders[0][h->mb_x];\n                AV_COPY128(top_border, src_y + 15 * linesize);\n                if (pixel_shift)\n                    AV_COPY128(top_border + 16, src_y + 15 * linesize + 16);\n                if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n                    if (chroma444) {\n                        if (pixel_shift) {\n                            AV_COPY128(top_border + 32, src_cb + 15 * uvlinesize);\n                            AV_COPY128(top_border + 48, src_cb + 15 * uvlinesize + 16);\n                            AV_COPY128(top_border + 64, src_cr + 15 * uvlinesize);\n                            AV_COPY128(top_border + 80, src_cr + 15 * uvlinesize + 16);\n                        } else {\n                            AV_COPY128(top_border + 16, src_cb + 15 * uvlinesize);\n                            AV_COPY128(top_border + 32, src_cr + 15 * uvlinesize);\n                        }\n                    } else if (chroma422) {\n                        if (pixel_shift) {\n                            AV_COPY128(top_border + 32, src_cb + 15 * uvlinesize);\n                            AV_COPY128(top_border + 48, src_cr + 15 * uvlinesize);\n                        } else {\n                            AV_COPY64(top_border + 16, src_cb + 15 * uvlinesize);\n                            AV_COPY64(top_border + 24, src_cr + 15 * uvlinesize);\n                        }\n                    } else {\n                        if (pixel_shift) {\n                            AV_COPY128(top_border + 32, src_cb + 7 * uvlinesize);\n                            AV_COPY128(top_border + 48, src_cr + 7 * uvlinesize);\n                        } else {\n                            AV_COPY64(top_border + 16, src_cb + 7 * uvlinesize);\n                            AV_COPY64(top_border + 24, src_cr + 7 * uvlinesize);\n                        }\n                    }\n                }\n            }\n        } else if (MB_MBAFF(h)) {\n            top_idx = 0;\n        } else\n            return;\n    }\n\n    top_border = h->top_borders[top_idx][h->mb_x];\n    /* There are two lines saved, the line above the top macroblock\n     * of a pair, and the line above the bottom macroblock. */\n    AV_COPY128(top_border, src_y + 16 * linesize);\n    if (pixel_shift)\n        AV_COPY128(top_border + 16, src_y + 16 * linesize + 16);\n\n    if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n        if (chroma444) {\n            if (pixel_shift) {\n                AV_COPY128(top_border + 32, src_cb + 16 * linesize);\n                AV_COPY128(top_border + 48, src_cb + 16 * linesize + 16);\n                AV_COPY128(top_border + 64, src_cr + 16 * linesize);\n                AV_COPY128(top_border + 80, src_cr + 16 * linesize + 16);\n            } else {\n                AV_COPY128(top_border + 16, src_cb + 16 * linesize);\n                AV_COPY128(top_border + 32, src_cr + 16 * linesize);\n            }\n        } else if (chroma422) {\n            if (pixel_shift) {\n                AV_COPY128(top_border + 32, src_cb + 16 * uvlinesize);\n                AV_COPY128(top_border + 48, src_cr + 16 * uvlinesize);\n            } else {\n                AV_COPY64(top_border + 16, src_cb + 16 * uvlinesize);\n                AV_COPY64(top_border + 24, src_cr + 16 * uvlinesize);\n            }\n        } else {\n            if (pixel_shift) {\n                AV_COPY128(top_border + 32, src_cb + 8 * uvlinesize);\n                AV_COPY128(top_border + 48, src_cr + 8 * uvlinesize);\n            } else {\n                AV_COPY64(top_border + 16, src_cb + 8 * uvlinesize);\n                AV_COPY64(top_border + 24, src_cr + 8 * uvlinesize);\n            }\n        }\n    }\n}\n\nstatic av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,\n                                            uint8_t *src_cb, uint8_t *src_cr,\n                                            int linesize, int uvlinesize,\n                                            int xchg, int chroma444,\n                                            int simple, int pixel_shift)\n{\n    int deblock_topleft;\n    int deblock_top;\n    int top_idx = 1;\n    uint8_t *top_border_m1;\n    uint8_t *top_border;\n\n    if (!simple && FRAME_MBAFF(h)) {\n        if (h->mb_y & 1) {\n            if (!MB_MBAFF(h))\n                return;\n        } else {\n            top_idx = MB_MBAFF(h) ? 0 : 1;\n        }\n    }\n\n    if (h->deblocking_filter == 2) {\n        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;\n        deblock_top     = h->top_type;\n    } else {\n        deblock_topleft = (h->mb_x > 0);\n        deblock_top     = (h->mb_y > !!MB_FIELD(h));\n    }\n\n    src_y  -= linesize   + 1 + pixel_shift;\n    src_cb -= uvlinesize + 1 + pixel_shift;\n    src_cr -= uvlinesize + 1 + pixel_shift;\n\n    top_border_m1 = h->top_borders[top_idx][h->mb_x - 1];\n    top_border    = h->top_borders[top_idx][h->mb_x];\n\n#define XCHG(a, b, xchg)                        \\\n    if (pixel_shift) {                          \\\n        if (xchg) {                             \\\n            AV_SWAP64(b + 0, a + 0);            \\\n            AV_SWAP64(b + 8, a + 8);            \\\n        } else {                                \\\n            AV_COPY128(b, a);                   \\\n        }                                       \\\n    } else if (xchg)                            \\\n        AV_SWAP64(b, a);                        \\\n    else                                        \\\n        AV_COPY64(b, a);\n\n    if (deblock_top) {\n        if (deblock_topleft) {\n            XCHG(top_border_m1 + (8 << pixel_shift),\n                 src_y - (7 << pixel_shift), 1);\n        }\n        XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg);\n        XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1);\n        if (h->mb_x + 1 < h->mb_width) {\n            XCHG(h->top_borders[top_idx][h->mb_x + 1],\n                 src_y + (17 << pixel_shift), 1);\n        }\n        if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n            if (chroma444) {\n                if (deblock_topleft) {\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n                    XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n                }\n                XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg);\n                XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);\n                XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);\n                XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);\n                if (h->mb_x + 1 < h->mb_width) {\n                    XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);\n                    XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);\n                }\n            } else {\n                if (deblock_topleft) {\n                    XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n                }\n                XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);\n                XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);\n            }\n        }\n    }\n}\n\nstatic av_always_inline int dctcoef_get(int16_t *mb, int high_bit_depth,\n                                        int index)\n{\n    if (high_bit_depth) {\n        return AV_RN32A(((int32_t *)mb) + index);\n    } else\n        return AV_RN16A(mb + index);\n}\n\nstatic av_always_inline void dctcoef_set(int16_t *mb, int high_bit_depth,\n                                         int index, int value)\n{\n    if (high_bit_depth) {\n        AV_WN32A(((int32_t *)mb) + index, value);\n    } else\n        AV_WN16A(mb + index, value);\n}\n\nstatic av_always_inline void hl_decode_mb_predict_luma(H264Context *h,\n                                                       int mb_type, int is_h264,\n                                                       int simple,\n                                                       int transform_bypass,\n                                                       int pixel_shift,\n                                                       int *block_offset,\n                                                       int linesize,\n                                                       uint8_t *dest_y, int p)\n{\n    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);\n    void (*idct_dc_add)(uint8_t *dst, int16_t *block, int stride);\n    int i;\n    int qscale = p == 0 ? h->qscale : h->chroma_qp[p - 1];\n    block_offset += 16 * p;\n    if (IS_INTRA4x4(mb_type)) {\n        if (IS_8x8DCT(mb_type)) {\n            if (transform_bypass) {\n                idct_dc_add =\n                idct_add    = h->h264dsp.h264_add_pixels8_clear;\n            } else {\n                idct_dc_add = h->h264dsp.h264_idct8_dc_add;\n                idct_add    = h->h264dsp.h264_idct8_add;\n            }\n            for (i = 0; i < 16; i += 4) {\n                uint8_t *const ptr = dest_y + block_offset[i];\n                const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];\n                if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {\n                    h->hpc.pred8x8l_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                } else {\n                    const int nnz = h->non_zero_count_cache[scan8[i + p * 16]];\n                    h->hpc.pred8x8l[dir](ptr, (h->topleft_samples_available << i) & 0x8000,\n                                         (h->topright_samples_available << i) & 0x4000, linesize);\n                    if (nnz) {\n                        if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))\n                            idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                        else\n                            idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                    }\n                }\n            }\n        } else {\n            if (transform_bypass) {\n                idct_dc_add  =\n                idct_add     = h->h264dsp.h264_add_pixels4_clear;\n            } else {\n                idct_dc_add = h->h264dsp.h264_idct_dc_add;\n                idct_add    = h->h264dsp.h264_idct_add;\n            }\n            for (i = 0; i < 16; i++) {\n                uint8_t *const ptr = dest_y + block_offset[i];\n                const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];\n\n                if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {\n                    h->hpc.pred4x4_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                } else {\n                    uint8_t *topright;\n                    int nnz, tr;\n                    uint64_t tr_high;\n                    if (dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED) {\n                        const int topright_avail = (h->topright_samples_available << i) & 0x8000;\n                        av_assert2(h->mb_y || linesize <= block_offset[i]);\n                        if (!topright_avail) {\n                            if (pixel_shift) {\n                                tr_high  = ((uint16_t *)ptr)[3 - linesize / 2] * 0x0001000100010001ULL;\n                                topright = (uint8_t *)&tr_high;\n                            } else {\n                                tr       = ptr[3 - linesize] * 0x01010101u;\n                                topright = (uint8_t *)&tr;\n                            }\n                        } else\n                            topright = ptr + (4 << pixel_shift) - linesize;\n                    } else\n                        topright = NULL;\n\n                    h->hpc.pred4x4[dir](ptr, topright, linesize);\n                    nnz = h->non_zero_count_cache[scan8[i + p * 16]];\n                    if (nnz) {\n                        if (is_h264) {\n                            if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))\n                                idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                            else\n                                idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);\n                        } else if (CONFIG_SVQ3_DECODER)\n                            ff_svq3_add_idct_c(ptr, h->mb + i * 16 + p * 256, linesize, qscale, 0);\n                    }\n                }\n            }\n        }\n    } else {\n        h->hpc.pred16x16[h->intra16x16_pred_mode](dest_y, linesize);\n        if (is_h264) {\n            if (h->non_zero_count_cache[scan8[LUMA_DC_BLOCK_INDEX + p]]) {\n                if (!transform_bypass)\n                    h->h264dsp.h264_luma_dc_dequant_idct(h->mb + (p * 256 << pixel_shift),\n                                                         h->mb_luma_dc[p],\n                                                         h->dequant4_coeff[p][qscale][0]);\n                else {\n                    static const uint8_t dc_mapping[16] = {\n                         0 * 16,  1 * 16,  4 * 16,  5 * 16,\n                         2 * 16,  3 * 16,  6 * 16,  7 * 16,\n                         8 * 16,  9 * 16, 12 * 16, 13 * 16,\n                        10 * 16, 11 * 16, 14 * 16, 15 * 16\n                    };\n                    for (i = 0; i < 16; i++)\n                        dctcoef_set(h->mb + (p * 256 << pixel_shift),\n                                    pixel_shift, dc_mapping[i],\n                                    dctcoef_get(h->mb_luma_dc[p],\n                                                pixel_shift, i));\n                }\n            }\n        } else if (CONFIG_SVQ3_DECODER)\n            ff_svq3_luma_dc_dequant_idct_c(h->mb + p * 256,\n                                           h->mb_luma_dc[p], qscale);\n    }\n}\n\nstatic av_always_inline void hl_decode_mb_idct_luma(H264Context *h, int mb_type,\n                                                    int is_h264, int simple,\n                                                    int transform_bypass,\n                                                    int pixel_shift,\n                                                    int *block_offset,\n                                                    int linesize,\n                                                    uint8_t *dest_y, int p)\n{\n    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);\n    int i;\n    block_offset += 16 * p;\n    if (!IS_INTRA4x4(mb_type)) {\n        if (is_h264) {\n            if (IS_INTRA16x16(mb_type)) {\n                if (transform_bypass) {\n                    if (h->sps.profile_idc == 244 &&\n                        (h->intra16x16_pred_mode == VERT_PRED8x8 ||\n                         h->intra16x16_pred_mode == HOR_PRED8x8)) {\n                        h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset,\n                                                                      h->mb + (p * 256 << pixel_shift),\n                                                                      linesize);\n                    } else {\n                        for (i = 0; i < 16; i++)\n                            if (h->non_zero_count_cache[scan8[i + p * 16]] ||\n                                dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))\n                                h->h264dsp.h264_add_pixels4_clear(dest_y + block_offset[i],\n                                                                  h->mb + (i * 16 + p * 256 << pixel_shift),\n                                                                  linesize);\n                    }\n                } else {\n                    h->h264dsp.h264_idct_add16intra(dest_y, block_offset,\n                                                    h->mb + (p * 256 << pixel_shift),\n                                                    linesize,\n                                                    h->non_zero_count_cache + p * 5 * 8);\n                }\n            } else if (h->cbp & 15) {\n                if (transform_bypass) {\n                    const int di = IS_8x8DCT(mb_type) ? 4 : 1;\n                    idct_add = IS_8x8DCT(mb_type) ? h->h264dsp.h264_add_pixels8_clear\n                                                  : h->h264dsp.h264_add_pixels4_clear;\n                    for (i = 0; i < 16; i += di)\n                        if (h->non_zero_count_cache[scan8[i + p * 16]])\n                            idct_add(dest_y + block_offset[i],\n                                     h->mb + (i * 16 + p * 256 << pixel_shift),\n                                     linesize);\n                } else {\n                    if (IS_8x8DCT(mb_type))\n                        h->h264dsp.h264_idct8_add4(dest_y, block_offset,\n                                                   h->mb + (p * 256 << pixel_shift),\n                                                   linesize,\n                                                   h->non_zero_count_cache + p * 5 * 8);\n                    else\n                        h->h264dsp.h264_idct_add16(dest_y, block_offset,\n                                                   h->mb + (p * 256 << pixel_shift),\n                                                   linesize,\n                                                   h->non_zero_count_cache + p * 5 * 8);\n                }\n            }\n        } else if (CONFIG_SVQ3_DECODER) {\n            for (i = 0; i < 16; i++)\n                if (h->non_zero_count_cache[scan8[i + p * 16]] || h->mb[i * 16 + p * 256]) {\n                    // FIXME benchmark weird rule, & below\n                    uint8_t *const ptr = dest_y + block_offset[i];\n                    ff_svq3_add_idct_c(ptr, h->mb + i * 16 + p * 256, linesize,\n                                       h->qscale, IS_INTRA(mb_type) ? 1 : 0);\n                }\n        }\n    }\n}\n\n#define BITS   8\n#define SIMPLE 1\n#include \"h264_mb_template.c\"\n\n#undef  BITS\n#define BITS   16\n#include \"h264_mb_template.c\"\n\n#undef  SIMPLE\n#define SIMPLE 0\n#include \"h264_mb_template.c\"\n\nvoid ff_h264_hl_decode_mb(H264Context *h)\n{\n    const int mb_xy   = h->mb_xy;\n    const int mb_type = h->cur_pic.mb_type[mb_xy];\n    int is_complex    = CONFIG_SMALL || h->is_complex ||\n                        IS_INTRA_PCM(mb_type) || h->qscale == 0;\n\n    if (CHROMA444(h)) {\n        if (is_complex || h->pixel_shift)\n            hl_decode_mb_444_complex(h);\n        else\n            hl_decode_mb_444_simple_8(h);\n    } else if (is_complex) {\n        hl_decode_mb_complex(h);\n    } else if (h->pixel_shift) {\n        hl_decode_mb_simple_16(h);\n    } else\n        hl_decode_mb_simple_8(h);\n}\n\nint ff_pred_weight_table(H264Context *h)\n{\n    int list, i;\n    int luma_def, chroma_def;\n\n    h->use_weight             = 0;\n    h->use_weight_chroma      = 0;\n    h->luma_log2_weight_denom = get_ue_golomb(&h->gb);\n    if (h->sps.chroma_format_idc)\n        h->chroma_log2_weight_denom = get_ue_golomb(&h->gb);\n    luma_def   = 1 << h->luma_log2_weight_denom;\n    chroma_def = 1 << h->chroma_log2_weight_denom;\n\n    for (list = 0; list < 2; list++) {\n        h->luma_weight_flag[list]   = 0;\n        h->chroma_weight_flag[list] = 0;\n        for (i = 0; i < h->ref_count[list]; i++) {\n            int luma_weight_flag, chroma_weight_flag;\n\n            luma_weight_flag = get_bits1(&h->gb);\n            if (luma_weight_flag) {\n                h->luma_weight[i][list][0] = get_se_golomb(&h->gb);\n                h->luma_weight[i][list][1] = get_se_golomb(&h->gb);\n                if (h->luma_weight[i][list][0] != luma_def ||\n                    h->luma_weight[i][list][1] != 0) {\n                    h->use_weight             = 1;\n                    h->luma_weight_flag[list] = 1;\n                }\n            } else {\n                h->luma_weight[i][list][0] = luma_def;\n                h->luma_weight[i][list][1] = 0;\n            }\n\n            if (h->sps.chroma_format_idc) {\n                chroma_weight_flag = get_bits1(&h->gb);\n                if (chroma_weight_flag) {\n                    int j;\n                    for (j = 0; j < 2; j++) {\n                        h->chroma_weight[i][list][j][0] = get_se_golomb(&h->gb);\n                        h->chroma_weight[i][list][j][1] = get_se_golomb(&h->gb);\n                        if (h->chroma_weight[i][list][j][0] != chroma_def ||\n                            h->chroma_weight[i][list][j][1] != 0) {\n                            h->use_weight_chroma        = 1;\n                            h->chroma_weight_flag[list] = 1;\n                        }\n                    }\n                } else {\n                    int j;\n                    for (j = 0; j < 2; j++) {\n                        h->chroma_weight[i][list][j][0] = chroma_def;\n                        h->chroma_weight[i][list][j][1] = 0;\n                    }\n                }\n            }\n        }\n        if (h->slice_type_nos != AV_PICTURE_TYPE_B)\n            break;\n    }\n    h->use_weight = h->use_weight || h->use_weight_chroma;\n    return 0;\n}\n\n/**\n * Initialize implicit_weight table.\n * @param field  0/1 initialize the weight for interlaced MBAFF\n *                -1 initializes the rest\n */\nstatic void implicit_weight_table(H264Context *h, int field)\n{\n    int ref0, ref1, i, cur_poc, ref_start, ref_count0, ref_count1;\n\n    for (i = 0; i < 2; i++) {\n        h->luma_weight_flag[i]   = 0;\n        h->chroma_weight_flag[i] = 0;\n    }\n\n    if (field < 0) {\n        if (h->picture_structure == PICT_FRAME) {\n            cur_poc = h->cur_pic_ptr->poc;\n        } else {\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure - 1];\n        }\n        if (h->ref_count[0] == 1 && h->ref_count[1] == 1 && !FRAME_MBAFF(h) &&\n            h->ref_list[0][0].poc + h->ref_list[1][0].poc == 2 * cur_poc) {\n            h->use_weight        = 0;\n            h->use_weight_chroma = 0;\n            return;\n        }\n        ref_start  = 0;\n        ref_count0 = h->ref_count[0];\n        ref_count1 = h->ref_count[1];\n    } else {\n        cur_poc    = h->cur_pic_ptr->field_poc[field];\n        ref_start  = 16;\n        ref_count0 = 16 + 2 * h->ref_count[0];\n        ref_count1 = 16 + 2 * h->ref_count[1];\n    }\n\n    h->use_weight               = 2;\n    h->use_weight_chroma        = 2;\n    h->luma_log2_weight_denom   = 5;\n    h->chroma_log2_weight_denom = 5;\n\n    for (ref0 = ref_start; ref0 < ref_count0; ref0++) {\n        int poc0 = h->ref_list[0][ref0].poc;\n        for (ref1 = ref_start; ref1 < ref_count1; ref1++) {\n            int w = 32;\n            if (!h->ref_list[0][ref0].long_ref && !h->ref_list[1][ref1].long_ref) {\n                int poc1 = h->ref_list[1][ref1].poc;\n                int td   = av_clip(poc1 - poc0, -128, 127);\n                if (td) {\n                    int tb = av_clip(cur_poc - poc0, -128, 127);\n                    int tx = (16384 + (FFABS(td) >> 1)) / td;\n                    int dist_scale_factor = (tb * tx + 32) >> 8;\n                    if (dist_scale_factor >= -64 && dist_scale_factor <= 128)\n                        w = 64 - dist_scale_factor;\n                }\n            }\n            if (field < 0) {\n                h->implicit_weight[ref0][ref1][0] =\n                h->implicit_weight[ref0][ref1][1] = w;\n            } else {\n                h->implicit_weight[ref0][ref1][field] = w;\n            }\n        }\n    }\n}\n\n/**\n * instantaneous decoder refresh.\n */\nstatic void idr(H264Context *h)\n{\n    int i;\n    ff_h264_remove_all_refs(h);\n    h->prev_frame_num        = 0;\n    h->prev_frame_num_offset = 0;\n    h->prev_poc_msb          = 1<<16;\n    h->prev_poc_lsb          = 0;\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n        h->last_pocs[i] = INT_MIN;\n}\n\n/* forget old pics after a seek */\nstatic void flush_change(H264Context *h)\n{\n    int i, j;\n\n    h->outputed_poc          = h->next_outputed_poc = INT_MIN;\n    h->prev_interlaced_frame = 1;\n    idr(h);\n\n    h->prev_frame_num = -1;\n    if (h->cur_pic_ptr) {\n        h->cur_pic_ptr->reference = 0;\n        for (j=i=0; h->delayed_pic[i]; i++)\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n                h->delayed_pic[j++] = h->delayed_pic[i];\n        h->delayed_pic[j] = NULL;\n    }\n    h->first_field = 0;\n    memset(h->ref_list[0], 0, sizeof(h->ref_list[0]));\n    memset(h->ref_list[1], 0, sizeof(h->ref_list[1]));\n    memset(h->default_ref_list[0], 0, sizeof(h->default_ref_list[0]));\n    memset(h->default_ref_list[1], 0, sizeof(h->default_ref_list[1]));\n    ff_h264_reset_sei(h);\n    h->recovery_frame= -1;\n    h->sync= 0;\n    h->list_count = 0;\n    h->current_slice = 0;\n}\n\n/* forget old pics after a seek */\nstatic void flush_dpb(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    int i;\n\n    for (i = 0; i <= MAX_DELAYED_PIC_COUNT; i++) {\n        if (h->delayed_pic[i])\n            h->delayed_pic[i]->reference = 0;\n        h->delayed_pic[i] = NULL;\n    }\n\n    flush_change(h);\n\n    if (h->DPB)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            unref_picture(h, &h->DPB[i]);\n    h->cur_pic_ptr = NULL;\n    unref_picture(h, &h->cur_pic);\n\n    h->mb_x = h->mb_y = 0;\n\n    h->parse_context.state             = -1;\n    h->parse_context.frame_start_found = 0;\n    h->parse_context.overread          = 0;\n    h->parse_context.overread_index    = 0;\n    h->parse_context.index             = 0;\n    h->parse_context.last_index        = 0;\n}\n\nint ff_init_poc(H264Context *h, int pic_field_poc[2], int *pic_poc)\n{\n    const int max_frame_num = 1 << h->sps.log2_max_frame_num;\n    int field_poc[2];\n\n    h->frame_num_offset = h->prev_frame_num_offset;\n    if (h->frame_num < h->prev_frame_num)\n        h->frame_num_offset += max_frame_num;\n\n    if (h->sps.poc_type == 0) {\n        const int max_poc_lsb = 1 << h->sps.log2_max_poc_lsb;\n\n        if (h->poc_lsb < h->prev_poc_lsb &&\n            h->prev_poc_lsb - h->poc_lsb >= max_poc_lsb / 2)\n            h->poc_msb = h->prev_poc_msb + max_poc_lsb;\n        else if (h->poc_lsb > h->prev_poc_lsb &&\n                 h->prev_poc_lsb - h->poc_lsb < -max_poc_lsb / 2)\n            h->poc_msb = h->prev_poc_msb - max_poc_lsb;\n        else\n            h->poc_msb = h->prev_poc_msb;\n        field_poc[0] =\n        field_poc[1] = h->poc_msb + h->poc_lsb;\n        if (h->picture_structure == PICT_FRAME)\n            field_poc[1] += h->delta_poc_bottom;\n    } else if (h->sps.poc_type == 1) {\n        int abs_frame_num, expected_delta_per_poc_cycle, expectedpoc;\n        int i;\n\n        if (h->sps.poc_cycle_length != 0)\n            abs_frame_num = h->frame_num_offset + h->frame_num;\n        else\n            abs_frame_num = 0;\n\n        if (h->nal_ref_idc == 0 && abs_frame_num > 0)\n            abs_frame_num--;\n\n        expected_delta_per_poc_cycle = 0;\n        for (i = 0; i < h->sps.poc_cycle_length; i++)\n            // FIXME integrate during sps parse\n            expected_delta_per_poc_cycle += h->sps.offset_for_ref_frame[i];\n\n        if (abs_frame_num > 0) {\n            int poc_cycle_cnt          = (abs_frame_num - 1) / h->sps.poc_cycle_length;\n            int frame_num_in_poc_cycle = (abs_frame_num - 1) % h->sps.poc_cycle_length;\n\n            expectedpoc = poc_cycle_cnt * expected_delta_per_poc_cycle;\n            for (i = 0; i <= frame_num_in_poc_cycle; i++)\n                expectedpoc = expectedpoc + h->sps.offset_for_ref_frame[i];\n        } else\n            expectedpoc = 0;\n\n        if (h->nal_ref_idc == 0)\n            expectedpoc = expectedpoc + h->sps.offset_for_non_ref_pic;\n\n        field_poc[0] = expectedpoc + h->delta_poc[0];\n        field_poc[1] = field_poc[0] + h->sps.offset_for_top_to_bottom_field;\n\n        if (h->picture_structure == PICT_FRAME)\n            field_poc[1] += h->delta_poc[1];\n    } else {\n        int poc = 2 * (h->frame_num_offset + h->frame_num);\n\n        if (!h->nal_ref_idc)\n            poc--;\n\n        field_poc[0] = poc;\n        field_poc[1] = poc;\n    }\n\n    if (h->picture_structure != PICT_BOTTOM_FIELD)\n        pic_field_poc[0] = field_poc[0];\n    if (h->picture_structure != PICT_TOP_FIELD)\n        pic_field_poc[1] = field_poc[1];\n    *pic_poc = FFMIN(pic_field_poc[0], pic_field_poc[1]);\n\n    return 0;\n}\n\n/**\n * initialize scan tables\n */\nstatic void init_scan_tables(H264Context *h)\n{\n    int i;\n    for (i = 0; i < 16; i++) {\n#define T(x) (x >> 2) | ((x << 2) & 0xF)\n        h->zigzag_scan[i] = T(zigzag_scan[i]);\n        h->field_scan[i]  = T(field_scan[i]);\n#undef T\n    }\n    for (i = 0; i < 64; i++) {\n#define T(x) (x >> 3) | ((x & 7) << 3)\n        h->zigzag_scan8x8[i]       = T(ff_zigzag_direct[i]);\n        h->zigzag_scan8x8_cavlc[i] = T(zigzag_scan8x8_cavlc[i]);\n        h->field_scan8x8[i]        = T(field_scan8x8[i]);\n        h->field_scan8x8_cavlc[i]  = T(field_scan8x8_cavlc[i]);\n#undef T\n    }\n    if (h->sps.transform_bypass) { // FIXME same ugly\n        memcpy(h->zigzag_scan_q0          , zigzag_scan             , sizeof(h->zigzag_scan_q0         ));\n        memcpy(h->zigzag_scan8x8_q0       , ff_zigzag_direct        , sizeof(h->zigzag_scan8x8_q0      ));\n        memcpy(h->zigzag_scan8x8_cavlc_q0 , zigzag_scan8x8_cavlc    , sizeof(h->zigzag_scan8x8_cavlc_q0));\n        memcpy(h->field_scan_q0           , field_scan              , sizeof(h->field_scan_q0          ));\n        memcpy(h->field_scan8x8_q0        , field_scan8x8           , sizeof(h->field_scan8x8_q0       ));\n        memcpy(h->field_scan8x8_cavlc_q0  , field_scan8x8_cavlc     , sizeof(h->field_scan8x8_cavlc_q0 ));\n    } else {\n        memcpy(h->zigzag_scan_q0          , h->zigzag_scan          , sizeof(h->zigzag_scan_q0         ));\n        memcpy(h->zigzag_scan8x8_q0       , h->zigzag_scan8x8       , sizeof(h->zigzag_scan8x8_q0      ));\n        memcpy(h->zigzag_scan8x8_cavlc_q0 , h->zigzag_scan8x8_cavlc , sizeof(h->zigzag_scan8x8_cavlc_q0));\n        memcpy(h->field_scan_q0           , h->field_scan           , sizeof(h->field_scan_q0          ));\n        memcpy(h->field_scan8x8_q0        , h->field_scan8x8        , sizeof(h->field_scan8x8_q0       ));\n        memcpy(h->field_scan8x8_cavlc_q0  , h->field_scan8x8_cavlc  , sizeof(h->field_scan8x8_cavlc_q0 ));\n    }\n}\n\nstatic int field_end(H264Context *h, int in_setup)\n{\n    AVCodecContext *const avctx = h->avctx;\n    int err = 0;\n    h->mb_y = 0;\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_set_reference_frames(h);\n\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (!h->droppable) {\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            h->prev_poc_msb = h->poc_msb;\n            h->prev_poc_lsb = h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n        h->outputed_poc          = h->next_outputed_poc;\n    }\n\n    if (avctx->hwaccel) {\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n\n    /*\n     * FIXME: Error handling code does not seem to support interlaced\n     * when slices span multiple rows\n     * The ff_er_add_slice calls don't work right for bottom\n     * fields; they cause massive erroneous error concealing\n     * Error marking covers both fields (top and bottom).\n     * This causes a mismatched s->error_count\n     * and a bad error table. Further, the error count goes to\n     * INT_MAX when called for bottom field, because mb_y is\n     * past end by one (callers fault) and resync_mb_y != 0\n     * causes problems for the first MB line, too.\n     */\n    if (CONFIG_ERROR_RESILIENCE &&\n        !FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\n        h->er.cur_pic  = h->cur_pic_ptr;\n        ff_er_frame_end(&h->er);\n    }\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n\n    h->current_slice = 0;\n\n    return err;\n}\n\n/**\n * Replicate H264 \"master\" context to thread contexts.\n */\nstatic int clone_slice(H264Context *dst, H264Context *src)\n{\n    memcpy(dst->block_offset, src->block_offset, sizeof(dst->block_offset));\n    dst->cur_pic_ptr = src->cur_pic_ptr;\n    dst->cur_pic     = src->cur_pic;\n    dst->linesize    = src->linesize;\n    dst->uvlinesize  = src->uvlinesize;\n    dst->first_field = src->first_field;\n\n    dst->prev_poc_msb          = src->prev_poc_msb;\n    dst->prev_poc_lsb          = src->prev_poc_lsb;\n    dst->prev_frame_num_offset = src->prev_frame_num_offset;\n    dst->prev_frame_num        = src->prev_frame_num;\n    dst->short_ref_count       = src->short_ref_count;\n\n    memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));\n    memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));\n    memcpy(dst->default_ref_list, src->default_ref_list, sizeof(dst->default_ref_list));\n\n    memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));\n    memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));\n\n    return 0;\n}\n\n/**\n * Compute profile from profile_idc and constraint_set?_flags.\n *\n * @param sps SPS\n *\n * @return profile as defined by FF_PROFILE_H264_*\n */\nint ff_h264_get_profile(SPS *sps)\n{\n    int profile = sps->profile_idc;\n\n    switch (sps->profile_idc) {\n    case FF_PROFILE_H264_BASELINE:\n        // constraint_set1_flag set to 1\n        profile |= (sps->constraint_set_flags & 1 << 1) ? FF_PROFILE_H264_CONSTRAINED : 0;\n        break;\n    case FF_PROFILE_H264_HIGH_10:\n    case FF_PROFILE_H264_HIGH_422:\n    case FF_PROFILE_H264_HIGH_444_PREDICTIVE:\n        // constraint_set3_flag set to 1\n        profile |= (sps->constraint_set_flags & 1 << 3) ? FF_PROFILE_H264_INTRA : 0;\n        break;\n    }\n\n    return profile;\n}\n\nstatic int h264_set_parameter_from_sps(H264Context *h)\n{\n    if (h->flags & CODEC_FLAG_LOW_DELAY ||\n        (h->sps.bitstream_restriction_flag &&\n         !h->sps.num_reorder_frames)) {\n        if (h->avctx->has_b_frames > 1 || h->delayed_pic[0])\n            av_log(h->avctx, AV_LOG_WARNING, \"Delayed frames seen. \"\n                   \"Reenabling low delay requires a codec flush.\\n\");\n        else\n            h->low_delay = 1;\n    }\n\n    if (h->avctx->has_b_frames < 2)\n        h->avctx->has_b_frames = !h->low_delay;\n\n    if (h->sps.bit_depth_luma != h->sps.bit_depth_chroma) {\n        avpriv_request_sample(h->avctx,\n                              \"Different chroma and luma bit depth\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||\n        h->cur_chroma_format_idc      != h->sps.chroma_format_idc) {\n        if (h->avctx->codec &&\n            h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU &&\n            (h->sps.bit_depth_luma != 8 || h->sps.chroma_format_idc > 1)) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"VDPAU decoding does not support video colorspace.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 14 &&\n            h->sps.bit_depth_luma != 11 && h->sps.bit_depth_luma != 13) {\n            h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;\n            h->cur_chroma_format_idc      = h->sps.chroma_format_idc;\n            h->pixel_shift                = h->sps.bit_depth_luma > 8;\n\n            ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,\n                            h->sps.chroma_format_idc);\n            ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma);\n            ff_h264qpel_init(&h->h264qpel, h->sps.bit_depth_luma);\n            ff_h264_pred_init(&h->hpc, h->avctx->codec_id, h->sps.bit_depth_luma,\n                              h->sps.chroma_format_idc);\n\n            if (CONFIG_ERROR_RESILIENCE)\n                ff_dsputil_init(&h->dsp, h->avctx);\n            ff_videodsp_init(&h->vdsp, h->sps.bit_depth_luma);\n        } else {\n            av_log(h->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\",\n                   h->sps.bit_depth_luma);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    return 0;\n}\n\nstatic enum AVPixelFormat get_pixel_format(H264Context *h, int force_callback)\n{\n    switch (h->sps.bit_depth_luma) {\n    case 9:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP9;\n            } else\n                return AV_PIX_FMT_YUV444P9;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P9;\n        else\n            return AV_PIX_FMT_YUV420P9;\n        break;\n    case 10:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP10;\n            } else\n                return AV_PIX_FMT_YUV444P10;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P10;\n        else\n            return AV_PIX_FMT_YUV420P10;\n        break;\n    case 12:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP12;\n            } else\n                return AV_PIX_FMT_YUV444P12;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P12;\n        else\n            return AV_PIX_FMT_YUV420P12;\n        break;\n    case 14:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                return AV_PIX_FMT_GBRP14;\n            } else\n                return AV_PIX_FMT_YUV444P14;\n        } else if (CHROMA422(h))\n            return AV_PIX_FMT_YUV422P14;\n        else\n            return AV_PIX_FMT_YUV420P14;\n        break;\n    case 8:\n        if (CHROMA444(h)) {\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n                av_log(h->avctx, AV_LOG_DEBUG, \"Detected GBR colorspace.\\n\");\n                return AV_PIX_FMT_GBR24P;\n            } else if (h->avctx->colorspace == AVCOL_SPC_YCGCO) {\n                av_log(h->avctx, AV_LOG_WARNING, \"Detected unsupported YCgCo colorspace.\\n\");\n            }\n            return h->avctx->color_range == AVCOL_RANGE_JPEG ? AV_PIX_FMT_YUVJ444P\n                                                                : AV_PIX_FMT_YUV444P;\n        } else if (CHROMA422(h)) {\n            return h->avctx->color_range == AVCOL_RANGE_JPEG ? AV_PIX_FMT_YUVJ422P\n                                                             : AV_PIX_FMT_YUV422P;\n        } else {\n            int i;\n            const enum AVPixelFormat * fmt = h->avctx->codec->pix_fmts ?\n                                        h->avctx->codec->pix_fmts :\n                                        h->avctx->color_range == AVCOL_RANGE_JPEG ?\n                                        h264_hwaccel_pixfmt_list_jpeg_420 :\n                                        h264_hwaccel_pixfmt_list_420;\n\n            for (i=0; fmt[i] != AV_PIX_FMT_NONE; i++)\n                if (fmt[i] == h->avctx->pix_fmt && !force_callback)\n                    return fmt[i];\n            return ff_thread_get_format(h->avctx, fmt);\n        }\n        break;\n    default:\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"Unsupported bit depth: %d\\n\", h->sps.bit_depth_luma);\n        return AVERROR_INVALIDDATA;\n    }\n}\n\n/* export coded and cropped frame dimensions to AVCodecContext */\nstatic int init_dimensions(H264Context *h)\n{\n    int width  = h->width  - (h->sps.crop_right + h->sps.crop_left);\n    int height = h->height - (h->sps.crop_top   + h->sps.crop_bottom);\n    av_assert0(h->sps.crop_right + h->sps.crop_left < (unsigned)h->width);\n    av_assert0(h->sps.crop_top + h->sps.crop_bottom < (unsigned)h->height);\n\n    /* handle container cropping */\n    if (!h->sps.crop &&\n        FFALIGN(h->avctx->width,  16) == h->width &&\n        FFALIGN(h->avctx->height, 16) == h->height) {\n        width  = h->avctx->width;\n        height = h->avctx->height;\n    }\n\n    if (width <= 0 || height <= 0) {\n        av_log(h->avctx, AV_LOG_ERROR, \"Invalid cropped dimensions: %dx%d.\\n\",\n               width, height);\n        if (h->avctx->err_recognition & AV_EF_EXPLODE)\n            return AVERROR_INVALIDDATA;\n\n        av_log(h->avctx, AV_LOG_WARNING, \"Ignoring cropping information.\\n\");\n        h->sps.crop_bottom = h->sps.crop_top = h->sps.crop_right = h->sps.crop_left = 0;\n        h->sps.crop        = 0;\n\n        width  = h->width;\n        height = h->height;\n    }\n\n    h->avctx->coded_width  = h->width;\n    h->avctx->coded_height = h->height;\n    h->avctx->width        = width;\n    h->avctx->height       = height;\n\n    return 0;\n}\n\nstatic int h264_slice_header_init(H264Context *h, int reinit)\n{\n    int nb_slices = (HAVE_THREADS &&\n                     h->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                    h->avctx->thread_count : 1;\n    int i, ret;\n\n    h->avctx->sample_aspect_ratio = h->sps.sar;\n    av_assert0(h->avctx->sample_aspect_ratio.den);\n    av_pix_fmt_get_chroma_sub_sample(h->avctx->pix_fmt,\n                                     &h->chroma_x_shift, &h->chroma_y_shift);\n\n    if (h->sps.timing_info_present_flag) {\n        int64_t den = h->sps.time_scale;\n        if (h->x264_build < 44U)\n            den *= 2;\n        av_reduce(&h->avctx->time_base.num, &h->avctx->time_base.den,\n                  h->sps.num_units_in_tick, den, 1 << 30);\n    }\n\n    h->avctx->hwaccel = ff_find_hwaccel(h->avctx->codec->id, h->avctx->pix_fmt);\n\n    if (reinit)\n        free_tables(h, 0);\n    h->first_field           = 0;\n    h->prev_interlaced_frame = 1;\n\n    init_scan_tables(h);\n    ret = ff_h264_alloc_tables(h);\n    if (ret < 0) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"Could not allocate memory for h264\\n\");\n        return ret;\n    }\n\n    if (nb_slices > MAX_THREADS || (nb_slices > h->mb_height && h->mb_height)) {\n        int max_slices;\n        if (h->mb_height)\n            max_slices = FFMIN(MAX_THREADS, h->mb_height);\n        else\n            max_slices = MAX_THREADS;\n        av_log(h->avctx, AV_LOG_WARNING, \"too many threads/slices (%d),\"\n               \" reducing to %d\\n\", nb_slices, max_slices);\n        nb_slices = max_slices;\n    }\n    h->slice_context_count = nb_slices;\n\n    if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_SLICE)) {\n        ret = context_init(h);\n        if (ret < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");\n            return ret;\n        }\n    } else {\n        for (i = 1; i < h->slice_context_count; i++) {\n            H264Context *c;\n            c                    = h->thread_context[i] = av_mallocz(sizeof(H264Context));\n            c->avctx             = h->avctx;\n            if (CONFIG_ERROR_RESILIENCE) {\n                c->dsp               = h->dsp;\n            }\n            c->vdsp              = h->vdsp;\n            c->h264dsp           = h->h264dsp;\n            c->h264qpel          = h->h264qpel;\n            c->h264chroma        = h->h264chroma;\n            c->sps               = h->sps;\n            c->pps               = h->pps;\n            c->pixel_shift       = h->pixel_shift;\n            c->cur_chroma_format_idc = h->cur_chroma_format_idc;\n            c->width             = h->width;\n            c->height            = h->height;\n            c->linesize          = h->linesize;\n            c->uvlinesize        = h->uvlinesize;\n            c->chroma_x_shift = h->chroma_x_shift;\n            c->chroma_y_shift = h->chroma_y_shift;\n            c->qscale            = h->qscale;\n            c->droppable         = h->droppable;\n            c->data_partitioning = h->data_partitioning;\n            c->low_delay         = h->low_delay;\n            c->mb_width          = h->mb_width;\n            c->mb_height         = h->mb_height;\n            c->mb_stride         = h->mb_stride;\n            c->mb_num            = h->mb_num;\n            c->flags             = h->flags;\n            c->workaround_bugs   = h->workaround_bugs;\n            c->pict_type         = h->pict_type;\n\n            init_scan_tables(c);\n            clone_tables(c, h, i);\n            c->context_initialized = 1;\n        }\n\n        for (i = 0; i < h->slice_context_count; i++)\n            if ((ret = context_init(h->thread_context[i])) < 0) {\n                av_log(h->avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");\n                return ret;\n            }\n    }\n\n    h->context_initialized = 1;\n\n    return 0;\n}\n\nint ff_set_ref_count(H264Context *h)\n{\n    int num_ref_idx_active_override_flag;\n\n    // set defaults, might be overridden a few lines later\n    h->ref_count[0] = h->pps.ref_count[0];\n    h->ref_count[1] = h->pps.ref_count[1];\n\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I) {\n        unsigned max[2];\n        max[0] = max[1] = h->picture_structure == PICT_FRAME ? 15 : 31;\n\n        if (h->slice_type_nos == AV_PICTURE_TYPE_B)\n            h->direct_spatial_mv_pred = get_bits1(&h->gb);\n        num_ref_idx_active_override_flag = get_bits1(&h->gb);\n\n        if (num_ref_idx_active_override_flag) {\n            h->ref_count[0] = get_ue_golomb(&h->gb) + 1;\n            if (h->slice_type_nos == AV_PICTURE_TYPE_B) {\n                h->ref_count[1] = get_ue_golomb(&h->gb) + 1;\n            } else\n                // full range is spec-ok in this case, even for frames\n                h->ref_count[1] = 1;\n        }\n\n        if (h->ref_count[0]-1 > max[0] || h->ref_count[1]-1 > max[1]){\n            av_log(h->avctx, AV_LOG_ERROR, \"reference overflow %u > %u or %u > %u\\n\", h->ref_count[0]-1, max[0], h->ref_count[1]-1, max[1]);\n            h->ref_count[0] = h->ref_count[1] = 0;\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (h->slice_type_nos == AV_PICTURE_TYPE_B)\n            h->list_count = 2;\n        else\n            h->list_count = 1;\n    } else {\n        h->list_count   = 0;\n        h->ref_count[0] = h->ref_count[1] = 0;\n    }\n\n    return 0;\n}\n\n/**\n * Decode a slice header.\n * This will also call ff_MPV_common_init() and frame_start() as needed.\n *\n * @param h h264context\n * @param h0 h264 master context (differs from 'h' when doing sliced based\n *           parallel decoding)\n *\n * @return 0 if okay, <0 if an error occurred, 1 if decoding must not be multithreaded\n */\nstatic int decode_slice_header(H264Context *h, H264Context *h0)\n{\n    unsigned int first_mb_in_slice;\n    unsigned int pps_id;\n    int ret;\n    unsigned int slice_type, tmp, i, j;\n    int last_pic_structure, last_pic_droppable;\n    int must_reinit;\n    int needs_reinit = 0;\n    int field_pic_flag, bottom_field_flag;\n\n    h->me.qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;\n    h->me.qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;\n\n    first_mb_in_slice = get_ue_golomb_long(&h->gb);\n\n    if (first_mb_in_slice == 0) { // FIXME better field boundary detection\n        if (h0->current_slice && FIELD_PICTURE(h)) {\n            field_end(h, 1);\n        }\n\n        h0->current_slice = 0;\n        if (!h0->first_field) {\n            if (h->cur_pic_ptr && !h->droppable) {\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n            }\n            h->cur_pic_ptr = NULL;\n        }\n    }\n\n    slice_type = get_ue_golomb_31(&h->gb);\n    if (slice_type > 9) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"slice type too large (%d) at %d %d\\n\",\n               slice_type, h->mb_x, h->mb_y);\n        return AVERROR_INVALIDDATA;\n    }\n    if (slice_type > 4) {\n        slice_type -= 5;\n        h->slice_type_fixed = 1;\n    } else\n        h->slice_type_fixed = 0;\n\n    slice_type = golomb_to_pict_type[slice_type];\n    h->slice_type     = slice_type;\n    h->slice_type_nos = slice_type & 3;\n\n    // to make a few old functions happy, it's wrong though\n    h->pict_type = h->slice_type;\n\n    pps_id = get_ue_golomb(&h->gb);\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %d out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!h0->pps_buffers[pps_id]) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"non-existing PPS %u referenced\\n\",\n               pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    h->pps = *h0->pps_buffers[pps_id];\n\n    if (!h0->sps_buffers[h->pps.sps_id]) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"non-existing SPS %u referenced\\n\",\n               h->pps.sps_id);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (h->pps.sps_id != h->current_sps_id ||\n        h0->sps_buffers[h->pps.sps_id]->new) {\n        h0->sps_buffers[h->pps.sps_id]->new = 0;\n\n        h->current_sps_id = h->pps.sps_id;\n        h->sps            = *h0->sps_buffers[h->pps.sps_id];\n\n        if (h->mb_width  != h->sps.mb_width ||\n            h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||\n            h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||\n            h->cur_chroma_format_idc != h->sps.chroma_format_idc\n        )\n            needs_reinit = 1;\n\n        if (h->bit_depth_luma    != h->sps.bit_depth_luma ||\n            h->chroma_format_idc != h->sps.chroma_format_idc) {\n            h->bit_depth_luma    = h->sps.bit_depth_luma;\n            h->chroma_format_idc = h->sps.chroma_format_idc;\n            needs_reinit         = 1;\n        }\n        if ((ret = h264_set_parameter_from_sps(h)) < 0)\n            return ret;\n    }\n\n    h->avctx->profile = ff_h264_get_profile(&h->sps);\n    h->avctx->level   = h->sps.level_idc;\n    h->avctx->refs    = h->sps.ref_frame_count;\n\n    must_reinit = (h->context_initialized &&\n                    (   16*h->sps.mb_width != h->avctx->coded_width\n                     || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height\n                     || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma\n                     || h->cur_chroma_format_idc != h->sps.chroma_format_idc\n                     || av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)\n                     || h->mb_width  != h->sps.mb_width\n                     || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)\n                    ));\n    if (h0->avctx->pix_fmt != get_pixel_format(h0, 0))\n        must_reinit = 1;\n\n    h->mb_width  = h->sps.mb_width;\n    h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);\n    h->mb_num    = h->mb_width * h->mb_height;\n    h->mb_stride = h->mb_width + 1;\n\n    h->b_stride = h->mb_width * 4;\n\n    h->chroma_y_shift = h->sps.chroma_format_idc <= 1; // 400 uses yuv420p\n\n    h->width  = 16 * h->mb_width;\n    h->height = 16 * h->mb_height;\n\n    ret = init_dimensions(h);\n    if (ret < 0)\n        return ret;\n\n    if (h->sps.video_signal_type_present_flag) {\n        h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG\n                                                    : AVCOL_RANGE_MPEG;\n        if (h->sps.colour_description_present_flag) {\n            if (h->avctx->colorspace != h->sps.colorspace)\n                needs_reinit = 1;\n            h->avctx->color_primaries = h->sps.color_primaries;\n            h->avctx->color_trc       = h->sps.color_trc;\n            h->avctx->colorspace      = h->sps.colorspace;\n        }\n    }\n\n    if (h->context_initialized &&\n        (h->width  != h->avctx->coded_width   ||\n         h->height != h->avctx->coded_height  ||\n         must_reinit ||\n         needs_reinit)) {\n        if (h != h0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"changing width/height on \"\n                   \"slice %d\\n\", h0->current_slice + 1);\n            return AVERROR_INVALIDDATA;\n        }\n\n        flush_change(h);\n\n        if ((ret = get_pixel_format(h, 1)) < 0)\n            return ret;\n        h->avctx->pix_fmt = ret;\n\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n               \"pix_fmt: %s\\n\", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));\n\n        if ((ret = h264_slice_header_init(h, 1)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"h264_slice_header_init() failed\\n\");\n            return ret;\n        }\n    }\n    if (!h->context_initialized) {\n        if (h != h0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        if ((ret = get_pixel_format(h, 1)) < 0)\n            return ret;\n        h->avctx->pix_fmt = ret;\n\n        if ((ret = h264_slice_header_init(h, 0)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"h264_slice_header_init() failed\\n\");\n            return ret;\n        }\n    }\n\n    if (h == h0 && h->dequant_coeff_pps != pps_id) {\n        h->dequant_coeff_pps = pps_id;\n        init_dequant_tables(h);\n    }\n\n    h->frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);\n\n    h->mb_mbaff        = 0;\n    h->mb_aff_frame    = 0;\n    last_pic_structure = h0->picture_structure;\n    last_pic_droppable = h0->droppable;\n    h->droppable       = h->nal_ref_idc == 0;\n    if (h->sps.frame_mbs_only_flag) {\n        h->picture_structure = PICT_FRAME;\n    } else {\n        if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {\n            av_log(h->avctx, AV_LOG_ERROR, \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");\n            return -1;\n        }\n        field_pic_flag = get_bits1(&h->gb);\n        if (field_pic_flag) {\n            bottom_field_flag = get_bits1(&h->gb);\n            h->picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n        } else {\n            h->picture_structure = PICT_FRAME;\n            h->mb_aff_frame      = h->sps.mb_aff;\n        }\n    }\n    h->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n\n    if (h0->current_slice != 0) {\n        if (last_pic_structure != h->picture_structure ||\n            last_pic_droppable != h->droppable) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n                   last_pic_structure, h->picture_structure);\n            h->picture_structure = last_pic_structure;\n            h->droppable         = last_pic_droppable;\n            return AVERROR_INVALIDDATA;\n        } else if (!h0->cur_pic_ptr) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"unset cur_pic_ptr on %d. slice\\n\",\n                   h0->current_slice + 1);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        /* Shorten frame num gaps so we don't have to allocate reference\n         * frames just to throw them away */\n        if (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0) {\n            int unwrap_prev_frame_num = h->prev_frame_num;\n            int max_frame_num         = 1 << h->sps.log2_max_frame_num;\n\n            if (unwrap_prev_frame_num > h->frame_num)\n                unwrap_prev_frame_num -= max_frame_num;\n\n            if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {\n                unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;\n                if (unwrap_prev_frame_num < 0)\n                    unwrap_prev_frame_num += max_frame_num;\n\n                h->prev_frame_num = unwrap_prev_frame_num;\n            }\n        }\n\n        /* See if we have a decoded first field looking for a pair...\n         * Here, we're using that to see if we should mark previously\n         * decode frames as \"finished\".\n         * We have to do that before the \"dummy\" in-between frame allocation,\n         * since that can modify h->cur_pic_ptr. */\n        if (h0->first_field) {\n            assert(h0->cur_pic_ptr);\n            assert(h0->cur_pic_ptr->f.data[0]);\n            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n            /* Mark old field/frame as completed */\n            if (h0->cur_pic_ptr->tf.owner == h0->avctx) {\n                ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                          last_pic_structure == PICT_BOTTOM_FIELD);\n            }\n\n            /* figure out if we have a complementary field pair */\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n                /* Previous field is unmatched. Don't display it, but let it\n                 * remain for reference if marked as such. */\n                if (last_pic_structure != PICT_FRAME) {\n                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                              last_pic_structure == PICT_TOP_FIELD);\n                }\n            } else {\n                if (h0->cur_pic_ptr->frame_num != h->frame_num) {\n                    /* This and previous field were reference, but had\n                     * different frame_nums. Consider this field first in\n                     * pair. Throw away previous field except for reference\n                     * purposes. */\n                    if (last_pic_structure != PICT_FRAME) {\n                        ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                                  last_pic_structure == PICT_TOP_FIELD);\n                    }\n                } else {\n                    /* Second field in complementary pair */\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n                           h->picture_structure == PICT_TOP_FIELD))) {\n                        av_log(h->avctx, AV_LOG_ERROR,\n                               \"Invalid field mode combination %d/%d\\n\",\n                               last_pic_structure, h->picture_structure);\n                        h->picture_structure = last_pic_structure;\n                        h->droppable         = last_pic_droppable;\n                        return AVERROR_INVALIDDATA;\n                    } else if (last_pic_droppable != h->droppable) {\n                        avpriv_request_sample(h->avctx,\n                                              \"Found reference and non-reference fields in the same frame, which\");\n                        h->picture_structure = last_pic_structure;\n                        h->droppable         = last_pic_droppable;\n                        return AVERROR_PATCHWELCOME;\n                    }\n                }\n            }\n        }\n\n        while (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0 && !h0->first_field &&\n               h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {\n            Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n                   h->frame_num, h->prev_frame_num);\n            if (!h->sps.gaps_in_frame_num_allowed_flag)\n                for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)\n                    h->last_pocs[i] = INT_MIN;\n            ret = h264_frame_start(h);\n            if (ret < 0)\n                return ret;\n            h->prev_frame_num++;\n            h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;\n            h->cur_pic_ptr->frame_num = h->prev_frame_num;\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            /* Error concealment: If a ref is missing, copy the previous ref\n             * in its place.\n             * FIXME: Avoiding a memcpy would be nice, but ref handling makes\n             * many assumptions about there being no actual duplicates.\n             * FIXME: This does not copy padding for out-of-frame motion\n             * vectors.  Given we are concealing a lost frame, this probably\n             * is not noticeable by comparison, but it should be fixed. */\n            if (h->short_ref_count) {\n                if (prev) {\n                    av_image_copy(h->short_ref[0]->f.data,\n                                  h->short_ref[0]->f.linesize,\n                                  (const uint8_t **)prev->f.data,\n                                  prev->f.linesize,\n                                  h->avctx->pix_fmt,\n                                  h->mb_width  * 16,\n                                  h->mb_height * 16);\n                    h->short_ref[0]->poc = prev->poc + 2;\n                }\n                h->short_ref[0]->frame_num = h->prev_frame_num;\n            }\n        }\n\n        /* See if we have a decoded first field looking for a pair...\n         * We're using that to see whether to continue decoding in that\n         * frame, or to allocate a new one. */\n        if (h0->first_field) {\n            assert(h0->cur_pic_ptr);\n            assert(h0->cur_pic_ptr->f.data[0]);\n            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n            /* figure out if we have a complementary field pair */\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n                /* Previous field is unmatched. Don't display it, but let it\n                 * remain for reference if marked as such. */\n                h0->cur_pic_ptr = NULL;\n                h0->first_field = FIELD_PICTURE(h);\n            } else {\n                if (h0->cur_pic_ptr->frame_num != h->frame_num) {\n                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                              h0->picture_structure==PICT_BOTTOM_FIELD);\n                    /* This and the previous field had different frame_nums.\n                     * Consider this field first in pair. Throw away previous\n                     * one except for reference purposes. */\n                    h0->first_field = 1;\n                    h0->cur_pic_ptr = NULL;\n                } else {\n                    /* Second field in complementary pair */\n                    h0->first_field = 0;\n                }\n            }\n        } else {\n            /* Frame or first field in a potentially complementary pair */\n            h0->first_field = FIELD_PICTURE(h);\n        }\n\n        if (!FIELD_PICTURE(h) || h0->first_field) {\n            if (h264_frame_start(h) < 0) {\n                h0->first_field = 0;\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            release_unused_pictures(h, 0);\n        }\n        /* Some macroblocks can be accessed before they're available in case\n        * of lost slices, MBAFF or threading. */\n        if (FIELD_PICTURE(h)) {\n            for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)\n                memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));\n        } else {\n            memset(h->slice_table, -1,\n                (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n        }\n        h0->last_slice_type = -1;\n    }\n    if (h != h0 && (ret = clone_slice(h, h0)) < 0)\n        return ret;\n\n    /* can't be in alloc_tables because linesize isn't known there.\n     * FIXME: redo bipred weight to not require extra buffer? */\n    for (i = 0; i < h->slice_context_count; i++)\n        if (h->thread_context[i]) {\n            ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);\n            if (ret < 0)\n                return ret;\n        }\n\n    h->cur_pic_ptr->frame_num = h->frame_num; // FIXME frame_num cleanup\n\n    av_assert1(h->mb_num == h->mb_width * h->mb_height);\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n        first_mb_in_slice >= h->mb_num) {\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;\n    h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<\n                               FIELD_OR_MBAFF_PICTURE(h);\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n        h->resync_mb_y = h->mb_y = h->mb_y + 1;\n    av_assert1(h->mb_y < h->mb_height);\n\n    if (h->picture_structure == PICT_FRAME) {\n        h->curr_pic_num = h->frame_num;\n        h->max_pic_num  = 1 << h->sps.log2_max_frame_num;\n    } else {\n        h->curr_pic_num = 2 * h->frame_num + 1;\n        h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);\n    }\n\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n        get_ue_golomb(&h->gb); /* idr_pic_id */\n\n    if (h->sps.poc_type == 0) {\n        h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);\n\n        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)\n            h->delta_poc_bottom = get_se_golomb(&h->gb);\n    }\n\n    if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {\n        h->delta_poc[0] = get_se_golomb(&h->gb);\n\n        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)\n            h->delta_poc[1] = get_se_golomb(&h->gb);\n    }\n\n    ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);\n\n    if (h->pps.redundant_pic_cnt_present)\n        h->redundant_pic_count = get_ue_golomb(&h->gb);\n\n    ret = ff_set_ref_count(h);\n    if (ret < 0)\n        return ret;\n\n    if (slice_type != AV_PICTURE_TYPE_I &&\n        (h0->current_slice == 0 ||\n         slice_type != h0->last_slice_type ||\n         memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {\n\n        ff_h264_fill_default_ref_list(h);\n    }\n\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I) {\n       ret = ff_h264_decode_ref_pic_list_reordering(h);\n       if (ret < 0) {\n           h->ref_count[1] = h->ref_count[0] = 0;\n           return ret;\n       }\n    }\n\n    if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||\n        (h->pps.weighted_bipred_idc == 1 &&\n         h->slice_type_nos == AV_PICTURE_TYPE_B))\n        ff_pred_weight_table(h);\n    else if (h->pps.weighted_bipred_idc == 2 &&\n             h->slice_type_nos == AV_PICTURE_TYPE_B) {\n        implicit_weight_table(h, -1);\n    } else {\n        h->use_weight = 0;\n        for (i = 0; i < 2; i++) {\n            h->luma_weight_flag[i]   = 0;\n            h->chroma_weight_flag[i] = 0;\n        }\n    }\n\n    // If frame-mt is enabled, only update mmco tables for the first slice\n    // in a field. Subsequent slices can temporarily clobber h->mmco_index\n    // or h->mmco, which will cause ref list mix-ups and decoding errors\n    // further down the line. This may break decoding if the first slice is\n    // corrupt, thus we only do this if frame-mt is enabled.\n    if (h->nal_ref_idc) {\n        ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n                                             h0->current_slice == 0);\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n            return AVERROR_INVALIDDATA;\n    }\n\n    if (FRAME_MBAFF(h)) {\n        ff_h264_fill_mbaff_ref_list(h);\n\n        if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {\n            implicit_weight_table(h, 0);\n            implicit_weight_table(h, 1);\n        }\n    }\n\n    if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)\n        ff_h264_direct_dist_scale_factor(h);\n    ff_h264_direct_ref_list_init(h);\n\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {\n        tmp = get_ue_golomb_31(&h->gb);\n        if (tmp > 2) {\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc overflow\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        h->cabac_init_idc = tmp;\n    }\n\n    h->last_qscale_diff = 0;\n    tmp = h->pps.init_qp + get_se_golomb(&h->gb);\n    if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n        return AVERROR_INVALIDDATA;\n    }\n    h->qscale       = tmp;\n    h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);\n    h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);\n    // FIXME qscale / qp ... stuff\n    if (h->slice_type == AV_PICTURE_TYPE_SP)\n        get_bits1(&h->gb); /* sp_for_switch_flag */\n    if (h->slice_type == AV_PICTURE_TYPE_SP ||\n        h->slice_type == AV_PICTURE_TYPE_SI)\n        get_se_golomb(&h->gb); /* slice_qs_delta */\n\n    h->deblocking_filter     = 1;\n    h->slice_alpha_c0_offset = 52;\n    h->slice_beta_offset     = 52;\n    if (h->pps.deblocking_filter_parameters_present) {\n        tmp = get_ue_golomb_31(&h->gb);\n        if (tmp > 2) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n            return AVERROR_INVALIDDATA;\n        }\n        h->deblocking_filter = tmp;\n        if (h->deblocking_filter < 2)\n            h->deblocking_filter ^= 1;  // 1<->0\n\n        if (h->deblocking_filter) {\n            h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;\n            h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;\n            if (h->slice_alpha_c0_offset > 104U ||\n                h->slice_beta_offset     > 104U) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"deblocking filter parameters %d %d out of range\\n\",\n                       h->slice_alpha_c0_offset, h->slice_beta_offset);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n\n    if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&\n         h->slice_type_nos != AV_PICTURE_TYPE_I) ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&\n         h->slice_type_nos == AV_PICTURE_TYPE_B) ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&\n         h->nal_ref_idc == 0))\n        h->deblocking_filter = 0;\n\n    if (h->deblocking_filter == 1 && h0->max_contexts > 1) {\n        if (h->avctx->flags2 & CODEC_FLAG2_FAST) {\n            /* Cheat slightly for speed:\n             * Do not bother to deblock across slices. */\n            h->deblocking_filter = 2;\n        } else {\n            h0->max_contexts = 1;\n            if (!h0->single_decode_warning) {\n                av_log(h->avctx, AV_LOG_INFO,\n                       \"Cannot parallelize deblocking type 1, decoding such frames in sequential order\\n\");\n                h0->single_decode_warning = 1;\n            }\n            if (h != h0) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"Deblocking switched inside frame.\\n\");\n                return 1;\n            }\n        }\n    }\n    h->qp_thresh = 15 + 52 -\n                   FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -\n                   FFMAX3(0,\n                          h->pps.chroma_qp_index_offset[0],\n                          h->pps.chroma_qp_index_offset[1]) +\n                   6 * (h->sps.bit_depth_luma - 8);\n\n    h0->last_slice_type = slice_type;\n    memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));\n    h->slice_num        = ++h0->current_slice;\n\n    if (h->slice_num)\n        h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;\n    if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y\n        && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y\n        && h->slice_num >= MAX_SLICES) {\n        //in case of ASO this check needs to be updated depending on how we decide to assign slice numbers in this case\n        av_log(h->avctx, AV_LOG_WARNING, \"Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\\n\", h->slice_num, MAX_SLICES);\n    }\n\n    for (j = 0; j < 2; j++) {\n        int id_list[16];\n        int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];\n        for (i = 0; i < 16; i++) {\n            id_list[i] = 60;\n            if (j < h->list_count && i < h->ref_count[j] &&\n                h->ref_list[j][i].f.buf[0]) {\n                int k;\n                AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;\n                for (k = 0; k < h->short_ref_count; k++)\n                    if (h->short_ref[k]->f.buf[0]->buffer == buf) {\n                        id_list[i] = k;\n                        break;\n                    }\n                for (k = 0; k < h->long_ref_count; k++)\n                    if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {\n                        id_list[i] = h->short_ref_count + k;\n                        break;\n                    }\n            }\n        }\n\n        ref2frm[0] =\n        ref2frm[1] = -1;\n        for (i = 0; i < 16; i++)\n            ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);\n        ref2frm[18 + 0] =\n        ref2frm[18 + 1] = -1;\n        for (i = 16; i < 48; i++)\n            ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +\n                             (h->ref_list[j][i].reference & 3);\n    }\n\n    if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];\n    if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];\n    h->er.ref_count = h->ref_count[0];\n\n    if (h->avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(h->avctx, AV_LOG_DEBUG,\n               \"slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\\n\",\n               h->slice_num,\n               (h->picture_structure == PICT_FRAME ? \"F\" : h->picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\"),\n               first_mb_in_slice,\n               av_get_picture_type_char(h->slice_type),\n               h->slice_type_fixed ? \" fix\" : \"\",\n               h->nal_unit_type == NAL_IDR_SLICE ? \" IDR\" : \"\",\n               pps_id, h->frame_num,\n               h->cur_pic_ptr->field_poc[0],\n               h->cur_pic_ptr->field_poc[1],\n               h->ref_count[0], h->ref_count[1],\n               h->qscale,\n               h->deblocking_filter,\n               h->slice_alpha_c0_offset / 2 - 26, h->slice_beta_offset / 2 - 26,\n               h->use_weight,\n               h->use_weight == 1 && h->use_weight_chroma ? \"c\" : \"\",\n               h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\") : \"\");\n    }\n\n    return 0;\n}\n\nint ff_h264_get_slice_type(const H264Context *h)\n{\n    switch (h->slice_type) {\n    case AV_PICTURE_TYPE_P:\n        return 0;\n    case AV_PICTURE_TYPE_B:\n        return 1;\n    case AV_PICTURE_TYPE_I:\n        return 2;\n    case AV_PICTURE_TYPE_SP:\n        return 3;\n    case AV_PICTURE_TYPE_SI:\n        return 4;\n    default:\n        return AVERROR_INVALIDDATA;\n    }\n}\n\nstatic av_always_inline void fill_filter_caches_inter(H264Context *h,\n                                                      int mb_type, int top_xy,\n                                                      int left_xy[LEFT_MBS],\n                                                      int top_type,\n                                                      int left_type[LEFT_MBS],\n                                                      int mb_xy, int list)\n{\n    int b_stride = h->b_stride;\n    int16_t(*mv_dst)[2] = &h->mv_cache[list][scan8[0]];\n    int8_t *ref_cache = &h->ref_cache[list][scan8[0]];\n    if (IS_INTER(mb_type) || IS_DIRECT(mb_type)) {\n        if (USES_LIST(top_type, list)) {\n            const int b_xy  = h->mb2b_xy[top_xy] + 3 * b_stride;\n            const int b8_xy = 4 * top_xy + 2;\n            int (*ref2frm)[64] = (void*)(h->ref2frm[h->slice_table[top_xy] & (MAX_SLICES - 1)][0] + (MB_MBAFF(h) ? 20 : 2));\n            AV_COPY128(mv_dst - 1 * 8, h->cur_pic.motion_val[list][b_xy + 0]);\n            ref_cache[0 - 1 * 8] =\n            ref_cache[1 - 1 * 8] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 0]];\n            ref_cache[2 - 1 * 8] =\n            ref_cache[3 - 1 * 8] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 1]];\n        } else {\n            AV_ZERO128(mv_dst - 1 * 8);\n            AV_WN32A(&ref_cache[0 - 1 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        }\n\n        if (!IS_INTERLACED(mb_type ^ left_type[LTOP])) {\n            if (USES_LIST(left_type[LTOP], list)) {\n                const int b_xy  = h->mb2b_xy[left_xy[LTOP]] + 3;\n                const int b8_xy = 4 * left_xy[LTOP] + 1;\n                int (*ref2frm)[64] =(void*)( h->ref2frm[h->slice_table[left_xy[LTOP]] & (MAX_SLICES - 1)][0] + (MB_MBAFF(h) ? 20 : 2));\n                AV_COPY32(mv_dst - 1 +  0, h->cur_pic.motion_val[list][b_xy + b_stride * 0]);\n                AV_COPY32(mv_dst - 1 +  8, h->cur_pic.motion_val[list][b_xy + b_stride * 1]);\n                AV_COPY32(mv_dst - 1 + 16, h->cur_pic.motion_val[list][b_xy + b_stride * 2]);\n                AV_COPY32(mv_dst - 1 + 24, h->cur_pic.motion_val[list][b_xy + b_stride * 3]);\n                ref_cache[-1 +  0] =\n                ref_cache[-1 +  8] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 2 * 0]];\n                ref_cache[-1 + 16] =\n                ref_cache[-1 + 24] = ref2frm[list][h->cur_pic.ref_index[list][b8_xy + 2 * 1]];\n            } else {\n                AV_ZERO32(mv_dst - 1 +  0);\n                AV_ZERO32(mv_dst - 1 +  8);\n                AV_ZERO32(mv_dst - 1 + 16);\n                AV_ZERO32(mv_dst - 1 + 24);\n                ref_cache[-1 +  0] =\n                ref_cache[-1 +  8] =\n                ref_cache[-1 + 16] =\n                ref_cache[-1 + 24] = LIST_NOT_USED;\n            }\n        }\n    }\n\n    if (!USES_LIST(mb_type, list)) {\n        fill_rectangle(mv_dst, 4, 4, 8, pack16to32(0, 0), 4);\n        AV_WN32A(&ref_cache[0 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        AV_WN32A(&ref_cache[1 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        AV_WN32A(&ref_cache[2 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        AV_WN32A(&ref_cache[3 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);\n        return;\n    }\n\n    {\n        int8_t *ref = &h->cur_pic.ref_index[list][4 * mb_xy];\n        int (*ref2frm)[64] = (void*)(h->ref2frm[h->slice_num & (MAX_SLICES - 1)][0] + (MB_MBAFF(h) ? 20 : 2));\n        uint32_t ref01 = (pack16to32(ref2frm[list][ref[0]], ref2frm[list][ref[1]]) & 0x00FF00FF) * 0x0101;\n        uint32_t ref23 = (pack16to32(ref2frm[list][ref[2]], ref2frm[list][ref[3]]) & 0x00FF00FF) * 0x0101;\n        AV_WN32A(&ref_cache[0 * 8], ref01);\n        AV_WN32A(&ref_cache[1 * 8], ref01);\n        AV_WN32A(&ref_cache[2 * 8], ref23);\n        AV_WN32A(&ref_cache[3 * 8], ref23);\n    }\n\n    {\n        int16_t(*mv_src)[2] = &h->cur_pic.motion_val[list][4 * h->mb_x + 4 * h->mb_y * b_stride];\n        AV_COPY128(mv_dst + 8 * 0, mv_src + 0 * b_stride);\n        AV_COPY128(mv_dst + 8 * 1, mv_src + 1 * b_stride);\n        AV_COPY128(mv_dst + 8 * 2, mv_src + 2 * b_stride);\n        AV_COPY128(mv_dst + 8 * 3, mv_src + 3 * b_stride);\n    }\n}\n\n/**\n *\n * @return non zero if the loop filter can be skipped\n */\nstatic int fill_filter_caches(H264Context *h, int mb_type)\n{\n    const int mb_xy = h->mb_xy;\n    int top_xy, left_xy[LEFT_MBS];\n    int top_type, left_type[LEFT_MBS];\n    uint8_t *nnz;\n    uint8_t *nnz_cache;\n\n    top_xy = mb_xy - (h->mb_stride << MB_FIELD(h));\n\n    /* Wow, what a mess, why didn't they simplify the interlacing & intra\n     * stuff, I can't imagine that these complex rules are worth it. */\n\n    left_xy[LBOT] = left_xy[LTOP] = mb_xy - 1;\n    if (FRAME_MBAFF(h)) {\n        const int left_mb_field_flag = IS_INTERLACED(h->cur_pic.mb_type[mb_xy - 1]);\n        const int curr_mb_field_flag = IS_INTERLACED(mb_type);\n        if (h->mb_y & 1) {\n            if (left_mb_field_flag != curr_mb_field_flag)\n                left_xy[LTOP] -= h->mb_stride;\n        } else {\n            if (curr_mb_field_flag)\n                top_xy += h->mb_stride &\n                          (((h->cur_pic.mb_type[top_xy] >> 7) & 1) - 1);\n            if (left_mb_field_flag != curr_mb_field_flag)\n                left_xy[LBOT] += h->mb_stride;\n        }\n    }\n\n    h->top_mb_xy        = top_xy;\n    h->left_mb_xy[LTOP] = left_xy[LTOP];\n    h->left_mb_xy[LBOT] = left_xy[LBOT];\n    {\n        /* For sufficiently low qp, filtering wouldn't do anything.\n         * This is a conservative estimate: could also check beta_offset\n         * and more accurate chroma_qp. */\n        int qp_thresh = h->qp_thresh; // FIXME strictly we should store qp_thresh for each mb of a slice\n        int qp        = h->cur_pic.qscale_table[mb_xy];\n        if (qp <= qp_thresh &&\n            (left_xy[LTOP] < 0 ||\n             ((qp + h->cur_pic.qscale_table[left_xy[LTOP]] + 1) >> 1) <= qp_thresh) &&\n            (top_xy < 0 ||\n             ((qp + h->cur_pic.qscale_table[top_xy] + 1) >> 1) <= qp_thresh)) {\n            if (!FRAME_MBAFF(h))\n                return 1;\n            if ((left_xy[LTOP] < 0 ||\n                 ((qp + h->cur_pic.qscale_table[left_xy[LBOT]] + 1) >> 1) <= qp_thresh) &&\n                (top_xy < h->mb_stride ||\n                 ((qp + h->cur_pic.qscale_table[top_xy - h->mb_stride] + 1) >> 1) <= qp_thresh))\n                return 1;\n        }\n    }\n\n    top_type        = h->cur_pic.mb_type[top_xy];\n    left_type[LTOP] = h->cur_pic.mb_type[left_xy[LTOP]];\n    left_type[LBOT] = h->cur_pic.mb_type[left_xy[LBOT]];\n    if (h->deblocking_filter == 2) {\n        if (h->slice_table[top_xy] != h->slice_num)\n            top_type = 0;\n        if (h->slice_table[left_xy[LBOT]] != h->slice_num)\n            left_type[LTOP] = left_type[LBOT] = 0;\n    } else {\n        if (h->slice_table[top_xy] == 0xFFFF)\n            top_type = 0;\n        if (h->slice_table[left_xy[LBOT]] == 0xFFFF)\n            left_type[LTOP] = left_type[LBOT] = 0;\n    }\n    h->top_type        = top_type;\n    h->left_type[LTOP] = left_type[LTOP];\n    h->left_type[LBOT] = left_type[LBOT];\n\n    if (IS_INTRA(mb_type))\n        return 0;\n\n    fill_filter_caches_inter(h, mb_type, top_xy, left_xy,\n                             top_type, left_type, mb_xy, 0);\n    if (h->list_count == 2)\n        fill_filter_caches_inter(h, mb_type, top_xy, left_xy,\n                                 top_type, left_type, mb_xy, 1);\n\n    nnz       = h->non_zero_count[mb_xy];\n    nnz_cache = h->non_zero_count_cache;\n    AV_COPY32(&nnz_cache[4 + 8 * 1], &nnz[0]);\n    AV_COPY32(&nnz_cache[4 + 8 * 2], &nnz[4]);\n    AV_COPY32(&nnz_cache[4 + 8 * 3], &nnz[8]);\n    AV_COPY32(&nnz_cache[4 + 8 * 4], &nnz[12]);\n    h->cbp = h->cbp_table[mb_xy];\n\n    if (top_type) {\n        nnz = h->non_zero_count[top_xy];\n        AV_COPY32(&nnz_cache[4 + 8 * 0], &nnz[3 * 4]);\n    }\n\n    if (left_type[LTOP]) {\n        nnz = h->non_zero_count[left_xy[LTOP]];\n        nnz_cache[3 + 8 * 1] = nnz[3 + 0 * 4];\n        nnz_cache[3 + 8 * 2] = nnz[3 + 1 * 4];\n        nnz_cache[3 + 8 * 3] = nnz[3 + 2 * 4];\n        nnz_cache[3 + 8 * 4] = nnz[3 + 3 * 4];\n    }\n\n    /* CAVLC 8x8dct requires NNZ values for residual decoding that differ\n     * from what the loop filter needs */\n    if (!CABAC(h) && h->pps.transform_8x8_mode) {\n        if (IS_8x8DCT(top_type)) {\n            nnz_cache[4 + 8 * 0] =\n            nnz_cache[5 + 8 * 0] = (h->cbp_table[top_xy] & 0x4000) >> 12;\n            nnz_cache[6 + 8 * 0] =\n            nnz_cache[7 + 8 * 0] = (h->cbp_table[top_xy] & 0x8000) >> 12;\n        }\n        if (IS_8x8DCT(left_type[LTOP])) {\n            nnz_cache[3 + 8 * 1] =\n            nnz_cache[3 + 8 * 2] = (h->cbp_table[left_xy[LTOP]] & 0x2000) >> 12; // FIXME check MBAFF\n        }\n        if (IS_8x8DCT(left_type[LBOT])) {\n            nnz_cache[3 + 8 * 3] =\n            nnz_cache[3 + 8 * 4] = (h->cbp_table[left_xy[LBOT]] & 0x8000) >> 12; // FIXME check MBAFF\n        }\n\n        if (IS_8x8DCT(mb_type)) {\n            nnz_cache[scan8[0]] =\n            nnz_cache[scan8[1]] =\n            nnz_cache[scan8[2]] =\n            nnz_cache[scan8[3]] = (h->cbp & 0x1000) >> 12;\n\n            nnz_cache[scan8[0 + 4]] =\n            nnz_cache[scan8[1 + 4]] =\n            nnz_cache[scan8[2 + 4]] =\n            nnz_cache[scan8[3 + 4]] = (h->cbp & 0x2000) >> 12;\n\n            nnz_cache[scan8[0 + 8]] =\n            nnz_cache[scan8[1 + 8]] =\n            nnz_cache[scan8[2 + 8]] =\n            nnz_cache[scan8[3 + 8]] = (h->cbp & 0x4000) >> 12;\n\n            nnz_cache[scan8[0 + 12]] =\n            nnz_cache[scan8[1 + 12]] =\n            nnz_cache[scan8[2 + 12]] =\n            nnz_cache[scan8[3 + 12]] = (h->cbp & 0x8000) >> 12;\n        }\n    }\n\n    return 0;\n}\n\nstatic void loop_filter(H264Context *h, int start_x, int end_x)\n{\n    uint8_t *dest_y, *dest_cb, *dest_cr;\n    int linesize, uvlinesize, mb_x, mb_y;\n    const int end_mb_y       = h->mb_y + FRAME_MBAFF(h);\n    const int old_slice_type = h->slice_type;\n    const int pixel_shift    = h->pixel_shift;\n    const int block_h        = 16 >> h->chroma_y_shift;\n\n    if (h->deblocking_filter) {\n        for (mb_x = start_x; mb_x < end_x; mb_x++)\n            for (mb_y = end_mb_y - FRAME_MBAFF(h); mb_y <= end_mb_y; mb_y++) {\n                int mb_xy, mb_type;\n                mb_xy         = h->mb_xy = mb_x + mb_y * h->mb_stride;\n                h->slice_num  = h->slice_table[mb_xy];\n                mb_type       = h->cur_pic.mb_type[mb_xy];\n                h->list_count = h->list_counts[mb_xy];\n\n                if (FRAME_MBAFF(h))\n                    h->mb_mbaff               =\n                    h->mb_field_decoding_flag = !!IS_INTERLACED(mb_type);\n\n                h->mb_x = mb_x;\n                h->mb_y = mb_y;\n                dest_y  = h->cur_pic.f.data[0] +\n                          ((mb_x << pixel_shift) + mb_y * h->linesize) * 16;\n                dest_cb = h->cur_pic.f.data[1] +\n                          (mb_x << pixel_shift) * (8 << CHROMA444(h)) +\n                          mb_y * h->uvlinesize * block_h;\n                dest_cr = h->cur_pic.f.data[2] +\n                          (mb_x << pixel_shift) * (8 << CHROMA444(h)) +\n                          mb_y * h->uvlinesize * block_h;\n                // FIXME simplify above\n\n                if (MB_FIELD(h)) {\n                    linesize   = h->mb_linesize   = h->linesize   * 2;\n                    uvlinesize = h->mb_uvlinesize = h->uvlinesize * 2;\n                    if (mb_y & 1) { // FIXME move out of this function?\n                        dest_y  -= h->linesize   * 15;\n                        dest_cb -= h->uvlinesize * (block_h - 1);\n                        dest_cr -= h->uvlinesize * (block_h - 1);\n                    }\n                } else {\n                    linesize   = h->mb_linesize   = h->linesize;\n                    uvlinesize = h->mb_uvlinesize = h->uvlinesize;\n                }\n                backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize,\n                                 uvlinesize, 0);\n                if (fill_filter_caches(h, mb_type))\n                    continue;\n                h->chroma_qp[0] = get_chroma_qp(h, 0, h->cur_pic.qscale_table[mb_xy]);\n                h->chroma_qp[1] = get_chroma_qp(h, 1, h->cur_pic.qscale_table[mb_xy]);\n\n                if (FRAME_MBAFF(h)) {\n                    ff_h264_filter_mb(h, mb_x, mb_y, dest_y, dest_cb, dest_cr,\n                                      linesize, uvlinesize);\n                } else {\n                    ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb,\n                                           dest_cr, linesize, uvlinesize);\n                }\n            }\n    }\n    h->slice_type   = old_slice_type;\n    h->mb_x         = end_x;\n    h->mb_y         = end_mb_y - FRAME_MBAFF(h);\n    h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);\n    h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);\n}\n\nstatic void predict_field_decoding_flag(H264Context *h)\n{\n    const int mb_xy = h->mb_x + h->mb_y * h->mb_stride;\n    int mb_type     = (h->slice_table[mb_xy - 1] == h->slice_num) ?\n                      h->cur_pic.mb_type[mb_xy - 1] :\n                      (h->slice_table[mb_xy - h->mb_stride] == h->slice_num) ?\n                      h->cur_pic.mb_type[mb_xy - h->mb_stride] : 0;\n    h->mb_mbaff     = h->mb_field_decoding_flag = IS_INTERLACED(mb_type) ? 1 : 0;\n}\n\n/**\n * Draw edges and report progress for the last MB row.\n */\nstatic void decode_finish_row(H264Context *h)\n{\n    int top            = 16 * (h->mb_y      >> FIELD_PICTURE(h));\n    int pic_height     = 16 *  h->mb_height >> FIELD_PICTURE(h);\n    int height         =  16      << FRAME_MBAFF(h);\n    int deblock_border = (16 + 4) << FRAME_MBAFF(h);\n\n    if (h->deblocking_filter) {\n        if ((top + height) >= pic_height)\n            height += deblock_border;\n        top -= deblock_border;\n    }\n\n    if (top >= pic_height || (top + height) < 0)\n        return;\n\n    height = FFMIN(height, pic_height - top);\n    if (top < 0) {\n        height = top + height;\n        top    = 0;\n    }\n\n    ff_h264_draw_horiz_band(h, top, height);\n\n    if (h->droppable || h->er.error_occurred)\n        return;\n\n    ff_thread_report_progress(&h->cur_pic_ptr->tf, top + height - 1,\n                              h->picture_structure == PICT_BOTTOM_FIELD);\n}\n\nstatic void er_add_slice(H264Context *h, int startx, int starty,\n                         int endx, int endy, int status)\n{\n    if (CONFIG_ERROR_RESILIENCE) {\n        ERContext *er = &h->er;\n\n        ff_er_add_slice(er, startx, starty, endx, endy, status);\n    }\n}\n\nstatic int decode_slice(struct AVCodecContext *avctx, void *arg)\n{\n    H264Context *h = *(void **)arg;\n    int lf_x_start = h->mb_x;\n\n    h->mb_skip_run = -1;\n\n    av_assert0(h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * h->linesize * ((scan8[15] - scan8[0]) >> 3));\n\n    h->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n                    avctx->codec_id != AV_CODEC_ID_H264 ||\n                    (CONFIG_GRAY && (h->flags & CODEC_FLAG_GRAY));\n\n    if (!(h->avctx->active_thread_type & FF_THREAD_SLICE) && h->picture_structure == PICT_FRAME && h->er.error_status_table) {\n        const int start_i  = av_clip(h->resync_mb_x + h->resync_mb_y * h->mb_width, 0, h->mb_num - 1);\n        if (start_i) {\n            int prev_status = h->er.error_status_table[h->er.mb_index2xy[start_i - 1]];\n            prev_status &= ~ VP_START;\n            if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END))\n                h->er.error_occurred = 1;\n        }\n    }\n\n    if (h->pps.cabac) {\n        /* realign */\n        align_get_bits(&h->gb);\n\n        /* init cabac */\n        ff_init_cabac_decoder(&h->cabac,\n                              h->gb.buffer + get_bits_count(&h->gb) / 8,\n                              (get_bits_left(&h->gb) + 7) / 8);\n\n        ff_h264_init_cabac_states(h);\n\n        for (;;) {\n            // START_TIMER\n            int ret = ff_h264_decode_mb_cabac(h);\n            int eos;\n            // STOP_TIMER(\"decode_mb_cabac\")\n\n            if (ret >= 0)\n                ff_h264_hl_decode_mb(h);\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n                h->mb_y++;\n\n                ret = ff_h264_decode_mb_cabac(h);\n\n                if (ret >= 0)\n                    ff_h264_hl_decode_mb(h);\n                h->mb_y--;\n            }\n            eos = get_cabac_terminate(&h->cabac);\n\n            if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n                h->cabac.bytestream > h->cabac.bytestream_end + 2) {\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n                             h->mb_y, ER_MB_END);\n                if (h->mb_x >= lf_x_start)\n                    loop_filter(h, lf_x_start, h->mb_x + 1);\n                return 0;\n            }\n            if (h->cabac.bytestream > h->cabac.bytestream_end + 2 )\n                av_log(h->avctx, AV_LOG_DEBUG, \"bytestream overread %td\\n\", h->cabac.bytestream_end - h->cabac.bytestream);\n            if (ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 4) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"error while decoding MB %d %d, bytestream (%td)\\n\",\n                       h->mb_x, h->mb_y,\n                       h->cabac.bytestream_end - h->cabac.bytestream);\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n                             h->mb_y, ER_MB_ERROR);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (++h->mb_x >= h->mb_width) {\n                loop_filter(h, lf_x_start, h->mb_x);\n                h->mb_x = lf_x_start = 0;\n                decode_finish_row(h);\n                ++h->mb_y;\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n                    ++h->mb_y;\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n                        predict_field_decoding_flag(h);\n                }\n            }\n\n            if (eos || h->mb_y >= h->mb_height) {\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n                             h->mb_y, ER_MB_END);\n                if (h->mb_x > lf_x_start)\n                    loop_filter(h, lf_x_start, h->mb_x);\n                return 0;\n            }\n        }\n    } else {\n        for (;;) {\n            int ret = ff_h264_decode_mb_cavlc(h);\n\n            if (ret >= 0)\n                ff_h264_hl_decode_mb(h);\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n                h->mb_y++;\n                ret = ff_h264_decode_mb_cavlc(h);\n\n                if (ret >= 0)\n                    ff_h264_hl_decode_mb(h);\n                h->mb_y--;\n            }\n\n            if (ret < 0) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"error while decoding MB %d %d\\n\", h->mb_x, h->mb_y);\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n                             h->mb_y, ER_MB_ERROR);\n                return ret;\n            }\n\n            if (++h->mb_x >= h->mb_width) {\n                loop_filter(h, lf_x_start, h->mb_x);\n                h->mb_x = lf_x_start = 0;\n                decode_finish_row(h);\n                ++h->mb_y;\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n                    ++h->mb_y;\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n                        predict_field_decoding_flag(h);\n                }\n                if (h->mb_y >= h->mb_height) {\n                    tprintf(h->avctx, \"slice end %d %d\\n\",\n                            get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                    if (   get_bits_left(&h->gb) == 0\n                        || get_bits_left(&h->gb) > 0 && !(h->avctx->err_recognition & AV_EF_AGGRESSIVE)) {\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n                                     h->mb_x - 1, h->mb_y,\n                                     ER_MB_END);\n\n                        return 0;\n                    } else {\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n                                     h->mb_x, h->mb_y,\n                                     ER_MB_END);\n\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if (get_bits_left(&h->gb) <= 0 && h->mb_skip_run <= 0) {\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                if (get_bits_left(&h->gb) == 0) {\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n                                 h->mb_x - 1, h->mb_y,\n                                 ER_MB_END);\n                    if (h->mb_x > lf_x_start)\n                        loop_filter(h, lf_x_start, h->mb_x);\n\n                    return 0;\n                } else {\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n                                 h->mb_y, ER_MB_ERROR);\n\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n}\n\n/**\n * Call decode_slice() for each context.\n *\n * @param h h264 master context\n * @param context_count number of contexts to execute\n */\nstatic int execute_decode_slices(H264Context *h, int context_count)\n{\n    AVCodecContext *const avctx = h->avctx;\n    H264Context *hx;\n    int i;\n\n    if (h->avctx->hwaccel ||\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        return 0;\n    if (context_count == 1) {\n        return decode_slice(avctx, &h);\n    } else {\n        av_assert0(context_count > 0);\n        for (i = 1; i < context_count; i++) {\n            hx                 = h->thread_context[i];\n            if (CONFIG_ERROR_RESILIENCE) {\n                hx->er.error_count = 0;\n            }\n            hx->x264_build     = h->x264_build;\n        }\n\n        avctx->execute(avctx, decode_slice, h->thread_context,\n                       NULL, context_count, sizeof(void *));\n\n        /* pull back stuff from slices to master context */\n        hx                   = h->thread_context[context_count - 1];\n        h->mb_x              = hx->mb_x;\n        h->mb_y              = hx->mb_y;\n        h->droppable         = hx->droppable;\n        h->picture_structure = hx->picture_structure;\n        if (CONFIG_ERROR_RESILIENCE) {\n            for (i = 1; i < context_count; i++)\n                h->er.error_count += h->thread_context[i]->er.error_count;\n        }\n    }\n\n    return 0;\n}\n\nstatic const uint8_t start_code[] = { 0x00, 0x00, 0x01 };\n\nstatic int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size,\n                            int parse_extradata)\n{\n    AVCodecContext *const avctx = h->avctx;\n    H264Context *hx; ///< thread context\n    int buf_index;\n    int context_count;\n    int next_avc;\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n    int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts\n    int nal_index;\n    int idr_cleared=0;\n    int first_slice = 0;\n    int ret = 0;\n\n    h->nal_unit_type= 0;\n\n    if(!h->slice_context_count)\n         h->slice_context_count= 1;\n    h->max_contexts = h->slice_context_count;\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS)) {\n        h->current_slice = 0;\n        if (!h->first_field)\n            h->cur_pic_ptr = NULL;\n        ff_h264_reset_sei(h);\n    }\n\n    if (h->nal_length_size == 4) {\n        if (buf_size > 8 && AV_RB32(buf) == 1 && AV_RB32(buf+5) > (unsigned)buf_size) {\n            h->is_avc = 0;\n        }else if(buf_size > 3 && AV_RB32(buf) > 1 && AV_RB32(buf) <= (unsigned)buf_size)\n            h->is_avc = 1;\n    }\n\n    for (; pass <= 1; pass++) {\n        buf_index     = 0;\n        context_count = 0;\n        next_avc      = h->is_avc ? 0 : buf_size;\n        nal_index     = 0;\n        for (;;) {\n            int consumed;\n            int dst_length;\n            int bit_length;\n            const uint8_t *ptr;\n            int i, nalsize = 0;\n            int err;\n\n            if (buf_index >= next_avc) {\n                if (buf_index >= buf_size - h->nal_length_size)\n                    break;\n                nalsize = 0;\n                for (i = 0; i < h->nal_length_size; i++)\n                    nalsize = (nalsize << 8) | buf[buf_index++];\n                if (nalsize <= 0 || nalsize > buf_size - buf_index) {\n                    av_log(h->avctx, AV_LOG_ERROR,\n                           \"AVC: nal size %d\\n\", nalsize);\n                    break;\n                }\n                next_avc = buf_index + nalsize;\n            } else {\n                // start code prefix search\n                for (; buf_index + 3 < next_avc; buf_index++)\n                    // This should always succeed in the first iteration.\n                    if (buf[buf_index]     == 0 &&\n                        buf[buf_index + 1] == 0 &&\n                        buf[buf_index + 2] == 1)\n                        break;\n\n                if (buf_index + 3 >= buf_size) {\n                    buf_index = buf_size;\n                    break;\n                }\n\n                buf_index += 3;\n                if (buf_index >= next_avc)\n                    continue;\n            }\n\n            hx = h->thread_context[context_count];\n\n            ptr = ff_h264_decode_nal(hx, buf + buf_index, &dst_length,\n                                     &consumed, next_avc - buf_index);\n            if (ptr == NULL || dst_length < 0) {\n                ret = -1;\n                goto end;\n            }\n            i = buf_index + consumed;\n            if ((h->workaround_bugs & FF_BUG_AUTODETECT) && i + 3 < next_avc &&\n                buf[i]     == 0x00 && buf[i + 1] == 0x00 &&\n                buf[i + 2] == 0x01 && buf[i + 3] == 0xE0)\n                h->workaround_bugs |= FF_BUG_TRUNCATED;\n\n            if (!(h->workaround_bugs & FF_BUG_TRUNCATED))\n                while(dst_length > 0 && ptr[dst_length - 1] == 0)\n                    dst_length--;\n            bit_length = !dst_length ? 0\n                                     : (8 * dst_length -\n                                        decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n            if (h->avctx->debug & FF_DEBUG_STARTCODE)\n                av_log(h->avctx, AV_LOG_DEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);\n\n            if (h->is_avc && (nalsize != consumed) && nalsize)\n                av_log(h->avctx, AV_LOG_DEBUG,\n                       \"AVC: Consumed only %d bytes instead of %d\\n\",\n                       consumed, nalsize);\n\n            buf_index += consumed;\n            nal_index++;\n\n            if (pass == 0) {\n                /* packets can sometimes contain multiple PPS/SPS,\n                 * e.g. two PAFF field pictures in one packet, or a demuxer\n                 * which splits NALs strangely if so, when frame threading we\n                 * can't start the next thread until we've read all of them */\n                switch (hx->nal_unit_type) {\n                case NAL_SPS:\n                case NAL_PPS:\n                    nals_needed = nal_index;\n                    break;\n                case NAL_DPA:\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                    init_get_bits(&hx->gb, ptr, bit_length);\n                    if (!get_ue_golomb(&hx->gb) || !first_slice)\n                        nals_needed = nal_index;\n                    if (!first_slice)\n                        first_slice = hx->nal_unit_type;\n                }\n                continue;\n            }\n\n            if (!first_slice)\n                switch (hx->nal_unit_type) {\n                case NAL_DPA:\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                    first_slice = hx->nal_unit_type;\n                }\n\n            if (avctx->skip_frame >= AVDISCARD_NONREF &&\n                h->nal_ref_idc == 0 &&\n                h->nal_unit_type != NAL_SEI)\n                continue;\n\nagain:\n            /* Ignore per frame NAL unit type during extradata\n             * parsing. Decoding slices is not possible in codec init\n             * with frame-mt */\n            if (parse_extradata) {\n                switch (hx->nal_unit_type) {\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                case NAL_DPA:\n                case NAL_DPB:\n                case NAL_DPC:\n                    av_log(h->avctx, AV_LOG_WARNING,\n                           \"Ignoring NAL %d in global header/extradata\\n\",\n                           hx->nal_unit_type);\n                    // fall through to next case\n                case NAL_AUXILIARY_SLICE:\n                    hx->nal_unit_type = NAL_FF_IGNORE;\n                }\n            }\n\n            err = 0;\n\n            switch (hx->nal_unit_type) {\n            case NAL_IDR_SLICE:\n                if (first_slice != NAL_IDR_SLICE) {\n                    av_log(h->avctx, AV_LOG_ERROR,\n                           \"Invalid mix of idr and non-idr slices\\n\");\n                    ret = -1;\n                    goto end;\n                }\n                if(!idr_cleared)\n                    idr(h); // FIXME ensure we don't lose some frames if there is reordering\n                idr_cleared = 1;\n            case NAL_SLICE:\n                init_get_bits(&hx->gb, ptr, bit_length);\n                hx->intra_gb_ptr      =\n                hx->inter_gb_ptr      = &hx->gb;\n                hx->data_partitioning = 0;\n\n                if ((err = decode_slice_header(hx, h)))\n                    break;\n\n                if (h->sei_recovery_frame_cnt >= 0 && (h->frame_num != h->sei_recovery_frame_cnt || hx->slice_type_nos != AV_PICTURE_TYPE_I))\n                    h->valid_recovery_point = 1;\n\n                if (   h->sei_recovery_frame_cnt >= 0\n                    && (   h->recovery_frame<0\n                        || ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt)) {\n                    h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %\n                                        (1 << h->sps.log2_max_frame_num);\n\n                    if (!h->valid_recovery_point)\n                        h->recovery_frame = h->frame_num;\n                }\n\n                h->cur_pic_ptr->f.key_frame |=\n                        (hx->nal_unit_type == NAL_IDR_SLICE);\n\n                if (h->recovery_frame == h->frame_num) {\n                    h->cur_pic_ptr->sync |= 1;\n                    h->recovery_frame = -1;\n                }\n\n                h->sync |= !!h->cur_pic_ptr->f.key_frame;\n                h->sync |= 3*!!(avctx->flags2 & CODEC_FLAG2_SHOW_ALL);\n                h->cur_pic_ptr->sync |= h->sync;\n\n                if (h->current_slice == 1) {\n                    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS))\n                        decode_postinit(h, nal_index >= nals_needed);\n\n                    if (h->avctx->hwaccel &&\n                        (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0)\n                        return ret;\n                    if (CONFIG_H264_VDPAU_DECODER &&\n                        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n                        ff_vdpau_h264_picture_start(h);\n                }\n\n                if (hx->redundant_pic_count == 0 &&\n                    (avctx->skip_frame < AVDISCARD_NONREF ||\n                     hx->nal_ref_idc) &&\n                    (avctx->skip_frame < AVDISCARD_BIDIR  ||\n                     hx->slice_type_nos != AV_PICTURE_TYPE_B) &&\n                    (avctx->skip_frame < AVDISCARD_NONKEY ||\n                     hx->slice_type_nos == AV_PICTURE_TYPE_I) &&\n                    avctx->skip_frame < AVDISCARD_ALL) {\n                    if (avctx->hwaccel) {\n                        ret = avctx->hwaccel->decode_slice(avctx,\n                                                           &buf[buf_index - consumed],\n                                                           consumed);\n                        if (ret < 0)\n                            return ret;\n                    } else if (CONFIG_H264_VDPAU_DECODER &&\n                               h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) {\n                        ff_vdpau_add_data_chunk(h->cur_pic_ptr->f.data[0],\n                                                start_code,\n                                                sizeof(start_code));\n                        ff_vdpau_add_data_chunk(h->cur_pic_ptr->f.data[0],\n                                                &buf[buf_index - consumed],\n                                                consumed);\n                    } else\n                        context_count++;\n                }\n                break;\n            case NAL_DPA:\n                init_get_bits(&hx->gb, ptr, bit_length);\n                hx->intra_gb_ptr =\n                hx->inter_gb_ptr = NULL;\n\n                if ((err = decode_slice_header(hx, h)) < 0)\n                    break;\n\n                hx->data_partitioning = 1;\n                break;\n            case NAL_DPB:\n                init_get_bits(&hx->intra_gb, ptr, bit_length);\n                hx->intra_gb_ptr = &hx->intra_gb;\n                break;\n            case NAL_DPC:\n                init_get_bits(&hx->inter_gb, ptr, bit_length);\n                hx->inter_gb_ptr = &hx->inter_gb;\n\n                av_log(h->avctx, AV_LOG_ERROR, \"Partitioned H.264 support is incomplete\\n\");\n                break;\n\n                if (hx->redundant_pic_count == 0 &&\n                    hx->intra_gb_ptr &&\n                    hx->data_partitioning &&\n                    h->cur_pic_ptr && h->context_initialized &&\n                    (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) &&\n                    (avctx->skip_frame < AVDISCARD_BIDIR  ||\n                     hx->slice_type_nos != AV_PICTURE_TYPE_B) &&\n                    (avctx->skip_frame < AVDISCARD_NONKEY ||\n                     hx->slice_type_nos == AV_PICTURE_TYPE_I) &&\n                    avctx->skip_frame < AVDISCARD_ALL)\n                    context_count++;\n                break;\n            case NAL_SEI:\n                init_get_bits(&h->gb, ptr, bit_length);\n                ff_h264_decode_sei(h);\n                break;\n            case NAL_SPS:\n                init_get_bits(&h->gb, ptr, bit_length);\n                if (ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? nalsize : 1)) {\n                    av_log(h->avctx, AV_LOG_DEBUG,\n                           \"SPS decoding failure, trying again with the complete NAL\\n\");\n                    if (h->is_avc)\n                        av_assert0(next_avc - buf_index + consumed == nalsize);\n                    if ((next_avc - buf_index + consumed - 1) >= INT_MAX/8)\n                        break;\n                    init_get_bits(&h->gb, &buf[buf_index + 1 - consumed],\n                                  8*(next_avc - buf_index + consumed - 1));\n                    ff_h264_decode_seq_parameter_set(h);\n                }\n\n                break;\n            case NAL_PPS:\n                init_get_bits(&h->gb, ptr, bit_length);\n                ff_h264_decode_picture_parameter_set(h, bit_length);\n                break;\n            case NAL_AUD:\n            case NAL_END_SEQUENCE:\n            case NAL_END_STREAM:\n            case NAL_FILLER_DATA:\n            case NAL_SPS_EXT:\n            case NAL_AUXILIARY_SLICE:\n                break;\n            case NAL_FF_IGNORE:\n                break;\n            default:\n                av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\",\n                       hx->nal_unit_type, bit_length);\n            }\n\n            if (context_count == h->max_contexts) {\n                execute_decode_slices(h, context_count);\n                context_count = 0;\n            }\n\n            if (err < 0)\n                av_log(h->avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n            else if (err == 1) {\n                /* Slice could not be decoded in parallel mode, copy down\n                 * NAL unit stuff to context 0 and restart. Note that\n                 * rbsp_buffer is not transferred, but since we no longer\n                 * run in parallel mode this should not be an issue. */\n                h->nal_unit_type = hx->nal_unit_type;\n                h->nal_ref_idc   = hx->nal_ref_idc;\n                hx               = h;\n                goto again;\n            }\n        }\n    }\n    if (context_count)\n        execute_decode_slices(h, context_count);\n\nend:\n    /* clean up */\n    if (h->cur_pic_ptr && !h->droppable) {\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    }\n\n    return (ret < 0) ? ret : buf_index;\n}\n\n/**\n * Return the number of bytes consumed for building the current frame.\n */\nstatic int get_consumed_bytes(int pos, int buf_size)\n{\n    if (pos == 0)\n        pos = 1;          // avoid infinite loops (i doubt that is needed but ...)\n    if (pos + 10 > buf_size)\n        pos = buf_size;                   // oops ;)\n\n    return pos;\n}\n\nstatic int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)\n{\n    AVFrame *src = &srcp->f;\n    int i;\n    int ret = av_frame_ref(dst, src);\n    if (ret < 0)\n        return ret;\n\n    av_dict_set(&dst->metadata, \"stereo_mode\", ff_h264_sei_stereo_mode(h), 0);\n\n    if (!srcp->crop)\n        return 0;\n\n    for (i = 0; i < 3; i++) {\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +\n                      (srcp->crop_top  >> vshift) * dst->linesize[i];\n        dst->data[i] += off;\n    }\n    return 0;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    H264Context *h     = avctx->priv_data;\n    AVFrame *pict      = data;\n    int buf_index      = 0;\n    Picture *out;\n    int i, out_idx;\n    int ret;\n\n    h->flags = avctx->flags;\n\n    /* end of stream, output what is still in the buffers */\n    if (buf_size == 0) {\n out:\n\n        h->cur_pic_ptr = NULL;\n        h->first_field = 0;\n\n        // FIXME factorize this with the output code below\n        out     = h->delayed_pic[0];\n        out_idx = 0;\n        for (i = 1;\n             h->delayed_pic[i] &&\n             !h->delayed_pic[i]->f.key_frame &&\n             !h->delayed_pic[i]->mmco_reset;\n             i++)\n            if (h->delayed_pic[i]->poc < out->poc) {\n                out     = h->delayed_pic[i];\n                out_idx = i;\n            }\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n        if (out) {\n            out->reference &= ~DELAYED_PIC_REF;\n            ret = output_frame(h, pict, out);\n            if (ret < 0)\n                return ret;\n            *got_frame = 1;\n        }\n\n        return buf_index;\n    }\n    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n        int cnt= buf[5]&0x1f;\n        const uint8_t *p= buf+6;\n        while(cnt--){\n            int nalsize= AV_RB16(p) + 2;\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)\n                goto not_extra;\n            p += nalsize;\n        }\n        cnt = *(p++);\n        if(!cnt)\n            goto not_extra;\n        while(cnt--){\n            int nalsize= AV_RB16(p) + 2;\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)\n                goto not_extra;\n            p += nalsize;\n        }\n\n        return ff_h264_decode_extradata(h, buf, buf_size);\n    }\nnot_extra:\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n    if (buf_index < 0)\n        return AVERROR_INVALIDDATA;\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n        av_assert0(buf_index <= buf_size);\n        goto out;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n            return buf_size;\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n            decode_postinit(h, 1);\n\n        field_end(h, 0);\n\n        /* Wait for second field. */\n        *got_frame = 0;\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n            ret = output_frame(h, pict, h->next_output_pic);\n            if (ret < 0)\n                return ret;\n            *got_frame = 1;\n            if (CONFIG_MPEGVIDEO) {\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n                                    &h->low_delay,\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n            }\n        }\n    }\n\n    assert(pict->data[0] || !*got_frame);\n\n    return get_consumed_bytes(buf_index, buf_size);\n}\n\nav_cold void ff_h264_free_context(H264Context *h)\n{\n    int i;\n\n    free_tables(h, 1); // FIXME cleanup init stuff perhaps\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n        av_freep(h->sps_buffers + i);\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n        av_freep(h->pps_buffers + i);\n}\n\nstatic av_cold int h264_decode_end(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n\n    ff_h264_remove_all_refs(h);\n    ff_h264_free_context(h);\n\n    unref_picture(h, &h->cur_pic);\n\n    return 0;\n}\n\nstatic const AVProfile profiles[] = {\n    { FF_PROFILE_H264_BASELINE,             \"Baseline\"              },\n    { FF_PROFILE_H264_CONSTRAINED_BASELINE, \"Constrained Baseline\"  },\n    { FF_PROFILE_H264_MAIN,                 \"Main\"                  },\n    { FF_PROFILE_H264_EXTENDED,             \"Extended\"              },\n    { FF_PROFILE_H264_HIGH,                 \"High\"                  },\n    { FF_PROFILE_H264_HIGH_10,              \"High 10\"               },\n    { FF_PROFILE_H264_HIGH_10_INTRA,        \"High 10 Intra\"         },\n    { FF_PROFILE_H264_HIGH_422,             \"High 4:2:2\"            },\n    { FF_PROFILE_H264_HIGH_422_INTRA,       \"High 4:2:2 Intra\"      },\n    { FF_PROFILE_H264_HIGH_444,             \"High 4:4:4\"            },\n    { FF_PROFILE_H264_HIGH_444_PREDICTIVE,  \"High 4:4:4 Predictive\" },\n    { FF_PROFILE_H264_HIGH_444_INTRA,       \"High 4:4:4 Intra\"      },\n    { FF_PROFILE_H264_CAVLC_444,            \"CAVLC 4:4:4\"           },\n    { FF_PROFILE_UNKNOWN },\n};\n\nstatic const AVOption h264_options[] = {\n    {\"is_avc\", \"is avc\", offsetof(H264Context, is_avc), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},\n    {\"nal_length_size\", \"nal_length_size\", offsetof(H264Context, nal_length_size), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 4, 0},\n    {NULL}\n};\n\nstatic const AVClass h264_class = {\n    .class_name = \"H264 Decoder\",\n    .item_name  = av_default_item_name,\n    .option     = h264_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nstatic const AVClass h264_vdpau_class = {\n    .class_name = \"H264 VDPAU Decoder\",\n    .item_name  = av_default_item_name,\n    .option     = h264_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_h264_decoder = {\n    .name                  = \"h264\",\n    .long_name             = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\"),\n    .type                  = AVMEDIA_TYPE_VIDEO,\n    .id                    = AV_CODEC_ID_H264,\n    .priv_data_size        = sizeof(H264Context),\n    .init                  = ff_h264_decode_init,\n    .close                 = h264_decode_end,\n    .decode                = decode_frame,\n    .capabilities          = /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 |\n                             CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS |\n                             CODEC_CAP_FRAME_THREADS,\n    .flush                 = flush_dpb,\n    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(decode_update_thread_context),\n    .profiles              = NULL_IF_CONFIG_SMALL(profiles),\n    .priv_class            = &h264_class,\n};\n\n#if CONFIG_H264_VDPAU_DECODER\nAVCodec ff_h264_vdpau_decoder = {\n    .name           = \"h264_vdpau\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (VDPAU acceleration)\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_H264,\n    .priv_data_size = sizeof(H264Context),\n    .init           = ff_h264_decode_init,\n    .close          = h264_decode_end,\n    .decode         = decode_frame,\n    .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,\n    .flush          = flush_dpb,\n    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_VDPAU_H264,\n                                                     AV_PIX_FMT_NONE},\n    .profiles       = NULL_IF_CONFIG_SMALL(profiles),\n    .priv_class     = &h264_vdpau_class,\n};\n#endif\n"], "buggy_code_start_loc": [3624], "buggy_code_end_loc": [3644], "fixing_code_start_loc": [3624], "fixing_code_end_loc": [3644], "type": "NVD-CWE-Other", "message": "The decode_slice_header function in libavcodec/h264.c in FFmpeg before 2.1 incorrectly relies on a certain droppable field, which allows remote attackers to cause a denial of service (deadlock) or possibly have unspecified other impact via crafted H.264 data.", "other": {"cve": {"id": "CVE-2013-7008", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:47.690", "lastModified": "2016-12-03T03:00:33.737", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The decode_slice_header function in libavcodec/h264.c in FFmpeg before 2.1 incorrectly relies on a certain droppable field, which allows remote attackers to cause a denial of service (deadlock) or possibly have unspecified other impact via crafted H.264 data."}, {"lang": "es", "value": "La funci\u00f3n decode_slice_header en libavcodec/h264.c en FFmpeg anteriores a 2.1 depende incorrectamente de cierto campo deshechable, lo que permite a atacantes remotos causar una denegaci\u00f3n de servico (deadlock) o posiblemente tener otro impacto no especificado a trav\u00e9s de datos H264 manipulados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/29ffeef5e73b8f41ff3a3f2242d356759c66f91f", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}, {"url": "https://trac.ffmpeg.org/ticket/2927", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/29ffeef5e73b8f41ff3a3f2242d356759c66f91f"}}