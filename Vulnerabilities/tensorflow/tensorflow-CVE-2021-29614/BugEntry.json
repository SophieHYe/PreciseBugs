{"buggy_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <algorithm>\n#include <cmath>\n\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n\nnamespace tensorflow {\n\ntemplate <typename T>\nclass DecodePaddedRawOp : public OpKernel {\n public:\n  explicit DecodePaddedRawOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"out_type\", &out_type_));\n\n    const bool host_is_little_endian = port::kLittleEndian;\n    bool data_is_little_endian;\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"little_endian\", &data_is_little_endian));\n    convert_data_endianness_ = host_is_little_endian != data_is_little_endian;\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n\n    int width = fixed_length / sizeof(T);\n\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n\n    if (flat_in.size() == 0) {  // Empty input\n      return;\n    }\n\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n\n    // Forcibly clear memory - we're going to copy variable length strings in,\n    // and need to ensure that if we don't write to byte N when we copy, that\n    // we're not getting random data.\n    memset(out_data, 0, fixed_length * flat_in.size());\n\n    // If the data is already in the host's byte order, or if the width of the\n    // output type is a single byte (meaning the ordering doesn't matter), we\n    // can copy the memory directly.\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      // Otherwise, the data is not in the host's byte order, and rather than a\n      // direct copy, we need to reverse the byte ordering of each element.\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }\n\n private:\n  // True if the endianness of the data and the endianness of the host are\n  // different, and the data needs conversion.\n  bool convert_data_endianness_;\n\n  // Data type of the output tensor.\n  DataType out_type_;\n};\n\n#define REGISTER(type)                                           \\\n  REGISTER_KERNEL_BUILDER(Name(\"DecodePaddedRaw\")                \\\n                              .Device(DEVICE_CPU)                \\\n                              .TypeConstraint<type>(\"out_type\"), \\\n                          DecodePaddedRawOp<type>)\n\nREGISTER(float);\nREGISTER(double);\nREGISTER(int32);\nREGISTER(uint16);\nREGISTER(uint8);\nREGISTER(int16);\nREGISTER(int8);\nREGISTER(int64);\n\n#undef REGISTER\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Parsing Ops.\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import gen_parsing_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import parsing_config\n# go/tf-wildcard-import\n# pylint: disable=wildcard-import,undefined-variable\nfrom tensorflow.python.ops.gen_parsing_ops import *\n# pylint: enable=wildcard-import,undefined-variable\nfrom tensorflow.python.util import deprecation\nfrom tensorflow.python.util import dispatch\nfrom tensorflow.python.util.tf_export import tf_export\n\n\nops.NotDifferentiable(\"DecodeRaw\")\nops.NotDifferentiable(\"DecodePaddedRaw\")\nops.NotDifferentiable(\"ParseTensor\")\nops.NotDifferentiable(\"SerializeTensor\")\nops.NotDifferentiable(\"StringToNumber\")\n\n\nVarLenFeature = parsing_config.VarLenFeature\nRaggedFeature = parsing_config.RaggedFeature\nSparseFeature = parsing_config.SparseFeature\nFixedLenFeature = parsing_config.FixedLenFeature\nFixedLenSequenceFeature = parsing_config.FixedLenSequenceFeature\n# pylint: disable=protected-access\n_ParseOpParams = parsing_config._ParseOpParams\n_construct_tensors_for_composite_features = (\n    parsing_config._construct_tensors_for_composite_features)\n# pylint: enable=protected-access\n\n\n# TODO(b/122887740) Switch files that use this private symbol to use new name.\n_construct_sparse_tensors_for_sparse_features = \\\n    _construct_tensors_for_composite_features\n\n\ndef _prepend_none_dimension(features):\n  \"\"\"Returns a copy of features with adjusted FixedLenSequenceFeature shapes.\"\"\"\n  if features:\n    modified_features = dict(features)  # Create a copy to modify\n    for key, feature in features.items():\n      if isinstance(feature, FixedLenSequenceFeature):\n        if not feature.allow_missing:\n          raise ValueError(\"Unsupported: FixedLenSequenceFeature requires \"\n                           \"allow_missing to be True.\")\n        modified_features[key] = FixedLenSequenceFeature(\n            [None] + list(feature.shape),\n            feature.dtype,\n            feature.allow_missing,\n            feature.default_value)\n    return modified_features\n  else:\n    return features\n\n\n@tf_export(\"io.parse_example\", v1=[])\n@dispatch.add_dispatch_support\ndef parse_example_v2(serialized, features, example_names=None, name=None):\n  # pylint: disable=line-too-long\n  \"\"\"Parses `Example` protos into a `dict` of tensors.\n\n  Parses a number of serialized [`Example`](https://www.tensorflow.org/code/tensorflow/core/example/example.proto)\n  protos given in `serialized`. We refer to `serialized` as a batch with\n  `batch_size` many entries of individual `Example` protos.\n\n  `example_names` may contain descriptive names for the corresponding serialized\n  protos. These may be useful for debugging purposes, but they have no effect on\n  the output. If not `None`, `example_names` must be the same length as\n  `serialized`.\n\n  This op parses serialized examples into a dictionary mapping keys to `Tensor`\n  `SparseTensor`, and `RaggedTensor` objects. `features` is a dict from keys to\n  `VarLenFeature`, `SparseFeature`, `RaggedFeature`, and `FixedLenFeature`\n  objects. Each `VarLenFeature` and `SparseFeature` is mapped to a\n  `SparseTensor`; each `FixedLenFeature` is mapped to a `Tensor`; and each\n  `RaggedFeature` is mapped to a `RaggedTensor`.\n\n  Each `VarLenFeature` maps to a `SparseTensor` of the specified type\n  representing a ragged matrix. Its indices are `[batch, index]` where `batch`\n  identifies the example in `serialized`, and `index` is the value's index in\n  the list of values associated with that feature and example.\n\n  Each `SparseFeature` maps to a `SparseTensor` of the specified type\n  representing a Tensor of `dense_shape` `[batch_size] + SparseFeature.size`.\n  Its `values` come from the feature in the examples with key `value_key`.\n  A `values[i]` comes from a position `k` in the feature of an example at batch\n  entry `batch`. This positional information is recorded in `indices[i]` as\n  `[batch, index_0, index_1, ...]` where `index_j` is the `k-th` value of\n  the feature in the example at with key `SparseFeature.index_key[j]`.\n  In other words, we split the indices (except the first index indicating the\n  batch entry) of a `SparseTensor` by dimension into different features of the\n  `Example`. Due to its complexity a `VarLenFeature` should be preferred over a\n  `SparseFeature` whenever possible.\n\n  Each `FixedLenFeature` `df` maps to a `Tensor` of the specified type (or\n  `tf.float32` if not specified) and shape `(serialized.size(),) + df.shape`.\n\n  `FixedLenFeature` entries with a `default_value` are optional. With no default\n  value, we will fail if that `Feature` is missing from any example in\n  `serialized`.\n\n  Each `FixedLenSequenceFeature` `df` maps to a `Tensor` of the specified type\n  (or `tf.float32` if not specified) and shape\n  `(serialized.size(), None) + df.shape`.\n  All examples in `serialized` will be padded with `default_value` along the\n  second dimension.\n\n  Each `RaggedFeature` maps to a `RaggedTensor` of the specified type.  It\n  is formed by stacking the `RaggedTensor` for each example, where the\n  `RaggedTensor` for each individual example is constructed using the tensors\n  specified by `RaggedTensor.values_key` and `RaggedTensor.partition`.  See\n  the `tf.io.RaggedFeature` documentation for details and examples.\n\n  Examples:\n\n  For example, if one expects a `tf.float32` `VarLenFeature` `ft` and three\n  serialized `Example`s are provided:\n\n  ```\n  serialized = [\n    features\n      { feature { key: \"ft\" value { float_list { value: [1.0, 2.0] } } } },\n    features\n      { feature []},\n    features\n      { feature { key: \"ft\" value { float_list { value: [3.0] } } }\n  ]\n  ```\n\n  then the output will look like:\n\n  ```python\n  {\"ft\": SparseTensor(indices=[[0, 0], [0, 1], [2, 0]],\n                      values=[1.0, 2.0, 3.0],\n                      dense_shape=(3, 2)) }\n  ```\n\n  If instead a `FixedLenSequenceFeature` with `default_value = -1.0` and\n  `shape=[]` is used then the output will look like:\n\n  ```python\n  {\"ft\": [[1.0, 2.0], [3.0, -1.0]]}\n  ```\n\n  Given two `Example` input protos in `serialized`:\n\n  ```\n  [\n    features {\n      feature { key: \"kw\" value { bytes_list { value: [ \"knit\", \"big\" ] } } }\n      feature { key: \"gps\" value { float_list { value: [] } } }\n    },\n    features {\n      feature { key: \"kw\" value { bytes_list { value: [ \"emmy\" ] } } }\n      feature { key: \"dank\" value { int64_list { value: [ 42 ] } } }\n      feature { key: \"gps\" value { } }\n    }\n  ]\n  ```\n\n  And arguments\n\n  ```\n  example_names: [\"input0\", \"input1\"],\n  features: {\n      \"kw\": VarLenFeature(tf.string),\n      \"dank\": VarLenFeature(tf.int64),\n      \"gps\": VarLenFeature(tf.float32),\n  }\n  ```\n\n  Then the output is a dictionary:\n\n  ```python\n  {\n    \"kw\": SparseTensor(\n        indices=[[0, 0], [0, 1], [1, 0]],\n        values=[\"knit\", \"big\", \"emmy\"]\n        dense_shape=[2, 2]),\n    \"dank\": SparseTensor(\n        indices=[[1, 0]],\n        values=[42],\n        dense_shape=[2, 1]),\n    \"gps\": SparseTensor(\n        indices=[],\n        values=[],\n        dense_shape=[2, 0]),\n  }\n  ```\n\n  For dense results in two serialized `Example`s:\n\n  ```\n  [\n    features {\n      feature { key: \"age\" value { int64_list { value: [ 0 ] } } }\n      feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n     },\n     features {\n      feature { key: \"age\" value { int64_list { value: [] } } }\n      feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n    }\n  ]\n  ```\n\n  We can use arguments:\n\n  ```\n  example_names: [\"input0\", \"input1\"],\n  features: {\n      \"age\": FixedLenFeature([], dtype=tf.int64, default_value=-1),\n      \"gender\": FixedLenFeature([], dtype=tf.string),\n  }\n  ```\n\n  And the expected output is:\n\n  ```python\n  {\n    \"age\": [[0], [-1]],\n    \"gender\": [[\"f\"], [\"f\"]],\n  }\n  ```\n\n  An alternative to `VarLenFeature` to obtain a `SparseTensor` is\n  `SparseFeature`. For example, given two `Example` input protos in\n  `serialized`:\n\n  ```\n  [\n    features {\n      feature { key: \"val\" value { float_list { value: [ 0.5, -1.0 ] } } }\n      feature { key: \"ix\" value { int64_list { value: [ 3, 20 ] } } }\n    },\n    features {\n      feature { key: \"val\" value { float_list { value: [ 0.0 ] } } }\n      feature { key: \"ix\" value { int64_list { value: [ 42 ] } } }\n    }\n  ]\n  ```\n\n  And arguments\n\n  ```\n  example_names: [\"input0\", \"input1\"],\n  features: {\n      \"sparse\": SparseFeature(\n          index_key=\"ix\", value_key=\"val\", dtype=tf.float32, size=100),\n  }\n  ```\n\n  Then the output is a dictionary:\n\n  ```python\n  {\n    \"sparse\": SparseTensor(\n        indices=[[0, 3], [0, 20], [1, 42]],\n        values=[0.5, -1.0, 0.0]\n        dense_shape=[2, 100]),\n  }\n  ```\n\n  See the `tf.io.RaggedFeature` documentation for examples showing how\n  `RaggedFeature` can be used to obtain `RaggedTensor`s.\n\n  Args:\n    serialized: A vector (1-D Tensor) of strings, a batch of binary\n      serialized `Example` protos.\n    features: A `dict` mapping feature keys to `FixedLenFeature`,\n      `VarLenFeature`, `SparseFeature`, and `RaggedFeature` values.\n    example_names: A vector (1-D Tensor) of strings (optional), the names of\n      the serialized protos in the batch.\n    name: A name for this operation (optional).\n\n  Returns:\n    A `dict` mapping feature keys to `Tensor`, `SparseTensor`, and\n    `RaggedTensor` values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  if not features:\n    raise ValueError(\"Missing: features was %s.\" % features)\n  features = _prepend_none_dimension(features)\n  params = _ParseOpParams.from_features(features, [\n      VarLenFeature, SparseFeature, FixedLenFeature, FixedLenSequenceFeature,\n      RaggedFeature\n  ])\n\n  outputs = _parse_example_raw(serialized, example_names, params, name=name)\n  return _construct_tensors_for_composite_features(features, outputs)\n\n\n@tf_export(v1=[\"io.parse_example\", \"parse_example\"])\n@dispatch.add_dispatch_support\ndef parse_example(serialized, features, name=None, example_names=None):\n  return parse_example_v2(serialized, features, example_names, name)\n\n\nparse_example.__doc__ = parse_example_v2.__doc__\n\n\ndef _parse_example_raw(serialized, names, params, name):\n  \"\"\"Parses `Example` protos.\n\n  Args:\n    serialized: A vector (1-D Tensor) of strings, a batch of binary\n      serialized `Example` protos.\n    names: A vector (1-D Tensor) of strings (optional), the names of\n      the serialized protos.\n    params: A `ParseOpParams` containing the parameters for the parse op.\n    name: A name for this operation (optional).\n\n  Returns:\n    A `dict` mapping keys to `Tensor`s and `SparseTensor`s and `RaggedTensor`s.\n\n  \"\"\"\n  if params.num_features == 0:\n    raise ValueError(\"Must provide at least one feature key\")\n  with ops.name_scope(name, \"ParseExample\", [serialized, names]):\n    names = [] if names is None else names\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    if params.ragged_keys and serialized.shape.ndims is None:\n      raise ValueError(\"serialized must have statically-known rank to \"\n                       \"parse ragged features.\")\n    outputs = gen_parsing_ops.parse_example_v2(\n        serialized=serialized,\n        names=names,\n        sparse_keys=params.sparse_keys,\n        dense_keys=params.dense_keys,\n        ragged_keys=params.ragged_keys,\n        dense_defaults=params.dense_defaults_vec,\n        num_sparse=len(params.sparse_keys),\n        sparse_types=params.sparse_types,\n        ragged_value_types=params.ragged_value_types,\n        ragged_split_types=params.ragged_split_types,\n        dense_shapes=params.dense_shapes_as_proto,\n        name=name)\n    (sparse_indices, sparse_values, sparse_shapes, dense_values,\n     ragged_values, ragged_row_splits) = outputs\n    # pylint: disable=protected-access\n    ragged_tensors = parsing_config._build_ragged_tensors(\n        serialized.shape, ragged_values, ragged_row_splits)\n\n    sparse_tensors = [\n        sparse_tensor.SparseTensor(ix, val, shape) for (ix, val, shape)\n        in zip(sparse_indices, sparse_values, sparse_shapes)]\n\n    return dict(\n        zip(params.sparse_keys + params.dense_keys + params.ragged_keys,\n            sparse_tensors + dense_values + ragged_tensors))\n\n\n@tf_export(v1=[\"io.parse_single_example\", \"parse_single_example\"])\n@dispatch.add_dispatch_support\ndef parse_single_example(serialized, features, name=None, example_names=None):\n  \"\"\"Parses a single `Example` proto.\n\n  Similar to `parse_example`, except:\n\n  For dense tensors, the returned `Tensor` is identical to the output of\n  `parse_example`, except there is no batch dimension, the output shape is the\n  same as the shape given in `dense_shape`.\n\n  For `SparseTensor`s, the first (batch) column of the indices matrix is removed\n  (the indices matrix is a column vector), the values vector is unchanged, and\n  the first (`batch_size`) entry of the shape vector is removed (it is now a\n  single element vector).\n\n  One might see performance advantages by batching `Example` protos with\n  `parse_example` instead of using this function directly.\n\n  Args:\n    serialized: A scalar string Tensor, a single serialized Example.\n    features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` values.\n    name: A name for this operation (optional).\n    example_names: (Optional) A scalar string Tensor, the associated name.\n\n  Returns:\n    A `dict` mapping feature keys to `Tensor` and `SparseTensor` values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  return parse_single_example_v2(serialized, features, example_names, name)\n\n\n@tf_export(\"io.parse_single_example\", v1=[])\n@dispatch.add_dispatch_support\ndef parse_single_example_v2(\n    serialized, features, example_names=None, name=None\n    ):\n  \"\"\"Parses a single `Example` proto.\n\n  Similar to `parse_example`, except:\n\n  For dense tensors, the returned `Tensor` is identical to the output of\n  `parse_example`, except there is no batch dimension, the output shape is the\n  same as the shape given in `dense_shape`.\n\n  For `SparseTensor`s, the first (batch) column of the indices matrix is removed\n  (the indices matrix is a column vector), the values vector is unchanged, and\n  the first (`batch_size`) entry of the shape vector is removed (it is now a\n  single element vector).\n\n  One might see performance advantages by batching `Example` protos with\n  `parse_example` instead of using this function directly.\n\n  Args:\n    serialized: A scalar string Tensor, a single serialized Example.\n    features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` values.\n    example_names: (Optional) A scalar string Tensor, the associated name.\n    name: A name for this operation (optional).\n\n  Returns:\n    A `dict` mapping feature keys to `Tensor` and `SparseTensor` values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  if not features:\n    raise ValueError(\"Missing features.\")\n  with ops.name_scope(name, \"ParseSingleExample\", [serialized, example_names]):\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    serialized = _assert_scalar(serialized, \"serialized\")\n    return parse_example_v2(serialized, features, example_names, name)\n\n\n@tf_export(\"io.parse_sequence_example\")\n@dispatch.add_dispatch_support\ndef parse_sequence_example(serialized,\n                           context_features=None,\n                           sequence_features=None,\n                           example_names=None,\n                           name=None):\n  # pylint: disable=line-too-long\n  \"\"\"Parses a batch of `SequenceExample` protos.\n\n  Parses a vector of serialized\n  [`SequenceExample`](https://www.tensorflow.org/code/tensorflow/core/example/example.proto)\n  protos given in `serialized`.\n\n  This op parses serialized sequence examples into a tuple of dictionaries,\n  each mapping keys to `Tensor` and `SparseTensor` objects.\n  The first dictionary contains mappings for keys appearing in\n  `context_features`, and the second dictionary contains mappings for keys\n  appearing in `sequence_features`.\n\n  At least one of `context_features` and `sequence_features` must be provided\n  and non-empty.\n\n  The `context_features` keys are associated with a `SequenceExample` as a\n  whole, independent of time / frame.  In contrast, the `sequence_features` keys\n  provide a way to access variable-length data within the `FeatureList` section\n  of the `SequenceExample` proto.  While the shapes of `context_features` values\n  are fixed with respect to frame, the frame dimension (the first dimension)\n  of `sequence_features` values may vary between `SequenceExample` protos,\n  and even between `feature_list` keys within the same `SequenceExample`.\n\n  `context_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenFeature`  objects. Each `VarLenFeature` is mapped to a\n  `SparseTensor`; each `RaggedFeature` is  mapped to a `RaggedTensor`; and each\n  `FixedLenFeature` is mapped to a `Tensor`, of the specified type, shape, and\n  default value.\n\n  `sequence_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenSequenceFeature` objects. Each `VarLenFeature` is mapped to a\n  `SparseTensor`; each `RaggedFeature` is mapped to a `RaggedTensor; and\n  each `FixedLenSequenceFeature` is mapped to a `Tensor`, each of the specified\n  type. The shape will be `(B,T,) + df.dense_shape` for\n  `FixedLenSequenceFeature` `df`, where `B` is the batch size, and `T` is the\n  length of the associated `FeatureList` in the `SequenceExample`. For instance,\n  `FixedLenSequenceFeature([])` yields a scalar 2-D `Tensor` of static shape\n  `[None, None]` and dynamic shape `[B, T]`, while\n  `FixedLenSequenceFeature([k])` (for `int k >= 1`) yields a 3-D matrix `Tensor`\n  of static shape `[None, None, k]` and dynamic shape `[B, T, k]`.\n\n  Like the input, the resulting output tensors have a batch dimension. This\n  means that the original per-example shapes of `VarLenFeature`s and\n  `FixedLenSequenceFeature`s can be lost. To handle that situation, this op also\n  provides dicts of shape tensors as part of the output. There is one dict for\n  the context features, and one for the feature_list features. Context features\n  of type `FixedLenFeature`s will not be present, since their shapes are already\n  known by the caller. In situations where the input 'FixedLenFeature`s are of\n  different lengths across examples, the shorter examples will be padded with\n  default datatype values: 0 for numeric types, and the empty string for string\n  types.\n\n  Each `SparseTensor` corresponding to `sequence_features` represents a ragged\n  vector.  Its indices are `[time, index]`, where `time` is the `FeatureList`\n  entry and `index` is the value's index in the list of values associated with\n  that time.\n\n  `FixedLenFeature` entries with a `default_value` and `FixedLenSequenceFeature`\n  entries with `allow_missing=True` are optional; otherwise, we will fail if\n  that `Feature` or `FeatureList` is missing from any example in `serialized`.\n\n  `example_name` may contain a descriptive name for the corresponding serialized\n  proto. This may be useful for debugging purposes, but it has no effect on the\n  output. If not `None`, `example_name` must be a scalar.\n\n  Args:\n    serialized: A vector (1-D Tensor) of type string containing binary\n      serialized `SequenceExample` protos.\n    context_features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` or `RaggedFeature` values. These features are associated\n      with a `SequenceExample` as a whole.\n    sequence_features: A `dict` mapping feature keys to\n      `FixedLenSequenceFeature` or `VarLenFeature` or `RaggedFeature` values.\n      These features are associated with data within the `FeatureList` section\n      of the `SequenceExample` proto.\n    example_names: A vector (1-D Tensor) of strings (optional), the name of the\n      serialized protos.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of three `dict`s, each mapping keys to `Tensor`s,\n    `SparseTensor`s, and `RaggedTensor`. The first dict contains the context\n    key/values, the second dict contains the feature_list key/values, and the\n    final dict contains the lengths of any dense feature_list features.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  if not (context_features or sequence_features):\n    raise ValueError(\"Missing features.\")\n  context_params = _ParseOpParams.from_features(\n      context_features, [VarLenFeature, FixedLenFeature, RaggedFeature])\n  feature_list_params = _ParseOpParams.from_features(\n      sequence_features,\n      [VarLenFeature, FixedLenSequenceFeature, RaggedFeature])\n\n  with ops.name_scope(name, \"ParseSequenceExample\",\n                      [serialized, example_names]):\n    outputs = _parse_sequence_example_raw(serialized, example_names,\n                                          context_params, feature_list_params,\n                                          name)\n    context_output, feature_list_output, feature_list_lengths = outputs\n\n    if context_params.ragged_keys:\n      context_output = _construct_tensors_for_composite_features(\n          context_features, context_output)\n    if feature_list_params.ragged_keys:\n      feature_list_output = _construct_tensors_for_composite_features(\n          sequence_features, feature_list_output)\n\n    return context_output, feature_list_output, feature_list_lengths\n\n\ndef _parse_sequence_example_raw(serialized,\n                                debug_name,\n                                context,\n                                feature_list,\n                                name=None):\n  \"\"\"Parses a vector of `SequenceExample` protos.\n\n  Args:\n    serialized: A vector (1-D Tensor) of type string, containing binary\n      serialized `SequenceExample` protos.\n    debug_name: A vector (1-D Tensor) of strings (optional), the names of the\n      serialized protos.\n    context: A `ParseOpParams` containing the parameters for the parse\n      op for the context features.\n    feature_list: A `ParseOpParams` containing the parameters for the\n      parse op for the feature_list features.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of three `dict`s, each mapping keys to `Tensor`s, `SparseTensor`s,\n    and `RaggedTensor`s. The first dict contains the context key/values, the\n    second dict contains the feature_list key/values, and the final dict\n    contains the lengths of any dense feature_list features.\n\n  Raises:\n    TypeError: if feature_list.dense_defaults is not either None or a dict.\n  \"\"\"\n  if context.num_features + feature_list.num_features == 0:\n    raise ValueError(\"Must provide at least one feature key\")\n  with ops.name_scope(name, \"ParseSequenceExample\", [serialized]):\n    debug_name = [] if debug_name is None else debug_name\n\n    # Internal\n    feature_list_dense_missing_assumed_empty = []\n    for k, v in feature_list.dense_defaults.items():\n      if v is not None:\n        raise ValueError(\"Value feature_list.dense_defaults[%s] must be None\" %\n                         k)\n      feature_list_dense_missing_assumed_empty.append(k)\n\n    has_ragged = context.ragged_keys or feature_list.ragged_keys\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    if has_ragged and serialized.shape.ndims is None:\n      raise ValueError(\"serialized must have statically-known rank to \"\n                       \"parse ragged features.\")\n    feature_list_dense_missing_assumed_empty_vector = [\n        key in feature_list_dense_missing_assumed_empty\n        for key in feature_list.dense_keys\n    ]\n    outputs = gen_parsing_ops.parse_sequence_example_v2(\n        # Inputs\n        serialized=serialized,\n        debug_name=debug_name,\n        context_sparse_keys=context.sparse_keys,\n        context_dense_keys=context.dense_keys,\n        context_ragged_keys=context.ragged_keys,\n        feature_list_sparse_keys=feature_list.sparse_keys,\n        feature_list_dense_keys=feature_list.dense_keys,\n        feature_list_ragged_keys=feature_list.ragged_keys,\n        feature_list_dense_missing_assumed_empty=(\n            feature_list_dense_missing_assumed_empty_vector),\n        context_dense_defaults=context.dense_defaults_vec,\n        # Attrs\n        Ncontext_sparse=len(context.sparse_keys),\n        Nfeature_list_sparse=len(feature_list.sparse_keys),\n        Nfeature_list_dense=len(feature_list.dense_keys),\n        context_sparse_types=context.sparse_types,\n        context_ragged_value_types=context.ragged_value_types,\n        context_ragged_split_types=context.ragged_split_types,\n        feature_list_dense_types=feature_list.dense_types,\n        feature_list_sparse_types=feature_list.sparse_types,\n        feature_list_ragged_value_types=feature_list.ragged_value_types,\n        feature_list_ragged_split_types=feature_list.ragged_split_types,\n        context_dense_shapes=context.dense_shapes_as_proto,\n        feature_list_dense_shapes=feature_list.dense_shapes,\n        name=name)\n    (context_sparse_indices, context_sparse_values, context_sparse_shapes,\n     context_dense_values, context_ragged_values, context_ragged_row_splits,\n     feature_list_sparse_indices, feature_list_sparse_values,\n     feature_list_sparse_shapes, feature_list_dense_values,\n     feature_list_dense_lengths, feature_list_ragged_values,\n     feature_list_ragged_outer_splits,\n     feature_list_ragged_inner_splits) = outputs\n    # pylint: disable=protected-access\n    context_ragged_tensors = parsing_config._build_ragged_tensors(\n        serialized.shape, context_ragged_values, context_ragged_row_splits)\n    feature_list_ragged_tensors = parsing_config._build_ragged_tensors(\n        serialized.shape, feature_list_ragged_values,\n        feature_list_ragged_outer_splits, feature_list_ragged_inner_splits)\n\n    # pylint: disable=g-complex-comprehension\n    context_sparse_tensors = [\n        sparse_tensor.SparseTensor(ix, val, shape)\n        for (ix, val,\n             shape) in zip(context_sparse_indices, context_sparse_values,\n                           context_sparse_shapes)\n    ]\n\n    feature_list_sparse_tensors = [\n        sparse_tensor.SparseTensor(ix, val, shape)\n        for (ix, val, shape\n            ) in zip(feature_list_sparse_indices, feature_list_sparse_values,\n                     feature_list_sparse_shapes)\n    ]\n    # pylint: enable=g-complex-comprehension\n\n    context_output = dict(\n        zip(\n            context.sparse_keys + context.dense_keys + context.ragged_keys,\n            context_sparse_tensors + context_dense_values +\n            context_ragged_tensors))\n    feature_list_output = dict(\n        zip(\n            feature_list.sparse_keys + feature_list.dense_keys +\n            feature_list.ragged_keys, feature_list_sparse_tensors +\n            feature_list_dense_values + feature_list_ragged_tensors))\n    feature_list_lengths = dict(\n        zip(feature_list.dense_keys, feature_list_dense_lengths))\n\n    return (context_output, feature_list_output, feature_list_lengths)\n\n\n@tf_export(\"io.parse_single_sequence_example\",\n           v1=[\"io.parse_single_sequence_example\",\n               \"parse_single_sequence_example\"])\n@dispatch.add_dispatch_support\ndef parse_single_sequence_example(\n    serialized, context_features=None, sequence_features=None,\n    example_name=None, name=None):\n  # pylint: disable=line-too-long\n  \"\"\"Parses a single `SequenceExample` proto.\n\n  Parses a single serialized [`SequenceExample`](https://www.tensorflow.org/code/tensorflow/core/example/example.proto)\n  proto given in `serialized`.\n\n  This op parses a serialized sequence example into a tuple of dictionaries,\n  each mapping keys to `Tensor` and `SparseTensor` objects.\n  The first dictionary contains mappings for keys appearing in\n  `context_features`, and the second dictionary contains mappings for keys\n  appearing in `sequence_features`.\n\n  At least one of `context_features` and `sequence_features` must be provided\n  and non-empty.\n\n  The `context_features` keys are associated with a `SequenceExample` as a\n  whole, independent of time / frame.  In contrast, the `sequence_features` keys\n  provide a way to access variable-length data within the `FeatureList` section\n  of the `SequenceExample` proto.  While the shapes of `context_features` values\n  are fixed with respect to frame, the frame dimension (the first dimension)\n  of `sequence_features` values may vary between `SequenceExample` protos,\n  and even between `feature_list` keys within the same `SequenceExample`.\n\n  `context_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenFeature` objects. Each `VarLenFeature` is mapped to a `SparseTensor`;\n  each `RaggedFeature` is mapped to a `RaggedTensor`; and each `FixedLenFeature`\n  is mapped to a `Tensor`, of the specified type, shape, and default value.\n\n  `sequence_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenSequenceFeature` objects. Each `VarLenFeature` is mapped to a\n  `SparseTensor`; each `RaggedFeature` is mapped to a `RaggedTensor`; and each\n  `FixedLenSequenceFeature` is mapped to a `Tensor`, each of the specified type.\n  The shape will be `(T,) + df.dense_shape` for `FixedLenSequenceFeature` `df`,\n  where `T` is the length of the associated `FeatureList` in the\n  `SequenceExample`. For instance, `FixedLenSequenceFeature([])` yields a scalar\n  1-D `Tensor` of static shape `[None]` and dynamic shape `[T]`, while\n  `FixedLenSequenceFeature([k])` (for `int k >= 1`) yields a 2-D matrix `Tensor`\n  of static shape `[None, k]` and dynamic shape `[T, k]`.\n\n  Each `SparseTensor` corresponding to `sequence_features` represents a ragged\n  vector.  Its indices are `[time, index]`, where `time` is the `FeatureList`\n  entry and `index` is the value's index in the list of values associated with\n  that time.\n\n  `FixedLenFeature` entries with a `default_value` and `FixedLenSequenceFeature`\n  entries with `allow_missing=True` are optional; otherwise, we will fail if\n  that `Feature` or `FeatureList` is missing from any example in `serialized`.\n\n  `example_name` may contain a descriptive name for the corresponding serialized\n  proto. This may be useful for debugging purposes, but it has no effect on the\n  output. If not `None`, `example_name` must be a scalar.\n\n  Note that the batch version of this function, `tf.parse_sequence_example`,\n  is written for better memory efficiency and will be faster on large\n  `SequenceExample`s.\n\n  Args:\n    serialized: A scalar (0-D Tensor) of type string, a single binary\n      serialized `SequenceExample` proto.\n    context_features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` or `RaggedFeature` values. These features are associated\n      with a `SequenceExample` as a whole.\n    sequence_features: A `dict` mapping feature keys to\n      `FixedLenSequenceFeature` or `VarLenFeature` or `RaggedFeature` values.\n      These features are associated with data within the `FeatureList` section\n      of the `SequenceExample` proto.\n    example_name: A scalar (0-D Tensor) of strings (optional), the name of\n      the serialized proto.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of two `dict`s, each mapping keys to `Tensor`s and `SparseTensor`s\n    and `RaggedTensor`s.\n\n    * The first dict contains the context key/values.\n    * The second dict contains the feature_list key/values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  # pylint: enable=line-too-long\n  if not (context_features or sequence_features):\n    raise ValueError(\"Missing features.\")\n  context_params = _ParseOpParams.from_features(\n      context_features, [VarLenFeature, FixedLenFeature, RaggedFeature])\n  feature_list_params = _ParseOpParams.from_features(\n      sequence_features,\n      [VarLenFeature, FixedLenSequenceFeature, RaggedFeature])\n\n  with ops.name_scope(name, \"ParseSingleSequenceExample\",\n                      [serialized, example_name]):\n    context_output, feature_list_output = (\n        _parse_single_sequence_example_raw(serialized, context_params,\n                                           feature_list_params, example_name,\n                                           name))\n\n    if context_params.ragged_keys:\n      context_output = _construct_tensors_for_composite_features(\n          context_features, context_output)\n    if feature_list_params.ragged_keys:\n      feature_list_output = _construct_tensors_for_composite_features(\n          sequence_features, feature_list_output)\n\n    return context_output, feature_list_output\n\n\ndef _parse_single_sequence_example_raw(serialized,\n                                       context,\n                                       feature_list,\n                                       debug_name,\n                                       name=None):\n  \"\"\"Parses a single `SequenceExample` proto.\n\n  Args:\n    serialized: A scalar (0-D Tensor) of type string, a single binary serialized\n      `SequenceExample` proto.\n    context: A `ParseOpParams` containing the parameters for the parse op for\n      the context features.\n    feature_list: A `ParseOpParams` containing the parameters for the parse op\n      for the feature_list features.\n    debug_name: A scalar (0-D Tensor) of strings (optional), the name of the\n      serialized proto.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of two `dict`s, each mapping keys to `Tensor`s and `SparseTensor`s.\n    The first dict contains the context key/values.\n    The second dict contains the feature_list key/values.\n\n  Raises:\n    TypeError: if feature_list.dense_defaults is not either None or a dict.\n  \"\"\"\n  with ops.name_scope(name, \"ParseSingleExample\", [serialized, debug_name]):\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    serialized = _assert_scalar(serialized, \"serialized\")\n  return _parse_sequence_example_raw(serialized, debug_name, context,\n                                     feature_list, name)[:2]\n\n\n@tf_export(\"io.decode_raw\", v1=[])\n@dispatch.add_dispatch_support\ndef decode_raw(input_bytes,\n               out_type,\n               little_endian=True,\n               fixed_length=None,\n               name=None):\n  r\"\"\"Convert raw bytes from input tensor into numeric tensors.\n\n  The input tensor is interpreted as a sequence of bytes. These bytes are then\n  decoded as numbers in the format specified by `out_type`.\n\n  >>> tf.io.decode_raw(tf.constant(\"1\"), tf.uint8)\n  <tf.Tensor: shape=(1,), dtype=uint8, numpy=array([49], dtype=uint8)>\n  >>> tf.io.decode_raw(tf.constant(\"1,2\"), tf.uint8)\n  <tf.Tensor: shape=(3,), dtype=uint8, numpy=array([49, 44, 50], dtype=uint8)>\n\n  Note that the rank of the output tensor is always one more than the input one:\n\n  >>> tf.io.decode_raw(tf.constant([\"1\",\"2\"]), tf.uint8).shape\n  TensorShape([2, 1])\n  >>> tf.io.decode_raw(tf.constant([[\"1\"],[\"2\"]]), tf.uint8).shape\n  TensorShape([2, 1, 1])\n\n  This is because each byte in the input is converted to a new value on the\n  output (if output type is `uint8` or `int8`, otherwise chunks of inputs get\n  coverted to a new value):\n\n  >>> tf.io.decode_raw(tf.constant(\"123\"), tf.uint8)\n  <tf.Tensor: shape=(3,), dtype=uint8, numpy=array([49, 50, 51], dtype=uint8)>\n  >>> tf.io.decode_raw(tf.constant(\"1234\"), tf.uint8)\n  <tf.Tensor: shape=(4,), dtype=uint8, numpy=array([49, 50, 51, 52], ...\n  >>> # chuncked output\n  >>> tf.io.decode_raw(tf.constant(\"12\"), tf.uint16)\n  <tf.Tensor: shape=(1,), dtype=uint16, numpy=array([12849], dtype=uint16)>\n  >>> tf.io.decode_raw(tf.constant(\"1234\"), tf.uint16)\n  <tf.Tensor: shape=(2,), dtype=uint16, numpy=array([12849, 13363], ...\n  >>> # int64 output\n  >>> tf.io.decode_raw(tf.constant(\"12345678\"), tf.int64)\n  <tf.Tensor: ... numpy=array([4050765991979987505])>\n  >>> tf.io.decode_raw(tf.constant(\"1234567887654321\"), tf.int64)\n  <tf.Tensor: ... numpy=array([4050765991979987505, 3544952156018063160])>\n\n  The operation allows specifying endianness via the `little_endian` parameter.\n\n  >>> tf.io.decode_raw(tf.constant(\"\\x0a\\x0b\"), tf.int16)\n  <tf.Tensor: shape=(1,), dtype=int16, numpy=array([2826], dtype=int16)>\n  >>> hex(2826)\n  '0xb0a'\n  >>> tf.io.decode_raw(tf.constant(\"\\x0a\\x0b\"), tf.int16, little_endian=False)\n  <tf.Tensor: shape=(1,), dtype=int16, numpy=array([2571], dtype=int16)>\n  >>> hex(2571)\n  '0xa0b'\n\n  If the elements of `input_bytes` are of different length, you must specify\n  `fixed_length`:\n\n  >>> tf.io.decode_raw(tf.constant([[\"1\"],[\"23\"]]), tf.uint8, fixed_length=4)\n  <tf.Tensor: shape=(2, 1, 4), dtype=uint8, numpy=\n  array([[[49,  0,  0,  0]],\n         [[50, 51,  0,  0]]], dtype=uint8)>\n\n  If the `fixed_length` value is larger that the length of the `out_type` dtype,\n  multiple values are generated:\n\n  >>> tf.io.decode_raw(tf.constant([\"1212\"]), tf.uint16, fixed_length=4)\n  <tf.Tensor: shape=(1, 2), dtype=uint16, numpy=array([[12849, 12849]], ...\n\n  Note: There is currently a bug in `fixed_length` that can result in data loss:\n\n  >>> # truncated to length of type as it matches fixed_length\n  >>> tf.io.decode_raw(tf.constant([\"1212\"]), tf.uint16, fixed_length=2)\n  <tf.Tensor: shape=(1, 1), dtype=uint16, numpy=array([[12849]], dtype=uint16)>\n  >>> # ignores the second component\n  >>> tf.io.decode_raw(tf.constant([\"12\",\"34\"]), tf.uint16, fixed_length=2)\n  <tf.Tensor: shape=(2, 1), dtype=uint16, numpy=\n  array([[12849],\n         [    0]], dtype=uint16)>\n  >>> tf.io.decode_raw(tf.constant([\"12\",\"34\"]), tf.uint16, fixed_length=4)\n  <tf.Tensor: shape=(2, 2), dtype=uint16, numpy=\n  array([[12849,     0],\n         [    0,     0]], dtype=uint16)>\n\n  This will be fixed on a future release of TensorFlow.\n\n  Args:\n    input_bytes:\n      Each element of the input Tensor is converted to an array of bytes.\n\n      Currently, this must be a tensor of strings (bytes), although semantically\n      the operation should support any input.\n    out_type:\n      `DType` of the output. Acceptable types are `half`, `float`, `double`,\n      `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`.\n    little_endian:\n      Whether the `input_bytes` data is in little-endian format. Data will be\n      converted into host byte order if necessary.\n    fixed_length:\n      If set, the first `fixed_length` bytes of each element will be converted.\n      Data will be zero-padded or truncated to the specified length.\n\n      `fixed_length` must be a multiple of the size of `out_type`.\n\n      `fixed_length` must be specified if the elements of `input_bytes` are of\n      variable length.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` object storing the decoded bytes.\n  \"\"\"\n  if fixed_length is not None:\n    return gen_parsing_ops.decode_padded_raw(\n        input_bytes,\n        fixed_length=fixed_length,\n        out_type=out_type,\n        little_endian=little_endian,\n        name=name)\n  else:\n    return gen_parsing_ops.decode_raw(\n        input_bytes, out_type, little_endian=little_endian, name=name)\n\n\n@tf_export(v1=[\"decode_raw\", \"io.decode_raw\"])\n@dispatch.add_dispatch_support\n@deprecation.deprecated_args(None,\n                             \"bytes is deprecated, use input_bytes instead\",\n                             \"bytes\")\ndef decode_raw_v1(\n    input_bytes=None,\n    out_type=None,\n    little_endian=True,\n    name=None,\n    bytes=None  # pylint: disable=redefined-builtin\n):\n  \"\"\"Convert raw byte strings into tensors.\n\n  Args:\n    input_bytes:\n      Each element of the input Tensor is converted to an array of bytes.\n    out_type:\n      `DType` of the output. Acceptable types are `half`, `float`, `double`,\n      `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`.\n    little_endian:\n      Whether the `input_bytes` data is in little-endian format. Data will be\n      converted into host byte order if necessary.\n    name: A name for the operation (optional).\n    bytes: Deprecated parameter. Use `input_bytes` instead.\n\n  Returns:\n    A `Tensor` object storing the decoded bytes.\n  \"\"\"\n  input_bytes = deprecation.deprecated_argument_lookup(\"input_bytes\",\n                                                       input_bytes, \"bytes\",\n                                                       bytes)\n\n  # out_type is a required positional argument in the original API, and had to\n  # be changed to a keyword argument in order to facilitate the transition from\n  # the reserved named `bytes` to `input_bytes`. Ensure it's still set.\n  if out_type is None:\n    raise ValueError(\n        \"decode_raw_v1() missing 1 positional argument: 'out_type'\")\n\n  return gen_parsing_ops.decode_raw(\n      input_bytes, out_type, little_endian=little_endian, name=name)\n\n\n# Swap `name` and `na_value` for backward compatibility.\n@tf_export(v1=[\"io.decode_csv\", \"decode_csv\"])\n@dispatch.add_dispatch_support\n@deprecation.deprecated_endpoints(\"decode_csv\")\ndef decode_csv(records,\n               record_defaults,\n               field_delim=\",\",\n               use_quote_delim=True,\n               name=None,\n               na_value=\"\",\n               select_cols=None):\n  \"\"\"Convert CSV records to tensors. Each column maps to one tensor.\n\n  RFC 4180 format is expected for the CSV records.\n  (https://tools.ietf.org/html/rfc4180)\n  Note that we allow leading and trailing spaces with int or float field.\n\n  Args:\n    records: A `Tensor` of type `string`.\n      Each string is a record/row in the csv and all records should have\n      the same format.\n    record_defaults: A list of `Tensor` objects with specific types.\n      Acceptable types are `float32`, `float64`, `int32`, `int64`, `string`.\n      One tensor per column of the input record, with either a\n      scalar default value for that column or an empty vector if the column is\n      required.\n    field_delim: An optional `string`. Defaults to `\",\"`.\n      char delimiter to separate fields in a record.\n    use_quote_delim: An optional `bool`. Defaults to `True`.\n      If false, treats double quotation marks as regular\n      characters inside of the string fields (ignoring RFC 4180, Section 2,\n      Bullet 5).\n    name: A name for the operation (optional).\n    na_value: Additional string to recognize as NA/NaN.\n    select_cols: Optional sorted list of column indices to select. If specified,\n      only this subset of columns will be parsed and returned.\n\n  Returns:\n    A list of `Tensor` objects. Has the same type as `record_defaults`.\n    Each tensor will have the same shape as records.\n\n  Raises:\n    ValueError: If any of the arguments is malformed.\n  \"\"\"\n  return decode_csv_v2(\n      records, record_defaults,\n      field_delim, use_quote_delim,\n      na_value, select_cols, name\n      )\n\n\n@tf_export(\"io.decode_csv\", v1=[])\n@dispatch.add_dispatch_support\ndef decode_csv_v2(records,\n                  record_defaults,\n                  field_delim=\",\",\n                  use_quote_delim=True,\n                  na_value=\"\",\n                  select_cols=None,\n                  name=None):\n  \"\"\"Convert CSV records to tensors. Each column maps to one tensor.\n\n  RFC 4180 format is expected for the CSV records.\n  (https://tools.ietf.org/html/rfc4180)\n  Note that we allow leading and trailing spaces with int or float field.\n\n  Args:\n    records: A `Tensor` of type `string`.\n      Each string is a record/row in the csv and all records should have\n      the same format.\n    record_defaults: A list of `Tensor` objects with specific types.\n      Acceptable types are `float32`, `float64`, `int32`, `int64`, `string`.\n      One tensor per column of the input record, with either a\n      scalar default value for that column or an empty vector if the column is\n      required.\n    field_delim: An optional `string`. Defaults to `\",\"`.\n      char delimiter to separate fields in a record.\n    use_quote_delim: An optional `bool`. Defaults to `True`.\n      If false, treats double quotation marks as regular\n      characters inside of the string fields (ignoring RFC 4180, Section 2,\n      Bullet 5).\n    na_value: Additional string to recognize as NA/NaN.\n    select_cols: Optional sorted list of column indices to select. If specified,\n      only this subset of columns will be parsed and returned.\n    name: A name for the operation (optional).\n\n  Returns:\n    A list of `Tensor` objects. Has the same type as `record_defaults`.\n    Each tensor will have the same shape as records.\n\n  Raises:\n    ValueError: If any of the arguments is malformed.\n  \"\"\"\n  if select_cols is not None and any(select_cols[i] >= select_cols[i + 1]\n                                     for i in range(len(select_cols) - 1)):\n    raise ValueError(\"select_cols is not strictly increasing.\")\n  if select_cols is not None and select_cols[0] < 0:\n    raise ValueError(\"select_cols contains negative values.\")\n  if select_cols is not None and len(select_cols) != len(record_defaults):\n    raise ValueError(\"Length of select_cols and record_defaults do not match.\")\n  return gen_parsing_ops.decode_csv(\n      records=records,\n      record_defaults=record_defaults,\n      field_delim=field_delim,\n      use_quote_delim=use_quote_delim,\n      na_value=na_value,\n      name=name,\n      select_cols=select_cols,\n  )\n\n\ndef _assert_scalar(value, name):\n  \"\"\"Asserts that `value` is scalar, and returns `value`.\"\"\"\n  value_rank = value.shape.rank\n  if value_rank is None:\n    check = control_flow_ops.Assert(\n        math_ops.equal(array_ops.rank(value), 0),\n        [\"Input %s must be a scalar\" % name],\n        name=\"%sIsScalar\" % name.capitalize())\n    result = control_flow_ops.with_dependencies([check],\n                                                value,\n                                                name=\"%sDependencies\" % name)\n    result.set_shape([])\n    return result\n  elif value_rank == 0:\n    return value\n  else:\n    raise ValueError(\"Input %s must be a scalar\" % name)\n\n\n@tf_export(\"io.decode_json_example\",\n           v1=[\"decode_json_example\", \"io.decode_json_example\"])\ndef decode_json_example(json_examples, name=None):\n  r\"\"\"Convert JSON-encoded Example records to binary protocol buffer strings.\n\n  Note: This is **not** a general purpose JSON parsing op.\n\n  This op converts JSON-serialized `tf.train.Example` (maybe created with\n  `json_format.MessageToJson`, following the\n  [standard JSON mapping](\n  https://developers.google.com/protocol-buffers/docs/proto3#json))\n  to a binary-serialized `tf.train.Example` (equivalent to\n  `Example.SerializeToString()`) suitable for conversion to tensors with\n  `tf.io.parse_example`.\n\n  Here is a `tf.train.Example` proto:\n\n  >>> example = tf.train.Example(\n  ...   features=tf.train.Features(\n  ...       feature={\n  ...           \"a\": tf.train.Feature(\n  ...               int64_list=tf.train.Int64List(\n  ...                   value=[1, 1, 3]))}))\n\n  Here it is converted to JSON:\n\n  >>> from google.protobuf import json_format\n  >>> example_json = json_format.MessageToJson(example)\n  >>> print(example_json)\n  {\n    \"features\": {\n      \"feature\": {\n        \"a\": {\n          \"int64List\": {\n            \"value\": [\n              \"1\",\n              \"1\",\n              \"3\"\n            ]\n          }\n        }\n      }\n    }\n  }\n\n  This op converts the above json string to a binary proto:\n\n  >>> example_binary = tf.io.decode_json_example(example_json)\n  >>> example_binary.numpy()\n  b'\\n\\x0f\\n\\r\\n\\x01a\\x12\\x08\\x1a\\x06\\x08\\x01\\x08\\x01\\x08\\x03'\n\n  The OP works on string tensors of andy shape:\n\n  >>> tf.io.decode_json_example([\n  ...     [example_json, example_json],\n  ...     [example_json, example_json]]).shape.as_list()\n  [2, 2]\n\n  This resulting binary-string is equivalent to `Example.SerializeToString()`,\n  and can be converted to Tensors using `tf.io.parse_example` and related\n  functions:\n\n  >>> tf.io.parse_example(\n  ...   serialized=[example_binary.numpy(),\n  ...              example.SerializeToString()],\n  ...   features = {'a': tf.io.FixedLenFeature(shape=[3], dtype=tf.int64)})\n  {'a': <tf.Tensor: shape=(2, 3), dtype=int64, numpy=\n   array([[1, 1, 3],\n          [1, 1, 3]])>}\n\n  Args:\n    json_examples: A string tensor containing json-serialized `tf.Example`\n      protos.\n    name: A name for the op.\n\n  Returns:\n    A string Tensor containing the binary-serialized `tf.Example` protos.\n\n  Raises:\n     `tf.errors.InvalidArgumentError`: If the JSON could not be converted to a\n     `tf.Example`\n  \"\"\"\n  return gen_parsing_ops.decode_json_example(json_examples, name=name)\n"], "fixing_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <algorithm>\n#include <cmath>\n\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n\nnamespace tensorflow {\n\ntemplate <typename T>\nclass DecodePaddedRawOp : public OpKernel {\n public:\n  explicit DecodePaddedRawOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"out_type\", &out_type_));\n\n    const bool host_is_little_endian = port::kLittleEndian;\n    bool data_is_little_endian;\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"little_endian\", &data_is_little_endian));\n    convert_data_endianness_ = host_is_little_endian != data_is_little_endian;\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n\n    int width = fixed_length / sizeof(T);\n\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n\n    if (flat_in.size() == 0) {  // Empty input\n      return;\n    }\n\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n\n    // Forcibly clear memory - we're going to copy variable length strings in,\n    // and need to ensure that if we don't write to byte N when we copy, that\n    // we're not getting random data.\n    memset(out_data, 0, fixed_length * flat_in.size());\n\n    // If the data is already in the host's byte order, or if the width of the\n    // output type is a single byte (meaning the ordering doesn't matter), we\n    // can copy the memory directly.\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const auto to_copy =\n            std::min(flat_in(i).size(), static_cast<size_t>(fixed_length));\n        memcpy(out_data, flat_in(i).data(), to_copy);\n        // Note: increase out_data by width since it's already of type T* so\n        // each shift amount is implicitly multiplied by sizeof(T) according to\n        // pointer arithmetic rules.\n        out_data += width;\n      }\n    } else {\n      // Otherwise, the data is not in the host's byte order, and rather than a\n      // direct copy, we need to reverse the byte ordering of each element.\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        // Note: increase out_data by width since it's already of type T* so\n        // each shift amount is implicitly multiplied by sizeof(T) according to\n        // pointer arithmetic rules.\n        out_data += width;\n      }\n    }\n  }\n\n private:\n  // True if the endianness of the data and the endianness of the host are\n  // different, and the data needs conversion.\n  bool convert_data_endianness_;\n\n  // Data type of the output tensor.\n  DataType out_type_;\n};\n\n#define REGISTER(type)                                           \\\n  REGISTER_KERNEL_BUILDER(Name(\"DecodePaddedRaw\")                \\\n                              .Device(DEVICE_CPU)                \\\n                              .TypeConstraint<type>(\"out_type\"), \\\n                          DecodePaddedRawOp<type>)\n\nREGISTER(float);\nREGISTER(double);\nREGISTER(int32);\nREGISTER(uint16);\nREGISTER(uint8);\nREGISTER(int16);\nREGISTER(int8);\nREGISTER(int64);\n\n#undef REGISTER\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Parsing Ops.\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import gen_parsing_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import parsing_config\n# go/tf-wildcard-import\n# pylint: disable=wildcard-import,undefined-variable\nfrom tensorflow.python.ops.gen_parsing_ops import *\n# pylint: enable=wildcard-import,undefined-variable\nfrom tensorflow.python.util import deprecation\nfrom tensorflow.python.util import dispatch\nfrom tensorflow.python.util.tf_export import tf_export\n\n\nops.NotDifferentiable(\"DecodeRaw\")\nops.NotDifferentiable(\"DecodePaddedRaw\")\nops.NotDifferentiable(\"ParseTensor\")\nops.NotDifferentiable(\"SerializeTensor\")\nops.NotDifferentiable(\"StringToNumber\")\n\n\nVarLenFeature = parsing_config.VarLenFeature\nRaggedFeature = parsing_config.RaggedFeature\nSparseFeature = parsing_config.SparseFeature\nFixedLenFeature = parsing_config.FixedLenFeature\nFixedLenSequenceFeature = parsing_config.FixedLenSequenceFeature\n# pylint: disable=protected-access\n_ParseOpParams = parsing_config._ParseOpParams\n_construct_tensors_for_composite_features = (\n    parsing_config._construct_tensors_for_composite_features)\n# pylint: enable=protected-access\n\n\n# TODO(b/122887740) Switch files that use this private symbol to use new name.\n_construct_sparse_tensors_for_sparse_features = \\\n    _construct_tensors_for_composite_features\n\n\ndef _prepend_none_dimension(features):\n  \"\"\"Returns a copy of features with adjusted FixedLenSequenceFeature shapes.\"\"\"\n  if features:\n    modified_features = dict(features)  # Create a copy to modify\n    for key, feature in features.items():\n      if isinstance(feature, FixedLenSequenceFeature):\n        if not feature.allow_missing:\n          raise ValueError(\"Unsupported: FixedLenSequenceFeature requires \"\n                           \"allow_missing to be True.\")\n        modified_features[key] = FixedLenSequenceFeature(\n            [None] + list(feature.shape),\n            feature.dtype,\n            feature.allow_missing,\n            feature.default_value)\n    return modified_features\n  else:\n    return features\n\n\n@tf_export(\"io.parse_example\", v1=[])\n@dispatch.add_dispatch_support\ndef parse_example_v2(serialized, features, example_names=None, name=None):\n  # pylint: disable=line-too-long\n  \"\"\"Parses `Example` protos into a `dict` of tensors.\n\n  Parses a number of serialized [`Example`](https://www.tensorflow.org/code/tensorflow/core/example/example.proto)\n  protos given in `serialized`. We refer to `serialized` as a batch with\n  `batch_size` many entries of individual `Example` protos.\n\n  `example_names` may contain descriptive names for the corresponding serialized\n  protos. These may be useful for debugging purposes, but they have no effect on\n  the output. If not `None`, `example_names` must be the same length as\n  `serialized`.\n\n  This op parses serialized examples into a dictionary mapping keys to `Tensor`\n  `SparseTensor`, and `RaggedTensor` objects. `features` is a dict from keys to\n  `VarLenFeature`, `SparseFeature`, `RaggedFeature`, and `FixedLenFeature`\n  objects. Each `VarLenFeature` and `SparseFeature` is mapped to a\n  `SparseTensor`; each `FixedLenFeature` is mapped to a `Tensor`; and each\n  `RaggedFeature` is mapped to a `RaggedTensor`.\n\n  Each `VarLenFeature` maps to a `SparseTensor` of the specified type\n  representing a ragged matrix. Its indices are `[batch, index]` where `batch`\n  identifies the example in `serialized`, and `index` is the value's index in\n  the list of values associated with that feature and example.\n\n  Each `SparseFeature` maps to a `SparseTensor` of the specified type\n  representing a Tensor of `dense_shape` `[batch_size] + SparseFeature.size`.\n  Its `values` come from the feature in the examples with key `value_key`.\n  A `values[i]` comes from a position `k` in the feature of an example at batch\n  entry `batch`. This positional information is recorded in `indices[i]` as\n  `[batch, index_0, index_1, ...]` where `index_j` is the `k-th` value of\n  the feature in the example at with key `SparseFeature.index_key[j]`.\n  In other words, we split the indices (except the first index indicating the\n  batch entry) of a `SparseTensor` by dimension into different features of the\n  `Example`. Due to its complexity a `VarLenFeature` should be preferred over a\n  `SparseFeature` whenever possible.\n\n  Each `FixedLenFeature` `df` maps to a `Tensor` of the specified type (or\n  `tf.float32` if not specified) and shape `(serialized.size(),) + df.shape`.\n\n  `FixedLenFeature` entries with a `default_value` are optional. With no default\n  value, we will fail if that `Feature` is missing from any example in\n  `serialized`.\n\n  Each `FixedLenSequenceFeature` `df` maps to a `Tensor` of the specified type\n  (or `tf.float32` if not specified) and shape\n  `(serialized.size(), None) + df.shape`.\n  All examples in `serialized` will be padded with `default_value` along the\n  second dimension.\n\n  Each `RaggedFeature` maps to a `RaggedTensor` of the specified type.  It\n  is formed by stacking the `RaggedTensor` for each example, where the\n  `RaggedTensor` for each individual example is constructed using the tensors\n  specified by `RaggedTensor.values_key` and `RaggedTensor.partition`.  See\n  the `tf.io.RaggedFeature` documentation for details and examples.\n\n  Examples:\n\n  For example, if one expects a `tf.float32` `VarLenFeature` `ft` and three\n  serialized `Example`s are provided:\n\n  ```\n  serialized = [\n    features\n      { feature { key: \"ft\" value { float_list { value: [1.0, 2.0] } } } },\n    features\n      { feature []},\n    features\n      { feature { key: \"ft\" value { float_list { value: [3.0] } } }\n  ]\n  ```\n\n  then the output will look like:\n\n  ```python\n  {\"ft\": SparseTensor(indices=[[0, 0], [0, 1], [2, 0]],\n                      values=[1.0, 2.0, 3.0],\n                      dense_shape=(3, 2)) }\n  ```\n\n  If instead a `FixedLenSequenceFeature` with `default_value = -1.0` and\n  `shape=[]` is used then the output will look like:\n\n  ```python\n  {\"ft\": [[1.0, 2.0], [3.0, -1.0]]}\n  ```\n\n  Given two `Example` input protos in `serialized`:\n\n  ```\n  [\n    features {\n      feature { key: \"kw\" value { bytes_list { value: [ \"knit\", \"big\" ] } } }\n      feature { key: \"gps\" value { float_list { value: [] } } }\n    },\n    features {\n      feature { key: \"kw\" value { bytes_list { value: [ \"emmy\" ] } } }\n      feature { key: \"dank\" value { int64_list { value: [ 42 ] } } }\n      feature { key: \"gps\" value { } }\n    }\n  ]\n  ```\n\n  And arguments\n\n  ```\n  example_names: [\"input0\", \"input1\"],\n  features: {\n      \"kw\": VarLenFeature(tf.string),\n      \"dank\": VarLenFeature(tf.int64),\n      \"gps\": VarLenFeature(tf.float32),\n  }\n  ```\n\n  Then the output is a dictionary:\n\n  ```python\n  {\n    \"kw\": SparseTensor(\n        indices=[[0, 0], [0, 1], [1, 0]],\n        values=[\"knit\", \"big\", \"emmy\"]\n        dense_shape=[2, 2]),\n    \"dank\": SparseTensor(\n        indices=[[1, 0]],\n        values=[42],\n        dense_shape=[2, 1]),\n    \"gps\": SparseTensor(\n        indices=[],\n        values=[],\n        dense_shape=[2, 0]),\n  }\n  ```\n\n  For dense results in two serialized `Example`s:\n\n  ```\n  [\n    features {\n      feature { key: \"age\" value { int64_list { value: [ 0 ] } } }\n      feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n     },\n     features {\n      feature { key: \"age\" value { int64_list { value: [] } } }\n      feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n    }\n  ]\n  ```\n\n  We can use arguments:\n\n  ```\n  example_names: [\"input0\", \"input1\"],\n  features: {\n      \"age\": FixedLenFeature([], dtype=tf.int64, default_value=-1),\n      \"gender\": FixedLenFeature([], dtype=tf.string),\n  }\n  ```\n\n  And the expected output is:\n\n  ```python\n  {\n    \"age\": [[0], [-1]],\n    \"gender\": [[\"f\"], [\"f\"]],\n  }\n  ```\n\n  An alternative to `VarLenFeature` to obtain a `SparseTensor` is\n  `SparseFeature`. For example, given two `Example` input protos in\n  `serialized`:\n\n  ```\n  [\n    features {\n      feature { key: \"val\" value { float_list { value: [ 0.5, -1.0 ] } } }\n      feature { key: \"ix\" value { int64_list { value: [ 3, 20 ] } } }\n    },\n    features {\n      feature { key: \"val\" value { float_list { value: [ 0.0 ] } } }\n      feature { key: \"ix\" value { int64_list { value: [ 42 ] } } }\n    }\n  ]\n  ```\n\n  And arguments\n\n  ```\n  example_names: [\"input0\", \"input1\"],\n  features: {\n      \"sparse\": SparseFeature(\n          index_key=\"ix\", value_key=\"val\", dtype=tf.float32, size=100),\n  }\n  ```\n\n  Then the output is a dictionary:\n\n  ```python\n  {\n    \"sparse\": SparseTensor(\n        indices=[[0, 3], [0, 20], [1, 42]],\n        values=[0.5, -1.0, 0.0]\n        dense_shape=[2, 100]),\n  }\n  ```\n\n  See the `tf.io.RaggedFeature` documentation for examples showing how\n  `RaggedFeature` can be used to obtain `RaggedTensor`s.\n\n  Args:\n    serialized: A vector (1-D Tensor) of strings, a batch of binary\n      serialized `Example` protos.\n    features: A `dict` mapping feature keys to `FixedLenFeature`,\n      `VarLenFeature`, `SparseFeature`, and `RaggedFeature` values.\n    example_names: A vector (1-D Tensor) of strings (optional), the names of\n      the serialized protos in the batch.\n    name: A name for this operation (optional).\n\n  Returns:\n    A `dict` mapping feature keys to `Tensor`, `SparseTensor`, and\n    `RaggedTensor` values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  if not features:\n    raise ValueError(\"Missing: features was %s.\" % features)\n  features = _prepend_none_dimension(features)\n  params = _ParseOpParams.from_features(features, [\n      VarLenFeature, SparseFeature, FixedLenFeature, FixedLenSequenceFeature,\n      RaggedFeature\n  ])\n\n  outputs = _parse_example_raw(serialized, example_names, params, name=name)\n  return _construct_tensors_for_composite_features(features, outputs)\n\n\n@tf_export(v1=[\"io.parse_example\", \"parse_example\"])\n@dispatch.add_dispatch_support\ndef parse_example(serialized, features, name=None, example_names=None):\n  return parse_example_v2(serialized, features, example_names, name)\n\n\nparse_example.__doc__ = parse_example_v2.__doc__\n\n\ndef _parse_example_raw(serialized, names, params, name):\n  \"\"\"Parses `Example` protos.\n\n  Args:\n    serialized: A vector (1-D Tensor) of strings, a batch of binary\n      serialized `Example` protos.\n    names: A vector (1-D Tensor) of strings (optional), the names of\n      the serialized protos.\n    params: A `ParseOpParams` containing the parameters for the parse op.\n    name: A name for this operation (optional).\n\n  Returns:\n    A `dict` mapping keys to `Tensor`s and `SparseTensor`s and `RaggedTensor`s.\n\n  \"\"\"\n  if params.num_features == 0:\n    raise ValueError(\"Must provide at least one feature key\")\n  with ops.name_scope(name, \"ParseExample\", [serialized, names]):\n    names = [] if names is None else names\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    if params.ragged_keys and serialized.shape.ndims is None:\n      raise ValueError(\"serialized must have statically-known rank to \"\n                       \"parse ragged features.\")\n    outputs = gen_parsing_ops.parse_example_v2(\n        serialized=serialized,\n        names=names,\n        sparse_keys=params.sparse_keys,\n        dense_keys=params.dense_keys,\n        ragged_keys=params.ragged_keys,\n        dense_defaults=params.dense_defaults_vec,\n        num_sparse=len(params.sparse_keys),\n        sparse_types=params.sparse_types,\n        ragged_value_types=params.ragged_value_types,\n        ragged_split_types=params.ragged_split_types,\n        dense_shapes=params.dense_shapes_as_proto,\n        name=name)\n    (sparse_indices, sparse_values, sparse_shapes, dense_values,\n     ragged_values, ragged_row_splits) = outputs\n    # pylint: disable=protected-access\n    ragged_tensors = parsing_config._build_ragged_tensors(\n        serialized.shape, ragged_values, ragged_row_splits)\n\n    sparse_tensors = [\n        sparse_tensor.SparseTensor(ix, val, shape) for (ix, val, shape)\n        in zip(sparse_indices, sparse_values, sparse_shapes)]\n\n    return dict(\n        zip(params.sparse_keys + params.dense_keys + params.ragged_keys,\n            sparse_tensors + dense_values + ragged_tensors))\n\n\n@tf_export(v1=[\"io.parse_single_example\", \"parse_single_example\"])\n@dispatch.add_dispatch_support\ndef parse_single_example(serialized, features, name=None, example_names=None):\n  \"\"\"Parses a single `Example` proto.\n\n  Similar to `parse_example`, except:\n\n  For dense tensors, the returned `Tensor` is identical to the output of\n  `parse_example`, except there is no batch dimension, the output shape is the\n  same as the shape given in `dense_shape`.\n\n  For `SparseTensor`s, the first (batch) column of the indices matrix is removed\n  (the indices matrix is a column vector), the values vector is unchanged, and\n  the first (`batch_size`) entry of the shape vector is removed (it is now a\n  single element vector).\n\n  One might see performance advantages by batching `Example` protos with\n  `parse_example` instead of using this function directly.\n\n  Args:\n    serialized: A scalar string Tensor, a single serialized Example.\n    features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` values.\n    name: A name for this operation (optional).\n    example_names: (Optional) A scalar string Tensor, the associated name.\n\n  Returns:\n    A `dict` mapping feature keys to `Tensor` and `SparseTensor` values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  return parse_single_example_v2(serialized, features, example_names, name)\n\n\n@tf_export(\"io.parse_single_example\", v1=[])\n@dispatch.add_dispatch_support\ndef parse_single_example_v2(\n    serialized, features, example_names=None, name=None\n    ):\n  \"\"\"Parses a single `Example` proto.\n\n  Similar to `parse_example`, except:\n\n  For dense tensors, the returned `Tensor` is identical to the output of\n  `parse_example`, except there is no batch dimension, the output shape is the\n  same as the shape given in `dense_shape`.\n\n  For `SparseTensor`s, the first (batch) column of the indices matrix is removed\n  (the indices matrix is a column vector), the values vector is unchanged, and\n  the first (`batch_size`) entry of the shape vector is removed (it is now a\n  single element vector).\n\n  One might see performance advantages by batching `Example` protos with\n  `parse_example` instead of using this function directly.\n\n  Args:\n    serialized: A scalar string Tensor, a single serialized Example.\n    features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` values.\n    example_names: (Optional) A scalar string Tensor, the associated name.\n    name: A name for this operation (optional).\n\n  Returns:\n    A `dict` mapping feature keys to `Tensor` and `SparseTensor` values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  if not features:\n    raise ValueError(\"Missing features.\")\n  with ops.name_scope(name, \"ParseSingleExample\", [serialized, example_names]):\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    serialized = _assert_scalar(serialized, \"serialized\")\n    return parse_example_v2(serialized, features, example_names, name)\n\n\n@tf_export(\"io.parse_sequence_example\")\n@dispatch.add_dispatch_support\ndef parse_sequence_example(serialized,\n                           context_features=None,\n                           sequence_features=None,\n                           example_names=None,\n                           name=None):\n  # pylint: disable=line-too-long\n  \"\"\"Parses a batch of `SequenceExample` protos.\n\n  Parses a vector of serialized\n  [`SequenceExample`](https://www.tensorflow.org/code/tensorflow/core/example/example.proto)\n  protos given in `serialized`.\n\n  This op parses serialized sequence examples into a tuple of dictionaries,\n  each mapping keys to `Tensor` and `SparseTensor` objects.\n  The first dictionary contains mappings for keys appearing in\n  `context_features`, and the second dictionary contains mappings for keys\n  appearing in `sequence_features`.\n\n  At least one of `context_features` and `sequence_features` must be provided\n  and non-empty.\n\n  The `context_features` keys are associated with a `SequenceExample` as a\n  whole, independent of time / frame.  In contrast, the `sequence_features` keys\n  provide a way to access variable-length data within the `FeatureList` section\n  of the `SequenceExample` proto.  While the shapes of `context_features` values\n  are fixed with respect to frame, the frame dimension (the first dimension)\n  of `sequence_features` values may vary between `SequenceExample` protos,\n  and even between `feature_list` keys within the same `SequenceExample`.\n\n  `context_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenFeature`  objects. Each `VarLenFeature` is mapped to a\n  `SparseTensor`; each `RaggedFeature` is  mapped to a `RaggedTensor`; and each\n  `FixedLenFeature` is mapped to a `Tensor`, of the specified type, shape, and\n  default value.\n\n  `sequence_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenSequenceFeature` objects. Each `VarLenFeature` is mapped to a\n  `SparseTensor`; each `RaggedFeature` is mapped to a `RaggedTensor; and\n  each `FixedLenSequenceFeature` is mapped to a `Tensor`, each of the specified\n  type. The shape will be `(B,T,) + df.dense_shape` for\n  `FixedLenSequenceFeature` `df`, where `B` is the batch size, and `T` is the\n  length of the associated `FeatureList` in the `SequenceExample`. For instance,\n  `FixedLenSequenceFeature([])` yields a scalar 2-D `Tensor` of static shape\n  `[None, None]` and dynamic shape `[B, T]`, while\n  `FixedLenSequenceFeature([k])` (for `int k >= 1`) yields a 3-D matrix `Tensor`\n  of static shape `[None, None, k]` and dynamic shape `[B, T, k]`.\n\n  Like the input, the resulting output tensors have a batch dimension. This\n  means that the original per-example shapes of `VarLenFeature`s and\n  `FixedLenSequenceFeature`s can be lost. To handle that situation, this op also\n  provides dicts of shape tensors as part of the output. There is one dict for\n  the context features, and one for the feature_list features. Context features\n  of type `FixedLenFeature`s will not be present, since their shapes are already\n  known by the caller. In situations where the input 'FixedLenFeature`s are of\n  different lengths across examples, the shorter examples will be padded with\n  default datatype values: 0 for numeric types, and the empty string for string\n  types.\n\n  Each `SparseTensor` corresponding to `sequence_features` represents a ragged\n  vector.  Its indices are `[time, index]`, where `time` is the `FeatureList`\n  entry and `index` is the value's index in the list of values associated with\n  that time.\n\n  `FixedLenFeature` entries with a `default_value` and `FixedLenSequenceFeature`\n  entries with `allow_missing=True` are optional; otherwise, we will fail if\n  that `Feature` or `FeatureList` is missing from any example in `serialized`.\n\n  `example_name` may contain a descriptive name for the corresponding serialized\n  proto. This may be useful for debugging purposes, but it has no effect on the\n  output. If not `None`, `example_name` must be a scalar.\n\n  Args:\n    serialized: A vector (1-D Tensor) of type string containing binary\n      serialized `SequenceExample` protos.\n    context_features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` or `RaggedFeature` values. These features are associated\n      with a `SequenceExample` as a whole.\n    sequence_features: A `dict` mapping feature keys to\n      `FixedLenSequenceFeature` or `VarLenFeature` or `RaggedFeature` values.\n      These features are associated with data within the `FeatureList` section\n      of the `SequenceExample` proto.\n    example_names: A vector (1-D Tensor) of strings (optional), the name of the\n      serialized protos.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of three `dict`s, each mapping keys to `Tensor`s,\n    `SparseTensor`s, and `RaggedTensor`. The first dict contains the context\n    key/values, the second dict contains the feature_list key/values, and the\n    final dict contains the lengths of any dense feature_list features.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  if not (context_features or sequence_features):\n    raise ValueError(\"Missing features.\")\n  context_params = _ParseOpParams.from_features(\n      context_features, [VarLenFeature, FixedLenFeature, RaggedFeature])\n  feature_list_params = _ParseOpParams.from_features(\n      sequence_features,\n      [VarLenFeature, FixedLenSequenceFeature, RaggedFeature])\n\n  with ops.name_scope(name, \"ParseSequenceExample\",\n                      [serialized, example_names]):\n    outputs = _parse_sequence_example_raw(serialized, example_names,\n                                          context_params, feature_list_params,\n                                          name)\n    context_output, feature_list_output, feature_list_lengths = outputs\n\n    if context_params.ragged_keys:\n      context_output = _construct_tensors_for_composite_features(\n          context_features, context_output)\n    if feature_list_params.ragged_keys:\n      feature_list_output = _construct_tensors_for_composite_features(\n          sequence_features, feature_list_output)\n\n    return context_output, feature_list_output, feature_list_lengths\n\n\ndef _parse_sequence_example_raw(serialized,\n                                debug_name,\n                                context,\n                                feature_list,\n                                name=None):\n  \"\"\"Parses a vector of `SequenceExample` protos.\n\n  Args:\n    serialized: A vector (1-D Tensor) of type string, containing binary\n      serialized `SequenceExample` protos.\n    debug_name: A vector (1-D Tensor) of strings (optional), the names of the\n      serialized protos.\n    context: A `ParseOpParams` containing the parameters for the parse\n      op for the context features.\n    feature_list: A `ParseOpParams` containing the parameters for the\n      parse op for the feature_list features.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of three `dict`s, each mapping keys to `Tensor`s, `SparseTensor`s,\n    and `RaggedTensor`s. The first dict contains the context key/values, the\n    second dict contains the feature_list key/values, and the final dict\n    contains the lengths of any dense feature_list features.\n\n  Raises:\n    TypeError: if feature_list.dense_defaults is not either None or a dict.\n  \"\"\"\n  if context.num_features + feature_list.num_features == 0:\n    raise ValueError(\"Must provide at least one feature key\")\n  with ops.name_scope(name, \"ParseSequenceExample\", [serialized]):\n    debug_name = [] if debug_name is None else debug_name\n\n    # Internal\n    feature_list_dense_missing_assumed_empty = []\n    for k, v in feature_list.dense_defaults.items():\n      if v is not None:\n        raise ValueError(\"Value feature_list.dense_defaults[%s] must be None\" %\n                         k)\n      feature_list_dense_missing_assumed_empty.append(k)\n\n    has_ragged = context.ragged_keys or feature_list.ragged_keys\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    if has_ragged and serialized.shape.ndims is None:\n      raise ValueError(\"serialized must have statically-known rank to \"\n                       \"parse ragged features.\")\n    feature_list_dense_missing_assumed_empty_vector = [\n        key in feature_list_dense_missing_assumed_empty\n        for key in feature_list.dense_keys\n    ]\n    outputs = gen_parsing_ops.parse_sequence_example_v2(\n        # Inputs\n        serialized=serialized,\n        debug_name=debug_name,\n        context_sparse_keys=context.sparse_keys,\n        context_dense_keys=context.dense_keys,\n        context_ragged_keys=context.ragged_keys,\n        feature_list_sparse_keys=feature_list.sparse_keys,\n        feature_list_dense_keys=feature_list.dense_keys,\n        feature_list_ragged_keys=feature_list.ragged_keys,\n        feature_list_dense_missing_assumed_empty=(\n            feature_list_dense_missing_assumed_empty_vector),\n        context_dense_defaults=context.dense_defaults_vec,\n        # Attrs\n        Ncontext_sparse=len(context.sparse_keys),\n        Nfeature_list_sparse=len(feature_list.sparse_keys),\n        Nfeature_list_dense=len(feature_list.dense_keys),\n        context_sparse_types=context.sparse_types,\n        context_ragged_value_types=context.ragged_value_types,\n        context_ragged_split_types=context.ragged_split_types,\n        feature_list_dense_types=feature_list.dense_types,\n        feature_list_sparse_types=feature_list.sparse_types,\n        feature_list_ragged_value_types=feature_list.ragged_value_types,\n        feature_list_ragged_split_types=feature_list.ragged_split_types,\n        context_dense_shapes=context.dense_shapes_as_proto,\n        feature_list_dense_shapes=feature_list.dense_shapes,\n        name=name)\n    (context_sparse_indices, context_sparse_values, context_sparse_shapes,\n     context_dense_values, context_ragged_values, context_ragged_row_splits,\n     feature_list_sparse_indices, feature_list_sparse_values,\n     feature_list_sparse_shapes, feature_list_dense_values,\n     feature_list_dense_lengths, feature_list_ragged_values,\n     feature_list_ragged_outer_splits,\n     feature_list_ragged_inner_splits) = outputs\n    # pylint: disable=protected-access\n    context_ragged_tensors = parsing_config._build_ragged_tensors(\n        serialized.shape, context_ragged_values, context_ragged_row_splits)\n    feature_list_ragged_tensors = parsing_config._build_ragged_tensors(\n        serialized.shape, feature_list_ragged_values,\n        feature_list_ragged_outer_splits, feature_list_ragged_inner_splits)\n\n    # pylint: disable=g-complex-comprehension\n    context_sparse_tensors = [\n        sparse_tensor.SparseTensor(ix, val, shape)\n        for (ix, val,\n             shape) in zip(context_sparse_indices, context_sparse_values,\n                           context_sparse_shapes)\n    ]\n\n    feature_list_sparse_tensors = [\n        sparse_tensor.SparseTensor(ix, val, shape)\n        for (ix, val, shape\n            ) in zip(feature_list_sparse_indices, feature_list_sparse_values,\n                     feature_list_sparse_shapes)\n    ]\n    # pylint: enable=g-complex-comprehension\n\n    context_output = dict(\n        zip(\n            context.sparse_keys + context.dense_keys + context.ragged_keys,\n            context_sparse_tensors + context_dense_values +\n            context_ragged_tensors))\n    feature_list_output = dict(\n        zip(\n            feature_list.sparse_keys + feature_list.dense_keys +\n            feature_list.ragged_keys, feature_list_sparse_tensors +\n            feature_list_dense_values + feature_list_ragged_tensors))\n    feature_list_lengths = dict(\n        zip(feature_list.dense_keys, feature_list_dense_lengths))\n\n    return (context_output, feature_list_output, feature_list_lengths)\n\n\n@tf_export(\"io.parse_single_sequence_example\",\n           v1=[\"io.parse_single_sequence_example\",\n               \"parse_single_sequence_example\"])\n@dispatch.add_dispatch_support\ndef parse_single_sequence_example(\n    serialized, context_features=None, sequence_features=None,\n    example_name=None, name=None):\n  # pylint: disable=line-too-long\n  \"\"\"Parses a single `SequenceExample` proto.\n\n  Parses a single serialized [`SequenceExample`](https://www.tensorflow.org/code/tensorflow/core/example/example.proto)\n  proto given in `serialized`.\n\n  This op parses a serialized sequence example into a tuple of dictionaries,\n  each mapping keys to `Tensor` and `SparseTensor` objects.\n  The first dictionary contains mappings for keys appearing in\n  `context_features`, and the second dictionary contains mappings for keys\n  appearing in `sequence_features`.\n\n  At least one of `context_features` and `sequence_features` must be provided\n  and non-empty.\n\n  The `context_features` keys are associated with a `SequenceExample` as a\n  whole, independent of time / frame.  In contrast, the `sequence_features` keys\n  provide a way to access variable-length data within the `FeatureList` section\n  of the `SequenceExample` proto.  While the shapes of `context_features` values\n  are fixed with respect to frame, the frame dimension (the first dimension)\n  of `sequence_features` values may vary between `SequenceExample` protos,\n  and even between `feature_list` keys within the same `SequenceExample`.\n\n  `context_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenFeature` objects. Each `VarLenFeature` is mapped to a `SparseTensor`;\n  each `RaggedFeature` is mapped to a `RaggedTensor`; and each `FixedLenFeature`\n  is mapped to a `Tensor`, of the specified type, shape, and default value.\n\n  `sequence_features` contains `VarLenFeature`, `RaggedFeature`, and\n  `FixedLenSequenceFeature` objects. Each `VarLenFeature` is mapped to a\n  `SparseTensor`; each `RaggedFeature` is mapped to a `RaggedTensor`; and each\n  `FixedLenSequenceFeature` is mapped to a `Tensor`, each of the specified type.\n  The shape will be `(T,) + df.dense_shape` for `FixedLenSequenceFeature` `df`,\n  where `T` is the length of the associated `FeatureList` in the\n  `SequenceExample`. For instance, `FixedLenSequenceFeature([])` yields a scalar\n  1-D `Tensor` of static shape `[None]` and dynamic shape `[T]`, while\n  `FixedLenSequenceFeature([k])` (for `int k >= 1`) yields a 2-D matrix `Tensor`\n  of static shape `[None, k]` and dynamic shape `[T, k]`.\n\n  Each `SparseTensor` corresponding to `sequence_features` represents a ragged\n  vector.  Its indices are `[time, index]`, where `time` is the `FeatureList`\n  entry and `index` is the value's index in the list of values associated with\n  that time.\n\n  `FixedLenFeature` entries with a `default_value` and `FixedLenSequenceFeature`\n  entries with `allow_missing=True` are optional; otherwise, we will fail if\n  that `Feature` or `FeatureList` is missing from any example in `serialized`.\n\n  `example_name` may contain a descriptive name for the corresponding serialized\n  proto. This may be useful for debugging purposes, but it has no effect on the\n  output. If not `None`, `example_name` must be a scalar.\n\n  Note that the batch version of this function, `tf.parse_sequence_example`,\n  is written for better memory efficiency and will be faster on large\n  `SequenceExample`s.\n\n  Args:\n    serialized: A scalar (0-D Tensor) of type string, a single binary\n      serialized `SequenceExample` proto.\n    context_features: A `dict` mapping feature keys to `FixedLenFeature` or\n      `VarLenFeature` or `RaggedFeature` values. These features are associated\n      with a `SequenceExample` as a whole.\n    sequence_features: A `dict` mapping feature keys to\n      `FixedLenSequenceFeature` or `VarLenFeature` or `RaggedFeature` values.\n      These features are associated with data within the `FeatureList` section\n      of the `SequenceExample` proto.\n    example_name: A scalar (0-D Tensor) of strings (optional), the name of\n      the serialized proto.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of two `dict`s, each mapping keys to `Tensor`s and `SparseTensor`s\n    and `RaggedTensor`s.\n\n    * The first dict contains the context key/values.\n    * The second dict contains the feature_list key/values.\n\n  Raises:\n    ValueError: if any feature is invalid.\n  \"\"\"\n  # pylint: enable=line-too-long\n  if not (context_features or sequence_features):\n    raise ValueError(\"Missing features.\")\n  context_params = _ParseOpParams.from_features(\n      context_features, [VarLenFeature, FixedLenFeature, RaggedFeature])\n  feature_list_params = _ParseOpParams.from_features(\n      sequence_features,\n      [VarLenFeature, FixedLenSequenceFeature, RaggedFeature])\n\n  with ops.name_scope(name, \"ParseSingleSequenceExample\",\n                      [serialized, example_name]):\n    context_output, feature_list_output = (\n        _parse_single_sequence_example_raw(serialized, context_params,\n                                           feature_list_params, example_name,\n                                           name))\n\n    if context_params.ragged_keys:\n      context_output = _construct_tensors_for_composite_features(\n          context_features, context_output)\n    if feature_list_params.ragged_keys:\n      feature_list_output = _construct_tensors_for_composite_features(\n          sequence_features, feature_list_output)\n\n    return context_output, feature_list_output\n\n\ndef _parse_single_sequence_example_raw(serialized,\n                                       context,\n                                       feature_list,\n                                       debug_name,\n                                       name=None):\n  \"\"\"Parses a single `SequenceExample` proto.\n\n  Args:\n    serialized: A scalar (0-D Tensor) of type string, a single binary serialized\n      `SequenceExample` proto.\n    context: A `ParseOpParams` containing the parameters for the parse op for\n      the context features.\n    feature_list: A `ParseOpParams` containing the parameters for the parse op\n      for the feature_list features.\n    debug_name: A scalar (0-D Tensor) of strings (optional), the name of the\n      serialized proto.\n    name: A name for this operation (optional).\n\n  Returns:\n    A tuple of two `dict`s, each mapping keys to `Tensor`s and `SparseTensor`s.\n    The first dict contains the context key/values.\n    The second dict contains the feature_list key/values.\n\n  Raises:\n    TypeError: if feature_list.dense_defaults is not either None or a dict.\n  \"\"\"\n  with ops.name_scope(name, \"ParseSingleExample\", [serialized, debug_name]):\n    serialized = ops.convert_to_tensor(serialized, name=\"serialized\")\n    serialized = _assert_scalar(serialized, \"serialized\")\n  return _parse_sequence_example_raw(serialized, debug_name, context,\n                                     feature_list, name)[:2]\n\n\n@tf_export(\"io.decode_raw\", v1=[])\n@dispatch.add_dispatch_support\ndef decode_raw(input_bytes,\n               out_type,\n               little_endian=True,\n               fixed_length=None,\n               name=None):\n  r\"\"\"Convert raw bytes from input tensor into numeric tensors.\n\n  Every component of the input tensor is interpreted as a sequence of bytes.\n  These bytes are then decoded as numbers in the format specified by `out_type`.\n\n  >>> tf.io.decode_raw(tf.constant(\"1\"), tf.uint8)\n  <tf.Tensor: shape=(1,), dtype=uint8, numpy=array([49], dtype=uint8)>\n  >>> tf.io.decode_raw(tf.constant(\"1,2\"), tf.uint8)\n  <tf.Tensor: shape=(3,), dtype=uint8, numpy=array([49, 44, 50], dtype=uint8)>\n\n  Note that the rank of the output tensor is always one more than the input one:\n\n  >>> tf.io.decode_raw(tf.constant([\"1\",\"2\"]), tf.uint8).shape\n  TensorShape([2, 1])\n  >>> tf.io.decode_raw(tf.constant([[\"1\"],[\"2\"]]), tf.uint8).shape\n  TensorShape([2, 1, 1])\n\n  This is because each byte in the input is converted to a new value on the\n  output (if output type is `uint8` or `int8`, otherwise chunks of inputs get\n  coverted to a new value):\n\n  >>> tf.io.decode_raw(tf.constant(\"123\"), tf.uint8)\n  <tf.Tensor: shape=(3,), dtype=uint8, numpy=array([49, 50, 51], dtype=uint8)>\n  >>> tf.io.decode_raw(tf.constant(\"1234\"), tf.uint8)\n  <tf.Tensor: shape=(4,), dtype=uint8, numpy=array([49, 50, 51, 52], ...\n  >>> # chuncked output\n  >>> tf.io.decode_raw(tf.constant(\"12\"), tf.uint16)\n  <tf.Tensor: shape=(1,), dtype=uint16, numpy=array([12849], dtype=uint16)>\n  >>> tf.io.decode_raw(tf.constant(\"1234\"), tf.uint16)\n  <tf.Tensor: shape=(2,), dtype=uint16, numpy=array([12849, 13363], ...\n  >>> # int64 output\n  >>> tf.io.decode_raw(tf.constant(\"12345678\"), tf.int64)\n  <tf.Tensor: ... numpy=array([4050765991979987505])>\n  >>> tf.io.decode_raw(tf.constant(\"1234567887654321\"), tf.int64)\n  <tf.Tensor: ... numpy=array([4050765991979987505, 3544952156018063160])>\n\n  The operation allows specifying endianness via the `little_endian` parameter.\n\n  >>> tf.io.decode_raw(tf.constant(\"\\x0a\\x0b\"), tf.int16)\n  <tf.Tensor: shape=(1,), dtype=int16, numpy=array([2826], dtype=int16)>\n  >>> hex(2826)\n  '0xb0a'\n  >>> tf.io.decode_raw(tf.constant(\"\\x0a\\x0b\"), tf.int16, little_endian=False)\n  <tf.Tensor: shape=(1,), dtype=int16, numpy=array([2571], dtype=int16)>\n  >>> hex(2571)\n  '0xa0b'\n\n  If the elements of `input_bytes` are of different length, you must specify\n  `fixed_length`:\n\n  >>> tf.io.decode_raw(tf.constant([[\"1\"],[\"23\"]]), tf.uint8, fixed_length=4)\n  <tf.Tensor: shape=(2, 1, 4), dtype=uint8, numpy=\n  array([[[49,  0,  0,  0]],\n         [[50, 51,  0,  0]]], dtype=uint8)>\n\n  If the `fixed_length` value is larger that the length of the `out_type` dtype,\n  multiple values are generated:\n\n  >>> tf.io.decode_raw(tf.constant([\"1212\"]), tf.uint16, fixed_length=4)\n  <tf.Tensor: shape=(1, 2), dtype=uint16, numpy=array([[12849, 12849]], ...\n\n  If the input value is larger than `fixed_length`, it is truncated:\n\n  >>> x=''.join([chr(1), chr(2), chr(3), chr(4)])\n  >>> tf.io.decode_raw(x, tf.uint16, fixed_length=2)\n  <tf.Tensor: shape=(1,), dtype=uint16, numpy=array([513], dtype=uint16)>\n  >>> hex(513)\n  '0x201'\n\n  If `little_endian` and `fixed_length` are specified, truncation to the fixed\n  length occurs before endianness conversion:\n\n  >>> x=''.join([chr(1), chr(2), chr(3), chr(4)])\n  >>> tf.io.decode_raw(x, tf.uint16, fixed_length=2, little_endian=False)\n  <tf.Tensor: shape=(1,), dtype=uint16, numpy=array([258], dtype=uint16)>\n  >>> hex(258)\n  '0x102'\n\n  If input values all have the same length, then specifying `fixed_length`\n  equal to the size of the strings should not change output:\n\n  >>> x = [\"12345678\", \"87654321\"]\n  >>> tf.io.decode_raw(x, tf.int16)\n  <tf.Tensor: shape=(2, 4), dtype=int16, numpy=\n  array([[12849, 13363, 13877, 14391],\n         [14136, 13622, 13108, 12594]], dtype=int16)>\n  >>> tf.io.decode_raw(x, tf.int16, fixed_length=len(x[0]))\n  <tf.Tensor: shape=(2, 4), dtype=int16, numpy=\n  array([[12849, 13363, 13877, 14391],\n         [14136, 13622, 13108, 12594]], dtype=int16)>\n\n  Args:\n    input_bytes:\n      Each element of the input Tensor is converted to an array of bytes.\n\n      Currently, this must be a tensor of strings (bytes), although semantically\n      the operation should support any input.\n    out_type:\n      `DType` of the output. Acceptable types are `half`, `float`, `double`,\n      `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`.\n    little_endian:\n      Whether the `input_bytes` data is in little-endian format. Data will be\n      converted into host byte order if necessary.\n    fixed_length:\n      If set, the first `fixed_length` bytes of each element will be converted.\n      Data will be zero-padded or truncated to the specified length.\n\n      `fixed_length` must be a multiple of the size of `out_type`.\n\n      `fixed_length` must be specified if the elements of `input_bytes` are of\n      variable length.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` object storing the decoded bytes.\n  \"\"\"\n  if fixed_length is not None:\n    return gen_parsing_ops.decode_padded_raw(\n        input_bytes,\n        fixed_length=fixed_length,\n        out_type=out_type,\n        little_endian=little_endian,\n        name=name)\n  else:\n    return gen_parsing_ops.decode_raw(\n        input_bytes, out_type, little_endian=little_endian, name=name)\n\n\n@tf_export(v1=[\"decode_raw\", \"io.decode_raw\"])\n@dispatch.add_dispatch_support\n@deprecation.deprecated_args(None,\n                             \"bytes is deprecated, use input_bytes instead\",\n                             \"bytes\")\ndef decode_raw_v1(\n    input_bytes=None,\n    out_type=None,\n    little_endian=True,\n    name=None,\n    bytes=None  # pylint: disable=redefined-builtin\n):\n  \"\"\"Convert raw byte strings into tensors.\n\n  Args:\n    input_bytes:\n      Each element of the input Tensor is converted to an array of bytes.\n    out_type:\n      `DType` of the output. Acceptable types are `half`, `float`, `double`,\n      `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`.\n    little_endian:\n      Whether the `input_bytes` data is in little-endian format. Data will be\n      converted into host byte order if necessary.\n    name: A name for the operation (optional).\n    bytes: Deprecated parameter. Use `input_bytes` instead.\n\n  Returns:\n    A `Tensor` object storing the decoded bytes.\n  \"\"\"\n  input_bytes = deprecation.deprecated_argument_lookup(\"input_bytes\",\n                                                       input_bytes, \"bytes\",\n                                                       bytes)\n\n  # out_type is a required positional argument in the original API, and had to\n  # be changed to a keyword argument in order to facilitate the transition from\n  # the reserved named `bytes` to `input_bytes`. Ensure it's still set.\n  if out_type is None:\n    raise ValueError(\n        \"decode_raw_v1() missing 1 positional argument: 'out_type'\")\n\n  return gen_parsing_ops.decode_raw(\n      input_bytes, out_type, little_endian=little_endian, name=name)\n\n\n# Swap `name` and `na_value` for backward compatibility.\n@tf_export(v1=[\"io.decode_csv\", \"decode_csv\"])\n@dispatch.add_dispatch_support\n@deprecation.deprecated_endpoints(\"decode_csv\")\ndef decode_csv(records,\n               record_defaults,\n               field_delim=\",\",\n               use_quote_delim=True,\n               name=None,\n               na_value=\"\",\n               select_cols=None):\n  \"\"\"Convert CSV records to tensors. Each column maps to one tensor.\n\n  RFC 4180 format is expected for the CSV records.\n  (https://tools.ietf.org/html/rfc4180)\n  Note that we allow leading and trailing spaces with int or float field.\n\n  Args:\n    records: A `Tensor` of type `string`.\n      Each string is a record/row in the csv and all records should have\n      the same format.\n    record_defaults: A list of `Tensor` objects with specific types.\n      Acceptable types are `float32`, `float64`, `int32`, `int64`, `string`.\n      One tensor per column of the input record, with either a\n      scalar default value for that column or an empty vector if the column is\n      required.\n    field_delim: An optional `string`. Defaults to `\",\"`.\n      char delimiter to separate fields in a record.\n    use_quote_delim: An optional `bool`. Defaults to `True`.\n      If false, treats double quotation marks as regular\n      characters inside of the string fields (ignoring RFC 4180, Section 2,\n      Bullet 5).\n    name: A name for the operation (optional).\n    na_value: Additional string to recognize as NA/NaN.\n    select_cols: Optional sorted list of column indices to select. If specified,\n      only this subset of columns will be parsed and returned.\n\n  Returns:\n    A list of `Tensor` objects. Has the same type as `record_defaults`.\n    Each tensor will have the same shape as records.\n\n  Raises:\n    ValueError: If any of the arguments is malformed.\n  \"\"\"\n  return decode_csv_v2(\n      records, record_defaults,\n      field_delim, use_quote_delim,\n      na_value, select_cols, name\n      )\n\n\n@tf_export(\"io.decode_csv\", v1=[])\n@dispatch.add_dispatch_support\ndef decode_csv_v2(records,\n                  record_defaults,\n                  field_delim=\",\",\n                  use_quote_delim=True,\n                  na_value=\"\",\n                  select_cols=None,\n                  name=None):\n  \"\"\"Convert CSV records to tensors. Each column maps to one tensor.\n\n  RFC 4180 format is expected for the CSV records.\n  (https://tools.ietf.org/html/rfc4180)\n  Note that we allow leading and trailing spaces with int or float field.\n\n  Args:\n    records: A `Tensor` of type `string`.\n      Each string is a record/row in the csv and all records should have\n      the same format.\n    record_defaults: A list of `Tensor` objects with specific types.\n      Acceptable types are `float32`, `float64`, `int32`, `int64`, `string`.\n      One tensor per column of the input record, with either a\n      scalar default value for that column or an empty vector if the column is\n      required.\n    field_delim: An optional `string`. Defaults to `\",\"`.\n      char delimiter to separate fields in a record.\n    use_quote_delim: An optional `bool`. Defaults to `True`.\n      If false, treats double quotation marks as regular\n      characters inside of the string fields (ignoring RFC 4180, Section 2,\n      Bullet 5).\n    na_value: Additional string to recognize as NA/NaN.\n    select_cols: Optional sorted list of column indices to select. If specified,\n      only this subset of columns will be parsed and returned.\n    name: A name for the operation (optional).\n\n  Returns:\n    A list of `Tensor` objects. Has the same type as `record_defaults`.\n    Each tensor will have the same shape as records.\n\n  Raises:\n    ValueError: If any of the arguments is malformed.\n  \"\"\"\n  if select_cols is not None and any(select_cols[i] >= select_cols[i + 1]\n                                     for i in range(len(select_cols) - 1)):\n    raise ValueError(\"select_cols is not strictly increasing.\")\n  if select_cols is not None and select_cols[0] < 0:\n    raise ValueError(\"select_cols contains negative values.\")\n  if select_cols is not None and len(select_cols) != len(record_defaults):\n    raise ValueError(\"Length of select_cols and record_defaults do not match.\")\n  return gen_parsing_ops.decode_csv(\n      records=records,\n      record_defaults=record_defaults,\n      field_delim=field_delim,\n      use_quote_delim=use_quote_delim,\n      na_value=na_value,\n      name=name,\n      select_cols=select_cols,\n  )\n\n\ndef _assert_scalar(value, name):\n  \"\"\"Asserts that `value` is scalar, and returns `value`.\"\"\"\n  value_rank = value.shape.rank\n  if value_rank is None:\n    check = control_flow_ops.Assert(\n        math_ops.equal(array_ops.rank(value), 0),\n        [\"Input %s must be a scalar\" % name],\n        name=\"%sIsScalar\" % name.capitalize())\n    result = control_flow_ops.with_dependencies([check],\n                                                value,\n                                                name=\"%sDependencies\" % name)\n    result.set_shape([])\n    return result\n  elif value_rank == 0:\n    return value\n  else:\n    raise ValueError(\"Input %s must be a scalar\" % name)\n\n\n@tf_export(\"io.decode_json_example\",\n           v1=[\"decode_json_example\", \"io.decode_json_example\"])\ndef decode_json_example(json_examples, name=None):\n  r\"\"\"Convert JSON-encoded Example records to binary protocol buffer strings.\n\n  Note: This is **not** a general purpose JSON parsing op.\n\n  This op converts JSON-serialized `tf.train.Example` (maybe created with\n  `json_format.MessageToJson`, following the\n  [standard JSON mapping](\n  https://developers.google.com/protocol-buffers/docs/proto3#json))\n  to a binary-serialized `tf.train.Example` (equivalent to\n  `Example.SerializeToString()`) suitable for conversion to tensors with\n  `tf.io.parse_example`.\n\n  Here is a `tf.train.Example` proto:\n\n  >>> example = tf.train.Example(\n  ...   features=tf.train.Features(\n  ...       feature={\n  ...           \"a\": tf.train.Feature(\n  ...               int64_list=tf.train.Int64List(\n  ...                   value=[1, 1, 3]))}))\n\n  Here it is converted to JSON:\n\n  >>> from google.protobuf import json_format\n  >>> example_json = json_format.MessageToJson(example)\n  >>> print(example_json)\n  {\n    \"features\": {\n      \"feature\": {\n        \"a\": {\n          \"int64List\": {\n            \"value\": [\n              \"1\",\n              \"1\",\n              \"3\"\n            ]\n          }\n        }\n      }\n    }\n  }\n\n  This op converts the above json string to a binary proto:\n\n  >>> example_binary = tf.io.decode_json_example(example_json)\n  >>> example_binary.numpy()\n  b'\\n\\x0f\\n\\r\\n\\x01a\\x12\\x08\\x1a\\x06\\x08\\x01\\x08\\x01\\x08\\x03'\n\n  The OP works on string tensors of andy shape:\n\n  >>> tf.io.decode_json_example([\n  ...     [example_json, example_json],\n  ...     [example_json, example_json]]).shape.as_list()\n  [2, 2]\n\n  This resulting binary-string is equivalent to `Example.SerializeToString()`,\n  and can be converted to Tensors using `tf.io.parse_example` and related\n  functions:\n\n  >>> tf.io.parse_example(\n  ...   serialized=[example_binary.numpy(),\n  ...              example.SerializeToString()],\n  ...   features = {'a': tf.io.FixedLenFeature(shape=[3], dtype=tf.int64)})\n  {'a': <tf.Tensor: shape=(2, 3), dtype=int64, numpy=\n   array([[1, 1, 3],\n          [1, 1, 3]])>}\n\n  Args:\n    json_examples: A string tensor containing json-serialized `tf.Example`\n      protos.\n    name: A name for the op.\n\n  Returns:\n    A string Tensor containing the binary-serialized `tf.Example` protos.\n\n  Raises:\n     `tf.errors.InvalidArgumentError`: If the JSON could not be converted to a\n     `tf.Example`\n  \"\"\"\n  return gen_parsing_ops.decode_json_example(json_examples, name=name)\n"], "buggy_code_start_loc": [21, 853], "buggy_code_end_loc": [109, 928], "fixing_code_start_loc": [22, 853], "fixing_code_end_loc": [112, 941], "type": "CWE-787", "message": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29614", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:16.080", "lastModified": "2022-04-25T20:09:40.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;La implementaci\u00f3n de \"tf.io.decode_raw\" produce resultados incorrectos y bloquea el int\u00e9rprete de Python al combinar \"fixed_length\" y tipos de datos m\u00e1s amplios.&#xa0;La implementaci\u00f3n de la versi\u00f3n acolchada (https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) presenta errores debido a una confusi\u00f3n acerca de las reglas aritm\u00e9ticas de punteros.&#xa0;Primero, el c\u00f3digo calcula (https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) el ancho de cada elemento de salida dividiendo el valor de la longitud fija del tipo argumento.&#xa0;El argumento \"fixed_length\" tambi\u00e9n es usado para determinar el tama\u00f1o necesario para el tensor de salida (https: //github.&#xa0;com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79).&#xa0;A continuaci\u00f3n, se vuelve a codificar el c\u00f3digo (https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94).&#xa0;El c\u00f3digo err\u00f3neo es la \u00faltima l\u00ednea de arriba: est\u00e1 moviendo el puntero \"out_data\" en bytes de \"fixed_length * sizeof(T)\" mientras que s\u00f3lo copi\u00f3 como m\u00e1ximo los bytes de \"fixed_length\" de la entrada.&#xa0;Esto resulta en que partes de la entrada no se descodifiquen en una salida.&#xa0;Adem\u00e1s, debido a que el avance del puntero es mucho m\u00e1s amplio de lo deseado, esto conlleva r\u00e1pidamente a escribir fuera de l\u00edmites de los datos de respaldo.&#xa0;Esta escritura OOB provoca un bloqueo del int\u00e9rprete en el reproductor mencionado aqu\u00ed, pero tambi\u00e9n puede ser montar ataques m\u00e1s severos,&#xa0;dado que este gadget permite escribir en ubicaciones colocadas peri\u00f3dicamente en una memoria.&#xa0;La correcci\u00f3n ser\u00e1 inclu\u00edda en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango compatible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/698e01511f62a3c185754db78ebce0eee1f0184d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-8pmx-p244-g88h", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/698e01511f62a3c185754db78ebce0eee1f0184d"}}